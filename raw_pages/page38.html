<!DOCTYPE HTML>
<html lang="en">
<head>

    
<script async src="https://www.googletagmanager.com/gtag/js?id=G-7SYLWGZYJ2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-7SYLWGZYJ2');
</script>

<title>Browse (39) - Shadertoy BETA</title>
<meta charset="utf-8" />
<meta name="Keywords" content="shadertoy, shader toy, quilez, inigo, jeremias, pol, fractals, demoscene, computer graphics, mathematics, rendering, demo, 3D, realtime, shader, raytracing, raymarching, webgl, glsl" />
<meta name="Description" content="Build shaders, share them, and learn from the best community." />
<meta name="Author" content="Beautypi" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<link rel="image_src" href="https://www.shadertoy.com/img/logo.png" />
<link rel="apple-touch-icon" href="/img/launch_icon_57.png"/>
<link rel="apple-touch-icon" sizes="72x72" href="/img/launch_icon_72.png"/>
<link rel="apple-touch-icon" sizes="114x114" href="/img/launch_icon_114.png"/>
<link rel="shortcut icon" href="/img/favicon.ico"/>

<style>::-webkit-scrollbar {
    height: 8px;
    width: 8px;
    background: #404040;
}

::-webkit-scrollbar-thumb
{
    background: #909090;
    border-radius: 0ex;
}

::-webkit-scrollbar-corner
{
    background: #000;
}

::-webkit-input-placeholder
{
	font-style:italic;
}
input:-moz-placeholder, textarea:-moz-placeholder
{
	font-style:italic;
}
input.placeholder-text, textarea.placeholder-text
{
	font-style:italic;
}

pre 
{
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
    white-space: -pre-wrap;
    white-space: -o-pre-wrap;
    word-wrap: break-word;
}

@font-face
{
    font-family: Lobster;
    src: url("/img/lobster.otf") format("opentype");
}

div#centerScreen
{
    left: 50%;
    top: 50%;
    position: absolute;
}

a.headerLinks:hover
{
    background-color:#505050;
    color : #ff8020;
}

body
{
    color: #000000;
    font-size:12px;
    font-style:normal;
    font-family:Tahoma,Arial;
    background-repeat: no-repeat;
    //background-attachment: fixed;
    padding:0px;
    margin:0px;
    text-align: left;
    background-color: #d0d0d0;
    background-repeat: repeat;
    user-select: text;
}

a,
a:hover,
a:visited
{
  color : inherit;
}

div#content {
    width: 95%;
    overflow: hidden;
    margin: auto;
    padding: 0px;
    min-height: calc(100vh - 80px);
    //box-sizing: border-box;
}


.notificationCount
{
 background-color:#ff0000;
 padding-left:3px;
 padding-right:1px;
 padding-top:1px;
 padding-bottom:1px;
}

div#header
{
    background-color: #404040;
    top: 0px;
    left: 0px;
    width: 100%;
    padding: 0;
    margin: 0;
    color: #ffffff;
    display: flex;
    flex-direction:row;
}

#headerBlock1
{
    width: 50%;
    display:flex;
    align-items:center;
}

a#headerTitle
{
    font-size: 2.25em;
    font-family: Lobster,Tahoma,Arial;
    text-decoration: none;
    padding-left:32px;
    padding-right:32px;
}

#headerSearch
{
    display: inline-block;
    color: #000000;
    width: 300px;
}

input[type=search]#mySearch
{
    width: 100%;
    border-radius: 6px;
    border: 1px solid black;
    padding:12px;
}

#headerBlock2
{
    width: 50%;
    margin-left: auto;
    display: flex;
    justify-content: flex-end;
}


a#headerTitle:hover
{
    color : #ff8020;
}

a.headerLinks
{
    font-weight: bold;
    padding-top: 14px;
    padding-bottom: 14px;
    padding-left: 14px;
    padding-right: 14px;
    margin:0px;
    text-decoration: none;
    transition: background-color 0.15s linear, color 0.15s linear;
}

#footer
{
    background-color: rgba(64,64,64,0.25);
    color: #000000;
    padding: 0px;
    margin: 0px;
    width: 100%;
    display: flex;
    justify-content: space-between;
    flex-wrap: wrap;
}

#footer div
{
    padding-top:10px;
    padding-bottom:0px;
    padding-left:16px;
    padding-right:16px;
}

#footer div ul
{
    margin-left:0px;
    padding-left:16px;
}

#footer div ul li
{
    padding-top:6px;
}

a.regular
{
    font-weight:bold;
    text-decoration:none
}

a.regular:hover
{
  color : #ff8020;
}

a.user
{
    font-weight:bold;
    text-decoration:none;
}

a.user:hover
{
  color : #ff8020;
  text-decoration: underline;
}

.uiButton
{
    border: none;
    outline: none;
    margin: 0px;
    padding: 0px;
    width: 22px;
    height: 22px;
    position: absolute;
    cursor: pointer;
    border-radius: 4px;
}

.uiButton:hover
{
    box-shadow: inset 0px 0px 1px 1px #808080, 0px 0px 1px 1px #808080;
}

.uiDivBUtton
{
    cursor:pointer;
}

.uiDivBUtton:hover
{
    color: #ffffff;
}


.dialog
{
    display: block;
    background-color: #e0e0e0;
    color: #000000;
    border:1px solid #000;
    padding:0px;
    margin:0px;
    text-align:left;
    border-radius: 4px;
    box-shadow:4px 4px 6px 0px rgba(0,0,0,0.5);
    overflow: hidden;
    z-index:1000;
    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;
}

.dialogHeader
{
    left:0px;
    top: 0px;
    width:100%;
    height:32px;
    position: absolute;
    background-color: #808080;
    cursor:move;
}

.dialogTitle
{
    left: 12px;
    top: 4px;
    position: absolute;
    padding: 0px;
    margin: 0px;
    color:#000000;
    font-size:1.5em;
    text-align: left;
    user-select: none;
    -moz-user-select: -moz-none;
    -webkit-user-select: none;
}

.dialogOverlay
{
    z-index:1000;

    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;

    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    width:100%;
    height:100%;
    position:absolute;

    background-color:rgba(0,0,0,.4);
}

.viewsIcon, .likesIcon
{
    border: none;
    outline: none;
    display:inline-block;
    background-repeat:no-repeat;
    top:0px;
    left:0px;
    padding:0px;
    padding-right: 2px;
    margin:0px;
    position:relative;
}

.userPictureSmall
{
    background-color:#808080;
    border: 1px solid #000000;
    width:32px;
    height:32px;
}

.dialogCloseButton
{
    right:8px;
    top: 4px;
    width:22px;
    height:22px;
    position: absolute;
    background-image: url("/img/close.png");
    cursor: pointer;
    border-radius: 4px;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContentButtons
{
     padding:0;
     border:0;
     text-align: justify;
     left: 24px;
     bottom:40px;
     position:absolute;
}

.dialogButton
{
    text-align: center;
    vertical-align: middle;
    display: inline-block;
    border-radius: 4px;
    font-weight: bold;
    cursor: pointer;
    padding-bottom:5px;
    padding-top:4px;
    padding-left: 8px;
    padding-right: 8px;
    margin-left:4px;
    margin-right:4px;
    text-decoration: none;
    color:#000000;
    width: 80px;
    -moz-transition:    background-color 0.15s linear, color 0.15s linear;
    -webkit-transition: background-color 0.15s linear, color 0.15s linear;
    transition:         background-color 0.15s linear, color 0.15s linear;
}

.dialogButton:hover
{
  background-color:#808080;
  color : #ff8020;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContent
{
    color: inherit;
    overflow: auto;
    width:100%;
    height:100%;
    left: 0px;
    top: 32px;
    position:absolute
}

.dialogContentBody
{
    color: inherit;
    width:100%;
    height:auto;
    padding-top:24px;
    padding-bottom:24px;
    padding-left:24px;
    padding-right:24px;
    text-align: left;
}

.formButton
{
    font-weight:bold;
	color:#ffffff;
	border:none;
    text-align:center;
	background-color:#808080;
    border-radius: 4px;
	padding-left:8px;
	padding-right:8px;
	padding-top:4px;
	padding-bottom:4px;
    cursor:pointer;
    min-width:80px;
    box-sizing: border-box;
}
.formInput {
    border-radius: 6px;
    border: 1px solid black;
    padding: 4px;
    border: none;
}
.formButton:hover {
    background-color: #e0e0e0;
}
.formButton:disabled
{
	color:#b0b0b0;
	background-color:#808080;
}

.formButtonSmall
{
    color:#ffffff;
    border:none;
    text-align:center;
    background-color:#808080;
    border-radius: 4px;
    padding-left:2px;
    padding-right:2px;
    padding-top:2px;
    padding-bottom:2px;
    cursor:pointer;
    min-width:40px;
}

.formButtonSmall:hover
{
    background-color: #e0e0e0;
}

.formButtonSmall:disabled
{
    color:#b0b0b0;
    background-color:#808080;
}

.formButtonSmall.disabled2,
.formButton.disabled2 { color:#b0b0b0; background-color:#808080; pointer-events: none; }

.inputForm
{
    padding-left:2%;
    padding-right:2%;
    resize: none;
    text-align: left;
    background-color:#e0e0e0;
    outline: none;
    border-radius: 4px;
    border: 1px solid #808080;
    color:inherit;
    box-sizing: border-box;
}

.inputForm:focus
{
    border: 1px solid #AFCDD8;
    background-color: #EBF2F4;
}

.transparentPannel
{
    background-color:rgba(64,64,64,0.1);
    padding:16px;
}

.comment, .commentSelf, .commentNew
{
    border-radius: 4px;
    width: 100%;
    margin-left: 0px;
    margin-right: 0px;
    margin-top: 0px;
    margin-bottom: 6px;

    padding: 14px;
    box-sizing: border-box;
    display: grid;
    grid-template-columns: 32px auto 8px;
    grid-template-rows: 1fr;
    grid-gap:8px;
}

.comment:nth-child(even)
{
    background-color: rgba(64,64,64,0.1);
}

.comment:nth-child(odd)
{
    background-color: rgba(128,128,128,0.1);
}

.commentSelf
{
    background-color: rgba(240,160,64,0.1);
}

.commentNew
{
    padding-right: 0px;
    grid-template-columns: 40px auto;
}

.commentContent
{
    vertical-align: top;
    text-align: left;
    word-break: break-all;
    word-break: break-word;
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
}


/* ----------------------- media resolutions ------------------------ */

@media screen and (max-width:799px)
{
    div#header {flex-direction:column; }
    #headerBlock1 { width:100%; }
    #headerBlock2 { width:100%; justify-content: space-around;}
    div#headerSearch {width:200px;}
    input#mySearch { width:200px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:10px; }
}

@media screen and (min-width:800px) and (max-width:1279px)
{
    body { font-size: 9px; }
    div#headerSearch {width: 250px;}
    input#mySearch { width:250px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:11px; }
}

@media screen and (min-width:1280px) and (max-width:1439px)
{
    body { font-size: 10px; }
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1440px) and (max-width:1919px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1920px) and (max-width:2559px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}

@media screen and (min-width:2560px) 
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}
body
{
    background-image: url("/img/themes/classic/background.jpg");
}
</style>

    <script>"use strict"

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piCamera
//
//==============================================================================

function piCamera()
{
    var mMatrix = setIdentity();
    var mMatrixInv = setIdentity();

    var mPosition = [0.0,0.0,0.0];
    var mXRotation = 0.0;
    var mYRotation = 0.0;

    var mPositionTarget = [0.0,0.0,0.0];
    var mXRotationTarget = 0.0;
    var mYRotationTarget = 0.0;

    var me = {};
/*
    me.Set = function( pos, dir, roll) 
             {
                 mMatrix    = setLookat( pos, add(pos,dir), [Math.sin(roll),Math.cos(roll),Math.sin(roll)] );
                 mMatrixInv = invertFast( mMatrix );
             };
*/
    me.SetPos = function(pos)
                {
                    mPosition = pos;
                    //mMatrix[ 3] = -(mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                    //mMatrix[ 7] = -(mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                    //mMatrix[11] = -(mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                };
/*
    me.GlobalMove = function(pos)
                    {
                        mMatrix[ 3] -= (mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                        mMatrix[ 7] -= (mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                        mMatrix[11] -= (mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                        mMatrixInv = invertFast(mMatrix);
                    };
*/
    me.LocalMove = function( dis )
                    {
                        dis = matMulvec( setRotationY(-mYRotation), dis);
                        mPositionTarget = sub(mPositionTarget,dis)
                    };

    me.RotateXY = function( x, y)
                  {
                    mXRotationTarget -= x;
                    mYRotationTarget -= y;
                    mXRotationTarget = Math.min( Math.max( mXRotationTarget, -Math.PI/2), Math.PI/2 );
                  };


    me.CameraExectue = function( dt )
    {
        // smooth position
        mXRotation += (mXRotationTarget-mXRotation) * 12.0*dt;
        mYRotation += (mYRotationTarget-mYRotation) * 12.0*dt;
        mPosition = add(mPosition, mul( sub(mPositionTarget, mPosition), 12.0*dt));

        // Make Camera matrix
        mMatrix = matMul( matMul(setRotationX(mXRotation), 
                                 setRotationY(mYRotation)),  
                                 setTranslation(mPosition));
        mMatrixInv = invertFast(mMatrix);

    }

    me.GetMatrix = function() { return mMatrix; };
    me.GetMatrixInverse = function() { return mMatrixInv; };
    me.SetMatrix = function( mat ) 
                    {
                        mMatrix = mat;
                        mMatrixInv = invertFast(mMatrix);

                        mPosition = getXYZ(matMulpoint(mat, [0.0,0.0,0.0]));
                        mPositionTarget = mPosition;
                    };

    me.GetPos = function() { return getXYZ(matMulpoint(mMatrixInv, [0.0,0.0,0.0])); }
    me.GetDir = function() { return getXYZ(normalize(matMulvec(mMatrixInv, [0.0,0.0,-1.0]))); }

    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piFile
//
//==============================================================================

function piFile( binaryDataArrayBuffer )
{
    // private
    //var mDataView = new DataView( binaryDataArrayBuffer, 0 );
    var mDataView = binaryDataArrayBuffer;
    var mOffset = 0;

    // public members
    var me = {};
    me.mDummy = 0;
/*
    // public functions
    me.Seek = function( off ) { mOffset = off - 3; };
    me.ReadUInt16 = function()  { var res = mDataView.getUint16( mOffset ); mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = mDataView.getUint32( mOffset ); mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = mDataView.getFloat32( mOffset ); mOffset+=4; return res; };
*/

    me.Seek = function( off ) { mOffset = off; };
    me.ReadUInt8  = function()  { var res = (new Uint8Array(mDataView,mOffset))[0]; mOffset+=1; return res; };
    me.ReadUInt16 = function()  { var res = (new Uint16Array(mDataView,mOffset))[0]; mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = (new Uint32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = (new Float32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadFloat32Array = function(n) 
                          { 
                              var src = new Float32Array(mDataView, mOffset);
                              var res = [];  for( var i=0; i<n; i++ ) { res[i] = src[i]; }
                              mOffset += 4*n;
                              return res;
                          };
    me.ReadFloat32ArrayNative = function(n) { var src = new Float32Array(mDataView, mOffset); mOffset += 4*n; return src; };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piMesh
//
//==============================================================================

function piMesh()
{
    this.mChunks = [];
    this.mPrimitiveType = 0;
    this.mVertexFormat = null;
}

/*
piMesh.prototype.normalize = function( ppos, npos )
{
    var numv = this.mVertexData.length;
    var numt = this.mIndices.length;

    for( var i=0; i<numv; i++ )
    {
        //float *v = (float*)piMesh_GetVertexData( me, i, npos );
        //v[0] = 0.0f;
        //v[1] = 0.0f;
        //v[2] = 0.0f;
        this.mVerts[8 * i + 3] = 0.0;
        this.mVerts[8 * i + 4] = 0.0;
        this.mVerts[8 * i + 5] = 0.0;
    }

    for( var i=0; i<numt; i++ )
    {
        piMeshFace *face = me->mFaceData.mIndexArray[0].mBuffer + i;

        const int ft = face->mNum;
        
        vec3 nor = vec3( 0.0f, 0.0f, 0.0f );
        for( int j=0; j<ft; j++ )
        {
            const vec3 va = *((vec3*)piMesh_GetVertexData( me, face->mIndex[ j      ], ppos ));
            const vec3 vb = *((vec3*)piMesh_GetVertexData( me, face->mIndex[(j+1)%ft], ppos ));

            nor += cross( va, vb );
        }

        for( int j=0; j<ft; j++ )
        {
            vec3 *n = (vec3*)piMesh_GetVertexData( me, face->mIndex[j], npos );
            n->x += nor.x;
            n->y += nor.y;
            n->z += nor.z;
        }
    }

    for( var i=0; i<numv; i++ )
    {
        vec3 *v = (vec3*)piMesh_GetVertexData( me, i, npos );
        *v = normalize( *v );
    }
}
*/

piMesh.prototype.createCube = function(renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([ -1.0, -1.0, -1.0,
                                       1.0, -1.0, -1.0,
                                      -1.0,  1.0, -1.0,
                                       1.0,  1.0, -1.0,
                                      -1.0, -1.0,  1.0,
                                       1.0, -1.0,  1.0,
                                      -1.0,  1.0,  1.0,
                                       1.0,  1.0,  1.0 ]),

                        mIndices : new Uint16Array([ 0, 2, 1,   1, 2, 3,   5, 1, 3,   5, 3, 7,   4, 5, 7,   4, 7, 6,   4, 6, 2,   4, 2, 0,   6, 7, 3,   6, 3, 2,   4, 0, 1,   4, 1, 5 ]),
                        mNumVertices : 8,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };

    this.mVertexFormat = { mStride:12, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}

piMesh.prototype.createCubeSharp = function (renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 1.0,
                                    -1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 0.0,

                                     1.0, 1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 0.0,

                                     1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 1.0,
                                    -1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   1.0, 1.0,
                                     1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   1.0, 0.0,

                                    -1.0, 1.0, 1.0,  -1.0, 0.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0,-1.0,  -1.0, 0.0, 0.0,   0.0, 1.0,
                                    -1.0,-1.0,-1.0,  -1.0, 0.0, 0.0,   1.0, 1.0,
                                    -1.0,-1.0, 1.0,  -1.0, 0.0, 0.0,   1.0, 0.0 ]),

                        mIndices : new Uint16Array([0,1,2, 0,2,3,   4,5,6, 4,6,7,    8,9,10,8,10,11,   12,13,14,12,14,15,   16,17,18,16,18,19,   20,21,22,20,22,23]),
                        mNumVertices : 24,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };


    this.mVertexFormat = { mStride:32, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}


piMesh.prototype.createUnitQuad = function (renderer)
{
    this.mPrimitiveType = 0;
    this.mVertexFormat = { mStride:8, mChannels: [ {mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false} ] };

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0,  1.0, 1.0,  1.0]),
                        mIndices : new Uint16Array([0, 2, 1, 1, 2, 3]),
                        mNumVertices : 4,
                        mNumFaces : 2, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };
 
    return true;
}




piMesh.prototype.destroy = function()
{
    //delete this.mVerts;   this.mVerts = null;
    //delete this.mIndices; this.mIndices = null;
}

piMesh.prototype.scale = function (x, y, z)
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] *= x;
            this.mChunks[j].mVerts[stride * i + 1] *= y;
            this.mChunks[j].mVerts[stride * i + 2] *= z;
        }
    }
}

piMesh.prototype.translate = function (x, y, z) 
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] += x;
            this.mChunks[j].mVerts[stride * i + 1] += y;
            this.mChunks[j].mVerts[stride * i + 2] += z;
        }
    }
}

piMesh.prototype.GPULoad = function (renderer)
{
    for( var i=0; i<this.mChunks.length; i++ )
    {
        var vbo = renderer.CreateVertexArray(this.mChunks[i].mVerts, renderer.BUFTYPE.STATIC );
        if (vbo == null)
            return false;

        var ibo = renderer.CreateIndexArray(this.mChunks[i].mIndices, renderer.BUFTYPE.STATIC);
        if (ibo == null)
            return false;

        this.mChunks[i].mVBO = vbo;
        this.mChunks[i].mIBO = ibo;
    }
    return true;
}

piMesh.prototype.GPURender = function (renderer, positions )//, matPrj, matCam )
{
    //renderer.SetShaderConstantMat4F("unMPrj", matPrj, false );

    var num = this.mChunks.length;
    for( var i=0; i<num; i++ )
    {
        //var mat =  matMul( matCam, this.mChunks[i].mTransform );
        //renderer.SetShaderConstantMat4F("unMMod", mat, false);

        renderer.AttachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat, positions );
        renderer.AttachIndexArray(this.mChunks[i].mIBO );
        renderer.DrawPrimitive(renderer.PRIMTYPE.TRIANGLES, this.mChunks[i].mNumFaces * 3, true, 1);
        renderer.DetachIndexArray(this.mChunks[i].mIBO);
        renderer.DetachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat );
    }
}
//==============================================================================
//
// piLibs 2014-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piRenderer
//
//==============================================================================

function piRenderer()
{
    // private members

    var mGL = null;
    var mBindedShader = null;
    var mIs20 = false;
    var mFloat32Textures;
    var mFloat32Filter;
    var mFloat16Textures;
    var mDrawBuffers;
    var mDepthTextures;
    var mDerivatives;
    var mFloat16Filter;
    var mShaderTextureLOD;
    var mAnisotropic;
    var mRenderToFloat32F;
    var mDebugShader;
    var mAsynchCompile;

    var mVBO_Quad = null;
    var mVBO_Tri = null;
    var mVBO_CubePosNor = null;
    var mVBO_CubePos = null;
    var mShaderHeader = ["",""];
    var mShaderHeaderLines = [0,0];

    // public members
    var me = {};

    me.CLEAR      = { Color: 1, Zbuffer : 2, Stencil : 4 };
    me.TEXFMT     = { C4I8 : 0, C1I8 : 1, C1F16 : 2, C4F16 : 3, C1F32 : 4, C4F32 : 5, Z16 : 6, Z24 : 7, Z32 : 8, C3F32:9 };
    me.TEXWRP     = { CLAMP : 0, REPEAT : 1 };
    me.BUFTYPE    = { STATIC : 0, DYNAMIC : 1 };
    me.PRIMTYPE   = { POINTS : 0, LINES : 1, LINE_LOOP : 2, LINE_STRIP : 3, TRIANGLES : 4, TRIANGLE_STRIP : 5 };
    me.RENDSTGATE = { WIREFRAME : 0, FRONT_FACE : 1, CULL_FACE : 2, DEPTH_TEST : 3, ALPHA_TO_COVERAGE : 4 };
    me.TEXTYPE    = { T2D : 0, T3D : 1, CUBEMAP : 2 };
    me.FILTER     = { NONE : 0, LINEAR : 1, MIPMAP : 2, NONE_MIPMAP : 3 };
    me.TYPE       = { UINT8 : 0, UINT16 : 1, UINT32 : 2, FLOAT16: 3, FLOAT32 : 4, FLOAT64: 5 };

    // private functions

    var iFormatPI2GL = function( format )
    {
        if( mIs20 )
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA8,           mGLExternal: mGL.RGBA,             mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.R8,              mGLExternal: mGL.RED,              mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.R16F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA16F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.R32F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA32F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C3F32) return { mGLFormat: mGL.RGB32F,          mGLExternal: mGL.RGB,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT16, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z24)   return { mGLFormat: mGL.DEPTH_COMPONENT24, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z32)   return { mGLFormat: mGL.DEPTH_COMPONENT32F, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        }
        else
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.RED,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT, mGLExternal: mGL.DEPTH_COMPONENT, mGLType: mGL.UNSIGNED_SHORT }
        }

        return null;
     }

    // public functions

    me.Initialize = function( gl )
                    {
                        mGL = gl;

                        mIs20 = !(gl instanceof WebGLRenderingContext);

                        if( mIs20 )
                        {
                            mFloat32Textures  = true;
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = true;
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = true;
                            mDrawBuffers      = true;
                            mDepthTextures    = true;
                            mShaderTextureLOD = true;
                            mAnisotropic = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mGL.getExtension( 'EXT_color_buffer_float');
                            mDebugShader = mGL.getExtension('WEBGL_debug_shaders');
                            mAsynchCompile = mGL.getExtension('KHR_parallel_shader_compile');

							mGL.hint( mGL.FRAGMENT_SHADER_DERIVATIVE_HINT, mGL.NICEST);
                        }
                        else
                        {
                            mFloat32Textures  = mGL.getExtension( 'OES_texture_float' );
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = mGL.getExtension( 'OES_texture_half_float' );
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = mGL.getExtension( 'OES_standard_derivatives' );
                            mDrawBuffers      = mGL.getExtension( 'WEBGL_draw_buffers' );
                            mDepthTextures    = mGL.getExtension( 'WEBGL_depth_texture' );
                            mShaderTextureLOD = mGL.getExtension( 'EXT_shader_texture_lod' );
                            mAnisotropic      = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mFloat32Textures;
                            mDebugShader      = null;
                            mAsynchCompile    = null;
							
							if( mDerivatives !== null) mGL.hint( mDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, mGL.NICEST);
                        }
                        
                        
                        var maxTexSize = mGL.getParameter( mGL.MAX_TEXTURE_SIZE );
                        var maxCubeSize = mGL.getParameter( mGL.MAX_CUBE_MAP_TEXTURE_SIZE );
                        var maxRenderbufferSize = mGL.getParameter( mGL.MAX_RENDERBUFFER_SIZE );
                        var extensions = mGL.getSupportedExtensions();
                        var textureUnits = mGL.getParameter( mGL.MAX_TEXTURE_IMAGE_UNITS );
                        console.log("WebGL (2.0=" + mIs20 + "):" +
                                    " Asynch Compile: "  + ((mAsynchCompile !==null) ? "yes" : "no") +
                                    ", Textures: F32 ["   + ((mFloat32Textures !==null) ? "yes" : "no") +
                                    "], F16 ["   + ((mFloat16Textures !==null) ? "yes" : "no") +
                                    "], Depth [" + ((mDepthTextures   !==null) ? "yes" : "no") +
                                    "], LOD ["    + ((mShaderTextureLOD!==null) ? "yes" : "no") +
                                    "], Aniso ["   + ((mAnisotropic     !==null) ? "yes" : "no") +
                                    "], Units [" + textureUnits +
                                    "], Max Size [" + maxTexSize +
                                    "], Cube Max Size [" + maxCubeSize +
                                    "], Targets: MRT ["            + ((mDrawBuffers     !==null) ? "yes" : "no") +
                                    "], F32 ["     + ((mRenderToFloat32F!==null) ? "yes" : "no") +
                                    "], Max Size [" + maxRenderbufferSize + "]");

                        // create a 2D quad Vertex Buffer
                        var vertices = new Float32Array( [ -1.0, -1.0,   1.0, -1.0,    -1.0,  1.0,     1.0, -1.0,    1.0,  1.0,    -1.0,  1.0] );
                        mVBO_Quad = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                        mGL.bufferData( mGL.ARRAY_BUFFER, vertices, mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 2D triangle Vertex Buffer
                        mVBO_Tri = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0,   3.0, -1.0,    -1.0,  3.0] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePosNor = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0, -1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                               1.0,  1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                               1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                               1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                               1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0,  1.0, -1.0,   0.0,  0.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePos = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0,  1.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        //-------------------------------------------------------------------

                        mShaderHeader[0] = "";
                        mShaderHeaderLines[0] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[0] += "#version 300 es\n" +
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[0] += 6;
                        }
                        else
                        {
                            mShaderHeader[0] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "#endif\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+                                                
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[0] += 26;
                        }

                        //-------------------------------------------------------

                        mShaderHeader[1] = "";
                        mShaderHeaderLines[1] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[1] += "#version 300 es\n"+
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[1] += 6;
                        }
                        else
                        {
                            if( mDerivatives ) { mShaderHeader[1] += "#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n"; mShaderHeaderLines[1]+=3; }
                            if( mShaderTextureLOD  ) { mShaderHeader[1] += "#extension GL_EXT_shader_texture_lod : enable\n"; mShaderHeaderLines[1]++; }
                            mShaderHeader[1] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "#endif\n"+ 
                                                "vec4 texture(     sampler2D   s, vec2 c)                   { return texture2D(s,c); }\n"+
                                                "vec4 texture(     sampler2D   s, vec2 c, float b)          { return texture2D(s,c,b); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c )                  { return textureCube(s,c); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c, float b)          { return textureCube(s,c,b); }\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[1] += 30;
                            if( mShaderTextureLOD )
                            {
                            mShaderHeader[1] += "vec4 textureLod(  sampler2D   s, vec2 c, float b)          { return texture2DLodEXT(s,c,b); }\n";
                            mShaderHeader[1] += "vec4 textureGrad( sampler2D   s, vec2 c, vec2 dx, vec2 dy) { return texture2DGradEXT(s,c,dx,dy); }\n";
                            mShaderHeaderLines[1] += 2;

                            //mShaderHeader[1] += "vec4 texelFetch( sampler2D s, ivec2 c, int l) { return texture2DLodEXT(s,(vec2(c)+0.5)/vec2(800,450),float(l)); }\n";
                            //mShaderHeaderLines[1] += 1;
                            }
                        }

                        return true;
                    };

        me.GetCaps =    function ()
                        {   
                            return { mIsGL20 : mIs20,
                                     mFloat32Textures: mFloat32Textures != null,
                                     mFloat16Textures: mFloat16Textures != null,
                                     mDrawBuffers: mDrawBuffers != null,
                                     mDepthTextures: mDepthTextures != null,
                                     mDerivatives: mDerivatives != null,
                                     mShaderTextureLOD: mShaderTextureLOD != null };
                        };

        me.GetShaderHeaderLines = function (shaderType)
                        {   
                            return mShaderHeaderLines[shaderType];
                        };

        me.CheckErrors = function()
                         {
                                var error = mGL.getError();
                                if( error != mGL.NO_ERROR ) 
                                { 
                                    for( var prop in mGL ) 
                                    {
                                        if( typeof mGL[prop] == 'number' ) 
                                        {
                                            if( mGL[prop] == error )
                                            {
                                                console.log( "GL Error " + error + ": " + prop );
                                                break;
                                            }
                                        }
                                    }
                                }
                         };

        me.Clear =  function( flags, ccolor, cdepth, cstencil )
                    {
                        var mode = 0;
                        if( flags & 1 ) { mode |= mGL.COLOR_BUFFER_BIT;   mGL.clearColor( ccolor[0], ccolor[1], ccolor[2], ccolor[3] ); }
                        if( flags & 2 ) { mode |= mGL.DEPTH_BUFFER_BIT;   mGL.clearDepth( cdepth ); }
                        if( flags & 4 ) { mode |= mGL.STENCIL_BUFFER_BIT; mGL.clearStencil( cstencil ); }
                        mGL.clear( mode );
                    };


        me.CreateTexture = function ( type, xres, yres, format, filter, wrap, buffer)
                           {
                                if( mGL===null ) return null;

                                var id = mGL.createTexture();

                                var glFoTy = iFormatPI2GL( format );
                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                if( type===me.TEXTYPE.T2D )
                                {
                                    mGL.bindTexture( mGL.TEXTURE_2D, id );
//if( buffer==null )
    //mGL.texStorage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres);
//else
                                    mGL.texImage2D( mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap );

                                    if (filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                }
                                else if( type===me.TEXTYPE.T3D )
                                {
                                    if( mIs20 )
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_3D, id );
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_BASE_LEVEL, 0);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAX_LEVEL, Math.log2(xres));
                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_3D);
                                        }
                                        mGL.texImage3D( mGL.TEXTURE_3D, 0, glFoTy.mGLFormat, xres, yres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap );

                                        if (filter === me.FILTER.MIPMAP)
                                            mGL.generateMipmap( mGL.TEXTURE_3D );
                                        mGL.bindTexture( mGL.TEXTURE_3D, null );
                                    }
                                    else 
                                    {
                                        return null;
                                    }
                                }
                                else 
                                {
                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );

                                    // this works great if we know the number of required mipmaps in advance (1, or other)
                                   //mGL.texStorage2D( mGL.TEXTURE_CUBE_MAP, 1, glFoTy.mGLFormat, xres, yres );

                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                    if( filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                    }

                                    if (filter === me.FILTER.MIPMAP)
                                        mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );

                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                }
                        return { mObjectID: id, mXres: xres, mYres: yres, mFormat: format, mType: type, mFilter: filter, mWrap: wrap, mVFlip:false };
                        };

        me.CreateTextureFromImage = function ( type, image, format, filter, wrap, flipY) 
                                {
                                    if( mGL===null ) return null;

                                    var id = mGL.createTexture();

                                    var glFoTy = iFormatPI2GL( format );

                                    var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                    if( type===me.TEXTYPE.T2D )
                                    {
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);

                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.pixelStorei(mGL.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                                        if( mIs20 ) mGL.pixelStorei(mGL.UNPACK_COLORSPACE_CONVERSION_WEBGL, mGL.NONE );

                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);

                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);

                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if( filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                    }
                                    else if( type===me.TEXTYPE.T3D )
                                    {
                                        return null;
                                    }
                                    else 
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );

                                        if( filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                    }
                                    return { mObjectID: id, mXres: image.width, mYres: image.height, mFormat: format, mType: type, mFilter: filter, mWrap:wrap, mVFlip:flipY };
                                };

        me.SetSamplerFilter = function (te, filter, doGenerateMipsIfNeeded) 
                            {
                                if (te.mFilter === filter) return;

                                if (te.mType === me.TEXTYPE.T2D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_3D, null);

                                }
                                else
                                {
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }


                                te.mFilter = filter;
                            };

        me.SetSamplerWrap = function (te, wrap)
                            {
                                if (te.mWrap === wrap) return;

                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, id);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, id);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_3D, null);
                                }

                                te.mWrap = wrap;
                            };

        me.SetSamplerVFlip = function (te, vflip, image)
                            {
                                if (te.mVFlip === vflip) return;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    if( image != null)
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                }
                                else if (te.mType === me.TEXTYPE.CUBEMAP)
                                {
                                    if( image != null)
                                    {
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei( mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
        
                                }

                                te.mVFlip = vflip;
                            };

        me.CreateMipmaps =  function (te)
                            {
                                if( te.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);
                                    mGL.generateMipmap(mGL.TEXTURE_2D);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);
                                }
                                else if( te.mType===me.TEXTYPE.CUBEMAP )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);
                                    mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }
                            };

        me.UpdateTexture =  function( tex, x0, y0, xres, yres, buffer )
                            {
                                var glFoTy = iFormatPI2GL( tex.mFormat );
                                if( tex.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture( mGL.TEXTURE0);
                                    mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                    mGL.texSubImage2D( mGL.TEXTURE_2D, 0, x0, y0, xres, yres, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                }
                            };

        me.UpdateTextureFromImage = function( tex, image )
                                {
                                    var glFoTy = iFormatPI2GL( tex.mFormat );
                                    if( tex.mType===me.TEXTYPE.T2D )
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                        mGL.texImage2D(  mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image );
                                        mGL.bindTexture( mGL.TEXTURE_2D, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                };

        me.DestroyTexture = function( te )
                            {
                                 mGL.deleteTexture( te.mObjectID );
                            };

        me.AttachTextures = function (num, t0, t1, t2, t3) 
                            {
                                if (num > 0 && t0 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                         if (t0.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t0.mObjectID);
                                }

                                if (num > 1 && t1 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE1);
                                         if (t1.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t1.mObjectID);
                                }

                                if (num > 2 && t2 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE2);
                                         if (t2.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t2.mObjectID);
                                }

                                if (num > 3 && t3 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE3);
                                         if (t3.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t3.mObjectID);
                                }
                            };

        me.DettachTextures = function()
                             {
                                mGL.activeTexture(mGL.TEXTURE0);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE1);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE2);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE3);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                             };

        me.CreateRenderTarget = function ( color0, color1, color2, color3, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);

                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_2D, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.DestroyRenderTarget = function ( tex )
                                 {
                                     mGL.deleteFramebuffer(tex.mObjectID);
                                 };

        me.SetRenderTarget = function (tex)
                             {
                                if( tex===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, tex.mObjectID);

                                //mGL.drawBuffers([mGL.COLOR_ATTACHMENT0, mGL.COLOR_ATTACHMENT1]);
                             };

        me.CreateRenderTargetNew = function ( wantColor0, wantZbuffer, xres, yres, samples )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if( wantZbuffer===true )
                                    {
                                        var zb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);

                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.DEPTH_COMPONENT16, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                    }

                                    if( wantColor0 )
                                    {
                                        var cb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, cb);
                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.RGBA8, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.RGBA8, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.RENDERBUFFER, cb);
                                    }

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                    {
                                        return null;
                                    }
                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mXres: xres, mYres:yres, mTex0: color0 };
                                };

        me.CreateRenderTargetCubeMap = function ( color0, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);
                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.SetRenderTargetCubeMap = function (fbo, face)
                             {
                                if( fbo===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                {
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, fbo.mObjectID);
                                    mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X+face, fbo.mTex0.mObjectID, 0);
                                }
                             };


        me.BlitRenderTarget = function( dst, src )
                                {
                                    mGL.bindFramebuffer(mGL.READ_FRAMEBUFFER, src.mObjectID);
                                    mGL.bindFramebuffer(mGL.DRAW_FRAMEBUFFER, dst.mObjectID);
                                    mGL.clearBufferfv(mGL.COLOR, 0, [0.0, 0.0, 0.0, 1.0]);
                                    mGL.blitFramebuffer( 0, 0, src.mXres, src.mYres,
                                                         0, 0, src.mXres, src.mYres,
                                                         mGL.COLOR_BUFFER_BIT, mGL.LINEAR
                                    );
                                };

        me.SetViewport = function( vp )
                         {
                              mGL.viewport( vp[0], vp[1], vp[2], vp[3] );
                         };

        me.SetWriteMask = function( c0, c1, c2, c3, z )
                          {
                              mGL.depthMask(z);
                              mGL.colorMask(c0,c0,c0,c0);
                          };

        me.SetState = function( stateName, stateValue )
                      {
                            if (stateName === me.RENDSTGATE.WIREFRAME)
                            {
                                if( stateValue ) mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.LINE );
                                else             mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.FILL );
                            }
                            else if (stateName === me.RENDSTGATE.FRONT_FACE)
                            {
                                if( stateValue ) mGL.cullFace( mGL.BACK );
                                else             mGL.cullFace( mGL.FRONT );
                            }
                            else if (stateName === me.RENDSTGATE.CULL_FACE)
                            {
                                if( stateValue ) mGL.enable( mGL.CULL_FACE );
                                else             mGL.disable( mGL.CULL_FACE );
                            }
                            else if (stateName === me.RENDSTGATE.DEPTH_TEST)
                            {
                                if( stateValue ) mGL.enable( mGL.DEPTH_TEST );
                                else             mGL.disable( mGL.DEPTH_TEST );
                            }
                            else if (stateName === me.RENDSTGATE.ALPHA_TO_COVERAGE)
                            {
                                if( stateValue ) { mGL.enable(  mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                                else             { mGL.disable( mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                            }
                      };

        me.SetMultisample = function( v)
                    {
                        if( v===true )
                        {
                            mGL.enable(mGL.SAMPLE_COVERAGE);
                            mGL.sampleCoverage(1.0, false);
                        }
                        else
                        {
                            mGL.disable(mGL.SAMPLE_COVERAGE);
                        }
                    };

        me.GetTranslatedShaderSource = function (shader) 
                          {
                            if( mGL===null ) return null;
                            if( mDebugShader===null ) return null;
                            let vfs = mGL.getAttachedShaders(shader.mProgram);
                            let str = mDebugShader.getTranslatedShaderSource(vfs[1]);
                            let parts = str.split("GLSL END"); str = (parts.length<2) ? str : parts[1];
                            return str;
                          };

        me.CreateShader = function (vsSource, fsSource, preventCache, forceSynch, onResolve) 
                          {
                            if( mGL===null ) return;

                            var vs = mGL.createShader( mGL.VERTEX_SHADER   );
                            var fs = mGL.createShader( mGL.FRAGMENT_SHADER );

                            vsSource = mShaderHeader[0] + vsSource;
                            fsSource = mShaderHeader[1] + fsSource;

                            if( preventCache )
                            {
                                let vran = Math.random().toString(36).substring(7);
                                let fran = Math.random().toString(36).substring(7);
                                vsSource += "\n#define K" + vran + "\n";
                                fsSource += "\n#define K" + fran + "\n";
                            }

                            var timeStart = getRealTime();

                            mGL.shaderSource(vs, vsSource);
                            mGL.shaderSource(fs, fsSource);
                            mGL.compileShader(vs);
                            mGL.compileShader(fs);

                            var pr = mGL.createProgram();
                            mGL.attachShader(pr, vs);
                            mGL.attachShader(pr, fs);
                            mGL.linkProgram(pr);

                            //-------------
                            let checkErrors = function()
                            {
                                if (!mGL.getProgramParameter(pr, mGL.LINK_STATUS))
                                {
                                    // vs error
                                    if (!mGL.getShaderParameter(vs, mGL.COMPILE_STATUS))
                                    {
                                        let vsLog = mGL.getShaderInfoLog(vs);
                                        onResolve(false, { mErrorType: 0, mErrorStr: vsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // fs error
                                    else if (!mGL.getShaderParameter(fs, mGL.COMPILE_STATUS))
                                    {
                                        let fsLog = mGL.getShaderInfoLog(fs);
                                        onResolve(false, { mErrorType: 1, mErrorStr: fsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // link error
                                    else
                                    {
                                        let infoLog = mGL.getProgramInfoLog(pr);
                                        onResolve(false, { mErrorType: 2, mErrorStr: infoLog });
                                        mGL.deleteProgram(pr);
                                    }
                                }
                                // no errors
                                else
                                {
                                    let compilationTime = getRealTime() - timeStart;
                                    onResolve(true, { mProgram: pr, mTime: compilationTime });
                                }
                            };

                            // check compilation
                            if (mAsynchCompile === null || forceSynch===true )
                            {
                                checkErrors();
                            }
                            else
                            {
                                let loopCheckCompletion = function ()
                                {
                                    if( mGL.getProgramParameter(pr, mAsynchCompile.COMPLETION_STATUS_KHR) === true )
                                        checkErrors();
                                    else
                                        setTimeout(loopCheckCompletion, 10);
                                };
                                setTimeout(loopCheckCompletion, 10);
                            }
                        };

        me.AttachShader = function( shader )
                          {
                                if( shader===null )
                                {
                                    mBindedShader = null;
                                    mGL.useProgram( null );
                                }
                                else
                                {
                                    mBindedShader = shader;
                                    mGL.useProgram(shader.mProgram);
                                }
                          };

        me.DetachShader = function ()
                        {
                            mGL.useProgram(null);
                        };

        me.DestroyShader = function( tex )
                        {
                            mGL.deleteProgram(tex.mProgram);
                        };

        me.GetAttribLocation = function (shader, name)
                        {
                            return mGL.getAttribLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantLocation = function (shader, name)
                        {
                            return mGL.getUniformLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantMat4F = function( uname, params, istranspose )
                        {
                            var program = mBindedShader;

                            let pos = mGL.getUniformLocation( program.mProgram, uname );
                            if( pos===null )
                                return false;

                            if( istranspose===false )
                            {
                                var tmp = new Float32Array( [ params[0], params[4], params[ 8], params[12],
                                                              params[1], params[5], params[ 9], params[13],
                                                              params[2], params[6], params[10], params[14],
                                                              params[3], params[7], params[11], params[15] ] );
	                            mGL.uniformMatrix4fv(pos,false,tmp);
                            }
                            else
                                mGL.uniformMatrix4fv(pos,false,new Float32Array(params) );
                            return true;
                        };

        me.SetShaderConstant1F_Pos = function(pos, x)
                        {
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1FV_Pos = function(pos, x)
                        {
                            mGL.uniform1fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant1F = function( uname, x )
                        {
                            var pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1I = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1i(pos, x);
                            return true;
                        };
        me.SetShaderConstant1I_Pos = function(pos, x)
                        {
                            mGL.uniform1i(pos, x);
                            return true;
                        };


        me.SetShaderConstant2F = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform2fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant3F = function(uname, x, y, z)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform3f(pos, x, y, z);
                            return true;
                        };

        me.SetShaderConstant1FV = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1fv(pos, new Float32Array(x));
                            return true;
                        };

        me.SetShaderConstant3FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform3fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderConstant4FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform4fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderTextureUnit = function( uname, unit )
                        {
                            var program = mBindedShader;
                            let pos = mGL.getUniformLocation(program.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform1i(pos, unit);
                            return true;
                        };

        me.CreateVertexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, id);
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.CreateIndexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, id );
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.DestroyArray = function( tex )
                        {
                            mGL.destroyBuffer(tex.mObject);
                        };

        me.AttachVertexArray = function( tex, attribs, pos )
                        {
                            let shader = mBindedShader;

                            mGL.bindBuffer( mGL.ARRAY_BUFFER, tex.mObject);

                            var num = attribs.mChannels.length;
                            var stride = attribs.mStride;

                            var offset = 0;
                            for (var i = 0; i < num; i++)
                            {
                                var id = pos[i];
                                mGL.enableVertexAttribArray(id);
                                var dtype = mGL.FLOAT;
                                var dsize = 4;
                                     if( attribs.mChannels[i].mType === me.TYPE.UINT8   ) { dtype = mGL.UNSIGNED_BYTE;  dsize = 1; }
                                else if( attribs.mChannels[i].mType === me.TYPE.UINT16  ) { dtype = mGL.UNSIGNED_SHORT; dsize = 2; }
                                else if( attribs.mChannels[i].mType === me.TYPE.FLOAT32 ) { dtype = mGL.FLOAT;          dsize = 4; }
                                mGL.vertexAttribPointer(id, attribs.mChannels[i].mNumComponents, dtype, attribs.mChannels[i].mNormalize, stride, offset);
                                offset += attribs.mChannels[i].mNumComponents * dsize;
                            }
                        };

        me.AttachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, tex.mObject);
                        };

        me.DetachVertexArray = function (tex, attribs)
                        {
                            let num = attribs.mChannels.length;
                            for (let i = 0; i < num; i++)
                                mGL.disableVertexAttribArray(i);
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, null);
                        };

        me.DetachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, null);
                        };

        me.DrawPrimitive = function( typeOfPrimitive, num, useIndexArray, numInstances )
                        {
                            let glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.POINTS ) glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.LINES ) glType = mGL.LINES;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_LOOP ) glType = mGL.LINE_LOOP;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_STRIP ) glType = mGL.LINE_STRIP;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLES ) glType = mGL.TRIANGLES;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLE_STRIP ) glType = mGL.TRIANGLE_STRIP;

                            if( numInstances<=1 )
                            {
  	                            if( useIndexArray ) mGL.drawElements( glType, num, mGL.UNSIGNED_SHORT, 0 );
	                            else                mGL.drawArrays( glType, 0, num );
                            }
                            else
                            {
                                mGL.drawArraysInstanced(glType, 0, num, numInstances);
                                mGL.drawElementsInstanced( glType, num, mGL.UNSIGNED_SHORT, 0, numInstances);
                            }
                        };


        me.DrawFullScreenTriangle_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 3 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };


        me.DrawUnitQuad_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 6 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };

        me.DrawUnitCube_XYZ_NOR = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                            mGL.vertexAttribPointer( vpos[0], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.vertexAttribPointer( vpos[1], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos[0] );
                            mGL.enableVertexAttribArray( vpos[1] );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos[0] );
                            mGL.disableVertexAttribArray( vpos[1] );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.DrawUnitCube_XYZ = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                            mGL.vertexAttribPointer( vpos, 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.SetBlend = function( enabled )
                    {
                        if( enabled )
                        {
                            mGL.enable( mGL.BLEND );
                            mGL.blendEquationSeparate( mGL.FUNC_ADD, mGL.FUNC_ADD );
                            mGL.blendFuncSeparate( mGL.SRC_ALPHA, mGL.ONE_MINUS_SRC_ALPHA, mGL.ONE, mGL.ONE_MINUS_SRC_ALPHA );
                        }
                        else
                        {
                            mGL.disable( mGL.BLEND );
                        }
                    };

        me.GetPixelData = function( data, offset, xres, yres )
                        {
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.UNSIGNED_BYTE, data, offset);
                        };

        me.GetPixelDataRenderTarget = function( obj, data, xres, yres )
                        {
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, obj.mObjectID);
                            mGL.readBuffer(mGL.COLOR_ATTACHMENT0);
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.FLOAT, data, 0);
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                        };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piShading
//
//==============================================================================

function smoothstep(a, b, x)
{
    x = (x - a) / (b - a);
    if (x < 0) x = 0; else if (x > 1) x = 1;
    return x * x * (3.0 - 2.0 * x);
}

function clamp01(x)
{
    if( x < 0.0 ) x = 0.0;
    if( x > 1.0 ) x = 1.0;
    return x;
}

function clamp(x, a, b)
{
    if( x < a ) x = a;
    if( x > b ) x = b;
    return x;
}

function screen(a, b)
{
    return 1.0 - (1.0 - a) * (1.0 - b);
}

function parabola(x)
{
    return 4.0 * x * (1.0 - x);
}

function min(a, b)
{
    return (a < b) ? a : b;
}

function max(a, b)
{
    return (a > b) ? a : b;
}

function noise( x )
{
    function grad(i, j, x, y)
    {
        var h = 7 * i + 131 * j;
        h = (h << 13) ^ h;
        h = (h * (h * h * 15731 + 789221) + 1376312589);

        var rx = (h & 0x20000000) ? x : -x;
        var ry = (h & 0x10000000) ? y : -y;

        return rx + ry;
    }

    var i = [ Math.floor(x[0]), Math.floor(x[1]) ];
    var f = [ x[0] - i[0], x[1] - i[1] ];
    var w = [ f[0]*f[0]*(3.0-2.0*f[0]), f[1]*f[1]*(3.0-2.0*f[1]) ];

    var a = grad( i[0]+0, i[1]+0, f[0]+0.0, f[1]+0.0 );
    var b = grad( i[0]+1, i[1]+0, f[0]-1.0, f[1]+0.0 );
    var c = grad( i[0]+0, i[1]+1, f[0]+0.0, f[1]-1.0 );
    var d = grad( i[0]+1, i[1]+1, f[0]-1.0, f[1]-1.0 );

    return a + (b-a)*w[0] + (c-a)*w[1] + (a-b-c+d)*w[0]*w[1];
}//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piVecTypes
//
//==============================================================================


function vec3( a, b, c )
{
    return [ a, b, c ];
}

function add( a, b )
{
    return [ a[0]+b[0], a[1]+b[1], a[2]+b[2] ];
}

function sub( a, b )
{
    return [ a[0]-b[0], a[1]-b[1], a[2]-b[2] ];
}

function mul( a, s ) 
{
    return [ a[0]*s, a[1]*s, a[2]*s ];
}

function cross( a, b )
{
    return [ a[1]*b[2] - a[2]*b[1],
             a[2]*b[0] - a[0]*b[2],
             a[0]*b[1] - a[1]*b[0] ];
}

function dot( a, b ) 
{
    return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
}

function normalize( v ) 
{
    var is = 1.0 / Math.sqrt( v[0]*v[0] + v[1]*v[1] + v[2]*v[2] );
    return [ v[0]*is, v[1]*is, v[2]*is ];
}

function createCirclePoint( cen, uuu, vvv, rad, s, t )
{
    return [ cen[0] + rad*(uuu[0]*s + vvv[0]*t),
             cen[1] + rad*(uuu[1]*s + vvv[1]*t),
             cen[2] + rad*(uuu[2]*s + vvv[2]*t) ];
}

function createTangent( a, b, c )
{
    var cb = normalize( [ c[0]-b[0], c[1]-b[1], c[2]-b[2] ] );
    var ba = normalize( [ b[0]-a[0], b[1]-a[1], b[2]-a[2] ] );
    return normalize( [ ba[0]+cb[0], ba[1]+cb[1], ba[2]+cb[2] ] );

}

//===================================

function vec4( a, b, c, d )
{
    return [ a, b, c, d ];
}

function getXYZ( v )
{
    return [ v[0], v[1], v[2] ];
}

//===================================

function setIdentity()
{
    return [ 1.0, 0.0, 0.0, 0.0,
             0.0, 1.0, 0.0, 0.0,
             0.0, 0.0, 1.0, 0.0,
             0.0, 0.0, 0.0, 1.0 ];
}

function setRotationX( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ 1.0,   0.0,   0.0, 0.0,
             0.0,  cost, -sint, 0.0, 
             0.0,  sint,  cost, 0.0,
             0.0,   0.0,   0.0, 1.0 ];
}

function setRotationY( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ cost, 0.0, -sint, 0.0,
              0.0, 1.0,   0.0, 0.0, 
             sint, 0.0,  cost, 0.0,
              0.0, 0.0,   0.0, 1.0 ];
}

function extractRotationEuler( m)
{
    var res = [];
    if (m[0] == 1.0)
    {
        res[0] = Math.atan2(m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;

    }
    else if (m[0] == -1.0)
    {
        res[0] = Math.atan2( m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;
    }
    else
    {
        res[0] = Math.atan2( -m[9], m[10]);
        res[1] = Math.atan2( m[8], Math.sqrt(m[9]*m[9] + m[10]*m[10]));
        res[2] = Math.atan2( m[4], m[0]);
    }
    return res;
}

function setFromQuaternion( q )
{
    var ww = q[3]*q[3];
    var xx = q[0]*q[0];
    var yy = q[1]*q[1];
    var zz = q[2]*q[2];

    return [ ww+xx-yy-zz,                   2.0*(q[0]*q[1] - q[3]*q[2]), 2.0*(q[0]*q[2] + q[3]*q[1]), 0.0,
               2.0*(q[0]*q[1] + q[3]*q[2]),   ww-xx+yy-zz,                 2.0*(q[1]*q[2] - q[3]*q[0]), 0.0,
               2.0*(q[0]*q[2] - q[3]*q[1]),   2.0*(q[1]*q[2] + q[3]*q[0]), ww-xx-yy+zz,                 0.0,
               0.0,                           0.0,                         0.0,                         1.0 ];
}

function setPerspective( fovy, aspect, znear, zfar )
{
    var tan = Math.tan(fovy * Math.PI/180.0);
    var x = 1.0 / (tan*aspect);
    var y = 1.0 / (tan);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0 * zfar * znear) / (zfar - znear);

    return [ x,    0.0,  0.0,  0.0,
             0.0,  y,    0.0,  0.0,
             0.0,  0.0,  c,     d,
             0.0,  0.0, -1.0,  0.0 ];
}

function setLookAt( eye, tar, up )
{
    var dir = [ -tar[0]+eye[0], -tar[1]+eye[1], -tar[2]+eye[2] ];

	var m00 = dir[2]*up[1] - dir[1]*up[2]; 
    var m01 = dir[0]*up[2] - dir[2]*up[0];
    var m02 = dir[1]*up[0] - dir[0]*up[1];
    var im = 1.0/Math.sqrt( m00*m00 + m01*m01 + m02*m02 );
    m00 *= im;
    m01 *= im;
    m02 *= im;

	var m04 = m02*dir[1] - m01*dir[2]; 
    var m05 = m00*dir[2] - m02*dir[0];
    var m06 = m01*dir[0] - m00*dir[1];
    im = 1.0/Math.sqrt( m04*m04 + m05*m05 + m06*m06 );
    m04 *= im;
    m05 *= im;
    m06 *= im;

	var m08 = dir[0];
	var m09 = dir[1];
	var m10 = dir[2];
    im = 1.0/Math.sqrt( m08*m08 + m09*m09 + m10*m10 );
    m08 *= im;
    m09 *= im;
    m10 *= im;

	var m03 = -(m00*eye[0] + m01*eye[1] + m02*eye[2] );
	var m07 = -(m04*eye[0] + m05*eye[1] + m06*eye[2] );
	var m11 = -(m08*eye[0] + m09*eye[1] + m10*eye[2] );

    return [ m00, m01, m02, m03,
             m04, m05, m06, m07,
             m08, m09, m10, m11,
             0.0, 0.0, 0.0, 1.0 ];
}


function setOrtho( left, right, bottom, top, znear, zfar )
{
   var x = 2.0 / (right - left);
   var y = 2.0 / (top - bottom);
   var a = (right + left) / (right - left);
   var b = (top + bottom) / (top - bottom);
   var c = -2.0 / (zfar - znear);
   var d = -(zfar + znear) / ( zfar - znear);

   return [  x, 0.0, 0.0,   a,
           0.0,   y, 0.0,   b,
           0.0, 0.0,   c,   d,
           0.0, 0.0, 0.0, 1.0 ];
}

function setTranslation( p )
{
    return [ 1.0, 0.0, 0.0, p[0],
             0.0, 1.0, 0.0, p[1],
             0.0, 0.0, 1.0, p[2],
             0.0, 0.0, 0.0, 1.0 ];
}

function setScale( s )
{
    return [ s[0], 0.0,  0.0,  0.0,
             0.0,  s[1], 0.0,  0.0,
             0.0,  0.0,  s[2], 0.0,
             0.0,  0.0,  0.0,  1.0];
}

function setProjection( fov, znear, zfar )
{
    var x = 2.0 / (fov[3]+fov[2]);
    var y = 2.0 / (fov[0]+fov[1]);
    var a = (fov[3]-fov[2]) / (fov[3]+fov[2]);
    var b = (fov[0]-fov[1]) / (fov[0]+fov[1]);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0*zfar*znear) / (zfar - znear);
    return [   x, 0.0,    a, 0.0,
             0.0,   y,    b, 0.0,
             0.0, 0.0,    c,   d,
             0.0, 0.0, -1.0, 0.0 ];
   // inverse is:
   //return mat4x4( 1.0/x, 0.0f,  0.0f,   a/x,
   //               0.0f,  1.0/y, 0.0f,   b/x,
   //               0.0f,  0.0f,  0.0f,   -1.0,
   //               0.0f,  0.0f,  1.0f/d, c/d );
}


function invertFast( m )
{
    var inv = [
   
             m[5]  * m[10] * m[15] - 
             m[5]  * m[11] * m[14] - 
             m[9]  * m[6]  * m[15] + 
             m[9]  * m[7]  * m[14] +
             m[13] * m[6]  * m[11] - 
             m[13] * m[7]  * m[10],

             -m[1]  * m[10] * m[15] + 
              m[1]  * m[11] * m[14] + 
              m[9]  * m[2] * m[15] - 
              m[9]  * m[3] * m[14] - 
              m[13] * m[2] * m[11] + 
              m[13] * m[3] * m[10],

             m[1]  * m[6] * m[15] - 
             m[1]  * m[7] * m[14] - 
             m[5]  * m[2] * m[15] + 
             m[5]  * m[3] * m[14] + 
             m[13] * m[2] * m[7] - 
             m[13] * m[3] * m[6],

             -m[1] * m[6] * m[11] + 
              m[1] * m[7] * m[10] + 
              m[5] * m[2] * m[11] - 
              m[5] * m[3] * m[10] - 
              m[9] * m[2] * m[7] + 
              m[9] * m[3] * m[6],

             -m[4]  * m[10] * m[15] + 
              m[4]  * m[11] * m[14] + 
              m[8]  * m[6]  * m[15] - 
              m[8]  * m[7]  * m[14] - 
              m[12] * m[6]  * m[11] + 
              m[12] * m[7]  * m[10],

             m[0]  * m[10] * m[15] - 
             m[0]  * m[11] * m[14] - 
             m[8]  * m[2] * m[15] + 
             m[8]  * m[3] * m[14] + 
             m[12] * m[2] * m[11] - 
             m[12] * m[3] * m[10],

             -m[0]  * m[6] * m[15] + 
              m[0]  * m[7] * m[14] + 
              m[4]  * m[2] * m[15] - 
              m[4]  * m[3] * m[14] - 
              m[12] * m[2] * m[7] + 
              m[12] * m[3] * m[6],


             m[0] * m[6] * m[11] - 
             m[0] * m[7] * m[10] - 
             m[4] * m[2] * m[11] + 
             m[4] * m[3] * m[10] + 
             m[8] * m[2] * m[7] - 
             m[8] * m[3] * m[6],


             m[4]  * m[9] * m[15] - 
             m[4]  * m[11] * m[13] - 
             m[8]  * m[5] * m[15] + 
             m[8]  * m[7] * m[13] + 
             m[12] * m[5] * m[11] - 
             m[12] * m[7] * m[9],



             -m[0]  * m[9] * m[15] + 
              m[0]  * m[11] * m[13] + 
              m[8]  * m[1] * m[15] - 
              m[8]  * m[3] * m[13] - 
              m[12] * m[1] * m[11] + 
              m[12] * m[3] * m[9],

              m[0]  * m[5] * m[15] - 
              m[0]  * m[7] * m[13] - 
              m[4]  * m[1] * m[15] + 
              m[4]  * m[3] * m[13] + 
              m[12] * m[1] * m[7] - 
              m[12] * m[3] * m[5],

              -m[0] * m[5] * m[11] + 
               m[0] * m[7] * m[9] + 
               m[4] * m[1] * m[11] - 
               m[4] * m[3] * m[9] - 
               m[8] * m[1] * m[7] + 
               m[8] * m[3] * m[5],

              -m[4]  * m[9] * m[14] + 
               m[4]  * m[10] * m[13] +
               m[8]  * m[5] * m[14] - 
               m[8]  * m[6] * m[13] - 
               m[12] * m[5] * m[10] + 
               m[12] * m[6] * m[9],

              m[0]  * m[9] * m[14] - 
              m[0]  * m[10] * m[13] - 
              m[8]  * m[1] * m[14] + 
              m[8]  * m[2] * m[13] + 
              m[12] * m[1] * m[10] - 
              m[12] * m[2] * m[9],

              -m[0]  * m[5] * m[14] + 
               m[0]  * m[6] * m[13] + 
               m[4]  * m[1] * m[14] - 
               m[4]  * m[2] * m[13] - 
               m[12] * m[1] * m[6] + 
               m[12] * m[2] * m[5],

              m[0] * m[5] * m[10] - 
              m[0] * m[6] * m[9] - 
              m[4] * m[1] * m[10] + 
              m[4] * m[2] * m[9] + 
              m[8] * m[1] * m[6] - 
              m[8] * m[2] * m[5] ];

    var det = m[0] * inv[0] + m[1] * inv[4] + m[2] * inv[8] + m[3] * inv[12];

    det = 1.0/det;

    for( var i = 0; i<16; i++ ) inv[i] = inv[i] * det;

    return inv;
}

function matMul( a, b )
{
    var res = [];
    for( var i=0; i<4; i++ )
    {
        var x = a[4*i+0];
        var y = a[4*i+1];
        var z = a[4*i+2];
        var w = a[4*i+3];

        res[4*i+0] = x * b[ 0] + y * b[ 4] + z * b[ 8] + w * b[12];
        res[4*i+1] = x * b[ 1] + y * b[ 5] + z * b[ 9] + w * b[13];
        res[4*i+2] = x * b[ 2] + y * b[ 6] + z * b[10] + w * b[14];
        res[4*i+3] = x * b[ 3] + y * b[ 7] + z * b[11] + w * b[15];
    }

    return res;
}

function matMulpoint( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2] + m[ 3],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2] + m[ 7],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] + m[11] ];
}

function matMulvec( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] ];
}


function bound3( infi )
{
    return [ infi, -infi, infi, -infi, infi, -infi ];
}

function bound3_include( a, p )
{
    return [
        (p[0]<a[0]) ? p[0] : a[0],
        (p[0]>a[1]) ? p[0] : a[1],
        (p[1]<a[2]) ? p[1] : a[2],
        (p[1]>a[3]) ? p[1] : a[3],
        (p[2]<a[4]) ? p[2] : a[4],
        (p[2]>a[5]) ? p[2] : a[5] ];
}

function bound3_center( b )
{
    return [ 0.5*(b[0]+b[1]),
             0.5*(b[2]+b[3]),
             0.5*(b[4]+b[5]) ];
}

function bound3_radius( b )
{
    return [ 0.5*(b[1]-b[0]),
             0.5*(b[3]-b[2]),
             0.5*(b[5]-b[4]) ];
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebVR
//
//==============================================================================

function WebVR( isVREnabledCallback, canvasElement )
{
    isVREnabledCallback(false);
    /*


    this.mSupportVR = false;
    this.mHMD = null;

    var me = this;
    var listVRDisplays = function (vrdevs) {
        for (var i = 0; i < vrdevs.length; i++)
        {
            if (vrdevs[i] instanceof VRDisplay)
            {
                me.mHMD = vrdevs[i];
                console.log("WebVR is available.");
                console.log(me.mHMD);
                break;
            }
        }

        isVREnabledCallback(true);
        me.mSupportVR = true;
    }

    if (navigator.getVRDisplays)
    {
        navigator.getVRDisplays().then(listVRDisplays);
    }

    isVREnabledCallback(false);
    this.mCanvas = canvasElement;
    */
}

WebVR.prototype.IsSupported = function()
{
    return false;
    //return this.mSupportVR;
}

WebVR.prototype.GetData = function( id )
{
    return {};
    /*
    var frameData = new VRFrameData();
    var s = this.mHMD.getFrameData(frameData);
    var ss = frameData.pose;
    
    var fovL = this.mHMD.getEyeParameters("left");
    var fovR = this.mHMD.getEyeParameters( "right" );

    // camera info
    var cPos = vec3(0.0, 0.0, 0.0);
    if (ss.position)
        cPos = vec3(-ss.position[0], -ss.position[1], -ss.position[2]);
    var rot = vec4(0.0, 0.0, 0.0, 0.0);
    if (ss.orientation)
        rot = vec4(ss.orientation[0], ss.orientation[1], ss.orientation[2], ss.orientation[3]);
    var cRot = setFromQuaternion(rot);
    var cTra = setTranslation(cPos);
    var cMat = matMul(invertFast(cRot), cTra);
    
    // per eye info
    var lTra = setTranslation( vec3(-fovL.offset[0], -fovL.offset[1], -fovL.offset[2]) );
    var lMat = matMul(lTra, cMat);
    var lPrj = [ Math.tan( fovL.fieldOfView.upDegrees * Math.PI/180.0),
                 Math.tan(fovL.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.rightDegrees * Math.PI / 180.0)];

    var rTra = setTranslation(vec3(-fovR.offset[0], -fovR.offset[1], -fovR.offset[2]));
    var rMat = matMul(rTra, cMat);
    var rPrj = [Math.tan(fovR.fieldOfView.upDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.rightDegrees * Math.PI / 180.0)];

    return {
        mCamera   : { mCamera: cMat },
        mLeftEye  : { mVP:[0,0,fovL.renderWidth,fovL.renderHeight], mProjection:lPrj, mCamera:lMat },
        mRightEye : { mVP:[fovR.renderWidth/2,0,fovR.renderWidth,fovR.renderHeight], mProjection:rPrj, mCamera:rMat }
           };
    */
}

WebVR.prototype.Enable = function( id )
{
    /*
    this.mHMD.requestPresent([{ source: this.mCanvas }]).then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : requestPresent failed.");
        }
    );
    */
}

WebVR.prototype.Disable = function( id )
{
    /*
    if (!this.mHMD.isPresenting)
    {
        return;
    }

    this.mHMD.exitPresent().then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : exitPresent failed.");
        }
    );
    */
}

WebVR.prototype.RequestAnimationFrame = function (id)
{
    //this.mHMD.requestAnimationFrame(id);
}

WebVR.prototype.IsPresenting = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        return true;
    }
    */
    return false;
}

WebVR.prototype.Finish = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        this.mHMD.submitFrame();
    }
    */
}

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebUtils
//
//==============================================================================


// RequestAnimationFrame
window.requestAnimFrame = ( function () { return window.requestAnimationFrame    || window.webkitRequestAnimationFrame ||
                                                 window.mozRequestAnimationFrame || window.oRequestAnimationFrame ||
                                                 window.msRequestAnimationFrame  || function( cb ) { window.setTimeout(cb,1000/60); };
                                        } )();

// performance.now
window.getRealTime = ( function() { if ("performance" in window ) return function() { return window.performance.now(); }
                                                                  return function() { return (new Date()).getTime(); }
                                  } )();

window.URL = window.URL || window.webkitURL;

navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;

function htmlEntities(str) 
{
    return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g,'&apos;');
}

function piDisableTouch()
{
    document.body.addEventListener('touchstart', function(e){ e.preventDefault(); });
}

var piGetTime = function ( timestamp )
{
    if (timestamp == 0)
        return "";
    return new Date(timestamp * 1000).toISOString().substr(0, 10);
}

function piGetCoords( obj )
{
    var x = 0;
    var y = 0; 
    do
    {
         x += obj.offsetLeft;
         y += obj.offsetTop;
    }while( obj = obj.offsetParent );

    return { mX:x, mY:y };
}

function piGetMouseCoords( ev, canvasElement )
{
    var pos = piGetCoords(canvasElement );
    var mcx =                        (ev.pageX - pos.mX) * canvasElement.width / canvasElement.offsetWidth;
    var mcy = canvasElement.height - (ev.pageY - pos.mY) * canvasElement.height / canvasElement.offsetHeight;

    return { mX: mcx, mY: mcy };

}

function piGetSourceElement( e )
{
    var ele = null;
    if( e.target )     ele = e.target;
    if( e.srcElement ) ele = e.srcElement;
    return ele;
}

function piRequestFullScreen( ele )
{
    if( ele==null ) ele =   document.documentElement;
         if( ele.requestFullscreen       ) ele.requestFullscreen();
    else if( ele.msRequestFullscreen     ) ele.msRequestFullscreen();
    else if( ele.mozRequestFullScreen    ) ele.mozRequestFullScreen();
    else if( ele.webkitRequestFullscreen ) ele.webkitRequestFullscreen( Element.ALLOW_KEYBOARD_INPUT );
}

function piIsFullScreen()
{
    return document.fullscreen || document.mozFullScreen || document.webkitIsFullScreen || document.msFullscreenElement || false;
}

function piExitFullScreen()
{
       if( document.exitFullscreen       ) document.exitFullscreen();
  else if( document.msExitFullscreen     ) document.msExitFullscreen();
  else if( document.mozCancelFullScreen  ) document.mozCancelFullScreen();
  else if( document.webkitExitFullscreen ) document.webkitExitFullscreen();
}

function piIsMobile()
{
    return (navigator.userAgent.match(/Android/i) ||
            navigator.userAgent.match(/webOS/i) ||
            navigator.userAgent.match(/iPhone/i) ||
            navigator.userAgent.match(/iPad/i) ||
            navigator.userAgent.match(/iPod/i) ||
            navigator.userAgent.match(/BlackBerry/i) ||
            navigator.userAgent.match(/Windows Phone/i)) ? true : false;
}

function piCreateGlContext( cv, useAlpha, useDepth, usePreserveBuffer, useSupersampling )
{
    var opts = { alpha: useAlpha, 
                 depth: useDepth, 
                 stencil: false, 
                 premultipliedAlpha: false, 
                 antialias: useSupersampling, 
                 preserveDrawingBuffer: usePreserveBuffer, 
                 powerPreference: "high-performance" }; // "low_power", "high_performance", "default"

    var gl = null;
    if( gl === null) gl = cv.getContext( "webgl2", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl2", opts );
    if( gl === null) gl = cv.getContext( "webgl", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl", opts );

    return gl;
}

function piCreateAudioContext()
{
    var res = null;
    try
    {
        if( window.AudioContext ) res = new AudioContext();
        if( res==null && window.webkitAudioContext ) res = new webkitAudioContext();
    }
    catch( e )
    {
        res = null;
    }
    return res;
}

function piHexColorToRGB(str) // "#ff3041"
{
    var rgb = parseInt(str.slice(1), 16);
    var r = (rgb >> 16) & 255;
    var g = (rgb >> 8) & 255;
    var b = (rgb >> 0) & 255;
    return [r, g, b];
}

function piCreateFPSCounter()
{
    var mFrame;
    var mTo;
    var mFPS;

    var iReset = function( time )
    {
        mFrame = 0;
        mTo = time;
        mFPS = 60.0;
    }

    var iCount = function( time )
    {
        mFrame++;

        if( (time-mTo)>500.0 )
        {
            mFPS = 1000.0*mFrame/(time-mTo);
            mFrame = 0;
            mTo = time;
            return true;
        }
        return false;
    }

    var iGetFPS = function()
    {
        return mFPS;
    }
    
    return { Reset : iReset, Count : iCount, GetFPS : iGetFPS };
}

function piCanMediaRecorded(canvas)
{
    if (typeof window.MediaRecorder !== 'function' || typeof canvas.captureStream !== 'function') {
        return false;
    }
    return true;
}

function piCreateMediaRecorder(isRecordingCallback, canvas) 
{
    if (piCanMediaRecorded(canvas) == false)
    {
        return null;
    }
    
    var options = { audioBitsPerSecond : 0, videoBitsPerSecond : 8000000 }; 
	     if (MediaRecorder.isTypeSupported('video/webm;codecs=h264')) options.mimeType = 'video/webm;codecs=h264';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9' )) options.mimeType = 'video/webm;codecs=vp9';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8' )) options.mimeType = 'video/webm;codecs=vp8';
    else                                                              options.mimeType = 'video/webm;';

    var mediaRecorder = new MediaRecorder(canvas.captureStream(), options);
    var chunks = [];
    
    mediaRecorder.ondataavailable = function(e) 
    {
        if (e.data.size > 0) 
        {
            chunks.push(e.data);
        }
    };
 
    mediaRecorder.onstart = function(){ 
        isRecordingCallback( true );
    };
    
    mediaRecorder.onstop = function()
    {
         isRecordingCallback( false );
         let blob     = new Blob(chunks, {type: "video/webm"});
         chunks       = [];
         let videoURL = window.URL.createObjectURL(blob);
         let url      = window.URL.createObjectURL(blob);
         let a        = document.createElement("a");
         document.body.appendChild(a);
         a.style      = "display: none";
         a.href       = url;
         a.download   = "capture.webm";
         a.click();
         window.URL.revokeObjectURL(url);
     };
    
    return mediaRecorder;
}

function piExportToEXR(width, height, numComponents, type, bytes)
{
    var bytesPerComponent = 0;
    if      (type=="Uint")   bytesPerComponent = 4; 
    else if (type=="Half")   bytesPerComponent = 2;
    else if (type=="Float")  bytesPerComponent = 4;

    var tHeader = 258 + (18 * numComponents + 1);
    var tTable = 8 * height;
    var tScanlines = height * (4 + 4 + (numComponents * bytesPerComponent * width));
    var tTotal = tHeader + tTable + tScanlines;

    //console.log("    header size = " + tHeader);
    //console.log("    table size = " + tTable);
    //console.log("    scanlines size = " + tScanlines);
    //console.log("    total = " + tTotal);

    var buffer = new ArrayBuffer(tTotal); 
    var data = new DataView(buffer);

    // Header
    {
        // Header : 4 bytes -> 0x76, 0x2f, 0x31, 0x01
        var c = 0;
        data.setUint8 (c++, 0x76);
        data.setUint8 (c++, 0x2f);
        data.setUint8 (c++, 0x31);
        data.setUint8 (c++, 0x01);

        // Version : 4 bytes -> 2, 0, 0, 0
        data.setUint8 (c++, 0x02);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        
        // Write channel info
        // Write attribute name : "channels"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x73);
            data.setUint8 (c++, 0x0);

            // Write attribute type : "chlist"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : 18 x 3 + 1 = 55
            var attribSize = 18 * numComponents + 1;
            data.setUint8 (c++, attribSize); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            var i;
            for (i = 0; i < numComponents; i++)
            {
                // Attribute : "B" (42) "G" (47) "R" (52)
                if (i==0)       data.setUint8 (c++, 0x42);
                else if (i==1)  data.setUint8 (c++, 0x47);
                else if (i==2)  data.setUint8 (c++, 0x52);
                data.setUint8 (c++, 0x00);
                
                // Value : Float (2), Half (1), Uint (0)
                if      (type=="Uint")   data.setUint8 (c++, 0x00); 
                else if (type=="Half")   data.setUint8 (c++, 0x01);
                else if (type=="Float")  data.setUint8 (c++, 0x02);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);

                // Plinear
                data.setUint8 (c++, 0x01);

                // Reserved
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 

                // X sampling
                data.setUint8 (c++, 0x01); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                
                // Y sampling
                data.setUint8 (c++, 0x01);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
            }
            // End attribute
            data.setUint8 (c++, 0x00);
    
        // Write attribute name : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute type : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : "1"
            data.setUint8 (c++, 0x01); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // Write attribute value : "0" (None)
            data.setUint8 (c++, 0x00);

        // datawindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00); 

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00);

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 

            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // displayWindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x79); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00);

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00); 

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // size
            data.setUint8 (c++, 0x01);
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);
            
            // value 
            data.setUint8 (c++, 0x00);

        // PixelAspectRatio
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x41); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x52); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x00); 

            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);
        
            // size 4
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 1.0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);
        
        // screenWindowCenter
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63);
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x43); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e);
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00);

            // v2f
            data.setUint8 (c++, 0x76); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x00);

            // size 8
            data.setUint8 (c++, 0x08); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

        // screenWindowWidth
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x00); 
            
            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00); 

            // size
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);

            // value
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);

        // End of header
        data.setUint8 (c++, 0x00);
    }
    //console.log("header size = " + c);

    // Scanline table
    var initc = c + height * 8;
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        var jump = initc + scanline * (8 + width * bytesPerComponent * numComponents); 
        data.setUint32 (c, jump, true);
        c += 4; 

        data.setUint32 (c, 0x00, true);
        c += 4;
    }
    //console.log("header + scanlines table size = " + c);

    // Scanlines
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        // Scanline
        data.setUint32(c, scanline, true);
        c += 4;

        // size 24
        var size = width * numComponents * bytesPerComponent; 
        data.setUint32(c, size, true);
        c += 4;

        var numComponentsSource = 4; // number of components in the SOURCE image
        for (var component = 0; component < numComponents ; component ++) 
        {
            for (var pixel = 0 ; pixel < width ; pixel ++) 
            {
                // flip vertical, so we read OpenGL buffers without JS image flipping
                var v = bytes[(height-1-scanline) * width *numComponentsSource + pixel * numComponentsSource + (2-component)];
                if      (type=="Float") data.setFloat32(c, v, true);
                else if (type=="Half")  data.setUint16(c, v, true);

                c += bytesPerComponent;
            }
        }
    }
    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}


function piExportToWAV(numSamples, rate, bits, numChannels, words)
{
    let numBytes = numSamples * numChannels * bits/8;

    let buffer = new ArrayBuffer(44 + numBytes); 
    let data = new DataView(buffer);

    {
        data.setUint32( 0, 0x46464952, true );  // RIFF
        data.setUint32( 4, numBytes + 36, true);
        {
            data.setUint32( 8, 0x45564157, true );  // WAV_WAVE
            data.setUint32( 12, 0x20746D66, true );  // WAV_FMT
            {
                data.setUint32( 16, 16, true);
                data.setUint16( 20, 1, true ); // WAV_FORMAT_PCM
                data.setUint16( 22, numChannels, true);
                data.setUint32( 24, rate, true);
                data.setUint32( 28, rate*numChannels*bits / 8, true);
                data.setUint16( 32, numChannels*bits / 8, true);
                data.setUint16( 34, bits, true);
            }

            data.setUint32( 36, 0x61746164, true);  // WAV_DATA
            {
                data.setUint32( 40, numBytes, true);
                let numWords = numSamples * numChannels;
                for(let i=0; i<numWords; i++ )
                {
                    data.setInt16( 44 + i*2, words[i], true );
                }
            }
        }
    }


    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}

function piTriggerDownload(name, blob)
{
    let url = URL.createObjectURL(blob);
    let aElement = document.createElement("a");
    aElement.href     = url;
    aElement.target   = "_self";
    aElement.download = name;
    document.body.appendChild(aElement);
    aElement.click();
    document.body.removeChild(aElement);
}</script>
    <script>"use strict"

function bufferID_to_assetID( id )
{
    if( id===0 ) return '4dXGR8';
    if( id===1 ) return 'XsXGR8';
    if( id===2 ) return '4sXGR8';
    if( id===3 ) return 'XdfGR8';
    return 'none';
}
function assetID_to_bufferID( id )
{
    if( id==='4dXGR8' ) return 0;
    if( id==='XsXGR8' ) return 1;
    if( id==='4sXGR8' ) return 2;
    if( id==='XdfGR8' ) return 3;
    return -1;
}

function assetID_to_cubemapBuferID( id )
{
    if( id==='4dX3Rr' ) return 0;
    return -1;
}
function cubamepBufferID_to_assetID( id )
{
    if( id===0 ) return '4dX3Rr';
    return 'none';
}

function EffectPass( renderer, is20, isLowEnd, hasShaderTextureLOD, callback, obj, forceMuted, forcePaused, outputGainNode, copyProgram, id, effect  )
{
    this.mID = id;
    this.mInputs  = [null, null, null, null ];
    this.mOutputs = [null, null, null, null ];
    this.mSource = null;

    this.mGainNode = outputGainNode;
    this.mSoundShaderCompiled = false;

    this.mEffect = effect;
    this.mRenderer = renderer;
    this.mProgramCopy = copyProgram; 
    this.mCompilationTime = 0;

    this.mType = "none";
    this.mName = "none";
    this.mFrame = 0;

    this.mShaderTextureLOD = hasShaderTextureLOD;
    this.mIs20 = is20;
    this.mIsLowEnd = isLowEnd;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mForceMuted = forceMuted;
    this.mForcePaused = forcePaused;
}

EffectPass.prototype.MakeHeader_Image = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        // old API
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                   header += "uniform sampler2D iChannel" + i + ";\n";

        // new API (see shadertoy.com/view/wtdGW8)
        header += "uniform struct {\n";
             if( inp===null )                  header += "  sampler2D";
        else if( inp.mInfo.mType==="cubemap" ) header += "  samplerCube";
        else if( inp.mInfo.mType==="volume"  ) header += "  sampler3D";
        else                                  header += "  sampler2D";
        header +=        " sampler;\n";
        header += "  vec3  size;\n";
        header += "  float time;\n";
        header += "  int   loaded;\n";
        header += "}iCh" + i + ";\n";
    }
	header += "void mainImage( out vec4 c, in vec2 f );\n";
    header += "void st_assert( bool cond );\n";
    header += "void st_assert( bool cond, int v );\n";

    if( this.mIs20 ) 
    {
        header += "\nout vec4 shadertoy_out_color;\n" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)shadertoy_out_color.x=-1.0;else if(v==1)shadertoy_out_color.y=-1.0;else if(v==2)shadertoy_out_color.z=-1.0;else shadertoy_out_color.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)shadertoy_out_color.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "shadertoy_out_color = vec4(1.0,1.0,1.0,1.0);" + 
            "vec4 color = vec4(1e20);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "if(shadertoy_out_color.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(shadertoy_out_color.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(shadertoy_out_color.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(shadertoy_out_color.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "shadertoy_out_color = vec4(color.xyz,1.0);" +
        "}";
    }
    else
    {
        header += "" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)gl_FragColor.x=-1.0;else if(v==1)gl_FragColor.y=-1.0;else if(v==2)gl_FragColor.z=-1.0;else gl_FragColor.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)gl_FragColor.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "gl_FragColor = vec4(0.0,0.0,0.0,1.0);" + 
            "vec4 color = vec4(1e20);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "color.w = 1.0;" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(gl_FragColor.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "gl_FragColor = vec4(color.xyz,1.0);"+
        "}";
    }
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 ) 
        this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "void main( void )" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );" +
        "color.w = 1.0;"
    if( this.mIs20 ) 
        this.mImagePassFooterVR +=  "outColor = color;}";
    else
        this.mImagePassFooterVR +=  "gl_FragColor = color;}";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Buffer = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                  header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainImage( out vec4 c,  in vec2 f );\n"

    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +
        "mainImage( color, gl_FragCoord.xy );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
    this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        this.mImagePassFooterVR +="outColor = color; }";
    else
        this.mImagePassFooterVR +="gl_FragColor = color; }";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Cubemap = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                   header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainCubemap( out vec4 c, in vec2 f, in vec3 ro, in vec3 rd );\n"

    header += "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainCubemap( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Sound = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform float     iChannelTime[4];\n" +
              "uniform float     iTimeOffset;\n" +
              "uniform int       iSampleOffset;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n";

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp!==null && inp.mInfo.mType==="cubemap" )
            header += "uniform samplerCube iChannel" + i + ";\n";
        else
            header += "uniform sampler2D iChannel" + i + ";\n";
    }
    header += "\n";
    header += "vec2 mainSound( in int samp, float time );\n";

    if( this.mIs20 )
    {
        header += "out vec4 outColor; void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "int   s = iSampleOffset + int(gl_FragCoord.y-0.2)*512 + int(gl_FragCoord.x-0.2);" +
            "vec2 y = mainSound( s, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "outColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    else
    {
        header += "void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "vec2 y = mainSound( 0, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "gl_FragColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    header += "\n";
    this.mHeader = header;
    this.mHeaderLength = 0;
}


EffectPass.prototype.MakeHeader_Common = function ()
{
    let header = "";
    let headerlength = 0;

    header += "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n";
    headerlength += 2;

    if (this.mIs20)
    {
        header += "out vec4 outColor;\n";
        headerlength += 1;
    }
    header += "void main( void )\n";
    headerlength += 1;

    if (this.mIs20)
        header += "{ outColor = vec4(0.0); }";
    else
        header += "{ gl_FragColor = vec4(0.0); }";
    headerlength += 1;
    header += "\n";
    headerlength += 1;

    this.mHeader = header;
    this.mHeaderLength = headerlength;
}

EffectPass.prototype.MakeHeader = function()
{
         if( this.mType==="image" ) this.MakeHeader_Image();
    else if( this.mType==="sound" ) this.MakeHeader_Sound();
    else if( this.mType==="buffer") this.MakeHeader_Buffer();
    else if( this.mType==="common") this.MakeHeader_Common();
    else if( this.mType==="cubemap") this.MakeHeader_Cubemap();
    else console.log("ERROR 4");
}

EffectPass.prototype.Create_Image = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}
EffectPass.prototype.Destroy_Image = function( wa )
{
}

EffectPass.prototype.Create_Buffer = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}

EffectPass.prototype.Destroy_Buffer = function( wa )
{
}

EffectPass.prototype.Create_Cubemap = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
}

EffectPass.prototype.Destroy_Cubemap = function( wa )
{
}

EffectPass.prototype.Create_Common = function( wa )
{
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.MakeHeader();
}
EffectPass.prototype.Destroy_Common = function( wa )
{
}

EffectPass.prototype.Create_Sound = function (wa)
{
    this.MakeHeader();

    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    this.mSampleRate = 44100;
    this.mPlayTime = 60*3;
    this.mPlaySamples = this.mPlayTime*this.mSampleRate;
    this.mBuffer = wa.createBuffer( 2, this.mPlaySamples, this.mSampleRate );

    //-------------------
    this.mTextureDimensions = 512;
    this.mRenderTexture = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D, 
                                                       this.mTextureDimensions, this.mTextureDimensions,
                                                       this.mRenderer.TEXFMT.C4I8,
                                                       this.mRenderer.FILTER.NONE,
                                                       this.mRenderer.TEXWRP.CLAMP, null);
    this.mRenderFBO = this.mRenderer.CreateRenderTarget(this.mRenderTexture, null, null, null, null, false);

    //-----------------------------

    // ArrayBufferView pixels;
    this.mTmpBufferSamples = this.mTextureDimensions*this.mTextureDimensions;
    this.mData = new Uint8Array( this.mTmpBufferSamples*4 );

    this.mPlaying = false;
}

EffectPass.prototype.Destroy_Sound = function( wa )
{
    if( this.mPlayNode!==null ) this.mPlayNode.stop();
    this.mPlayNode = null;
    this.mBuffer = null;
    this.mData = null;

    this.mRenderer.DestroyRenderTarget(this.mRenderFBO);
    this.mRenderer.DestroyTexture(this.mRenderTexture);
}

EffectPass.prototype.Create = function( passType, wa )
{
    this.mType = passType;
    this.mSource = null;

         if( passType==="image" ) this.Create_Image( wa );
    else if( passType==="sound" ) this.Create_Sound( wa );
    else if( passType==="buffer") this.Create_Buffer( wa );
    else if( passType==="common") this.Create_Common( wa );
    else if( passType==="cubemap") this.Create_Cubemap( wa );
    else alert("ERROR 1");
}

EffectPass.prototype.SetName = function (passName)
{
    this.mName = passName;
}

EffectPass.prototype.SetCode = function (src)
{
    this.mSource = src;
}

EffectPass.prototype.Destroy = function( wa )
{
    this.mSource = null;
         if( this.mType==="image" ) this.Destroy_Image( wa );
    else if( this.mType==="sound" ) this.Destroy_Sound( wa );
    else if( this.mType==="buffer") this.Destroy_Buffer( wa );
    else if( this.mType==="common") this.Destroy_Common( wa );
    else if( this.mType==="cubemap") this.Destroy_Cubemap( wa );
    else alert("ERROR 2");
}

EffectPass.prototype.NewShader_Sound = function( shaderCode, commonShaderCodes)
{
    let vsSource = null;

    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for( let i=0; i<commonShaderCodes.length; i++ )
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    this.mSoundShaderCompiled = false;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader_Image = function ( shaderCode, commonShaderCodes )
{
    this.mSupportsVR = false;

    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    return [vsSource, fsSource];


    /*
    let n1 = shaderCode.indexOf("mainVR(");
    let n2 = shaderCode.indexOf("mainVR (");
    let n3 = shaderCode.indexOf("mainVR  (");
    if( n1>0 || n2>0 || n3>0 )
    {
        let vsSourceVR;
        if( this.mIs20 )
            vsSourceVR = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        else
            vsSourceVR = "attribute in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

        let fsSourceVR = this.mHeader;
        for (let i = 0; i < commonShaderCodes.length; i++) {
            fsSourceVR += commonShaderCodes[i];
        }
        fsSourceVR += shaderCode;
        fsSourceVR += this.mImagePassFooterVR;

        let res = this.mRenderer.CreateShader(vsSource, fsSourceVR, preventCache);
        if( res.mResult == false )
        {
            return res.mInfo;
        }
        if( this.mProgramVR != null )
            this.mRenderer.DestroyShader( this.mProgramVR );

        this.mSupportsVR = true;
        this.mProgramVR = res;
    }
    */
}

EffectPass.prototype.NewShader_Cubemap = function( shaderCode, commonShaderCodes )
{
    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }

    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;

    fsSource += shaderCode;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader_Common = function (shaderCode )
{
    let vsSource = null;
    if (this.mIs20)
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader + shaderCode;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader = function ( commonSourceCodes, preventCache, onResolve)
{
    if( this.mRenderer===null ) return;

    let vs_fs = null;

         if( this.mType==="sound"  ) vs_fs = this.NewShader_Sound(   this.mSource, commonSourceCodes );
    else if( this.mType==="image"  ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="buffer" ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="common" ) vs_fs = this.NewShader_Common(  this.mSource,                   );
    else if( this.mType==="cubemap") vs_fs = this.NewShader_Cubemap( this.mSource, commonSourceCodes );
    else { console.log("ERROR 3: \"" + this.mType + "\""); return; }

    let me = this;
    this.mRenderer.CreateShader(vs_fs[0], vs_fs[1], preventCache, false,
        function (worked, info)
        {
            if (worked === true)
            {
                if (me.mType === "sound")
                {
                    me.mSoundShaderCompiled = true;
                }

                me.mCompilationTime = info.mTime;
                me.mError = false;
                me.mErrorStr = "No Errors";
                if (me.mProgram !== null)
                    me.mRenderer.DestroyShader(me.mProgram);
                me.mTranslatedSource = me.mRenderer.GetTranslatedShaderSource(info);
                me.mProgram = info;
            }
            else
            {
                me.mError = true;
                me.mErrorStr = info.mErrorStr;
            }
            onResolve();
        });
}

EffectPass.prototype.DestroyInput = function( id )
{
    if( this.mInputs[id]===null ) return;

    if( this.mInputs[id].mInfo.mType==="texture" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    if( this.mInputs[id].mInfo.mType==="volume" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="webcam" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video.src = "";

        if( this.mInputs[id].video.srcObject!==null )
        {
        let tracks = this.mInputs[id].video.srcObject.getVideoTracks();
        if( tracks ) tracks[0].stop();
        }
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="video" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="music" || this.mInputs[id].mInfo.mType==="musicstream")
    {
        this.mInputs[id].audio.pause();
        this.mInputs[id].audio.mSound.mFreqData = null;
        this.mInputs[id].audio.mSound.mWaveData = null;
        this.mInputs[id].audio = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="cubemap" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="keyboard" )
    {
        //if( this.mInputs[id].globject != null )
          //  this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="mic" )
    {
        this.mInputs[id].mic = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }

    this.mInputs[id] = null;
}

EffectPass.prototype.TooglePauseInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        else
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.audio.mPaused )
        {
            if( inp.loaded )
            {
                inp.audio.play();
            }
            inp.audio.mPaused = false;
        }
        else
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }

    return null;
}

EffectPass.prototype.StopInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused === false )
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused === false )
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.ResumeInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused )
        {
            inp.audio.play();
            inp.audio.mPaused = false;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.RewindInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp==null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.loaded )
        {
            inp.video.currentTime = 0;
        }
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.loaded )
        {
            inp.audio.currentTime = 0;
        }
    }
}

EffectPass.prototype.MuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = true;
        inp.video.mMuted = true;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 0.0;
        inp.audio.mMuted = true;
    }
}

EffectPass.prototype.UnMuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = false;
        inp.video.mMuted = false;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 1.0;
        inp.audio.mMuted = false;
    }
}

EffectPass.prototype.ToggleMuteInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];
    if( inp===null ) return null;

    if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.video.mMuted;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if( inp.audio.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.audio.mMuted;
    }

    return null;
}

EffectPass.prototype.UpdateInputs = function( wa, forceUpdate, keyboard )
{
   for (let i=0; i<this.mInputs.length; i++ )
   {
        let inp = this.mInputs[i];

        if( inp===null )
        {
            if( forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, null, false, 0, 0, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.image, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mPreview, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if( inp.loaded && forceUpdate )
            {
                if( this.mTextureCallbackFun!==null )
                {
                    let img = (assetID_to_cubemapBuferID(inp.mInfo.mID)===-1) ? inp.image[0] : inp.mImage;
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, img, true, 2, 1, -1.0, this.mID );
                }
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:keyboard.mIcon,mData:keyboard.mData}, false, 6, 0, -1.0, this.mID );
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, -1, this.mID );
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
              if( inp.loaded && inp.audio.mPaused === false && inp.audio.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                      inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                  }

                  if (this.mTextureCallbackFun!==null)
                  {
                           if (inp.mInfo.mType === "music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData}, false, 4, 1, inp.audio.currentTime, this.mID);
                      else if (inp.mInfo.mType === "musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData, info: inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                  }
              }
              else if( inp.loaded===false )
              {
                  if (this.mTextureCallbackFun!==null)
                      this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:null}, false, 4, 0, -1.0, this.mID);
              }
        }
        else if( inp.mInfo.mType==="mic" )
        {
              if( inp.loaded && inp.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                      inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
                  }
                  if( this.mTextureCallbackFun!==null )
                      this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave: ((wa==null)?null:inp.mFreqData) }, false, 5, 1, 0, this.mID );
              }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:null}, true, 9, 1, -1.0, this.mID );
            }
        }
    }
}

EffectPass.prototype.Sampler2Renderer = function (sampler)
{
    let filter = this.mRenderer.FILTER.NONE;
    if (sampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
    if (sampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
    let wrap = this.mRenderer.TEXWRP.REPEAT;
    if (sampler.wrap === "clamp") wrap = this.mRenderer.TEXWRP.CLAMP;
    let vflip = false;
    if (sampler.vflip === "true") vflip = true;

    return { mFilter: filter, mWrap: wrap, mVFlip: vflip };
}

EffectPass.prototype.GetSamplerVFlip = function (id)
{
    let inp = this.mInputs[id];
    return inp.mInfo.mSampler.vflip;
}

EffectPass.prototype.GetTranslatedShaderSource = function ()
{
    return this.mTranslatedSource;
}

EffectPass.prototype.SetSamplerVFlip = function (id, str) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = false;
    if (str === "true") filter = true;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, null);
            inp.mInfo.mSampler.vflip = str;
        }
    }
}

EffectPass.prototype.GetAcceptsVFlip = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return false;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return false;
    return true;
}

EffectPass.prototype.GetSamplerFilter = function (id)
{
    let inp = this.mInputs[id];
    if( inp===null) return;
    return inp.mInfo.mSampler.filter;
}

EffectPass.prototype.SetSamplerFilter = function (id, str, buffers, cubeBuffers) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = renderer.FILTER.NONE;
    if (str === "linear") filter = renderer.FILTER.LINEAR;
    if (str === "mipmap") filter = renderer.FILTER.MIPMAP;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0)
            {
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[0], filter, true);
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[1], filter, true);
                inp.mInfo.mSampler.filter = str;
            }
            else
            {
                renderer.SetSamplerFilter(inp.globject, filter, true);
                inp.mInfo.mSampler.filter = str;
            }
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[0], filter, true);
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[1], filter, true);
        inp.mInfo.mSampler.filter = str;
    }
    else if (inp.mInfo.mType === "keyboard")
    {
        inp.mInfo.mSampler.filter = str;
    }
}

EffectPass.prototype.GetAcceptsMipmapping = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetAcceptsLinear = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return true;
    if (inp.mInfo.mType === "musicstream") return true;
    if (inp.mInfo.mType === "mic")  return true;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return true;
    return false;
}

EffectPass.prototype.GetAcceptsWrapRepeat = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return false;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetSamplerWrap = function (id)
{
    return this.mInputs[id].mInfo.mSampler.wrap;
}

EffectPass.prototype.SetSamplerWrap = function (id, str, buffers)
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let restr = renderer.TEXWRP.REPEAT;
    if (str === "clamp") restr = renderer.TEXWRP.CLAMP;

    if (inp === null) 
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "video") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap") 
    {
        if (inp.loaded)
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "webcam") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[0], restr);
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[1], restr);
        inp.mInfo.mSampler.wrap = str;
    }
}


EffectPass.prototype.GetTexture = function( slot )
{
    let inp = this.mInputs[slot];
    if( inp===null ) return null;
    return inp.mInfo;
}

EffectPass.prototype.SetOutputs = function( slot, id )
{
    this.mOutputs[slot] = id;
}

EffectPass.prototype.SetOutputsByBufferID = function( slot, id )
{
    if( this.mType==="buffer" )
    {
        this.mOutputs[slot] = bufferID_to_assetID( id );

        this.mEffect.ResizeBuffer( id, this.mEffect.mXres, this.mEffect.mYres, false );
    }
    else if( this.mType==="cubemap" )
    {
        this.mOutputs[slot] = cubamepBufferID_to_assetID( id );
        this.mEffect.ResizeCubemapBuffer(id, 1024, 1024 );
    }
}

EffectPass.prototype.NewTexture = function( wa, slot, url, buffers, cubeBuffers, keyboard )
{
    var me = this;
    var renderer = this.mRenderer;

    if( renderer===null ) return;

    let texture = null;

    if( url===null || url.mType===null )
    {
        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( this.mTextureCallbackObj, slot, null, true, 0, 0, -1.0, me.mID );
        me.DestroyInput( slot );
        me.mInputs[slot] = null;
        me.MakeHeader();
        return { mFailed:false, mNeedsShaderCompile:false };
    }
    else if( url.mType==="texture" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.image = new Image();
        texture.image.crossOrigin = '';
        texture.image.onload = function()
        {
            let rti = me.Sampler2Renderer(url.mSampler);

            // O.M.G. FIX THIS
            let channels = renderer.TEXFMT.C4I8;
            if (url.mID === "Xdf3zn" || url.mID === "4sf3Rn" || url.mID === "4dXGzn" || url.mID === "4sf3Rr")
                channels = renderer.TEXFMT.C1I8;
            
            texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.image, channels, rti.mFilter, rti.mWrap, rti.mVFlip);

            texture.loaded = true;
            if( me.mTextureCallbackFun!==null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.image, true, 1, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="volume" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mImage = { mData:null, mXres:1, mYres:0, mZres:0 };
        texture.mPreview = new Image();
        texture.mPreview.crossOrigin = '';

	    var xmlHttp = new XMLHttpRequest();
        if( xmlHttp===null ) return { mFailed:true };

        xmlHttp.open('GET', url.mSrc, true);
        xmlHttp.responseType = "arraybuffer";
        xmlHttp.onerror = function()
        {
            console.log( "Error 1 loading Volume" );
        }
        xmlHttp.onload = function()
        {
            let data = xmlHttp.response;
            if (!data ) { console.log( "Error 2 loading Volume" ); return; }

            let file = piFile(data);

            let signature = file.ReadUInt32();
            texture.mImage.mXres = file.ReadUInt32();
            texture.mImage.mYres = file.ReadUInt32();
            texture.mImage.mZres = file.ReadUInt32();
            let binNumChannels = file.ReadUInt8();
            let binLayout = file.ReadUInt8();
            let binFormat = file.ReadUInt16();
            let format = renderer.TEXFMT.C1I8;
                 if( binNumChannels===1 && binFormat===0 )  format = renderer.TEXFMT.C1I8;
            else if( binNumChannels===2 && binFormat===0 )  format = renderer.TEXFMT.C2I8;
            else if( binNumChannels===3 && binFormat===0 )  format = renderer.TEXFMT.C3I8;
            else if( binNumChannels===4 && binFormat===0 )  format = renderer.TEXFMT.C4I8;
            else if( binNumChannels===1 && binFormat===10 ) format = renderer.TEXFMT.C1F32;
            else if( binNumChannels===2 && binFormat===10 ) format = renderer.TEXFMT.C2F32;
            else if( binNumChannels===3 && binFormat===10 ) format = renderer.TEXFMT.C3F32;
            else if( binNumChannels===4 && binFormat===10 ) format = renderer.TEXFMT.C4F32;
            else return;

            let buffer = new Uint8Array(data, 20); // skip 16 bytes (header of .bin)

            let rti = me.Sampler2Renderer(url.mSampler);

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T3D, texture.mImage.mXres, texture.mImage.mYres, format, rti.mFilter, rti.mWrap, buffer);

            if( texture.globject===null )
            {
                console.log( "Error 4: loading Volume" ); 
                return { mFailed:true };
            }

            if (me.mTextureCallbackFun !== null)
            {
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }

            texture.loaded = true;

            // load icon for it
            texture.mPreview.onload = function()
            {
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }
            texture.mPreview.src = url.mPreviewSrc;
        }
        xmlHttp.send("");


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="volume")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="cubemap" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        let rti = me.Sampler2Renderer(url.mSampler);

        if( assetID_to_cubemapBuferID(url.mID)!==-1 )
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 2, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/cubemap00.png";

            this.mEffect.ResizeCubemapBuffer(0, 1024, 1024 );

        }
        else
        {
            texture.image = [ new Image(), new Image(), new Image(), new Image(), new Image(), new Image() ];

            let numLoaded = 0;
            for (var i=0; i<6; i++ )
            {
                texture.image[i].mId = i;
                texture.image[i].crossOrigin = '';
                texture.image[i].onload = function()
                {
                    var id = this.mId;
                    numLoaded++;
                    if( numLoaded===6 )
                    {
                        texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.CUBEMAP, texture.image, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                        texture.loaded = true;
                        if (me.mTextureCallbackFun !== null)
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, texture.image[0], true, 2, 1, -1.0, me.mID);
                    }
                }

                if( i === 0) 
                {
                    texture.image[i].src = url.mSrc;
                } 
                else 
                {
                    let n = url.mSrc.lastIndexOf(".");
                    texture.image[i].src = url.mSrc.substring(0, n) + "_" + i + url.mSrc.substring(n, url.mSrc.length);
                }
            }
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="cubemap")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="webcam" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        texture.video = document.createElement('video');
    	texture.video.width = 320;
    	texture.video.height = 240;
    	texture.video.autoplay = true;
    	texture.video.loop = true;
        texture.mForceMuted = this.mForceMuted;
        texture.mImage = null;

        let rti = me.Sampler2Renderer(url.mSampler);

        var loadImageInsteadOfWebCam = function()
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.mImage, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 7, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/webcam.png";
        }
        
        loadImageInsteadOfWebCam();

        if( typeof navigator.getUserMedia !== "undefined"  && texture.mForceMuted===false )
        {
            texture.video.addEventListener("canplay", function (e)
            {
				try
				{
                    texture.mImage = null;
                    if( texture.globject != null )
                        renderer.DestroyTexture( texture.globject );
					texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
					texture.loaded = true;
                }
                catch(e)
                {
                    loadImageInsteadOfWebCam();
	                alert( 'Your browser can not transfer webcam data to the GPU.');
                }
            } );

            navigator.mediaDevices.getUserMedia( 
                                { "video": { width: 1280, height: 720 }, "audio": false } )
                                .then( function(stream)
                                       {
                                            texture.video.srcObject = stream;
    	                               } )
                                .catch( function(error)
                                        {
                                            loadImageInsteadOfWebCam();
    		                                alert( 'Unable to capture WebCam. Please reload the page.' );
    	                                } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="mic" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mForceMuted = this.mForceMuted;
        texture.mAnalyser = null;
        let num = 512;
        texture.mFreqData = new Uint8Array( num );
        texture.mWaveData = new Uint8Array( num );

        if( wa === null || typeof navigator.getUserMedia === "undefined" )
        {
            if( !texture.mForceMuted ) alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.mForceMuted = true; 
        }

        if( texture.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, num, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)
            texture.loaded = true;
        }
        else
        {
        navigator.getUserMedia( { "audio": true },
                                function(stream)
                                {
                                  texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, null)
                                  texture.mic = wa.createMediaStreamSource(stream);
                                  texture.mAnalyser = wa.createAnalyser();
                                  texture.mic.connect( texture.mAnalyser );
                                  texture.loaded = true;
    	                        },
                                function(error)
                                {
    		                        alert( 'Unable open Mic. Please reload the page.' );
    	                        } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="video" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.video = document.createElement('video');
    	texture.video.loop = true;
        texture.video.preload = "auto";
        texture.video.mPaused = this.mForcePaused;
        texture.video.mMuted = true;//this.mForceMuted;
    	texture.video.muted  = true;//this.mForceMuted;
        if( this.mForceMuted===true )
            texture.video.volume = 0;
    	texture.video.autoplay = false;
        texture.video.hasFalled = false;
        
        let rti = me.Sampler2Renderer(url.mSampler);

        texture.video.addEventListener("canplay", function (e)
        {
            texture.video.play().then( function()
                                       {
                                           texture.video.mPaused = false;

                                           texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                                           texture.loaded = true;
            
                                           if( me.mTextureCallbackFun!=null )
                                               me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.video, true, 3, 1, -1.0, me.mID );
                                        } )
                               .catch( function(error)
                                       {
                                           console.log( error );
                                       }
                                );
        } );

        texture.video.addEventListener( "error", function(e)
        {
               if( texture.video.hasFalled===true ) { alert("Error: cannot load video" ); return; }
               let str = texture.video.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".mp4";
               texture.video.src = str;
               texture.video.hasFalled = true;
        } );

        texture.video.src = url.mSrc;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="music" || url.mType==="musicstream" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.audio = document.createElement('audio');
    	texture.audio.loop = true;
        texture.audio.mMuted = this.mForceMuted;
        texture.audio.mForceMuted = this.mForceMuted;
        texture.audio.muted = this.mForceMuted;
        if( this.mForceMuted===true )
            texture.audio.volume = 0;
        texture.audio.autoplay = false;
        texture.audio.hasFalled = false;
        texture.audio.mPaused = false;
        texture.audio.mSound = {};

        if( this.mForceMuted===false )
        {
            if(url.mType==="musicstream" && SC === null)
            {
                alert( "Shadertoy: Soundcloud could not be reached" );
                texture.audio.mForceMuted = true;
            }
            }

        if( wa === null && this.mForceMuted===false )
        {
            alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.audio.mForceMuted = true;
        }

        if( texture.audio.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null);
            let num = 512;
            texture.audio.mSound.mFreqData = new Uint8Array( num );
            texture.audio.mSound.mWaveData = new Uint8Array( num );
            texture.loaded = true;
        }

        texture.audio.addEventListener( "canplay", function()
        {
            if( texture===null || texture.audio===null ) return;
            if( this.mForceMuted  ) return;
            if( texture.loaded === true ) return;

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)

            texture.audio.mSound.mSource   = wa.createMediaElementSource( texture.audio );
            texture.audio.mSound.mAnalyser = wa.createAnalyser();
            texture.audio.mSound.mGain     = wa.createGain();

            texture.audio.mSound.mSource.connect(   texture.audio.mSound.mAnalyser );
            texture.audio.mSound.mAnalyser.connect( texture.audio.mSound.mGain );
            texture.audio.mSound.mGain.connect(me.mGainNode);

            texture.audio.mSound.mFreqData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );
            texture.audio.mSound.mWaveData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );

            if( texture.audio.mPaused )
            {
                texture.audio.pause();
            }
            else
            {
                texture.audio.play().then( function() {} ).catch( function(e){console.log("error " + e);} );
            }
            texture.loaded = true;
        } );

        texture.audio.addEventListener( "error", function(e)
        {
               if( this.mForceMuted  ) return;

               if( texture.audio.hasFalled===true ) { return; }
               let str = texture.audio.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".ogg";
               texture.audio.src = str;
               texture.audio.hasFalled = true;
        } );

        if( !texture.audio.mForceMuted )
        {
            if(url.mType==="musicstream")
            {
                SC.resolve(url.mSrc, 
                    function(song) 
                    {
                        if( song.streamable===true )
                        {
                            texture.audio.crossOrigin = 'anonymous';
                            texture.audio.src = song.stream_url;
                            texture.audio.soundcloudInfo = song;
                        }
                        else
                        {
                            alert('Shadertoy: Soundcloud 3 - This track cannot be streamed' );
                        }
                    },
                    function(error)
                    {
                        if (me.mTextureCallbackFun!==null)
                        {
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
                        }
                    } );
            } 
            else
            {
                texture.audio.src = url.mSrc;
            }
        }

        if (me.mTextureCallbackFun!==null)
        {
            if (url.mType === "music")            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
            else if (url.mType === "musicstream") me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null, info: texture.audio.soundcloudInfo}, false, 8, 0, -1.0, me.mID);
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="keyboard" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = true;

        texture.keyboard = {};

        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {mImage: keyboard.mIcon, mData: keyboard.mData}, false, 6, 1, -1.0, me.mID );

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="buffer" )
    {
        texture = {};
        texture.mInfo = url;

        texture.image = new Image();
        texture.image.onload = function()
        {
            if( me.mTextureCallbackFun!==null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {texture: texture.image, data:null}, true, 9, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;
        texture.id = assetID_to_bufferID( url.mID );
        texture.loaded = true;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;

        this.mEffect.ResizeBuffer(texture.id, this.mEffect.mXres, this.mEffect.mYres, false );

        this.SetSamplerFilter(slot, url.mSampler.filter, buffers, cubeBuffers, true);
        this.SetSamplerVFlip(slot, url.mSampler.vflip);
        this.SetSamplerWrap(slot, url.mSampler.wrap, buffers);

        this.MakeHeader();
        return returnValue;
    }
    else
    {
        alert( "input type error" );
        return { mFailed: true };
    }

    return { mFailed: true };
}

EffectPass.prototype.Paint_Image = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];

    //------------------------
    
    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];
    let texIsLoaded = [0, 0, 0, 0 ];
    let texID = [ null, null, null, null];

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
            texIsLoaded[i] = 1;
            resos[3*i+0] = 256;
            resos[3*i+1] = 3;
            resos[3*i+2] = 1;
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;

                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                }
            }
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {

                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                texIsLoaded[i] = 0;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    times[i] = 10.0 + time;
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            let id = inp.id;
            if( inp.loaded===true  )
            {
                texID[i] = buffers[id].mTexture[ buffers[id].mLastRenderDone ];
                texIsLoaded[i] = 1;
                resos[3*i+0] = xres;
                resos[3*i+1] = yres;
                resos[3*i+2] = 1;
                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID[i], filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    let prog = this.mProgram;

    //if( vrData!=null && this.mSupportsVR ) prog = this.mProgramVR;

    this.mRenderer.AttachShader(prog);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F("iFrameRate", fps);

    this.mRenderer.SetShaderConstant1F(  "iCh0.time", times[0] );
    this.mRenderer.SetShaderConstant1F(  "iCh1.time", times[1] );
    this.mRenderer.SetShaderConstant1F(  "iCh2.time", times[2] );
    this.mRenderer.SetShaderConstant1F(  "iCh3.time", times[3] );
    this.mRenderer.SetShaderConstant3F(  "iCh0.size", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iCh1.size", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iCh2.size", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iCh3.size", resos[9], resos[10], resos[11] );
    this.mRenderer.SetShaderConstant1I(  "iCh0.loaded", texIsLoaded[0] );
    this.mRenderer.SetShaderConstant1I(  "iCh1.loaded", texIsLoaded[1] );
    this.mRenderer.SetShaderConstant1I(  "iCh2.loaded", texIsLoaded[2] );
    this.mRenderer.SetShaderConstant1I(  "iCh3.loaded", texIsLoaded[3] );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    if( (vrData !== null) && this.mSupportsVR )
    {
        for (let i=0; i<2; i++ )
        {
            let ei = (i===0) ? vrData.mLeftEye : vrData.mRightEye;

            let vp = [i * xres / 2, 0, xres / 2, yres];

            this.mRenderer.SetViewport(vp);

            let fov = ei.mProjection;
            let corA = [ -fov[2], -fov[1], -1.0 ];
            let corB = [  fov[3], -fov[1], -1.0 ];
            let corC = [  fov[3],  fov[0], -1.0 ];
            let corD = [ -fov[2],  fov[0], -1.0 ];
            let apex = [ 0.0, 0.0, 0.0 ];

            let ma = invertFast( ei.mCamera );
            corA = matMulpoint( ma, corA ); 
            corB = matMulpoint( ma, corB ); 
            corC = matMulpoint( ma, corC ); 
            corD = matMulpoint( ma, corD ); 
            apex = matMulpoint( ma, apex ); 

            let corners = [ corA[0], corA[1], corA[2], 
                            corB[0], corB[1], corB[2], 
                            corC[0], corC[1], corC[2], 
                            corD[0], corD[1], corD[2],
                            apex[0], apex[1], apex[2]];

            this.mRenderer.SetShaderConstant3FV("unCorners", corners);
            this.mRenderer.SetShaderConstant4FV("unViewport", vp);

            this.mRenderer.DrawUnitQuad_XY(l1);
        }
    }
    else 
    {
        this.mRenderer.SetViewport([0, 0, xres, yres]);
        this.mRenderer.DrawFullScreenTriangle_XY( l1 );
    }

    this.mRenderer.DettachTextures();
}

EffectPass.prototype.iRenderSound = function(d, callback )
{
    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds() ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    this.mRenderer.SetRenderTarget(this.mRenderFBO);

    this.mRenderer.SetViewport([0, 0, this.mTextureDimensions, this.mTextureDimensions]);
    this.mRenderer.AttachShader(this.mProgram);
    this.mRenderer.SetBlend( false );

    let texID = [null, null, null, null];
    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
    }

    this.mRenderer.AttachTextures(4, texID[0], texID[1], texID[2], texID[3]);

    let l2 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iTimeOffset");
    let l3 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iSampleOffset");
    this.mRenderer.SetShaderConstant4FV("iDate", dates);
    this.mRenderer.SetShaderConstant3FV("iChannelResolution", resos);
    this.mRenderer.SetShaderConstant1F("iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit("iChannel0", 0);
    this.mRenderer.SetShaderTextureUnit("iChannel1", 1);
    this.mRenderer.SetShaderTextureUnit("iChannel2", 2);
    this.mRenderer.SetShaderTextureUnit("iChannel3", 3);

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    //--------------------------------
    let numSamples = this.mTmpBufferSamples;
    let numBlocks = this.mPlaySamples / numSamples;
    for (let j=0; j<numBlocks; j++ )
    {
        let off = j*numSamples;
        
        this.mRenderer.SetShaderConstant1F_Pos(l2, off / this.mSampleRate);
        this.mRenderer.SetShaderConstant1I_Pos(l3, off );
        this.mRenderer.DrawUnitQuad_XY(l1);

        this.mRenderer.GetPixelData(this.mData, 0, this.mTextureDimensions, this.mTextureDimensions);

        callback( off, this.mData, numSamples );
    }

    this.mRenderer.DetachShader();
    this.mRenderer.DettachTextures();
    this.mRenderer.SetRenderTarget(null);
}

EffectPass.prototype.Paint_Sound = function( wa, d )
{
    let bufL = this.mBuffer.getChannelData(0); // Float32Array
    let bufR = this.mBuffer.getChannelData(1); // Float32Array

    this.iRenderSound( d, function(off, data, numSamples)
                         {
                            for( let i=0; i<numSamples; i++ )
                            {
                                bufL[off+i] = -1.0 + 2.0*(data[4*i+0]+256.0*data[4*i+1])/65535.0;
                                bufR[off+i] = -1.0 + 2.0*(data[4*i+2]+256.0*data[4*i+3])/65535.0;
                            }
                         }
                     );
}

EffectPass.prototype.SetUniforms = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    //------------------------
    
    let texID = [ null, null, null, null];

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
        }
        else if( inp.mInfo.mType=="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
    
                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                }
            }

        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
           if( inp.loaded===true )
           { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                times[i] = 10.0 + time;
            }

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = buffers[inp.id].mTexture[ buffers[inp.id].mLastRenderDone ];
                resos[3*i+0] = buffers[inp.id].mResolution[0];
                resos[3*i+1] = buffers[inp.id].mResolution[1];
                resos[3*i+2] = 1;
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    this.mRenderer.AttachShader(this.mProgram);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F(  "iFrameRate", fps );

    this.mRenderer.SetShaderConstant1F(  "iChannel[0].time",       times[0] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[1].time",       times[1] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[2].time",       times[2] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[3].time",       times[3] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[0].resolution", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[1].resolution", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[2].resolution", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[3].resolution", resos[9], resos[10], resos[11] );
}

EffectPass.prototype.ProcessInputs = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
        }
        else if( inp.mInfo.mType==="volume" )
        {
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );
                }
                else if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                if( inp.audio.mForceMuted === true )
                {
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                let id = inp.id;
                let texID = buffers[id].mTexture[ buffers[id].mLastRenderDone ];

                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID, filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
				let id = inp.id;
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }
}

EffectPass.prototype.Paint_Cubemap = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face )
{
    this.ProcessInputs(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
    this.SetUniforms(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    let vp = [0, 0, xres, yres];

    this.mRenderer.SetViewport(vp);

    let corA = [-1.0, -1.0, -1.0];
    let corB = [ 1.0, -1.0, -1.0];
    let corC = [ 1.0,  1.0, -1.0];
    let corD = [-1.0,  1.0, -1.0];
    let apex = [ 0.0,  0.0,  0.0];

         if( face===0 ) { corA=[ 1.0,  1.0,  1.0]; corB=[ 1.0,  1.0, -1.0]; corC=[ 1.0, -1.0, -1.0]; corD=[ 1.0, -1.0,  1.0]; }
    else if( face===1 ) { corA=[-1.0,  1.0, -1.0]; corB=[-1.0,  1.0,  1.0]; corC=[-1.0, -1.0,  1.0]; corD=[-1.0, -1.0, -1.0]; }
    else if( face===2 ) { corA=[-1.0,  1.0, -1.0]; corB=[ 1.0,  1.0, -1.0]; corC=[ 1.0,  1.0,  1.0]; corD=[-1.0,  1.0,  1.0]; }
    else if( face===3 ) { corA=[-1.0, -1.0,  1.0]; corB=[ 1.0, -1.0,  1.0]; corC=[ 1.0, -1.0, -1.0]; corD=[-1.0, -1.0, -1.0]; }
    else if( face===4 ) { corA=[-1.0,  1.0,  1.0]; corB=[ 1.0,  1.0,  1.0]; corC=[ 1.0, -1.0,  1.0]; corD=[-1.0, -1.0,  1.0]; }
    else if( face===5 ) { corA=[ 1.0,  1.0, -1.0]; corB=[-1.0,  1.0, -1.0]; corC=[-1.0, -1.0, -1.0]; corD=[ 1.0, -1.0, -1.0]; }

    let corners = [ corA[0], corA[1], corA[2], 
                    corB[0], corB[1], corB[2], 
                    corC[0], corC[1], corC[2], 
                    corD[0], corD[1], corD[2],
                    apex[0], apex[1], apex[2]];

    this.mRenderer.SetShaderConstant3FV("unCorners", corners);
    this.mRenderer.SetShaderConstant4FV("unViewport", vp);

    this.mRenderer.DrawUnitQuad_XY(l1);

    this.mRenderer.DettachTextures();
}

EffectPass.prototype.Paint = function( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, bufferNeedsMimaps, buffers, cubeBuffers, keyboard, effect )
{
    if( this.mType==="sound" )
    {
        if (this.mSoundShaderCompiled === true)
        {
            // make sure all textures are loaded
            for (let i=0; i<this.mInputs.length; i++ )
            {
                let inp = this.mInputs[i];
                if (inp === null) continue;

                if (inp.mInfo.mType === "texture" && !inp.loaded) return;
                if (inp.mInfo.mType === "cubemap" && !inp.loaded) return;
            }

            this.Paint_Sound(wa, da);
            this.mSoundShaderCompiled = false;
        }
        if (this.mFrame === 0)
        {
            if (this.mPlaying===true)
            {
                this.mPlayNode.disconnect();
                this.mPlayNode.stop();
                this.mPlayNode = null;
            }
            this.mPlaying = true;

            this.mPlayNode = wa.createBufferSource();
            this.mPlayNode.buffer = this.mBuffer;
            this.mPlayNode.connect(this.mGainNode);
            this.mPlayNode.start(0);
        }
        this.mFrame++;
    }
    else if( this.mType==="image" )
    {
        this.mRenderer.SetRenderTarget( null );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );
        this.mFrame++;
    }
    else if( this.mType==="common" )
    {
    }
    else if( this.mType==="buffer" )
    {
        this.mEffect.ResizeBuffer(bufferID, this.mEffect.mXres, this.mEffect.mYres, false );

        let buffer = buffers[bufferID];

        let dstID = 1 - buffer.mLastRenderDone;

        this.mRenderer.SetRenderTarget( buffer.mTarget[dstID] );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }

        // make thumbnail
        //if( this.mTextureCallbackFun != null )
        /*
        {
            this.mRenderer.SetRenderTarget( buffer.mThumbnailRenderTarget );
            let v = [0, 0, buffer.mThumbnailRes[0], buffer.mThumbnailRes[1]];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            this.mRenderer.SetShaderConstant4FV("v", v);
            this.mRenderer.AttachTextures(1, buffer.mTexture[dstID], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);
            this.mRenderer.DettachTextures();
            this.mRenderer.DetachShader();
            this.mRenderer.GetPixelData( new Uint8Array(buffer.mThumbnailBuffer.data.buffer), buffer.mThumbnailRes[0], buffer.mThumbnailRes[1] );
            this.mRenderer.SetRenderTarget(null);
        }
        */
        buffers[bufferID].mLastRenderDone = 1 - buffers[bufferID].mLastRenderDone;
        this.mFrame++;
    }
    else if( this.mType==="cubemap" )
    {
        this.mEffect.ResizeCubemapBuffer(bufferID, 1024, 1024, false );

        let buffer = cubeBuffers[bufferID];

        xres = buffer.mResolution[0];
        yres = buffer.mResolution[1];
        let dstID = 1 - buffer.mLastRenderDone;
        for( let face=0; face<6; face++ )
        {
            this.mRenderer.SetRenderTargetCubeMap( buffer.mTarget[dstID], face );
            this.Paint_Cubemap( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
        }
        this.mRenderer.SetRenderTargetCubeMap( null, 0 );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }
        cubeBuffers[bufferID].mLastRenderDone = 1 - cubeBuffers[bufferID].mLastRenderDone;

        this.mFrame++;
    }
}

EffectPass.prototype.StopOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;
    this.mPlayNode.disconnect();
}

EffectPass.prototype.ResumeOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;

    wa.resume()
    this.mPlayNode.connect( this.mGainNode );
}

EffectPass.prototype.StopOutput_Image = function( wa )
{
}

EffectPass.prototype.ResumeOutput_Image = function( wa )
{
}

EffectPass.prototype.StopOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.StopInput(j);

    if( this.mType==="sound" )
         this.StopOutput_Sound( wa );
    else
         this.StopOutput_Image( wa );
}

EffectPass.prototype.ResumeOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.ResumeInput(j);

    if( this.mType==="sound" )
         this.ResumeOutput_Sound( wa );
    else
         this.ResumeOutput_Image( wa );
}

EffectPass.prototype.GetCompilationTime = function()
{
    return this.mCompilationTime;
}

//============================================================================================================
function Screenshots()
{
    // private
    let mTexture = null;
    let mTarget = null;
    let mXres = 0;
    let mYres = 0;
    let mCubemapToEquirectProgram;
    let mRenderer = null;

    // public
    var me = {};

    me.Initialize = function(renderer)
    {
        mRenderer = renderer;
        let caps = mRenderer.GetCaps();
        let is20 = caps.mIsGL20;

        let vsSourceC, fsSourceC;
        if( is20 )
        {
            vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; out vec4 outColor; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); outColor = texture(t, rd); }";
        }
        else
        {
            vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); gl_FragColor = texture(t, rd); }";
        }

        let compileShader = function (worked, info)
        {
            if (worked === false)
            {
                console.log("Failed to compile cubemap resample shader (" + errorType + "): " + log);
            }
            else
            {
                mCubemapToEquirectProgram = info;
            }
        }
        mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, compileShader);

        return true;
    };

    me.Allocate = function( xres, yres )
    {
        if( xres>mXres || yres>mYres )
        {
            let texture = mRenderer.CreateTexture(mRenderer.TEXTYPE.T2D, xres, yres, mRenderer.TEXFMT.C4F32, mRenderer.FILTER.NONE, mRenderer.TEXWRP.CLAMP, null);
            let target = mRenderer.CreateRenderTarget( texture, null, null, null, null, false);

            if( mXres!==0 )
            {
                mRenderer.DestroyTexture(mTexture);
                mRenderer.DestroyRenderTarget(mTarget);
            }

            mTexture = texture;
            mTarget = target;
            mXres = xres;
            mYres = yres;
        }
    };

    me.GetProgram = function()
    {
        return mCubemapToEquirectProgram;
    };
    me.GetTarget = function()
    {
        return mTarget;
    };

    return me;
};

//============================================================================================================

function Effect(vr, ac, canvas, callback, obj, forceMuted, forcePaused, resizeCallback, crashCallback )
{
    let xres = canvas.width;
    let yres = canvas.height;

    let me = this;
    this.mCanvas = canvas;
    this.mCreated = false;
    this.mRenderer = null;
    this.mAudioContext = ac;
    this.mGLContext = null;
    this.mWebVR = vr;
    this.mRenderingStereo = false;
    this.mXres = xres;
    this.mYres = yres;
    this.mForceMuted = forceMuted;
    if( ac===null ) this.mForceMuted = true;
    this.mForcePaused = forcePaused;
    this.mGainNode = null;
    this.mPasses = [];
    this.mFrame = 0;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mMaxBuffers = 4;
    this.mMaxCubeBuffers = 1;
    this.mMaxPasses = this.mMaxBuffers + 1 + 1 + 1 + 1; // some day decouple passes from buffers (4 buffers + common + Imagen + sound + cubemap)
    this.mBuffers = [];
    this.mCubeBuffers = [];
    this.mScreenshotSytem = null;
    this.mCompilationTime = 0;
    this.mIsLowEnd = piIsMobile();

    this.mGLContext = piCreateGlContext(canvas, false, false, true, false); // need preserve-buffe to true in order to capture screenshots
    if (this.mGLContext === null)
    {
        return;
    }

    canvas.addEventListener("webglcontextlost", function (event)
        {
            event.preventDefault();
            crashCallback();
        }, false);

    this.mRenderer = piRenderer();
    if (!this.mRenderer.Initialize(this.mGLContext))
        return;

    this.mScreenshotSytem = Screenshots();
    if (!this.mScreenshotSytem.Initialize(this.mRenderer))
        return;

    var caps = this.mRenderer.GetCaps();
    this.mIs20 = caps.mIsGL20;
    this.mShaderTextureLOD = caps.mShaderTextureLOD;
    //-------------
    if( ac!==null )
    {   
        this.mGainNode = ac.createGain();
        if( !forceMuted )
        {
            this.mGainNode.connect( ac.destination);
        }
        if (this.mForceMuted )
            this.mGainNode.gain.value = 0.0;
        else
            this.mGainNode.gain.value = 1.0;
    }

    //-------------
    let vsSourceC, fsSourceC;
    if( this.mIs20 )
    {
        vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { outColor = textureLod(t, gl_FragCoord.xy / v.zw, 0.0); }";
    }
    else
    {
        vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; void main() { gl_FragColor = texture2D(t, gl_FragCoord.xy / v.zw, -100.0); }";
    }

    this.mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, function(worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to copy buffers : " + info.mErrorStr);
            else me.mProgramCopy = info;
        });

    let vsSourceD, fsSourceD;
    if( this.mIs20 )
    {
        vsSourceD = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { vec2 uv = gl_FragCoord.xy / v.zw; outColor = texture(t, vec2(uv.x,1.0-uv.y)); }";
    }
    else
    {
        vsSourceD = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; void main() { vec2 uv = gl_FragCoord.xy / v.zw; gl_FragColor = texture2D(t, vec2(uv.x,1.0-uv.y)); }";
    }

    this.mRenderer.CreateShader(vsSourceD, fsSourceD, false, true, function (worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to downscale buffers : " + info.mErrorStr);
            else me.mProgramDownscale = info;
        });


    // set all buffers and cubemaps to null
    for( let i=0; i<this.mMaxBuffers; i++ )
    {
        this.mBuffers[i] = { mTexture: [null, null], 
                             mTarget:  [null, null], 
                             mResolution: [0, 0],
                             mLastRenderDone: 0,
                             mThumbnailRenderTarget: null,
                             mThumbnailTexture: null,
                             mThumbnailBuffer:  null,
                             mThumbnailRes: [0, 0] };
    }

    for( let i=0; i<this.mMaxCubeBuffers; i++ )
    {
        this.mCubeBuffers[i] = { mTexture: [null, null], 
                                mTarget:  [null, null], 
                                mResolution: [0, 0],
                                mLastRenderDone: 0,
                                mThumbnailRenderTarget: null,
                                mThumbnailTexture: null,
                                mThumbnailBuffer:  null,
                                mThumbnailRes: [0, 0] };
    }

    //-------

    let keyboardData = new Uint8Array( 256*3 );
    for (let j=0; j<(256*3); j++ ) { keyboardData[j] = 0; }
    let kayboardTexture = this.mRenderer.CreateTexture( this.mRenderer.TEXTYPE.T2D, 256, 3, this.mRenderer.TEXFMT.C1I8, this.mRenderer.FILTER.NONE, this.mRenderer.TEXWRP.CLAMP, null);
    let keyboardImage = new Image();
    if( callback!==null )
        keyboardImage.src = "/img/keyboard.png"; // don't load PNG if no UI 
    this.mKeyboard = { mData: keyboardData, mTexture: kayboardTexture, mIcon: keyboardImage };

    let iResize = function( xres, yres )
    {
        me.mCanvas.width = xres;
        me.mCanvas.height = yres;
        me.mXres = xres;
        me.mYres = yres;
        me.ResizeBuffers(xres, yres);
        resizeCallback(xres, yres);
    };

    let bestAttemptFallback = function()
    {
        let devicePixelRatio = window.devicePixelRatio || 1;
        let xres = Math.round(me.mCanvas.offsetWidth  * devicePixelRatio) | 0;
        let yres = Math.round(me.mCanvas.offsetHeight * devicePixelRatio) | 0;
        iResize(xres, yres);
    };

    if(!window.ResizeObserver)
    {
        console.log("WARNING: This browser doesn't support ResizeObserver.");
        bestAttemptFallback();
        window.addEventListener("resize", bestAttemptFallback);
    }
    else
    {
        this.mRO = new ResizeObserver( function(entries, observer)
        {
            var entry = entries[0];
            if (!entry['devicePixelContentBoxSize'])
            {
                observer.unobserve(me.mCanvas);
                console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (2)");
                bestAttemptFallback();
                window.addEventListener("resize", bestAttemptFallback);
            }
            else
            {
                let box = entry.devicePixelContentBoxSize[0];
                let xres = box.inlineSize;
                let yres = box.blockSize;
                iResize(xres, yres);
            }
        });
        try
        {
            this.mRO.observe(this.mCanvas, { box: ["device-pixel-content-box"] });
            //this.mRO.observe(this.mCanvas);
        }
        catch (e)
        {
            console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (1)");
            bestAttemptFallback();
            window.addEventListener("resize", bestAttemptFallback);
        }
    }

    this.mCreated = true;
}

Effect.prototype.ResizeCubemapBuffer = function(i, xres, yres )
{
    let oldXres = this.mCubeBuffers[i].mResolution[0];
    let oldYres = this.mCubeBuffers[i].mResolution[1];

    if( this.mCubeBuffers[i].mTexture[0]===null || oldXres !== xres || oldYres !== yres )
    {
        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);
        let target1 = this.mRenderer.CreateRenderTargetCubeMap( texture1, null, false);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target2 = this.mRenderer.CreateRenderTargetCubeMap( texture2, null, false);

        // Store new buffers
        this.mCubeBuffers[i].mTexture = [texture1,texture2], 
        this.mCubeBuffers[i].mTarget =  [target1, target2 ], 
        this.mCubeBuffers[i].mLastRenderDone = 0;
        this.mCubeBuffers[i].mResolution[0] = xres;
        this.mCubeBuffers[i].mResolution[1] = yres;
    }
}

Effect.prototype.ResizeBuffer = function( i, xres, yres, skipIfNotExists )
{
    if( skipIfNotExists && this.mBuffers[i].mTexture[0]===null ) return;

    let oldXres = this.mBuffers[i].mResolution[0];
    let oldYres = this.mBuffers[i].mResolution[1];

    if( oldXres !== xres || oldYres !== yres )
    {
        let needCopy = (this.mBuffers[i].mTexture[0]!==null);

        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[0].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[0].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[1].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[1].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target1 = this.mRenderer.CreateRenderTarget( texture1, null, null, null, null, false);
        let target2 = this.mRenderer.CreateRenderTarget( texture2, null, null, null, null, false);

        if( needCopy )
        {
            let v = [0, 0, Math.min(xres, oldXres), Math.min(yres, oldYres)];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            let vOld = [0, 0, oldXres, oldYres];
            this.mRenderer.SetShaderConstant4FV("v", vOld);

            // Copy old buffers 1 to new buffer
            this.mRenderer.SetRenderTarget(target1);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[0], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Copy old buffers 2 to new buffer
            this.mRenderer.SetRenderTarget(target2);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[1], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Deallocate old memory
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[0]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[0]);
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[1]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[1]);
            //this.mRenderer.DestroyTexture(this.mBuffers[i].thumbnailTexture);
        }

        // Store new buffers
        this.mBuffers[i].mTexture = [texture1,texture2], 
        this.mBuffers[i].mTarget =  [target1, target2 ], 
        this.mBuffers[i].mLastRenderDone = 0;
        this.mBuffers[i].mResolution[0] = xres;
        this.mBuffers[i].mResolution[1] = yres;
    }
}

Effect.prototype.saveScreenshot = function(passid)
{
    let pass = this.mPasses[passid];

    if( pass.mType === "buffer" )
    {
        let bufferID = assetID_to_bufferID( this.mPasses[passid].mOutputs[0] );

        let texture = this.mBuffers[bufferID].mTarget[ this.mBuffers[bufferID].mLastRenderDone ];

        let numComponents = 3;
        let width = texture.mTex0.mXres;
        let height = texture.mTex0.mYres;
        let type = "Float"; // Other options Float, Half, Uint
        let bytes = new Float32Array(width * height * 4 );//numComponents);
        this.mRenderer.GetPixelDataRenderTarget( texture, bytes, width, height );
        let blob = piExportToEXR(width, height, numComponents, type, bytes);

        // Offer download automatically to the user
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "cubemap" )
    {
        let xres = 4096;
        let yres = 2048;
        this.mScreenshotSytem.Allocate( xres, yres );

        let cubeBuffer = this.mCubeBuffers[0];

        let target = this.mScreenshotSytem.GetTarget();
        this.mRenderer.SetRenderTarget( target );

        let program = this.mScreenshotSytem.GetProgram();

        this.mRenderer.AttachShader(program);
        let l1 = this.mRenderer.GetAttribLocation(program, "pos");
        this.mRenderer.SetViewport( [0, 0, xres, yres] );
        this.mRenderer.AttachTextures(1, cubeBuffer.mTexture[ cubeBuffer.mLastRenderDone ], null, null, null);
        this.mRenderer.DrawUnitQuad_XY(l1);
        this.mRenderer.DettachTextures();
        this.mRenderer.SetRenderTarget( null );

        let data = new Float32Array(xres*yres*4);
        this.mRenderer.GetPixelDataRenderTarget( target, data, xres, yres );

        let blob = piExportToEXR(xres, yres, 3, "Float", data );
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "sound" )
    {
        let offset = 0;
        const bits = 16;
        const numChannels = 2;
        let words = new Int16Array(60*pass.mSampleRate*numChannels );

        pass.iRenderSound( new Date(), function(off, data, numSamples)
                                         {
                                            for( let i=0; i<numSamples; i++ )
                                            {
                                                words[offset++] = (data[4*i+0]+256.0*data[4*i+1]) - 32767;
                                                words[offset++] = (data[4*i+2]+256.0*data[4*i+3]) - 32767;
                                            }
                                         }
                                     );

        let blob = piExportToWAV( 60*pass.mSampleRate, pass.mSampleRate, bits, numChannels, words);

        piTriggerDownload("sound.wav", blob);
    }    
}

Effect.prototype.ResizeBuffers = function(xres, yres)
{
    for (let i=0; i<this.mMaxBuffers; i++ )
    {
        this.ResizeBuffer(i, xres, yres, true);
    }
}

Effect.prototype.IsEnabledVR = function ()
{
    if (this.mRenderingStereo) return true;
    return false;
}

Effect.prototype.EnableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( this.mRenderingStereo ) return;

    this.mRenderingStereo = true;
    this.mWebVR.Enable();
}

Effect.prototype.DisableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( !this.mRenderingStereo ) return;

    this.mRenderingStereo = false;
    this.mWebVR.Disable();
}

Effect.prototype.GetTexture = function( passid, slot ) { return this.mPasses[passid].GetTexture( slot ); }
Effect.prototype.NewTexture = function (passid, slot, url) { return this.mPasses[passid].NewTexture( this.mAudioContext, slot, url, this.mBuffers, this.mCubeBuffers, this.mKeyboard ); }
Effect.prototype.SetOutputs = function( passid, slot, url ) { this.mPasses[passid].SetOutputs( slot, url ); }
Effect.prototype.SetOutputsByBufferID = function( passid, slot, id ) { this.mPasses[passid].SetOutputsByBufferID( slot, id ); }
Effect.prototype.GetAcceptsLinear = function (passid, slot) { return this.mPasses[passid].GetAcceptsLinear(slot); }
Effect.prototype.GetAcceptsMipmapping = function (passid, slot) { return this.mPasses[passid].GetAcceptsMipmapping(slot); }
Effect.prototype.GetAcceptsWrapRepeat = function (passid, slot) { return this.mPasses[passid].GetAcceptsWrapRepeat(slot); }
Effect.prototype.GetAcceptsVFlip = function (passid, slot) { return this.mPasses[passid].GetAcceptsVFlip(slot); }
Effect.prototype.SetSamplerFilter = function (passid, slot, str) { this.mPasses[passid].SetSamplerFilter(slot, str, this.mBuffers, this.mCubeBuffers); }
Effect.prototype.GetTranslatedShaderSource = function (passid) { return this.mPasses[passid].GetTranslatedShaderSource(); }
Effect.prototype.GetSamplerFilter = function (passid, slot) { return this.mPasses[passid].GetSamplerFilter(slot); }
Effect.prototype.SetSamplerWrap = function (passid, slot, str) { this.mPasses[passid].SetSamplerWrap(slot, str, this.mBuffers); }
Effect.prototype.GetSamplerWrap = function (passid, slot) { return this.mPasses[passid].GetSamplerWrap(slot); }
Effect.prototype.SetSamplerVFlip = function (passid, slot, str) { this.mPasses[passid].SetSamplerVFlip(slot, str); }
Effect.prototype.GetSamplerVFlip = function (passid, slot) { return this.mPasses[passid].GetSamplerVFlip(slot); }

Effect.prototype.GetHeaderSize = function (passid)
{
    return this.mPasses[passid].mHeaderLength + 
           this.mRenderer.GetShaderHeaderLines(1);
}

Effect.prototype.ToggleVolume = function()
{
    this.mForceMuted = !this.mForceMuted;

    // outp
    if (this.mForceMuted)
        this.mGainNode.gain.value = 0.0;
    else
        this.mGainNode.gain.value = 1.0;

    // inp
    let num = this.mPasses.length;
    for( let j=0; j<num; j++ )
    {
        for( let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            if( this.mForceMuted )
                this.mPasses[j].MuteInput( this.mAudioContext, i );
            else
                this.mPasses[j].UnMuteInput( this.mAudioContext, i );
        }
    }

    return this.mForceMuted;
}

Effect.prototype.SetKeyDown = function( passid, k )
{
    if( this.mKeyboard.mData[ k + 0*256 ] == 255 ) return;

    this.mKeyboard.mData[ k + 0*256 ] = 255;
    this.mKeyboard.mData[ k + 1*256 ] = 255;
    this.mKeyboard.mData[ k + 2*256 ] = 255 - this.mKeyboard.mData[ k + 2*256 ];
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }
}

Effect.prototype.SetKeyUp = function( passid, k )
{
    this.mKeyboard.mData[ k + 0*256 ] = 0;
    this.mKeyboard.mData[ k + 1*256 ] = 0;
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }
}

Effect.prototype.StopOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].StopOutput( wa );
    }
}

Effect.prototype.ResumeOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].ResumeOutput( wa );
    }
}

Effect.prototype.PauseInput = function( passid, id )
{
    return this.mPasses[passid].TooglePauseInput( this.mAudioContext, id );
}

Effect.prototype.ToggleMuteInput = function( passid, id )
{
    return this.mPasses[passid].ToggleMuteInput( this.mAudioContext, id );
}

Effect.prototype.RewindInput = function( passid, id )
{
    this.mPasses[passid].RewindInput( this.mAudioContext, id );
}

Effect.prototype.UpdateInputs = function( passid, forceUpdate )
{
   this.mPasses[passid].UpdateInputs( this.mAudioContext, forceUpdate, this.mKeyboard );
}

Effect.prototype.ResetTime = function()
{
    this.mFrame = 0;
    this.mAudioContext.resume()

    let num = this.mPasses.length;
    for( let i=0; i<num; i++ )
    {
        this.mPasses[i].mFrame = 0;
        for( let j=0; j<this.mPasses[i].mInputs.length; j++ )
            this.mPasses[i].RewindInput(this.mAudioContext, j)
    }
}

Effect.prototype.RequestAnimationFrame = function (id)
{
    if (this.mRenderingStereo && this.mWebVR.IsPresenting())
    {
        this.mWebVR.RequestAnimationFrame(id);
    }
    else
    {
        requestAnimFrame(id);
    }
}

Effect.prototype.Paint = function(time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, isPaused)
{
    let wa = this.mAudioContext;
    let da = new Date();
    let vrData = null; if (this.mRenderingStereo) vrData = this.mWebVR.GetData();
    let xres = this.mXres / 1;
    let yres = this.mYres / 1;

    if( this.mFrame===0 )
    {
        for( let i=0; i<this.mMaxBuffers; i++ )
        {
            if( this.mBuffers[i].mTexture[0]!==null )
            {
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[0] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[1] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
				
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[0] );
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[1] );
            }
        }
        for( let i=0; i<this.mMaxCubeBuffers; i++ )
        {
            if( this.mCubeBuffers[i].mTexture[0]!==null )
            {
                for( let face=0; face<6; face++ )
                {
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[0], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[1], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
					this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[0] );
				    this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[1] );
                }
            }
        }
    }

    let num = this.mPasses.length;

    // render sound first
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "sound" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "buffer" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;
        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="buffer" && inp.id === bufferID && inp.mInfo.mSampler.filter === "mipmap")
                {
                    needMipMaps = true;
                    break;
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render cubemap buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "cubemap" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = 0;//assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;

        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="cubemap" )
                {
                    if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0 && inp.mInfo.mSampler.filter === "mipmap" )
                    {
                        needMipMaps = true;
                        break;
                    }
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render image last
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "image" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }   

    // erase keypresses
    for (let k=0; k<256; k++ )
    {
       this.mKeyboard.mData[ k + 1*256 ] = 0;
    }
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    if( this.mRenderingStereo ) this.mWebVR.Finish();

    this.mFrame++;
}

Effect.prototype.NewShader = function( passid, preventCache, onResolve )
{
    let commonSourceCodes = [];
    for (let i=0; i<this.mPasses.length; i++ )
    {
        if( this.mPasses[i].mType==="common")
        {
            commonSourceCodes.push(this.mPasses[i].mSource);
        }
    }

    this.mPasses[passid].NewShader(commonSourceCodes, preventCache, onResolve );
}

Effect.prototype.GetNumPasses = function()
{
    return this.mPasses.length;
}

Effect.prototype.GetNumOfType = function(passtype)
{
    let id = 0;
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType===passtype )
        {
            id++;
        }
    }
    return id;
}

Effect.prototype.GetPassType = function( id ) { return this.mPasses[id].mType; }
Effect.prototype.GetPassName = function( id ) { return this.mPasses[id].mName; }
Effect.prototype.GetCode = function( id ) { return this.mPasses[id].mSource; }
Effect.prototype.SetCode = function( id, source ) { this.mPasses[id].SetCode(source); }
Effect.prototype.GetError = function (id) { return this.mPasses[id].mError; }
Effect.prototype.GetErrorStr = function (id) { return this.mPasses[id].mErrorStr; }
Effect.prototype.GetErrorGlobal = function()
{
    for (let i = 0; i < this.mPasses.length; i++)
    {
        if (this.mPasses[i].mError)
        {
            return true;
        }
    }
    return false;
}

Effect.prototype.Load = function (jobj )
{
    if (jobj.ver !== "0.1")
    {
        console.log("Wrong Format");
        return false;
    }

    let numPasses = jobj.renderpass.length;

    if( numPasses<1 || numPasses>this.mMaxPasses )
    {
        console.log("Corrupted Shader - " + numPasses);
        return false;
    }

    this.mPasses = [];
    for (let j = 0; j < numPasses; j++)
    {
        let rpass = jobj.renderpass[j];

        // skip sound passes if in thumbnail mode
        if( this.mForceMuted && rpass.type === "sound" ) continue;

        let wpass = new EffectPass(this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                   this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode,
                                   this.mProgramDownscale, j, this);

        wpass.Create(rpass.type, this.mAudioContext);

        let numInputs = rpass.inputs.length;

        for (let i = 0; i < 4; i++)
        {
            wpass.NewTexture(this.mAudioContext, i, null, null, null);
        }
        for (let i = 0; i < numInputs; i++)
        {
            let lid  = rpass.inputs[i].channel;
            let styp = rpass.inputs[i].type;
            let sid  = rpass.inputs[i].id;
            let ssrc = rpass.inputs[i].filepath;
            let psrc = rpass.inputs[i].previewfilepath;
            let samp = rpass.inputs[i].sampler;

            wpass.NewTexture(this.mAudioContext, lid, { mType: styp, mID: sid, mSrc: ssrc, mSampler: samp, mPreviewSrc: psrc }, this.mBuffers, this.mCubeBuffers, this.mKeyboard);
        }

        for (let i = 0; i < 4; i++)
        {
            wpass.SetOutputs(i, null);
        }

        let numOutputs = rpass.outputs.length;
        for (let i = 0; i < numOutputs; i++)
        {
            let outputID = rpass.outputs[i].id;
            let outputCH = rpass.outputs[i].channel;
            wpass.SetOutputs(outputCH, outputID);
        }

        // create some hardcoded names. This should come from the DB
        let rpassName = "";
        if (rpass.type === "common" ) rpassName = "Common";
        if (rpass.type === "sound"  ) rpassName = "Sound";
        if (rpass.type === "image"  ) rpassName = "Image";
        if (rpass.type === "buffer") rpassName = "Buffer " + String.fromCharCode(65 + assetID_to_bufferID(wpass.mOutputs[0]));
        if (rpass.type === "cubemap") rpassName = "Cube A";// " + String.fromCharCode(65 + assetID_to_bufferID(this.mPasses[j].mOutputs[0]));
        wpass.SetName(rpassName);
        wpass.SetCode(rpass.code);

        this.mPasses.push(wpass);
    }
    return true;
}

Effect.prototype.CompileSome = function ( passes, preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    for (let j = 0; j < passes.length; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(passes[j], preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < me.mPasses.length; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.Compile = function (preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(j, preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < numPasses; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.GetCompilationTime = function( id )
{
    return this.mPasses[id].GetCompilationTime()/1000.0;
}
Effect.prototype.GetTotalCompilationTime = function()
{
    return this.mCompilationTime/1000.0;
}

Effect.prototype.DestroyPass = function( id )
{
   this.mPasses[id].Destroy( this.mAudioContext );
   this.mPasses.splice(id, 1);
}

Effect.prototype.AddPass = function( passType, passName, onResolve )
{
    let shaderStr = null;

    if( passType==="sound"   ) shaderStr = "vec2 mainSound( int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n}";
    if( passType==="buffer"  ) shaderStr = "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}";
    if( passType==="common"  ) shaderStr = "vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}";
    if( passType==="cubemap" ) shaderStr = "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rayDir;\n\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}";

    let id = this.GetNumPasses();
    this.mPasses[id] = new EffectPass( this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                       this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode, 
                                       this.mProgramDownscale, id, this );

    this.mPasses[id].Create( passType, this.mAudioContext );
    this.mPasses[id].SetName( passName );
    this.mPasses[id].SetCode( shaderStr );
    this.NewShader(id, false, function ()
    {
        onResolve();
    });

    return { mId : id, mShader : shaderStr };
}

// this should be removed once we have MultiPass 2.0 and passes render to arbitrary buffers
Effect.prototype.IsBufferPassUsed = function( bufferID )
{
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType !== "buffer" ) continue;
        if( this.mPasses[j].mOutputs[0] === bufferID_to_assetID(bufferID) ) return true;
    }
    return false;
}

Effect.prototype.Save = function()
{
    var result = {};

    result.ver = "0.1";

    result.renderpass = [];

    let numPasses = this.mPasses.length;
    for (let j=0; j<numPasses; j++ )
    {
        result.renderpass[j] = {};

        result.renderpass[j].outputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            let outputID = this.mPasses[j].mOutputs[i];
            if( outputID===null ) continue;
            result.renderpass[j].outputs.push( { channel: i, id: outputID } );
        }
        result.renderpass[j].inputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            if( this.mPasses[j].mInputs[i]===null ) continue;
            result.renderpass[j].inputs.push( {channel: i,
                                               type    : this.mPasses[j].mInputs[i].mInfo.mType,
                                               id      : this.mPasses[j].mInputs[i].mInfo.mID,
                                               filepath: this.mPasses[j].mInputs[i].mInfo.mSrc,
                                               sampler : this.mPasses[j].mInputs[i].mInfo.mSampler });
        }

        result.renderpass[j].code = this.mPasses[j].mSource;
        result.renderpass[j].name = this.mPasses[j].mName
        result.renderpass[j].description = "";
        result.renderpass[j].type = this.mPasses[j].mType;
    }

    result.flags = this.calcFlags();

    return result;
}

Effect.prototype.calcFlags = function ()
{
    let flagVR = false;
    let flagWebcam = false;
    let flagSoundInput = false;
    let flagSoundOutput = false;
    let flagKeyboard = false;
    let flagMultipass = false;
    let flagMusicStream = false;

    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        let pass = this.mPasses[j];

        if (pass.mType === "sound") flagSoundOutput = true;
        if (pass.mType === "buffer") flagMultipass = true;

        for (let i = 0; i < 4; i++)
        {
            if (pass.mInputs[i] === null) continue;

            if (pass.mInputs[i].mInfo.mType === "webcam") flagWebcam = true;
            else if (pass.mInputs[i].mInfo.mType === "keyboard") flagKeyboard = true;
            else if (pass.mInputs[i].mInfo.mType === "mic") flagSoundInput = true;
            else if (pass.mInputs[i].mInfo.mType === "musicstream") flagMusicStream = true;
        }

        let n1 = pass.mSource.indexOf("mainVR(");
        let n2 = pass.mSource.indexOf("mainVR (");
        if (n1 > 0 || n2 > 0) flagVR = true;
    }

    return {
        mFlagVR: flagVR,
        mFlagWebcam: flagWebcam,
        mFlagSoundInput: flagSoundInput,
        mFlagSoundOutput: flagSoundOutput,
        mFlagKeyboard: flagKeyboard,
        mFlagMultipass: flagMultipass,
        mFlagMusicStream: flagMusicStream
    };
}</script>
    <script>"use strict"

const kMaxCompileTime = 10.0;

function iReportCrash(shaderID)
{
    let req = new XMLHttpRequest();
    req.onload = function ()
    {
        let jsn = req.response;
        if (jsn === null) return;
        if (jsn.result === 0)
        {
            // yep
        }
    };
    req.open("POST", "/shadertoy", true);
    req.responseType = "json";
    req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    req.send( "s=" + shaderID + "&r=2" );
}
</script>
    <script>"use strict"

var gActive = -1;
var mShaders = [];
var gNumCanvases = 0;

function myrefresh( id, slot, img, forceFrame, gui, guiID, renderID, time )
{
    if( mShaders[id].mReady===false ) return;
    if( forceFrame )
    {
        if (mShaders[id].mScreenshot === false)
        {
            mShaders[id].gEffect.Paint(mShaders[id].mTime / 1000.0, 1.0 / 60.0, 60.0, 0, 0, 0, 0, false);
        }
    }
}

function startRendering()
{
    if( gActive<0 ) return;
    if( mShaders[gActive].mReady===false ) return;
    if( mShaders[gActive].mScreenshot===true ) return;

    let time = getRealTime();

    mShaders[gActive].mFPS.Count( time );
    mShaders[gActive].mTime = mShaders[gActive].mTime0 + (time - mShaders[gActive].mTo);
    let dtime = 1000.0/60.0;
    mShaders[gActive].gEffect.Paint( mShaders[gActive].mTime/1000.0, dtime/1000.0, mShaders[gActive].mFPS.GetFPS(), 0,0,0,0, false);

    requestAnimFrame( startRendering );
}

function iLoadAndCompile(jsn, i )
{
    var shaderObj = jsn[i];
    if (shaderObj === null) return;

    var resizeCB = function (xres, yres) { myrefresh(i, 0, null, true, false, 0, -1.0) };
    var crashCB = function () { alert('crash');/*iReportCrash(gShaderIDs[i])*/ };
    mShaders[i].gEffect = new Effect(null, null, mShaders[i].mPreview.mCanvas, myrefresh, i, true, true, resizeCB, crashCB);

    if (!mShaders[i].gEffect.Load(shaderObj)) return;

    mShaders[i].gEffect.Compile(false, function (worked)
    {
        if (worked === true)
        {
            previewShowRender(mShaders[i].mPreview);

            mShaders[i].mScreenshot = false;
            mShaders[i].mReady = true;
            mShaders[i].mTime = 10.0 * 1000.0;
            mShaders[i].mTime0 = 0.0;
            mShaders[i].mTo = 0.0;
            mShaders[i].mFPS = piCreateFPSCounter();
            mShaders[i].mPreview.mCanvas.addEventListener("mouseout", function (ev) { gActive = -1; }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseover", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.add('isVisible'); }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseout", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.remove('isVisible'); }, true);
            mShaders[i].mPreview.mCanvas.addEventListener("mouseover", function (ev)
            {
                let ele = piGetSourceElement(ev);
                if (ele.mId === undefined) return;

                gActive = ele.mId;
                if (!mShaders[gActive].mReady) return;
                let time = getRealTime();
                mShaders[gActive].mTo = time;
                mShaders[gActive].mTime0 = mShaders[gActive].mTime;
                mShaders[gActive].mFPS.Reset(time);

                startRendering();
            }, true);


            /*
            let compilationTime = mShaders[i].gEffect.GetTotalCompilationTime();
            if (compilationTime > kMaxCompileTime)
            {
                iReportCrash(mShaders[i].mShaderID);
            }*/

            myrefresh(i, null, null, true, false, 0, -1.0);
        }
        else
        {
            mShaders[i].mReady = false;
            previewShowError(mShaders[i].mPreview);
        }
    });
};


function iProcessShader( jsn, i )
{
    var shaderObj = jsn[i];
    if( shaderObj===null ) return;

    if ((shaderObj.info.usePreview === 0 && !gUseScreenshots) || (mShaders[i].mPreviewReady !== 1))
    {
        iLoadAndCompile(jsn, i);
    }
    else
    {
        mShaders[i].mScreenshot = true;
        if( shaderObj.info.usePreview === 1 )
            previewShowScreenshot(mShaders[i].mPreview, 1); // comp
        else if (gUseScreenshots)
            previewShowScreenshot(mShaders[i].mPreview, 2); // sett
    }

    if( i<(jsn.length-1) ) setTimeout( function(){iProcessShader(jsn,i+1);}, 10 );
}

function iInitUI(numCanvases, uiCallback, windowTitle)
{
    gNumCanvases = numCanvases;
    document.getElementById("mySearch").focus();

    //-----------------------------------------------------------------
    // window
    //-----------------------------------------------------------------
    if (windowTitle !== null) {
        document.title = windowTitle;
    }

    //-----------------------------------------------------------------
    // ui
    //-----------------------------------------------------------------
    var num = Math.min(gShaders.length, gNumCanvases);

    //var base = document.getElementsByClassName( "searchResult" );

    for (let i = 0; i < gNumCanvases; i++)
    {
        let pv = createPreview(i);

        if (i >= num) {
            previewHide(pv);
            continue;
        }

        let shaderID = gShaders[i].info.id;
        
        if (pv.mUI !== null && uiCallback !== null) {
            pv.mUI.addEventListener('click', function (ev) {
                uiCallback(shaderID);
                ev.preventDefault();
            }, false);
        }
        
        previewShowLoading(pv);
        
        mShaders[i] = {};
        mShaders[i].mShaderID = shaderID;
        mShaders[i].mPreview = pv;
        mShaders[i].mScreenshot = false;
        mShaders[i].mPreview.mLink.href = "/view/" + shaderID;
        mShaders[i].mPreviewReady = 0;
        mShaders[i].mReady = false;
        mShaders[i].gEffect = null;

        previewLoadScreenshot(mShaders[i].mPreview,
            function () { mShaders[i].mPreviewReady = 1; if (mShaders[i].mReady === false) previewShowScreenshot(mShaders[i].mPreview, 0); },
            function () { mShaders[i].mPreviewReady = 2; },
            shaderID);
    }

    if (num <= 0) {
        return;
    }
}

function iInitShaders(jsn)
{
    for (let i = 0; i < jsn.length; i++)
    {
        let shaderObj = jsn[i];
        if (shaderObj === null) continue;
        let inf = shaderObj.info;
        mShaders[i].mPreview.mTextA.textContent = inf.name;
        mShaders[i].mPreview.mTextB.innerHTML = "<a class='user' href='/user/" + htmlEntities(inf.username) + "'>" + htmlEntities(inf.username) + "</a>";
        mShaders[i].mPreview.mTextC.innerHTML = "<img src='/img/themes/" + gThemeName + "/views.png' class='viewsIcon'></img>" + inf.viewed + "    &nbsp;&nbsp;  <img src='/img/themes/" + gThemeName + "/likes.png' class='likesIcon'></img>" + inf.likes;
    }

    setTimeout(function () { iProcessShader(jsn, 0); }, 10);
}

function resultsInitStatic(numCanvases, uiCallback, windowTitle)
{
    iInitUI(numCanvases, uiCallback, windowTitle);

    iInitShaders(gShaders);
}

function resultsInit(numCanvases, uiCallback, windowTitle)
{	
    iInitUI(numCanvases, uiCallback, windowTitle);

    var num = Math.min(gShaderIDs.length, gNumCanvases);

    var mHttpReq = new XMLHttpRequest();

    mHttpReq.abort();

    var str = "{ \"shaders\" : [";
    for( let i=0; i<num; i++ )
    {
         str += "\"" + gShaderIDs[i] + "\"";
         if( i!==(num-1) ) str += ", ";
    }
    str += "] }";

    str = "s=" + encodeURIComponent( str ) + "&nt=0&nl=0&np=0";

    mHttpReq.open( "POST", "/shadertoy", true );
    mHttpReq.responseType = "json";
    mHttpReq.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    mHttpReq.onload = function ()
    {
        let jsn = this.response;
        if( jsn===null )
        {
            console.log( "Could not load shaders" );
            return;
        }

        iInitShaders(jsn);
    }
    mHttpReq.send( str );
}</script>
    <style>
    .shaderPreview
    {
    display: block;
    background-color: #000000;
    background-image: url("/img/loading.gif");
    background-repeat: no-repeat;
    background-position: center;
    padding: 0px;
    margin: 0px;
    border: 0px solid #000000;
    border-radius: 8px;
    width:100%;
    height:100%;
    position: absolute;
    overflow:hidden;
    }

    .previewInfo
    {
    width: 100%;
    left: 0px;
    top: 2px;
    position: relative;
    visibility: hidden;
    }

    .previewCanvas
    {
    left: 0px;
    top: 0px;
    padding: 0px;
    margin: 0px;
    position: absolute;
    cursor: pointer;
    width:100%;
    height:100%;
    border-radius: 8px;
    border: 0px solid #000000;
    backgroundColor: transparent;
visibility: hidden;
opacity:0;
transition: opacity 1.0s ease;
    }

    .previewText
    {
        text-overflow: ellipsis;
    white-space: nowrap;
    padding-right: 1px;
    }

    .previewTextUser
    {
    text-overflow: ellipsis;
    white-space: nowrap;
    padding-left: 3px;
    }

    .previewStats
    {
    padding-right: 1px;
    right: 0px;
    top: 0px;
    position: absolute;
    }

    .previewErrorContainer
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    visibility:hidden;
    }

    .previewErrorMessage
    {
    top:50%;
    position:absolute;
    width:100%;
    text-align:center;
    padding:0;
    margin:auto;
    color:#ff0000;
    font-size:2em;
    font-style:italic;
    }

    .previewNoGLContainter
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    position:absolute;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    pointer-events:none;
    visibility:hidden;
    font-size:2em;
    }

    .previewNoGLMessage
    {
    width:86%;
    height:90%;
    padding-left:7%;
    padding-right:7%;
    padding-top:10%;
    padding-bottom:0px;
    color:#ff0000;
    position:absolute;
    visibility:hidden;
    }

    .previewThumbnailContainer
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    visibility:hidden;
    border-radius:8px;
    border:0px solid #000000;
    }

    .previewThumbnailImage
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    border-radius:8px;
    border:0px solid #000000;
opacity: 0.0;
transition: opacity 1.0s ease;
    }

    .previewThumbnailIcon
    {
    width:64px;
    height:32px;
    left:0px;
    top:0px;
    padding:0px;
    padding-top:12px;
    margin:0px;
    position:absolute;
    color:#ffffff;
    background-color:#ff8020;
    font-weight:bold;
    border-radius:0px 0px 8px 0px;
    text-align:center;
    //visibility:hidden;
    }


    .previewUIContainter
    {
    display: block;
    right:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    //cursor:pointer;
    //pointer-events:none;
    //visibility:hidden;
    }
</style>

<script>
    function previewHide(me)
    {
    me.mBase.style.visibility = "hidden";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";
    }

    function previewShowRender(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "visible";
me.mCanvas.style.opacity = 1.0;
    me.mCanvas.style.borderRadius ="8px;";
//  me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    }

    function previewShowScreenshot(me, message)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "visible";
me.mThumbnailImg.style.opacity = 1.0;
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    me.mThumbnailWar1.style.visibility = (message===1)?"visible":"hidden";
    me.mThumbnailWar2.style.visibility = (message===2)?"visible":"hidden";
    }

    function previewShowLoading(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";

    me.mLink.style.visibility = "visible";
    me.mBase.style.backgroundColor = "#ff0000;"
    me.mCont.style.visibility = "visible";
    }

    function previewShowNoWebGL(me, shaderID)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "visible";
    me.mError.style.visibility = "visible";
    me.mThumbnailImgNoWebGL.onerror = function(ev) 
                                      { 
                                            me.mThumbnailImgNoWebGL.style.visibility="hidden"; 
                                            me.mMessageNoWebGL.style.visibility="visible"; 
                                      };
    me.mThumbnailImgNoWebGL.src = "/media/shaders/" + shaderID + ".jpg";
    }

    function previewShowError(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "visible";
    me.mCont.style.visibility = "visible";
    }

    function previewLoadScreenshot( me, cbSuccess, cbError, shaderID )
    {
    var url = "/media/shaders/" + shaderID + ".jpg";
    me.mThumbnailImg.onload = cbSuccess;
    me.mThumbnailImg.onerror = function(ev) { cbError(); };
    me.mThumbnailImg.src = url;
    }
        
    function createPreview(id)
    {
        var bar = document.getElementById( "Preview_"+id+"_Canvas" );
        bar.width = bar.offsetWidth;
        bar.height = bar.offsetHeight;
        bar.mId = id;

        return { mBase: document.getElementById( "Preview_"+id+"_Container" ),
        mLink: document.getElementById( "Preview_"+id+"_Link" ),
        mCanvas: bar,
        mCont: document.getElementById( "Preview_"+id+"_Info" ),
        mTextA: document.getElementById( "Preview_"+id+"_Text" ),
        mTextB: document.getElementById( "Preview_"+id+"_TextUser" ),
        mTextC: document.getElementById( "Preview_"+id+"_Stats" ),
        mNoWebGL: document.getElementById( "Preview_"+id+"_NoWebGL" ),
        mError: document.getElementById( "Preview_"+id+"_Error" ),
        mCanvas2D: document.getElementById( "Preview_"+id+"_Thumnail" ),
        mThumbnailImg: document.getElementById( "Preview_"+id+"_ThumnailImage" ),
        mThumbnailWar1: document.getElementById( "Preview_"+id+"_ThumnailWarning1" ),
        mThumbnailWar2: document.getElementById( "Preview_"+id+"_ThumnailWarning2" ),
        mThumbnailImgNoWebGL: document.getElementById( "Preview_"+id+"_ThumnailImageNoWebGL" ),
        mMessageNoWebGL: document.getElementById( "Preview_"+id+"_MessageNoWebGL"),
        mUI: document.getElementById( "Preview_"+id+"_UI" )
        };
    }
</script>

    <style>

    div#shaderGrid
    {
        width:100%;
        padding:0px;
        margin:0px;
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        grid-template-rows: repeat(3, 1fr);
        grid-column-gap: 64px;
        grid-row-gap: 24px;
    }
    .searchResult
    {
        margin: 0px;
        padding: 0px;
        width: 100%;
    }
    .searchResultContainer
    {
        width: 100%;
        padding-bottom:56.25%;
        height: 0;
        position: relative;
    }
    .navigation
    {
        display:flex;
        align-items:center;
    }
    div#navBottom
    {
        display:none;
        justify-content:center;
    }
    a.pageButtons, .pageButtonsCurrent
    {
        border-style: solid;
        border-width: 1px;
        border-color: #808080;
        text-align: center;
        vertical-align: middle;
        margin-left: 12px;
        display: inline-block;
        border-radius: 4px;
		font-weight:bold;
        cursor: pointer;
        padding-bottom:5px;
        padding-top:4px;
        padding-left: 8px;
        padding-right: 8px;
        margin:8px;
    }
    a.pageButtons
    {
        text-decoration: none;
        -moz-transition:    background-color 0.15s linear, color 0.15s linear;
        -webkit-transition: background-color 0.15s linear, color 0.15s linear;
        transition:         background-color 0.15s linear, color 0.15s linear;
    }
    a.pageButtons:hover
    {
      background-color:#808080;
      color : #ff8020;
    }
    .pageButtonsCurrent
    {
        background-color: #808080;
        color:#000000;
    }
    div#controls
    {
        width:100%;
        padding-top:16px;
        padding-bottom:16px;
        display:flex;
        justify-content:space-between; 
        flex-wrap:wrap;
    }
    div#controls > div
    {
        display:inline-flex;
    }
    .controlOptions
    {
        display:inline-block;
    }

    /* ----------------------- media resolutions ------------------------ */

    @media screen and (max-width:799px) 
    {
        div#shaderGrid  { grid-template-columns: 1fr; grid-template-rows: repeat(12, 1fr); grid-column-gap: 0px; grid-row-gap: 16px; }
        div#controls
        {
            width:100%;
            display:flex;
            justify-content:flex-start; 
            flex-wrap:wrap;
        }
        div#controls > div
        {
            display:inline-flex;
            width:100%;
            margin-left: 0px;
            margin-right: 0px;
            padding-bottom:16px;
        }
        div#navBottom
        {
            display: flex;
        }
    }
    
    </style>
    <script>
    var gShaders=[{"ver":"0.1","info":{"id":"XsSSzD","date":"1409348200","viewed":14453,"name":"Alien Thorns","username":"Dave_Hoskins","description":"3D voronoi cells twisted into each other. I Managed to get the texture to move with the voronoi objects. They also slowly change colour.","likes":51,"published":3,"flags":8,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"\/media\/a\/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"\/media\/ap\/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRn","filepath":"\/media\/a\/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"\/media\/ap\/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"\/media\/a\/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"\/media\/ap\/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Alien Thorns\n\/\/ Dave Hoskins\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/#define MOUSE_SCUB\n\n#define PRECISION 0.02\n\n#define MOD3 vec3(.0631,.07369,.08787)\n\nvec3 sunDir = normalize(vec3(-.3, 0.6, .8));\n\nfloat time;\n\n\/\/--------------------------------------------------------------------------------------------------\nvec3 TexCube(in vec3 p, in vec3 n )\n{\n    p *= .5;\n\tvec3 x = textureLod( iChannel0, p.yz, 0.0 ).xyz;\n\tvec3 y = textureLod( iChannel1, p.zx, 0.0 ).xyz;\n\tvec3 z = textureLod( iChannel2, p.xy, 0.0 ).xyz;\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\n\/\/--------------------------------------------------------------------------------------------------\nvec4 ThornVoronoi( vec3 p, out float which)\n{\n    \n    vec2 f = fract(p.xz);\n    p.xz = floor(p.xz);\n\tfloat d = 1.0e10;\n    vec3 id = vec3(0.0);\n    \n\tfor (int xo = -1; xo <= 1; xo++)\n\t{\n\t\tfor (int yo = -1; yo <= 1; yo++)\n\t\t{\n            vec2 g = vec2(xo, yo);\n            vec2 n = textureLod(iChannel3,(p.xz + g+.5)\/256.0, 0.0).xy;\n            n = n*n*(3.0-2.0*n);\n            \n\t\t\tvec2 tp = g + .5 + sin(p.y + 1.2831 * (n * time*.5)) - f;\n            float d2 = dot(tp, tp);\n\t\t\tif (d2 < d)\n            {\n                \/\/ 'id' is the colour code for each thorn\n                d = d2;\n                which = n.x+n.y*3.0;\n                id = vec3(tp.x, p.y, tp.y);\n            }\n\t\t}\n\t}\n\n    return vec4(id, 1.35-pow(d, .17));\n}\n\n\n\/\/--------------------------------------------------------------------------------------------------\nfloat MapThorns( in vec3 pos)\n{\n    float which;\n\treturn pos.y * .21 - ThornVoronoi(pos, which).w  - max(pos.y-5.0, 0.0) * .5 + max(pos.y-5.5, 0.0) * .8;\n}\n\n\/\/--------------------------------------------------------------------------------------------------\nvec4 MapThornsID( in vec3 pos, out float which)\n{\n    vec4 ret = ThornVoronoi(pos, which);\n\treturn vec4(ret.xyz, pos.y * .21 - ret.w - max(pos.y-5.0, 0.0) * .5 + max(pos.y-5.5, 0.0) * .8);\n}\n\n\/\/--------------------------------------------------------------------------------------------------\nfloat Hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract(p3.x * p3.y * p3.z);\n}\n\n\/\/--------------------------------------------------------------------------------------------------\nvec4 Raymarch( in vec3 ro, in vec3 rd, in vec2 uv, in vec2 fragCoord, out float which)\n{\n\tfloat maxd = 40.0;\n\t\n    vec4 h = vec4(1.0);\n    float t = 0.+ Hash12(fragCoord.xy)*.2;\n    vec3 p;\n    for (int i = 0; i < 110; i++)\n    {\n        p = ro + rd * t;\n        if(h.w < PRECISION || t > maxd || p.y > 12.0 ) break;\n\t    h = MapThornsID(p, which);\n        t += h.w * .5 + min(t*.002, .03);\n    }\n\n    if (t > maxd || p.y > 8.0)\tt = -1.0;\n    \n    return vec4(h.xyz, t);\n}\n\n\/\/--------------------------------------------------------------------------------------------------\nvec3 Normal( in vec3 pos )\n{\n    vec2 eps = vec2(PRECISION, 0.0);\n\treturn normalize( vec3(\n           MapThorns(pos+eps.xyy) - MapThorns(pos-eps.xyy),\n           MapThorns(pos+eps.yxy) - MapThorns(pos-eps.yxy),\n           MapThorns(pos+eps.yyx) - MapThorns(pos-eps.yyx) ) );\n\n}\n\n\/\/--------------------------------------------------------------------------\nfloat FractalNoise(in vec2 xy)\n{\n\tfloat w = 1.5;\n\tfloat f = 0.0;\n    xy *= .08;\n\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tf += texture(iChannel2, .5+xy * w, -99.0).x \/ w;\n\t\tw += w;\n\t}\n\treturn f*.8;\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 GetClouds(in vec3 sky, in vec3 cameraPos, in vec3 rd)\n{\n    \/\/if (rd.y < 0.0) return vec3(0);\n\t\/\/ Uses the ray's y component for horizon fade of fixed colour clouds...\n\tfloat v = (70.0-cameraPos.y)\/rd.y;\n\trd.xz = (rd.xz * v + cameraPos.xz+vec2(0.0,0.0)) * 0.004;\n\tfloat f = (FractalNoise(rd.xz) -.5);\n\tvec3 cloud = mix(sky, vec3(.4, .2, .2), max(f, 0.0));\n   \treturn cloud;\n}\n\n\/\/\n\/\/--------------------------------------------------------------------------------------------------\nfloat Shadow( in vec3 ro, in vec3 rd, float mint)\n{\n    float res = 1.0;\n    float t = .15;\n    for( int i=0; i < 15; i++ )\n    {\n        float h = MapThorns(ro + rd*t);\n\t\th = max( h, 0.0 );\n        res = min( res, 4.0*h\/t );\n        t+= clamp( h*.6, 0.05, .1);\n\t\tif(h < .001) break;\n    }\n    return clamp(res,0.05,1.0);\n}\n\n\/\/--------------------------------------------------------------------------------------------------\nvec3 Path( float time )\n{\n\treturn vec3(1.3+ 17.2*cos(0.2-0.5*.33*time*.75), 4.7, 7.- 16.2*sin(0.5*0.11*time*.75) );\n}\n\n\/\/--------------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 q = fragCoord.xy \/ iResolution.xy;\n\tvec2 p = (-1.0 + 2.0*q)*vec2(iResolution.x \/ iResolution.y, 1.0);\n\t\n    \/\/ Camera...\n    #ifdef MOUSE_SCUB\n\tfloat off = iMouse.x*1.0*iMouse.x\/iResolution.x;\n    #else\n    float off = 0.;\n    #endif\n\ttime =173.0+iTime + off;\n\tvec3 ro = Path( time+0.0 );\n    \n\tvec3 ta = Path( time+5.2 );\n    float add = (sin(time*.3)+1.0)*2.0;\n    ro.y+= add;\n    ta.y -= add;\n\tta.y *= 1.0+sin(3.0+0.12*time) * .5;\n\tfloat roll = 0.3*sin(0.07*time);\n\t\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = (cross(cu,cw));\n\t\n\tfloat r2 = p.x*p.x*0.32 + p.y*p.y;\n    p *= (7.0-sqrt(37.5-11.5*r2))\/(r2+1.0);\n\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.1*cw );\n\n\tvec3 col \t\t= mix(vec3(.3, .3, .5), GetClouds(vec3(0.), ro, rd),\tpow(abs(rd.y), .5));\n    vec3 background = mix(vec3(.3, .3, .5), vec3(.0), \t\t\t\t\t\tpow(abs(rd.y), .5));\n\n\tfloat sun = clamp( dot(rd, sunDir), 0.0, 1.0 );\n\tfloat which;\n\tvec4 ret = Raymarch(ro, rd, q, fragCoord, which);\n    \n    if(ret.w > 0.0)\n\t{\n\t\tvec3 pos = ro + ret.w*rd;\n\t\tvec3 nor = Normal(pos);\n\t\tvec3 ref = reflect(rd, nor);\n\t\t\n\t\tfloat s = clamp( dot( nor, sunDir ), 0.0, 1.0 );\n\t\t\n        float sha = 0.0; if( s>0.01) sha = Shadow(pos, sunDir, 0.05);\n\t\tvec3 lin = s*vec3(1.0,.9,.8) * sha;\n\t\tlin += background*(max(nor.y, 0.0)*.2);\n\n\t\tcol = TexCube(ret.xyz, nor);\n        vec3 wormCol =  clamp(abs(fract(which * 1.5 + vec3(1.0, 2.0 \/ 3.0, 1.0 \/ 3.0)) * 6.0 - 3.0) -1.0, 0.0, 1.0);\n        \n\t\tcol = lin * col * (.7 + wormCol * .6);\n        col += vec3(1.0, .6, 1.0)*pow(clamp( dot( ref, sunDir ), 0.0, 1.0 ), 10.0) * sha;\n\t\t\n\t\tcol = mix( col, background, 1.0-exp(-0.002*ret.w*ret.w) );\n\t}\n\n    col += vec3(.4,.25,.25)*pow( sun, 20.0 )*4.0*clamp( (rd.y+0.4) \/ .2,0.0,1.0);\n    \/\/ Gamma & colour adjust...\n\tcol = pow(col, vec3(.45, .45, .5));\n    \/\/ Border shading...\n    col *= 0.5 + 0.5*pow( 52.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2 );\n\n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsfGRr","channel":0}],"code":"#define PI 3.14159265359\n\n#define MOD3 vec3(.0631,.07369,.08787)\nfloat gTime;\n\n\/\/--------------------------------------------------------------------------------------------------\nvec2 Hash2(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3.zxy, p3.yxz+19.19);\n    return fract(vec2(p3.x * p3.y, p3.z*p3.x));\n}\n\n\/\/--------------------------------------------------------------------------------------------------\nvec2 Noise( in vec2 x )\n{\n    return mix(Hash2(floor(x)), Hash2(floor(x)+1.0), fract(x));\n}\n\nfloat Saw(float n, float fil)\n{\n\tfloat v = 0.0;\n\tfloat f = 1.0;\n    int filt = int(fil);\n    \n\tfor (int i = 0; i < 100; i++)\n\t{\n        if (i > filt) break;\n        float a = .5*(sin(2.0*f*n * PI) \/ f);\n        if (i > filt-filt\/10) a = 2.5 * a;\n        v += a;\n        \n\t\tf++;\n\t}\n\treturn v* 2000.0 \/ (fil+1000.0);\n}\n\n\nvec2 Hash( vec2 n)\n{\n\tvec4 p = texture( iChannel0, n*vec2(.78271, .32837), -100.0 );\n    return (p.xy + p.zw) * .5; \n}\n\n\/\/--------------------------------------------------------------------------\nvec2 Noise2D( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 res = mix(mix( Hash(p + 0.0), Hash(p + vec2(1.0, 0.0)),f.x),\n                   mix( Hash(p + vec2(0.0, 1.0) ), Hash(p + vec2(1.0, 1.0)),f.x),f.y);\n    return res-.5;\n}\n\n\/\/--------------------------------------------------------------------------\nvec2 FBM( vec2 p )\n{\n    vec2 f;\n\tf  = 0.5000\t * Noise2D(p); p = p * 2.32;\n\tf += 0.2500  * Noise2D(p); p = p * 2.23;\n\tf += 0.1250  * Noise2D(p); p = p * 2.31;\n    f += 0.0625  * Noise2D(p); p = p * 2.28;\n    f += 0.03125 * Noise2D(p);\n    return f;\n}\n\n\n\/\/--------------------------------------------------------------------------------------------------\nvec4 ThornVoronoi( vec3 p)\n{\n    \n    vec2 f = fract(p.xz);\n    p.xz = floor(p.xz);\n\tfloat d = 1.0e10;\n    vec3 id = vec3(0.0);\n    \n\tfor (int xo = -1; xo <= 1; xo++)\n\t{\n\t\tfor (int yo = -1; yo <= 1; yo++)\n\t\t{\n            vec2 g = vec2(xo, yo);\n            vec2 n = texture(iChannel3,(p.xz + g+.5)\/256.0, -100.0).xy;\n            n = n*n*(3.0-2.0*n);\n            \n\t\t\tvec2 tp = g + .5 + sin(p.y + 1.2831 * (n * gTime*.5)) - f;\n            float d2 = dot(tp, tp);\n\t\t\tif (d2 < d)\n            {\n                \/\/ 'id' is the colour code for each thorn\n                d = d2;\n\n                id = vec3(tp.x, p.y, tp.y);\n            }\n\t\t}\n\t}\n\n    return vec4(id, 1.35-pow(d, .17));\n}\n\n\n\/\/--------------------------------------------------------------------------------------------------\nfloat MapThorns( in vec3 pos )\n{\n\treturn pos.y * .21 - ThornVoronoi(pos).w  - max(pos.y-5.0, 0.0) * .5 + max(pos.y-5.5, 0.0) * .8;\n}\n\n\/\/--------------------------------------------------------------------------------------------------\nvec3 Path( float time )\n{\n\t\treturn vec3(1.3+ 17.2*cos(0.2-0.5*.33*time*.75), 4.7, 7.6 - 16.2*sin(0.5*0.11*time*.75) );\n}\n\/\/--------------------------------------------------------------------------------------------------\nvec2 mainSound( in int samp,float time)\n{\n    gTime = time+173.0;\n\t\n    vec3 ro = Path(gTime+.0);\n    vec3 ta = Path(gTime + 5.2);\n    float add = (sin(gTime*.3)+1.0)*2.0;\n     ro.y+= add;\n    ta.y -= add;\n    \n    vec3 cw = normalize(ta-ro);\t\t\/\/ Point down movement line\n\tvec3 cp = vec3(0.0, 1.0, 0.0);\t\/\/ Up vector\n    vec3 cu = (cross(cw, cp));\t\t\/\/ Cross product to get the right ear direction\n    \n    vec2 ears;\n    ears.x = abs(MapThorns(ro+cu*.1)) * .8;\n    ears.y = abs(MapThorns(ro-cu*.1)) * .8;\n    \n    vec2 gain = vec2(0.0);\n    gain = clamp(1. - ears, 0.0, 1.0);\n    gain = pow(gain, vec2(3.9));\n    \n    float fil1 = sin(gTime*.521)* 50.0 + 60.0;\n    float fil2 = -sin(gTime*.474)* 50.0 + 60.0;\n    vec2 audio;\n    audio.x = gain.x * (Saw(11.125*time, fil1) + Saw(22.2*time, fil1));\n    audio.y = gain.y * (Saw(11.125*time, fil2) + Saw(22.3*time, fil2));\n    vec2 pos = vec2(gTime * (192.017331), gTime * (182.066927));\n    pos -= sin((gTime*.143))*20.0 * (gain.x+gain.y);\n    audio += FBM(pos) * Saw(gTime*10.5 -sin(gTime * .2)* 8.0, 30.0) ;\n    \n    return clamp(audio, -1.0, 1.0) * smoothstep(180.0, 175.0, time);\n}","name":"Sound","description":"","type":"sound"}]},{"ver":"0.1","info":{"id":"Mt3GWs","date":"1472322663","viewed":14384,"name":"Structured Vol Sampling","username":"huwb","description":"New volume sampling algorithm for the camera-in-volume case which eliminates aliasing. Click to turn off. Works by placing samples on set of world planes. See comments for links to diagram, github repos.","likes":242,"published":1,"flags":0,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/\n\/\/ For diagram shader showing how samples are taken:\n\/\/\n\/\/ https:\/\/www.shadertoy.com\/view\/ll3GWs\n\/\/\n\/\/ We are in the process of writing up this technique. The following github repos\n\/\/ is the home of this research.\n\/\/\n\/\/ https:\/\/github.com\/huwb\/volsample\n\/\/\n\/\/ \n\/\/\n\/\/ Additional credits - this scene is mostly mash up of these two amazing shaders:\n\/\/\n\/\/ Clouds by iq: https:\/\/www.shadertoy.com\/view\/XslGRr\n\/\/ Cloud Ten by nimitz: https:\/\/www.shadertoy.com\/view\/XtS3DD\n\/\/ \n\n#define SAMPLE_COUNT 40\n#define PERIOD 1.\n\n\/\/ mouse toggle\nbool STRUCTURED;\n\n\/\/ cam moving in a straight line\nvec3 sundir;\n\n\/\/ LUT based 3d value noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = textureLod( iChannel0, (uv+ 0.5)\/256.0, 0.0 ).yx;\n    return mix( rg.x, rg.y, f.z );\n}\n\n\nvec4 map( in vec3 p )\n{\n\tfloat d = 0.1 + .8 * sin(0.6*p.z)*sin(0.5*p.x) - p.y;\n\n    vec3 q = p;\n    float f;\n    \n    f  = 0.5000*noise( q ); q = q*2.02;\n    f += 0.2500*noise( q ); q = q*2.03;\n    f += 0.1250*noise( q ); q = q*2.01;\n    f += 0.0625*noise( q );\n    d += 2.75 * f;\n\n    d = clamp( d, 0.0, 1.0 );\n    \n    vec4 res = vec4( d );\n    \n    vec3 col = 1.15 * vec3(1.0,0.95,0.8);\n    col += vec3(1.,0.,0.) * exp2(res.x*10.-10.);\n    res.xyz = mix( col, vec3(0.7,0.7,0.7), res.x );\n    \n    return res;\n}\n\n\n\/\/ to share with unity hlsl\n#define float2 vec2\n#define float3 vec3\n#define fmod mod\nfloat mysign( float x ) { return x < 0. ? -1. : 1. ; }\nfloat2 mysign( float2 x ) { return float2( x.x < 0. ? -1. : 1., x.y < 0. ? -1. : 1. ) ; }\n\n\/\/ compute ray march start offset and ray march step delta and blend weight for the current ray\nvoid SetupSampling( out float2 t, out float2 dt, out float2 wt, in float3 ro, in float3 rd )\n{\n    if( !STRUCTURED )\n    {\n        dt = float2(PERIOD,PERIOD);\n        t = dt;\n        wt = float2(0.5,0.5);\n        return;\n    }\n    \n    \/\/ the following code computes intersections between the current ray, and a set\n    \/\/ of (possibly) stationary sample planes.\n    \n    \/\/ much of this should be more at home on the CPU or in a VS.\n    \n    \/\/ structured sampling pattern line normals\n    float3 n0 = (abs( rd.x ) > abs( rd.z )) ? float3(1., 0., 0.) : float3(0., 0., 1.); \/\/ non diagonal\n    float3 n1 = float3(mysign( rd.x * rd.z ), 0., 1.); \/\/ diagonal\n\n    \/\/ normal lengths (used later)\n    float2 ln = float2(length( n0 ), length( n1 ));\n    n0 \/= ln.x;\n    n1 \/= ln.y;\n\n    \/\/ some useful DPs\n    float2 ndotro = float2(dot( ro, n0 ), dot( ro, n1 ));\n    float2 ndotrd = float2(dot( rd, n0 ), dot( rd, n1 ));\n\n    \/\/ step size\n    float2 period = ln * PERIOD;\n    dt = period \/ abs( ndotrd );\n\n    \/\/ dist to line through origin\n    float2 dist = abs( ndotro \/ ndotrd );\n\n    \/\/ raymarch start offset - skips leftover bit to get from ro to first strata lines\n    t = -mysign( ndotrd ) * fmod( ndotro, period ) \/ abs( ndotrd );\n    if( ndotrd.x > 0. ) t.x += dt.x;\n    if( ndotrd.y > 0. ) t.y += dt.y;\n\n    \/\/ sample weights\n    float minperiod = PERIOD;\n    float maxperiod = sqrt( 2. )*PERIOD;\n    wt = smoothstep( maxperiod, minperiod, dt\/ln );\n    wt \/= (wt.x + wt.y);\n}\n\nvec4 raymarch( in vec3 ro, in vec3 rd )\n{\n    vec4 sum = vec4(0, 0, 0, 0);\n    \n    \/\/ setup sampling - compute intersection of ray with 2 sets of planes\n    float2 t, dt, wt;\n\tSetupSampling( t, dt, wt, ro, rd );\n    \n    \/\/ fade samples at far extent\n    float f = .6; \/\/ magic number - TODO justify this\n    float endFade = f*float(SAMPLE_COUNT)*PERIOD;\n    float startFade = .8*endFade;\n    \n    for(int i=0; i<SAMPLE_COUNT; i++)\n    {\n        if( sum.a > 0.99 ) continue;\n\n        \/\/ data for next sample\n        vec4 data = t.x < t.y ? vec4( t.x, wt.x, dt.x, 0. ) : vec4( t.y, wt.y, 0., dt.y );\n        \/\/ somewhat similar to: https:\/\/www.shadertoy.com\/view\/4dX3zl\n        \/\/vec4 data = mix( vec4( t.x, wt.x, dt.x, 0. ), vec4( t.y, wt.y, 0., dt.y ), float(t.x > t.y) );\n        vec3 pos = ro + data.x * rd;\n        float w = data.y;\n        t += data.zw;\n        \n        \/\/ fade samples at far extent\n        w *= smoothstep( endFade, startFade, data.x );\n        \n        vec4 col = map( pos );\n        \n        \/\/ iqs goodness\n        float dif = clamp((col.w - map(pos+0.6*sundir).w)\/0.6, 0.0, 1.0 );\n        vec3 lin = vec3(0.51, 0.53, 0.63)*1.35 + 0.55*vec3(0.85, 0.57, 0.3)*dif;\n        col.xyz *= lin;\n        \n        col.xyz *= col.xyz;\n        \n        col.a *= 0.75;\n        col.rgb *= col.a;\n\n        \/\/ integrate. doesn't account for dt yet, wip.\n        sum += col * (1.0 - sum.a) * w;\n    }\n\n    sum.xyz \/= (0.001+sum.w);\n\n    return clamp( sum, 0.0, 1.0 );\n}\n\nvec3 sky( vec3 rd )\n{\n    vec3 col = vec3(0.);\n    \n    float hort = 1. - clamp(abs(rd.y), 0., 1.);\n    col += 0.5*vec3(.99,.5,.0)*exp2(hort*8.-8.);\n    col += 0.1*vec3(.5,.9,1.)*exp2(hort*3.-3.);\n    col += 0.55*vec3(.6,.6,.9);\n    \n    float sun = clamp( dot(sundir,rd), 0.0, 1.0 );\n    col += .2*vec3(1.0,0.3,0.2)*pow( sun, 2.0 );\n    col += .5*vec3(1.,.9,.9)*exp2(sun*650.-650.);\n    col += .1*vec3(1.,1.,0.1)*exp2(sun*100.-100.);\n    col += .3*vec3(1.,.7,0.)*exp2(sun*50.-50.);\n    col += .5*vec3(1.,0.3,0.05)*exp2(sun*10.-10.); \n    \n    float ax = atan(rd.y,length(rd.xz))\/1.;\n    float ay = atan(rd.z,rd.x)\/2.;\n    float st = texture( iChannel0, vec2(ax,ay) ).x;\n    float st2 = texture( iChannel0, .25*vec2(ax,ay) ).x;\n    st *= st2;\n    st = smoothstep(0.65,.9,st);\n    col = mix(col,col+1.8*st,clamp(1.-1.1*length(col),0.,1.));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ click mouse to use naive raymarching\n    STRUCTURED = iMouse.z <= 0.;\n    sundir = normalize(vec3(-1.0,0.0,-1.));\n\n    vec2 q = fragCoord.xy \/ iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x\/ iResolution.y;\n    vec2 mo = -1.0 + 2.0*iMouse.xy \/ iResolution.xy;\n   \n    \/\/ camera\n    vec3 lookDir = vec3(cos(.53*iTime),0.,sin(iTime));\n    vec3 camVel = vec3(-20.,0.,0.);\n\n    vec3 ro = vec3(0.,1.5,0.) + iTime*camVel;\n    vec3 ta = ro + lookDir; \/\/vec3(ro.x, ro.y, ro.z-1.);\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    float fov = 1.;\n    vec3 rd = normalize( fov*p.x*uu + fov*1.2*p.y*vv + 1.5*ww );\n    \n    \/\/ divide by forward component to get fixed z layout instead of fixed dist layout\n    \/\/vec3 rd_layout = rd\/mix(dot(rd,ww),1.0,samplesCurvature);\n    vec4 clouds = raymarch( ro, rd );\n    \n    vec3 col = clouds.xyz;\n        \n    \/\/ sky if visible\n    if( clouds.w <= 0.99 )\n\t    col = mix( sky(rd), col, clouds.w );\n    \n\tcol = clamp(col, 0., 1.);\n    col = smoothstep(0.,1.,col);\n\tcol *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.12 ); \/\/Vign\n        \n    fragColor = vec4( col, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"MsVfz1","date":"1527860847","viewed":14371,"name":"Neon Lit Hexagons","username":"Shane","description":"A simple raymarched hexagon scene with some neon elements.","likes":290,"published":3,"flags":0,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"\/media\/a\/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"\/media\/ap\/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/*\n\tNeon Lit Hexagons\n\t-----------------\n\n\tI needed a break from a few technical shaders I've beem hacking away at, so I finished an old \n\tgeometric example that'd been sitting on the blocks for a while.\n\t\n\t3D hexagon tech imagery is a bit of a cliche, but I've always been a fan. Most tend to be high \n\tquality pathtraced renderings, but since this is a realtime raymarched example, I had to make \n\ta lot of concessions. The glowing neon lights were inspired by some of Shau's examples, some\n\tonline imagery, and practically half the demos out there. :)\n\n\tI tried to create the glowing effect without the use of a volumetric pass, but my eyes weren't\n\taccepting the results, which meant the observant people on here -- pretty much everyone -- would \n\tnotice immediately, so I put a relatively cheap one in. The improvements were immediate, but it\n\twas at the cost of rendering speed... I'm just hoping no one notices the lack of reflections from \n\tthe neon lights. :) I have a pretty quick laptop, but ever since the WebGL 2 update, it hasn't \n\tenjoyed compiling extra passes, so reflections had to go. At a later stage, I might attempt to \n\tfake them in some way.\n\n\tThere are a couple of surface detail defines below that I had to leave out. I also came pretty \n\tclose to greebling the surfaces, but figured that might be overkill. In the end, I took the \n\t\"less is more\" approach. However, I intend to put together a greebled surface pretty soon.\n\n\n    \/\/ Other neon-looking examples:\n\n\t\/\/ Shau has a heap of bright glowing examples, but here's a few.\n\tOTT - shau\n\thttps:\/\/www.shadertoy.com\/view\/4sVyDd\n\n\t43% Burnt - shau\n\thttps:\/\/www.shadertoy.com\/view\/XljBWW\n\n\tAngle Grinder - shau\n\thttps:\/\/www.shadertoy.com\/view\/XtsfWX\n\n\n    \/\/ Great example.\n\tNeon World - zguerrero\n    https:\/\/www.shadertoy.com\/view\/MlscDj\n\n*\/\n\n\n\n\/\/ Hexagon: 0, Dodecahedron: 1, Circle: 2.\n\/\/ Squares, stars, etc, are possible too, but I didn't include those.\n#define SHAPE 0\n\n\n\/\/ Details usually make a scene more interesting. In this case, however, they seemed a\n\/\/ little expensive, so I left them out.\n\/\/\n\/\/ I wanted to include the grooves, at least, but I figured speed on slower machines was\n\/\/ more important.\n\/\/#define ADD_DETAIL_GROOVE \n\/\/#define ADD_DETAIL_BOLT\n\n\/\/ Animating the neon lights, or not. I find them a little too distracting, \n\/\/ so the default is \"off.\"\n\/\/#define ANIMATE_LIGHTS\n\n\/\/ If Borg green is more your thing. :)\n\/\/#define GREEN_GLOW\n\n\/\/ Maximum ray distance.\n#define FAR 50.\n\n\/\/ Standard 2D rotation formula.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\/\/ vec2 to float hash.\nfloat hash21(vec2 p){\n   \n    float n = dot(p, vec2(7.163, 157.247)); \n    return fract(sin(n)*43758.5453);\n}\n\n\/\/ vec3 to float hash.\nfloat hash31(vec3 p){\n   \n    float n = dot(p, vec3(13.163, 157.247, 7.951)); \n    return fract(sin(n)*43758.5453); \n}\n\n\n\/\/ Commutative smooth maximum function. Provided by Tomkh, and taken \n\/\/ from Alex Evans's (aka Statix) talk: \n\/\/ http:\/\/media.lolrus.mediamolecule.com\/AlexEvans_SIGGRAPH-2015.pdf\n\/\/ Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)\/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n\/*\n\/\/ Commutative smooth minimum function. Provided by Tomkh, and taken \n\/\/ from Alex Evans's (aka Statix) talk: \n\/\/ http:\/\/media.lolrus.mediamolecule.com\/AlexEvans_SIGGRAPH-2015.pdf\n\/\/ Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)\/k);\n   return min(a, b) - k*.25*f*f;\n}\n\n*\/\n\n\/*\n\/\/ Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - .2)*7., .001); \/\/ n = max(abs(n), .001), etc.\n    n \/= (n.x + n.y + n.z );  \n    \n\tvec3 tx = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    \n    return tx*tx;\n}\n*\/\n\n\/\/ Tri-Planar blending function. Based on an old Nvidia writeup:\n\/\/ GPU Gems 3 - Ryan Geiss: https:\/\/developer.nvidia.com\/gpugems\/GPUGems3\/gpugems3_ch01.html\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){\n    \n    \/\/ We only want positive normal weightings. The normal is manipulated to suit\n    \/\/ your needs.\n    n = max(abs(n) - .2, .001); \/\/ n = max(n*n - .1, .001), etc.\n    \/\/n \/= dot(n, vec3(1)); \/\/ Rough renormalization approximation.\n    n \/= length(n); \/\/ Renormalizing.\n    \n\tvec3 tx = texture(t, p.yz).xyz; \/\/ Left and right sides.\n    vec3 ty = texture(t, p.zx).xyz; \/\/ Top and bottom.\n    vec3 tz = texture(t, p.xy).xyz; \/\/ Front and back.\n    \n    \/\/ Blending the surrounding textures with the normal weightings. If the surface is facing\n    \/\/ more up or down, then a larger \"n.y\" weighting would make sense, etc.\n    \/\/\n    \/\/ Textures are stored in sRGB (I think), so you have to convert them to linear space \n    \/\/ (squaring is a rough approximation) prior to working with them... or something like that. :)\n    \/\/ Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n    \n}\n\n\/\/ More concise, self contained version of IQ's original 3D noise function.\nfloat noise3D(in vec3 p){\n    \n    \/\/ Just some random figures, analogous to stride. You can change this, if you want.\n\tconst vec3 s = vec3(113, 157, 1);\n\t\n\tvec3 ip = floor(p); \/\/ Unique unit cell ID.\n    \n    \/\/ Setting up the stride vector for randomization and interpolation, kind of. \n    \/\/ All kinds of shortcuts are taken here. Refer to IQ's original formula.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tp -= ip; \/\/ Cell's fractional component.\n\t\n    \/\/ A bit of cubic smoothing, to give the noise that rounded look.\n    p = p*p*(3. - 2.*p);\n    \n    \/\/ Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\n    \/\/ then interpolating along X. There are countless ways to randomize, but this is\n    \/\/ the way most are familar with: fract(sin(x)*largeNumber).\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\t\n    \/\/ Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    \/\/ Interpolating along Z, and returning the 3D noise value.\n    float n = mix(h.x, h.y, p.z); \/\/ Range: [0, 1].\n\t\n    return n;\/\/abs(n - .5)*2.;\n}\n\n\/\/ Simple fBm to produce some clouds.\nfloat fbm(in vec3 p){\n    \n    \/\/ Four layers of 3D noise.\n    \/\/p \/= 1.5;\n    \/\/p -= vec3(0, 0, iTime*1.);\n    return 0.5333*noise3D( p ) + 0.2667*noise3D( p*2.02 ) + 0.1333*noise3D( p*4.03 ) + 0.0667*noise3D( p*8.03 );\n\n}\n\n\n\n\/\/ The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ \n\n    \/\/return vec2(0);\n    \n    \/\/return vec2(sin(z * 0.15)*2.4, cos(z * 0.075)*.15); \n    \n    return vec2(sin(z * 0.15)*2.4, 0);\n}\n\n\n\n\n\/\/\/\/\/\/\n\/\/float objID, svObjID;\n\n\/\/ Helper vector. If you're doing anything that involves regular triangles or hexagons, the\n\/\/ 30-60-90 triangle will be involved in some way, which has sides of 1, sqrt(3) and 2.\nconst vec2 s = vec2(.866025, 1);\/\/const vec2 s = vec2(1, 1.7320508); \/\/\n\n\n\/\/ The 2D hexagonal isosuface function: If you were to render a horizontal line and one that\n\/\/ slopes at 60 degrees, mirror, then combine them, you'd arrive at the following.\nfloat hex(in vec2 p){\n    \n    \/\/return length(p);\n    p = abs(p);\n    \n    \/\/ Below is equivalent to:\n    return max(p.x*.866025 + p.y*.5, p.y); \n\n    \/\/return max(dot(p, s*.5), p.x); \/\/ Hexagon.\n    \n}\n\n\/*\n\/\/ More accurate formula, but involves more operations and didn't improve quality by any\n\/\/ significant amount, so I've used the estimation below.\nfloat hexPylon(vec2 p2, float pz, float r, float ht){\n\n    vec3 p = vec3(p2.x, pz, p2.y);\n    \n    \/\/ Note the \"*1.5\" You need to take the minimum of\n    \/\/ long-sided rectangles, not squares. Squares will give\n    \/\/ you a dodecahedron.\n    vec3 b = vec3(r*1.5, ht, r); \n    \n    \/\/p.xz = abs(p.xz);\n    \/\/p.xz = vec2(p.x*.866025 + p.z*.5, p.z);\n    \n    b -= .015;\n    \/\/p.xz = r2(-3.14159\/3.)*q.xz;\n  \tfloat d1 = length(max(abs(p) - b, 0.));\n    p.xz = r2(6.2831\/3.)*p.xz;\n    float d2 = length(max(abs(p) - b, 0.));\n\n    p.xz = r2(6.2831\/3.)*p.xz;\n    float d3 = length(max(abs(p) - b, 0.));    \n    return max(max(d1, d2), d3) - .015;\n}\n*\/\n\n\/*\n\/\/ Signed distance to a regular hexagon -- using IQ's more exact method.\nfloat sdHexagon(in vec2 p, in float r){\n    \n  const vec3 k = vec3(-.8660254, .5, .57735); \/\/ pi\/6: cos, sin, tan.\n\n  \/\/ X and Y reflection.\n  p = abs(p);\n  p -= 2.*min(dot(k.xy, p), 0.)*k.xy;\n    \n  \/\/ Polygon side.\n  return length(p - vec2(clamp(p.x, -k.z*r, k.z*r), r))*sign(p.y - r);\n    \n}\n\n\/\/ IQ's extrusion formula, with a bit of rounding (the .015 bit) thrown in.\nfloat opExtrusion(in float sdf, in float pz, in float h)\n{\n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x,w.y), 0.) + length(max(w + .015, 0.)) - .015;\n}\n\n\/\/ A technically correct hexagonal pylon formual.\nfloat hexPylon(vec2 p2, float pz, float r, float ht){\n    \n    float hex = sdHexagon(p2, r);\n    return opExtrusion(hex, pz, ht);\n}\n*\/\n\n\/\/ Normally, I'd say this is the hexagonal pylon distance function. However, I should \n\/\/ probably make the distinction between a fully bonafide distance function and something\n\/\/ that estimates it. This is a bound of sorts. There's not a great deal between it and \n\/\/ the real thing, but it does exhibit different behaviour away from the surface, which \n\/\/ can affect things like shadows, etc. However, as you can see, in this situation, you\n\/\/ can't really tell. I figured I'd mention this, because myself and others use a lot of\n\/\/ these kind of functions.\n\/\/\n\/\/ By the way, a more exact formula is commented out above.\n\/\/\n\/\/ Hexagonal pylon field. There's also defines for a dodecahedron and a cylinder.\nfloat hexPylon(vec2 p2, float pz, float r, float ht){\n\n    vec3 p = vec3(p2.x, pz, p2.y);\n    vec3 b = vec3(r, ht, r);\n    \n    \n    #if SHAPE == 0\n    \/\/ Hexagon.\n    p.xz = abs(p.xz);\n    p.xz = vec2(p.x*.866025 + p.z*.5, p.z);\n    \/\/ The \".015\" is a subtle rounding factor. Zero gives sharp edges,\n    \/\/ and larger numbers give a more rounded look.\n  \treturn length(max(abs(p) - b + .015, 0.)) - .015;\n    #elif SHAPE == 1\n    \/\/ Dodecahedron.\n    p.xz = abs(p.xz);\n    p2 = p.xz*.8660254 + p.zx*.5;\n    p.xz = vec2(max(p2.x, p2.y), max(p.z, p.x));\n    \/\/ The \".015\" is a subtle rounding factor. Zero gives sharp edges,\n    \/\/ and larger numbers give a more rounded look.\n  \treturn length(max(abs(p) - b + .015, 0.)) - .015;\n    #else\n    \/\/ Cylinder -- IQ's cylinder function, to be precise, so I think this particular\n    \/\/ function is a proper distance field.\n    p.xy = abs(vec2(length(p.xz), p.y)) - b.xy + .015;\n    return min(max(p.x, p.y), 0.) + length(max(p.xy, 0.)) - .015;\n    #endif\n    \n    \n}\n \n\n\n\/\/ IDs for the neon lights. Added at the last minute. Identifying things can be tiresome. Individual \n\/\/ objects need to be identified, and sometimes, objects within objects need identification too.\n\/\/ In this case, there are four pylon groupings. Each pylon object contains a neon light object that \n\/\/ is either on or off.\n\/\/ \n\/\/ If you're seting IDs withing the distance function, they can be lost when calling things like the \n\/\/ \"normal\" function, etc. Therefore, you need extra variables to save the IDs directly after calling \n\/\/ the trace function. Then there's the matter of ID sorting, which should be done outside the loop... \n\/\/ Even with a \"struct,\" or something to that effect, it can still be messy. Having said that, I might \n\/\/ start trying to streamline and formalize the process.\nvec4 litID;\nfloat svLitID;\n\n\/\/ The pylon and light distance field.\n\/\/ Variables in order: p.xz, p.y, radius, height, ID, direction (unused).\nfloat objDist(vec2 p, float pH, float r, float ht, inout float id, float dir){\n    \n    \/\/ Neon light height: Four levels, plus the height is divided by two.\n    const float s = 1.\/16.; \/\/1.\/4.\/2.*.5; \n\n    \/\/ Main hexagon pylon.\n    float h1 = hexPylon(p, pH, r, ht);\n    \n    #ifdef ADD_DETAIL_GROOVE\n    \/\/ I like this extra detail, but it was a little too expensive.\n\th1 = max(h1, -hexPylon(p, pH + ht, r - .06, s\/4.)); \/\/ Extra detail.\n    #endif\n    \n    #ifdef ADD_DETAIL_BOLT\n    \/\/ An alternative extra detail. Also a little on the expensive side.\n    h1 = min(h1, hexPylon(p, pH, .1, ht + s\/4.)); \/\/ Extra detail.\n    #endif\n\n    \n    \n    \/\/ Thin hexagon slab -- sitting just below the top of the main hexagon. It's\n    \/\/ lit differently to represent the neon portion.\n    float h2 = hexPylon(p, pH + ht - s, r + .01, s\/3.);\n    \n     \n    \/\/ Opens a space around the neon lit hexagon. Used, if the radius of \"h2\" is\n    \/\/ less that \"h1,\" which isn't the case here.\n    \/\/h1 = smax(h1, -(abs(pH + ht - s) - s\/3.), .015);\n    \n    \/\/ Identifying the main hexagon pylon or the neon lit portion.\n    id = h1<h2? 0. : 1.;\n    \n    \/\/ Return the closest object.\n    return min(h1, h2);\n    \n}\n\n\/\/ Height field for the hexagon.\nfloat hexHeight(vec2 p){\n    \n    \/\/ Random height.\n    \/\/return hash21(p + 57.)*.75;\n    \n    \/\/ Any kind of cheap flowing height field will do. \n    return dot(sin(p*2. - cos(p.yx*1.4)), vec2(.25)) + .5;\n    \n    \n    \/\/ Two layers. Not used, because we're trying to keep costs down.\n    \/\/float n1 = dot(sin(p*2. - cos(p.yx*1.4)), vec2(.25)) + .5;\n    \/\/float n2 = dot(sin(p.yx*8. - cos(p*6.)), vec2(.25)) + .5;\n    \/\/return n1*.85 + n2*.15;\n}\n\n\n\n\n\/\/ This function returns the hexagonal grid coordinate for the grid cell, and the corresponding \n\/\/ hexagon cell ID - in the form of the central hexagonal point. That's basically all you need to \n\/\/ produce a hexagonal grid.\n\/\/\n\/\/ When working with 2D, I guess it's not that important to streamline this particular function.\n\/\/ However, if you need to raymarch a hexagonal grid, the number of operations tend to matter.\n\/\/ This one has minimal setup, one \"floor\" call, a couple of \"dot\" calls, a ternary operator, etc.\n\/\/ To use it to raymarch, it's necessary to double up on everything -- in order to deal with \n\/\/ overlapping fields from neighboring cells, so the fewer operations the better.\nvec4 getHex(vec2 p, float pH){\n   \n    \/\/ The hexagon centers: Two sets of repeat hexagons are required to fill in the space, and\n    \/\/ the two sets are stored in a \"vec4\" in order to group some calculations together. The hexagon\n    \/\/ center we'll eventually use will depend upon which is closest to the current point. Since \n    \/\/ the central hexagon point is unique, it doubles as the unique hexagon ID.\n    vec4 hC = floor(vec4(p, p - vec2(0, .5))\/s.xyxy) + vec4(0, 0, 0, .5);\n    vec4 hC2 = floor(vec4(p - vec2(.5, .25), p - vec2(.5, .75))\/s.xyxy) + vec4(.5, .25, .5, .75);\n    \n    \/\/ Centering the coordinates with the hexagon centers above.\n    vec4 h = vec4(p - (hC.xy + .5)*s, p - (hC.zw + .5)*s);\n    vec4 h2 = vec4(p - (hC2.xy + .5)*s, p - (hC2.zw + .5)*s);\n    \n    \/\/ Hexagon height.\n    vec4 ht = vec4(hexHeight(hC.xy), hexHeight(hC.zw), hexHeight(hC2.xy), hexHeight(hC2.zw));\n    \/\/ Restricting the heights to five levels... The \".02\" was a hack to take out the lights\n    \/\/ on the ground tiles, or something. :)\n    ht = floor(ht*4.99)\/4.\/2. + .02;\n\n    \/\/ The pylon radius. Lower numbers leave gaps, and heigher numbers give overlap. There's not a \n    \/\/ lot of room for movement, so numbers above \".3,\" or so give artefacts.\n    const float r = .25; \/\/ .21 to .3. \n    vec4 obj = vec4(objDist(h.xy, pH, r, ht.x, litID.x, 1.), objDist(h.zw, pH, r, ht.y, litID.y, -1.), \n                    objDist(h2.xy, pH, r, ht.z, litID.z, -1.), objDist(h2.zw, pH, r, ht.w, litID.w, 1.));\n    \n    \n    \/\/tempD = min(min(obj.x, obj.y), min(obj.z, obj.w));\n    \n    \/\/ Nearest hexagon center (with respect to p) to the current point. In other words, when\n    \/\/ \"h.xy\" is zero, we're at the center. We're also returning the corresponding hexagon ID -\n    \/\/ in the form of the hexagonal central point.\n    \/\/\n    h = obj.x<obj.y ? vec4(h.xy, hC.xy) : vec4(h.zw, hC.zw);\n    h2 = obj.z<obj.w ? vec4(h2.xy, hC2.xy) : vec4(h2.zw, hC2.zw);\n    \n    vec2 oH = obj.x<obj.y ? vec2(obj.x, litID.x) : vec2(obj.y, litID.y);\n    vec2 oH2 = obj.z<obj.w ? vec2(obj.z, litID.z) : vec2(obj.w, litID.w);\n    \n    \/\/return oH<oH2 ? vec4(h.xy, hC.xy) : vec4(h2.xy, hC2.xy);\n    return oH.x<oH2.x ? vec4(oH,  h.zw) : vec4(oH2, h2.zw);\n    \n}\n\n\/\/ Some IDs. One to save the unique hexagonal center coordinates and an ID for the part of the\n\/\/ pylon that is lit. These were added on the fly. There'd be cleaner ways to do this.\nvec2 v2Rnd, svV2Rnd;\nfloat gLitID;\n\n\n\n\/\/ Reducing the heightmap function to a single texel lookup - via the stone texture which was \n\/\/ generated outside the distance function in the onscreen buffer, of course.\n\/\/\n\/\/ Using the single pass system, there would have been no other option than to generate the stone \n\/\/ texture several times a frame... or beg someone behind the scenes to provide a 2D multilayered \n\/\/ Voronoi heightmap. :)\nfloat heightMap(in vec3 p){\n\n    \/\/ The stone texture is tileable, or repeatable, which means the pattern is slightly\n    \/\/ repetitive, but not too bad, all things considered. Note that the offscreen buffer \n    \/\/ doesn't wrap, so you have to do that yourself. Ie: fract(p) - Range [0, 1].\n    \/\/return Voronoi(p.xy*2.);\/\/texture2D(texChannel0, fract(p\/2.), -100.).w;\n    \n    const float sc = 1.;\n    vec4 h = getHex(p.xz*sc, -p.y*sc);\n    \n    v2Rnd = h.zw;\n    \n    gLitID = h.y;\n        \n    return h.x\/sc;\n\n}\n\n\/\/\/\/\/\/\/\n\n\/\/ Standard setup for a plane at zero level with a perturbed surface on it.\nfloat map(vec3 p){\n    \n    float c = heightMap(p);\n    \n    \/\/objID = 1.;\n    \n    return c*.7;\n \n}\n\n\/\/ Global glow variable.\nvec3 glow;\n\n\/\/ Determines whether the neon light should be switched on, or not.\nfloat getRndID(vec2 p){\n    \n    #ifdef ANIMATE_LIGHTS\n    \/\/ Blinking version. Interesting, but I found it too distracting.\n    float rnd = hash21(p);\n    return smoothstep(.5, .875, sin(rnd*6.283 + iTime)); \n    #else\n    return hash21(p) - .75;\n    #endif\n    \n    \n}\n\n\/\/ Standard raymarching routine, with some custom glow mixed in.\nfloat trace(vec3 ro, vec3 rd){\n   \n    \/\/ Applying some jitter to the jump off point to alleviate volumetric banding.\n    float t = hash31(ro + rd)*.25, d, ad;\n\n    glow = vec3(0);\n    \n    \/\/ It's a kind of expensive function, so I'm trying to minimize the iteration number.\n    \/\/ In fact, since the GPU unrolls everything, this number should always be minimized.\n    for (int i = 0; i<80; i++){\n\n        d = map(ro + rd*t);\n        ad = abs(d);\n\n     \tif(ad<.001*(t*.125 + 1.) || t>FAR) break;\n        \n        \/\/ Applying some glow. There are probably better ways to go about it, but this\n        \/\/ will suffice. If the ray passes within \"gd\" units of the neon object, add some\n        \/\/ distance-based glow.\n        const float gd = .1;\n        float rnd = getRndID(v2Rnd);\n        if(rnd>0. && gLitID == 1. && ad<gd) { \/\/ && ad<.05\n\t\t\tfloat gl = .2*(gd - ad)\/gd\/(1. + ad*ad\/gd\/gd*8.);\n            \/\/ Colors are possible, but I just wanted the scaler value, which is colorized\n            \/\/ outside the loop.\n            glow += gl; \n        }\n        \n        t += d;  \/\/ Advance the ray.\n    }\n    \n   \n    return min(t, FAR);\n}\n\n\n\n\n\/*\nvoid getGlow(vec3 ro, vec3 rd, float t){\n    \n   glow = vec3(0);\n   float t2 = hash31(ro + rd)*.25, d, ad;\n   t2 = max(t2 - 3., 0.);\n\n   for (int i = 0; i<30; i++){\n       \n\t\td = map(ro + rd*t2);\n        ad = abs(d);\n\n        if(ad<.001*(t2*.125 + 1.) || t2>FAR) break;\n\n        const float gd = .1;\n        float rnd = getRndID(vRnd);\n        if(rnd>0. && gLitID == 1. && ad<gd) { \/\/ && ad<.05\n\t\t\tfloat gl = .2*(gd - ad)\/gd\/(1. + ad*ad\/gd\/gd*8.);\n            glow += gl;\n        }\n       \n\t\tt2 += d;\n        \n    }\n    \n   \n    \n}\n*\/\n\n\/*\n\/\/ Second pass, which is the first, and only, reflected bounce. \n\/\/ Virtually the same as above, but with fewer iterations and less \n\/\/ accuracy.\n\/\/\n\/\/ The reason for a second, virtually identical equation is that \n\/\/ raymarching is usually a pretty expensive exercise, so since the \n\/\/ reflected ray doesn't require as much detail, you can relax things \n\/\/ a bit - in the hope of speeding things up a little.\nfloat traceRef(vec3 ro, vec3 rd){\n    \n    float t = 0., d;\n    \n    for (int i = 0; i<32; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.002*(t*.25 + 1.) || t>FAR) break;\n        \n        t += d;\n    }\n    \n    return min(t, FAR);\n}\n*\/\n\n\n\/\/ Cheap shadows are hard. In fact, I'd almost say, shadowing repeat objects - in a setting like this - with limited \n\/\/ iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    \/\/ More would be nicer. More is always nicer, but not really affordable.\n    const int maxIterationsShad = 32; \n    \n    vec3 rd = (lp-ro); \/\/ Unnormalized direction ray.\n\n    float shade = 1.0;\n    float dist = 0.01;    \n    float end = max(length(rd), 0.001);\n    float stepDist = end\/float(maxIterationsShad);\n    \n    rd \/= end;\n\n    \/\/ Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    \/\/ number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        \/\/shade = min(shade, k*h\/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h\/dist)); \/\/ Subtle difference. Thanks to IQ for this tidbit.\n        \/\/dist += min(h, stepDist); \/\/ So many options here, and none are perfect: dist += min( h, 0.2 ), etc\n        dist += clamp(h, .02, .25); \/\/ So many options here, and none are perfect: dist += min( h, 0.2 ), etc\n        \n        \/\/ Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0. || dist > end) break; \n    }\n\n    \/\/ I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    \/\/ Really dark shadows look too brutal to me.\n    return min(max(shade, 0.) + .05, 1.); \n}\n\n\n\n\/\/ Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical. Due to \n\/\/ the intricacies of this particular scene, it's kind of needed to reduce jagged effects.\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.0025, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n\n\n\/*\n\/\/ Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 getNormal( in vec3 p ){\n\n    \/\/ Note the slightly increased sampling distance, to alleviate\n    \/\/ artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.0025, -0.0025); \n    return normalize(\n        e.xyy * map(p + e.xyy) + \n        e.yyx * map(p + e.yyx) + \n        e.yxy * map(p + e.yxy) + \n        e.xxx * map(p + e.xxx));\n}\n*\/\n\n\/*\n\/\/ Normal calculation, with some edging and curvature bundled in.\nvec3 getNormal(vec3 p, inout float edge, inout float crv, float ef) { \n\t\n    \/\/ Roughly two pixel edge spread, but increased slightly with larger resolution.\n    vec2 e = vec2(ef\/mix(450., iResolution.y, .5), 0);\n\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p)*2.;\n\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    \/\/edge = abs(d1 + d2 + d3 + d4 + d5 + d6 - d*3.);\n    edge = smoothstep(0., 1., sqrt(edge\/e.x*2.));\n\n      \n    \/\/ Wider sample spread for the curvature.\n    \/\/e = vec2(12.\/450., 0);\n\t\/\/d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\t\/\/d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\t\/\/d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n    \/\/crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .5, 0., 1.);\n \t \n    \n    e = vec2(.0025, 0); \/\/iResolution.y - Depending how you want different resolutions to look.\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n*\/\n\n\/\/ Ambient occlusion, for that self shadowed look.\n\/\/ Based on the original by IQ.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 4., occ = 0.0;\n    for( int i=1; i<6; i++ ){\n    \n        float hr = float(i)*.125\/5.;        \n        float dd = map(p + hr*n);\n        occ += (hr - dd)*sca;\n        sca *= .75;\n    }\n    return clamp(1. - occ, 0., 1.);   \n    \n}\n\n\n\/\/ Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to\n\/\/ make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(.001, 0);\n    \n    \/\/ Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3(tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(.299, .587, .114)*m; \/\/ Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(.299, .587, .114)))\/e.x; \n    \n    \/\/ Adjusting the tangent vector so that it's perpendicular to the normal -- Thanks to\n    \/\/ EvilRyu for reminding me why we perform this step. It's been a while, but I vaguely\n    \/\/ recall that it's some kind of orthogonal space fix using the Gram-Schmidt process. \n    \/\/ However, all you need to know is that it works. :)\n    g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); \/\/ Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n\n\/\/ Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n\/\/ does give the impression that the surface is reflecting the surrounds in some way.\n\/\/\n\/\/ More sophisticated environment mapping:\n\/\/ UI easy to integrate - XT95    \n\/\/ https:\/\/www.shadertoy.com\/view\/ldKSDm\nvec3 envMap(vec3 p){\n    \n    p *= 3.;\n    \/\/p.xz += iTime*.5;\n    \n    float n3D2 = noise3D(p*3.);\n   \n    \/\/ A bit of fBm.\n    float c = noise3D(p)*.57 + noise3D(p*2.)*.28 + noise3D(p*4.)*.15;\n    c = smoothstep(.25, 1., c); \/\/ Putting in some dark space.\n    \n    p = vec3(c, c*c, c*c*c); \/\/ Bluish tinge.\n    \n    return mix(p, p.zyx, n3D2*.25 + .75); \/\/ Mixing in a bit of purple.\n\n}\n\n\nvec3 getObjectColor(vec3 p, vec3 n){\n    \n    \n    \/\/p.xy -= path(p.z);\n    float sz0 = 1.\/2.;\n    \n    \/\/ Texel retrieval.\n    vec3 txP = p;\n    \/\/txP.xz *= r2(getRndID(svVRnd)*6.2831);\n    vec3 col = tex3D(iChannel0, txP*sz0, n );\n    col = smoothstep(-.0, .5, col);\/\/*vec3(.5, .8, 1.5);\n    col = mix(col, vec3(1)*dot(col, vec3(.299, .587, .114)), .5);\n    \/\/ Darken the surfaces to bring more attention to the neon lights.\n    col \/= 16.;\n    \n   \n    \/\/ Unique random ID for the hexagon pylon.\n    float rnd = getRndID(svV2Rnd);\n    \n    \/\/ Subtly coloring the unlit hexagons... I wasn't feeling it. :)\n    \/\/if(svLitID==1. && rnd<=.0) col *= vec3(1, .85, .75)*4.;\n\n    \/\/ Applying the glow.\n    \/\/\n    \/\/ It's took a while to hit upon the right combination. You can create a cheap lit object \n    \/\/ effect by simply ramping up the object's color intensity. However, your eyes can tell that\n    \/\/ it's lacking that volumetric haze. Volumetric haze is achievable via a volumetric appoach.\n    \/\/ However, it's prone to patchiness. The solutionm, of course, is to combine the smoothness\n    \/\/ of direct object coloring with a portion of the glow. That's what is happining here.\n\n    \/\/ Object glow.\n    float oGlow = 0.;\n    \n    \/\/ Color every lit object with a gradient based on its vertical positioning.\n    if(rnd>0. && svLitID==1.) {\n        \n        float ht = hexHeight(svV2Rnd);\n    \tht = floor(ht*4.99)\/4.\/2. + .02;\n        const float s = 1.\/4.\/2.*.5; \/\/ Four levels, plus the height is divided by two.\n     \n        oGlow = mix(1., 0., clamp((abs(p.y - (ht - s)))\/s*3.*1., 0., 1.));\n        oGlow = smoothstep(0., 1., oGlow*1.);\n    }\n    \n    \/\/ Mix the object glow in with a small potion of the volumetric glow.\n    glow = mix(glow, vec3(oGlow), .75);\n    \n    \/\/ Colorizing the glow, depending on your requirements. I've used a colorful orangey palette,\n    \/\/ then have modified the single color according to a made up 3D transcental function.\n    \/\/glow = pow(vec3(1, 1.05, 1.1)*glow.x, vec3(6, 3, 1));\n    glow = pow(vec3(1.5, 1, 1)*glow, vec3(1, 3, 6)); \/\/ Mild firey orange.\n    glow = mix(glow, glow.xzy, dot(sin(p*4. - cos(p.yzx*4.)), vec3(.166)) + .5); \/\/ Mixing in some pink.\n    glow = mix(glow, glow.zyx, dot(cos(p*2. - sin(p.yzx*2.)), vec3(.166)) + .5); \/\/ Blue tones.\n    \/\/glow = mix(glow.zyx, glow, smoothstep(-.1, .1, dot(sin(p + cos(p.yzx)), vec3(.166))));\n     \n    #ifdef GREEN_GLOW \n    glow = glow.yxz;\n    #endif\n    \n   \n    return col;\n    \n}\n\n\n\/\/ Using the hit point, unit direction ray, etc, to color the \n\/\/ scene. Diffuse, specular, falloff, etc. It's all pretty \n\/\/ standard stuff.\nvec3 doColor(in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, in float t){\n    \n    vec3 sceneCol = vec3(0);\n    \n    if(t<FAR){\n        \n           \/\/ Texture bump the normal.\n    \tfloat sz0 = 1.\/1.;\n    \tvec3 txP = sp;\n        \/\/txP.xy -= path(txP.z);\n        \/\/txP.xz *= r2(getRndID(svVRnd)*6.2831);\n        sn = texBump(iChannel0, txP*sz0, sn, .005);\/\/\/(1. + t\/FAR)\n \n\n        \/\/ Retrieving the normal at the hit point.\n        \/\/sn = getNormal(sp);  \n        float sh = softShadow(sp, lp, 12.);\n        float ao = calcAO(sp, sn);\n        sh = min(sh + ao*.3, 1.);\n\n        vec3 ld = lp - sp; \/\/ Light direction vector.\n        float lDist = max(length(ld), .001); \/\/ Light to surface distance.\n        ld \/= lDist; \/\/ Normalizing the light vector.\n\n        \/\/ Attenuating the light, based on distance.\n        float atten = 1.5\/(1. + lDist*.1 + lDist*lDist*.02);\n\n        \/\/ Standard diffuse term.\n        float diff = max(dot(sn, ld), 0.);\n        \/\/if(svLitID == 0.) diff = pow(diff, 4.)*2.;\n        \/\/ Standard specualr term.\n        float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.);\n        float fres = clamp(1.0 + dot(rd, sn), 0.0, 1.0); \/\/ Fresnel reflection term.\n        \/\/float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.0);\n        \/\/float fre2 = mix(.5, 1., Schlick);  \/\/F0 = .5.\n        \n\n\n        \/\/ Coloring the object. You could set it to a single color, to\n        \/\/ make things simpler, if you wanted.\n        vec3 objCol = getObjectColor(sp, sn);\n\n\n        \/\/ Combining the above terms to produce the final scene color.\n        sceneCol = objCol*(diff + vec3(1, .6, .3)*spec*4. + .5*ao + vec3(.3, .5, 1)*fres*fres*2.);\n\n        \/\/ Fake environment mapping.\n        sceneCol += pow(sceneCol, vec3(1.))*envMap(reflect(rd, sn))*4.;\n        \n       \n        \/\/ Applying the shadows and ambient occlusion.\n        sceneCol *= atten*sh*ao;\n        \n        \/\/ For whatever reason, I didn't want the shadows and such to effect the glow, so I layered\n        \/\/ it over the top.\n        sceneCol += (objCol*6. + 1.)*glow; \/\/*(sh*.35 + .65);\n \n        \/\/sceneCol = vec3(sh);\n    \n    }\n    \n    \n\n    \n    \/\/ Return the color. Done once every pass... of which there are\n    \/\/ only two, in this particular instance.\n    return sceneCol;\n    \n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \/\/ Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5) \/ iResolution.y;\n    \n\t\n\t\/\/ Camera Setup.\n\t\/\/vec3 lookAt = vec3(0., 0.25, iTime*2.);  \/\/ \"Look At\" position.\n\t\/\/vec3 camPos = lookAt + vec3(2., 1.5, -1.5); \/\/ Camera position, doubling as the ray origin.\n\t\n\tvec3 lk = vec3(0, 1.25, iTime*1.);  \/\/ \"Look At\" position.\n\tvec3 ro = lk + vec3(0, .175, -.25); \/\/ Camera position, doubling as the ray origin.\n\n   \n    \/\/ Light position. Set in the vicinity the ray origin.\n    vec3 lp = ro + vec3(0, 1, 4); \/\/4\n    \n\t\/\/ Using the Z-value to perturb the XY-plane.\n\t\/\/ Sending the camera, \"look at,\" and two light vectors down the tunnel. The \"path\" function is \n\t\/\/ synchronized with the distance function. Change to \"path2\" to traverse the other tunnel.\n\tlk.xy += path(lk.z);\n\tro.xy += path(ro.z);\n\tlp.xy += path(lp.z);\n\n    \/\/ Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159\/3.; \/\/ FOV - Field of view.\n    vec3 forward = normalize(lk-ro);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    \/\/ rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    \n    \/\/ Camera lean.\n    \/\/rd.xy *= r2(path(lk.z).x\/32.);\n    \/\/\/\/\/\/\/\/\/\n    \n\n    vec3 sceneColor, passColor, sn, sSn;\n\n    \n    \n    \/\/ FIRST PASS.\n    \n    float t = trace(ro, rd);\n    svV2Rnd = v2Rnd;\n    svLitID = gLitID;\n\n    \n    \/\/getGlow(ro, rd, t);\n    \n    \/\/ Fog based off of distance from the camera. Not used here.\n    float fog = smoothstep(0., FAR-1., t); \n    \n    \/\/ Advancing the ray origin, \"ro,\" to the new hit point.\n    ro += rd*t;\n   \n    \/\/ Retrieving the normal at the hit point.\n    \/\/sn = getNormal(ro); \n    \/\/float edge = 0., crv = 1., ef = 5.;\n\t\/\/sn = getNormal(ro, edge, crv, ef);\/\/\n    \/\/sSn = sn; \/\/ Save the unpeturbed normal.\n    sn = getNormal(ro);\n    \n    \n    \n    \/\/ Retrieving the color at the hit point, which is now \"ro.\" I agree, reusing \n    \/\/ the ray origin to describe the surface hit point is kind of confusing. The reason \n    \/\/ we do it is because the reflective ray will begin from the hit point in the \n    \/\/ direction of the reflected ray. Thus the new ray origin will be the hit point. \n    \/\/ See \"traceRef\" below.\n    passColor = doColor(ro, rd, sn, lp, t);\n    sceneColor = passColor;\/\/*(1. - edge*.8);\/\/mix(passColor, vec3(0), fog); \/\/\n    \n    \n    \n    \/\/ Shading. Shadows, ambient occlusion, etc. We're only performing this on the \n    \/\/ first pass. Not accurate, but faster, and in most cases, not that noticeable.\n    \/\/float sh = softShadow(ro, lp, 12.);\n    \/\/sh *= calcAO(ro, sn);\n    \n\/*    \n    \/\/ SECOND PASS - REFLECTED RAY\n    \n    \/\/ Standard reflected ray, which is just a reflection of the unit\n    \/\/ direction ray off of the intersected surface. You use the normal\n    \/\/ at the surface point to do that. Hopefully, it's common sense.\n    rd = reflect(rd, normalize(sSn*.66 + sn*.34));\n    \n    \n    \n    \n    \/\/ The reflected pass begins where the first ray ended, which is the suface\n    \/\/ hit point, or in a few cases, beyond the far plane. By the way, for the sake\n    \/\/ of simplicity, we'll perform a reflective pass for non hit points too. Kind\n    \/\/ of wasteful, but not really noticeable. The direction of the new ray will\n    \/\/ obviously be in the direction of the reflected ray. See just above.\n    \/\/\n    \/\/ To anyone who's new to this, don't forgot to nudge the ray off of the \n    \/\/ initial surface point. Otherwise, you'll intersect with the surface\n    \/\/ you've just hit. After years of doing this, I still forget on occasion.\n    t = traceRef(ro +  rd*.01, rd);\n    svVRnd = vRnd;\n    svObjID = objID;\n    \n    \/\/ Advancing the reflected ray origin, \"ro,\" to the new hit point.\n    ro += rd*t;\n    \n    \/\/ Retrieving the new normal at the reflected hit point.\n    \/\/sn = getNormal(ro); \n    float edge2 = 0., crv2 = 1.;\/\/, ef2 = 8.;\n\tsn = getNormal(ro, edge2, crv2, ef);\/\/getNormal(sp);\n\n    \n    \/\/ Coloring the reflected hit point, then adding a portion of it to the final scene color.\n    \/\/ How much you add depends on what you're trying to accomplish.\n    passColor = doColor(ro, rd, sn, lp, t);\n    sceneColor = sceneColor*.5 + passColor*(1. - edge2*.8);\/\/mix(passColor, vec3(0), fog);\n    \n*\/  \n    \n    \/\/sceneColor *= (1. - edge*.8);\n    \n    \n    \/\/ APPLYING SHADOWS\n    \/\/\n    \/\/ Multiply the shadow from the first pass by the final scene color. Ideally, you'd check to\n    \/\/ see if the reflected point was in shadow, and incorporate that too, but we're cheating to\n    \/\/ save cycles and skipping it. It's not really noticeable anyway. By the way, ambient\n    \/\/ occlusion would make it a little nicer, but we're saving cycles and keeping things simple.\n    \/\/sceneColor *= sh;\n    \n    sceneColor = mix(sceneColor, vec3(0), fog);\n    \n\n    \/\/ Square vignette.\n    uv = fragCoord\/iResolution.xy;\n    sceneColor = min(sceneColor, 1.)*pow( 16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625);\n\n    \/\/ Clamping the scene color, then presenting to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneColor, 0.0, 1.0)), 1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4lBXDt","date":"1447167870","viewed":14318,"name":"Balloons","username":"candycat","description":"Draw some balloons. Uncomment line 70 to see  singing balloons. thanks @FabriceNeyret2!","likes":109,"published":1,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"\/media\/a\/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"\/media\/ap\/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define amplitude 0.1\n#define BackgroundColor vec4(0.957, 0.925, 0.773, 1.0)\n#define EdgeColor vec4(0.2, 0.2, 0.2, 1.0)\n#define BlueColor vec4(0.384, 0.667, 0.655, 1.0)\n#define PurpleColor vec4(0.761, 0.706, 0.835, 1.0)\n#define YellowColor vec4(0.961, 0.753, 0.196, 1.0)\n#define GreenColor vec4(0.624, 0.796, 0.361, 1.0)\n#define OrangeColor vec4(0.953, 0.482, 0.318, 1.0)\n#define RedColor vec4(0.886, 0.557, 0.616, 1.0)\n\nfloat noise2d(vec2 p) {\n\tfloat t = texture(iChannel0, p).x;\n\tt += 0.5 * texture(iChannel0, p * 2.0).x;\n\tt += 0.25 * texture(iChannel0, p * 4.0).x;\n\treturn t \/ 1.75;\n}\n\nfloat line(vec2 p, vec2 p0, vec2 p1, float width) {\n    vec2 dir0 = p1 - p0;\n    vec2 dir1 = p - p0;\n    float h = clamp(dot(dir1, dir0)\/dot(dir0, dir0), 0.0, 1.0);\n    float d = (length(dir1 - dir0 * h) - width * 0.5);\n    return d;\n}\n\nvec4 drawline(vec2 p, vec2 p0, vec2 p1, float width) {   \t\t\n    float d = line(p, p0, p1, width);\n    d += noise2d(p * vec2(0.2)) * 0.005;\n    float w = fwidth(d) * 1.0;\n    \n    return vec4(EdgeColor.rgb, 1.-smoothstep(-w, w, d));\n}\n\nfloat metaball(vec2 p, float r) {\n\treturn r \/ dot(p, p);\n}\n\nvec4 balloon(vec2 pos, vec2 start, vec2 end, float radius, vec4 color) {\n    \/\/ Draw line\n    vec2 linePos = pos;\n    linePos.x *= (1.0 + sin(noise2d(pos * 0.005) * pos.y * 8.) * 0.05);\n    vec4 line = drawline(linePos, \n                         start * (1.0 + vec2(cos(iTime * 1.4), sin(iTime * 2.4)) * 0.4 * amplitude), \n                         end, 0.015);\n    \n    vec2 c0 = start * (1.0 + vec2(cos(iTime * 1.4), sin(iTime * 2.4)) * 0.57 * amplitude);\n    vec2 c1 = start * (1.0 + vec2(cos(iTime * 1.4), sin(iTime * 1.9)) * 0.49 * amplitude);\n    vec2 c2 = start * (1.0 + vec2(sin(iTime * 1.9), cos(iTime * 2.4)) * 0.46 * amplitude);\n\t\t\t\n\tfloat r = metaball(pos - c0, radius*1.1) *\n\t\t \t\tmetaball(pos - c1, radius*1.3) *\n\t\t\t\tmetaball(pos - c2, radius*0.9);\n    \n    vec2 boundary = vec2(0.4, 0.5);\n\tvec4 c = vec4(0);\n\t\t\t\n\tvec4 egdeColor = EdgeColor;\n\tvec4 blobColor = color;\n    \n\tr += noise2d(pos * vec2(0.05)) * 0.15;\n    \n    if (r < boundary.x) {\n\t\tc = egdeColor;\n\t\tc.a = 0.0;\n\t} else if (r < boundary.y) {\n\t\tc = egdeColor;\n\t\tc.a = 1.0;\n    } else {\n        c = blobColor;\n        \/\/c = mix(blobColor,texture(iChannel1,.5+(pos-c2)*3.),.5+.5*cos(10.*start.x+iTime));\n        c.a = 1.0;\n    }\n    \n    \/\/ Blur the edges\n    float w = 0.05;\n\tif (r > boundary.x - w && r < boundary.x) {\n\t\tc = mix(line, egdeColor, smoothstep(-w, 0.0, r - boundary.x));\n        c.a = mix(0.0, 1.0, smoothstep(-w, 0.0, r - boundary.x));\n\t}\n\tif (r > boundary.y - w && r < boundary.y + w) {\n\t\tc.rgb = mix(egdeColor.rgb, blobColor.rgb, smoothstep(-w, w, r - boundary.y));\n\t}\n    \n    c.rgb += noise2d(pos * 0.1) * 0.1;\n    \n    c.rgb = mix(line.rgb, c.rgb, c.a);\n    c.a = max(line.a, c.a);\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.yy;\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)\/min(iResolution.y,iResolution.x); \n    \n    if (iMouse.z > 0.0) {\n        uv.y -= (iMouse.y\/iResolution.y - 0.5)*0.3;\n    }\n\t\n    float width = iResolution.x\/iResolution.y; \n\n    fragColor = BackgroundColor;\n    \n    float end = -0.1;\n    \n    \/\/ First level\n    vec4 c = balloon(uv, vec2(width * 0.5, 0.9), vec2(width*0.5, end), 0.013, BlueColor);\n    fragColor.rgb = mix(fragColor.rgb, c.rgb, c.a);\n    \n    \/\/ Second level\n    c = balloon(uv, vec2(width*0.4, 0.75), vec2(width*0.5, end), 0.015, PurpleColor);\n    fragColor.rgb = mix(fragColor.rgb, c.rgb, c.a);\n    \n    c = balloon(uv, vec2(width*0.6, 0.7), vec2(width*0.5, end), 0.015, YellowColor);\n    fragColor.rgb = mix(fragColor.rgb, c.rgb, c.a);\n    \n    \/\/ Third level\n    c = balloon(uv, vec2(width*0.25, 0.67), vec2(width*0.5, end), 0.013, GreenColor);\n    fragColor.rgb = mix(fragColor.rgb, c.rgb, c.a);\n    \n    c = balloon(uv, vec2(width*0.7, 0.63), vec2(width*0.5, end), 0.013, OrangeColor);\n    fragColor.rgb = mix(fragColor.rgb, c.rgb, c.a);\n    \n    \/\/ Fourth level\n    c = balloon(uv, vec2(width*0.38, 0.35), vec2(width*0.5, end), 0.011, RedColor);\n    fragColor.rgb = mix(fragColor.rgb, c.rgb, c.a);\n    \n    c = balloon(uv, vec2(width * 0.2, 0.45), vec2(width*0.5, end), 0.014, BlueColor);\n    fragColor.rgb = mix(fragColor.rgb, c.rgb, c.a);\n    \n    c = balloon(uv, vec2(width*0.73, 0.32), vec2(width*0.5, end), 0.012, YellowColor);\n    fragColor.rgb = mix(fragColor.rgb, c.rgb, c.a);\n    \n    c = balloon(uv, vec2(width*0.55, 0.4), vec2(width*0.5, end), 0.013, GreenColor);\n    fragColor.rgb = mix(fragColor.rgb, c.rgb, c.a);\n    \n    fragColor.rgb = fragColor.rgb*(1.0-0.15*length(p));\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0\/1.8));\n}\n\n\n","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4sGSRV","date":"1465388127","viewed":14314,"name":"Abstract Plane","username":"Shane","description":"Using a randomized 3D tile to add some pronounced surfacing to a warped plane.","likes":220,"published":3,"flags":0,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"\/media\/a\/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"\/media\/ap\/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/*\n    Abstract Plane\n    --------------\n\n\tPerforming 2nd order distance checks on randomized 3D tiles to add some pronounced \n\tsurfacing to a warped plane... Verbose description aside, it's a pretty simple process. :)\n\n\tI put this example together some time ago, but couldn't afford a reflective pass, so \n\tforgot about it. Anyway, I was looking at XT95's really nice \"UI\" example - plus a \n\tcouple of my own - and realized that a little bit of environment mapping would work \n\tnicely. I'm using a less sophisticated environment mapping function than XT95's, but \n\tit produces the desired effect. \n\t\n    By the way, XT95's is really worth taking a look at. It gives off a vibe of surrounding \n\tarea lights. I tested it on other surfaces and was pretty pleased with the results. The \n\tlink is below.\n\n\tAs for the geometry itself, it's just a variation of 3D repetitive tiling. I colored in\n\tsome of the regions - Greyscale with a splash of color is on page five of the \"Tired Old \n\tCliche Design\" handbook. :) However, I also to wanted to show that it's possible to \n\tidentify certain regions within the tile in a similar way to which it is done with regular \n\tVoronoi.\t\n\n\tOther examples:\n    \n\t\/\/ Excellent environment mapping example.\n\tUI easy to integrate - XT95    \n\thttps:\/\/www.shadertoy.com\/view\/ldKSDm\n\n\t\/\/ As abstact terrain shaders go, this is my favorite. :)\n\tSomewhere in 1993 - nimitz\n\thttps:\/\/www.shadertoy.com\/view\/Md2XDD\n*\/\n\n\n#define FAR 40.\n\n\/\/ 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n\/\/ of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) - a);\treturn mat2(v, -v.y, v.x); }\n\n \n\nfloat drawObject(in vec3 p){\n    \n    \/\/ Anything that wraps the domain will work. The following looks pretty intereting.\n    \/\/p = cos(p*3.14159)*0.5; \n    \/\/p = abs(cos(p*3.14159)*0.5);\n    \n    \/\/ Try this one for a regular, beveled Voronoi looking pattern. It's faster to\n    \/\/ hone in on too, which is a bonus.\n    \/\/p = fract(p)-.5;    \n    \/\/return dot(p, p);\n    \n    p = abs(fract(p)-.5);\n    return dot(p, vec3(.5));\n    \n    \/\/p = abs(fract(p)-.5);\n    \/\/return max(max(p.x, p.y), p.z);\n    \n    \/\/p = cos(p*3.14159)*0.5; \n    \/\/p = abs(cos(p*3.14159)*0.5);\n    \/\/p = abs(fract(p)-.5);\n    \/\/return max(max(p.x - p.y, p.y - p.z), p.z - p.x);\n    \/\/return min(min(p.x - p.y, p.y - p.z), p.z - p.x);\n    \n}\n\n\/\/ The 3D tiling process. I've explained it in the link below, if you're interested in the process.\n\/\/\n\/\/ Cellular Tiled Tunnel\n\/\/ https:\/\/www.shadertoy.com\/view\/MscSDB\nfloat cellTile(in vec3 p){\n    \n    p \/= 5.5;\n    \/\/ Draw four overlapping objects at various positions throughout the tile.\n    vec4 v, d; \n    d.x = drawObject(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.y = drawObject(p - vec3(.39, .2, .11));\n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawObject(p - vec3(.62, .24, .06));\n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071;\n    d.w = drawObject(p - vec3(.2, .82, .64));\n\n    v.xy = min(d.xz, d.yw), v.z = min(max(d.x, d.y), max(d.z, d.w)), v.w = max(v.x, v.y); \n   \n    d.x =  min(v.z, v.w) - min(v.x, v.y); \/\/ Maximum minus second order, for that beveled Voronoi look. Range [0, 1].\n    \/\/d.x =  min(v.x, v.y); \/\/ First order.\n        \n    return d.x*2.66; \/\/ Normalize... roughly.\n    \n}\n\n\nvec3 cellTileColor(in vec3 p){\n    \n    \n    int cellID = 0;\n    \n    p\/=5.5;\n    \n    vec3 d = (vec3(.75)); \/\/ Set the maximum.\n   \n    \n    \/\/ Draw four overlapping shapes using the darken blend \n    \/\/ at various positions on the tile.\n    d.z = drawObject(p - vec3(.81, .62, .53)); if(d.z<d.x)cellID = 1;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    \n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.z = drawObject(p - vec3(.39, .2, .11)); if(d.z<d.x)cellID = 2;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    \n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawObject(p - vec3(.62, .24, .06)); if(d.z<d.x)cellID = 3;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    \n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071; \n    d.z = drawObject(p - vec3(.2, .82, .64)); if(d.z<d.x)cellID = 4;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n\n   \n    \n    vec3 col = vec3(.25);\/\/vec3(.7, .8, 1);\n    \n   \n    if (cellID == 3) col = vec3(1, .05, .15);\n    \/\/vec3(.1, .8, .0);\/\/vec3(.4, .7, 1.);\/\/vec3(.8, .4, .2);\/\/vec3(1, .05, .15)\/\/\n    \n    \/\/ Extra color, if desired.\n    \/\/if (cellID == 4) col = vec3(.1, .8, .0);\/\/vec3(.5, .4, .35);\n    \n    \/\/ Interesting, but probably a little to abstract for this example.\n    \/\/col *= (vec3(clamp(sin(d.x*24.*6.283)*2., 0., 1.)) + .5);\n    \n    return col;\n    \n    \n    \n    \/\/return (1.-sqrt(d.x)*1.33);\n    \n}\n\n\n\/\/ Standard setup for a plane at zero level with a perturbed surface on it.\nfloat map(vec3 p){\n    \n    float n = (.5-cellTile(p))*1.5;\n    return p.y + dot(sin(p\/2. + cos(p.yzx\/2. + 3.14159\/2.)), vec3(.5)) + n;\n \n}\n\n\n\/\/ Standard raymarching routine.\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 0.0;\n    \n    for (int i = 0; i < 96; i++){\n\n        float d = map(ro + rd*t);\n        \n        if(abs(d)<0.0025*(t*.125 + 1.) || t>FAR) break;\n        \n        t += d*.7;  \/\/ Using more accuracy, in the first pass.\n    }\n    \n    return min(t, FAR);\n}\n\n\n\/\/ Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical. Due to \n\/\/ the intricacies of this particular scene, it's kind of needed to reduce jagged effects.\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.005, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n\/*\n\/\/ Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 getNormal( in vec3 p ){\n\n    \/\/ Note the larger than usual sampline distance (epsilon value). It's an old trick to give\n    \/\/ rounded edges, and with the right objects it gives a slightly blurred antialiased look.\n    vec2 e = vec2(0.015, -0.015);\n    return normalize( e.xyy*map(p+e.xyy ) + e.yyx*map(p+e.yyx ) + e.yxy*map(p+e.yxy ) + e.xxx*map(p+e.xxx ));\n}\n*\/\n\n\n\/\/ I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n\/\/ Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calculateAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 2.0, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5\/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\/\/ Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n    \n    \/\/return cellTileColor(p);\n  \n    n = max((abs(n) - 0.2)*7., 0.001); \/\/ n = max(abs(n), 0.001), etc.\n    n \/= (n.x + n.y + n.z ); \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n\/\/ Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n\/\/ make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.002, 0);\n    \n    \/\/ Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; \/\/ Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )\/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); \/\/ Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n\/\/ Cool curve function, by Shadertoy user, Nimitz.\n\/\/\n\/\/ I think it's based on a discrete finite difference approximation to the continuous\n\/\/ Laplace differential operator? Either way, it gives you the curvature of a surface, \n\/\/ which is pretty handy. I used it to do a bit of fake shadowing.\n\/\/\n\/\/ Original usage (I think?) - Cheap curvature: https:\/\/www.shadertoy.com\/view\/Xts3WM\n\/\/ Other usage: Xyptonjtroz: https:\/\/www.shadertoy.com\/view\/4ts3z2\nfloat curve(in vec3 p, in float w){\n\n    vec2 e = vec2(-1., 1.)*w;\n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return 0.125\/(w*w) *(t1 + t2 + t3 + t4 - 4.*map(p));\n}\n\n\n\/\/ Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n\/\/ does give the impression that the surface is reflecting the surrounds in some way.\n\/\/\n\/\/ Anyway, the idea is very simple. Obtain the reflected ray at the surface hit point, then \n\/\/ pass it into a 3D function. If you wanted, you could convert the 3D ray coordinates (p) \n\/\/ to polar coordinates and index into a repeat texture. It can be pretty convincing (in an \n\/\/ abstract way) and allows environment mapping without the need for a cube map, or a \n\/\/ reflective pass.\n\/\/\n\/\/ More sophisticated environment mapping:\n\/\/ UI easy to integrate - XT95    \n\/\/ https:\/\/www.shadertoy.com\/view\/ldKSDm\nvec3 envMap(vec3 p){\n   \n    \/\/ Some functions work, and others don't. The surface is created with the function\n    \/\/ below, so that makes it somewhat believable.\n    float c = cellTile(p*6.);\n    c = smoothstep(0.2, 1., c); \/\/ Contract gives it more of a lit look... kind of.\n    \n    return vec3(pow(c, 8.), c*c, c); \/\/ Icy glow... for whatever reason. :)\n    \/\/ Alternate firey glow.\n    \/\/return vec3(min(c*1.5, 1.), pow(c, 2.5), pow(c, 12.));\n\n}\n\n\/\/ Simple sinusoidal path, based on the z-distance.\nvec2 path(in float z){ float s = sin(z\/36.)*cos(z\/18.); return vec2(s*16., 0.); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n\t\/\/ Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)\/iResolution.y;\n\t\n\t\/\/ Camera Setup.\n\tvec3 lk = vec3(0, 3.5, iTime*6.);  \/\/ \"Look At\" position.\n\tvec3 ro = lk + vec3(0, .25, -.25); \/\/ Camera position, doubling as the ray origin.\n \n    \/\/ Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(0, .75, 2);\/\/ Put it a bit in front of the camera.\n\tvec3 lp2 = ro + vec3(0, .75, 9);\/\/ Put it a bit in front of the camera.\n\t\n\t\/\/ Sending the camera, \"look at,\" and two light vectors across the plain. The \"path\" function is \n\t\/\/ synchronized with the distance function.\n\tlk.xy += path(lk.z);\n\tro.xy += path(ro.z);\n\tlp.xy += path(lp.z);\n\tlp2.xy += path(lp2.z);\n\n    \/\/ Using the above to produce the unit ray-direction vector.\n    float FOV = 1.57; \/\/ FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    \/\/ \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    \/\/ assuming no normalization is necessary? The only reason I ask is that lots of people do \n    \/\/ normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    \/\/ rd - Ray direction.\n    vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    \n    \/\/ Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    \/\/ Naturally, it's synchronized with the path in some kind of way.\n\trd.xy *= rot2( path(lk.z).x\/64. );\n    \n    \/*    \n    \/\/ Mouse controls, as per TambakoJaguar's suggestion.\n    \/\/ Works better if the line above is commented out.   \n\tvec2 ms = vec2(0);\n    if (iMouse.z > 1.0) ms = (2.*iMouse.xy - iResolution.xy)\/iResolution.xy;\n    vec2 a = sin(vec2(1.5707963, 0) - ms.x); \n    mat2 rM = mat2(a, -a.y, a.x);\n    rd.xz = rd.xz*rM; \n    a = sin(vec2(1.5707963, 0) - ms.y); \n    rM = mat2(a, -a.y, a.x);\n    rd.yz = rd.yz*rM;\n\t*\/ \n    \n    \/\/ Raymarch to the scene.\n    float t = trace(ro, rd);\n\t\n    \/\/ Initiate the scene color to black.\n\tvec3 sceneCol = vec3(0.);\n\t\n\t\/\/ The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n    \t\n    \t\/\/ Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    vec3 sn = getNormal(sp);\n        \n        \/\/ Texture scale factor.\n        const float tSize0 = 1.\/2.;\n        \/\/ Texture-based bump mapping.\n\t    sn = texBump(iChannel0, sp*tSize0, sn, 0.01);\n        \n        \/\/ Obtaining the texel color. \n\t    vec3 texCol = tex3D(iChannel0, sp*tSize0, sn);\n\n\t    \/\/ Ambient occlusion.\n\t    float ao = calculateAO(sp, sn);\n    \t\n    \t\/\/ Light direction vectors.\n\t    vec3 ld = lp-sp;\n\t    vec3 ld2 = lp2-sp;\n\n        \/\/ Distance from respective lights to the surface point.\n\t    float lDist = max(length(ld), 0.001);\n\t    float lDist2 = max(length(ld2), 0.001);\n    \t\n    \t\/\/ Normalize the light direction vectors.\n\t    ld \/= lDist;\n\t    ld2 \/= lDist2;\n\t    \n\t    \/\/ Light attenuation, based on the distances above.\n\t    float atten = 1.\/(1. + lDist*lDist*0.025);\n\t    float atten2 = 1.\/(1. +lDist2*lDist2*0.025);\n    \t\n    \t\/\/ Ambient light.\n\t    float ambience = 0.1;\n    \t\n    \t\/\/ Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.0);\n\t    float diff2 = max( dot(sn, ld2), 0.0);\n    \t\n    \t\/\/ Specular lighting.\n\t    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 8.);\n\t    float spec2 = pow(max( dot( reflect(-ld2, sn), -rd ), 0.0 ), 8.);\n    \t\n    \t\/\/ Curvature.\n\t    float crv = clamp(curve(sp, 0.125)*0.5+0.5, .0, 1.);\n\t    \n\t    \/\/ Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow( clamp(dot(sn, rd) + 1., .0, 1.), 1.);\n\n    \t\n    \t\/\/ Darkening the crevices. Otherse known as cheap, scientifically-incorrect shadowing.\t\n\t    float shading =  crv*0.5+0.5; \/\/smoothstep(-.05, .1, cellTile(sp));\/\/\n        shading *= smoothstep(-.1, .15, cellTile(sp));\n        \n        \n        \/\/ I got a reminder looking at XT95's \"UI\" shader that there are cheaper ways\n        \/\/ to produce a hint of reflectivity than an actual reflective pass. :)        \n        vec3 env = envMap(reflect(rd, sn))*.5;\n    \n\n        \/\/ Combining the above terms to procude the final color.\n        vec3 rCol = cellTileColor(sp)*dot(texCol, vec3(.299, .587, .114));\n        sceneCol += (rCol*(diff + ambience) + vec3(.8, .95, 1)*spec*1.5 + env)*atten;\n        sceneCol += (rCol*(diff2 + ambience) + vec3(.8, .95, 1)*spec2*1.5 + env)*atten2;\n        \n        \/\/ Cube mapping, for those who want more believable environment mapping.\n        \/\/vec3 rfCol = texture(iChannel1, reflect(rd, sn)).xyz; \/\/ Forest scene.\n        \/\/sceneCol += rfCol*rfCol*.25;\n        \n\n        \/\/ Shading.\n        sceneCol *= shading*ao;\n        \n        \n\t\n\t}\n    \n    \/\/ Simple dark fog. It's almost black, but I left a speck of blue in there to account for \n    \/\/ the blue reflective glow... Although, it still doesn't explain where it's coming from. :)\n    sceneCol = mix(sceneCol, vec3(.0, .003, .01), smoothstep(0., FAR-5., t));\n    \n    \n\tfragColor = vec4(sqrt(clamp(sceneCol, 0., 1.)), 1.0);\n\t\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"XdVGWt","date":"1459453855","viewed":14300,"name":"Homecomputer","username":"nimitz","description":"Soundcloud track by Dubmood: https:\/\/soundcloud.com\/dubmood","likes":173,"published":1,"flags":96,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Homecomputer by nimitz 2016 (twitter: @stormoid)\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\/\/ Contact the author for other licensing options\n\n\/\/Code is in the other tabs:\n\/\/Buf A = Velocity and position handling\n\/\/Buf B = Rendering\n\/\/Buf C = Soundcloud filtering and propagation\n\n#define time iTime\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy \/ iResolution.xy;\n\tvec3 col = texture(iChannel0, q).rgb;\n    col *= sin(gl_FragCoord.y*350.+time)*0.04+1.;\/\/Scanlines\n    col *= sin(gl_FragCoord.x*350.+time)*0.04+1.;\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1)*0.35+0.65; \/\/Vign\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ Homecomputer by nimitz 2016 (twitter: @stormoid)\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\/\/ Contact the author for other licensing options\n\n\/\/Velocity handling\n\n#define time iTime\n\nvec3 hash3(vec3 p)\n{\n    p = fract(p * vec3(443.8975,397.2973, 491.1871));\n    p += dot(p.zxy, p.yxz+19.1);\n    return fract(vec3(p.x * p.y, p.z*p.x, p.y*p.z))-0.5;\n}\n\nvec3 update(in vec3 vel, vec3 pos, in float id)\n{\n    vec4 sndNFO = texture(iChannel2, vec2(0.75, 0.25));\n    float R = 1.5;\n    const float r = .5;\n    float t= time*2.+id*8.;\n    float d= 5.;\n    \n    float x = ((R-r)*cos(t-time*0.1) + d*cos((R-r)\/r*t));\n    float y = ((R-r)*sin(t) - d*sin((R-r)\/r*t));\n    \n    vel = mix(vel, vec3(x*1.2,y,sin(time*12.6+id*50. + sndNFO.z*10.)*7.)*5. +hash3(vel*10.+time*0.2)*7., 1.);\n    \n    \/\/vel.z += sin(time*sndNFO.z)*50.;\n    \/\/vel.z += sin(time + sndNFO.z*70.)*10.;\n    \/\/vel.z += sin(time)*30.*sndNFO.x;\n    \n    return vel;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy \/ iResolution.xy;\n    vec2 p = q-0.5;\n    p.x *= iResolution.x\/iResolution.y;\n    \n    vec2 mo = iMouse.xy\/iResolution.xy-0.5;\n    \n    float dt = iTimeDelta;\n    \n    vec4 col= vec4(0);\n    \n    vec2 w = 1.\/iResolution.xy;\n    \n    vec3 pos = texture(iChannel0, vec2(q.x,100.*w)).xyz;\n    vec3 velo = texture(iChannel0, vec2(q.x,0.0)).xyz;\n    velo = update(velo, pos, q.x);\n    \n    if (fragCoord.y < 30.)\n    {\n    \tcol.rgb = velo;\n    }\n    else\n    {\n        pos += velo*0.002;\n        col.rgb = pos;\n    }\n\t\n    if (iFrame < 5) \n    {\n        if (fragCoord.y < 30.)\n        \tcol = ((texture(iChannel1, q*1.9))-.5)*vec4(0.,0.,0.,0.);\n        else\n        {\n            col = vec4(.0,-.7,0,0);\n        }\n    }\n    \n    \n    if (mod(float(iFrame), 300.) == 0. && fragCoord.y > 30.)\n    {\n        col = vec4(.0,-.2, -0.,0);\n    }\n    \n    col.a = q.x;\n    \n\tfragColor = col;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/\/ Homecomputer by nimitz 2016 (twitter: @stormoid)\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\/\/ Contact the author for other licensing options\n\n\/\/Rendering\n\n\/*\n\tThis buffer renders each particles\n\tmultiple times per frame to allow particles\n\tto move more than one pixel per frame while still\n\tleaving a solid trail.\n*\/\n\n#define time iTime\nconst int numParticles = 100;\nconst int stepsPerFrame = 9;\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\nfloat mag(vec3 p){return dot(p,p);}\n\nvec4 drawParticles(in vec3 ro, in vec3 rd, in float ints)\n{\n    vec4 rez = vec4(0);\n    vec2 w = 1.\/iResolution.xy;\n    \n    for (int i = 0; i < numParticles; i++)\n    {\n        vec3 pos = texture(iChannel0, vec2(i,100.0)*w).rgb;\n        vec3 vel = texture(iChannel0, vec2(i,0.0)*w).rgb;\n        \n        float st = sin(time*0.6);\n        \n        for(int j = 0; j < stepsPerFrame; j++)\n        {\n            float d = mag((ro + rd*dot(pos.xyz - ro, rd)) - pos.xyz);\n            d *= 1000.;\n            d = 2.\/(pow(d,1.+ sin(time*0.6)*0.15)+1.5);\n            d *= (st+4.)*.8;\n\n            rez.rgb += d*(sin(vec3(.7,2.0,2.5)+float(i)*.015 + time*0.3 + vec3(5,1,6))*0.45+0.55)*0.005;\n            \n            pos.xyz += vel*0.002*1.5;\n        }\n    }\n    \n    return rez;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\t\n    vec2 q = fragCoord.xy\/iResolution.xy;\n\tvec2 p = fragCoord.xy\/iResolution.xy-0.5;\n\tp.x*=iResolution.x\/iResolution.y;\n\t\n\tvec3 ro = vec3(0.,0.,2.7);\n    vec3 rd = normalize(vec3(p,-.5));\n    \n    vec3 sndNFO = texture(iChannel2, vec2(0.65, 0.1)).zwx + vec3(-.5, -0.1, -0.0);\n    \n    vec4 cola = drawParticles(ro, rd, sndNFO.y)*10.;\n    if (mod(time+q.x*.15+q.y*0.15,28.) < 14.)cola = vec4(.9,.95,1.,1.)-cola*.9; \/\/Invert colors\n    \n    vec2 mv = vec2(pow(sndNFO.z,2.)*0.05,sndNFO.x*.95);\n    mv *= mm2(time*1.);\n    \n    vec4 colb = texture(iChannel1, q+mv);\n    \/\/vec4 colb = texture(iChannel1, q);\n    \n    vec4 col = mix(cola, colb, 0.91);\n    if (iFrame < 5) col = vec4(0);\n    \n\tfragColor = col;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"lsfGR2","filepath":"https:\/\/soundcloud.com\/dubmood\/kraftwerk-heimcomputer-dubmood-gem-tos-remix","previewfilepath":"https:\/\/soundcloud.com\/dubmood\/kraftwerk-heimcomputer-dubmood-gem-tos-remix","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\/\/ Homecomputer by nimitz 2016 (twitter: @stormoid)\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\/\/ Contact the author for other licensing options\n\n\/*\n \tThe goal of this Buffer is to prepare\n\tthe sound data so that it can be used \n\tby the other buffers\n\n\tData output:\n\tx = fft\n\ty = waveform\n\tz = filtered waveform\n\tw = filtered fft summed over many bands\n*\/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy\/iResolution.xy;\n    float fft  = texture( iChannel1, vec2(q.x,0.25) ).x;\n\tfloat nwave = texture( iChannel1, vec2(q.x,0.75) ).x;\n    \n    float owave = texture( iChannel0, vec2(q.x,0.25) ).z;\n    float offt  = texture( iChannel0, vec2(q.x,0.25) ).w;\n    \n    \n    float fwave = mix(nwave,owave, 0.85);\n    \n    \n    \/*\n        get fft sum over many bands, this will allow\n\t\tto ge tthe current \"intensity\" of a track\n\t*\/\n    float nfft = 0.;\n    for (float i = 0.; i < 1.; i += 0.05)\n    {\n        nfft += texture( iChannel1, vec2(i,0.25) ).x; \n    }\n    nfft = clamp(nfft\/30.,0.,1.);\n    \n    float ffts = mix(nfft, offt, 0.8);\n    \n    if (iFrame < 5) \n    {\n        fft = 0.;\n        fwave= .5;\n        ffts = 0.;\n    }\n    \n    fragColor = vec4(fft, nwave, fwave, ffts);\n}","name":"Buffer C","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"fsXXzX","date":"1618927470","viewed":14293,"name":"English Lane","username":"blackjero","description":"You are walking and flying through an infinite English countryside. \nChill out and use the mouse to look around. \nA single walk->fly cycle is about 50s.","likes":291,"published":3,"flags":32,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"IMAGE","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\/\/ English Lane by Jerome Liard, April 2021\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/ https:\/\/www.shadertoy.com\/view\/fsXXzX\n\/\/\n\/\/ You are walking and flying through an infinite English countryside.\n\/\/ Chill out and use the mouse to look around. \n\/\/ A single walk->fly cycle is about 50s.\n\/\/\n\/\/ Shadertoy compilation time seems to be about 15s, thanks for your patience.\n\n\/\/ This is the start lane index. At each walk-flight cycle we switch to the next lane midair.\n\/\/ You can set any reasonable integer value (negative ok too) to walk along other paths.\n\n#define FIRST_LANE_INDEX 10.0\n\/\/#define FIRST_LANE_INDEX (-80.0+mod(iDate.x*365.+iDate.y*31.+iDate.z,160.)) \/\/ one different lane every day (no fade when day changes)\n\n\/\/ If the reprojection is janky please press the button that resets time to zero.\n\/\/\n\/\/ I wanted to make a navigable countryside with paths inspired by paintings from Richard Thorn (see his book \"Down an English Lane\"), \n\/\/ and a little bit by Hiroshi Nagai and Tezuka Osamu's Jumping short anime (both life long inspirations).\n\/\/\n\/\/ Creation of the initial patchwork and parameterized paths network:\n\/\/\n\/\/   - 2 perpendicular sets of regularly spaced parallel 1d lanes are used. \n\/\/   - Each 1d lane has an id. The amplitude of each 1d lane must be such that they don't cross the previous or next 1d lane.\n\/\/   - The horizonal set of parallel lanes have constant vertical center spacing.\n\/\/   - The twist: the vertical set of parallel lanes can have their spacing set more freely based on which stab we are in the horizontal set.\n\/\/     This helps generating complex branching patterns.\n\/\/   - For each set of parallel lanes we simply use its local x coordinate as a parameter (used for garden brick wall and camera).\n\/\/   - The intersections of lane stabs give us a cellular base for country patches, and for each patch we get an id, a distance to boundary, and parameterized borders.\n\/\/\n\/\/ Trees and houses placement:\n\/\/\n\/\/   - Patches ids is used to decide what combination of things goes on the patch (trees, bushes, farms, walls, lawn...)\n\/\/   - There are 3 layers of cellular placement for trees, bushes, and farms.\n\/\/     - Bushes are too close to each other and must be soft blended, but 3x3 search is no-no so we do a \"4 or 5\" neighbours search (we only consider checkboard black cells).\n\/\/     - For farms and trees we use randomly decimated jittered grid and actually only consider the current cell we are in, and hack marching to death to compensate.\n\/\/   - Modeling:\n\/\/     - Trees leaves volume have a base shape done with 2 spheres soft blended, then distored by 2 layers of packed 3d spheres tiling to blobify the leaves volume, and then some fine noise distortion on the surface.\n\/\/       The use of densely packed sphere tiling is inspired by @Shane's Cellular Tiling https:\/\/www.shadertoy.com\/view\/4scXz2\n\/\/     - Farms are randomized with gable and hipped roof, chimneys and colors very vaguely inspired by pictures of Devon.\n\/\/\n\/\/ Marching:\n\/\/\n\/\/   - For patches, marching uses ghost steps nearby patch boundaries so that we don't check neighbour patches objects, only the patch we are in.\n\/\/   - For trees and farms too, we force the raymarch to take ghost steps along their cell borders for x1 sdf eval.\n\/\/     - This ghost point machinery is hacky and not perfect (esp on patches boundary where we don't have clean intersections) but still helps.\n\/\/   - Because of all the cellular evals going on, to save height evals we use taylor expansion of the heightfield on local neiborhood.\n\/\/   - Despite above efforts I had to resort to reprojection and still perf isn't great. \n\/\/     Blurring the noise with reprojection also helps hide the general noisy lameness and gives better colors.\n\/\/\n\/\/ Clouds are volumetric but baked in a spheremap at first frame and assumed distant.\n\/\/ Also had to turn view trace\/shadow trace\/scene gradient\/cellular evals into loops to help compile time on the website, sometimes at the expense of runtime perfs.\n\/\/ As always some code, techniques, ideas from @iq, @Dave_Hoskins, @Shane, @FabriceNeyret2 are used in various places, \n\/\/ this shader also uses some spherical gaussian code from Matt Pettineo \n\/\/ (see comment for links to references).\n\n#define PI 3.141592654 \/\/ He does love his numbers\n#define FLT_MAX 1000000.0\n\n#define SQR2 1.414213562\n#define SQR3 1.732050807\n\n#define RED  vec3( 1, 0, 0 )\n#define GREEN vec3( 0, 1, 0 )\n#define BLUE vec3( 0, 0, 1 )\n#define WHITE vec3( 1, 1, 1 )\n#define BLACK vec3( 0, 0, 0 )\n#define MAGENTA vec3( 1, 0, 1 )\n#define YELLOW vec3( 1, 1, 0 )\n#define AZURE vec3( 0.0, 0.5, 1.0 )\n\n#define A_FEW_FUNC(type) \\\ntype saturate( type x ) { return clamp( x, type(0.0), type(1.0) ); } \\\ntype smoothstep_unchecked( type x ) { return ( x * x ) * ( type(3.0) - x * 2.0 ); } \\\ntype smoothstep_unchecked_d( type x ) { return 6.0 * x * ( type(1.0) - x ); }\n\nA_FEW_FUNC( float )\nA_FEW_FUNC( vec2 )\nA_FEW_FUNC( vec3 )\nA_FEW_FUNC( vec4 )\n\nfloat exp_decay( float x ) { return 1. - exp( -x ); }\n\/\/ cubic bump that goes through (0,0)->(1,0)\n\/\/ slope at x=0 is df0\n\/\/ slope at x=1 is df1\nfloat cubicbump( float x, float df0, float df1 ) { float a = df1 + df0; float c = df0; float b = -a - c; return x * ( x * ( x * a + b ) + c ); }\nfloat smoothbump( float a, float r, float x ) { return 1.0 - smoothstep_unchecked( min( abs( x - a ), r ) \/ r ); }\n\/\/ like smoothstep, but takes a center and a radius instead\nfloat smoothstep_c( float x, float c, float r ) { return smoothstep( c - r, c + r, x ); }\n\/\/ centered at 0\nfloat smoothband( float x, float r, float raa ) { return 1. - smoothstep_c( abs( x ), r, raa ); }\n\/\/ range s,e\nfloat smoothband( float x, float s, float e, float raa ) { return smoothband( x - ( e + s ) * 0.5, ( e - s ) * 0.5, raa ); }\nvec2 perp( vec2 v ) { return vec2( -v.y, v.x ); }\nfloat calc_angle( vec2 v ) { return atan( v.y, v.x ); } \/\/ return range -pi,pi\nfloat calc_angle( vec2 a, vec2 b ) { return calc_angle( vec2( dot( a, b ), dot( perp( a ), b ) ) ); }\nfloat contrast( float x, float s ) { return ( x - 0.5 ) * s + 0.5; }\nvec3 contrast( vec3 x, vec3 s ) { return ( x - 0.5 ) * s + 0.5; }\nfloat lensqr( vec2 v ) { return dot( v, v ); }\nfloat lensqr( vec3 v ) { return dot( v, v ); }\nfloat lensqr( vec4 v ) { return dot( v, v ); }\nfloat pow2( float x ) { return x * x; }\nvec3 pow2( vec3 x ) { return x * x; }\nvec4 pow2( vec4 x ) { return x * x; }\n\/\/ variant of exp\/log soft min and max that save a few instructions\nfloat smin_exp2( float a, float b, float k ) { return -log2( exp2( -k * a ) + exp2( -k * b ) ) \/ k; }\nfloat smax_exp2( float a, float b, float k ) { return -smin_exp2( -a, -b, k ); }\n\/\/ https:\/\/iquilezles.org\/articles\/smin\nfloat smin_pol( float a, float b, float k ) { float h = clamp( 0.5f + 0.5f * ( b - a ) \/ k, 0.0f, 1.0f ); return mix( b, a, h ) - k * h * ( 1.0 - h ); }\nfloat smax_pol( float a, float b, float k ) { return -smin_pol( -a, -b, k ); }\nfloat powerful_scurve( float x, float p1, float p2 ) { return pow( 1.0 - pow( 1.0 - clamp( x, 0.0, 1.0 ), p2 ), p1 ); }\nfloat maxcomp( float x ) { return x; }\nfloat maxcomp( vec2 v ) { return max( v.x, v.y ); }\nfloat maxcomp( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat min_( float x, float y, float z ) { return min( min( x, y ), z ); }\nfloat max_( float x, float y, float z ) { return max( max( x, y ), z ); }\nfloat nearest( float x ) { return floor( 0.5 + x ); }\nfloat nearest( float x, float spacing ) { return floor( 0.5 + x \/ spacing ) * spacing; }\nvec2 nearest( vec2 x, vec2 spacing ) { return floor( vec2( 0.5 ) + x \/ spacing ) * spacing; }\nfloat sum( vec4 v ) { return v.x + v.y + v.z + v.w; }\nfloat safe_acos( float x ) { return acos( clamp( x, -1., 1. ) ); }\n\n\/\/ project this on line (O,d), d is assumed to be unit length\n#define PROJECT_ON_LINE1(type) \\\ntype project_on_line( type P, type O, type d ) { return O + d * dot( P - O , d ) \/ dot(d, d ); } \\\ntype project_on_plane( type P, type O, type n ) { return P - n * dot( P - O , n ) \/ dot(n, n ); } \\\n\nPROJECT_ON_LINE1( vec2 )\nPROJECT_ON_LINE1( vec3 )\n\n\/\/ https:\/\/iquilezles.org\/articles\/distance\n\/\/ fast and nice in most cases\n#define FAST_SIGNED_DISTANCE_TO_FUNC_11_ARG( a_signed_distance, a_p, a_func, a_arg, a_epsilon ) \\\n{ \\\n\tvec2 _p = a_p; \\\n\tfloat _epsilon = a_epsilon; \\\n\tfloat _y = a_func( _p.x, a_arg ); \\\n\tfloat _y1 = a_func( _p.x + _epsilon, a_arg ); \\\n\tfloat _ddy = ( _y1 - _y ) * ( 1. \/ _epsilon ); \\\n\ta_signed_distance = ( _p.y - _y ) \/ sqrt( 1. + _ddy * _ddy ); \\\n}\n\n\/\/ this macro returns:\n\/\/  - the vector to the closest point on a curve (the length of which gives a better distance than FAST_SIGNED_DISTANCE_TO_FUNC_11) \n\/\/  - the tangent at that closest point\n\/\/ http:\/\/www.geometrie.tugraz.at\/wallner\/sproj.pdf\n\/\/ input:\n\/\/  a_p               eval at pos\n\/\/  a_funcd           is the R->R function to evaluate, first guess (iteration start point) is vec2(a_p.x,a_func(a_p.x))\n\/\/                    a_funcd can be a macro, it seems\n\/\/                    returns the function value at t in .x and the derivative at t in .y\n\/\/  a_funcd_arg       an argument passed to a_func\n\/\/  a_cheap           num iterations, 2 should be enough, a_cheap==true only does 1 iteration\n\/\/\n\/\/ output:\n\/\/  a_ret   \t\t  a_ret.xy is vector to closest point on curve\n\/\/                    a_ret.zw is the derivative (tangent at the closest point)\n\/\/\n\/\/ note: we could get the sign from the first iteration\n\n#define CLOSEST_POINT_TANGENT_TO_FUNCD_11_ARG_CHEAP( a_ret, a_p, a_funcd, a_funcd_arg, a_cheap ) \\\n{ \\\n\tvec2 _p = a_p.xy, _c, _dc, _ev; \\\n\tfloat _t = _p.x; \/* t0, could be a parameter if the user knows better *\/ \\\n\t_ev = a_funcd( _t, a_funcd_arg ); \\\n\t_c = vec2( _t, _ev.x ); \\\n\t_dc = vec2( 1.0, _ev.y ); \/*important: 1 in x!*\/ \\\n\tif ( !(a_cheap) ) \/* IMPORTANT: if num iteration is 2, an if test can behave much better than for loop *\/ \\\n\t{ \\\n\t\t\/*#if 0*\/ \\\n\t\t\/*vec2 _q = project_on_line( _p.xy, _c, _dc );*\/ \\\n\t\t\/*_t += dot( _dc, _q - _c ) \/ dot( _dc, _dc );*\/ \\\n\t\t\/* simplifies to: *\/ \\\n\t\t\/*#else*\/ \\\n\t\t_t += dot( _p.xy - _c, _dc ) \/ dot( _dc, _dc ); \\\n\t\t\/*#endif*\/ \\\n\t\t_ev = a_funcd( _t, a_funcd_arg ); \\\n\t\t_c = vec2( _t, _ev.x ); \\\n\t\t_dc = vec2( 1.0, _ev.y ); \/*important: 1 in x!*\/ \\\n\t} \\\n\ta_ret = vec4( _c - _p, _dc ); \\\n}\n\nvec3 transform_vector( mat4 m, vec3 v ) { return ( m * vec4( v, 0.0 ) ).xyz ; }\n\nstruct bounds2 { vec2 pmin; vec2 pmax; };\nbounds2 mkbounds_unchecked( vec2 amin, vec2 amax ) { bounds2 ret; ret.pmin = amin; ret.pmax = amax; return ret; }\n\n#define REPEAT_FUNCTIONS( type ) \\\ntype repeat( type x, type len ) { return len * fract( x * ( type( 1.0 ) \/ len ) ); }\\\ntype repeat_mirror( type x, type len ) { return len * abs( type( -1.0 ) + 2.0 * fract( ( ( x * ( type( 1.0 ) \/ len ) ) - type( -1.0 ) ) * 0.5 ) ); }\n\nREPEAT_FUNCTIONS( float )\nREPEAT_FUNCTIONS( vec2 )\n\n\/\/ badly antialiased stripes\n\/\/ r is the half width of the stripes\n\/\/ raa is the half size of the edge\/aa smoothstep (ex: pixel_size)\n\/\/ period is the distance between 2 consecutive stripes\n\nfloat stripes( float x, float period, float r, float raa ) { return smoothstep( r + raa, r - raa, repeat_mirror( x, period * 0.5 ) ); }\nvec2 stripes( vec2 x, vec2 period, vec2 r, vec2 raa ) { return smoothstep( r + raa, r - raa, repeat_mirror( x, period * 0.5 ) ); }\n\n\/\/ triangular sin waves - you can drop in as a replacement for sin to get polygonized looks\nfloat tri_sin( float x ) { return (abs(fract((x-PI*0.5)\/(PI*2.))-0.5)-0.25)*4.0; }\n\n\/\/ hash functions from David Hoskins's https:\/\/www.shadertoy.com\/view\/4djSRW\n\n\/\/ Hash without Sine\n\/\/ MIT License...\n\/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*\/\n\nfloat hash11(float p) { p = fract(p * .1031); p *= p + 33.33; p *= p + p; return fract(p); }\nfloat hash12(vec2 p) { vec3 p3 = fract(vec3(p.xyx ) * .1031); p3 += dot(p3, p3.yzx + 33.33); return fract((p3.x + p3.y) * p3.z); }\nfloat hash13(vec3 p3) { p3 = fract(p3 * .1031); p3 += dot(p3, p3.yzx + 33.33); return fract((p3.x + p3.y) * p3.z); }\nvec2 hash22(vec2 p) { vec3 p3 = fract(vec3(p.xyx ) * vec3(.1031, .1030, .0973)); p3 += dot(p3, p3.yzx +33.33); return fract((p3.xx +p3.yz )*p3.zy ); }\nvec2 hash23(vec3 p3) { p3 = fract(p3 * vec3(.1031, .1030, .0973)); p3 += dot(p3, p3.yzx +33.33); return fract((p3.xx +p3.yz )*p3.zy ); }\nvec3 hash31(float p) { vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973)); p3 += dot(p3, p3.yzx +33.33); return fract((p3.xxy +p3.yzz )*p3.zyx ); }\nvec3 hash32(vec2 p) { vec3 p3 = fract(vec3(p.xyx ) * vec3(.1031, .1030, .0973)); p3 += dot(p3, p3.yxz +33.33); return fract((p3.xxy +p3.yzz )*p3.zyx ); }\nvec3 hash33(vec3 p3) { p3 = fract(p3 * vec3(.1031, .1030, .0973)); p3 += dot(p3, p3.yxz +33.33); return fract((p3.xxy + p3.yxx )*p3.zyx ); }\n\n\/\/###############################################################################\n\n\/\/ iq's function munged for vec4, used in city shader...\n\/\/ https:\/\/www.shadertoy.com\/view\/XlXcW4 note: source has changed since then...\n\nvec4 hash42_( ivec2 x0 )\n{\n\tuint k = 1103515245U;  \/\/ GLIB C\n\tuvec4 x = uvec4( x0, x0 * 0x8da6b343 );\n\tx = (( x >> 13U ) ^ x.yzwx ) * k;\n\tx = (( x >> 13U ) ^ x.zwxy ) * k;\n\/\/\tx = (( x >> 13U ) ^ x.wxyz ) * k; \/\/ can't really tell the difference\n\treturn vec4( x ) * ( 1.0 \/ float( 0xffffffffU ));\n}\n\n\/\/ integer hashes\n\/\/ https:\/\/www.shadertoy.com\/view\/4tXyWN iq\n\nfloat hash1u2_4tXyWN( uvec2 x )\n{\n\tuvec2 q = 1103515245U * ( ( x >> 1U ) ^ ( x.yx  ) );\n\tuint  n = 1103515245U * ( ( q.x  ) ^ ( q.y >> 3U ) );\n\treturn float( n ) * ( 1.0 \/ float( 0xffffffffU ) );\n}\n\n\/\/ https:\/\/nullprogram.com\/blog\/2018\/07\/31\/ Chris Wellons\n\/\/ https:\/\/www.shadertoy.com\/view\/WttXWX via Fabrice\n\nuint lowbias32(uint x) { x ^= x >> 16; x *= 0x7feb352dU; x ^= x >> 15; x *= 0x846ca68bU; x ^= x >> 16; return x; }\nfloat hash11u_lowbias32( uint x ) { return float( lowbias32( x ) ) \/ float( 0xffffffffU ); }\n\n#define V30 vec2( 0.866025403, 0.5 )\n#define V45 vec2( 0.707106781, 0.707106781 )\n#define V60 vec2( 0.5, 0.866025403 )\n\n\/\/ return a unit vector, or an angle (it's the same thing)\nvec2 unit_vector2( float angle ) { return vec2( cos( angle ), sin( angle ) ); }\n\/\/ note that if point p is also a unit vector, rotate_with_unit_vector returns the same as doing unit_vector2 on the sum of the angles (obvious but)\nvec2 rotate_with_unit_vector( vec2 p, vec2 cs ) { return vec2( cs.x * p.x - cs.y * p.y, cs.y * p.x + cs.x * p.y ); }\nvec2 rotate_with_angle( vec2 p, float a_angle ) { return rotate_with_unit_vector( p, unit_vector2( a_angle ) ); }\n\n\/\/ theta is angle with the z axis, range [0,pi].\n\/\/ phi is angle with x vectors on z=0 plane, range [0,2pi].\n\/\/ theta_vec is the unit vector for angle theta\n\/\/ phi_vec is the unit vector for angle phi\nvec3 zup_spherical_coords_to_vector( vec2 theta_vec, vec2 phi_vec ) { return vec3( theta_vec.y * phi_vec, theta_vec.x ); }\nvec3 zup_spherical_coords_to_vector( float theta, float phi ) { return zup_spherical_coords_to_vector( unit_vector2( theta ), unit_vector2( phi ) ); }\nvec3 zup_spherical_coords_to_vector( vec2 theta_phi ) { return zup_spherical_coords_to_vector( theta_phi.x, theta_phi.y ); }\n\n\/\/ note: n.xy==0 is undefined for phi, pleae handle in caller code\nvec2 vector_to_zup_spherical_coords( vec3 n )\n{\n\tfloat theta = safe_acos( n.z ); \/\/ note: vectors normalized with normalize() are not immune to -1,1 overflow which cause nan in acos\n\tfloat phi = calc_angle( n.xy  );\n\treturn vec2( theta, phi );\n}\n\nvec3 yup_spherical_coords_to_vector( vec2 theta, vec2 phi ) { return zup_spherical_coords_to_vector( theta, phi ).yzx ; }\nvec3 yup_spherical_coords_to_vector( float theta, float phi ) { return yup_spherical_coords_to_vector( unit_vector2( theta ), unit_vector2( phi ) ); }\n\nmat4 yup_spherical_coords_to_matrix( vec2 theta, vec2 phi )\n{\n\tvec3 y = yup_spherical_coords_to_vector( theta, phi );\n\tvec3 z = yup_spherical_coords_to_vector( perp( theta ), phi ); \/\/ note: perp(theta) = unit_vector2(theta+PI*0.5)\n\tvec3 x = cross( y, z );\n\treturn ( mat4( vec4( x, 0.0 ), vec4( y, 0.0 ), vec4( z, 0.0 ), vec4( 0, 0, 0, 1 ) ) );\n}\n\nmat4 yup_spherical_coords_to_matrix( float theta, float phi ) {  return yup_spherical_coords_to_matrix( unit_vector2( theta ), unit_vector2( phi ) ); }\n\nmat4 z_rotation( float angle ) { vec2 v = unit_vector2( angle ); return mat4( vec4( v.x, v.y, 0.0, 0.0 ), vec4( -v.y, v.x, 0.0, 0.0 ), vec4( 0, 0, 1, 0 ), vec4( 0, 0, 0, 1 ) ); }\n\nmat3 mat3_rotation_x( vec2 v ) { return mat3( vec3( 1, 0, 0 ), vec3( 0, v.x, v.y ), vec3( 0, -v.y, v.x ) ); }\nmat3 mat3_rotation_z( vec2 v ) { return mat3( vec3( v.x, v.y, 0 ), vec3( -v.y, v.x, 0 ), vec3( 0, 0, 1 ) ); }\n\n\/\/ icdf for pdf a*exp(-a*x) (wikipedia Exponential distribution)\nfloat ed_icdf( float u, float a ) { return -log( 1. - u ) * ( 1.0 \/ a ); }\n\n#define INDEXHASHOFFSET3 vec3( 137.0, 53.0, 173 )\n\n#define LAYERED1(func,p,args) ((func(p*1.0,args)*0.5)                                                                                               *(1.0\/(0.5)))\n#define LAYERED2(func,p,args) ((func(p*1.0,args)*0.5+func(p*2.0,args)*0.25)                                                                         *(1.0\/((0.5+0.25))))\n#define LAYERED4(func,p,args) ((func(p*1.0,args)*0.5+func(p*2.0,args)*0.25+func(p*4.0,args)*0.125+func(p*8.0,args)*0.0625)                          *(1.0\/((0.5+0.25+0.125+0.0625))))\n#define LAYERED5(func,p,args) ((func(p*1.0,args)*0.5+func(p*2.0,args)*0.25+func(p*4.0,args)*0.125+func(p*8.0,args)*0.0625+func(p*16.0,args)*0.03125)*(1.0\/((0.5+0.25+0.125+0.0625+0.03125))))\n\nfloat noise12( vec2 p, bool use_smooth )\n{\n\tp -= 0.5;\n\n\tvec2 p00 = floor( p );\n\tvec2 p10 = p00 + vec2( 1, 0 );\n\tvec2 p01 = p00 + vec2( 0, 1 );\n\tvec2 p11 = p00 + vec2( 1, 1 );\n\n\tfloat v00 = hash12( p00 );\n\tfloat v10 = hash12( p10 );\n\tfloat v01 = hash12( p01 );\n\tfloat v11 = hash12( p11 );\n\n\tvec2 f = fract( p ); \/\/ p-p00 but beware large values...\n\n\tif ( use_smooth ) f = smoothstep_unchecked( f );\n\n\tfloat A = v10 - v00;\n\tfloat B = v01 - v00;\n\tfloat C = ( v11 - v01 ) - A;\n\tfloat D = v00;\n\n\/\/\treturn mix( mix( v00, v10, f.x ), mix( v01, v11, f.x ), f.y ),\n\treturn A * f.x + B * f.y + C * f.x * f.y + D;\n}\n\nfloat noise13( vec3 p, bool use_smooth )\n{\n\tp -= 0.5;\n\n\tvec3 p000 = floor( p ) + INDEXHASHOFFSET3;\n\tvec3 p100 = p000 + vec3( 1, 0, 0 );\n\tvec3 p010 = p000 + vec3( 0, 1, 0 );\n\tvec3 p110 = p000 + vec3( 1, 1, 0 );\n\tvec3 p001 = p000 + vec3( 0, 0, 1 );\n\tvec3 p101 = p000 + vec3( 1, 0, 1 );\n\tvec3 p011 = p000 + vec3( 0, 1, 1 );\n\tvec3 p111 = p000 + vec3( 1, 1, 1 );\n\n\tfloat v000 = hash13( p000 );\n\tfloat v100 = hash13( p100 );\n\tfloat v010 = hash13( p010 );\n\tfloat v110 = hash13( p110 );\n\tfloat v001 = hash13( p001 );\n\tfloat v101 = hash13( p101 );\n\tfloat v011 = hash13( p011 );\n\tfloat v111 = hash13( p111 );\n\n\tvec3 f = fract( p ); \/\/ bilinear\n\n\tif ( use_smooth ) f = smoothstep_unchecked(f);\n\t\n\treturn mix( mix( mix( v000, v100, f.x ),\n\t\t\t\t\t mix( v010, v110, f.x ), f.y ),\n\t\t\t\tmix( mix( v001, v101, f.x ),\n\t\t\t\t\t mix( v011, v111, f.x ), f.y ), f.z );\n}\n\nvec3 noise33( vec3 p, bool use_smooth )\n{\n\tp -= 0.5;\n\n\tvec3 p000 = floor( p ) + INDEXHASHOFFSET3;\n\tvec3 p100 = p000 + vec3( 1, 0, 0 );\n\tvec3 p010 = p000 + vec3( 0, 1, 0 );\n\tvec3 p110 = p000 + vec3( 1, 1, 0 );\n\tvec3 p001 = p000 + vec3( 0, 0, 1 );\n\tvec3 p101 = p000 + vec3( 1, 0, 1 );\n\tvec3 p011 = p000 + vec3( 0, 1, 1 );\n\tvec3 p111 = p000 + vec3( 1, 1, 1 );\n\n\tvec3 v000 = hash33( p000 );\n\tvec3 v100 = hash33( p100 );\n\tvec3 v010 = hash33( p010 );\n\tvec3 v110 = hash33( p110 );\n\tvec3 v001 = hash33( p001 );\n\tvec3 v101 = hash33( p101 );\n\tvec3 v011 = hash33( p011 );\n\tvec3 v111 = hash33( p111 );\n\n\tvec3 f = fract( p ); \/\/ bilinear\n\n\tif ( use_smooth ) f = smoothstep_unchecked(f); \/\/ looks sharper in 3d\n\n\treturn mix( mix( mix( v000, v100, f.x ),\n\t\t\t\t\t mix( v010, v110, f.x ), f.y ),\n\t\t\t\tmix( mix( v001, v101, f.x ),\n\t\t\t\t\t mix( v011, v111, f.x ), f.y ), f.z );\n}\n\nfloat enoise13( vec3 p, float a, bool use_smooth )\n{\n\tp -= 0.5;\n\n\tvec3 p000 = floor( p ) + INDEXHASHOFFSET3;\n\tvec3 p100 = p000 + vec3( 1, 0, 0 );\n\tvec3 p010 = p000 + vec3( 0, 1, 0 );\n\tvec3 p110 = p000 + vec3( 1, 1, 0 );\n\tvec3 p001 = p000 + vec3( 0, 0, 1 );\n\tvec3 p101 = p000 + vec3( 1, 0, 1 );\n\tvec3 p011 = p000 + vec3( 0, 1, 1 );\n\tvec3 p111 = p000 + vec3( 1, 1, 1 );\n\n\tvec2 h000 = hash23( p000 );\n\tvec2 h100 = hash23( p100 );\n\tvec2 h010 = hash23( p010 );\n\tvec2 h110 = hash23( p110 );\n\tvec2 h001 = hash23( p001 );\n\tvec2 h101 = hash23( p101 );\n\tvec2 h011 = hash23( p011 );\n\tvec2 h111 = hash23( p111 );\n\n\tfloat v000 = ed_icdf( h000.x, a ) * h000.y;\n\tfloat v100 = ed_icdf( h100.x, a ) * h100.y;\n\tfloat v010 = ed_icdf( h010.x, a ) * h010.y;\n\tfloat v110 = ed_icdf( h110.x, a ) * h110.y;\n\tfloat v001 = ed_icdf( h001.x, a ) * h001.y;\n\tfloat v101 = ed_icdf( h101.x, a ) * h101.y;\n\tfloat v011 = ed_icdf( h011.x, a ) * h011.y;\n\tfloat v111 = ed_icdf( h111.x, a ) * h111.y;\n\n\tvec3 f = fract( p ); \/\/ bilinear\n\n\tif ( use_smooth ) f = smoothstep_unchecked(f); \/\/ looks sharper in 3d\n\n\treturn mix( mix( mix( v000, v100, f.x ),\n\t\t\t\t\t mix( v010, v110, f.x ), f.y ),\n\t\t\t\tmix( mix( v001, v101, f.x ),\n\t\t\t\t\t mix( v011, v111, f.x ), f.y ), f.z );\n}\n\n\/\/ prefix meaning: \n\/\/  e stands for exponential distribution\n\/\/  s stands for smoothstep interpolation\nfloat snoise12_( vec2 p, float args ) { return noise12( p, true ); }\nfloat snoise13_( vec3 p, float args ) { return noise13( p, true ); }\nvec3 noise33_( vec3 p, float args ) { return noise33( p, false ); }\nfloat enoise13_( vec3 p, float a ) { return enoise13( p, a, false ); }\nfloat sfbm1_12( vec2 p ) { return LAYERED1( snoise12_, p, -1.0); }\nfloat sfbm2_13( vec3 p ) { return LAYERED2( snoise13_, p, -1.0); }\nfloat sfbm2_13_leaf( vec3 p ) { return (noise13(p*0.8,true)+noise13(p*4.0,true)*0.6)\/1.5;}\nfloat sfbm2_12( vec2 p ) { return LAYERED2( snoise12_, p, -1.0); }\nfloat efbm4_13( vec3 p, float arg ) { return LAYERED4( enoise13_, p, arg); }\nvec3 sfbm4_33( vec3 p ) { return LAYERED5( noise33_, p, -1.0); }\n\nstruct Ray { vec3 o; vec3 d;  };\n\nRay mkray( vec3 o, vec3 d ) { Ray tmp; tmp.o = o; tmp.d = d; return tmp; }\n\nvec3 get_view_dir( vec2 normalized_pos, float aspect, float tan_half_fovy_rcp )\n{\n\treturn normalize( vec3( normalized_pos.x * aspect, normalized_pos.y, -tan_half_fovy_rcp ) ); \/\/ note: looking down z\n}\n\n\/\/ same as get_view_ray_old but without a znear\n\/\/ note that we pass the reciprocal of tan_half_fovy\n\/\/ normalized_pos is (-1,1-)->(1,1)\nRay get_view_ray2( vec2 normalized_pos, float aspect, float tan_half_fovy_rcp, mat4 camera )\n{\n\treturn mkray( camera[3].xyz , transform_vector( camera, get_view_dir( normalized_pos, aspect, tan_half_fovy_rcp ) ) );\n}\n\nmat4 lookat( vec3 eye, vec3 center, vec3 up )\n{\n\tvec3 z = normalize( eye - center );\n\tvec3 x = normalize( cross( up, z ) );\n\tvec3 y = cross( z, x );\n\treturn mat4( vec4( x, 0.0 ), vec4( y, 0.0 ), vec4( z, 0.0 ), vec4( eye, 1.0 ) );\n}\n\nvec2 sphere_trace( Ray ray, float radius, vec3 center )\n{\n\tvec3 O = ray.o;\n\tvec3 d = ray.d;\n\tfloat tp = dot( center - O, d ); \/\/ O + d * tp = center projected on line (O,d)\n\tfloat h_sqr = lensqr( ( O + d * tp ) - center );\n\tfloat radius_sqr = radius * radius;\n\tif ( h_sqr > radius_sqr ) return vec2( FLT_MAX, FLT_MAX ); \/\/ ray missed the sphere\n\tfloat dt = sqrt( radius_sqr - h_sqr ); \/\/ distance from P to In (near hit) and If (far hit)\n\treturn vec2( tp - dt, tp + dt ); \/\/ record 2 hits In, If\n}\n\nfloat plane_trace( vec3 ray_o, vec3 ray_d, vec3 base, vec3 n, float epsilon ) { float ddotn = dot( ray_d, n ); return abs( ddotn ) > epsilon ? dot( base - ray_o, n ) \/ ddotn : FLT_MAX; }\nfloat plane_trace( Ray ray, vec3 base, vec3 n, float epsilon ) { float ddotn = dot( ray.d, n ); return abs( ddotn ) > epsilon ? dot( base - ray.o, n ) \/ ddotn : FLT_MAX; }\nfloat plane_trace_z( Ray ray, float base, float epsilon ) { return abs( ray.d.z ) > epsilon ? ( base - ray.o.z ) \/ ray.d.z : FLT_MAX; }\n\/\/ d is a unit direction, ray starts at 0,0,0 base is plane position along z, this is just a division...\nfloat plane_trace_z( vec3 d, float base, float epsilon ) { return abs( d.z ) > epsilon ? base \/ d.z : FLT_MAX; }\n\n\/\/ build a little quadric so that y'(0)=0, y(r)=r, y'(r)=1 here\nfloat her2( float x, float r ) { return 0.5 * ( ( 1.0 \/ r ) * x * x + r ); }\n\/\/ smooth bevel (like a soft_abs function)\nfloat curved_max_vfunc_weld_quadric( float x, float r ) { x = abs( x ); return x > r ? x : her2( x, r ); }\n\/\/ max\nfloat opI( float d1, float d2 ) { return max( d1, d2 ); }\nfloat opI_soft2( float a, float b, float k ) { return smax_exp2( a, b, k ); }\nfloat opI_soft2_pol( float a, float b, float k ) { return smax_pol( a, b, k ); }\nfloat opI_weld_quadric( float a, float b, float r ) { float c = ( a + b ) * 0.5; return c + curved_max_vfunc_weld_quadric( a - c, r ); }\n\/\/ min(a,b) = -max(-a,-b)\nfloat opU( float d1, float d2 ) { return -max( -d1, -d2 ); }\nfloat opU_soft2_pol( float a, float b, float k ) { return -opI_soft2_pol( -a, -b, k ); }\nfloat opU_weld_quadric( float a, float b, float r ) { return -opI_weld_quadric( -a, -b, r ); }\nfloat opS( float d1, float d2 ) { return max( -d2, d1 );}\nfloat opS_soft2( float a, float b, float k ) { return opI_soft2( -b, a, k ); }\nfloat opI( float d1, float d2, float d3 ) { return max( max( d1, d2 ), d3 ); }\n\n\/\/ r can be zero\nfloat sd_bounds_range_round( vec2 p, vec2 mi, vec2 ma, float r )\n{\n\tvec2 h = ( ma - mi ) * 0.5;\n\tp = abs( p - ( mi + ma ) * 0.5 );\n\tvec2 c = h - r;\n\tfloat mask = maxcomp( step( c, p ) );\n\treturn mix( maxcomp( p - c ), length( max( p - c, vec2( 0.0 ) ) ), mask ) - r;\n}\n\n\/\/ r can be zero\nfloat sd_bounds_range_round( vec3 p, vec3 mi, vec3 ma, float r )\n{\n\tvec3 h = ( ma - mi ) * 0.5;\n\tp = abs( p - ( mi + ma ) * 0.5 );\n\tvec3 c = h - r;\n\tfloat mask = maxcomp( step( c, p ) );\n\treturn mix( maxcomp( p - c ), length( max( p - c, vec3( 0.0 ) ) ), mask ) - r;\n}\n\nfloat sd_bounds_half_size( float p, float h ) { p = abs( p ) - h; return p; }\nfloat sd_bounds_half_size( vec2 p, vec2 h ) { p = abs( p ) - h; return opI( p.x, p.y ); }\nfloat sd_bounds_half_size( vec3 p, vec3 h ) { p = abs( p ) - h; return opI( p.x, p.y, p.z ); }\nfloat sd_bounds_range( vec2 p, vec2 mi, vec2 ma ) { vec2 hmi = mi * 0.5; vec2 hma = ma * 0.5; return sd_bounds_half_size( p - ( hma + hmi ), hma - hmi ); }\n\/\/ those bounds repeat might be good after all, since they centering and lead to a correct repeat...\nfloat sd_bounds_range( float p, float mi, float ma ) { return sd_bounds_half_size( p - ( ( ma + mi ) * 0.5 ), ( ma - mi ) * 0.5 ); }\nfloat sd_bounds_range( vec3 p, vec3 mi, vec3 ma ) { return sd_bounds_half_size( p - ( ( ma + mi ) * 0.5 ), ( ma - mi ) * 0.5 ); }\n\nfloat sd_sphere( vec3 p, vec3 center, float radius ) { return length( p - center ) - radius; }\nfloat sd_sphere( vec2 p, vec2 center, float radius ) { return length( p - center ) - radius; }\n\n\/\/ iq's https:\/\/www.shadertoy.com\/view\/Xds3zN modified for z up\nfloat sdCylinder( vec3 p, vec2 h )\n{\n\tvec2 d = abs( vec2( length( p.xy ),p.z)) - h;\n\treturn min( max( d.x, d.y ), 0.0 ) + length( max( d, vec2( 0.0 ) ) );\n}\n\n\/\/ internal function in packed_spheres_tiling3d\nfloat packed_spheres_tiling3d_internal_layer( vec3 p )\n{\n\tvec2 rh = vec2( 1.0, SQR3 ); \/\/ r=1  (normally h = spacing*0.5 * SQR3, and here spacing=2)\n\tvec2 c = rh * 2.0; \/\/ cell size for each row\n\tvec2 i1 = floor( p.xy  \/ c );\n\tvec2 i2 = floor( ( p.xy  - rh ) \/ c );\n\treturn min(\n\t\tlength( p - vec3( ( i1 + vec2( 0.5 ) ) * c, 0 ) ) - 1.0f,\n\t\tlength( p - vec3( ( i2 + vec2( 0.5 ) ) * c + rh, 0 ) ) - 1.0f ); \/\/ second row offset by rh\n}\n\n\/\/ sdf of packed spheres of radius 1 (just add to distance for smaller radius...)\nfloat packed_spheres_tiling3d( vec3 p )\n{\n\tvec3 p0 = p;\n\tfloat h = SQR3; \/\/ height of equilateral triangle of edge len 1+1=2\n\tfloat b = ( 1.0 - h * h ) \/ ( -2.0 * h );\n\tfloat c = h - b;\n\tfloat h3 = sqrt( 2.0 * 2.0 - c * c ); \/\/ height of tetrahedra, also the spacing between layers, also the half period of each layer\n\tp = p0;\n\tp.z -= ( floor( ( p.z - ( -h3 ) ) \/ ( 2.0 * h3 ) ) + 0.5 ) * ( 2.0 * h3 ) - h3; \/\/ repeat layer\n\tfloat d1 = packed_spheres_tiling3d_internal_layer( p );\n\/\/\treturn d1;\n\tp = p0;\n\tp.y += h - b; \/\/ offset to overlap centers of first layer exactly\n\tp.z -= ( floor( ( p.z - 0.0 ) \/ ( 2.0 * h3 ) ) + 0.5 ) * ( 2.0 * h3 ) - 0.0; \/\/ repeat layer\n\tfloat d2 = packed_spheres_tiling3d_internal_layer( p );\n\/\/\treturn d2;\n\/\/\treturn opU( d1, d2 );\n\treturn min( d1, d2 );\n}\n\n\/\/ r is sphere radius, distance between 2 spheres is spacing\n\/\/ r must be < spacing\/2\nfloat packed_spheres_tiling3d( vec3 p, float r, float spacing )\n{\n\tfloat s = spacing * 0.5; \/\/ packed sphere radius\n\treturn packed_spheres_tiling3d( p * ( 1.0 \/ s ) ) * s + ( s - r );\n}\n\n\/\/ r is sphere radius, distance between 2 spheres is 2*r\nfloat packed_spheres_tiling3d( vec3 p, float r )\n{\n\treturn packed_spheres_tiling3d( p * ( 1.0 \/ r ) ) * r;\n}\n\nvec3 tonemap_reinhard( vec3 x ) { return x \/ ( 1. + x ); }\n\/\/ mentioned in http:\/\/resources.mpi-inf.mpg.de\/tmo\/logmap\/\nvec3 gamma_correction_itu( vec3 L ) { return mix( 4.5061986 * L, 1.099 * pow( L, vec3( 0.45 ) ) - 0.099, step( vec3( 0.018 ), L ) ); }\n\n\/\/ the couple of following functions are copied from Matt Pettineo's spherical gaussian article, \n\/\/ I liked the soft look and ease of use of SG and ended up keeping to the end\n\/\/ https:\/\/mynameismjp.wordpress.com\/2016\/10\/09\/sg-series-part-2-spherical-gaussians-101\/\n\nstruct SG { vec3 Amplitude; vec3 Axis; float Sharpness; };\n\n\/\/ approximate integral on omega of sg(v)dv\nvec3 ApproximateSGIntegral( in SG sg ) { return 2. * PI * ( sg.Amplitude \/ sg.Sharpness ); }\n\nSG CosineLobeSG( in vec3 direction )\n{\n\tSG cosineLobe;\n\tcosineLobe.Axis = direction;\n\tcosineLobe.Sharpness = 2.133f;\n\tcosineLobe.Amplitude = vec3( 1.17f );\n\treturn cosineLobe;\n}\n\n\/\/ https:\/\/mynameismjp.wordpress.com\/2016\/10\/09\/sg-series-part-3-diffuse-lighting-from-an-sg-light-source\/\n\nvec3 SGIrradianceFitted( in SG lightingLobe, in vec3 normal )\n{\n\tfloat muDotN = dot( lightingLobe.Axis, normal );\n\tfloat lambda = lightingLobe.Sharpness;\n\n\tfloat c0 = 0.36f;\n\tfloat c1 = 1.0f \/ ( 4.0f * c0 );\n\n\tfloat eml  = exp( -lambda );\n\tfloat em2l = eml * eml;\n\tfloat rl   = 1.0 \/ lambda;\n\n\tfloat scale = 1.0f + 2.0f * em2l - rl;\n\tfloat bias  = ( eml - em2l ) * rl - em2l;\n\n\tfloat x  = sqrt( 1.0f - scale );\n\tfloat x0 = c0 * muDotN;\n\tfloat x1 = c1 * x;\n\n\tfloat n = x0 + x1;\n\n\tfloat y = saturate( muDotN );\n\tif ( abs( x0 ) <= x1 ) y = n * n \/ x;\n\n\tfloat result = scale * y + bias;\n\n\treturn result * ApproximateSGIntegral( lightingLobe );\n}\n\n\/\/ what am I doing\nvec3 SGDiffuseFitted( in SG lightingLobe, in vec3 normal, vec3 albedo )\n{\n\tvec3 brdf = albedo \/ PI;\n\treturn SGIrradianceFitted( lightingLobe, normal ) * brdf;\n}\n\n\/\/ BUFFER_MODE\n\/\/ 0: normal size (ugly but use to check artifacts in high def, also cloudless)\n\/\/ 2: halfsize + history reprojection... blurry-but-AA type of thing\n#define BUFFER_MODE 2\n\n\/\/ iChannel0 is always Buf A\n\/\/ iChannel1 is always Buf B\n\n\/\/ note: glsl doesn't let us write if (1), so we write if (_1), note that occasionally compiler may fail to treat that as a static branch\n#define _1 true\n#define _0 false\n\n\/\/ skip space faster above bushes (and maybe other things if proves useful)\n\/\/ notes:\n\/\/  - at higher res we can see that causes artifacts, see the bit that sets\n\/\/    eval.terrain_warp and tweak hack constants there\n\/\/  - this causes artifacts on trees's tracing... close to patch borders maybe? (messes with shadows sometimes)\n\/\/  - this messes with bush shadows even when bush surface seems unchanged (shrinks shadows a bit)\n#define TERRAIN_WARP\n\n#define FORCE_LOOP +min(0,aFrame)\n#define FORCE_LOOPF +min(0.0,float(aFrame))\n\n#define SHADOW_TINT_SATURATION 0.45 \/\/ [0,1]\n\n#define AO _0 \/\/ nice term, visible extra cost, but doesn't contribute much, so disable \n#define SHADOWS _1\n\n#define SUN _1\n#define SUN_GLARE _0 \/\/ could be interesting but needs more work\n\n#define GROUND_OCCLUSION _1 \/\/ first sdf is ground's base level so we get occlusion\n#define PATH _1 \/\/ cost peanuts\n#define GRASS _1 \/\/ cost peanuts\n#define BUSH _1 \/\/ a bit expensive\n#define TREE _1 \/\/ super expensive\n#define FARM _1 \/\/ cost a little bit\n#define BRICKWALL _1 \/\/ cost a little bit\n\n#define TAYLOR_HEIGHT_BUSH _1\n#define TAYLOR_HEIGHT_TREE _1\n#define TAYLOR_HEIGHT_FARM _0 \/\/ object is too large, causes a little bit too much distortion\n\n#define GHOST_STEPS_PATCH _1\n#define GHOST_STEPS_TREE _1 \/\/ visible extra cost, fixes the trees, but we start hitting iteration limit\n#define GHOST_STEPS_FARM _1 \/\/ little cost (large cells) and fixes farms, hits a little bit more max iterations far away\n\/\/ about GHOST_MAX_DIST:\n\/\/ introduced a second distance for bird views\n\/\/ having 2 thresh lets us fix bird view, but they get more expensive\n#define GHOST_MAX_DIST_FROM_T0 7.0\n#define GHOST_MAX_DIST_ABS 25.0\n\/\/ fixes weird grain that happens when using second threshold that goes further away... hack hack...\n#define GHOST_EPS 0.0001\n\n#define DISPLACE_PATH _1 \/\/ a bit expensive, actually\n#define DISPLACE_PATH_AMPL 0.002\n\n#define DISPLACE_PINE _1\n#define DISPLACE_TREE _1\n#define DISPLACE_BUSH _1\n#define DISPLACE_BUSH_FREQ 8.0\n\n\/\/ CLOUD_MODE\n\/\/  0: no cloud\n\/\/  1: trace cloud per pixel (for debug)\n\/\/  2: cache trace cloud in B texture every frame and use that (for debug)\n\/\/ >3: cache trace cloud in B texture only first frame and use that (same cost as no cloud)\n#define CLOUD_MODE 3\n\n\/\/ the wind doesn't have much amplitude, and movement isn't smooth enough, but reprojection hides that a bit...\n#define WIND_BUSH _1\n#define WIND_TREE_AND_PINES _1\n\n#define FARM_WINDOWS _1\n\n#define SOFT_BLEND_BUSH _1\n#define SQUARE_BUSH_TEST _1 \/\/ some farms have nicely cut bushes arounds them\n\n#define MATID_NONE    0.0\n#define MATID_BUSH    1.0\n#define MATID_TRUNK   2.0\n#define MATID_HOUSE   3.0\n#define MATID_ROOF    4.0\n#define MATID_PINE    5.0\n#define MATID_BRICKWALL   6.0\n#define MATID_GRASS   7.0\n#define MATID_GROUND  8.0\n#define MATID_TREE    9.0\n#define MATID_WINDOW 10.0\n#define MATID_HOUSE_BOTTOM 11.0\n\n#define BROWN (vec3(133,84,57)\/255.0)\n#define PATH_COLOR BROWN\n#define PATH_COLOR2 (BROWN*0.8)\n#define COLOR_BUSH1 (0.8*vec3(0.07,0.3,0.05))\n#define COLOR_BUSH2 (0.55*vec3(0.12,0.6,0.2))\n#define COLOR_BUSH3 (0.55*vec3(0.1,0.35,0.09))\n#define COLOR_BUSH4 (0.82*vec3(0.18,0.39,0.06))\n#define COLOR_BUSH5 vec3(0.1,0.3,0.01) \/\/ rare color\n#define COLOR_TREE1 (vec3(0.1,0.35,0.09)*0.55)\n#define COLOR_TREE2 (vec3(0.1,0.45,0.08)*0.8)\n#define COLOR_TREE_SURF vec3(0.15,0.4,0.04)\n#define COLOR_GRASS vec3(0.1,0.35,0.09)\n#define COLOR_GRASS2 vec3(0.35,0.39,0.06)\n#define COLOR_MOWED_GRASS vec3(0.17,0.37,0.05)\n#define COLOR_MOWED_GRASS2 (COLOR_MOWED_GRASS* 0.6)\n#define COLOR_PINE (vec3(0.4,1.0,0.2)*0.2)\n#define COLOR_PINE2 (vec3(0.5,1.0,0.0)*0.32)\n#define COLOR_TRUNK (BROWN*0.5)\n#define COLOR_ROOF1 (vec3(0.6,0.2,0.3)*0.7)\n#define COLOR_ROOF2 (vec3(0.1,0.4,0.5)*0.7)\n#define COLOR_BRICKWALL mix(vec3(0.52,0.33,0.22),vec3(0.9,0.9,0.7),0.35)\n#define COLOR_HOUSE mix((vec3(1,1,1)*0.65),COLOR_BRICKWALL,0.1) \/\/ white is a bit too white so blend with brickwall color\n#define COLOR_HOUSE_BOTTOM (COLOR_HOUSE*0.7)\n\nstruct CellPoint\n{\n\tvec2 p;\n\tivec2 _pi; \/\/ some cell index to take a hash from\n\tfloat pradius; \/\/ point radius, small points can be closer to cell edges\n};\n\n\/\/ meaning of id varies, if 32bits floats we should be able to have exact ints up to 2^24=16777216\nstruct DistanceId { float d; float id;  };\n\nDistanceId MkDistanceId( float d, float id ) { DistanceId v; v.d = d; v.id = id; return v; }\n\nDistanceId MkDistanceId_16( float d, float id, float id_fraction )\n{\n\treturn MkDistanceId( d, float( int( id ) | ( int( id_fraction * 65535.0 ) << 5 ) ) );\n}\n\nDistanceId MkDistanceId_5_5_5( float d, float id, vec3 v )\n{\n\treturn MkDistanceId( d, float( int( id )\n\t\t\t\t\t\t\t\t   | ( int( v.x * 31.0 ) <<  5 )\n\t\t\t\t\t\t\t\t   | ( int( v.y * 31.0 ) << 10 )\n\t\t\t\t\t\t\t\t   | ( int( v.z * 31.0 ) << 15 ) ) );\n}\n\nvec2 DecodeId_16( DistanceId di )\n{\n\tint i = int( di.id );\n\treturn vec2( float( i&31 ), float( i >> 5 ) * ( 1.0 \/ 65535.0 ) );\n}\n\nfloat DecodeId( DistanceId di )\n{\n\tint i = int( di.id );\n\treturn float( i&31 );\n}\n\nvec4 DecodeId_5_5_5( DistanceId di )\n{\n\tint i = int( di.id );\n\treturn vec4( float( i&31 )\n\t\t\t\t , float( ( i >>  5 ) & 31 ) * ( 1.0 \/ 31.0 )\n\t\t\t\t , float( ( i >> 10 ) & 31 ) * ( 1.0 \/ 31.0 )\n\t\t\t\t , float( ( i >> 15 ) & 31 ) * ( 1.0 \/ 31.0 ) );\n}\n\n#if 0 \n\/\/ bogus build error on ? : in shadertoy\nDistanceId opUdi( DistanceId a, DistanceId b ) { return a.d < b.d ? a : b; }\n#else\nDistanceId opUdi( DistanceId a, DistanceId b ) { if ( a.d < b.d ) return a; return b; }\n#endif\n\n\/\/ some rough scale for the roads pattern\n\/\/ you need to tweak x spacing and y spacing of path slabs\n\/\/ and the x and y scale of the main path function\n#define LANEWIDTH 0.08\n\n\/\/ 0: sin waves\n\/\/>1: sin waves with flat sections (default)\n\/\/ 2: constant (straight lines, rectangular layout)\n\/\/ 3: smooth noise\n#define LANE_FUNC 1\n\nvec2 PathNoise11sD( float x )\n{\n\tx -= 0.5;\n\tfloat fr = fract( x );\n\tint x0 = int( x - fr );\n\tuint i = uint( x0 );\n\tfloat y0 = hash11u_lowbias32( i );\n\tfloat y1 = hash11u_lowbias32( i + 1u );\n\tfloat f = smoothstep_unchecked( fr );\n\tfloat fd = smoothstep_unchecked_d( fr );\n\treturn vec2( mix( y0, y1, f ), ( y1 - y0 ) * fd );\n}\n\n\/\/ return lane's (y,y'), called a lot so make it cheap (this *does not* return world space y coord)\nvec2 wavyLaneFuncAndDerivative( float x, float lane_index )\n{\n#if LANE_FUNC==0\n\tfloat a = mix( 0.5, 1.7, ( 1.0 + cos( lane_index ) ) * 0.5 ); \/\/ per lane constant\n\treturn vec2( ( sin( a * x ) + 1.0 ) * 0.5, 0.5 * a * cos( a * x ) );\n#elif LANE_FUNC==1\n\t\/\/ sin wave with soft straight sections so it's just all curvy\n\tfloat a = mix( 0.9, 2.0, ( 1.0 + cos( lane_index ) ) * 0.5 ); \/\/ per lane constant\n\tfloat z = ( 1.0 + sin( x * a ) ) * 0.5;\n\treturn vec2( z * z, a * z * cos( a * x ) );\n#elif LANE_FUNC==2\n\treturn vec2( 0.5, 0 );\n#elif LANE_FUNC==3\n\treturn PathNoise11sD( x - lane_index * 80.0 );\n#endif\n}\n\n#define PATH_SPACING_Y 1.0\n\/\/ used by camera, don't forget to offset by lane_index (regular wavyLaneFuncAndDerivative() doesn't care!)\nvec2 wavyLaneFuncAndDerivative_WORLD( float x, float lane_index )\n{\n\treturn wavyLaneFuncAndDerivative( x, lane_index ) + vec2( lane_index * PATH_SPACING_Y, 0 );\n}\n\n\/\/ return vector to closest point in .xy, derivative there in .zw\n\/\/ use cheap when you don't care about accurate distance or closest point\nvec4 sdWavyLane( vec2 p, float lane_index, bool cheap )\n{\n\tvec4 ret;\n\tCLOSEST_POINT_TANGENT_TO_FUNCD_11_ARG_CHEAP( ret, p, wavyLaneFuncAndDerivative, lane_index, cheap )\n\treturn ret;\n}\n\nstruct SceneIn\n{\n\t\/\/ constant during trace:\n\/\/\tvec3 o;\n\tvec3 v;\n\tvec3 v_rcp; \/\/ for cell boundaries\n\tint trace_flags; \/\/ we can skip material related calculations during the traversal and enable only on shade\n\t\/\/ varying during trace:\n\tvec3 p;\n\tfloat t0; \/\/ warp start to hmax\n\tfloat t;\n};\n\nstruct ClosestPath\n{\n\tDistanceId patch_di; \/\/ patch id and distance (which is also the distance to paths)\n\tvec2 v2closest; \/\/ vector to closest patch boundary point, in world coords\n\tfloat curve_local_param; \/\/ the curve parameter, p.x in the local curve distance eval, so we can parametrixe space for making walls etc\n\t\t\t\t\t   \/\/ (since the path uses x and y directions we need to know which was used)\n};\n\nvec2 GetLocalCurvePoint( ClosestPath path ) { return vec2( path.curve_local_param, length( path.v2closest ) ); }\n\n\/\/ spacing must be >= 1 for the band to work\nClosestPath EvalClosestPathSlab( vec2 p, float spacing, bool cheap )\n{\n\tfloat id1 = floor( p.y \/ spacing );\n\tp.y = p.y - id1 * spacing;\n\tvec4 c1 = sdWavyLane( p, id1, cheap ); \/\/ should return in 0,spacing\n\tfloat d1 = cheap ? abs( c1.y ) : length( c1.xy );\n\tfloat s1 = sign( c1.y ); \/\/ this tells us if are above or below the curve (which adjacent curve to eval)\n\n\tfloat id2 = id1 - s1; \/\/ find the other 1d lane of the slab we are in: next or prev\n\tvec4 c2 = sdWavyLane( p + vec2( 0, s1 * spacing ), id2, cheap );\n\tfloat d2 = cheap ? abs( c2.y ) : length( c2.xy );\n\tfloat s2 = sign( c2.y );\n\n\tfloat m = s2 < 0.0 ? id1 : id1 - s1;\n\n\tClosestPath eval;\n\tif ( d1 < d2 ) { eval.patch_di.d = d1; eval.v2closest = c1.xy; }\n\telse           { eval.patch_di.d = d2; eval.v2closest = c2.xy; }\n\teval.patch_di.id = m;\n\teval.curve_local_param = p.x;\n\treturn eval;\n}\n\n\/\/ the lane curve is evaluated 4 times (twice per axis)\nClosestPath EvalClosestPath( vec2 p, bool cheap )\n{\n\t\/\/ horizonal lanes\n\t\/\/ PATH_SPACING_Y must be >= 1 for the band to work\n\tClosestPath ev1 = EvalClosestPathSlab( p, PATH_SPACING_Y, cheap );\n\n\t\/\/ vertical lanes\n\t\/\/ each horizontal stab can call a different set of vertical lanes which generates complex patterns\n\tvec2 p2 = perp( p ); \/\/ 90 degrees\n\t\/\/ important: spacing2 must be >= 1 for the band to work\n\tfloat spacing2 = ( 1.0 + 4.0 * ( sin( ev1.patch_di.id * 10.0 ) + 1.0 ) * 0.5 ); \/\/ spacinf of vertical lane can differ per horizontal stab which is key to complex branching patterns\n\tClosestPath ev2 = EvalClosestPathSlab( p2, spacing2, cheap );\n\tev2.v2closest = -perp( ev2.v2closest ); \/\/ put v2closest back to world coords (-90 degrees)\n\n\tClosestPath eval = ev1;\n\teval.patch_di.id *= ev2.patch_di.id; \/\/ get a unique id for this patch\n\tif ( ev2.patch_di.d < ev1.patch_di.d )\n\t{\n\t\teval.patch_di.d = ev2.patch_di.d;\n\t\teval.v2closest = ev2.v2closest;\n\t\teval.curve_local_param = ev2.curve_local_param;\n\t}\n\treturn eval;\n}\n\n\/\/ I hope you like magic constant\n#define MAX_TERRAIN_HEIGHT 0.74\n#define TALLEST_OBJECT_HEIGHT 0.645\n\nfloat sin_bumps_array( vec2 p ) { return sin( p.x ) * sin( p.y ) + 1.0; }\n\n\/\/ this function is called a lot so pick something simple\nfloat BaseGroundHeight( vec2 p  )\n{\n\tfloat h = sin_bumps_array( p.xy * ( 0.16 * PI ) ) * 0.5;\n\treturn h * h * MAX_TERRAIN_HEIGHT; \/\/ sinbumps as is is too bumpy everywhere, we need also flatter areas, so square h\n}\n\n\/\/ image was blue point juniper... end result is noise vomit\nfloat pine_tree_cross_section( float x, vec2 rh ) { x \/= rh.y; return cubicbump( x, 3.0, -0.98 ) * rh.x; }\nfloat sdRevolutionPine( vec3 p, float r, float h )\n{\n\tvec2 p2d = vec2( ( p.z ), length( p.xy ) );\n\tif ( p2d.x >= h ) return length( p2d - vec2( h, 0 ) ); \/\/ don't forget to deal with endpoints...\n\tif ( p2d.x <= 0.0 ) return length( p2d - vec2( 0, 0 ) );\n\tfloat d; \/\/ note: we could use FAST_SIGNED_DISTANCE_TO_FUNCD_11_ARG but function is relatively cheap to eval so\n\tFAST_SIGNED_DISTANCE_TO_FUNC_11_ARG( d, p2d, pine_tree_cross_section, vec2( r, h ), 1e-3 );\n\treturn d; \/\/ note: this is already signed\n}\n\nvec3 ApplyWind( vec3 pd, float aTime ) { return vec3( sin( aTime * 0.8 + pd.zx ) * 0.0003, 0 ); }\n\nfloat ddPineSurfLayer( vec3 p )\n{\n\tp *= 400.0;\n\tp.z *= 0.25;\n\tp.xy = rotate_with_angle( p.xy, p.z * 0.11 );\n\treturn ( ( tri_sin( p.x ) + tri_sin( p.y ) + tri_sin( p.z ) ) + 3. ) * ( 1. \/ 6. ); \/\/ normalize to 0,1\n}\n\nfloat ddPineSurf( vec3 p )\n{\n\treturn ( ddPineSurfLayer( p ) + ddPineSurfLayer( vec3( rotate_with_angle( p.xy, 0.5 ), p.z ) * 0.5 ) )\n\t\t   * ( 1. \/ ( 2.5 ) ); \/\/ normalize to 0,1\n}\n\nfloat sdDisplacePine( vec3 p, float d, float uheight )\n{\n\tif ( !DISPLACE_PINE ) return d;\n\tfloat dd_amp = 0.018;\n\tif ( d > dd_amp ) return d;\n\tdd_amp *= ddPineSurf( p );\n\treturn d + dd_amp;\n}\n\n#define TRACE_VIEW 1\n#define TRACE_SHADE 2\n#define TRACE_AO 4\n#define TRACE_SHADOW 16\n#define TRACE_HAS_DIRECTION 64 \/\/ note: it is faster to check flags than checking for v_rcp == 0 or whatnot (that might not been resolved to static)\n\nbool IsShadeTrace( int trace_flags ) { return ( trace_flags & TRACE_SHADE ) != 0; }\nbool IsShadowTrace( int trace_flags ) { return ( trace_flags & TRACE_SHADOW ) != 0; }\nbool HasDirection( int trace_flags ) { return ( trace_flags & TRACE_HAS_DIRECTION ) != 0; }\n\nDistanceId sdTreeLeaves( vec3 p, vec2 c, float cz, float trunk_height\n\t\t\t\t\t\t , float leaves_volume_base_radius\n\t\t\t\t\t\t , float leaves_volume_top_radius\n\t\t\t\t\t\t , int trace_flags\n\t\t\t\t\t\t , float color_rnd )\n{\n\tfloat d = FLT_MAX;\n\tvec3 c0 = vec3( c, cz + trunk_height * 0.7 );\n\tvec3 c1 = vec3( c, cz + trunk_height );\n\tfloat d0 = length( p - c0 ) - leaves_volume_base_radius;\n\tfloat d1 = length( p - c1 ) - leaves_volume_top_radius;\n\t\/\/ soft blend between 2 sphere for the base leaves volumes\n\tfloat k = leaves_volume_base_radius * 0.4;\n\td = opU_soft2_pol( d0, d1, k );\n\/\/\treturn MkDistanceId( d, MATID_TREE );\n\n#define TREE_SDD 0.02 \/\/ upper bound for  amplitude of fine displacement on pines and trees\n\n\tfloat dd1 = 0.007;\n\tif ( d > dd1 + TREE_SDD ) return MkDistanceId( d, MATID_TREE ); \/\/ massive saving. only consider envelope displacement when we are close\n\n\tfloat d_envelope = d;\n\tbool blend = _1;\n\tfloat depth = 0.0;\n\tfloat uheight = 0.0;\n\t\n\tif ( _1 )\n\t{\n\t\t\/\/ make the leaves volume more bubbly by using 2 layers of *packed* 3d spheres regular tiling (non packed doesn't work well)\n\t\t\/\/ see @Shane's cellular tiling shaders\/comments\n\n\t\tmat3 m3 =\n\t\t\tmat3_rotation_x( unit_vector2( radians( c.x * 200. ) ) ) *\n\t\t\tmat3_rotation_z( unit_vector2( radians( c.y * 200. ) ) );\n\n\t\tfloat dl1;\n\n\t\t{\n\t\t\tfloat c1 = leaves_volume_base_radius * 0.3;\n\t\t\tfloat da1 = packed_spheres_tiling3d( p * m3, c1, c1 * 2.5 ); \/\/ more spacing gives more clustering\/bumpiness\n\t\t\tda1 += smoothstep( cz + trunk_height * 0.75, cz + trunk_height, p.z ) * 0.007;\n\t\t\tdl1 = blend\n\t\t\t\t? opI_weld_quadric( d_envelope, da1, leaves_volume_base_radius * 0.3 )\n\t\t\t\t: opI( d_envelope, da1 );\n\t\t}\n\n\t\tfloat dl2;\n\n\t\t{\n\t\t\t\/\/ note: the second packed_spheres_tiling3d could just be global and evaluated 1 for the 3 trees\n\t\t\tfloat c1 = leaves_volume_base_radius * 0.4;\n\t\t\tfloat da1 = packed_spheres_tiling3d( m3 * p, c1, c1 * 2.5 );\n\t\t\tdl2 = blend\n\t\t\t\t? opI_weld_quadric( d_envelope, da1, leaves_volume_base_radius * 0.25 )\n\t\t\t\t: opI( d_envelope, da1 );\n\t\t}\n\n\t\tfloat d_leaf_clusters = blend\n\t\t\t? opU_weld_quadric( dl1, dl2, leaves_volume_base_radius * 0.1 )\n\t\t\t: opU( dl1, dl2 );\n\n\t\td = blend\n\t\t\t? opU_weld_quadric( d_leaf_clusters, d_envelope + 0.02, leaves_volume_base_radius * 0.19 )\n\t\t\t: d_leaf_clusters;\n\n\t\tdepth = saturate( 1.0 \/ ( 1. + abs( d - d_envelope ) * 100. ) );\n\t\t\n\t\tfloat b = c0.z - leaves_volume_base_radius; \/\/ bottom most-ish\n\t\tfloat t = c1.z + leaves_volume_top_radius; \/\/ topmost-ish\n\t\tuheight = saturate( ( p.z - b )\/( t - b ) ); \/\/ a 0-1 normalized height value for shading\n\t}\n\n\tif ( _1 )\n\t{\n\t\t\/\/ clip leaves volume's bottom with a wavy surface so it's not spherical things everywhere\n\t\tfloat clipsurf = ( ( c0.z - leaves_volume_base_radius * .6 )\n\t\t\t\t\t\t   + leaves_volume_base_radius * 0.1\n\t\t\t\t\t\t   * ( sin_bumps_array( p.xy * ( 13.0 * PI ) ) - 2.4 ) );\n\n\t\td = blend\n\t\t\t? opI_weld_quadric( d, -( p.z - clipsurf ), leaves_volume_base_radius * 0.15 )\n\t\t\t: opI( d, -( p.z - clipsurf ) );\n\t}\n\n\treturn MkDistanceId_5_5_5( d, MATID_TREE, saturate( vec3( depth, uheight, color_rnd ) ) );\n}\n\n\/\/ retrieve terrain height, using full eval or taylor expansion\nfloat CalcHeight( vec2 c, vec2 p, vec3 h_gradval, bool taylor_expansion_height )\n{\n\treturn taylor_expansion_height\n\t\t   ? h_gradval.z + dot( h_gradval.xy, c - p ) \/\/ h(p)=h(c)+(c-h).grad(c): taylor expansion to skip height evaluations \n\t\t   : BaseGroundHeight( c );\n}\n\nDistanceId sdGridObj_TreeOrPine( DistanceId di\n\t\t\t\t\t\t\t\t , vec3 p\n\t\t\t\t\t\t\t\t , CellPoint cr\n\t\t\t\t\t\t\t\t , float radius_fraction\n\t\t\t\t\t\t\t\t , float patch_id\n\t\t\t\t\t\t\t\t , inout vec3 color\n\t\t\t\t\t\t\t\t , SceneIn scenein\n\t\t\t\t\t\t\t\t , vec3 h_gradval, bool taylor_expansion_height )\n{\n\tvec2 c = cr.p;\n\tfloat r = radius_fraction * cr.pradius;\n\tfloat cz = CalcHeight( cr.p, p.xy, h_gradval, taylor_expansion_height );\n\n\tif ( _0 && ( ( length( p - vec3( c, cz ) ) - cr.pradius ) > di.d ) ) return di; \/\/ CULL\n#if 0\n\t\/\/ doesn't save enough vs extra test cost\n\tif ( HasDirection( scenein.trace_flags ) )\n\t{\n\t\tvec2 n = perp( scenein.v.xy );\n\t\tvec2 o = scenein.o.xy;\n\t\tvec2 pp = project_on_plane( c, o, n );\n\t\tif ( lensqr( p.xy - pp ) > r * r ) return di;\n\t}\n#endif\n\tvec4 hhh = hash42_( cr._pi * 123 );\n\tvec3 tree_base_point = vec3( c, cz );\n\n\tfloat pine_dice_roll = hhh.x;\n\tfloat pine_probability = 0.7;\n\t\n\tif ( _1 && ( pine_dice_roll > pine_probability) )\n\t{\n\t\tfloat pine_radius_scale = mix( 0.65, 0.75, hhh.w ) * r;\n\t\tfloat pine_height = mix( 0.42, 0.56, hhh.z * hhh.z );\n\t\tfloat uheight = saturate( ( p.z - cz ) \/ pine_height );\n\t\tDistanceId pine_tree = MkDistanceId_5_5_5( \n\t\t\tsdDisplacePine( p - tree_base_point\n\t\t\t\t\t\t\t, sdRevolutionPine( p - tree_base_point, pine_radius_scale, pine_height ), uheight )\n\t\t\t, MATID_PINE, vec3( 0.0, uheight, ( ( hhh.x - pine_probability ) * ( 1.0 \/ ( 1.0 - pine_probability ) ) ) ) );\n\t\treturn opUdi( di, pine_tree );\n\t}\n\n\thhh.x *= 1.0\/pine_probability; \/\/ back into [0,1]\n\tfloat aa = mix( 0.018, 0.012, hhh.y ); \/\/ trunk\n\tfloat trunk_height = aa * ( 1.1 * 1.0 \/ 0.018 ) * mix( 0.2, 0.35, hhh.z * hhh.z );\n\tfloat trunk_radius = aa * 0.8;\n\tfloat leaves_volume_top_radius = mix( 0.5, 0.7, hhh.w ) * r;\n\tfloat leaves_volume_base_radius = mix( 1.1, 1.35, hhh.y ) * leaves_volume_top_radius;\n\tDistanceId leaves = sdTreeLeaves( p, c, cz, trunk_height, leaves_volume_base_radius, leaves_volume_top_radius, scenein.trace_flags, hhh.x );\n\tfloat trunk_uheight = saturate( ( p.z - cz ) \/ trunk_height );\n\ttrunk_radius *= mix(0.8,1.2,pow2(1.0-saturate(trunk_uheight*3.5)));\n\tDistanceId trunk = MkDistanceId( sdCylinder( p - tree_base_point, vec2( trunk_radius, trunk_height ) ), MATID_TRUNK );\n\tif ( trunk.d < 0. ) leaves = trunk; \/\/ horrible hack to force trunk to be trunk inside leaves, as the leaves sdf has been hacked to death and union doesn't quite work anymore\n\treturn opUdi( di, opUdi( trunk, leaves  ) );\n}\n\n\/\/ function used to make roof tiles\n\/\/ a1 is the slope of curve going up (1.)\n\/\/ a2 is the slope of curve going down (-2.)\n\/\/ p is the period\nfloat hard_waves( float x, float a1, float a2, float p ) { x = repeat( x, p ); return min( a1 * x, a2 * ( x - p ) ); }\n\/\/ roof tiles height field (hf)\nfloat hf_SurfaceRoofTiles( vec2 p ) { return 0.1 * hard_waves( p.y, 0.3, -1.1, 0.024 ) + 0.001 * ( 1.0 - pow2( 1.0 - abs( sin( p.x * 200. ) ) ) ); }\n\nstruct WindowOrDoorArg\n{\n\tvec2 c; \/\/ cellsize\n\tvec2 g; \/\/ num cells\n\tfloat frame_width, border_height, border_depth, glass_depth, frame_depth;\n};\n\nvoid sdOneWindow( vec3 p, inout DistanceId eval, WindowOrDoorArg args )\n{\n\tfloat d_in = eval.d;\n\tvec2 c = args.c;\n\tvec2 g = args.g - vec2( 1 );\n\tp.x += ( args.g.x * 0.5 - 0.5 ) * c.x; \/\/ center on x...\n\tvec2 pmin = -c.xy * 0.5;\n\tvec2 pmax = c.xy * ( vec2( 0.5 ) + g );\n\t\/\/ window glass and frame\n\tvec3 pr = p;\n\tvec2 i = floor( ( pr.xy - ( -c * 0.5 ) ) \/ c ); \/\/ c the cell size\n\ti = clamp( i, vec2( 0, 0 ), g );\n\tpr.xy -= i * c;\n\tfloat d_glass = sd_bounds_half_size( pr, vec3( c * 0.5 - vec2( args.frame_width ) * 0.5, args.glass_depth ) );\n\teval.d = opS( eval.d, d_glass );\n\t\/\/ window general frame\n\tfloat d_frame = sd_bounds_range( p, vec3( pmin, -args.frame_depth ), vec3( pmax, args.frame_depth ) );\n\teval.d = opS( eval.d, d_frame ); \/\/ make the whole window sink a bit\n\t\/\/ window border\n\tif ( _1 ) eval.d = opI( d_in - args.border_depth \/\/ clamp vs inflated version of source block we are decorating\n\t\t\t\t\t\t\t, opU( eval.d\n\t\t\t\t\t\t\t\t   , sd_bounds_range( p\n\t\t\t\t\t\t\t\t\t\t\t\t\t  , vec3( pmin.x, pmin.y - args.border_height, 0 )\n\t\t\t\t\t\t\t\t\t\t\t\t\t  , vec3( pmax.x, pmin.y, args.border_depth ) ) ) );\n\tif ( -d_glass == eval.d ) eval.id = MATID_WINDOW; \/\/ we used opS so we need -d_glass\n}\n\nvoid addWindow( inout DistanceId eval, vec3 p, float is_chimney_face, float half_wall_width )\n{\n\tp.y += 0.016; \/\/ adjust windows height\n\tvec2 c = vec2( 0.07*mix(1.8,1.0,is_chimney_face), 0.07 ); \/\/ tile size\n\tvec2 window_size = vec2( 0.018, 0.02 ); \/\/ size of the object inside each tile, must be smaller than c\n\tfloat d_glass = FLT_MAX;\n\tvec2 i = floor( ( p.xy - ( -c.xy * 0.5 ) ) \/ c.xy ); \/\/ c the cell size\n\tfloat maxnum_cells = floor( (half_wall_width \/ c.x) - 0.5 ); \/\/ max num window that fit on this wall, assume p.x centered\n\tivec2 imin = ivec2( -maxnum_cells, 1 );\n\tivec2 imax = ivec2(  maxnum_cells, 1 );\n\ti = clamp( i, vec2(imin), vec2(imax) );\n\tp.xy -= i * c;\n\tWindowOrDoorArg args;\n\targs.c = window_size; \/\/ cellsize\n\targs.g = mix( vec2( 2, 2 ), vec2( 2, 2 ), is_chimney_face ); \/\/ window glass grid size\n\tfloat scl = 0.012;\n\targs.frame_width = 0.05 * scl;\n\targs.border_height = 0.3 * scl;\n\targs.border_depth = 0.2 * scl; \/\/ can't be bigger than d_house_bottom_inset\n\targs.glass_depth = 0.3 * scl;\n\targs.frame_depth = 0.1 * scl;\n\tsdOneWindow( p, eval, args );\n}\n\n\/\/ convert point p to y=0 face local point, a is a plane base3d\/origin2d point\nvec3 p2yface( vec3 p, vec2 orig ) { p.y = abs( p.y ); p.xy -= orig; p.xzy = p.xyz; p.x = -p.x; return p; }\n\/\/ convert point p to y=0 face local point, a is a plane base3d\/origin2d point\nvec3 p2xface( vec3 p, vec2 orig ) { p.x = abs( p.x ); p.xy -= orig; return p.yzx; }\n\n\/\/ note: tracing detail doesn't always work very well on heightfields so z proj\/triplanar type of mapping isn't great for roof\n\/\/ instead we do more tedious evals, building roof local points + 3d detail on that etc\nDistanceId sdFarm( vec3 p, CellPoint cr,float patch_id,float r, float detail )\n{\n\tvec4 hh = hash42_( cr._pi);\n\tbool has_chimney = hh.y > 0.4;\n\tbool _x2chimney = _1;\n\tvec2 hs1 = vec2( 0.25, 0.083 );\n\tvec2 hs2 = vec2( 0.083, 0.18+hh.z*0.02 );\n\tfloat h = 0.0996;\n\tfloat bottom_block_inset = 0.00498;\n\tfloat bottom_block_inset2 = bottom_block_inset*(has_chimney?0.0:1.0);\n\tfloat roof_thickness = 0.00166;\n\tfloat chimney_side_len = 0.018+hh.z*0.002; \/\/ chimney side length\n\tfloat chimney_height = h + hs1.y + chimney_side_len;\n\tfloat chimney_bottom = h + hs1.y - 0.04;\n\tfloat roof_tile_scl = 2.5; \n\tfloat roof_tile_scl2 = 1.1; \n\tbool half_hipped = hh.z>0.5;\n\tfloat bottom_inflate = 0.001;\n\tvec2 hs1_in = hs1 - vec2( bottom_block_inset2, bottom_block_inset );\n\tvec2 hs2_in = hs2 - vec2( bottom_block_inset );\n\t\/\/ symmetric window plane\n\tfloat block1_chimney_wall_plane_x = hs1_in.x;\n\tfloat block1_wall_plane_y = hs1_in.y;\n\tfloat block2_wall_plane_y = hs2_in.y;\n\tvec3 ps = p; \/\/ store signed p\n\tvec3 pay = p; pay.y = abs( pay.y ); \/\/ symmetric around y\n\tvec3 pax = p; pax.x = abs( pax.x ); \/\/ symmetric around x\n\tfloat d_block1_bottom = FLT_MAX;\n\tfloat d_block1_roof = FLT_MAX;\n\tfloat d_block1_bottom2 = FLT_MAX;\n\t{\n\t\t\/\/ --- gable roof, 2 planes (v-shaped)\n\t\tbounds2 block1 = mkbounds_unchecked( -hs1, hs1 );\n\t\tfloat d_block1_footprint = sd_bounds_range( p.xy, block1.pmin.xy, block1.pmax.xy );\n\t\tvec3 roof1_top_point = vec3( hs1.x, 0, h + hs1.y );\n\t\t\/\/ p.yz is the gable roof cross section space point\n\t\tvec3 roof_plane_local_p = vec3( -dot( pay.yz - roof1_top_point.yz, perp( V45 ) ), p.x, dot( pay.yz - roof1_top_point.yz, V45 ) );\n\t\td_block1_bottom = opI( roof_plane_local_p.z, d_block1_footprint );\n\t\td_block1_bottom = opI( d_block1_bottom, pay.y -hs1_in.y );\n\t\td_block1_bottom = opI( d_block1_bottom, pax.x - block1_chimney_wall_plane_x );\n\t\td_block1_bottom = opI( d_block1_bottom, roof_plane_local_p.z + 0.002 );\n\t\t\/\/ add tile detail to gabble roof, hacky mess to be sorted\n\t\td_block1_roof = roof_plane_local_p.z - detail*hf_SurfaceRoofTiles( roof_plane_local_p.yx * roof_tile_scl )* roof_tile_scl2;\n\t\td_block1_roof = opS( d_block1_roof, roof_plane_local_p.z + 0.002 );\n\t\td_block1_roof = opI( d_block1_roof, d_block1_footprint );\n\t\td_block1_bottom2 = opI(d_block1_footprint-bottom_inflate,p.z);\n\t}\n\tfloat d_chimney = FLT_MAX;\n\tif ( has_chimney )\n\t{\n\t\tvec2 chimney_c = vec2( hs1_in.x, 0 );\n\t\tbounds2 chimney_footprint_b = mkbounds_unchecked( chimney_c - vec2( chimney_side_len ), chimney_c + vec2( 0, chimney_side_len * 0.5 ) );\n\t\tfloat d_chimney_footprint = sd_bounds_range( _x2chimney ? abs( p.xy ) : p.xy, chimney_footprint_b.pmin.xy, chimney_footprint_b.pmax.xy );\n\t\td_chimney = opI( chimney_bottom - p.z, opI( d_chimney_footprint, p.z -chimney_height ) );\n\t\tfloat d_chimney_hole = opI( chimney_bottom - p.z, opI( d_chimney_footprint, p.z - chimney_height * 1.5 ) ) + 0.002;\n\t\td_chimney = opS( d_chimney, d_chimney_hole );\n\t}\n\tfloat d_block2_roof = FLT_MAX;\n\tfloat d_block2_bottom = FLT_MAX;\n\tfloat d_block2_bottom2 = FLT_MAX;\n\tif ( hh.x > 0.4 )\n\t{\n\t\t\/\/ --- hipped roof\n\t\tbounds2 block2 = mkbounds_unchecked( -hs2, hs2 );\n\t\tfloat d_block2_footprint = sd_bounds_range( p.xy, block2.pmin.xy, block2.pmax.xy );\n\t\t\/\/return d_block1_roof;\n\t\td_block2_bottom = opI( d_block2_footprint + bottom_block_inset, ( p.z - h ) ); \/\/ block2 is inset equally on x and y \n\t\td_block2_bottom2 = opI(d_block2_footprint-bottom_inflate,p.z);\n\t\t\n\t\t\/\/return d_block2_bottom;\n\t\tvec3 roof2_corner_point = vec3( hs2, h );\n\t\tvec3 roof2a_plane_local_p = vec3( p.y, -dot( pax.xz - roof2_corner_point.xz, perp( V45 ) ),dot( pax.xz - roof2_corner_point.xz, V45 ) );\n\t\tfloat roof2detail_a = roof2a_plane_local_p.z - detail*hf_SurfaceRoofTiles( roof2a_plane_local_p.xy * roof_tile_scl ) * roof_tile_scl2;\n\t\t\/\/ like the s1 one, exactly. just offset, can we factorize?\n\t\tvec3 roof2b_plane_local_p = vec3( p.x, -dot( pay.yz - roof2_corner_point.yz, perp( V45 ) ),dot( pay.yz - roof2_corner_point.yz, V45 ) );\n\t\tfloat roof2detail_b = roof2b_plane_local_p.z - detail*hf_SurfaceRoofTiles( roof2b_plane_local_p.xy * roof_tile_scl ) * roof_tile_scl2;\n\t\td_block2_roof = opI( roof2b_plane_local_p.z, roof2a_plane_local_p.z );\n\t\td_block2_roof = opI( roof2detail_a, roof2detail_b );\n\n\t\tif ( half_hipped )\n\t\t{\n\t\t\td_block2_roof = opI( d_block2_roof, p.y );\n\t\t\td_block2_bottom = opI( d_block2_bottom, p.y );\n\t\t\td_block2_bottom2 = opI( d_block2_bottom2, p.y );\n\t\t}\n\t}\n\tDistanceId bb1 = MkDistanceId( d_block1_bottom, MATID_HOUSE );\n\tDistanceId bb2 = MkDistanceId( d_block2_bottom, MATID_HOUSE );\n\tif ( FARM_WINDOWS )\n\t{\n\t\taddWindow( bb1, p2xface( p, vec2( hs1_in.x, 0.0 ) ), 1., hs1_in.y );\n\t\taddWindow( bb1, p2yface( p, vec2( 0, hs1_in.y ) ), 0., hs1_in.x );\n\t\taddWindow( bb2, p2yface( p, vec2( 0, hs2_in.y ) ), 0., hs2_in.x );\n\t}\n\tDistanceId roof_eval = MkDistanceId( opI( h - p.z, opU( d_block1_roof, d_block2_roof ) ), MATID_ROOF );\n\tDistanceId bottom_eval = MkDistanceId( d_chimney, MATID_HOUSE );\n\tbottom_eval = opUdi( bottom_eval, bb1 );\n\tbottom_eval = opUdi( bottom_eval, bb2 );\n\tDistanceId bottom2_eval = MkDistanceId( opU( d_block1_bottom2, d_block2_bottom2 ), MATID_HOUSE_BOTTOM );\n\treturn opUdi( opUdi( roof_eval, bottom_eval ), bottom2_eval );\n}\n\nDistanceId sdGridObj_Farm( DistanceId di\n\t\t\t\t\t\t   , vec3 p\n\t\t\t\t\t\t   , CellPoint cr\n\t\t\t\t\t\t   , float radius_fraction\n\t\t\t\t\t\t   , float patch_id\n\t\t\t\t\t\t   , inout vec3 color\n\t\t\t\t\t\t   , SceneIn scenein\n\t\t\t\t\t\t   , vec3 h_gradval, bool taylor_expansion_height )\n{\n\tvec2 c = cr.p;\n\tfloat r = radius_fraction * cr.pradius;\n\tfloat cz = CalcHeight( cr.p, p.xy, h_gradval, taylor_expansion_height );\n\t\n\tif ( _0 && ( ( length( p - vec3( c, cz ) ) - cr.pradius ) > di.d ) ) return di; \/\/ CULL\n#if 0\n\tif ( HasDirection( scenein.trace_flags ) \n\t\t && ( sphere_trace( mkray( scenein.p, scenein.v ), r, vec3( c, cz ) ).x == FLT_MAX ) )\n\t{\n\t\treturn di;\n\t}\n#endif\n\t\/\/ orient farm along terrain gradient to reduce sinking cases\n\tvec2 e = vec2( 1e-3, 0 );\n\tvec2 h_gradval_at_c = ( vec2( BaseGroundHeight( c.xy + e.xy ),\n\t\t\t\t\t\t\t\t  BaseGroundHeight( c.xy + e.yx ) ) - vec2( cz ) ) \/ e.x; \/\/ be careful to not divide by e since it has zero in .y\n\t\n\tfloat grad_len = length( h_gradval_at_c );\n\n\t#define FARMS_GRAD_LIMIT   _1 \/\/ don't place farms when slope is too strong\n\t#define FARMS_GRAD_ELEVATE _1 \/\/ elevate house so they don't sink into the ground, using the gradient\n\t#define FARMS_GRAD_ALIGN   _1 \/\/ align farm with terrain gradient instead of random rotation\n\n\tif ( FARMS_GRAD_LIMIT && ( grad_len > 0.17 ) ) return di;\n\tif ( FARMS_GRAD_ELEVATE ) cz += r * grad_len * 0.65;\n\n\t\/\/ move to local coords\n\tp.xy -= c;\n\tp.z -= cz;\n\t\n\tp.xy = rotate_with_unit_vector( p.xy, FARMS_GRAD_ALIGN && ( grad_len > 0.01 )\n\t\t\t\t\t\t\t\t\t? normalize( h_gradval_at_c ) \n\t\t\t\t\t\t\t\t\t: unit_vector2( hash1u2_4tXyWN( uvec2(cr._pi) ) * 2.0 * PI ) ); \/\/ random rotation\n\n\tif ( _0 ) return MkDistanceId( sd_sphere( p, vec3( 0 ), r ), MATID_HOUSE ); \/\/ try make the building fit inside the sphere\n\n\tDistanceId eval = sdFarm( p, cr,patch_id, r, 1.0 );\n\t\n\tif ( IsShadeTrace( scenein.trace_flags ) && ( DecodeId( eval ) == MATID_ROOF ) )\n\t{\n\t\teval = MkDistanceId_16( eval.d, MATID_ROOF, hash11( patch_id ) ); \/\/ same roof color for all houses in patch\n\t}\n\n\treturn eval;\n}\n\nfloat sdBrickWall( vec3 p, ClosestPath path, float h )\n{\n\tfloat wall_start_dist = LANEWIDTH * 0.5 + 0.005;\n\tfloat wall_thickness = 0.018;\n\tfloat wall_height = 0.05;\n\tfloat wall_radius = 0.008;\n\tfloat d = FLT_MAX;\n\tfor ( float k = 0.0; k < 2.0; k += 1.0 )\n\t{\n\t\tvec3 pl = p; \/\/ p local\n\t\tpl.xy = GetLocalCurvePoint( path );\n\t\tpl.y -= wall_start_dist + wall_thickness * 0.5;\n\t\tpl.z -= h;\n\t\tvec3 s = vec3( 0.01, 0.006, 0.006 );\n\t\tfloat spacing = 0.0015;\n\t\tvec3 c;\n\t\tc.xz = vec2( s.x + spacing, 2.0 * s.z + spacing );\n\t\tc.y = s.y + spacing;\n\t\tvec2 offset = -0.5 * c.xz;\n\t\tfloat o = 0.5 * k;\n\t\toffset.xy += o * c.xz;\n\t\tvec2 i;\n\t\ti = floor( ( pl.xz - offset ) \/ c.xz );\n\t\ti.y = min( i.y, 2.0 );\n\t\tpl.xz -= i * c.xz;\n\t\tpl.xz -= o * c.xz;\n\t\tfloat r = 0.002;\n\t\td = opU( d, sd_bounds_range_round( pl, -s * 0.5, s * 0.5, r ) );\n\t}\n\tif ( _1 ) d -= 0.003 * sfbm2_13( p * 80.0 );\n\treturn d;\n}\n\nfloat sdGrass( vec3 p, float h ) { return p.z - h; }\n\n\/\/ scene eval output\nstruct SceneOut\n{\n\tDistanceId object_di;\n\tfloat d_ghost; \/\/ can we optimize that and have less of those?\n\tfloat base_height; \/\/ base ground height\n\tClosestPath path;\n\tClosestPath test2d; \/\/ for 2d view mode\n\tvec3 color; \/\/ special color case for bushes (when id_fraction is not enough)\n#ifdef TERRAIN_WARP\n\t\/\/ this cuts bush evals massively\n\tfloat terrain_warp; \/\/ todo: move out of this struct, this is not part of returned information\n#endif\n};\n\nvoid SceneOutInit( inout SceneOut eval ) { eval.d_ghost = FLT_MAX; }\n\nvec3 get_bush_palette( vec2 uv )\n{\n\treturn mix( mix( mix( COLOR_BUSH1, COLOR_BUSH2, uv.x ), mix( COLOR_BUSH3, COLOR_BUSH4, uv.x ), uv.y )\n\t\t\t\t, COLOR_BUSH5, smoothband( uv.x, 0.49, 0.51, 0.01 ) );\n}\n\nbool is_white_cell( vec2 p_index ) { return ( int( p_index.x + p_index.y ) & 1 ) == 1; }\n\nvoid consider_close_point_hi( inout float d, vec2 index, float r, inout vec4 color, vec3 p, float cellsize\n\t\t\t\t\t\t\t  , vec3 h_gradval, bool taylor_expansion_height, int trace_flags )\n{\n\tvec3 c;\n\tvec3 h = hash32( index );\n\tc.xy = ( index + h.xy ) * cellsize;\n\tc.z = CalcHeight( c.xy, p.xy, h_gradval, taylor_expansion_height ) + r * mix( -0.8, 1.3, h.z );\n\tfloat di = length( c - p ) - r;\n\td = min( d, di );\n\n\tif ( IsShadeTrace( trace_flags ) )\n\t{\n\t\tvec2 ch = hash22( index );\n\t\t\/\/ this is called only once in shade, knock yourself out\n\t\tfloat w = max( 1. - smoothstep( -r * 0.1, r * 0.25, di ), 1e-3 );\n\t\tcolor.xyz += get_bush_palette( ch ) * w;\n\t\tcolor.a += w;\n\t}\n}\n\nstruct CloseGridPointArgs { float cell_size, max_radius, radius_disparity; };\n\nstruct CloseGridPointArgsWithBand\n{\n\tCloseGridPointArgs args0;\n\tfloat band_start, band_end;\n\tbool taylor_expansion_height;\n};\n\n\/\/ 45 means we consider 4 or 5 neighbour (instead of 3x3) depending on whether we are on a white or a black cell (not perfect but covers lots of cases)\n\/\/ instead of giving the closest point this version does a little bit of extra calculation or each candidate for color blending on bushes\nfloat GetCloseGridPoints45( inout vec3 a_color, vec3 p, float cellsize, vec3 h_gradval, CloseGridPointArgsWithBand args, int trace_flags, int aFrame )\n{\n\tfloat r = args.args0.max_radius * 0.8;\n\tvec2 p_index = floor( p.xy * ( 1.0 \/ cellsize ) );\n\n\tfloat d = FLT_MAX;\n\tvec4 color = vec4( 0.0 );\n#if 0\n\t\/\/ the unrolled code path is faster on my current view (70ms->68ms) but shader compilation prefers the loop (-1s)\n\tif ( is_white_cell( p_index ) )\n\t{\n\t\t\/\/white cell\n\t\tconsider_close_point_hi( d, p_index + vec2( -1,  0 ), r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t\tconsider_close_point_hi( d, p_index + vec2(  1,  0 ), r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t\tconsider_close_point_hi( d, p_index + vec2(  0, -1 ), r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t\tconsider_close_point_hi( d, p_index + vec2(  0,  1 ), r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t}\n\telse\n\t{\n\t\t\/\/black cell\n\t\tconsider_close_point_hi( d, p_index + vec2( -1,  1 ), r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t\tconsider_close_point_hi( d, p_index + vec2(  1,  1 ), r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t\tconsider_close_point_hi( d, p_index + vec2( -1, -1 ), r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t\tconsider_close_point_hi( d, p_index + vec2(  1, -1 ), r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t\tconsider_close_point_hi( d, p_index + vec2(  0,  0 ), r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t}\n#else\n\tvec2 offset = vec2( 0, 1 ); \/\/ white cells check 4 canonical axis neigbours\n\tif ( !is_white_cell( p_index ) )\n\t{\n\t\tconsider_close_point_hi( d, p_index, r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags ); \/\/ this cell, only checked if black\n\t\toffset = vec2( 1, 1 ); \/\/ black cells check the 4 diagonal neighbours\n\t}\n\n\tfor ( int i = 0 FORCE_LOOP; i < 4; ++i )\n\t{\n\t\tconsider_close_point_hi( d, p_index + offset, r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t\toffset = perp( -offset ); \/\/ go to next neighbour by rotating +90\n\t}\n#endif\n\tif ( IsShadeTrace( trace_flags ) ) \/\/ skipping this test breaks the trees...\n\t\ta_color = color.xyz \/ color.a;\n\n\treturn d;\n}\n\n#define bush_max_radius 0.04\n\/\/ for bushes we do something symbolic looking, with a slight Hiroshi Nagai vibe \nvoid AddContributionBushes( inout SceneOut eval, SceneIn scenein\n\t\t\t\t\t\t\t, vec3 h_gradval, float groundz, vec3 patch_id_hash\n\t\t\t\t\t\t\t, bool is_forest_patch, float aTime, int aFrame )\n{\n\tvec3 p = scenein.p;\n\tbool has_bushes = patch_id_hash.x > 0.2;\n\tbool has_cut_bushes = SQUARE_BUSH_TEST && ( !is_forest_patch && patch_id_hash.x > 0.62 );\n\n\tfloat bush_cell_size = 0.095;\n\n\tfloat bush_d_min = p.z - ( groundz + bush_max_radius*1.9 ); \/\/ upper bound for distance to bushes\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \/\/ multiply by 2 else lots of bushes get cut... \n\n\t\/\/ note: whether we use > or <= has resulted in big difference in the past sometimes\n\tif ( !has_bushes\n\t\t || ( bush_d_min > eval.object_di.d )\n#ifdef TERRAIN_WARP\n\t\t || (\n\t\t\t  ( eval.terrain_warp != 0.0 ) &&\n\t\t\t  ( bush_d_min > 0.0 ) &&\n\t\t\t  ( bush_d_min < eval.terrain_warp ) ) \/\/ we know we can roughly traverse by eval.terrain_warp before hitting next bush\n#endif\n\t\t) return;\n\n\tfloat d = FLT_MAX;\n\tfloat id_fraction = 0.0;\n\tfloat freq = 1.0;\n\n\tif ( has_cut_bushes )\n\t{\n\t\tfreq = DISPLACE_BUSH_FREQ;\n\t\t\n\t\t\/\/ patch section 2d point\n\t\tvec2 p_patch_section = vec2( eval.path.patch_di.d, p.z - eval.base_height );\n\t\tfloat d_square_bush = sd_bounds_range( p_patch_section, vec2( LANEWIDTH - 0.015, 0 ), vec2( LANEWIDTH + 0.02, 0.05 ) );\n\t\td = d_square_bush; \/\/ we distort so...\n\n\t\teval.color = COLOR_BUSH3;\n\t}\n\telse\n\t{\n\t\tfreq = DISPLACE_BUSH_FREQ;\n\n\t\t\/\/ this is a patch with bushes on the side\n\t\tCloseGridPointArgsWithBand args;\n\t\targs.args0.cell_size = bush_cell_size;\n\t\targs.args0.max_radius = bush_max_radius;\n\t\targs.args0.radius_disparity = 0.4;\n\t\targs.band_start = LANEWIDTH * 0.5 + args.args0.max_radius * 0.5; \/\/ take a fraction of the radius so that some of the bushes overlap a bit with the path\n\t\targs.band_end = args.band_start + 0.18 + pow2( patch_id_hash.z ) * 0.3;\n\t\targs.taylor_expansion_height = TAYLOR_HEIGHT_BUSH;\n\n\t\td = GetCloseGridPoints45( eval.color, p, args.args0.cell_size * 0.5, h_gradval, args, scenein.trace_flags, aFrame );\n\n\t\tif ( SOFT_BLEND_BUSH ) d = opU_weld_quadric( p.z - eval.base_height, d, 0.027 );\n\n\t\t\/\/ clip bush vs path\/walls (leak through walls is a happy accident)\n\t\tif ( _1 ) d = opS_soft2( d, abs( eval.path.patch_di.d ) - LANEWIDTH * 0.5, 100.0 );\n\n\t\tif ( _1 )\n\t\t{\n\t\t\t\/\/ fade bush inside patch\n\t\t\tfloat bf = ( sfbm1_12( p.xy * 18.0 ) - 0.5 ) * 0.33; \/\/ distort fade boundary\n\t\t\td = opS_soft2( d, args.band_end * ( 1. + bf ) - eval.path.patch_di.d, 30.0 );\n\t\t}\n\t}\n\n\tif ( DISPLACE_BUSH )\n\t{\n\t\tfloat dd = 0.0045; \/\/ need more displacement to see shadows...\n\n\t\tvec3 pd = p;\n\t\tif ( WIND_BUSH ) pd += ApplyWind( pd, aTime );\n\t\t\n\t\t \/\/ the test is < ..*3 because we INFLATE\n\t\tif ( d < dd * 3.0 ) d -= sfbm2_13( pd * vec3( 80.0, 80.0, 100 ) * freq ) * dd;\n\t}\n\n\teval.object_di = opUdi( eval.object_di, MkDistanceId_16( d, MATID_BUSH, id_fraction ) );\n}\n\n\/\/ return closest cell point with a radius, no neighbour, used by farms and trees\n\/\/ max_radius must be less than cell_size*0.5\n\/\/ radius_disparity percentage in 0,1\n\/\/ grid_offset in 0,1, conceptually...\nvoid GetClosestGridPoint( inout CellPoint point, vec2 p, CloseGridPointArgs args0, float grid_offset, float hoffset )\n{\n\tvec2 pi = floor( ( p - grid_offset ) \/ args0.cell_size );\n\tpoint._pi = ivec2( pi + vec2( hoffset ) );\n\tvec4 ph = hash42_( point._pi );\n\/\/\tph.xy = vec2( 0.5 ); \/\/ debug\n\tpoint.pradius = args0.max_radius * ( 1.0 - args0.radius_disparity * ph.z );\n\tvec2 a = grid_offset + pi * args0.cell_size;\n\tvec2 b = a + vec2( args0.cell_size );\n\tpoint.p = mix( a + vec2( point.pradius ),\n\t\t\t\t   b - vec2( point.pradius ), ph.xy ); \/\/ important: +offset to put back in same space as p\n}\n\n\/\/ used by farms and trees\nbool GetClosestGridPointWithPathBand_x1( inout CellPoint point\n\t\t\t\t\t\t\t\t\t\t , vec2 p\n\t\t\t\t\t\t\t\t\t\t , vec3 h_gradval\n\t\t\t\t\t\t\t\t\t\t , CloseGridPointArgsWithBand args\n\t\t\t\t\t\t\t\t\t\t , float grid_offset, float hoffset )\n{\n\tGetClosestGridPoint( point, p, args.args0, grid_offset, hoffset );\n\n\t\/\/ we want to know if this point is within a band of the country patch we are currently in\n\tfloat distance_to_patch_border = abs( EvalClosestPath( point.p, true ).patch_di.d );\n\treturn ( distance_to_patch_border > args.band_start )\n\t\t&& ( distance_to_patch_border < args.band_end );\n}\n\nvoid SetSceneInDirection( inout SceneIn scenein, vec3 o, vec3 v, int trace_flags )\n{\n\tscenein.v = v;\n\tscenein.v_rcp = vec3( 1.0 ) \/ v;\n\/\/\tscenein.o = o;\n\tscenein.trace_flags = trace_flags | TRACE_HAS_DIRECTION;\n\tscenein.t0 = 0.0;\n}\n\nvoid SetSceneInDirectionless( inout SceneIn scenein, int trace_flags )\n{\n\tscenein.v = vec3( 0.0 );\n\tscenein.v_rcp = vec3( 0.0 );\n\/\/\tscenein.o = vec3( 0.0 );\n\tscenein.trace_flags = trace_flags;\n\tscenein.t0 = 0.0;\n}\n\nfloat ClampRayAgainstCurrentGridCell( vec3 p, vec3 v_rcp, vec3 cell_size, float cell_inflate_epsilon )\n{\n\t\/\/ we know the direction therefore we only have to test one side of each axis\n\tvec3 s = sign( v_rcp );\n\tvec3 amin = floor( p \/ cell_size ) * cell_size;\n\tamin -= vec3( cell_inflate_epsilon ); \/\/ instead of adding that to d_ghost we clamp to cell_size + cell_inflate_epsilon\n\tvec3 a = amin + ( ( s + 1.0 ) * 0.5 ) * ( cell_size + 2.0 * vec3( cell_inflate_epsilon ) );\n\tvec3 t = ( a - p ) * v_rcp; \/\/ ray vs all closest box planes\n\/\/\tt += FLT_MAX * ( 1.0 - abs( s ) ); \/\/ when sign is zero, push next hit at t=+infinite, v_rcp has been set to zero in that case\n\treturn min( min( t.x, t.y ), t.z ); \/\/ should be > 0 by construction\n}\n\nbool CanGhostStep( SceneIn scenein, float maxdist_from_t0, float maxdist_abs )\n{\n\treturn HasDirection( scenein.trace_flags )\n\t\t&& ( scenein.t < maxdist_abs ) \/\/ GHOST_MAX_DIST_ABS\n\t\t&& ( ( scenein.t - scenein.t0 ) < maxdist_from_t0 ); \/\/ GHOST_MAX_DIST_FROM_T0\n}\n\nvoid GhostGridSteps( inout SceneOut eval, SceneIn scenein, float cell_size, float cell_inflate_epsilon )\n{\n\tfloat dm = ClampRayAgainstCurrentGridCell( scenein.p, scenein.v_rcp\n\t\t\t\t\t\t\t\t\t\t\t   , vec3( cell_size, cell_size, 20.0 ), cell_inflate_epsilon );\n\t\/\/ note that this doesn't deal with diagonals which might cross another cell\n\teval.d_ghost = min( eval.d_ghost, max( dm, GHOST_EPS ) );\n}\n\n\/\/ used by farms and trees\n#define SD_OBJECT_CONTRIB( _di_, _object_sd_func_, _grid_offset_, _hoffset_ ) {\\\n\tCellPoint _cp_; \\\n\tif ( GetClosestGridPointWithPathBand_x1( _cp_, p.xy, h_gradval, args, _grid_offset_, _hoffset_ ) )\\\n\t\t_di_.object_di = _object_sd_func_( _di_.object_di, p, _cp_, radius_fraction, _di_.path.patch_di.id, eval.color, scenein, h_gradval, args.taylor_expansion_height );\\\n}\n\nvoid AddContributionTrees( inout SceneOut eval, SceneIn scenein\n\t\t\t\t\t\t   , vec3 h_gradval, float groundz, vec3 patch_id_hash, int aFrame, float aTime )\n{\n\tvec3 p = scenein.p;\n\tfloat tree_max_radius = 0.15;\n\n\tCloseGridPointArgsWithBand args;\n\targs.args0.cell_size = 0.4;\n\targs.args0.max_radius = tree_max_radius;\n\targs.args0.radius_disparity = 0.1;\n\targs.band_start = args.args0.max_radius;\n\t\/\/ some patches are filled with trees, some other patches only have trees on the border\n#if 1\n\targs.band_end = patch_id_hash.x > 0.9 ? FLT_MAX : args.args0.max_radius * 3.0;\n#else\n\targs.band_end = FLT_MAX;\n#endif\n\targs.taylor_expansion_height = TAYLOR_HEIGHT_TREE;\n\n\tfloat grid_offset_step = 0.25; \/\/ this is wrong actually but creates a certain sparsity that is welcome\n\tvec3 grid_offsets = vec3( 0., 1.0, 2.0 ) * grid_offset_step * args.args0.cell_size;\n\tfloat radius_fraction = 1.0;\n#if 0\n\tSD_OBJECT_CONTRIB( eval, sdGridObj_TreeOrPine, grid_offsets.x, 000.0 );\n\tSD_OBJECT_CONTRIB( eval, sdGridObj_TreeOrPine, grid_offsets.y, 100.0 );\n\tSD_OBJECT_CONTRIB( eval, sdGridObj_TreeOrPine, grid_offsets.z, 200.0 );\n#else\n\t\/\/ this might be a bit faster (92->71!), also shadertoy compile time\n\tfor ( float f = 0.0 FORCE_LOOPF; f < 3.0; f += 1.0 )\n\t{\n\t\tSD_OBJECT_CONTRIB( eval, sdGridObj_TreeOrPine, grid_offset_step * args.args0.cell_size * f, 100.0 * f );\n\t}\n#endif\n\n\tfloat mat_id = DecodeId( eval.object_di );\n\t\/\/ displace all the trees at once...\n\tif ( DISPLACE_TREE && ( ( mat_id == MATID_TREE ) || ( mat_id == MATID_PINE ) ) )\n\t{\n\t\tvec3 pd = p;\n\t\tif ( WIND_TREE_AND_PINES ) pd += ApplyWind( pd, aTime );\n\n\t\tfloat is_pine = ( mat_id == MATID_PINE ) ? 1. : 0.;\n\t\t\n\t\tpd.z *= mix(1.,0.75,is_pine);\n\t\t\n\t\teval.object_di.d += sfbm2_13_leaf( pd * 80.0 * 2.2 ) * TREE_SDD * mix( 1., 0.4, is_pine ) * 0.8;\n\t}\n\n\tif ( GHOST_STEPS_TREE && CanGhostStep( scenein, GHOST_MAX_DIST_FROM_T0, GHOST_MAX_DIST_ABS ) )\n\t{\n\t\t\/\/ note: offset zero for all + smallest cell size fraction multiple should yield same result\n\t\tfloat cell_inflate_epsilon = 0.004; \/\/ tree\n\t\tGhostGridSteps( eval, scenein, grid_offset_step * args.args0.cell_size, cell_inflate_epsilon );\n\t}\n}\n\nvoid AddContributionFarms( inout SceneOut eval, SceneIn scenein\n\t\t\t\t\t\t   , vec3 h_gradval, float groundz, vec3 patch_id_hash\n\t\t\t\t\t\t   , float closest_path_middle_point_height )\n{\n\tvec3 p = scenein.p;\n\tbool is_farm_patch = patch_id_hash.x > 0.2;\n\n\tif ( !is_farm_patch ) return;\n\n\tif ( FARM )\n\t{\n\t\t\/\/ farms are sparse so use 1 cell\n\t\tCloseGridPointArgsWithBand args;\n\t\targs.args0.cell_size = 1.2;\n\t\targs.args0.max_radius = 0.35;\n\t\targs.args0.radius_disparity = 0.3;\n\t\targs.band_start = args.args0.max_radius * 1.5;\n\t\targs.band_end = FLT_MAX;\n\t\targs.taylor_expansion_height = TAYLOR_HEIGHT_FARM;\n\t\tfloat radius_fraction = 0.8;\n\t\tSD_OBJECT_CONTRIB( eval, sdGridObj_Farm, 0.0, 0.0 );\n\t\tif ( GHOST_STEPS_FARM && CanGhostStep( scenein, GHOST_MAX_DIST_FROM_T0, GHOST_MAX_DIST_ABS ) )\n\t\t{\n\t\t\tfloat cell_inflate_epsilon = 0.004;\n\t\t\tGhostGridSteps( eval, scenein, args.args0.cell_size, cell_inflate_epsilon );\n\t\t}\n\t}\n\n\tif ( BRICKWALL && patch_id_hash.y > 0.7 ) \/\/ note: not all farm patch have a visible house on them...\n\t{\n\t\tDistanceId walls = MkDistanceId( sdBrickWall( p, eval.path, eval.base_height ), MATID_BRICKWALL );\n\t\teval.object_di = opUdi( eval.object_di, walls );\n\t}\n}\n\nvoid AddContributionGrass( inout SceneOut eval, vec3 p, float groundz, vec3 patch_id_hash )\n{\n\tfloat grass_height = ( groundz - 0.01 ) \/\/ make sure grass doesn't cover the path ground\n\t\t+ smoothstep( -0.02, 0.04, abs( eval.path.patch_di.d ) - LANEWIDTH * 0.5 ) * 0.0195;\n\tDistanceId grass = MkDistanceId_16( sdGrass( p, grass_height ), MATID_GRASS, patch_id_hash.z ); \/\/ each patch has slightly different colors\n\teval.object_di = opUdi( eval.object_di, grass );\n}\n\nvoid AddContributionPath( inout SceneOut eval, SceneIn scenein, float groundz )\n{\n\tvec3 p = scenein.p;\n\tfloat path_d_min = p.z - groundz;\n\n\tif ( !( path_d_min < eval.object_di.d ) ) return; \/\/ weird compiler horror happened depending how we write the if branch here\n\n\t\/\/ path is the most occluded thing so do it last\n\tDistanceId path_di = MkDistanceId_16( path_d_min \/\/ lower bound for bushes\n\t\t\t\t\t\t\t\t\t   , MATID_GROUND, ( 1.0 - smoothstep( 0.0, 0.05, eval.path.patch_di.d ) ) );\n\tif ( DISPLACE_PATH )\n\t{\n\t\t\/\/ this displacement is expensive, cull as much as we can, maybe we could just do that in shade\n\t\tfloat path_blend = 1.0 - smoothstep( 0.001, 0.008, eval.path.patch_di.d - LANEWIDTH * 0.5 );\n\t\tfloat distance_blend = 1.0 - smoothstep( 6.0, 7.0, scenein.t );\n\t\tfloat fade = path_blend * distance_blend;\n\t\tif ( fade > 0.0 ) \/\/ that cuts a bit\n\t\t{\n\t\t\t\/\/ so we can scale along road direction\n\t\t\tpath_di.d += fade * sfbm2_12( GetLocalCurvePoint( eval.path ) * vec2( 1, 2 ) * 80.0 ) * DISPLACE_PATH_AMPL;\n\t\t}\n\t}\n\n\teval.object_di = opUdi( eval.object_di, path_di );\n}\n\nSceneOut evalScene( SceneIn scenein, int aFrame, float aTime)\n{\n\tvec3 p = scenein.p;\n\n\tSceneOut eval;\n\tSceneOutInit( eval );\n\t\n\tfloat groundz = BaseGroundHeight( p.xy );\n\teval.base_height = groundz;\n\teval.path = EvalClosestPath( p.xy, false );\n\tvec3 h_gradval = vec3( 0.0, 0.0, groundz );\n\n#ifdef TERRAIN_WARP\n\tvec3 ground_normal;\n#endif\n\n\tif (\n#ifdef TERRAIN_WARP\n\t\t _1 ||\n#endif\n\t\t \/\/ any of those need the height gradient at p\n\t\t TAYLOR_HEIGHT_BUSH ||\n\t\t TAYLOR_HEIGHT_TREE ||\n\t\t TAYLOR_HEIGHT_FARM )\n\t{\n\t\tvec2 e = vec2( 1e-3, 0 );\n\t\tfloat hx = BaseGroundHeight( p.xy + e.xy );\n\t\tfloat hy = BaseGroundHeight( p.xy + e.yx );\n\t\th_gradval.xy = vec2( hx - eval.base_height,\n\t\t\t\t\t\t\t hy - eval.base_height ) \/ e.x; \/\/ be careful to not divide by e since it has zero in .y\n#ifdef TERRAIN_WARP\n\t\tvec3 px = vec3( p.xy + e.xy, hx );\n\t\tvec3 py = vec3( p.xy + e.yx, hy );\n\t\tvec3 pc = vec3( p.xy, eval.base_height );\n\t\tground_normal = normalize( cross( px - pc, py - pc ) );\n#endif\n\t}\n\n#ifdef TERRAIN_WARP\n\teval.terrain_warp = 0.0;\n\tif ( HasDirection( scenein.trace_flags ) )\n\t{\n\t\tfloat large_optimistic_step = 3.0;\n\t\tvec3 base = vec3( p.xy, eval.base_height + bush_max_radius*2.5 );\n\t\tRay warp_ray;\n\t\twarp_ray.o = scenein.p;\n\t\twarp_ray.d = scenein.v;\n\t\tfloat t2 = plane_trace( warp_ray, base, ground_normal, 1e-3 );\n\t\tif ( t2 > 0.0 )\n\t\t{\n\/\/\t\t\tif ( dot( ground_normal, scenein.v ) < 0 ) \/\/ if terrain is convex at ground_normal in trace direction?\n\t\t\t\teval.terrain_warp = min( t2, large_optimistic_step );\n\t\t}\n\t}\n#endif\n\n\t\/\/ eval.path.patch_di.id is the patch id\n\t\/\/ eval.path.patch_di.d is the distance to closest path\n\t\/\/\n\t\/\/ the path we walk on is flat so we need the height of center of the road\n\tvec2 closest_patch_border_point2 = p.xy + eval.path.v2closest; \/\/ center of road\n\tfloat closest_path_middle_point_height = BaseGroundHeight( closest_patch_border_point2 ); \/\/ fences use\n\n\teval.test2d = eval.path;\n\n\t\/\/ upper bound for distance to ground, take into account displacement that might dig a little on paths\n\tfloat d_ground_max = p.z - ( eval.base_height - DISPLACE_PATH_AMPL * 2.0 );\n#if 0\n\t\/\/ bogus build error on ? : in shadertoy\n\teval.object_di = GROUND_OCCLUSION \/\/ occlusion helps\n\t\t? MkDistanceId( d_ground_max, MATID_GROUND )\n\t\t: MkDistanceId( FLT_MAX, MATID_NONE ); \/\/ enable PATH to get a ground\n#else\n\tif ( GROUND_OCCLUSION ) eval.object_di = MkDistanceId( d_ground_max, MATID_GROUND ); \/\/ occlusion helps\n\telse eval.object_di = MkDistanceId( FLT_MAX, MATID_NONE ); \/\/ enable PATH to get a ground\n#endif\n\t\/\/ hit the patch boundary tangent plane, this has 2 properties we want:\n\t\/\/  1- the closer we are to the boundary the more this approximates the hit point, sort of\n\t\/\/  2- if ray leaches the patch boundary, the hit point will be far away\n\t\/\/      -> that second one improves significantly the horrible artifact where we run out of points...\n\t\/\/  also ignore far away hits for perfs   \n\t\n\t\/\/ todo: we don't need ghost steps if we are far above the ground! we can save a bit\n\n\tif ( GHOST_STEPS_PATCH && CanGhostStep( scenein, GHOST_MAX_DIST_FROM_T0, GHOST_MAX_DIST_ABS ) )\n\t{\n\t\tvec3 base = vec3( p.xy + eval.path.v2closest, p.z );\n\t\tvec3 normal = normalize( -vec3( eval.path.v2closest, 0 ) );\n\t\tfloat t2 = plane_trace( p, scenein.v, base, normal, 1e-3 );\n\t\tif ( t2 > 0.0 ) eval.d_ghost = min( eval.d_ghost, max( t2, GHOST_EPS ) );\n\t}\n\n\/\/\tvec3 patch_id_hash = hash31( eval.path.patch_di.id );\n\tvec3 patch_id_hash = hash42_( ivec2( int( eval.path.patch_di.id ) ) ).xyz; \/\/ paranoid use of ints for important structural elements\n\n\tbool is_forest_patch = patch_id_hash.x > 0.65;\n\n\tif ( is_forest_patch )\n\t{\n\t\tif ( TREE ) AddContributionTrees( eval, scenein, h_gradval, groundz, patch_id_hash, aFrame, aTime );\n\t}\n\telse AddContributionFarms( eval, scenein, h_gradval, groundz, patch_id_hash, closest_path_middle_point_height );\n\n\tif ( BUSH ) AddContributionBushes( eval, scenein, h_gradval, groundz, patch_id_hash, is_forest_patch, aTime, aFrame );\n\tif ( GRASS ) AddContributionGrass( eval, p, groundz, patch_id_hash );\n\tif ( PATH ) AddContributionPath( eval, scenein, groundz );\n\n\treturn eval;\n}\n\nstruct TraceOutput\n{\n\tfloat t;\n\tfloat dist; \/\/ distance to surface (error)\n\tfloat shadow; \/\/ sun\/main light occlusion\n};\n\n#define MAX_ITERATIONS_VIEW 120\n#define MAX_ITERATIONS_SHADOW 40 \/\/ set this as small as you can with your lighting setting, even if shadow ray escape to sky quickly this results in big win\n#define TMAX_VIEW 80.0 \/\/ was 200 before\n#define TMAX_SHADOW 40.0 \/\/ reducing this doesn't help much\n#define TFRAC 0.8\n#define DBREAK 0.0025 \/\/ tweak for perfs!!! depends on scene scale etc might make small features thicker than they actually are\n\nTraceOutput traceScene( Ray ray, float shadow_sharpness, int trace_flags\n\t\t\t\t\t\t, int max_iterations, float tfrac, float tmaxmax, float dbreak, vec2 uv, vec2 fragCoord, int aFrame, float aTime )\n{\n\tTraceOutput to;\n\tto.t = 0.0;\n\tto.dist = 0.0;\n\tto.shadow = 1.0;\n\n\tfloat tmax = tmaxmax; \/\/ default to absolute max\n\n\t{\n\t\t\/\/ clamp traced segment\n\t\tfloat hmax = MAX_TERRAIN_HEIGHT + TALLEST_OBJECT_HEIGHT; \/\/ there must be nothing above this height\n\t\tfloat thit = plane_trace_z( ray, hmax, 1e-4 );\n\t\tif ( thit > 0.0 )\n\t\t{\n\t\t\tif ( ray.o.z > hmax ) to.t = thit; \/\/ above hmax looking down\n\t\t\telse tmax = min( thit, tmaxmax ); \/\/ below hmax looking up, clamp at hmax\n\t\t}\n\t\telse if ( ray.o.z > hmax )\n\t\t{\n\t\t\tto.t = tmaxmax * 1.1; \/\/ above hmax looking up, there is only sky\n\/\/\t\t\treturn to; \/\/ don't branch here, that might be actually slower\n\t\t}\n\t}\n\n\tSceneIn scenein;\n\tSetSceneInDirection( scenein, ray.o, ray.d, trace_flags );\n\tscenein.t0 = to.t;\n\t\n\tfor ( int i = 0 FORCE_LOOP; i < max_iterations; ++i )\n\t{\n\t\tscenein.p = ray.o + to.t * ray.d;\n\t\tscenein.t = to.t;\n\t\tSceneOut eval = evalScene( scenein, aFrame, aTime );\n\t\tfloat d = min( eval.object_di.d, eval.d_ghost );\n\t\t\/\/ note: ghost points might make us jump over solid tfrac points\n\t\tfloat is_ghost_step = ( d == eval.d_ghost ? 1.0 : 0.0 );\n\t\tto.dist = d;\n\n\t\t\/\/ important: do not move this block after the to.dist check!\n\t\tif ( IsShadowTrace( trace_flags )\n\t\t\t\/\/&& ( is_ghost_step == 0.0 ) \/\/ creates ugly discontinuities\n\t\t\t)\n\t\t{\n\t\t\t\/\/ note: if eval.object_di.d < 0 we set shadow to 0 in effect\n\t\t\t\/\/ that catches the case where first point is inside an object (because shadow ray offset issues, ex: bush vs ground normal discontinuity)\n\t\t\t\/\/ for regular case if distance is neg it means we hit an object and so shadow = 0 too anyway\n\t\t\t\/\/ https:\/\/iquilezles.org\/www\/material\/nvscene2008\/rwwtt.pdf for shadows\n\t\t\tto.shadow = min( to.shadow, shadow_sharpness * max( eval.object_di.d, 0.0 ) \/ ( to.t + 1e-4f ) );\n\t\t\t\n\t\t\tif ( to.shadow <= 0.01 ) break;\n\t\t}\n\n\t\t\/\/ warning: never stop on a ghost step!!\n\t\tif ( ( ( is_ghost_step == 0.0 ) && ( to.dist <= dbreak * to.t ) )\n\t\t\t || ( to.t > tmax ) ) break;\n\n\t\t\/\/ the amount by which we advance t: drop tfrac on ghost steps\n\t\tfloat dt = to.dist * mix( tfrac, 1.0, is_ghost_step );\n\n\t\tto.t += dt;\n\t}\n\n\tif ( to.t > tmax ) to.t = tmaxmax * 1.1;\n\n\treturn to;\n}\n\n#ifdef SHADERTOY_STANDALONE\n#define TIME_OF_DAY iSlider0\n#else\n#define TIME_OF_DAY 0.56\n#endif\n\nvec3 get_sun_direction(float aTime)\n{\n\tfloat sun_elevation = radians( mix( -30.0, 90.0, TIME_OF_DAY ) ); \/\/ careful with z, long shadows make the tracing slower\n\treturn zup_spherical_coords_to_vector( unit_vector2( PI * 0.5 - sun_elevation )\n\t\t\t\t\t\t\t\t\t\t\t , _1 ? V45 : unit_vector2( 2.0 * PI * aTime \/ 3.0 ) );\n}\n\n#define cloud_re 3000.0\n#define cloud_r1 ((cloud_re)+8.0)\n#define cloud_r2 ((cloud_r1)+1.8)\n#define fake_earth_center vec3(0,0,-cloud_re)\n\nfloat cloudDensity( vec3 p )\n{\n\tfloat sparsity = 0.07; \/\/ 0,1.x\n\tfloat freq = 0.2;\n\tfloat d = efbm4_13( p * freq, 1.0 + sparsity );\n\tfloat r = length( p - fake_earth_center );\n\tfloat r2 = length( p.xy );\n\tfloat c = smoothstep( 3., 5., r2 ); \/\/ cleanup singularity at north pole a little bit\n\td *= smoothstep( 0.4, 0.6, d * c ); \/\/ multiply d by c give best fade out\n\td = max( d, 0. );\n\td *= smoothstep( cloud_r1, cloud_r1 + 0.1, r )\n\t\t* ( 1.0 - smoothstep( cloud_r2 - 0.1, cloud_r2, r ) ); \/\/ altitude band\n\treturn d;\n}\n\n\/\/ make some ultra basic clouds out of thin air, we will bake them in a spheremap\nvec3 traceClouds( vec3 n, float aTime )\n{\n\tvec3 sun_direction = get_sun_direction(aTime);\n\tRay ray = mkray( vec3( 0.0 ), n );\n\tvec2 vt1 = sphere_trace( ray, cloud_r1, fake_earth_center );\n\tvec2 vt2 = sphere_trace( ray, cloud_r2, fake_earth_center );\n\t\/\/return vec4( vec3( 0.1*( t2.y - t1.y ) \/ ( r2 - r1 ) ), 0 );\n\/\/\tfloat li = 1.0;\n\tfloat vlen = ( vt2.y - vt1.y );\n\tfloat vdt = vlen \/ 100.0;\n\tfloat vt = vt1.y;\n\tfloat vod = 0.0;\n\tfloat vod2 = 0.0;\n\tfloat c = 0.8;\n\t\/\/ view ray\n\tfor ( ; vt < vt2.y ; vt += vdt )\n\t{\n\t\tvec3 p = ray.o + ray.d * vt;\n\t\tfloat pd = cloudDensity( p );\n\t\t{\n\t\t\t\/\/ sun ray\n\t\t\tRay lray = mkray( p, sun_direction );\n\t\t\tvec2 lt2 = sphere_trace( lray, cloud_r2, fake_earth_center );\n\t\t\tfloat llen = lt2.y;\n\t\t\tfloat ldt = llen \/ 5.0;\n\t\t\tfloat lt = ldt;\n\t\t\tfloat lod = 0.0;\n\t\t\tfor (; lt < llen; lt += ldt )\n\t\t\t{\n\t\t\t\tvec3 lp = lray.o + lray.d * lt;\n\t\t\t\tfloat lpd = cloudDensity( p );\n\t\t\t\tlod += vdt * lpd * c * 10.0;\n\t\t\t}\n\t\t\tvod2 += vdt * pd * exp( -lod -vod ); \/\/ inscatter\n\t\t}\n\t\tvod += vdt * pd * c; \/\/ absorption\n\t}\n\n\t\/\/ for compositing we do something like exp( -vod ) * distant_sky_color + vod2\n\treturn vec3( saturate(vod2), exp( -vod ), 0 );\n\t\n#define cloud_lowest_absorption_remap 0.6\n\t\n}\n\n\/\/ map theta to uv .5 r, we only keep the [0,PI\/2] theta range\n#if 0\nfloat theta2r05( float theta ) { return theta *(1.0\/PI) ; }\nfloat r052theta( float r ) { return r * PI; }\n#else\n\/\/ give more resolution to the horizon\nfloat theta2r05( float theta ) { return pow(saturate(theta*(1.0\/(PI*0.5))),2.0) *0.5; }\nfloat r052theta( float r ) { return pow((r*2.0),0.5) *PI*0.5; }\n#endif\n\nvec3 get_cloud( vec3 v, sampler2D aChannel1, vec3 aResolution, float aTime )\n{\n\tvec3 cloud = vec3(0.0);\n#if BUFFER_MODE==2\n\tif ( CLOUD_MODE>0 )\n\t{\n\t\tvec2 sc = vector_to_zup_spherical_coords( v );\n\t\tif ( sc.x > PI * 0.5 ) return BLUE;\n\t\tvec2 uv = vec2( 0.5 ) + unit_vector2( sc.y ) * theta2r05( sc.x );\n\t\tuv.x *= aResolution.y \/ aResolution.x;\n\t\tcloud = CLOUD_MODE==1\n\t\t\t? traceClouds( v, aTime )\n\t\t\t: texture( aChannel1, uv ).xyz; \/\/ return the highres one here for debug, should match with sampled one\n\t}\n#endif\t\n\treturn cloud; \/\/ debug\n}\n\nfloat sFlarePeak( vec2 p, float da, float a, float a_offset )\n{\n\ta += a_offset;\n\ta = floor( ( a \/ da ) + 0.5 ) * da;\n\tvec2 vv = unit_vector2( a - a_offset );\n\treturn abs( dot( p, perp( vv ) ) );\n}\n\nvec4 sunGlareCoords( mat4 cam, vec3 v, vec3 l )\n{\n\tvec3 sy = normalize( cross( cam[0].xyz, l ) );\n\tvec3 sx = normalize( cross( l, sy ) );\n\treturn vec4( normalize( vec2( dot( v, sx ), dot( v, sy ) ) ), dot( v, l ), -cam[2].z );\n}\n\nvec3 sunGlare( vec4 ppd \/\/ xy: angle as unit vector z: dot(v,l)\n\t\t\t   , float solid_sun_disk_radius\n\t\t\t   , float ray_length \/\/ higher value = shorter length\n\t\t\t   , float ray_thickness\n\t\t\t   , float ray_thickness_disparity\n\t\t\t   , float n1 \/\/ can be arbitrarily large\n\t\t\t   , float n2 \/\/ there is a loop on n2 - the number of rays is n1*n2 so we have a trade off between the repeat in sFlarePeak (which can't do proper additive on rays) and the for loop (which can)\n\t\t\t   , float falloff_glare_attn\n\t\t\t   , float falloff_glare_p1\n\t\t\t   , float falloff_glare_p2\n\t\t\t   , bool falloff_glare_multiplicative )\n{\n\tvec2 anglev = ppd.xy; \/\/ angle as unit vector\n\tfloat v_dot_l = ppd.z;\n\tfloat r = safe_acos( v_dot_l ) \/ PI; \/\/ could do without acos but it is a lot more easier to work with regular spacing\n\tvec2 p = anglev * r;\n\tfloat a = calc_angle( anglev );\n\/\/\treturn vec3( stripes(r,0.02,0.001,0.001\/2.0), stripes(degrees(a),10.,0.1,0.1\/2.0),0.); \/\/ visualize polarcoords\n\tfloat v = 0.0;\n\tfloat d2 = max( r - solid_sun_disk_radius, 0. ); \/\/ falloff glare\n\tfloat da = 2.0 * PI \/ n1;\n\tfloat da2 = 2.0 * PI \/ ( n1 + n2 );\n\tfor ( float i = 0.; i < n2; ++i )\n\t{\n\t\tvec3 rr = hash31( i + 1. );\n\t\tfloat rda = rr.x * da2 * 0.1;\n\t\tfloat d1 = sFlarePeak( p, da, a, -i * da \/ n2 + rda );\n\t\tif ( r < solid_sun_disk_radius ) d1 = 0.;\n\t\tv += exp2( -d1 * d1 * ray_thickness * mix( 1.0-ray_thickness_disparity, 1.+ray_thickness_disparity, rr.y )\n\t\t\t\t   -d2 * ray_length * mix( 0.5, 1.5, rr.z ) );\n\t}\n\tfloat falloff_glare = falloff_glare_attn * ( 1.0 - powerful_scurve( d2, falloff_glare_p1, falloff_glare_p2 ) );\n\tv = falloff_glare_multiplicative ? v * falloff_glare : v + falloff_glare;\n\tv = min( v, 1. );\n\treturn vec3( v );\n}\n\n#define FOG_GROUND _1\n\n \/\/ set render to false for getting a value for lighting calculation as opposed to display\nvec3 get_top_sky_color( bool render ) {  return AZURE * ( render ? 0.6 : 1.0 ); }\nvec3 get_sky_horizon_color() { return mix( WHITE, AZURE, 0.4 ); }\nvec3 get_fog_color() { return mix( AZURE, WHITE, 0.15 ); }\n\n\/\/ return a v.z normalized so that horizon view direction is remapped to 0 and zenith is still 1\nfloat get_hacked_vz( vec3 v, float ez )\n{\n\tfloat zmin = -max(ez,0.)\/(TMAX_VIEW*1.1); \/\/ z\/f=zmin\/1. where f=TMAX_VIEW*1.1\n\treturn max(0.,(v.z-zmin)\/(1.-zmin));\n}\n\nvec3 get_sky( vec3 v, vec3 l, float ez, bool render )\n{\t\n\tfloat hz = get_hacked_vz( v, ez );\n\treturn mix( get_sky_horizon_color(), get_top_sky_color(render), pow( hz, 0.2 ));\n}\n\nvec3 get_sky_plus_clouds( vec3 v, vec3 l, float ez, sampler2D aChannel1, vec3 aResolution, float aTime )\n{\n\tvec3 col = get_sky( v, l, ez, true );\n\tvec3 cloud = get_cloud( v, aChannel1, aResolution, aTime  );\n\tvec3 sky_with_clouds =  col * mix( cloud_lowest_absorption_remap, 1., cloud.y ) + vec3( cloud.x ); \/\/ composite clouds, col * absorption + scattering\n\treturn mix( col, sky_with_clouds, smoothstep( 0., 0.025, v.z ) ); \/\/ fade to sky on thin horizon band\n}\n\n\/\/ e = eye pos, v = view vector, p = lit point, n = normal, l = sun direction\nvec3 shadeSample( in vec3 e, in vec3 v, mat4 cam, in vec3 p, in vec3 n, vec3 l\n\t\t\t\t  , float shadow, TraceOutput to, float ao, vec2 uv\n\t\t\t\t  , SceneOut eval, bool sky, sampler2D aChannel1, vec3 aResolution, float aTime )\n{\n\tvec3 col = vec3( 0. );\n\t\n\tvec3 sunI = vec3( 2.0 );\n\n\tvec3 top_sky_color = get_sky(vec3(0,0,1),l,e.z,false);\n\n\tSG sun_lobe = CosineLobeSG( l );\n\tsun_lobe.Amplitude *= sunI;\n\n\tSG sky_lobe = CosineLobeSG( vec3( 0, 0, 1 ) );\n\tsky_lobe.Amplitude *= top_sky_color;\n\n\tif ( !sky )\n\t{\n\t\tvec3 scene_color = vec3( 0 );\n\t\n\t\tfloat bush_factor = 0.0;\n\t\tfloat tree_factor = 0.0;\n\t\tfloat pine_factor = 0.0;\n\t\tvec3 sky_reflection = vec3(0,0,0);\n\t\t\n\t\tvec2 mm = DecodeId_16( eval.object_di );\n\t\tfloat matid = mm.x;\n\t\tfloat matid_f = mm.y; \/\/ we can have color variations within an id\n\n\t\tbush_factor = smoothbump( MATID_BUSH, 0.5, matid );\n\t\ttree_factor = smoothbump( MATID_TREE, 0.5, matid );\n\t\tpine_factor = smoothbump( MATID_PINE, 0.5, matid );\n\t\tvec4 mm4 = DecodeId_5_5_5( eval.object_di ); \/\/ yzw = depth uheight color_rnd\n\t\tfloat tree_ao = mix( 0.6, 1., smoothstep( 0., 0.5, mm4.z ) ); \/\/ make it very faint, doesn't fit the style\n\n\t\tscene_color = vec3( 0 )\n\t\t\t+ bush_factor * eval.color\n\t\t\t+ tree_factor * mix( mix( COLOR_TREE1, COLOR_TREE2, mm4.w ), COLOR_TREE_SURF, 0.0*mm4.y*mm4.y*mm4.y ) * tree_ao\n\t\t\t+ smoothbump( MATID_TRUNK, 0.5, matid ) * COLOR_TRUNK\n\t\t\t+ smoothbump( MATID_HOUSE, 0.5, matid ) * COLOR_HOUSE\n\t\t\t+ smoothbump( MATID_HOUSE_BOTTOM, 0.5, matid ) * COLOR_HOUSE_BOTTOM\n\t\t\t+ smoothbump( MATID_ROOF, 0.5, matid ) * mix( COLOR_ROOF1, COLOR_ROOF2, matid_f )\n\t\t\t+ smoothbump( MATID_BRICKWALL, 0.5, matid ) * COLOR_BRICKWALL\n\t\t\t+ pine_factor * mix( COLOR_PINE, COLOR_PINE2, mm4.w ) * tree_ao\n\t\t\t+ smoothbump( MATID_GRASS, 0.5, matid ) * mix( COLOR_GRASS, COLOR_GRASS2, matid_f )\n\t\t\t+ smoothbump( MATID_GROUND, 0.5, matid ) * mix( PATH_COLOR, PATH_COLOR2, matid_f )\n\t\t\t+ smoothbump( MATID_NONE, 0.5, matid ) * MAGENTA;\n\n\t\tif ( MATID_WINDOW == matid ) \n\t\t{\n\t\t\tscene_color = BLACK;\n\t\t\tvec3 vr = reflect( v, n );\n\t\t\tvec3 refl_color = get_sky_plus_clouds( vr, l, p.z, aChannel1, aResolution, aTime );\n\t\t\trefl_color = mix( COLOR_GRASS * mix( 0.2, 1.0, shadow ), refl_color, smoothstep( -0.03, -0.0, vr.z ) );\n\t\t\tsky_reflection = refl_color * mix( 0.2, 1.0, pow( 1.0 - saturate( dot( -v, n ) ), 2.0 ) );\n\t\t}\n\n\t\tif ( MATID_GRASS == matid )\n\t\t{\n\t\t\tvec3 lf = sfbm4_33( p * 40.0 );\n\t\t\tfloat hf = sfbm1_12( p.xy * 2800.0 );\n\n\t\t\tif ( matid_f > ( 1. - 0.04 ) ) \/\/ mowed lawn, should be rare\n\t\t\t{\n\t\t\t\tfloat period = 0.07;\n\t\t\t\tfloat s = stripes( rotate_with_angle( p.xy, matid_f * 1000.0 ).x, period, period * 0.25, 0.004 );\n\t\t\t\tscene_color = mix( COLOR_MOWED_GRASS, COLOR_MOWED_GRASS2, saturate( s + ( lf.x - 0.38 ) * 1.5 ) );\n\t\t\t}\n\n\t\t\t\/\/ just apply some noise\n\t\t\tscene_color *= 1.0 - 0.2 * ( saturate( 1.0 - lf.y ) );\n\t\t\tscene_color *= saturate( 1.0 - 0.4 * hf * saturate( 1.0 - lf.y ) );\n\t\t}\n\t\n\t\tvec3 albedo = scene_color; \/\/ return albedo;\n\n\t\tcol += shadow * SGDiffuseFitted( sun_lobe, n, albedo );\n\n\t\t\/\/ this way of doing diffuse makes shadow color be different on ground than back of object resting on it which sucks\n\t\tif ( _1 ) col += mix( SGDiffuseFitted( sky_lobe, n, albedo ), top_sky_color, SHADOW_TINT_SATURATION )\n\t\t\t\t\/\/ add more sky ambient to tint shadow in blue? in a way that is not too hacky?\n\t\t\t\t* mix( 0.15, 0.02, shadow )\n\t\t\t\t* ao;\n\n\t\tcol += sky_reflection;\n\n\t\tfloat d = length( p - e );\n\t\tif ( FOG_GROUND ) col = mix( col, get_fog_color() * 0.8, ( 1. - exp( -0.1 * max( d - 6.1, 0. ) ) ) * 0.378 ); \/\/ fog\n\t}\n\telse\n\t{\n\t\tcol = get_sky_plus_clouds( v, l, e.z, aChannel1, aResolution, aTime );\n\n\t\tif ( SUN ) \/\/ this sun is the one in the sky\n\t\t{\n\t\t\tvec4 ppd = sunGlareCoords( cam, v, l );\n\t\t\tcol += sunGlare( ppd, 0.007, 280., 100000.0, 0.2, 20.0, 4.0, 0.3, 0.4, 8., false )\n\t\t\t\t* vec3( 0.8, 0.8, 0.5 ) * sunI;\n\t\t}\n\t}\n\n\t\/\/ note: we would like to do SUN_GLARE here, but reprojection only works on solid world pos or distance sky\n\treturn col;\n}\n\nvec3 postProcess( vec3 col, vec2 uv, vec4 ppd )\n{\n\tif ( SUN_GLARE )\n\t{\n\t\tcol.xyz += 0.116 * sunGlare( ppd, 0., 7., 8000.0, 0.2, 8.0, 8.0, 0.3, 2., 2., true )\n\t\t\t* vec3( 1., 0.7, 0.2 ) * 2. \/\/ use warmer color for this glare\n\t\t\t* smoothstep( -0.15, 0.3, ppd.w )\n\t\t\t* (1.0-smoothstep( 0.78, 0.9, ppd.z ));\n\t}\n\n\tfloat exposure = 3.0; \n\t\/\/ maybe auto expose when staring straight at the sun? the sun is a bit saturated on the clouds\n\t\/\/exposure = mix(exposure,1.,smoothstep(0.985,1.0,1.-ppd.z));\n\tcol = exposure * tonemap_reinhard( col );\n\/\/\tcol = max( vec3( 0. ), contrast( col, vec3( 1.02 ) ) );\n\tfloat vignette = .0 + 1. * pow( 20. * uv.x * uv.y * ( 1. - uv.x ) * ( 1. - uv.y ), 0.15 );\n\tcol *= vignette;\n\tcol = contrast( col, vec3( 1.06 ) );\n\tcol = gamma_correction_itu( col );\n\treturn col;\n}\n\nstruct CameraRet { vec3 eye; vec3 target; float roll; float pitch; };\n\nCameraRet init_cam() { CameraRet cam; cam.roll = 0.; cam.pitch = 0.; return cam; }\n\n#define STICKY_MOUSE false\n\nmat4 look_around_mouse_control( mat4 camera, float pitch, float tan_half_fovy, vec3 aResolution, vec4 aMouse, float dmmx )\n{\n\tfloat mouse_ctrl = 1.0;\n\tvec2 mm_offset = vec2( dmmx, pitch );\n\tvec2 mm = vec2( 0.0, 0.0 );\n\n#ifndef EXTRA_3D_CAMERA\n\tif ( aMouse.z > 0.0 || STICKY_MOUSE ) mm = ( aMouse.xy - aResolution.xy * 0.5 ) \/ ( min( aResolution.x, aResolution.y ) * 0.5 );\n#endif\n\n\tmm.x = -mm.x;\n\tmm = sign( mm ) * pow( abs( mm ), vec2( 0.9 ) );\n\tmm *= PI * tan_half_fovy * mouse_ctrl;\n\tmm += mm_offset;\n\n\treturn camera * yup_spherical_coords_to_matrix( mm.y, mm.x );\n}\n\nstruct LanePoint { vec3 p; vec3 tangent2d; float lane_index; };\n\nLanePoint getPathPointAndDir( float x, float lane_index )\n{\n\tLanePoint ret;\n\tvec2 y = wavyLaneFuncAndDerivative_WORLD( x, lane_index );\n\tret.p.xy = vec2( x, y.x );\n\tret.p.z = BaseGroundHeight( ret.p.xy ) + 0.073;\n\tret.tangent2d = normalize( vec3( 1.0, y.y, 0 ) );\n\tret.lane_index = lane_index;\n\treturn ret;\n}\n\n\/\/ a cubicstep function that takes 2 arbitrary end points and 2 (begin end) slopes\nfloat cubicstep2( float x, vec2 p0, vec2 p1, float s0, float s1 )\n{\n\tx -= p0.x;\n\tp1 -= p0;\n\tx = clamp( x, 0., p1.x );\n\tfloat x1_sqr = p1.x * p1.x;\n\tvec3 eq1 = vec3( 3.0 * x1_sqr, 2.0 * p1.x, s1 - s0 );\n\tvec3 eq2 = vec3( x1_sqr * p1.x, x1_sqr, p1.y - s0 * p1.x );\n\tfloat a = ( eq1.y * eq2.z - eq1.z * eq2.y ) \/ ( eq1.y * eq2.x - eq1.x * eq2.y );\n\tfloat b = ( eq1.z - eq1.x * a ) \/ eq1.y;\n\treturn p0.y + ( ( a * x + b ) * x + s0 ) * x;\n}\n\nfloat linearstep2( float x, vec2 p0, float s0 ) { return p0.y + s0 * ( x - p0.x ); }\n\n\/\/ getCameraPathx is a line segment of length 'a', slope 'sa' followed by another line segment of length 'b', slope 'sb',\n\/\/ made periodic and smooth. \n\/\/ the 'a' segment is where we walk, the 'b' segment is where we fly \n\/\/ this lets us tweak length and speed of walk and flight sequences separately\n\/\/ the cubic transitions are a bit iffy and tedious looking but the curve must be really clean to make landing and take off transitions natural and gentle\n\/\/ return values:\n\/\/  x: were we are on the lane\n\/\/  y: flight smooth blend factor (0 means we walk >0 means we fly, function goes up and down smootly)\n\/\/  z: the periodicity index, so each period can use a different lane\n\/\/  w: the flight begin to end smoothstep, we use it so we can blend between lanes whilst we are in the air\nvec4 getCameraPathx( float x, float a, float b, float sa, float sb, float e )\n{\n\te = min( e, min( a, b ) * 0.5 ); \/\/ e is the half lenght of smooth transitions\n\tfloat period = a + b;\n\tfloat h = sa * a + sb * b;\n\tfloat n = floor( x \/ period );\n\tx -= n * period;\n\/\/#if 1\n\tvec2 M = vec2( a, sa * a );\n\tvec2 F = vec2( a + b, h );\n\tvec2 A = vec2( 0, 0 );\n\tvec2 B = A + vec2( e, sa * e );\n\tvec2 C = M - vec2( e, sa * e );\n\tvec2 D = M + vec2( e, sb * e );\n\tvec2 E = F - vec2( e, sb * e );\n\tfloat y = n * h;\n\tif ( x < B.x ) y += cubicstep2( x, A + ( E - F ), B, sb, sa );\n\telse if ( x < C.x ) y += linearstep2( x, B, sa );\n\telse if ( x < D.x ) y += cubicstep2( x, C, D, sa, sb );\n\telse if ( x < E.x ) y += linearstep2( x, D, sb );\n\telse y += cubicstep2( x, E, F + ( B - A ), sb, sa );\n\tfloat section_b = min( smoothstep( C.x, D.x, x ), 1. - smoothstep( E.x, F.x + B.x - A.x, x ) )\n\t+ 1.0 - smoothstep( A.x + E.x - F.x, B.x, x );\n\treturn vec4( y, section_b, n, smoothstep( D.x, E.x, x ) ); \/\/ w: flight begin and end for lane transitions\n\/\/#endif\n\/\/\t\/\/ the function above if it was just piecewise linear\n\/\/\tif ( x < a ) x *= sa; else x = sa * a + ( x - a ) * sb;\n\/\/\treturn vec4( x + n * h, 0, n, 0 );\n}\n\n\/\/ get the args for getCameraPathx, with a travel lengh l and speed in input\nvec2 get_duration_and_slope( float l, float speed ) { float t = l \/ speed; return vec2( t, sqrt( max( l * l - t * t, 0. ) ) \/ t ); }\n\nmat4 walkAndFlyCamera( float tan_half_fovy, float aTime, vec4 aDate, vec3 aResolution, vec4 aMouse )\n{\n#if 1\n\tvec2 aa = get_duration_and_slope( 2.82, 1.41 );\n\tvec2 bb = get_duration_and_slope( 11.34, 7.56 );\n\tfloat te = 0.4;\n\tvec4 vv = getCameraPathx( te + aTime * 0.07, aa.x, bb.x, aa.y, bb.y, te ); \/\/ vv.y = is fly mode amount\n\tfloat lane_index = FIRST_LANE_INDEX;\n\tlane_index += vv.z;\n\tLanePoint pp_next = getPathPointAndDir( vv.x, lane_index+1.0 );\n\tLanePoint pp = getPathPointAndDir( vv.x, lane_index );\n\t\/\/ lerp with the next lane\n\tpp.p = mix(pp.p,pp_next.p,vv.w);\n\tpp.lane_index = mix(pp.lane_index,pp_next.lane_index,vv.w);\n\tpp.tangent2d = normalize(mix(pp.tangent2d,pp_next.tangent2d,vv.w));\n\t\/\/ lerp with straight curve corresponding to that (now blending) lane\n\tfloat alt = 1.;\n\tpp.p.z = mix( pp.p.z, alt, vv.y * vv.y );\n\tpp.p.y = mix( pp.p.y, ( pp.lane_index + 0.5 ) * PATH_SPACING_Y, vv.y * vv.y );\n\tpp.tangent2d = normalize( mix( pp.tangent2d, vec3( 1., 0., 0. ), vv.y ) );\n#else\n\tLanePoint pp = getPathPointAndDir( 9.8+aTime * 0.08, FIRST_LANE_INDEX ); \/\/ simple walk camera\n#endif\n\tCameraRet cam = init_cam();\n\tcam.eye = pp.p;\n\tcam.target = cam.eye + pp.tangent2d;\n\tcam.target.z -= mix(0.15,0.53, vv.y * vv.y); \/\/ this causes some roll on mouse movements as a happy side effect\n\/\/\tcam.target.z -= 0.59 * vv.y * vv.y; \/\/ this causes some roll on mouse movements as a happy side effect\n\tmat4 camera = lookat( cam.eye, cam.target, vec3( 0., 0., 1. ) ) * z_rotation( cam.roll );\n\tfloat tilt = 0.2 * sin( aTime * 0.02 ) * vv.y * vv.y; \/\/ in flight mode add some small left-right to get some tilt when no one touches the mouse\n\tvec2 dmm = vec2( tilt, -0.35 * pow( abs( tilt ), 0.6 ) );\n\treturn look_around_mouse_control( camera, cam.pitch + dmm.y, tan_half_fovy, aResolution, aMouse, dmm.x );\n}\n\nvec2 pixelIndexToFragcoord( vec2 pixel_indexf, vec3 aResolution )\n{\n\t\/\/ note that pixelIndexToFragcoord(floor(fragCoord))==fragCoord\n\treturn aResolution.xy * ( ( vec2( 0.5 ) + pixel_indexf ) \/ aResolution.xy );\n}\n\nstruct CameraData { mat4 camera; float tan_half_fovy; }; \/\/ what we need to write for the reprojection\n\nCameraData GetCameraTransform( float aTime, vec4 aDate, vec3 aResolution, vec4 aMouse )\n{\n\tCameraData data;\n\n\tdata.tan_half_fovy = 0.6;\n\n#ifdef EXTRA_3D_CAMERA\n\tdata.camera = mat4( iCamera[0], iCamera[1], iCamera[2], iCamera[3] );\n\tdata.tan_half_fovy = iTanHalfFovy;\n#else\n\tdata.camera = walkAndFlyCamera( data.tan_half_fovy, aTime, aDate, aResolution, aMouse );\n#endif\n\treturn data;\n}\n\nvec3 mat_project_vector( vec3 v, mat4 camera ) { return vec3( dot( v, camera[0].xyz ), dot( v, camera[1].xyz ), dot( v, camera[2].xyz ) ); }\nvec3 mat_project_point_dir( vec3 p, mat4 camera ) { return normalize( mat_project_vector( p - camera[3].xyz, camera ) ); }\n\n\/\/ get subpixel index, 2x2 for now\nivec2 SubpixelIndex( int aFrame ) { aFrame &= 3; return ivec2( aFrame & 1, aFrame >> 1 ); }\n\nvec2 NumSubpixels( vec3 aResolution ) { return aResolution.xy \/ 2.0; }\n\nCameraData readCameraData( ivec2 offset, vec3 aResolution, sampler2D aChannel1 )\n{\n\tCameraData data;\n#if 0\n\tfloat y = offset.x + 2.0 * offset.y;\n\tdata.camera[0] = vec4( texture( aChannel1, ( vec2( 0.5 ) + vec2( 0, y ) ) \/ aResolution.xy, 0 ).xyz, 0 );\n\tdata.camera[1] = vec4( texture( aChannel1, ( vec2( 0.5 ) + vec2( 1, y ) ) \/ aResolution.xy, 0 ).xyz, 0 );\n\tdata.camera[2] = vec4( texture( aChannel1, ( vec2( 0.5 ) + vec2( 2, y ) ) \/ aResolution.xy, 0 ).xyz, 0 );\n\tdata.camera[3] = vec4( texture( aChannel1, ( vec2( 0.5 ) + vec2( 3, y ) ) \/ aResolution.xy, 0 ).xyz, 1 );\n\tdata.tan_half_fovy = texture( aChannel1, ( vec2( 0.5 ) + vec2( 4, y ) ) \/ aResolution.xy, 0 ).x;\n#else\n\tint y = offset.x + 2 * offset.y;\n\tdata.camera[0] = texelFetch( aChannel1, ivec2( 0, y ), 0 );\n\tdata.camera[1] = texelFetch( aChannel1, ivec2( 1, y ), 0 );\n\tdata.camera[2] = texelFetch( aChannel1, ivec2( 2, y ), 0 );\n\tdata.camera[3] = texelFetch( aChannel1, ivec2( 3, y ), 0 );\n\tdata.tan_half_fovy = texelFetch( aChannel1, ivec2( 4, y ), 0 ).x;\n#endif\n\treturn data;\n}\n\nvec4 mainScene( vec2 fragCoord, float aTime, vec4 aDate, vec3 aResolution, int aFrame, vec4 aMouse, sampler2D aChannel1\n\t\t\t\t, out vec4 ppd )\n{\n\tfloat aspect = aResolution.x \/ aResolution.y;\n\tvec2 uv = fragCoord.xy \/ aResolution.xy;\n\n\tvec2 pixel = fragCoord.xy;\n\tvec4 fragColor = vec4( 0.0 );\n\n#if 1\n\tCameraData camera_data = GetCameraTransform( aTime, aDate, aResolution, aMouse );\n#else\n\tivec2 offset0 = SubpixelIndex( aFrame - 0 ); \/\/ I think we get previous frame because double buffer so doesn't work as is\n\tCameraData camera_data = readCameraData( offset0, aResolution, aChannel1 );\n#endif\n\n\tRay view_ray = get_view_ray2( ( uv - vec2( 0.5 ) ) * 2.0, aspect, 1.0 \/ camera_data.tan_half_fovy, camera_data.camera );\n\tfloat ao = 1.0;\n\n\tvec3 sun_direction = get_sun_direction( aTime );\n\tbool sky = false;\n\tfloat shadow = 1.0;\n\tTraceOutput to;\n\tvec3 p2;\n\tvec3 n;\n\tSceneOut eval_for_shade;\n\tSceneOutInit( eval_for_shade );\n    Ray trace_ray = view_ray;\n\tint trace_flags = TRACE_VIEW;\n\tint max_iterations = MAX_ITERATIONS_VIEW; \n\tfloat tmaxmax = TMAX_VIEW;\n\n\t\/\/ force a loop on view ray, shadow ray to prevent shadertoy compilation abject unrolling horror\n\tfor ( int pass = 0 FORCE_LOOP; pass < (SHADOWS?2:1); ++pass )\n\t{\n\t\tTraceOutput tmp_to = traceScene( trace_ray, 5.0, trace_flags, max_iterations, TFRAC, tmaxmax, DBREAK\n\t\t\t\t\t\t\t\t\t\t , uv, fragCoord, aFrame, aTime );\n\t\tif ( pass == 1 )\n\t\t{\n\t\t\t\/\/shadow = ( tmp_to.t > TMAX_SHADOW ? 1 : 0 ); \/\/ check hard shadows\n\t\t\t\/\/shadow = tmp_to.shadow; \/\/ default soft shadows, don't work well with this scene\n\t\t\tshadow = mix( 0.05, 1.0, smoothstep( 0.4, 0.6, tmp_to.shadow ) ); \/\/ take a threshold on default soft shadows, good for sunny setting\n\t\t\tbreak;\n\t\t}\n\n\t\t\/\/ only view rays make it here... \n\n\t\tto = tmp_to;\n\t\tp2 = view_ray.o + to.t * view_ray.d;\n\t\tsky = to.t > TMAX_VIEW;\n\n\t\tif ( sky ) break;\n\t\t\n\t\t\/\/ only view rays that hit solid surfaces make it here...\n\n\t\t\/\/ we need to evaluate normal vector at hit point, we will also retrieve extra material calculations\n\t\tSceneIn scenein;\n\t\tscenein.p = p2;\n\t\tSetSceneInDirectionless( scenein, TRACE_SHADE );\n\t\tscenein.t = 0.0;\n\n\t\t{\n\t\t\t\/\/ to set this epsilon, set the camera at 1000 and check fence and terrain normal...\n\t\t\t\/\/ it should look the same as 0,0,0...\n\t\t\tfloat e = 1e-3 * 2.;\n\t\t\tvec4 v; \/\/ center in .w, deltas in .xyz\n#if 0\n\t\t\tSceneIn scenein2 = scenein;\n\t\t\tscenein2.p = scenein.p + vec3( e, 0.0, 0.0 ); v.x = evalScene( scenein2, aFrame, aTime ).object_di.d;\n\t\t\tscenein2.p = scenein.p + vec3( 0.0, e, 0.0 ); v.y = evalScene( scenein2, aFrame, aTime ).object_di.d;\n\t\t\tscenein2.p = scenein.p + vec3( 0.0, 0.0, e ); v.z = evalScene( scenein2, aFrame, aTime ).object_di.d;\n\t\t\teval_for_shade = evalScene( scenein, aFrame, aTime );\n\t\t\tv.w = eval_for_shade.object_di.d;\n#else\n\t\t\t\/\/ force a loop on gradient eval to prevent shadertoy compilation abject unrolling horror\n\t\t\tfor ( int i = 0 FORCE_LOOP; i < 4; ++i )\n\t\t\t{\n\t\t\t\tSceneIn scenein2 = scenein;\n\t\t\t\tif ( i != 3 ) scenein2.p[i] += e; \/\/ let's live dangerously and use vector component random access\n\t\t\t\teval_for_shade = evalScene( scenein2, aFrame, aTime ); \/\/ note: eval_for_shade contains material data at center, at the end of the loop\n\t\t\t\tv[i] = eval_for_shade.object_di.d;\n\t\t\t}\n#endif\n\t\t\tn = normalize( v.xyz - vec3( v.w ) );\n\t\t}\n\n\t\tif ( AO )\n\t\t{\n\t\t\tSceneIn scenein2 = scenein;\n\t\t\tSetSceneInDirection( scenein2, p2, n, TRACE_AO );  \/\/ shouldn't change anything\n\n\t\t\t\/\/ https:\/\/iquilezles.org\/www\/material\/nvscene2008\/rwwtt.pdf\n\t\t\tfloat delta = 0.1;\n\t\t\tfloat a = 0.0;\n\t\t\tfloat b = 1.0;\n\t\t\tfor ( int i = 0 FORCE_LOOP; i < 4; i++)\n\t\t\t{\n\t\t\t\tfloat fi = float( i );\n\t\t\t\tscenein2.p = p2 + n * delta * fi;\n\t\t\t\tfloat d = evalScene( scenein2, aFrame, aTime ).object_di.d;\n\t\t\t\ta += ( delta * fi - d ) * b;\n\t\t\t\tb *= 0.5;\n\t\t\t}\n\t\t\tao = max( 1.0 - 1.8 * a, 0.0 );\n\t\t}\n\n\t\tif ( SHADOWS )\n\t\t{\n\t\t\t\/\/ hack: use a different normal offset for trees as noise shadows are very sensitive to that\n\t\t\tvec4 mm4 = DecodeId_5_5_5( eval_for_shade.object_di );\n\t\t\tfloat tree_ao = 1.0;\n\t\t\tif ( (mm4.x == MATID_TREE) || (mm4.x == MATID_PINE) )\n\t\t\t{\n\t\t\t\ttree_ao += 1.0 - smoothstep( 0.2, 0.5, mm4.z );\n\t\t\t\ttree_ao -= smoothstep( -0.2, 0.0, dot( sun_direction, n ) );\n\t\t\t\ttree_ao = saturate( tree_ao );\n\t\t\t}\n\n\t\t\t\/\/ note: because of surface noise, tweaking the shadow ray normal bias has a lot of impact on vegetation\n\t\t\t\/\/ might want to tweak it per surface too\n\t\t\ttrace_ray = mkray( p2 + n * mix( 0.004, 0.0005, tree_ao ), sun_direction ); \/\/ if bias is too small here tree shadows become shitty\n\t\t\ttrace_flags = TRACE_SHADOW;\n\t\t\tmax_iterations = MAX_ITERATIONS_SHADOW;\n\t\t\ttmaxmax = TMAX_SHADOW;\n\t\t}\n\t}\n\n\tfragColor.rgb = shadeSample( view_ray.o, view_ray.d, camera_data.camera, p2\n\t\t\t\t\t\t\t\t , n, sun_direction, shadow, to, ao, uv, eval_for_shade, sky, aChannel1, aResolution, aTime );\n\n\tppd = sunGlareCoords( camera_data.camera, view_ray.d, sun_direction );\n\n\tfragColor.a = to.t; \/\/ write depth in .w to recover the world position in reprojection\n\n\treturn fragColor;\n}\n\n#if BUFFER_MODE==0\nvec4 Mode0_NoBuffer_mainImage( vec2 fragCoord, float aTime, vec4 aDate, vec3 aResolution, int aFrame, vec4 aMouse, sampler2D aChannel1 )\n{\n\tvec4 ppd;\n\tvec4 col = mainScene( fragCoord, aTime, aDate, aResolution, aFrame, aMouse, aChannel1, ppd );\n\tcol.rgb = postProcess( col.rgb, fragCoord \/ aResolution.xy, ppd );\n\treturn col;\n}\n#endif\n\n#if BUFFER_MODE==2\n\n\/\/ write camera\nvec4 Mode2_Reproject_mainBufferB( vec2 fragCoord, float aTime, vec4 aDate, vec3 aResolution, int aFrame, vec4 aMouse, sampler2D aChannel0, sampler2D aChannel1 )\n{\n\tvec2 pi = floor( fragCoord );\n\tvec4 background = texelFetch( aChannel1, ivec2( pi ), 0 );\n\n\tif ( ( pi.y > 3.0 ) || \n\t\t ( pi.x > 4.0 ) ) \n\t{\n\t\tvec4 skybox = background;\n\n\t\tivec2 res_addr = ivec2( 5, 0 ); \/\/ store position for resolution\n\n\t\tif ( ( CLOUD_MODE > 1 ) &&\n\t\t\t ( ( CLOUD_MODE == 2 ) \/\/ always\n\t\t\t   || ( aFrame <= 1 ) \/\/ on first frame\n\t\t\t   || ( texelFetch( aChannel1, res_addr, 0 ).xy != vec2( aResolution.xy ) ) ) ) \/\/ on resolution change\n\t\t{\n\t\t\tif ( pi == vec2(res_addr) ) return vec4( aResolution.xy, 0, 0 );\n\t\t\t\n\t\t\tvec2 p = fragCoord \/ aResolution.y;\n\t\t\tif ( p.x > 1. || p.y > 1. ) skybox.xyz = MAGENTA;\n\t\t\telse\n\t\t\t{\n\t\t\t\tskybox.xyz = vec3( p,0 ); \/\/vec3( traceClouds( n ) );\n\t\t\t\tp -= vec2( 0.5 );\n\t\t\t\tfloat r = length( p );\n\t\t\t\tvec3 n = zup_spherical_coords_to_vector( r052theta( r ), calc_angle( p ) ); \/\/ only care about theta in [0,PI\/2]\n\t\t\t\tskybox.xyz = traceClouds( n, aTime );\n\t\t\t\tif ( r > 0.5 ) skybox.xyz = RED;\n\t\t\t\t\/\/skybox = vec4( get_sky( n, vec3( 0 ) ).w, 0 );\n\t\t\t}\n\t\t}\n\n\t\tif ( CLOUD_MODE <= 1 ) skybox.xyz = MAGENTA;\n\n\t\treturn skybox; \/\/ unused area, we use the bottom (3*4,4) pixels\n\t}\n\n\tvec2 offset = vec2( SubpixelIndex( aFrame ) );\n\tfloat y = offset.x + 2.0 * offset.y; \/\/ subpixel flat index\n\t\n\tif ( pi.y == y )\n\t{\n\t\tCameraData data = GetCameraTransform( aTime, aDate, aResolution, aMouse );\n\t\tif ( pi.x == 0.0 ) return vec4( data.camera[0].xyz, 1 );\t   \/\/ return vec4( RED, 1 );    \n\t\tif ( pi.x == 1.0 ) return vec4( data.camera[1].xyz, 1 );\t   \/\/ return vec4( GREEN, 1 );  \n\t\tif ( pi.x == 2.0 ) return vec4( data.camera[2].xyz, 1 );\t   \/\/ return vec4( BLUE, 1 );   \n\t\tif ( pi.x == 3.0 ) return vec4( data.camera[3].xyz, 1 );\t   \/\/ return vec4( YELLOW, 1 ); \n\t\tif ( pi.x == 4.0 ) return vec4( data.tan_half_fovy, 0, 0, 1 ); \/\/ return vec4( MAGENTA, 1 );\n\t}\n\treturn background; \/\/ no touch = copy old data - we need to do that because shadertoy double buffers\n}\n\n\/\/ write each subpixel in its respective quadrant\nvec4 Mode2_Reproject_mainBufferA( vec2 fragCoord, float aTime, vec4 aDate, vec3 aResolution, int aFrame, vec4 aMouse, sampler2D aChannel0, sampler2D aChannel1 )\n{\n\tivec2 hres = ivec2( aResolution.xy ) \/ 2;\n\tivec2 offset = SubpixelIndex( aFrame );\n\tivec2 pi = ivec2( floor( fragCoord ) );\n\tivec2 pi0 = pi;\n\t\/\/ gather for coherency (make 4 quadrant, each having a full scene, instead of pixel all top pixels in 4)\n\tif ( offset != ( pi \/ hres ) ) \/\/ quadrant this pixel is in\n\t{\n\t\treturn texelFetch( aChannel0, pi, 0 ); \/\/ no touch = copy old data - we need to do that because shadertoy double buffers\n\t}\n\tpi = ( pi - offset * hres ) * 2; \/\/ also clears offset lower bits\n\tfragCoord = pixelIndexToFragcoord( vec2( pi + offset ), aResolution );\n\/\/\treturn vec4( offset, 0., 1. ); \/\/ quadrant debug color\n\tvec4 ppd;\n\treturn mainScene( fragCoord, aTime, aDate, aResolution, aFrame, aMouse, aChannel1, ppd );\n}\n\n\/\/ input uv maps 0,1 to screen\nvec2 applySubPixelOffsetTo01UV( vec2 uv, vec2 offseti, vec3 aResolution )\n{\n\t\/\/ important: since we sample the *center* of the top level pixel,\n\t\/\/ we want the *corner* of the corresponding subpixel in the quadrant image\n\t\/\/ (so offset by half the quadrant offset)\n\t\/\/ without that the image is much blurrier than it should\n\t\/\/ besides, the chance I got this wroing somewhere is high :-D\n\tuv -= ( offseti - vec2( 0.5 ) ) \/ aResolution.xy;\n\treturn ( uv + vec2( offseti ) ) * 0.5;\n}\n\nfloat reprojected( vec3 p, ivec2 offseti, CameraData cdati, vec3 aResolution, out vec4 ret, out Ray view_ray, sampler2D aChannel0 )\n{\n\tfloat aspect = aResolution.x \/ aResolution.y;\n\/\/\tCameraData cdati = readCameraData( offseti, aResolution ); \/\/ passed from caller\n\tvec3 v = mat_project_point_dir( p, cdati.camera ); \/\/ ray direction in the older camera\n\tview_ray.d = v;\n\tview_ray.o = cdati.camera[3].xyz;\n\tfloat t = plane_trace_z( v, -1.0 \/ cdati.tan_half_fovy, 1e-3 );\n\tvec2 uv = ( v * t ).xy;\n\tuv.x \/= aspect;\n\tuv = ( uv + vec2( 1.0 ) ) * 0.5;\n\tvec2 uvcheck = uv; \/\/ before going to quadrant uv, store the 01 range uv to do a uv range check see if our sampled thing is valid...\n\tuv = applySubPixelOffsetTo01UV( uv, vec2(offseti), aResolution );\n\tif ( ( t < 0.0 ) || ( t == FLT_MAX ) || ( saturate( uvcheck ) != uvcheck ) ) return 0.0;\n#if 0\n\tret = texture( aChannel0, uv );\n#else\n#if 0\n\tivec2 pmin = ivec2( 0, 0 );\n\tivec2 pmax = ivec2( aResolution.xy ) - ivec2( 1, 1 );\n#else\n\t\/\/ deal with borders\n\tivec2 pmin = offseti * ivec2( aResolution.xy ) \/ 2;\n\tivec2 pmax = pmin + ivec2( aResolution.xy ) \/ 2 - ivec2( 1, 1 );\n#endif\n\t\/\/ bilinear by hand so we can exclude samples and\/or clamp borders properly\n\tvec2 pi = uv * aResolution.xy - vec2( 0.5 );\n\tivec2 i = ivec2( floor( pi ) );\n\tvec2 f = fract( pi );\n\tvec4 v00 = texelFetch( aChannel0, clamp( i + ivec2( 0, 0 ), pmin, pmax ), 0 ); \/\/ return im0;\n\tvec4 v10 = texelFetch( aChannel0, clamp( i + ivec2( 1, 0 ), pmin, pmax ), 0 );\n\tvec4 v01 = texelFetch( aChannel0, clamp( i + ivec2( 0, 1 ), pmin, pmax ), 0 );\n\tvec4 v11 = texelFetch( aChannel0, clamp( i + ivec2( 1, 1 ), pmin, pmax ), 0 );\n#if 1\n\tvec4 A = v10 - v00;\n\tvec4 B = v01 - v00;\n\tvec4 C = ( v11 - v01 ) - A;\n\tvec4 D = v00;\n\tret = A * f.x + B * f.y + C * f.x * f.y + D;\n#else\n\tret = mix( mix( v00, v10, f.x ), mix( v01, v11, f.x ), f.y );\n#endif\n#endif\n\/\/\tret = vec4(uvcheck,0,1);\n\treturn 1.0;\n}\n\n\/\/ combine images history\nvec4 Mode2_Reproject_mainImage( vec2 fragCoord, float aTime, vec3 aResolution, int aFrame, vec4 aMouse, sampler2D aChannel0, sampler2D aChannel1, out vec4 ppd )\n{\n\tivec2 hres = ivec2( aResolution.xy ) \/ 2;\n\tivec2 pi = ivec2( floor( fragCoord ) );\n\tivec2 offset0 = SubpixelIndex( aFrame - 0 ); \/\/ this frame\n\tivec2 offset1 = SubpixelIndex( aFrame - 1 ); \/\/ previous frame\n\tivec2 offset2 = SubpixelIndex( aFrame - 2 ); \/\/ previous previous frame\n\tivec2 offset3 = SubpixelIndex( aFrame - 3 );\n\tCameraData cdat0 = readCameraData( offset0, aResolution, aChannel1 );\n\tCameraData cdat1 = readCameraData( offset1, aResolution, aChannel1 );\n\tCameraData cdat2 = readCameraData( offset2, aResolution, aChannel1 );\n\tCameraData cdat3 = readCameraData( offset3, aResolution, aChannel1 );\n\t\/\/ reprojection code path\n\t\/\/ we need to be careful here... the point we reproject is the center of the quadrant,\n\t\/\/ the regular raytraced position if we were fullscreen, because it is the only point\n\t\/\/ that is common to all quadrants and the only point that will give us a stable image\n\t\/\/ with 4 last frames (without accumulating)\n\tvec2 uv = fragCoord \/ aResolution.xy;\n\tfloat aspect = aResolution.x \/ aResolution.y;\n\tRay view_ray0 = get_view_ray2( ( uv - vec2( 0.5 ) ) * 2.0, aspect, 1.0 \/ cdat0.tan_half_fovy, cdat0.camera );\n\tvec2 uv0 = applySubPixelOffsetTo01UV( uv, vec2(offset0), aResolution );\n\tvec4 im0 = texture( aChannel0, uv0 );\n\/\/\treturn im0; \/\/ this one is always good, we have just calculated it\n\tvec3 p0 = view_ray0.o + view_ray0.d * im0.w; \/\/ the most recent world point we have\n\tvec4 im1, im2, im3;\n\tvec3 valid;\n\tRay view_ray1, view_ray2, view_ray3;\n\tvalid.x = reprojected( p0, offset1, cdat1, aResolution, im1, view_ray1, aChannel0 ); vec3 p1 = view_ray1.o + view_ray1.d * im1.w;\n\tvalid.y = reprojected( p0, offset2, cdat2, aResolution, im2, view_ray2, aChannel0 ); vec3 p2 = view_ray2.o + view_ray2.d * im2.w;\n\tvalid.z = reprojected( p0, offset3, cdat3, aResolution, im3, view_ray3, aChannel0 ); vec3 p3 = view_ray3.o + view_ray3.d * im3.w;\n\tvec4 w = vec4( 1.0 );\n\tw.yzw = valid.xyz;\n\tvec4 col = ( im0 * w.x + im1 * w.y + im2 * w.z + im3 * w.w ) \/ sum( w ); \/\/ note: don't preprocess here\n\tif ( SUN_GLARE ) ppd = sunGlareCoords( cdat0.camera, view_ray0.d, get_sun_direction( aTime ) ); \/\/ pass this to post processing\n\treturn col;\n}\n\n#endif\n\n#if BUFFER_MODE==0\n #define BUFFERB void mainImage( out vec4 fragColor, in vec2 fragCoord ) { }\n #define BUFFERA void mainImage( out vec4 fragColor, in vec2 fragCoord ) { }\n #define IMAGE void mainImage( out vec4 fragColor, in vec2 fragCoord ) { fragColor = Mode0_NoBuffer_mainImage( fragCoord, iTime, iDate, iResolution, iFrame, iMouse , iChannel1); }\n#elif BUFFER_MODE==2\n #define BUFFERB void mainImage( out vec4 fragColor, in vec2 fragCoord ) { fragColor = Mode2_Reproject_mainBufferB( fragCoord, iTime, iDate, iResolution, iFrame, iMouse , iChannel0, iChannel1); }\n #define BUFFERA void mainImage( out vec4 fragColor, in vec2 fragCoord ) { fragColor = Mode2_Reproject_mainBufferA( fragCoord, iTime, iDate, iResolution, iFrame, iMouse , iChannel0, iChannel1); }\n #define IMAGE \\\n  void mainImage( out vec4 fragColor, in vec2 fragCoord ) \\\n  { \\\n\t  vec4 ppd; \\\n\t  fragColor = Mode2_Reproject_mainImage( fragCoord, iTime, iResolution, iFrame, iMouse, iChannel0, iChannel1, ppd ); \\\n\t  fragColor.rgb = postProcess( fragColor.rgb, fragCoord \/ iResolution.xy, ppd ); \\\n\t  fragColor.a = 0.; \/* remember we have the depth in alpha, png save will go weird so clear *\/ \\\n  }\n#endif\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"BUFFERA","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"BUFFERB","name":"Buffer B","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"llsXRX","date":"1438688991","viewed":14284,"name":"[SIG15] Eve Arrives","username":"iq","description":"Still incomplete (finish arms, add animation, add cameras, add sounds fx)","likes":120,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"\/media\/a\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"\/media\/ap\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Created by inigo quilez - iq\/2015\n\/\/ https:\/\/www.youtube.com\/c\/InigoQuilez\n\/\/ https:\/\/iquilezles.org\/\n\n\/\/ Unfortunatelly, too similar to Dave Hoskins' shader. \n\/\/ But it's one of my fav scenes from Wall-E, https:\/\/www.youtube.com\/watch?v=vkAjOPqTghg\n\/\/ (well, the shader is only vagely inspired in that sene really)\n\n\n\/\/ number of samples (for blurring)\n\/\/#define HIGH_QUALITY \n\n\n#ifdef HIGH_QUALITY\n  #define NS 8\n#else\n  #if HW_PERFORMANCE==0\n    #define NS 1\n  #else\n    #define NS 2\n  #endif\n#endif\n\n\n\/\/------------ primitives ------------\n\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdSphere( in vec3 p, in vec4 s )\n{\n    return length(p-s.xyz) - s.w;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 c, in vec3 r )\n{\n    p = p-c;\n    float k0 = length(p\/r);\n    float k1 = length(p\/(r*r));\n    return k0*(k0-1.0)\/k1;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\n\/\/------------ operators ------------\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)\/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)\/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\nvec2 minx( in vec2 a, in vec2 b )\n{\n    return (a.x<b.x)?a:b;\n}\n\n\/\/------------ maths ------------\n\nmat4 matRotate( in vec3 xyz )\n{\n    vec3 si = sin(xyz);\n    vec3 co = cos(xyz);\n\n\treturn mat4( co.y*co.z,                co.y*si.z,               -si.y,       0.0,\n                 si.x*si.y*co.z-co.x*si.z, si.x*si.y*si.z+co.x*co.z, si.x*co.y,  0.0,\n                 co.x*si.y*co.z+si.x*si.z, co.x*si.y*si.z-si.x*co.z, co.x*co.y,  0.0,\n\t\t\t     0.0,                      0.0,                      0.0,        1.0 );\n}\n\nmat4 matTranslate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\nmat4 matInverse( in mat4 m )\n{\n\treturn mat4(\n        m[0][0], m[1][0], m[2][0], 0.0,\n        m[0][1], m[1][1], m[2][1], 0.0,\n        m[0][2], m[1][2], m[2][2], 0.0,\n        -dot(m[0].xyz,m[3].xyz),\n        -dot(m[1].xyz,m[3].xyz),\n        -dot(m[2].xyz,m[3].xyz),\n        1.0 );\n}\n\n\/\/--------------------------------------------\n\nfloat hash( float n )\n{\n    return fract(sin(n)*1751.5453);\n}\n\n\/\/--------------------------------------------\n\n\nmat4 mtxHead;\n\nvec2 map( vec3 p )\n{\n    vec3 q = p; q.x = abs(q.x);\n    vec3 hp = (mtxHead*vec4(p,1.0)).xyz;\n\n    \/\/ body\n    p.yz = mat2(0.98,-0.2,0.2,0.98)*p.yz;\n    \n    float d1 = sdEllipsoid( p, vec3(0.0,0.15,0.0), vec3(0.41,0.83,0.41) );\n    float d2 = sdSphere( p, vec4(0.0,1.4,0.0,1.2) );\n    float d9 = sdCapsule( q, vec3(0.5,-0.6,0.02), vec3(0.45,0.07,-0.02), 0.15 );\n    float body = smax( d1, -d2, 0.03 );\n    body = smax( body, -d9, 0.01 );\n    \n    \n    \/\/ head\n    float d3 = sdSphere( hp, vec4(0.0,0.0,0.0,0.4) );\n    float d4 = sdSphere( hp, vec4(0.0,0.45,0.008,0.65) );\n    float head = smax( d3, d4, 0.05 );\n    \/\/ head hole    \n    float d5 = sdEllipsoid( hp, vec3(0.0,0.0,0.4), vec3(0.48,0.3,0.2) );\n    \/\/d5 = smax( d5, sdSphere( hp, vec4(0.0,0.34,0.2, 0.46 )), 0.07 );\n    d5 = smax( d5, sdSphere( hp, vec4(0.0,0.49,0.2, 0.6 )), 0.07 );\n    head = smax( head, -d5, 0.025 );\n    \n    \/\/ face\n    float d6 = sdSphere( hp, vec4(0.0,0.04,-0.05,0.41) );\n    float m2 = smax(d6,d5,0.01);\n\n    \/\/ arm\n    float d7 = sdEllipsoid( q, vec3(0.5,-0.15,0.0), vec3(0.1,0.35,0.1) );\n    float d8 = sdEllipsoid( q, vec3(0.54,-0.15,0.0), vec3(0.1,0.35,0.1) );\n\/\/    d8 = sdCapsule( q, vec3(0.6,-0.6,0.02), vec3(0.55,0.09,-0.02), 0.15 );\n    d7 = max( d7, d8 );\n    float arm = d7;\n\n    float m1 = min( min( body, head ), arm );\n                        \n    return minx( vec2(m1,0.0),\n                 vec2(m2,1.0) );\n}\n\nvec3 calcNormal( in vec3 pos, in float eps )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        \/\/float h = 0.01 + 0.22*float(i)\/7.0;\n        float h = 0.01 + 0.21*float(i)\/7.0;\n        occ += (h-map( pos + h*nor )).x;\n    }\n    return clamp( 1.0 - 5.8*occ\/8.0, 0.0, 1.0 );    \n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n    float t = 0.01;\n#ifdef HIGH_QUALITY\n    for( int i=0; i<64; i++ )\n#else\n    for( int i=0; i<16; i++ )\n#endif    \n    {\n        float h = map(ro + rd*t ).x;\n        res = min( res, smoothstep(0.0,1.0,k*h\/t) );\n#ifdef HIGH_QUALITY\n        t += clamp( h, 0.01, 0.025 );\n#else        \n        t += clamp( h, 0.04, 0.1 );\n#endif        \n\t\tif( res<0.01 ) break;\n    }\n    \n    return clamp(res,0.0,1.0);\n}\n\nconst vec3 sundir = normalize( vec3(1.0,0.3,-0.5) );\n\nvec3 shade( in vec3 ro, in vec3 rd, in float t, float m )\n{\n    float eps = 0.001;\n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormal( pos, eps );\n    vec3 ref = reflect( rd, nor );\n    \n    vec3 mate = vec3(1.0,1.0,1.0);\n    \n    if( m<0.5 )\n    {\n        mate = vec3(0.7);\n    }\n\telse\n    {\n        mate = vec3(0.0,0.0,0.0);\n        \n        vec2 uv = (mtxHead * vec4(pos,1.0)).xy;\n\n        uv.x = abs(uv.x);\n        uv -= vec2(0.11,0.565-0.5);\n        vec2 st  = uv;\n        uv = mat2(0.9,-0.4,0.4,0.9)*uv;\n        vec3 eye = vec3(0.02,0.2,0.9)*1.9;\n        eye *= 0.9 + 0.1*sin(512.0*st.x + sin(512.0*st.y));\n        \n        float eyesN = 1.0-smoothstep( 0.03, 0.06, length(uv * vec2(0.7,1.0)) );\n        float eyesB = 1.0-smoothstep( 0.00,0.008,abs(st.y));\n        float bl = smoothstep( 0.9,0.91, sin(10.0*iTime)*sin(3.0*iTime) );\n        float eyes = mix( eyesN, eyesB, bl );\n        mate = mix( mate, eye, eyes );\n        \n        mate += (0.01+mate)*0.9*smoothstep(-0.1,0.1,sin(st.y*400.0));\n    }\n    \n    vec3 hal = normalize( sundir - rd );\n    \n    float fre = clamp( 1.0 + dot(nor,rd), 0.0, 1.0 );\n    float occ = calcAO( pos, nor );\n\n    float bak = clamp( dot(nor,normalize(vec3(-sundir.x,0.0,-sundir.z))), 0.0, 1.0 );\n    float dif = clamp( dot(nor,sundir), 0.0, 1.0 );\n    float spe = clamp( dot(nor,hal), 0.0, 1.0 );\n    float sha = calcSoftshadow( pos, sundir, 8.0 ); \n    dif *= sha;\n\n    vec3 col = 1.4*vec3(1.0,0.9,0.8)*dif +  0.8*vec3(0.2,0.28,0.35)*occ;\n    col += vec3(1.2,1.0,0.8)*fre*(0.3+0.7*dif)*occ*3.5;\n    col += vec3(0.4,0.3,0.2)*bak*occ;\n    \n    col *= mate;\n    \n    col += 3.5*vec3(0.3,0.4,0.5) * smoothstep( -0.1, 0.1, ref.y ) * (0.04 + 0.96*pow( fre, 5.0 )) * occ;\n    col += 2.0*vec3(1.0)*pow( spe, 64.0 ) * (0.2 + 0.8*pow( fre, 5.0 )) * (occ*dif);\n    \n    col = pow( col, vec3(0.8,1.0,0.9) );\n\n    col *= mix( vec3(0.3,0.2,0.1), vec3(1.0), smoothstep(-1.0,0.4,pos.y) );\n    return col;        \n}\n\nvec2 intersect( in vec3 ro, in vec3 rd, const float maxdist )\n{\n    vec2 res = vec2(-1.0);\n    vec3 resP = vec3(0.0);\n    float t = 3.0;\n    for( int i=0; i<100; i++ )\n    {\n        vec3 p = ro + t*rd;\n        vec2 h = map( p );\n        res = vec2( t, h.y );\n\n        if( h.x<(0.001*t) || t>maxdist ) break;\n        \n        t += h.x;\/\/*0.5;\n    }\n\treturn res;\n}\n\n\/\/----------------------------------------------------------------------------------\nvec2 mapTerrain( vec3 p )\n{\n    float h = -2.5;\n    h -= 1.5*sin( 5.0 + 0.2*p.z);\n    h += 1.5*sin( 0.0 - 0.05*p.x - 0.05*p.z);\n    float g = h;\n    \n    h += 0.1*(textureLod( iChannel0, 0.1*p.xz, 0.0 ).x);\n\n    float d1 = 0.2*(p.y-h);\n        \n    vec2 res = vec2( d1, 1.0 );\n    \n    if( -p.z>11.0 )\n    {\n        float ss = 4.0;\n        vec3 q = p;\n        vec2 id = floor( (q.xz+0.5*ss)\/ss );\n        q.xz = mod( q.xz+0.5*ss, ss ) - 0.5*ss;\n\n\n        float r1 = hash(121.11*id.x+id.y*117.4);\n        float r2 = hash( 71.72*id.x+id.y* 61.9);\n        float r3 = hash( 31.74*id.x+id.y*317.1);\n        mat4 rm = matRotate( vec3(1.0*r1,313.13*r2,0.2) );\n\n        vec3 r = (rm*vec4(q,0.0)).xyz;\n        r.y -= g + 0.25;\n\n        float d2 = 0.8*udRoundBox( r, vec3(2.,0.01+0.2*r3,0.1+0.5*r3), 0.002 );\n        res.x = min( d1, d2 );\n    }\n        \n    return res;\n}\n\nvec3 calcNormalTerrain( in vec3 pos, in float eps )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*mapTerrain( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*mapTerrain( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*mapTerrain( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*mapTerrain( pos + e.xxx ).x );\n}\n\nfloat calcSoftshadowTerrain( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n    float t = 0.01;\n    for( int i=0; i<16; i++ )\n    {\n        float h = mapTerrain(ro + rd*t ).x;\n        res = min( res, smoothstep(0.0,1.0,k*h\/t) );\n        t += clamp( h, 0.04, 0.1 );\n\t\tif( res<0.01 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 shadeTerrain( in vec3 ro, in vec3 rd, in float t, float m )\n{\n    vec3 pos = ro + rd * t;\n    vec3 nor = calcNormalTerrain( pos, 0.01 );\n    vec3 hal = normalize( sundir - rd );\n    \n    vec3 col = texture( iChannel0, 0.01*pos.xz ).xyz*0.14 * vec3(1.1,1.0,0.9);\n\n    float dif = clamp( dot(sundir,nor), 0.0, 1.0 );\n    float spe = clamp( dot(nor,hal), 0.0, 1.0 );\n    float amb = clamp( 0.3 + 0.7*nor.y, 0.0, 1.0 );\n    \/\/dif *= calcSoftshadowTerrain( pos+nor*0.1, sundir, 32.0 );\n    vec3 lig = dif*vec3(3.0,2.0,1.5)*2.0 + pow(spe,8.0)*3.0*dif*4.0 + vec3(0.5,0.6,1.0)*amb;\n        \n    return col * lig;\n}\n    \nvec2 intersectTerrain( in vec3 ro, in vec3 rd, float maxdist )\n{\n    vec2 res = vec2(-1.0);\n    float t = 1.0;\n    \n    for( int i=0; i<256; i++ )\n    {\n        vec3 p = ro + t*rd;\n        vec2 h = mapTerrain( p );\n        res = vec2( t, h.y );\n        if( h.x<(0.001*t) || t>maxdist ) break;\n        t += h.x;\n    }\n    \n\treturn res;\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    \/\/ sky\n    vec3 col = mix( vec3(1.0,1.0,1.0), vec3(0.8,0.6,0.4), sqrt(max(rd.y,0.0)) );\n    float sun = clamp( dot(rd,sundir), 0.0, 1.0 );\n    col += 0.9*pow( sun, 64.0 );\n    \n    \/\/ terrain\n    float maxdistTerrain = 200.0;\n    float bp = (4.0-ro.y)\/rd.y; if( bp>0.0 && bp<maxdistTerrain ) maxdistTerrain = bp;\n    vec2 res = intersectTerrain( ro, rd, maxdistTerrain );\n    float t = res.x;\n    if( t < maxdistTerrain )\n    {\n        col = shadeTerrain( ro, rd, t, res.y );\n    }\n    \n    \/\/ eve\n    const float maxdist = 6.0;\n    res = intersect( ro, rd, maxdist );\n    if( res.x < maxdist )\n    {\n        t = res.x;\n        col = shade( ro, rd, t, res.y );\n    }\n\n    \/\/ fog\n    if( t<maxdistTerrain )\n    {\n        float f = exp(-0.03*t);\n        col *= f;\n        vec3 fcol = mix( vec3(1.0,0.9,0.9), vec3(1.1,0.8,0.4), exp(-0.01*t) );\n        col += (1.0-f)*fcol*0.8;    \n    }\n\n    col += 0.4*pow( sun, 20.0 );\n    \n    return pow( col, vec3(0.45) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n\n    float rt = mod( time, 15.0 );\n    float zo = step( 11.0, rt );\n    float zf = clamp( (rt-11.0)\/(15.0-11.0), 0.0, 1.0 );\n\n    float an1 = sin(0.5*time*1.0+0.4)*(1.0-zo);\n    float an2 = sin(0.5*time*1.3+0.0)*(1.0-zo);\n    float an3 = sin(2.0*time);\n    an1 = an1*an1*an1;\n    an2 = an2*an2*an2;\n    \n    mat4 hRot = matRotate( vec3(-0.2*an1*an1*an1 - 0.1*zo,-1.0*an2*an2*an2, 0.0) );\n    mat4 hTra = matTranslate( 0.0,0.5+0.015*an3-0.02*zo,0.11 );\n\n    mtxHead = matInverse( hTra * hRot );\n\n    vec2 q = fragCoord.xy\/iResolution.xy;\n\n    float an4 = 0.3 + 0.2*sin(0.04*time);\n    vec3 ro = vec3( -5.2*sin(an4), 0.0+0.05*zo, 5.2*cos(an4) );\n    \n    vec3 ta = vec3(0.0,0.2+0.3*zo,0.0);\n    ta += 0.02*cos( 1.0*time + vec3(0.0,2.0,3.0) )*(1.0-0.25*zo);\n    ro += 0.02*cos( 1.0*time + vec3(1.0,3.5,5.0) )*(1.0-0.25*zo);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    float fl = 1.5 * (2.2 + 2.5*zo*(1.0+0.25*zf));\n    \n    vec3 col = vec3(0.0);\n    for( int j=0; j<NS; j++ )\n    for( int i=0; i<NS; i++ )\n    {    \n        vec2 o = (1.0+abs(q.x-0.5)*8.0*iResolution.x\/850.0)*(vec2(float(i),float(j))\/float(NS)-0.5);\n        vec2 p = (-iResolution.xy+2.0*(fragCoord.xy+o))\/iResolution.y;\n\n        vec3 rd = normalize( ca * vec3(p,-fl) );\n        col += render( ro, rd );\n    }\n    col \/= float(NS*NS);\n    \n    \/\/ saturate\n    col = mix( col, vec3(dot(col,vec3(0.333))), -0.1 );\n\n    \/\/ vignette\n    col *= 0.2 + 0.8*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\n    \/\/ letterbox\n    col *= 1.0 - smoothstep( 0.4, 0.41, abs(q.y-0.5) );\n\n    \/\/ flicker\n    col *= 1.0 + 0.015*fract( 17.1*sin( 13.1*floor(12.0*iTime) ));\n    \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"tlcSRN","date":"1580495516","viewed":14234,"name":"ceva lejer","username":"alinres","description":"dsadas","likes":3,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord \/ iResolution.xy;\n    \n    \/\/ Calculate the to center distance\n    float d = length(uv - 0.5) * 2.0;\n    \n    \/\/ Calculate the ripple time\n    float t = d * d * 25.0 - iTime * 3.0;\n    \n    \/\/ Calculate the ripple thickness\n    d = (cos(t) * 0.5 + 0.5) * (1.0 - d);\n    \n    \/\/ Time varying pixel color\n    vec3 col = 0.5 + 0.5 * cos(t \/ 20.0 + uv.xyx + vec3(0.0,2.0,4.0));\n\n    \/\/ Set the output color to rgb channels and the thickness to alpha channel\n    \/\/ AO is automatically calculated\n    fragColor = vec4(col, d);\n}\n\n\/** SHADERDATA\n{\n\t\"title\": \"RD Design\",\n\t\"description\": \"We design for future\",\n\t\"model\": \"person\"\n}\n*\/","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"MsX3zr","date":"1360976009","viewed":14142,"name":"Cubes and Spheres","username":"PauloFalcao","description":"Raymarching a field of cubes that morph into spheres.\nUse mouse to change camera position.","likes":105,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[],"code":"\/\/ Cubes and Spheres by @paulofalcao\r\n\r\n\/\/Scene Start\r\n\r\nvec2 sim2d(\r\n  in vec2 p,\r\n  in float s)\r\n{\r\n   vec2 ret=p;\r\n   ret=p+s\/2.0;\r\n   ret=fract(ret\/s)*s-s\/2.0;\r\n   return ret;\r\n}\r\n\r\nvec3 stepspace(\r\n  in vec3 p,\r\n  in float s)\r\n{\r\n  return p-mod(p-s\/2.0,s);\r\n}\r\n\r\n\/\/Object\r\nfloat obj(in vec3 p)\r\n{ \r\n  vec3 fp=stepspace(p,2.0);;\r\n  float d=sin(fp.x*0.3+iTime*4.0)+cos(fp.z*0.3+iTime*2.0);\r\n  p.y=p.y+d;\r\n  p.xz=sim2d(p.xz,2.0);\r\n  \/\/c1 is IQ RoundBox from https:\/\/iquilezles.org\/articles\/distfunctions\r\n  float c1=length(max(abs(p)-vec3(0.6,0.6,0.6),0.0))-0.35;\r\n  \/\/c2 is a Sphere\r\n  float c2=length(p)-1.0;\r\n  float cf=sin(iTime)*0.5+0.5;\r\n  return mix(c1,c2,cf);\r\n}\r\n\r\n\/\/Object Color\r\nvec3 obj_c(vec3 p)\r\n{\r\n  vec2 fp=sim2d(p.xz-1.0,4.0);\r\n  if (fp.y>0.0) fp.x=-fp.x;\r\n  if (fp.x>0.0) return vec3(0.0,0.0,0.0);\r\n    else return vec3(1.0,1.0,1.0);   \r\n}\r\n\r\n\/\/Scene End\r\n\r\n\r\n\/\/Raymarching Framework Start\r\n\r\nfloat PI=3.14159265;\r\n\r\nvec3 phong(\r\n  in vec3 pt,\r\n  in vec3 prp,\r\n  in vec3 normal,\r\n  in vec3 light,\r\n  in vec3 color,\r\n  in float spec,\r\n  in vec3 ambLight)\r\n{\r\n   vec3 lightv=normalize(light-pt);\r\n   float diffuse=dot(normal,lightv);\r\n   vec3 refl=-reflect(lightv,normal);\r\n   vec3 viewv=normalize(prp-pt);\r\n   float specular=pow(max(dot(refl,viewv),0.0),spec);\r\n   return (max(diffuse,0.0)+ambLight)*color+specular;\r\n}\r\n\r\nfloat raymarching(\r\n  in vec3 prp,\r\n  in vec3 scp,\r\n  in int maxite,\r\n  in float precis,\r\n  in float startf,\r\n  in float maxd,\r\n  out int objfound)\r\n{ \r\n  const vec3 e=vec3(0.1,0,0.0);\r\n  float s=startf;\r\n  vec3 c,p,n;\r\n  float f=startf;\r\n  objfound=1;\r\n  for(int i=0;i<256;i++){\r\n    if (abs(s)<precis||f>maxd||i>maxite) break;\r\n    f+=s;\r\n    p=prp+scp*f;\r\n    s=obj(p);\r\n  }\r\n  if (f>maxd) objfound=-1;\r\n  return f;\r\n}\r\n\r\nvec3 camera(\r\n  in vec3 prp,\r\n  in vec3 vrp,\r\n  in vec3 vuv,\r\n  in float vpd,\r\n  in vec2 fragCoord)\r\n{\r\n  vec2 vPos=-1.0+2.0*fragCoord.xy\/iResolution.xy;\r\n  vec3 vpn=normalize(vrp-prp);\r\n  vec3 u=normalize(cross(vuv,vpn));\r\n  vec3 v=cross(vpn,u);\r\n  vec3 scrCoord=prp+vpn*vpd+vPos.x*u*iResolution.x\/iResolution.y+vPos.y*v;\r\n  return normalize(scrCoord-prp);\r\n}\r\n\r\nvec3 normal(in vec3 p)\r\n{\r\n  \/\/tetrahedron normal\r\n  const float n_er=0.01;\r\n  float v1=obj(vec3(p.x+n_er,p.y-n_er,p.z-n_er));\r\n  float v2=obj(vec3(p.x-n_er,p.y-n_er,p.z+n_er));\r\n  float v3=obj(vec3(p.x-n_er,p.y+n_er,p.z-n_er));\r\n  float v4=obj(vec3(p.x+n_er,p.y+n_er,p.z+n_er));\r\n  return normalize(vec3(v4+v1-v3-v2,v3+v4-v1-v2,v2+v4-v3-v1));\r\n}\r\n\r\nvec3 render(\r\n  in vec3 prp,\r\n  in vec3 scp,\r\n  in int maxite,\r\n  in float precis,\r\n  in float startf,\r\n  in float maxd,\r\n  in vec3 background,\r\n  in vec3 light,\r\n  in float spec,\r\n  in vec3 ambLight,\r\n  out vec3 n,\r\n  out vec3 p,\r\n  out float f,\r\n  out int objfound)\r\n{ \r\n  objfound=-1;\r\n  f=raymarching(prp,scp,maxite,precis,startf,maxd,objfound);\r\n  if (objfound>0){\r\n    p=prp+scp*f;\r\n    vec3 c=obj_c(p);\r\n    n=normal(p);\r\n    vec3 cf=phong(p,prp,n,light,c,spec,ambLight);\r\n    return vec3(cf);\r\n  }\r\n  f=maxd;\r\n  return vec3(background); \/\/background color\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\r\n \r\n  \/\/Camera animation\r\n  vec3 vuv=vec3(0,1,0);\r\n  vec3 vrp=vec3(iTime*4.0,0.0,0.0);\r\n  float mx=iMouse.x\/iResolution.x*PI*2.0;\r\n  float my=iMouse.y\/iResolution.y*PI\/2.01;\r\n  if ((iMouse.x<=0.0)||(iMouse.y<=0.0)){mx=1.0,my=0.5;};\/\/quick hack to detect no mouse input for thumbnail\r\n  vec3 prp=vrp+vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*12.0; \/\/Trackball style camera pos\r\n  float vpd=1.5;\r\n  vec3 light=prp+vec3(5.0,0,5.0);\r\n  \r\n  vec3 scp=camera(prp,vrp,vuv,vpd,fragCoord);\r\n  vec3 n,p;\r\n  float f;\r\n  int o;\r\n  const float maxe=0.01;\r\n  const float startf=0.1;\r\n  const vec3 backc=vec3(0.0,0.0,0.0);\r\n  const float spec=8.0;\r\n  const vec3 ambi=vec3(0.1,0.1,0.1);\r\n  \r\n  vec3 c1=render(prp,scp,256,maxe,startf,60.0,backc,light,spec,ambi,n,p,f,o);\r\n  c1=c1*max(1.0-f*.015,0.0);\r\n  vec3 c2=backc;\r\n  if (o>0){\r\n    scp=reflect(scp,n);\r\n    c2=render(p+scp*0.05,scp,32,maxe,startf,10.0,backc,light,spec,ambi,n,p,f,o);\r\n  }\r\n  c2=c2*max(1.0-f*.1,0.0);\r\n  fragColor=vec4(c1.xyz*0.75+c2.xyz*0.25,1.0);\r\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"Mdf3zM","date":"1365959156","viewed":14130,"name":"Escher's prentententoonstelling","username":"reinder","description":"I found this article: http:\/\/www.ams.org\/notices\/200304\/fea-escher.pdf describing the transformation used by Escher in the droste-picture: de prentententoonstelling (the picture gallery). The source is a mess atm - I will clean up later.","likes":136,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Escher's prentententoonstelling. Reinder Nijhoff 2013\n\/\/ Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n\/\/ @reindernijhoff\n\/\/\n\/\/ https:\/\/www.shadertoy.com\/view\/Mdf3zM\n\/\/\n\/\/ Study of the transformation of Escher in 'the prentententoonstelling' \n\/\/ ```\n\/\/ h(w) = w^((2\u03c0i + log scale)\/(2\u03c0i))\n\/\/ ```\n\/\/ Distance field functions by Inigo Quilez.\n\/\/\n\/\/ [1] http:\/\/www.ams.org\/notices\/200304\/fea-escher.pdf\n\/\/\n\n\/\/ #define SHADOW\n#define WOBBLE\n\nfloat t;\n\nfloat st = 0., zt = 0.;\n\nfloat deformationScale, zoom;\n\nvec2 escherDeformation( in vec2 uv ) {\n\t\n\/\/ http:\/\/www.ams.org\/notices\/200304\/fea-escher.pdf\n\/\/ h(w) = w^((2\u03c0i + log scale)\/(2\u03c0i))\n\t\n\tfloat lnr = log(length(uv));\n\tfloat th = atan( uv.y, uv.x )+(0.4\/256.)*deformationScale;\n\tfloat sn = -log(deformationScale)*(1.\/(2.*3.1415926));\n\tfloat l = exp( lnr - th*sn ); \n\t\n\tvec2 ret = vec2( l );\n\t\n\tret.x *= cos( sn*lnr+th );\n\tret.y *= sin( sn*lnr+th );\n\t\t\n\treturn ret;\n}\n\n#define drostescale 256.\n\nvec2 drosteTransformation( in vec2 uv ) {\n\tfor( int i=0; i<2; i++ ) {\n\t\tif(any(greaterThan(abs(uv),vec2(1.)))) {\n\t\t\tuv *= (1.\/drostescale);\n\t\t}\t\t\n\t\tif(all(lessThan(abs(uv),vec2(1.\/drostescale)))) {\n\t\t\tuv *= drostescale;\n\t\t}\n\t}\n\treturn uv;\n}\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat sdPlane( vec3 p ) {\n\treturn p.y+14.+0.05*cos(p.x+iTime*2.);\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat udBox( vec3 p, vec3 b) {\n  return length(max(abs(p)-b,0.0));\n}\nfloat sdTriPrism( vec3 p, vec2 h ) {\n    vec3 q = abs(p);\n    return max(q.x-h.y,max(q.z*0.4+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdCylinderXY( vec3 p, vec2 h ) {\n  return max( length(p.xy)-h.x, abs(p.z)-h.y );\n}\nfloat sdCylinderYZ( vec3 p, vec2 h ) {\n  return max( length(p.yz)-h.x, abs(p.x)-h.y );\n}\nfloat sdCylinderXZ( vec3 p, vec2 h ) {\n  return max( length(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n\n\/\/----------------------------------------------------------------------\n\nfloat opS( float d1, float d2 ) {\n    return max(-d2,d1);\n}\nfloat opU( float d1, float d2 ) {\n    return min(d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 ) {\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nfloat opI( float d1, float d2 ) {\n    return max(d1,d2);\n}\n\n\/\/----------------------------------------------------------------------\n\n\nfloat objPrentenTentoonstelling( in vec3 pos ) {\n\tvec3 tpos;\/\/ = pos;\n\ttpos.x = min( abs(pos.x), abs(pos.z) );\n\ttpos.y = pos.y;\n\ttpos.z = max( abs(pos.x), abs(pos.z) );\n\t\n\tfloat res = opU(opU(opU(opU(opU(\n\t\t\topS(opS(opS( \/\/ main building\n\t\t\t\topS(\n\t\t\t\t\tudBox( tpos, vec3( 5.5, 24.0, 5.5 ) ),\n\t\t\t\t\tsdBox( vec3(tpos.x, tpos.y-24.0, tpos.z), vec3( 5.25, 0.5, 5.25) ) \n\t\t\t\t),\n\t\t\t\tsdBox( vec3( mod(tpos.x+1.75, 3.5)-1.75, tpos.y-21.5, tpos.z-5.), vec3( 1.,1.,4.) )\n\t\t\t),\n\t\t\t\tsdBox( vec3( mod(tpos.x+1.75, 3.5)-1.75, tpos.y-15.5, tpos.z-5.), vec3( 1.,2.,4.) )\n\t\t\t),\n\t\t\t\tsdCylinderXY( vec3( mod(tpos.x+1.75, 3.5)-1.75, tpos.y-17.5, tpos.z-5.), vec2( 1.,4.) )\n\t\t\t),\n\t\t\topI( \/\/ main building windows\n\t\t\t\tudBox( tpos, vec3( 5.5, 23., 5.5 ) ),\n\t\t\t\topU(\n\t\t\t\t\tudBox(  vec3( mod(tpos.x+1.75, 3.5)-1.75, tpos.y, tpos.z-5.2), vec3( 0.05, 24., 0.05 ) ),\n\t\t\t\t\tudBox(  vec3( tpos.x, mod(tpos.y+0.425, 1.75)-0.875, tpos.z-5.2), vec3( 10.0, 0.05, 0.05 ) )\n\t\t\t\t)\n\t\t\t)\n\t\t),\n\t\topS( \/\/ gallery\n\t\t\topU(opU(opU(\t\t\n\t\t\t\topS(opS( \n\t\t\t\t\t\tudBox( tpos, vec3( 8.375, 8.75, 8.375 ) ),\n\t\t\t\t\t\tsdCylinderXY( vec3( mod(tpos.x, 2.75)-1.375, tpos.y-6.5, tpos.z-8.75), vec2( 1.25,2.75) )\n\t\t\t\t\t),\n\t\t\t\t\tsdBox( vec3(  mod(tpos.x, 2.75)-1.375, tpos.y-4.5, tpos.z-8.75), vec3( 1.25,2.0,2.75) )\t\t\t\n\t\t\t\t),\n\t\t\t\tudBox(  vec3( mod(tpos.x-8.375\/18., 8.375\/9.)-8.375\/18., tpos.y, tpos.z-8.3), vec3( 0.025, 8.5, 0.025 ) )\n\t\t\t),\n\t\t\t\tudBox(  vec3( tpos.x, tpos.y-4.3, tpos.z-8.3), vec3( 8.5, 0.025, 0.025 ) ) \n\t\t\t),\n\t\t\t\tudBox(  vec3( tpos.x, tpos.y-6.3, tpos.z-8.3), vec3( 8.5, 0.025, 0.025 ) ) \n\t\t\t),\n\t\t\topU(opU(opU(\n\t\t\t\tsdCylinderYZ( vec3( pos.x-8.75, pos.y-6.5, mod(pos.z, 13.75)-6.875), vec2( 1.25,20.) ),\n\t\t\t\tsdBox( vec3(  pos.x-8.75, pos.y-2.5, mod(pos.z,  13.75)-6.875), vec3( 20.,4.0,1.25) )\t\t\t\n\t\t\t),\n\t\t\t\tsdCylinderXY( vec3( mod(pos.x,13.75)-6.875, pos.y-6.5, pos.z-8.75), vec2( 1.25,20.) )\n\t\t\t),\n\t\t\t\tsdBox( vec3(  mod(pos.x, 13.75)-6.875, pos.y-2.5, pos.z-8.75), vec3( 1.25,4.0,20.) )\t\n\t\t\t)\n\t\t) ),\n\t\t\tsdTriPrism( vec3(tpos.x, tpos.y-9.3, tpos.z-5.2), vec2(2.0, 10. ) ) \/\/ roof\n\t\t),\n\t\t\tsdTriPrism( vec3(tpos.x, tpos.y-2.8, tpos.z-5.2), vec2(0.75, 8. ) )\n\t\t),\n\t\tudBox( tpos, vec3( 6.5, 2.5, 6.5 ) )\n\t);\n\t\n\treturn res;\n}\n\nfloat objB1( in vec3 pos ) {\n\tfloat res =\n\t\topU(opS(\t\t\t\n\t\t\topS(\n\t\t\t\tudBox( pos, vec3( 20., 30.0, 10. ) ),\t\t\t\t\n\t\t\t\tsdBox( pos+vec3(0., -30., 0.), vec3( 19.75, 1., 9.75 ) )\n\t\t\t),\n\t\t\tsdBox( vec3( mod(pos.x+1.75, 3.5)-1.75, mod(pos.y+3.5, 7.)-2., pos.z-10.), vec3( 1.,1.,4.) )\n\t\t),\n\t\t\topI( \/\/ main building windows\n\t\t\t\tudBox( pos, vec3( 18., 30.0, 10. ) ),\n\t\t\t\topU(\n\t\t\t\t\tudBox(  vec3( mod(pos.x+1.75, 3.5)-1.75, pos.y, pos.z-9.8), vec3( 0.05, 30., 0.05 ) ),\n\t\t\t\t\tudBox(  vec3( pos.x, mod(pos.y+0.425, 1.75)-0.875, pos.z-9.8), vec3( 50.0, 0.05, 0.05 ) )\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\treturn res;\t\n}\n\nfloat objB2( in vec3 pos ) {\n\tvec3 tpos;\/\/ = pos;\n\ttpos.x = min( abs(pos.x), abs(pos.z) );\n\ttpos.y = pos.y;\n\ttpos.z = max( abs(pos.x), abs(pos.z) );\n\t\n\tfloat res = opU(\n\t\t\topS(opS( \/\/ main building\n\t\t\t\topS(\n\t\t\t\t\tudBox( tpos, vec3( 8.75, 31.0, 8.75 ) ),\n\t\t\t\t\tsdBox( vec3(tpos.x, tpos.y-31.0, tpos.z), vec3( 8.5, 1.0, 8.5) ) \n\t\t\t\t\n\t\t\t),\n\t\t\t\tsdBox( vec3( mod(tpos.x+1.75, 3.5)-1.75, mod(tpos.y+4.5, 9.)-2.5, tpos.z-5.), vec3( 1.,2.,4.) )\n\t\t\t),\n\t\t\t\tsdCylinderXY( vec3( mod(tpos.x+1.75, 3.5)-1.75, mod(tpos.y+4.5, 9.)-4.5, tpos.z-5.), vec2( 1.,4.) )\n\t\t\t),\n\t\t\topI( \/\/ main building windows\n\t\t\t\tudBox( tpos, vec3( 8.75, 31.0, 8.75 ) ),\n\t\t\t\topU(\n\t\t\t\t\tudBox(  vec3( mod(tpos.x+1.75, 3.5)-1.75, tpos.y, tpos.z-8.45), vec3( 0.05, 31., 0.05 ) ),\n\t\t\t\t\tudBox(  vec3( tpos.x, mod(tpos.y+0.425, 1.75)-0.875, tpos.z-8.45), vec3( 10.0, 0.05, 0.05 ) )\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\treturn res;\t\n}\n\nvec2 map( in vec3 pos ) {\n    vec2 res = opU( vec2( sdPlane( pos), 3.0 ),\n\t                vec2( udBox( pos+vec3(0.0, 9.0, 85.0), vec3( 200., 10.0, 100. ) ), 1. ) );\n\n\tres = opU( res, vec2( udBox( pos+vec3(0.0, 20.0, 75.0), vec3( 200., 10.0, 100. ) ), 1. ) );\n \tres = opU( res, vec2( udBox( pos+vec3(0.0, 6.5, -15.0), vec3( 200., 10.0, 0.25 ) ), 1. ) );\n\n\tres = opU( res, vec2( udBox( pos+vec3( 220.0, 14.0, 0.0), vec3( 100., 10.0, 200. ) ), 1. ) );\n\t\t\n\tres = opU( res, vec2( udBox( (pos+vec3(3.20, -4.95, -5.55)), vec3( 0.55, 0.9, 0.01 ) ), 2. ) );\n\tres = opU( res, vec2( sdCylinderXZ( vec3(mod(pos.x+8., 16.)-8., pos.y+10., pos.z-24.), vec2( 0.4, 1.5)), 1.) );\n\n\tif( pos.z > 20. ) {\n\t\treturn res;\n\t}\n\t\n\tres = opU( res, vec2( objPrentenTentoonstelling( vec3(mod(pos.x+40.,80.)-40., pos.y, mod(pos.z+40.,80.)-40.) ), 1. ) );\n\t\n\tpos += vec3(3.25, -4.60, -5.55);\n\tres = opU( res, vec2( opI(\n\t\tudBox( vec3(mod(pos.x+0.8, 1.6)-0.8, pos.y, pos.z), vec3( 0.7, 0.9, 0.1 ) ),\n\t\tudBox( pos-vec3(3.25, -4.60, -5.55), vec3( 5.5, 5.5, 8.5 ) )\n\t\t), 4. ) );\n\tpos -= vec3(3.25, -4.60, -5.55);\n\t\n\tpos += vec3( 15.5, 8., 10.);\n\tres = opU( res, vec2( objB1( vec3(mod(pos.x+27.,54.)-27., pos.y, mod(pos.z+50.,100.)-50.) ), 1. ) );\n\tpos += vec3( 20.5, -8., 5.);\n\tres = opU( res, vec2( objB2( vec3(mod(pos.x+23.,46.)-23., pos.y, mod(pos.z+35.,70.)-35.) ), 1. ) );\n\tpos += vec3( 20., -10., 10.);\n\tres = opU( res, vec2( objB1( vec3(mod(pos.x+77.,144.)-77., pos.y, mod(pos.z+66.,132.)-66.) ), 1. ) );\n\t\t\n\treturn res;\n}\n\n\n\/\/ fast castfunctions to detect if droste picture is hit by ray\n\nfloat fastObjPrentenTentoonstelling( in vec3 pos ) {\n\treturn opU(\tudBox(  vec3( pos.x, pos.y-6.3, pos.z-8.3), vec3( 8.5, 0.025, 0.025 ) ),\n\t\t\t\tudBox(  vec3( mod(pos.x-8.375\/18., 8.375\/9.)-8.375\/18., pos.y, pos.z-8.3), vec3( 0.025, 8.5, 0.025 ) )\n\t);\n}\nvec2 fastMap( in vec3 pos ) {\n    return opU( vec2( fastObjPrentenTentoonstelling( pos), 1.0 ),\n\t            vec2( udBox( (pos+vec3(3.30, -4.55, -5.55)), vec3( 0.55, 0.7, 0.01 ) ), 2. ) );\n}\n\nvec2 fastCastRay( in vec3 ro, in vec3 rd, in float maxd )\n{\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float t = 0.0;\n    float m = -1.0;\n    for( int i=0; i<60; i++ )\n    {\n\t\tif( abs(h)<precis || t>maxd ) break;  {\n\t\t\tt += h;\n\t\t\tvec2 res = fastMap( ro+rd*t );\n\t\t\th = res.x;\n\t\t\tm = res.y;\n\t\t}\n    }\n\n    if( t>maxd ) m=-1.0;\n    return vec2( t, m );\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, in float maxd )\n{\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float t = 0.0;\n    float m = -1.0;\n    for( int i=0; i<60; i++ )\n    {\n\t\tif( abs(h)<precis || t>maxd ) break;  {\n\t\t\tt += h;\n\t\t\tvec2 res = map( ro+rd*t );\n\t\t\th = res.x;\n\t\t\tm = res.y;\n\t\t}\n    }\n\n    if( t>maxd ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k )\n{\n\tfloat res = 1.0;\n    float t = 0.1;\n    float ph = 0.0;\n    for( int i=0; i<32; i++ )\n    {\n\t\tif( t<maxt )\n\t\t{\n            float h = map( ro + rd*t ).x;\t\t\t\n                        \n            float y = h*h\/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, 10.0*d\/max(0.0,t-y) );\n            ph = h;\n            \n            t += 0.005+h;\n\t\t} \n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvoid getRoAndRd( in vec2 uv, out vec3 ro, out vec3 rd ) {\n#ifdef WOBBLE\n\tro = vec3( 20.2+(1.0+cos((t+42.)\/48.*2.*3.1415926))*cos(iTime), 36.0, 47.0  );\n#else\n\tro = vec3( 20.2, 36.0, 47.0  );\n#endif\t\n\tvec3 ta = vec3( -3.1, 4.8,  5.5 );\n\t\n\t\/\/ camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\trd = normalize( uv.x*cu + uv.y*cv + cw*zoom);\n}\n\nbool hitDrostePicture( vec2 uv ) {\n\tvec3 ro, rd;\n\tgetRoAndRd( uv, ro, rd );\t\n\t\n\tvec2 res = fastCastRay(ro,rd,200.0);\n\treturn (res.y == 2. );\n}\n\nvec4 trace( vec2 uv ) {\n\tvec3 ro, rd;\n\tgetRoAndRd( uv, ro, rd );\n\t\n    vec3 col = vec3(0.);\n\t\t\n    vec2 res = castRay(ro,rd,400.0);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n\n\t\tcol = vec3(0.7);\n\t\tif( m == 3. ) col = vec3(0.6,0.71,1.0);\n\t\tif( m == 4. ) col = vec3( 1. );\n\t\t\n\t\tif( m == 1. && all(lessThan(abs(pos), vec3( 5.65, 10., 5.65 ) ) ) ) {\n\t\t\tcol = vec3( 0.6 ); \/\/ inside gallery\n\t\t}\n\t\t\n\t\tvec3 lig = normalize( vec3(-0.4, 0.4, 0.8) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n\n\t\tfloat sh = 1.0;\n#ifdef SHADOW\t\t\n\t\tif( dif>0.05 ) { sh = softshadow( pos, lig, 0.1, 30.0, 5.0 ); dif *= (0.8+0.2*sh); }\n#endif\t\t\n\t\tvec3 brdf = vec3(0.0);\n\t\tbrdf += 0.80*amb*vec3(0.6,0.71,0.85);\n        brdf += 1.30*dif*vec3(1.00,0.90,0.70);\n\n\t\tcol = col*brdf;\n\t\t\n\t} else {\n\t\tcol = 1.2*vec3(0.6,0.71,0.85) - rd.y*0.2*vec3(1.0,0.5,1.0);\n\t}\n\n\treturn vec4( clamp(col,0.0,1.0), m );\n}\n\nvoid init() {\n\tt = mod( t+11., 48. );\n\n\tif( t < 8. ) st = t;\n\telse if( t < 24. ) st = 8.;\n\telse if( t < 32. ) st = 32.-t;\n\t\t\n\tt = mod( t+12., 48. );\n\t\t\n\tif( t < 8. ) zt = t;\n\telse if( t < 24. ) zt = 8.;\n\telse if( t < 32. ) zt = 32.-t;\n\t\t\n\tdeformationScale = clamp(pow(2.0,st), 1., 256.);\n\tzoom =  2.71828 * clamp(pow(2.0,zt), 1.0, 256. );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    t = mod(iTime, 48.);\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n\t\n\tuv = 2.*uv - vec2(1.);\n    uv.x *= iResolution.x\/ iResolution.y;\n\t\t\n\tinit();\n\t\n\tvec3 col = vec3(0.);\n\n\tbool band = abs(uv.x)>1.?true:false;\n\t\n\t\/\/ the  gallerymodel is a factor 1.\/0.7 too high to match Eschers painting, so I cheat :(\n\tuv.x *= 0.7;\n\tuv = escherDeformation(uv);\t\n\tuv = drosteTransformation(uv);\n\t\n\tif( hitDrostePicture(uv) ) uv*=256.;\n\tif( hitDrostePicture(uv) ) uv*=256.;\n\t\n\t\n\tvec4 tr = trace( uv );\n\tcol = tr.xyz;\n\t\n\tif( band ) {\n\t\tcol = mix( col, vec3(0.), st\/8. );\t\n\t}\t\t\n\t\n\tfragColor = vec4( col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"XdS3Rt","date":"1392023597","viewed":14130,"name":"Sphere - visibility","username":"iq","description":"Analytical sphere visibility. Can be used for occlusion culling!  White: spheres don't touch.   Yellow: spheres touch (partial occlusion).   Red: spheres completely occlude each other. I'm expecting the \"Yellow is gay\" joke.","likes":37,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ The MIT License\n\/\/ Copyright \u00a9 2014 Inigo Quilez\n\/\/ Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\/\/ https:\/\/www.youtube.com\/c\/InigoQuilez\n\/\/ https:\/\/iquilezles.org\/\n\n\n\/\/ Analytical sphere visibility, which can be used of occlusion\n\/\/ culling, based on this article I wrote in 2008:\n\/\/\n\/\/ https:\/\/iquilezles.org\/articles\/sphereocc\n\/\/\n\/\/ Related info: https:\/\/iquilezles.org\/articles\/spherefunctions\n\n\/\/-----------------------------------------------------------------\n\n\/\/ Return values:\n\/\/ 1: spheres don't overlap\n\/\/ 2: spheres overlap partially\n\/\/ 3: spheres overlap completely (one completelly occludes the other)\n\nint sphereVisibility( in vec3 ca, in float ra, in vec3 cb, float rb, in vec3 c )\n{\n    float aa = dot(ca-c,ca-c);\n    float bb = dot(cb-c,cb-c);\n    float ab = dot(ca-c,cb-c);\n    \n    float s = ab*ab + ra*ra*bb + rb*rb*aa - aa*bb; \n    float t = 2.0*ab*ra*rb;\n\n\t     if( s + t < 0.0 ) return 1;\n\telse if( s - t < 0.0 ) return 2;\n\t                       return 3;\n}\n\n\/\/-----------------------------------------------------------------\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\nfloat oSphere( in vec3 pos, in vec3 nor, in vec4 sph )\n{\n    vec3 di = sph.xyz - pos;\n    float l = length(di);\n    return 1.0 - max(0.0,dot(nor,di\/l))*sph.w*sph.w\/(l*l); \n}\n\n\/\/-----------------------------------------------------------------\n\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*43758.5453123); }\n\n\/\/-----------------------------------------------------------------\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float an = 0.6 - 0.5*iTime + 10.0*iMouse.x\/iResolution.x;\n    vec3 ro = vec3( 3.5*cos(an), 0.0, 3.5*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n\n    vec4 sph1 = vec4(-1.2,0.7,0.0,1.0);\n    vec4 sph2 = vec4( 1.2,0.0,0.0,1.0);\n    int vis = sphereVisibility( sph1.xyz, sph1.w, sph2.xyz, sph2.w, ro );\n\n            \n    vec3 tot = vec3(0.0);\n    for( int j=0; j<AA; j++ )\n    for( int i=0; i<AA; i++ )\n    {\n        vec2 off = vec2( float(i), float(j) ) \/ float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+off)) \/ iResolution.y;\n        \n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        float tmin = 10000.0;\n        vec3  nor = vec3(0.0);\n        float occ = 1.0;\n        vec3  pos = vec3(0.0);\n\n        float h = iSphere( ro, rd, sph1 );\n        if( h>0.0 && h<tmin ) \n        { \n            tmin = h; \n            pos = ro + h*rd;\n            nor = normalize(pos-sph1.xyz); \n            occ = oSphere( pos, nor, sph2 );\n            occ *= smoothstep(-0.6,-0.2,sin(20.0*(pos.x-sph1.x)));\n        }\n        h = iSphere( ro, rd, sph2 );\n        if( h>0.0 && h<tmin ) \n        { \n            tmin = h; \n            pos = ro + h*rd;\n            nor = normalize(pos-sph2.xyz); \n            occ = oSphere( pos, nor, sph1 );\n            occ *= smoothstep(-0.6,-0.2,sin(20.0*(pos.z-sph1.z)));\n        }\n\n        vec3 col = vec3(0.02)*clamp(1.0-0.5*length(p),0.0,1.0);\n        if( tmin<100.0 )\n        {\n            col = vec3(0.5);\n            if( vis==1 ) col = vec3(1.0,1.0,1.0);\n            if( vis==2 ) col = vec3(1.0,1.0,0.0);\n            if( vis==3 ) col = vec3(1.0,0.0,0.0);\n            col *= occ;\n            col *= 0.7 + 0.3*nor.y;\n            col *= exp(-0.5*max(0.0,tmin-2.0));\n        }\n\n        tot += pow( col, vec3(0.45) );\n        tot += (1.0\/255.0)*hash3(p.x+13.0*p.y);\n    }\n    tot \/= float(AA*AA);\n\n\tfragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}];    var gUseScreenshots = piIsMobile();
    var gThemeName = "classic";



    </script>
</head>

<!-- <body onload="resultsInit(12,null,null)"> -->
<body onload="resultsInitStatic(12,null,null)">

<!-- header =================================================================================== -->


<div id="header">

    <div id="headerBlock1">
        <a href="/" id="headerTitle">Shadertoy</a>
        <form name="formSearch" action="/results" method="get" style="display:inline-block;">
        <div  id="headerSearch">
            <input type="search" id="mySearch" name="query" placeholder="Search..." value=""/>
        </div>
        </form>
    </div>

    <div id="headerBlock2">
            <a class="headerLinks" href="/browse">Browse</a>
        <a class="headerLinks" href="/new">New</a>
        <a class="headerLinks" href="/signin">Sign In</a>
        </div>
</div>
<!-- content ================================================================================== -->

<div id="content">

  <div id="controls">
    <div>
      <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
      Sort:      </div>
      <div class="controlOptions"><div class="pageButtonsCurrent" href="/results?query=&sort=popular&filter=">Popular</div><a class="pageButtons" href="/results?query=&sort=newest&filter=">Newest</a><a class="pageButtons" href="/results?query=&sort=love&filter=">Love</a><a class="pageButtons" href="/results?query=&sort=hot&filter=">Hot</a></div>
    </div>

    <div id="controlFilter">
      <div style="display:flex;margin-right:8px;align-items:center;">Filter:</div>
      <div class="controlOptions"> <a class="pageButtons" href="/results?query=&sort=popular&filter=multipass">Multipass</a><a class="pageButtons" href="/results?query=&sort=popular&filter=soundoutput">GPU Sound</a><a class="pageButtons" href="/results?query=&sort=popular&filter=vr">VR</a><a class="pageButtons" href="/results?query=&sort=popular&filter=soundinput">Microphone</a><a class="pageButtons" href="/results?query=&sort=popular&filter=musicstream">Soundcloud</a><a class="pageButtons" href="/results?query=&sort=popular&filter=webcam">Webcam</a></div>
    </div>

    <div>
        <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
        View:</div>
        <div><a class="pageButtons" href="/slideshow?query=&sort=popular">Slideshow</a></div>
    </div>

    <div class="navigation" id="navTop" ><span style="padding-right:8px;">Results (74098):</span><div class="controlOptions"><a id="pageButtonFirst" class="pageButtons" href="results?query=&sort=popular&from=0&num=12">1</a><span>...</span><a id="pageButton"0 class="pageButtons" href="results?query=&sort=popular&from=432&num=12">37</a><a id="pageButton"1 class="pageButtons" href="results?query=&sort=popular&from=444&num=12">38</a><div id="pageButton"2 class="pageButtonsCurrent" href="results?query=&sort=popular&from=456&num=12">39</div><a id="pageButton"3 class="pageButtons" href="results?query=&sort=popular&from=468&num=12">40</a><a id="pageButton"4 class="pageButtons" href="results?query=&sort=popular&from=480&num=12">41</a><span>...</span><a id="pageButtonLast" class="pageButtons" href="results?query=&sort=popular&from=74088&num=12">6175</a></div>
</div>
  </div>


  <div id="shaderGrid">
    <div class='searchResult'><div class='searchResultContainer' id='Preview_0_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_0_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_0_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_0_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_0_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_0_Thumnail'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_0_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_0_Info'>  <span class='previewText'  id='Preview_0_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_0_TextUser'></span>  <span class='previewStats' id='Preview_0_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_1_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_1_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_1_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_1_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_1_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_1_Thumnail'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_1_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_1_Info'>  <span class='previewText'  id='Preview_1_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_1_TextUser'></span>  <span class='previewStats' id='Preview_1_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_2_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_2_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_2_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_2_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_2_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_2_Thumnail'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_2_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_2_Info'>  <span class='previewText'  id='Preview_2_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_2_TextUser'></span>  <span class='previewStats' id='Preview_2_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_3_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_3_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_3_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_3_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_3_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_3_Thumnail'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_3_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_3_Info'>  <span class='previewText'  id='Preview_3_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_3_TextUser'></span>  <span class='previewStats' id='Preview_3_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_4_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_4_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_4_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_4_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_4_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_4_Thumnail'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_4_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_4_Info'>  <span class='previewText'  id='Preview_4_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_4_TextUser'></span>  <span class='previewStats' id='Preview_4_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_5_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_5_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_5_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_5_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_5_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_5_Thumnail'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_5_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_5_Info'>  <span class='previewText'  id='Preview_5_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_5_TextUser'></span>  <span class='previewStats' id='Preview_5_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_6_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_6_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_6_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_6_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_6_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_6_Thumnail'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_6_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_6_Info'>  <span class='previewText'  id='Preview_6_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_6_TextUser'></span>  <span class='previewStats' id='Preview_6_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_7_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_7_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_7_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_7_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_7_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_7_Thumnail'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_7_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_7_Info'>  <span class='previewText'  id='Preview_7_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_7_TextUser'></span>  <span class='previewStats' id='Preview_7_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_8_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_8_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_8_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_8_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_8_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_8_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_8_Thumnail'>        <img class='previewThumbnailImage' id='Preview_8_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_8_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_8_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_8_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_8_Info'>  <span class='previewText'  id='Preview_8_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_8_TextUser'></span>  <span class='previewStats' id='Preview_8_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_9_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_9_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_9_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_9_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_9_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_9_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_9_Thumnail'>        <img class='previewThumbnailImage' id='Preview_9_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_9_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_9_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_9_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_9_Info'>  <span class='previewText'  id='Preview_9_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_9_TextUser'></span>  <span class='previewStats' id='Preview_9_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_10_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_10_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_10_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_10_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_10_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_10_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_10_Thumnail'>        <img class='previewThumbnailImage' id='Preview_10_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_10_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_10_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_10_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_10_Info'>  <span class='previewText'  id='Preview_10_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_10_TextUser'></span>  <span class='previewStats' id='Preview_10_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_11_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_11_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_11_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_11_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_11_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_11_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_11_Thumnail'>        <img class='previewThumbnailImage' id='Preview_11_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_11_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_11_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_11_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_11_Info'>  <span class='previewText'  id='Preview_11_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_11_TextUser'></span>  <span class='previewStats' id='Preview_11_Stats'></span></div></div>  </div>
  <br>
  <div class="navigation" id="navBottom" ><span style="padding-right:8px;">Results (74098):</span><div class="controlOptions"><a id="pageButtonFirst" class="pageButtons" href="results?query=&sort=popular&from=0&num=12">1</a><span>...</span><a id="pageButton"0 class="pageButtons" href="results?query=&sort=popular&from=432&num=12">37</a><a id="pageButton"1 class="pageButtons" href="results?query=&sort=popular&from=444&num=12">38</a><div id="pageButton"2 class="pageButtonsCurrent" href="results?query=&sort=popular&from=456&num=12">39</div><a id="pageButton"3 class="pageButtons" href="results?query=&sort=popular&from=468&num=12">40</a><a id="pageButton"4 class="pageButtons" href="results?query=&sort=popular&from=480&num=12">41</a><span>...</span><a id="pageButtonLast" class="pageButtons" href="results?query=&sort=popular&from=74088&num=12">6175</a></div>
</div>  <br>      
</div>

<!-- footer ================================================================================== -->

<div id="footer">
    
    <div><span style="color:#ffffff;">Community Forums</span>
      <ul>
      <li><a class="regular" href="/events">Official Events</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/147749602472741">In Facebook (english)</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/1339783682699494">In Facebook (korean)</a></li>
      <li><a class="regular" href="https://discord.gg/XtmMN6E">In Discord</a> (<a class="regular" href="https://discordapp.com/channels/578696555612209173/579531723348639754">direct link</a>)</li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Feedback and Support</span>
      <ul>
      <li><a class="regular" href="https://www.facebook.com/Shadertoy">Facebook</a></li>
      <li><a class="regular" href="https://twitter.com/shadertoy">Twitter</a></li>
      <li><a class="regular" href="https://www.patreon.com/shadertoy">Patreon</a></li>
      <li><a class="regular" href="https://trello.com/b/5hM0CjId">Roadmap</a></li>

      
      </ul>
    </div>

    <div><span style="color:#ffffff;">Shadertoy</span>
      <ul>
      <li><a class="regular" href="/store">Store</a></li>
      <li><a class="regular" href="/howto">Documentation</a></li>
      <li><a class="regular" href="/terms">Terms & Privacy</a></li>
      <li><a class="regular" href="/about">About</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Apps and Plugins</span>
      <ul>
      <li><a class="regular" href="https://itunes.apple.com/us/app/shadertoy/id717961814">Official iPhone App</a> by <a class="user" href="/user/reinder">Reinder</a></li>
      <li><a class="regular" href="https://steamcommunity.com/sharedfiles/filedetails/?id=1726697188">Screensaver</a> by <a class="user" href="/user/kosro">Kosro</a></li>
      <li><a class="regular" href="https://chrome.google.com/webstore/detail/shadertoy-unofficial-plug/ohicbclhdmkhoabobgppffepcopomhgl">Shadertoy plugin</a> by <a class="user" href="/user/patu">Patu</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Tutorials</span>
      <ul>
      <li><a class="regular" href="https://www.youtube.com/watch?v=0ifChJ0nJfM">Shader coding intro</a> by <a class="user" href="/user/iq">iq</a></li>
      <li><a class="regular" href="https://shadertoyunofficial.wordpress.com/">Shadertoy Unofficial</a> by <a class="user" href="/user/FabriceNeyret2">FabriceNeyret2</a></li>
      </ul>
    </div>

</div>

<div id="compliance" style="padding-bottom:6px;visibility:hidden;left:0;top:0px;width:100%;background-color:rgb(200,120,20,0.93);position:absolute;color:#FFFFFF">
    <div style="text-align: center; margin-top:8px">
        We use cookies to give you the best experience on our website. If you continue using Shadertoy, we'll assume that you are happy to receive all cookies on this website. 
        For more information, please review our <a class="regular" href="/terms">Terms & Privacy</a>.
    </div> 
    <div style="text-align: center;margin-top:6px">
        <button type="button" style="width:100px;font-size:inherit" onclick="acceptCompliance()">Accept</button>
    </div>
</div>

<script>
(function runCompliance() 
{
    let showCompliance = 1;
    let allcookies = document.cookie;
    let cookiearray = allcookies.split(';');
    for (var i=0; i<cookiearray.length; i++)
    {
        let name  = cookiearray[i].split('=')[0];
        let value = cookiearray[i].split('=')[1];
        if (name.trim() == "scmp") 
        {
            showCompliance = value;
            break;
        }
    }

    if (showCompliance === 1) 
    {
        var ve = document.getElementById("compliance");
        ve.style.visibility="visible";
    }
})();

function acceptCompliance()
{
    let now = new Date();
    now.setTime( now.getTime() + (5*365*24*60*60*1000) );
    document.cookie="scmp=0;expires=" + now.toUTCString() + ";";

    var ve = document.getElementById("compliance");
    ve.style.visibility="hidden";
}
</script>

</body>
</html>
