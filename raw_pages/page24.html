<!DOCTYPE HTML>
<html lang="en">
<head>

    
<script async src="https://www.googletagmanager.com/gtag/js?id=G-7SYLWGZYJ2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-7SYLWGZYJ2');
</script>

<title>Browse (25) - Shadertoy BETA</title>
<meta charset="utf-8" />
<meta name="Keywords" content="shadertoy, shader toy, quilez, inigo, jeremias, pol, fractals, demoscene, computer graphics, mathematics, rendering, demo, 3D, realtime, shader, raytracing, raymarching, webgl, glsl" />
<meta name="Description" content="Build shaders, share them, and learn from the best community." />
<meta name="Author" content="Beautypi" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<link rel="image_src" href="https://www.shadertoy.com/img/logo.png" />
<link rel="apple-touch-icon" href="/img/launch_icon_57.png"/>
<link rel="apple-touch-icon" sizes="72x72" href="/img/launch_icon_72.png"/>
<link rel="apple-touch-icon" sizes="114x114" href="/img/launch_icon_114.png"/>
<link rel="shortcut icon" href="/img/favicon.ico"/>

<style>::-webkit-scrollbar {
    height: 8px;
    width: 8px;
    background: #404040;
}

::-webkit-scrollbar-thumb
{
    background: #909090;
    border-radius: 0ex;
}

::-webkit-scrollbar-corner
{
    background: #000;
}

::-webkit-input-placeholder
{
	font-style:italic;
}
input:-moz-placeholder, textarea:-moz-placeholder
{
	font-style:italic;
}
input.placeholder-text, textarea.placeholder-text
{
	font-style:italic;
}

pre 
{
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
    white-space: -pre-wrap;
    white-space: -o-pre-wrap;
    word-wrap: break-word;
}

@font-face
{
    font-family: Lobster;
    src: url("/img/lobster.otf") format("opentype");
}

div#centerScreen
{
    left: 50%;
    top: 50%;
    position: absolute;
}

a.headerLinks:hover
{
    background-color:#505050;
    color : #ff8020;
}

body
{
    color: #000000;
    font-size:12px;
    font-style:normal;
    font-family:Tahoma,Arial;
    background-repeat: no-repeat;
    //background-attachment: fixed;
    padding:0px;
    margin:0px;
    text-align: left;
    background-color: #d0d0d0;
    background-repeat: repeat;
    user-select: text;
}

a,
a:hover,
a:visited
{
  color : inherit;
}

div#content {
    width: 95%;
    overflow: hidden;
    margin: auto;
    padding: 0px;
    min-height: calc(100vh - 80px);
    //box-sizing: border-box;
}


.notificationCount
{
 background-color:#ff0000;
 padding-left:3px;
 padding-right:1px;
 padding-top:1px;
 padding-bottom:1px;
}

div#header
{
    background-color: #404040;
    top: 0px;
    left: 0px;
    width: 100%;
    padding: 0;
    margin: 0;
    color: #ffffff;
    display: flex;
    flex-direction:row;
}

#headerBlock1
{
    width: 50%;
    display:flex;
    align-items:center;
}

a#headerTitle
{
    font-size: 2.25em;
    font-family: Lobster,Tahoma,Arial;
    text-decoration: none;
    padding-left:32px;
    padding-right:32px;
}

#headerSearch
{
    display: inline-block;
    color: #000000;
    width: 300px;
}

input[type=search]#mySearch
{
    width: 100%;
    border-radius: 6px;
    border: 1px solid black;
    padding:12px;
}

#headerBlock2
{
    width: 50%;
    margin-left: auto;
    display: flex;
    justify-content: flex-end;
}


a#headerTitle:hover
{
    color : #ff8020;
}

a.headerLinks
{
    font-weight: bold;
    padding-top: 14px;
    padding-bottom: 14px;
    padding-left: 14px;
    padding-right: 14px;
    margin:0px;
    text-decoration: none;
    transition: background-color 0.15s linear, color 0.15s linear;
}

#footer
{
    background-color: rgba(64,64,64,0.25);
    color: #000000;
    padding: 0px;
    margin: 0px;
    width: 100%;
    display: flex;
    justify-content: space-between;
    flex-wrap: wrap;
}

#footer div
{
    padding-top:10px;
    padding-bottom:0px;
    padding-left:16px;
    padding-right:16px;
}

#footer div ul
{
    margin-left:0px;
    padding-left:16px;
}

#footer div ul li
{
    padding-top:6px;
}

a.regular
{
    font-weight:bold;
    text-decoration:none
}

a.regular:hover
{
  color : #ff8020;
}

a.user
{
    font-weight:bold;
    text-decoration:none;
}

a.user:hover
{
  color : #ff8020;
  text-decoration: underline;
}

.uiButton
{
    border: none;
    outline: none;
    margin: 0px;
    padding: 0px;
    width: 22px;
    height: 22px;
    position: absolute;
    cursor: pointer;
    border-radius: 4px;
}

.uiButton:hover
{
    box-shadow: inset 0px 0px 1px 1px #808080, 0px 0px 1px 1px #808080;
}

.uiDivBUtton
{
    cursor:pointer;
}

.uiDivBUtton:hover
{
    color: #ffffff;
}


.dialog
{
    display: block;
    background-color: #e0e0e0;
    color: #000000;
    border:1px solid #000;
    padding:0px;
    margin:0px;
    text-align:left;
    border-radius: 4px;
    box-shadow:4px 4px 6px 0px rgba(0,0,0,0.5);
    overflow: hidden;
    z-index:1000;
    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;
}

.dialogHeader
{
    left:0px;
    top: 0px;
    width:100%;
    height:32px;
    position: absolute;
    background-color: #808080;
    cursor:move;
}

.dialogTitle
{
    left: 12px;
    top: 4px;
    position: absolute;
    padding: 0px;
    margin: 0px;
    color:#000000;
    font-size:1.5em;
    text-align: left;
    user-select: none;
    -moz-user-select: -moz-none;
    -webkit-user-select: none;
}

.dialogOverlay
{
    z-index:1000;

    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;

    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    width:100%;
    height:100%;
    position:absolute;

    background-color:rgba(0,0,0,.4);
}

.viewsIcon, .likesIcon
{
    border: none;
    outline: none;
    display:inline-block;
    background-repeat:no-repeat;
    top:0px;
    left:0px;
    padding:0px;
    padding-right: 2px;
    margin:0px;
    position:relative;
}

.userPictureSmall
{
    background-color:#808080;
    border: 1px solid #000000;
    width:32px;
    height:32px;
}

.dialogCloseButton
{
    right:8px;
    top: 4px;
    width:22px;
    height:22px;
    position: absolute;
    background-image: url("/img/close.png");
    cursor: pointer;
    border-radius: 4px;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContentButtons
{
     padding:0;
     border:0;
     text-align: justify;
     left: 24px;
     bottom:40px;
     position:absolute;
}

.dialogButton
{
    text-align: center;
    vertical-align: middle;
    display: inline-block;
    border-radius: 4px;
    font-weight: bold;
    cursor: pointer;
    padding-bottom:5px;
    padding-top:4px;
    padding-left: 8px;
    padding-right: 8px;
    margin-left:4px;
    margin-right:4px;
    text-decoration: none;
    color:#000000;
    width: 80px;
    -moz-transition:    background-color 0.15s linear, color 0.15s linear;
    -webkit-transition: background-color 0.15s linear, color 0.15s linear;
    transition:         background-color 0.15s linear, color 0.15s linear;
}

.dialogButton:hover
{
  background-color:#808080;
  color : #ff8020;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContent
{
    color: inherit;
    overflow: auto;
    width:100%;
    height:100%;
    left: 0px;
    top: 32px;
    position:absolute
}

.dialogContentBody
{
    color: inherit;
    width:100%;
    height:auto;
    padding-top:24px;
    padding-bottom:24px;
    padding-left:24px;
    padding-right:24px;
    text-align: left;
}

.formButton
{
    font-weight:bold;
	color:#ffffff;
	border:none;
    text-align:center;
	background-color:#808080;
    border-radius: 4px;
	padding-left:8px;
	padding-right:8px;
	padding-top:4px;
	padding-bottom:4px;
    cursor:pointer;
    min-width:80px;
    box-sizing: border-box;
}
.formInput {
    border-radius: 6px;
    border: 1px solid black;
    padding: 4px;
    border: none;
}
.formButton:hover {
    background-color: #e0e0e0;
}
.formButton:disabled
{
	color:#b0b0b0;
	background-color:#808080;
}

.formButtonSmall
{
    color:#ffffff;
    border:none;
    text-align:center;
    background-color:#808080;
    border-radius: 4px;
    padding-left:2px;
    padding-right:2px;
    padding-top:2px;
    padding-bottom:2px;
    cursor:pointer;
    min-width:40px;
}

.formButtonSmall:hover
{
    background-color: #e0e0e0;
}

.formButtonSmall:disabled
{
    color:#b0b0b0;
    background-color:#808080;
}

.formButtonSmall.disabled2,
.formButton.disabled2 { color:#b0b0b0; background-color:#808080; pointer-events: none; }

.inputForm
{
    padding-left:2%;
    padding-right:2%;
    resize: none;
    text-align: left;
    background-color:#e0e0e0;
    outline: none;
    border-radius: 4px;
    border: 1px solid #808080;
    color:inherit;
    box-sizing: border-box;
}

.inputForm:focus
{
    border: 1px solid #AFCDD8;
    background-color: #EBF2F4;
}

.transparentPannel
{
    background-color:rgba(64,64,64,0.1);
    padding:16px;
}

.comment, .commentSelf, .commentNew
{
    border-radius: 4px;
    width: 100%;
    margin-left: 0px;
    margin-right: 0px;
    margin-top: 0px;
    margin-bottom: 6px;

    padding: 14px;
    box-sizing: border-box;
    display: grid;
    grid-template-columns: 32px auto 8px;
    grid-template-rows: 1fr;
    grid-gap:8px;
}

.comment:nth-child(even)
{
    background-color: rgba(64,64,64,0.1);
}

.comment:nth-child(odd)
{
    background-color: rgba(128,128,128,0.1);
}

.commentSelf
{
    background-color: rgba(240,160,64,0.1);
}

.commentNew
{
    padding-right: 0px;
    grid-template-columns: 40px auto;
}

.commentContent
{
    vertical-align: top;
    text-align: left;
    word-break: break-all;
    word-break: break-word;
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
}


/* ----------------------- media resolutions ------------------------ */

@media screen and (max-width:799px)
{
    div#header {flex-direction:column; }
    #headerBlock1 { width:100%; }
    #headerBlock2 { width:100%; justify-content: space-around;}
    div#headerSearch {width:200px;}
    input#mySearch { width:200px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:10px; }
}

@media screen and (min-width:800px) and (max-width:1279px)
{
    body { font-size: 9px; }
    div#headerSearch {width: 250px;}
    input#mySearch { width:250px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:11px; }
}

@media screen and (min-width:1280px) and (max-width:1439px)
{
    body { font-size: 10px; }
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1440px) and (max-width:1919px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1920px) and (max-width:2559px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}

@media screen and (min-width:2560px) 
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}
body
{
    background-image: url("/img/themes/classic/background.jpg");
}
</style>

    <script>"use strict"

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piCamera
//
//==============================================================================

function piCamera()
{
    var mMatrix = setIdentity();
    var mMatrixInv = setIdentity();

    var mPosition = [0.0,0.0,0.0];
    var mXRotation = 0.0;
    var mYRotation = 0.0;

    var mPositionTarget = [0.0,0.0,0.0];
    var mXRotationTarget = 0.0;
    var mYRotationTarget = 0.0;

    var me = {};
/*
    me.Set = function( pos, dir, roll) 
             {
                 mMatrix    = setLookat( pos, add(pos,dir), [Math.sin(roll),Math.cos(roll),Math.sin(roll)] );
                 mMatrixInv = invertFast( mMatrix );
             };
*/
    me.SetPos = function(pos)
                {
                    mPosition = pos;
                    //mMatrix[ 3] = -(mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                    //mMatrix[ 7] = -(mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                    //mMatrix[11] = -(mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                };
/*
    me.GlobalMove = function(pos)
                    {
                        mMatrix[ 3] -= (mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                        mMatrix[ 7] -= (mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                        mMatrix[11] -= (mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                        mMatrixInv = invertFast(mMatrix);
                    };
*/
    me.LocalMove = function( dis )
                    {
                        dis = matMulvec( setRotationY(-mYRotation), dis);
                        mPositionTarget = sub(mPositionTarget,dis)
                    };

    me.RotateXY = function( x, y)
                  {
                    mXRotationTarget -= x;
                    mYRotationTarget -= y;
                    mXRotationTarget = Math.min( Math.max( mXRotationTarget, -Math.PI/2), Math.PI/2 );
                  };


    me.CameraExectue = function( dt )
    {
        // smooth position
        mXRotation += (mXRotationTarget-mXRotation) * 12.0*dt;
        mYRotation += (mYRotationTarget-mYRotation) * 12.0*dt;
        mPosition = add(mPosition, mul( sub(mPositionTarget, mPosition), 12.0*dt));

        // Make Camera matrix
        mMatrix = matMul( matMul(setRotationX(mXRotation), 
                                 setRotationY(mYRotation)),  
                                 setTranslation(mPosition));
        mMatrixInv = invertFast(mMatrix);

    }

    me.GetMatrix = function() { return mMatrix; };
    me.GetMatrixInverse = function() { return mMatrixInv; };
    me.SetMatrix = function( mat ) 
                    {
                        mMatrix = mat;
                        mMatrixInv = invertFast(mMatrix);

                        mPosition = getXYZ(matMulpoint(mat, [0.0,0.0,0.0]));
                        mPositionTarget = mPosition;
                    };

    me.GetPos = function() { return getXYZ(matMulpoint(mMatrixInv, [0.0,0.0,0.0])); }
    me.GetDir = function() { return getXYZ(normalize(matMulvec(mMatrixInv, [0.0,0.0,-1.0]))); }

    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piFile
//
//==============================================================================

function piFile( binaryDataArrayBuffer )
{
    // private
    //var mDataView = new DataView( binaryDataArrayBuffer, 0 );
    var mDataView = binaryDataArrayBuffer;
    var mOffset = 0;

    // public members
    var me = {};
    me.mDummy = 0;
/*
    // public functions
    me.Seek = function( off ) { mOffset = off - 3; };
    me.ReadUInt16 = function()  { var res = mDataView.getUint16( mOffset ); mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = mDataView.getUint32( mOffset ); mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = mDataView.getFloat32( mOffset ); mOffset+=4; return res; };
*/

    me.Seek = function( off ) { mOffset = off; };
    me.ReadUInt8  = function()  { var res = (new Uint8Array(mDataView,mOffset))[0]; mOffset+=1; return res; };
    me.ReadUInt16 = function()  { var res = (new Uint16Array(mDataView,mOffset))[0]; mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = (new Uint32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = (new Float32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadFloat32Array = function(n) 
                          { 
                              var src = new Float32Array(mDataView, mOffset);
                              var res = [];  for( var i=0; i<n; i++ ) { res[i] = src[i]; }
                              mOffset += 4*n;
                              return res;
                          };
    me.ReadFloat32ArrayNative = function(n) { var src = new Float32Array(mDataView, mOffset); mOffset += 4*n; return src; };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piMesh
//
//==============================================================================

function piMesh()
{
    this.mChunks = [];
    this.mPrimitiveType = 0;
    this.mVertexFormat = null;
}

/*
piMesh.prototype.normalize = function( ppos, npos )
{
    var numv = this.mVertexData.length;
    var numt = this.mIndices.length;

    for( var i=0; i<numv; i++ )
    {
        //float *v = (float*)piMesh_GetVertexData( me, i, npos );
        //v[0] = 0.0f;
        //v[1] = 0.0f;
        //v[2] = 0.0f;
        this.mVerts[8 * i + 3] = 0.0;
        this.mVerts[8 * i + 4] = 0.0;
        this.mVerts[8 * i + 5] = 0.0;
    }

    for( var i=0; i<numt; i++ )
    {
        piMeshFace *face = me->mFaceData.mIndexArray[0].mBuffer + i;

        const int ft = face->mNum;
        
        vec3 nor = vec3( 0.0f, 0.0f, 0.0f );
        for( int j=0; j<ft; j++ )
        {
            const vec3 va = *((vec3*)piMesh_GetVertexData( me, face->mIndex[ j      ], ppos ));
            const vec3 vb = *((vec3*)piMesh_GetVertexData( me, face->mIndex[(j+1)%ft], ppos ));

            nor += cross( va, vb );
        }

        for( int j=0; j<ft; j++ )
        {
            vec3 *n = (vec3*)piMesh_GetVertexData( me, face->mIndex[j], npos );
            n->x += nor.x;
            n->y += nor.y;
            n->z += nor.z;
        }
    }

    for( var i=0; i<numv; i++ )
    {
        vec3 *v = (vec3*)piMesh_GetVertexData( me, i, npos );
        *v = normalize( *v );
    }
}
*/

piMesh.prototype.createCube = function(renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([ -1.0, -1.0, -1.0,
                                       1.0, -1.0, -1.0,
                                      -1.0,  1.0, -1.0,
                                       1.0,  1.0, -1.0,
                                      -1.0, -1.0,  1.0,
                                       1.0, -1.0,  1.0,
                                      -1.0,  1.0,  1.0,
                                       1.0,  1.0,  1.0 ]),

                        mIndices : new Uint16Array([ 0, 2, 1,   1, 2, 3,   5, 1, 3,   5, 3, 7,   4, 5, 7,   4, 7, 6,   4, 6, 2,   4, 2, 0,   6, 7, 3,   6, 3, 2,   4, 0, 1,   4, 1, 5 ]),
                        mNumVertices : 8,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };

    this.mVertexFormat = { mStride:12, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}

piMesh.prototype.createCubeSharp = function (renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 1.0,
                                    -1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 0.0,

                                     1.0, 1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 0.0,

                                     1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 1.0,
                                    -1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   1.0, 1.0,
                                     1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   1.0, 0.0,

                                    -1.0, 1.0, 1.0,  -1.0, 0.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0,-1.0,  -1.0, 0.0, 0.0,   0.0, 1.0,
                                    -1.0,-1.0,-1.0,  -1.0, 0.0, 0.0,   1.0, 1.0,
                                    -1.0,-1.0, 1.0,  -1.0, 0.0, 0.0,   1.0, 0.0 ]),

                        mIndices : new Uint16Array([0,1,2, 0,2,3,   4,5,6, 4,6,7,    8,9,10,8,10,11,   12,13,14,12,14,15,   16,17,18,16,18,19,   20,21,22,20,22,23]),
                        mNumVertices : 24,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };


    this.mVertexFormat = { mStride:32, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}


piMesh.prototype.createUnitQuad = function (renderer)
{
    this.mPrimitiveType = 0;
    this.mVertexFormat = { mStride:8, mChannels: [ {mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false} ] };

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0,  1.0, 1.0,  1.0]),
                        mIndices : new Uint16Array([0, 2, 1, 1, 2, 3]),
                        mNumVertices : 4,
                        mNumFaces : 2, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };
 
    return true;
}




piMesh.prototype.destroy = function()
{
    //delete this.mVerts;   this.mVerts = null;
    //delete this.mIndices; this.mIndices = null;
}

piMesh.prototype.scale = function (x, y, z)
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] *= x;
            this.mChunks[j].mVerts[stride * i + 1] *= y;
            this.mChunks[j].mVerts[stride * i + 2] *= z;
        }
    }
}

piMesh.prototype.translate = function (x, y, z) 
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] += x;
            this.mChunks[j].mVerts[stride * i + 1] += y;
            this.mChunks[j].mVerts[stride * i + 2] += z;
        }
    }
}

piMesh.prototype.GPULoad = function (renderer)
{
    for( var i=0; i<this.mChunks.length; i++ )
    {
        var vbo = renderer.CreateVertexArray(this.mChunks[i].mVerts, renderer.BUFTYPE.STATIC );
        if (vbo == null)
            return false;

        var ibo = renderer.CreateIndexArray(this.mChunks[i].mIndices, renderer.BUFTYPE.STATIC);
        if (ibo == null)
            return false;

        this.mChunks[i].mVBO = vbo;
        this.mChunks[i].mIBO = ibo;
    }
    return true;
}

piMesh.prototype.GPURender = function (renderer, positions )//, matPrj, matCam )
{
    //renderer.SetShaderConstantMat4F("unMPrj", matPrj, false );

    var num = this.mChunks.length;
    for( var i=0; i<num; i++ )
    {
        //var mat =  matMul( matCam, this.mChunks[i].mTransform );
        //renderer.SetShaderConstantMat4F("unMMod", mat, false);

        renderer.AttachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat, positions );
        renderer.AttachIndexArray(this.mChunks[i].mIBO );
        renderer.DrawPrimitive(renderer.PRIMTYPE.TRIANGLES, this.mChunks[i].mNumFaces * 3, true, 1);
        renderer.DetachIndexArray(this.mChunks[i].mIBO);
        renderer.DetachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat );
    }
}
//==============================================================================
//
// piLibs 2014-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piRenderer
//
//==============================================================================

function piRenderer()
{
    // private members

    var mGL = null;
    var mBindedShader = null;
    var mIs20 = false;
    var mFloat32Textures;
    var mFloat32Filter;
    var mFloat16Textures;
    var mDrawBuffers;
    var mDepthTextures;
    var mDerivatives;
    var mFloat16Filter;
    var mShaderTextureLOD;
    var mAnisotropic;
    var mRenderToFloat32F;
    var mDebugShader;
    var mAsynchCompile;

    var mVBO_Quad = null;
    var mVBO_Tri = null;
    var mVBO_CubePosNor = null;
    var mVBO_CubePos = null;
    var mShaderHeader = ["",""];
    var mShaderHeaderLines = [0,0];

    // public members
    var me = {};

    me.CLEAR      = { Color: 1, Zbuffer : 2, Stencil : 4 };
    me.TEXFMT     = { C4I8 : 0, C1I8 : 1, C1F16 : 2, C4F16 : 3, C1F32 : 4, C4F32 : 5, Z16 : 6, Z24 : 7, Z32 : 8, C3F32:9 };
    me.TEXWRP     = { CLAMP : 0, REPEAT : 1 };
    me.BUFTYPE    = { STATIC : 0, DYNAMIC : 1 };
    me.PRIMTYPE   = { POINTS : 0, LINES : 1, LINE_LOOP : 2, LINE_STRIP : 3, TRIANGLES : 4, TRIANGLE_STRIP : 5 };
    me.RENDSTGATE = { WIREFRAME : 0, FRONT_FACE : 1, CULL_FACE : 2, DEPTH_TEST : 3, ALPHA_TO_COVERAGE : 4 };
    me.TEXTYPE    = { T2D : 0, T3D : 1, CUBEMAP : 2 };
    me.FILTER     = { NONE : 0, LINEAR : 1, MIPMAP : 2, NONE_MIPMAP : 3 };
    me.TYPE       = { UINT8 : 0, UINT16 : 1, UINT32 : 2, FLOAT16: 3, FLOAT32 : 4, FLOAT64: 5 };

    // private functions

    var iFormatPI2GL = function( format )
    {
        if( mIs20 )
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA8,           mGLExternal: mGL.RGBA,             mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.R8,              mGLExternal: mGL.RED,              mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.R16F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA16F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.R32F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA32F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C3F32) return { mGLFormat: mGL.RGB32F,          mGLExternal: mGL.RGB,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT16, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z24)   return { mGLFormat: mGL.DEPTH_COMPONENT24, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z32)   return { mGLFormat: mGL.DEPTH_COMPONENT32F, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        }
        else
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.RED,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT, mGLExternal: mGL.DEPTH_COMPONENT, mGLType: mGL.UNSIGNED_SHORT }
        }

        return null;
     }

    // public functions

    me.Initialize = function( gl )
                    {
                        mGL = gl;

                        mIs20 = !(gl instanceof WebGLRenderingContext);

                        if( mIs20 )
                        {
                            mFloat32Textures  = true;
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = true;
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = true;
                            mDrawBuffers      = true;
                            mDepthTextures    = true;
                            mShaderTextureLOD = true;
                            mAnisotropic = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mGL.getExtension( 'EXT_color_buffer_float');
                            mDebugShader = mGL.getExtension('WEBGL_debug_shaders');
                            mAsynchCompile = mGL.getExtension('KHR_parallel_shader_compile');

							mGL.hint( mGL.FRAGMENT_SHADER_DERIVATIVE_HINT, mGL.NICEST);
                        }
                        else
                        {
                            mFloat32Textures  = mGL.getExtension( 'OES_texture_float' );
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = mGL.getExtension( 'OES_texture_half_float' );
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = mGL.getExtension( 'OES_standard_derivatives' );
                            mDrawBuffers      = mGL.getExtension( 'WEBGL_draw_buffers' );
                            mDepthTextures    = mGL.getExtension( 'WEBGL_depth_texture' );
                            mShaderTextureLOD = mGL.getExtension( 'EXT_shader_texture_lod' );
                            mAnisotropic      = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mFloat32Textures;
                            mDebugShader      = null;
                            mAsynchCompile    = null;
							
							if( mDerivatives !== null) mGL.hint( mDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, mGL.NICEST);
                        }
                        
                        
                        var maxTexSize = mGL.getParameter( mGL.MAX_TEXTURE_SIZE );
                        var maxCubeSize = mGL.getParameter( mGL.MAX_CUBE_MAP_TEXTURE_SIZE );
                        var maxRenderbufferSize = mGL.getParameter( mGL.MAX_RENDERBUFFER_SIZE );
                        var extensions = mGL.getSupportedExtensions();
                        var textureUnits = mGL.getParameter( mGL.MAX_TEXTURE_IMAGE_UNITS );
                        console.log("WebGL (2.0=" + mIs20 + "):" +
                                    " Asynch Compile: "  + ((mAsynchCompile !==null) ? "yes" : "no") +
                                    ", Textures: F32 ["   + ((mFloat32Textures !==null) ? "yes" : "no") +
                                    "], F16 ["   + ((mFloat16Textures !==null) ? "yes" : "no") +
                                    "], Depth [" + ((mDepthTextures   !==null) ? "yes" : "no") +
                                    "], LOD ["    + ((mShaderTextureLOD!==null) ? "yes" : "no") +
                                    "], Aniso ["   + ((mAnisotropic     !==null) ? "yes" : "no") +
                                    "], Units [" + textureUnits +
                                    "], Max Size [" + maxTexSize +
                                    "], Cube Max Size [" + maxCubeSize +
                                    "], Targets: MRT ["            + ((mDrawBuffers     !==null) ? "yes" : "no") +
                                    "], F32 ["     + ((mRenderToFloat32F!==null) ? "yes" : "no") +
                                    "], Max Size [" + maxRenderbufferSize + "]");

                        // create a 2D quad Vertex Buffer
                        var vertices = new Float32Array( [ -1.0, -1.0,   1.0, -1.0,    -1.0,  1.0,     1.0, -1.0,    1.0,  1.0,    -1.0,  1.0] );
                        mVBO_Quad = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                        mGL.bufferData( mGL.ARRAY_BUFFER, vertices, mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 2D triangle Vertex Buffer
                        mVBO_Tri = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0,   3.0, -1.0,    -1.0,  3.0] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePosNor = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0, -1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                               1.0,  1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                               1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                               1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                               1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0,  1.0, -1.0,   0.0,  0.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePos = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0,  1.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        //-------------------------------------------------------------------

                        mShaderHeader[0] = "";
                        mShaderHeaderLines[0] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[0] += "#version 300 es\n" +
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[0] += 6;
                        }
                        else
                        {
                            mShaderHeader[0] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "#endif\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+                                                
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[0] += 26;
                        }

                        //-------------------------------------------------------

                        mShaderHeader[1] = "";
                        mShaderHeaderLines[1] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[1] += "#version 300 es\n"+
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[1] += 6;
                        }
                        else
                        {
                            if( mDerivatives ) { mShaderHeader[1] += "#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n"; mShaderHeaderLines[1]+=3; }
                            if( mShaderTextureLOD  ) { mShaderHeader[1] += "#extension GL_EXT_shader_texture_lod : enable\n"; mShaderHeaderLines[1]++; }
                            mShaderHeader[1] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "#endif\n"+ 
                                                "vec4 texture(     sampler2D   s, vec2 c)                   { return texture2D(s,c); }\n"+
                                                "vec4 texture(     sampler2D   s, vec2 c, float b)          { return texture2D(s,c,b); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c )                  { return textureCube(s,c); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c, float b)          { return textureCube(s,c,b); }\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[1] += 30;
                            if( mShaderTextureLOD )
                            {
                            mShaderHeader[1] += "vec4 textureLod(  sampler2D   s, vec2 c, float b)          { return texture2DLodEXT(s,c,b); }\n";
                            mShaderHeader[1] += "vec4 textureGrad( sampler2D   s, vec2 c, vec2 dx, vec2 dy) { return texture2DGradEXT(s,c,dx,dy); }\n";
                            mShaderHeaderLines[1] += 2;

                            //mShaderHeader[1] += "vec4 texelFetch( sampler2D s, ivec2 c, int l) { return texture2DLodEXT(s,(vec2(c)+0.5)/vec2(800,450),float(l)); }\n";
                            //mShaderHeaderLines[1] += 1;
                            }
                        }

                        return true;
                    };

        me.GetCaps =    function ()
                        {   
                            return { mIsGL20 : mIs20,
                                     mFloat32Textures: mFloat32Textures != null,
                                     mFloat16Textures: mFloat16Textures != null,
                                     mDrawBuffers: mDrawBuffers != null,
                                     mDepthTextures: mDepthTextures != null,
                                     mDerivatives: mDerivatives != null,
                                     mShaderTextureLOD: mShaderTextureLOD != null };
                        };

        me.GetShaderHeaderLines = function (shaderType)
                        {   
                            return mShaderHeaderLines[shaderType];
                        };

        me.CheckErrors = function()
                         {
                                var error = mGL.getError();
                                if( error != mGL.NO_ERROR ) 
                                { 
                                    for( var prop in mGL ) 
                                    {
                                        if( typeof mGL[prop] == 'number' ) 
                                        {
                                            if( mGL[prop] == error )
                                            {
                                                console.log( "GL Error " + error + ": " + prop );
                                                break;
                                            }
                                        }
                                    }
                                }
                         };

        me.Clear =  function( flags, ccolor, cdepth, cstencil )
                    {
                        var mode = 0;
                        if( flags & 1 ) { mode |= mGL.COLOR_BUFFER_BIT;   mGL.clearColor( ccolor[0], ccolor[1], ccolor[2], ccolor[3] ); }
                        if( flags & 2 ) { mode |= mGL.DEPTH_BUFFER_BIT;   mGL.clearDepth( cdepth ); }
                        if( flags & 4 ) { mode |= mGL.STENCIL_BUFFER_BIT; mGL.clearStencil( cstencil ); }
                        mGL.clear( mode );
                    };


        me.CreateTexture = function ( type, xres, yres, format, filter, wrap, buffer)
                           {
                                if( mGL===null ) return null;

                                var id = mGL.createTexture();

                                var glFoTy = iFormatPI2GL( format );
                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                if( type===me.TEXTYPE.T2D )
                                {
                                    mGL.bindTexture( mGL.TEXTURE_2D, id );
//if( buffer==null )
    //mGL.texStorage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres);
//else
                                    mGL.texImage2D( mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap );

                                    if (filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                }
                                else if( type===me.TEXTYPE.T3D )
                                {
                                    if( mIs20 )
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_3D, id );
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_BASE_LEVEL, 0);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAX_LEVEL, Math.log2(xres));
                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_3D);
                                        }
                                        mGL.texImage3D( mGL.TEXTURE_3D, 0, glFoTy.mGLFormat, xres, yres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap );

                                        if (filter === me.FILTER.MIPMAP)
                                            mGL.generateMipmap( mGL.TEXTURE_3D );
                                        mGL.bindTexture( mGL.TEXTURE_3D, null );
                                    }
                                    else 
                                    {
                                        return null;
                                    }
                                }
                                else 
                                {
                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );

                                    // this works great if we know the number of required mipmaps in advance (1, or other)
                                   //mGL.texStorage2D( mGL.TEXTURE_CUBE_MAP, 1, glFoTy.mGLFormat, xres, yres );

                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                    if( filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                    }

                                    if (filter === me.FILTER.MIPMAP)
                                        mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );

                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                }
                        return { mObjectID: id, mXres: xres, mYres: yres, mFormat: format, mType: type, mFilter: filter, mWrap: wrap, mVFlip:false };
                        };

        me.CreateTextureFromImage = function ( type, image, format, filter, wrap, flipY) 
                                {
                                    if( mGL===null ) return null;

                                    var id = mGL.createTexture();

                                    var glFoTy = iFormatPI2GL( format );

                                    var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                    if( type===me.TEXTYPE.T2D )
                                    {
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);

                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.pixelStorei(mGL.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                                        if( mIs20 ) mGL.pixelStorei(mGL.UNPACK_COLORSPACE_CONVERSION_WEBGL, mGL.NONE );

                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);

                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);

                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if( filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                    }
                                    else if( type===me.TEXTYPE.T3D )
                                    {
                                        return null;
                                    }
                                    else 
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );

                                        if( filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                    }
                                    return { mObjectID: id, mXres: image.width, mYres: image.height, mFormat: format, mType: type, mFilter: filter, mWrap:wrap, mVFlip:flipY };
                                };

        me.SetSamplerFilter = function (te, filter, doGenerateMipsIfNeeded) 
                            {
                                if (te.mFilter === filter) return;

                                if (te.mType === me.TEXTYPE.T2D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_3D, null);

                                }
                                else
                                {
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }


                                te.mFilter = filter;
                            };

        me.SetSamplerWrap = function (te, wrap)
                            {
                                if (te.mWrap === wrap) return;

                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, id);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, id);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_3D, null);
                                }

                                te.mWrap = wrap;
                            };

        me.SetSamplerVFlip = function (te, vflip, image)
                            {
                                if (te.mVFlip === vflip) return;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    if( image != null)
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                }
                                else if (te.mType === me.TEXTYPE.CUBEMAP)
                                {
                                    if( image != null)
                                    {
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei( mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
        
                                }

                                te.mVFlip = vflip;
                            };

        me.CreateMipmaps =  function (te)
                            {
                                if( te.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);
                                    mGL.generateMipmap(mGL.TEXTURE_2D);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);
                                }
                                else if( te.mType===me.TEXTYPE.CUBEMAP )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);
                                    mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }
                            };

        me.UpdateTexture =  function( tex, x0, y0, xres, yres, buffer )
                            {
                                var glFoTy = iFormatPI2GL( tex.mFormat );
                                if( tex.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture( mGL.TEXTURE0);
                                    mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                    mGL.texSubImage2D( mGL.TEXTURE_2D, 0, x0, y0, xres, yres, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                }
                            };

        me.UpdateTextureFromImage = function( tex, image )
                                {
                                    var glFoTy = iFormatPI2GL( tex.mFormat );
                                    if( tex.mType===me.TEXTYPE.T2D )
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                        mGL.texImage2D(  mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image );
                                        mGL.bindTexture( mGL.TEXTURE_2D, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                };

        me.DestroyTexture = function( te )
                            {
                                 mGL.deleteTexture( te.mObjectID );
                            };

        me.AttachTextures = function (num, t0, t1, t2, t3) 
                            {
                                if (num > 0 && t0 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                         if (t0.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t0.mObjectID);
                                }

                                if (num > 1 && t1 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE1);
                                         if (t1.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t1.mObjectID);
                                }

                                if (num > 2 && t2 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE2);
                                         if (t2.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t2.mObjectID);
                                }

                                if (num > 3 && t3 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE3);
                                         if (t3.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t3.mObjectID);
                                }
                            };

        me.DettachTextures = function()
                             {
                                mGL.activeTexture(mGL.TEXTURE0);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE1);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE2);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE3);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                             };

        me.CreateRenderTarget = function ( color0, color1, color2, color3, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);

                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_2D, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.DestroyRenderTarget = function ( tex )
                                 {
                                     mGL.deleteFramebuffer(tex.mObjectID);
                                 };

        me.SetRenderTarget = function (tex)
                             {
                                if( tex===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, tex.mObjectID);

                                //mGL.drawBuffers([mGL.COLOR_ATTACHMENT0, mGL.COLOR_ATTACHMENT1]);
                             };

        me.CreateRenderTargetNew = function ( wantColor0, wantZbuffer, xres, yres, samples )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if( wantZbuffer===true )
                                    {
                                        var zb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);

                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.DEPTH_COMPONENT16, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                    }

                                    if( wantColor0 )
                                    {
                                        var cb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, cb);
                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.RGBA8, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.RGBA8, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.RENDERBUFFER, cb);
                                    }

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                    {
                                        return null;
                                    }
                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mXres: xres, mYres:yres, mTex0: color0 };
                                };

        me.CreateRenderTargetCubeMap = function ( color0, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);
                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.SetRenderTargetCubeMap = function (fbo, face)
                             {
                                if( fbo===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                {
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, fbo.mObjectID);
                                    mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X+face, fbo.mTex0.mObjectID, 0);
                                }
                             };


        me.BlitRenderTarget = function( dst, src )
                                {
                                    mGL.bindFramebuffer(mGL.READ_FRAMEBUFFER, src.mObjectID);
                                    mGL.bindFramebuffer(mGL.DRAW_FRAMEBUFFER, dst.mObjectID);
                                    mGL.clearBufferfv(mGL.COLOR, 0, [0.0, 0.0, 0.0, 1.0]);
                                    mGL.blitFramebuffer( 0, 0, src.mXres, src.mYres,
                                                         0, 0, src.mXres, src.mYres,
                                                         mGL.COLOR_BUFFER_BIT, mGL.LINEAR
                                    );
                                };

        me.SetViewport = function( vp )
                         {
                              mGL.viewport( vp[0], vp[1], vp[2], vp[3] );
                         };

        me.SetWriteMask = function( c0, c1, c2, c3, z )
                          {
                              mGL.depthMask(z);
                              mGL.colorMask(c0,c0,c0,c0);
                          };

        me.SetState = function( stateName, stateValue )
                      {
                            if (stateName === me.RENDSTGATE.WIREFRAME)
                            {
                                if( stateValue ) mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.LINE );
                                else             mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.FILL );
                            }
                            else if (stateName === me.RENDSTGATE.FRONT_FACE)
                            {
                                if( stateValue ) mGL.cullFace( mGL.BACK );
                                else             mGL.cullFace( mGL.FRONT );
                            }
                            else if (stateName === me.RENDSTGATE.CULL_FACE)
                            {
                                if( stateValue ) mGL.enable( mGL.CULL_FACE );
                                else             mGL.disable( mGL.CULL_FACE );
                            }
                            else if (stateName === me.RENDSTGATE.DEPTH_TEST)
                            {
                                if( stateValue ) mGL.enable( mGL.DEPTH_TEST );
                                else             mGL.disable( mGL.DEPTH_TEST );
                            }
                            else if (stateName === me.RENDSTGATE.ALPHA_TO_COVERAGE)
                            {
                                if( stateValue ) { mGL.enable(  mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                                else             { mGL.disable( mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                            }
                      };

        me.SetMultisample = function( v)
                    {
                        if( v===true )
                        {
                            mGL.enable(mGL.SAMPLE_COVERAGE);
                            mGL.sampleCoverage(1.0, false);
                        }
                        else
                        {
                            mGL.disable(mGL.SAMPLE_COVERAGE);
                        }
                    };

        me.GetTranslatedShaderSource = function (shader) 
                          {
                            if( mGL===null ) return null;
                            if( mDebugShader===null ) return null;
                            let vfs = mGL.getAttachedShaders(shader.mProgram);
                            let str = mDebugShader.getTranslatedShaderSource(vfs[1]);
                            let parts = str.split("GLSL END"); str = (parts.length<2) ? str : parts[1];
                            return str;
                          };

        me.CreateShader = function (vsSource, fsSource, preventCache, forceSynch, onResolve) 
                          {
                            if( mGL===null ) return;

                            var vs = mGL.createShader( mGL.VERTEX_SHADER   );
                            var fs = mGL.createShader( mGL.FRAGMENT_SHADER );

                            vsSource = mShaderHeader[0] + vsSource;
                            fsSource = mShaderHeader[1] + fsSource;

                            if( preventCache )
                            {
                                let vran = Math.random().toString(36).substring(7);
                                let fran = Math.random().toString(36).substring(7);
                                vsSource += "\n#define K" + vran + "\n";
                                fsSource += "\n#define K" + fran + "\n";
                            }

                            var timeStart = getRealTime();

                            mGL.shaderSource(vs, vsSource);
                            mGL.shaderSource(fs, fsSource);
                            mGL.compileShader(vs);
                            mGL.compileShader(fs);

                            var pr = mGL.createProgram();
                            mGL.attachShader(pr, vs);
                            mGL.attachShader(pr, fs);
                            mGL.linkProgram(pr);

                            //-------------
                            let checkErrors = function()
                            {
                                if (!mGL.getProgramParameter(pr, mGL.LINK_STATUS))
                                {
                                    // vs error
                                    if (!mGL.getShaderParameter(vs, mGL.COMPILE_STATUS))
                                    {
                                        let vsLog = mGL.getShaderInfoLog(vs);
                                        onResolve(false, { mErrorType: 0, mErrorStr: vsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // fs error
                                    else if (!mGL.getShaderParameter(fs, mGL.COMPILE_STATUS))
                                    {
                                        let fsLog = mGL.getShaderInfoLog(fs);
                                        onResolve(false, { mErrorType: 1, mErrorStr: fsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // link error
                                    else
                                    {
                                        let infoLog = mGL.getProgramInfoLog(pr);
                                        onResolve(false, { mErrorType: 2, mErrorStr: infoLog });
                                        mGL.deleteProgram(pr);
                                    }
                                }
                                // no errors
                                else
                                {
                                    let compilationTime = getRealTime() - timeStart;
                                    onResolve(true, { mProgram: pr, mTime: compilationTime });
                                }
                            };

                            // check compilation
                            if (mAsynchCompile === null || forceSynch===true )
                            {
                                checkErrors();
                            }
                            else
                            {
                                let loopCheckCompletion = function ()
                                {
                                    if( mGL.getProgramParameter(pr, mAsynchCompile.COMPLETION_STATUS_KHR) === true )
                                        checkErrors();
                                    else
                                        setTimeout(loopCheckCompletion, 10);
                                };
                                setTimeout(loopCheckCompletion, 10);
                            }
                        };

        me.AttachShader = function( shader )
                          {
                                if( shader===null )
                                {
                                    mBindedShader = null;
                                    mGL.useProgram( null );
                                }
                                else
                                {
                                    mBindedShader = shader;
                                    mGL.useProgram(shader.mProgram);
                                }
                          };

        me.DetachShader = function ()
                        {
                            mGL.useProgram(null);
                        };

        me.DestroyShader = function( tex )
                        {
                            mGL.deleteProgram(tex.mProgram);
                        };

        me.GetAttribLocation = function (shader, name)
                        {
                            return mGL.getAttribLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantLocation = function (shader, name)
                        {
                            return mGL.getUniformLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantMat4F = function( uname, params, istranspose )
                        {
                            var program = mBindedShader;

                            let pos = mGL.getUniformLocation( program.mProgram, uname );
                            if( pos===null )
                                return false;

                            if( istranspose===false )
                            {
                                var tmp = new Float32Array( [ params[0], params[4], params[ 8], params[12],
                                                              params[1], params[5], params[ 9], params[13],
                                                              params[2], params[6], params[10], params[14],
                                                              params[3], params[7], params[11], params[15] ] );
	                            mGL.uniformMatrix4fv(pos,false,tmp);
                            }
                            else
                                mGL.uniformMatrix4fv(pos,false,new Float32Array(params) );
                            return true;
                        };

        me.SetShaderConstant1F_Pos = function(pos, x)
                        {
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1FV_Pos = function(pos, x)
                        {
                            mGL.uniform1fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant1F = function( uname, x )
                        {
                            var pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1I = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1i(pos, x);
                            return true;
                        };
        me.SetShaderConstant1I_Pos = function(pos, x)
                        {
                            mGL.uniform1i(pos, x);
                            return true;
                        };


        me.SetShaderConstant2F = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform2fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant3F = function(uname, x, y, z)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform3f(pos, x, y, z);
                            return true;
                        };

        me.SetShaderConstant1FV = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1fv(pos, new Float32Array(x));
                            return true;
                        };

        me.SetShaderConstant3FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform3fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderConstant4FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform4fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderTextureUnit = function( uname, unit )
                        {
                            var program = mBindedShader;
                            let pos = mGL.getUniformLocation(program.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform1i(pos, unit);
                            return true;
                        };

        me.CreateVertexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, id);
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.CreateIndexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, id );
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.DestroyArray = function( tex )
                        {
                            mGL.destroyBuffer(tex.mObject);
                        };

        me.AttachVertexArray = function( tex, attribs, pos )
                        {
                            let shader = mBindedShader;

                            mGL.bindBuffer( mGL.ARRAY_BUFFER, tex.mObject);

                            var num = attribs.mChannels.length;
                            var stride = attribs.mStride;

                            var offset = 0;
                            for (var i = 0; i < num; i++)
                            {
                                var id = pos[i];
                                mGL.enableVertexAttribArray(id);
                                var dtype = mGL.FLOAT;
                                var dsize = 4;
                                     if( attribs.mChannels[i].mType === me.TYPE.UINT8   ) { dtype = mGL.UNSIGNED_BYTE;  dsize = 1; }
                                else if( attribs.mChannels[i].mType === me.TYPE.UINT16  ) { dtype = mGL.UNSIGNED_SHORT; dsize = 2; }
                                else if( attribs.mChannels[i].mType === me.TYPE.FLOAT32 ) { dtype = mGL.FLOAT;          dsize = 4; }
                                mGL.vertexAttribPointer(id, attribs.mChannels[i].mNumComponents, dtype, attribs.mChannels[i].mNormalize, stride, offset);
                                offset += attribs.mChannels[i].mNumComponents * dsize;
                            }
                        };

        me.AttachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, tex.mObject);
                        };

        me.DetachVertexArray = function (tex, attribs)
                        {
                            let num = attribs.mChannels.length;
                            for (let i = 0; i < num; i++)
                                mGL.disableVertexAttribArray(i);
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, null);
                        };

        me.DetachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, null);
                        };

        me.DrawPrimitive = function( typeOfPrimitive, num, useIndexArray, numInstances )
                        {
                            let glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.POINTS ) glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.LINES ) glType = mGL.LINES;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_LOOP ) glType = mGL.LINE_LOOP;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_STRIP ) glType = mGL.LINE_STRIP;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLES ) glType = mGL.TRIANGLES;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLE_STRIP ) glType = mGL.TRIANGLE_STRIP;

                            if( numInstances<=1 )
                            {
  	                            if( useIndexArray ) mGL.drawElements( glType, num, mGL.UNSIGNED_SHORT, 0 );
	                            else                mGL.drawArrays( glType, 0, num );
                            }
                            else
                            {
                                mGL.drawArraysInstanced(glType, 0, num, numInstances);
                                mGL.drawElementsInstanced( glType, num, mGL.UNSIGNED_SHORT, 0, numInstances);
                            }
                        };


        me.DrawFullScreenTriangle_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 3 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };


        me.DrawUnitQuad_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 6 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };

        me.DrawUnitCube_XYZ_NOR = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                            mGL.vertexAttribPointer( vpos[0], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.vertexAttribPointer( vpos[1], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos[0] );
                            mGL.enableVertexAttribArray( vpos[1] );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos[0] );
                            mGL.disableVertexAttribArray( vpos[1] );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.DrawUnitCube_XYZ = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                            mGL.vertexAttribPointer( vpos, 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.SetBlend = function( enabled )
                    {
                        if( enabled )
                        {
                            mGL.enable( mGL.BLEND );
                            mGL.blendEquationSeparate( mGL.FUNC_ADD, mGL.FUNC_ADD );
                            mGL.blendFuncSeparate( mGL.SRC_ALPHA, mGL.ONE_MINUS_SRC_ALPHA, mGL.ONE, mGL.ONE_MINUS_SRC_ALPHA );
                        }
                        else
                        {
                            mGL.disable( mGL.BLEND );
                        }
                    };

        me.GetPixelData = function( data, offset, xres, yres )
                        {
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.UNSIGNED_BYTE, data, offset);
                        };

        me.GetPixelDataRenderTarget = function( obj, data, xres, yres )
                        {
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, obj.mObjectID);
                            mGL.readBuffer(mGL.COLOR_ATTACHMENT0);
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.FLOAT, data, 0);
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                        };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piShading
//
//==============================================================================

function smoothstep(a, b, x)
{
    x = (x - a) / (b - a);
    if (x < 0) x = 0; else if (x > 1) x = 1;
    return x * x * (3.0 - 2.0 * x);
}

function clamp01(x)
{
    if( x < 0.0 ) x = 0.0;
    if( x > 1.0 ) x = 1.0;
    return x;
}

function clamp(x, a, b)
{
    if( x < a ) x = a;
    if( x > b ) x = b;
    return x;
}

function screen(a, b)
{
    return 1.0 - (1.0 - a) * (1.0 - b);
}

function parabola(x)
{
    return 4.0 * x * (1.0 - x);
}

function min(a, b)
{
    return (a < b) ? a : b;
}

function max(a, b)
{
    return (a > b) ? a : b;
}

function noise( x )
{
    function grad(i, j, x, y)
    {
        var h = 7 * i + 131 * j;
        h = (h << 13) ^ h;
        h = (h * (h * h * 15731 + 789221) + 1376312589);

        var rx = (h & 0x20000000) ? x : -x;
        var ry = (h & 0x10000000) ? y : -y;

        return rx + ry;
    }

    var i = [ Math.floor(x[0]), Math.floor(x[1]) ];
    var f = [ x[0] - i[0], x[1] - i[1] ];
    var w = [ f[0]*f[0]*(3.0-2.0*f[0]), f[1]*f[1]*(3.0-2.0*f[1]) ];

    var a = grad( i[0]+0, i[1]+0, f[0]+0.0, f[1]+0.0 );
    var b = grad( i[0]+1, i[1]+0, f[0]-1.0, f[1]+0.0 );
    var c = grad( i[0]+0, i[1]+1, f[0]+0.0, f[1]-1.0 );
    var d = grad( i[0]+1, i[1]+1, f[0]-1.0, f[1]-1.0 );

    return a + (b-a)*w[0] + (c-a)*w[1] + (a-b-c+d)*w[0]*w[1];
}//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piVecTypes
//
//==============================================================================


function vec3( a, b, c )
{
    return [ a, b, c ];
}

function add( a, b )
{
    return [ a[0]+b[0], a[1]+b[1], a[2]+b[2] ];
}

function sub( a, b )
{
    return [ a[0]-b[0], a[1]-b[1], a[2]-b[2] ];
}

function mul( a, s ) 
{
    return [ a[0]*s, a[1]*s, a[2]*s ];
}

function cross( a, b )
{
    return [ a[1]*b[2] - a[2]*b[1],
             a[2]*b[0] - a[0]*b[2],
             a[0]*b[1] - a[1]*b[0] ];
}

function dot( a, b ) 
{
    return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
}

function normalize( v ) 
{
    var is = 1.0 / Math.sqrt( v[0]*v[0] + v[1]*v[1] + v[2]*v[2] );
    return [ v[0]*is, v[1]*is, v[2]*is ];
}

function createCirclePoint( cen, uuu, vvv, rad, s, t )
{
    return [ cen[0] + rad*(uuu[0]*s + vvv[0]*t),
             cen[1] + rad*(uuu[1]*s + vvv[1]*t),
             cen[2] + rad*(uuu[2]*s + vvv[2]*t) ];
}

function createTangent( a, b, c )
{
    var cb = normalize( [ c[0]-b[0], c[1]-b[1], c[2]-b[2] ] );
    var ba = normalize( [ b[0]-a[0], b[1]-a[1], b[2]-a[2] ] );
    return normalize( [ ba[0]+cb[0], ba[1]+cb[1], ba[2]+cb[2] ] );

}

//===================================

function vec4( a, b, c, d )
{
    return [ a, b, c, d ];
}

function getXYZ( v )
{
    return [ v[0], v[1], v[2] ];
}

//===================================

function setIdentity()
{
    return [ 1.0, 0.0, 0.0, 0.0,
             0.0, 1.0, 0.0, 0.0,
             0.0, 0.0, 1.0, 0.0,
             0.0, 0.0, 0.0, 1.0 ];
}

function setRotationX( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ 1.0,   0.0,   0.0, 0.0,
             0.0,  cost, -sint, 0.0, 
             0.0,  sint,  cost, 0.0,
             0.0,   0.0,   0.0, 1.0 ];
}

function setRotationY( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ cost, 0.0, -sint, 0.0,
              0.0, 1.0,   0.0, 0.0, 
             sint, 0.0,  cost, 0.0,
              0.0, 0.0,   0.0, 1.0 ];
}

function extractRotationEuler( m)
{
    var res = [];
    if (m[0] == 1.0)
    {
        res[0] = Math.atan2(m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;

    }
    else if (m[0] == -1.0)
    {
        res[0] = Math.atan2( m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;
    }
    else
    {
        res[0] = Math.atan2( -m[9], m[10]);
        res[1] = Math.atan2( m[8], Math.sqrt(m[9]*m[9] + m[10]*m[10]));
        res[2] = Math.atan2( m[4], m[0]);
    }
    return res;
}

function setFromQuaternion( q )
{
    var ww = q[3]*q[3];
    var xx = q[0]*q[0];
    var yy = q[1]*q[1];
    var zz = q[2]*q[2];

    return [ ww+xx-yy-zz,                   2.0*(q[0]*q[1] - q[3]*q[2]), 2.0*(q[0]*q[2] + q[3]*q[1]), 0.0,
               2.0*(q[0]*q[1] + q[3]*q[2]),   ww-xx+yy-zz,                 2.0*(q[1]*q[2] - q[3]*q[0]), 0.0,
               2.0*(q[0]*q[2] - q[3]*q[1]),   2.0*(q[1]*q[2] + q[3]*q[0]), ww-xx-yy+zz,                 0.0,
               0.0,                           0.0,                         0.0,                         1.0 ];
}

function setPerspective( fovy, aspect, znear, zfar )
{
    var tan = Math.tan(fovy * Math.PI/180.0);
    var x = 1.0 / (tan*aspect);
    var y = 1.0 / (tan);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0 * zfar * znear) / (zfar - znear);

    return [ x,    0.0,  0.0,  0.0,
             0.0,  y,    0.0,  0.0,
             0.0,  0.0,  c,     d,
             0.0,  0.0, -1.0,  0.0 ];
}

function setLookAt( eye, tar, up )
{
    var dir = [ -tar[0]+eye[0], -tar[1]+eye[1], -tar[2]+eye[2] ];

	var m00 = dir[2]*up[1] - dir[1]*up[2]; 
    var m01 = dir[0]*up[2] - dir[2]*up[0];
    var m02 = dir[1]*up[0] - dir[0]*up[1];
    var im = 1.0/Math.sqrt( m00*m00 + m01*m01 + m02*m02 );
    m00 *= im;
    m01 *= im;
    m02 *= im;

	var m04 = m02*dir[1] - m01*dir[2]; 
    var m05 = m00*dir[2] - m02*dir[0];
    var m06 = m01*dir[0] - m00*dir[1];
    im = 1.0/Math.sqrt( m04*m04 + m05*m05 + m06*m06 );
    m04 *= im;
    m05 *= im;
    m06 *= im;

	var m08 = dir[0];
	var m09 = dir[1];
	var m10 = dir[2];
    im = 1.0/Math.sqrt( m08*m08 + m09*m09 + m10*m10 );
    m08 *= im;
    m09 *= im;
    m10 *= im;

	var m03 = -(m00*eye[0] + m01*eye[1] + m02*eye[2] );
	var m07 = -(m04*eye[0] + m05*eye[1] + m06*eye[2] );
	var m11 = -(m08*eye[0] + m09*eye[1] + m10*eye[2] );

    return [ m00, m01, m02, m03,
             m04, m05, m06, m07,
             m08, m09, m10, m11,
             0.0, 0.0, 0.0, 1.0 ];
}


function setOrtho( left, right, bottom, top, znear, zfar )
{
   var x = 2.0 / (right - left);
   var y = 2.0 / (top - bottom);
   var a = (right + left) / (right - left);
   var b = (top + bottom) / (top - bottom);
   var c = -2.0 / (zfar - znear);
   var d = -(zfar + znear) / ( zfar - znear);

   return [  x, 0.0, 0.0,   a,
           0.0,   y, 0.0,   b,
           0.0, 0.0,   c,   d,
           0.0, 0.0, 0.0, 1.0 ];
}

function setTranslation( p )
{
    return [ 1.0, 0.0, 0.0, p[0],
             0.0, 1.0, 0.0, p[1],
             0.0, 0.0, 1.0, p[2],
             0.0, 0.0, 0.0, 1.0 ];
}

function setScale( s )
{
    return [ s[0], 0.0,  0.0,  0.0,
             0.0,  s[1], 0.0,  0.0,
             0.0,  0.0,  s[2], 0.0,
             0.0,  0.0,  0.0,  1.0];
}

function setProjection( fov, znear, zfar )
{
    var x = 2.0 / (fov[3]+fov[2]);
    var y = 2.0 / (fov[0]+fov[1]);
    var a = (fov[3]-fov[2]) / (fov[3]+fov[2]);
    var b = (fov[0]-fov[1]) / (fov[0]+fov[1]);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0*zfar*znear) / (zfar - znear);
    return [   x, 0.0,    a, 0.0,
             0.0,   y,    b, 0.0,
             0.0, 0.0,    c,   d,
             0.0, 0.0, -1.0, 0.0 ];
   // inverse is:
   //return mat4x4( 1.0/x, 0.0f,  0.0f,   a/x,
   //               0.0f,  1.0/y, 0.0f,   b/x,
   //               0.0f,  0.0f,  0.0f,   -1.0,
   //               0.0f,  0.0f,  1.0f/d, c/d );
}


function invertFast( m )
{
    var inv = [
   
             m[5]  * m[10] * m[15] - 
             m[5]  * m[11] * m[14] - 
             m[9]  * m[6]  * m[15] + 
             m[9]  * m[7]  * m[14] +
             m[13] * m[6]  * m[11] - 
             m[13] * m[7]  * m[10],

             -m[1]  * m[10] * m[15] + 
              m[1]  * m[11] * m[14] + 
              m[9]  * m[2] * m[15] - 
              m[9]  * m[3] * m[14] - 
              m[13] * m[2] * m[11] + 
              m[13] * m[3] * m[10],

             m[1]  * m[6] * m[15] - 
             m[1]  * m[7] * m[14] - 
             m[5]  * m[2] * m[15] + 
             m[5]  * m[3] * m[14] + 
             m[13] * m[2] * m[7] - 
             m[13] * m[3] * m[6],

             -m[1] * m[6] * m[11] + 
              m[1] * m[7] * m[10] + 
              m[5] * m[2] * m[11] - 
              m[5] * m[3] * m[10] - 
              m[9] * m[2] * m[7] + 
              m[9] * m[3] * m[6],

             -m[4]  * m[10] * m[15] + 
              m[4]  * m[11] * m[14] + 
              m[8]  * m[6]  * m[15] - 
              m[8]  * m[7]  * m[14] - 
              m[12] * m[6]  * m[11] + 
              m[12] * m[7]  * m[10],

             m[0]  * m[10] * m[15] - 
             m[0]  * m[11] * m[14] - 
             m[8]  * m[2] * m[15] + 
             m[8]  * m[3] * m[14] + 
             m[12] * m[2] * m[11] - 
             m[12] * m[3] * m[10],

             -m[0]  * m[6] * m[15] + 
              m[0]  * m[7] * m[14] + 
              m[4]  * m[2] * m[15] - 
              m[4]  * m[3] * m[14] - 
              m[12] * m[2] * m[7] + 
              m[12] * m[3] * m[6],


             m[0] * m[6] * m[11] - 
             m[0] * m[7] * m[10] - 
             m[4] * m[2] * m[11] + 
             m[4] * m[3] * m[10] + 
             m[8] * m[2] * m[7] - 
             m[8] * m[3] * m[6],


             m[4]  * m[9] * m[15] - 
             m[4]  * m[11] * m[13] - 
             m[8]  * m[5] * m[15] + 
             m[8]  * m[7] * m[13] + 
             m[12] * m[5] * m[11] - 
             m[12] * m[7] * m[9],



             -m[0]  * m[9] * m[15] + 
              m[0]  * m[11] * m[13] + 
              m[8]  * m[1] * m[15] - 
              m[8]  * m[3] * m[13] - 
              m[12] * m[1] * m[11] + 
              m[12] * m[3] * m[9],

              m[0]  * m[5] * m[15] - 
              m[0]  * m[7] * m[13] - 
              m[4]  * m[1] * m[15] + 
              m[4]  * m[3] * m[13] + 
              m[12] * m[1] * m[7] - 
              m[12] * m[3] * m[5],

              -m[0] * m[5] * m[11] + 
               m[0] * m[7] * m[9] + 
               m[4] * m[1] * m[11] - 
               m[4] * m[3] * m[9] - 
               m[8] * m[1] * m[7] + 
               m[8] * m[3] * m[5],

              -m[4]  * m[9] * m[14] + 
               m[4]  * m[10] * m[13] +
               m[8]  * m[5] * m[14] - 
               m[8]  * m[6] * m[13] - 
               m[12] * m[5] * m[10] + 
               m[12] * m[6] * m[9],

              m[0]  * m[9] * m[14] - 
              m[0]  * m[10] * m[13] - 
              m[8]  * m[1] * m[14] + 
              m[8]  * m[2] * m[13] + 
              m[12] * m[1] * m[10] - 
              m[12] * m[2] * m[9],

              -m[0]  * m[5] * m[14] + 
               m[0]  * m[6] * m[13] + 
               m[4]  * m[1] * m[14] - 
               m[4]  * m[2] * m[13] - 
               m[12] * m[1] * m[6] + 
               m[12] * m[2] * m[5],

              m[0] * m[5] * m[10] - 
              m[0] * m[6] * m[9] - 
              m[4] * m[1] * m[10] + 
              m[4] * m[2] * m[9] + 
              m[8] * m[1] * m[6] - 
              m[8] * m[2] * m[5] ];

    var det = m[0] * inv[0] + m[1] * inv[4] + m[2] * inv[8] + m[3] * inv[12];

    det = 1.0/det;

    for( var i = 0; i<16; i++ ) inv[i] = inv[i] * det;

    return inv;
}

function matMul( a, b )
{
    var res = [];
    for( var i=0; i<4; i++ )
    {
        var x = a[4*i+0];
        var y = a[4*i+1];
        var z = a[4*i+2];
        var w = a[4*i+3];

        res[4*i+0] = x * b[ 0] + y * b[ 4] + z * b[ 8] + w * b[12];
        res[4*i+1] = x * b[ 1] + y * b[ 5] + z * b[ 9] + w * b[13];
        res[4*i+2] = x * b[ 2] + y * b[ 6] + z * b[10] + w * b[14];
        res[4*i+3] = x * b[ 3] + y * b[ 7] + z * b[11] + w * b[15];
    }

    return res;
}

function matMulpoint( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2] + m[ 3],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2] + m[ 7],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] + m[11] ];
}

function matMulvec( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] ];
}


function bound3( infi )
{
    return [ infi, -infi, infi, -infi, infi, -infi ];
}

function bound3_include( a, p )
{
    return [
        (p[0]<a[0]) ? p[0] : a[0],
        (p[0]>a[1]) ? p[0] : a[1],
        (p[1]<a[2]) ? p[1] : a[2],
        (p[1]>a[3]) ? p[1] : a[3],
        (p[2]<a[4]) ? p[2] : a[4],
        (p[2]>a[5]) ? p[2] : a[5] ];
}

function bound3_center( b )
{
    return [ 0.5*(b[0]+b[1]),
             0.5*(b[2]+b[3]),
             0.5*(b[4]+b[5]) ];
}

function bound3_radius( b )
{
    return [ 0.5*(b[1]-b[0]),
             0.5*(b[3]-b[2]),
             0.5*(b[5]-b[4]) ];
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebVR
//
//==============================================================================

function WebVR( isVREnabledCallback, canvasElement )
{
    isVREnabledCallback(false);
    /*


    this.mSupportVR = false;
    this.mHMD = null;

    var me = this;
    var listVRDisplays = function (vrdevs) {
        for (var i = 0; i < vrdevs.length; i++)
        {
            if (vrdevs[i] instanceof VRDisplay)
            {
                me.mHMD = vrdevs[i];
                console.log("WebVR is available.");
                console.log(me.mHMD);
                break;
            }
        }

        isVREnabledCallback(true);
        me.mSupportVR = true;
    }

    if (navigator.getVRDisplays)
    {
        navigator.getVRDisplays().then(listVRDisplays);
    }

    isVREnabledCallback(false);
    this.mCanvas = canvasElement;
    */
}

WebVR.prototype.IsSupported = function()
{
    return false;
    //return this.mSupportVR;
}

WebVR.prototype.GetData = function( id )
{
    return {};
    /*
    var frameData = new VRFrameData();
    var s = this.mHMD.getFrameData(frameData);
    var ss = frameData.pose;
    
    var fovL = this.mHMD.getEyeParameters("left");
    var fovR = this.mHMD.getEyeParameters( "right" );

    // camera info
    var cPos = vec3(0.0, 0.0, 0.0);
    if (ss.position)
        cPos = vec3(-ss.position[0], -ss.position[1], -ss.position[2]);
    var rot = vec4(0.0, 0.0, 0.0, 0.0);
    if (ss.orientation)
        rot = vec4(ss.orientation[0], ss.orientation[1], ss.orientation[2], ss.orientation[3]);
    var cRot = setFromQuaternion(rot);
    var cTra = setTranslation(cPos);
    var cMat = matMul(invertFast(cRot), cTra);
    
    // per eye info
    var lTra = setTranslation( vec3(-fovL.offset[0], -fovL.offset[1], -fovL.offset[2]) );
    var lMat = matMul(lTra, cMat);
    var lPrj = [ Math.tan( fovL.fieldOfView.upDegrees * Math.PI/180.0),
                 Math.tan(fovL.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.rightDegrees * Math.PI / 180.0)];

    var rTra = setTranslation(vec3(-fovR.offset[0], -fovR.offset[1], -fovR.offset[2]));
    var rMat = matMul(rTra, cMat);
    var rPrj = [Math.tan(fovR.fieldOfView.upDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.rightDegrees * Math.PI / 180.0)];

    return {
        mCamera   : { mCamera: cMat },
        mLeftEye  : { mVP:[0,0,fovL.renderWidth,fovL.renderHeight], mProjection:lPrj, mCamera:lMat },
        mRightEye : { mVP:[fovR.renderWidth/2,0,fovR.renderWidth,fovR.renderHeight], mProjection:rPrj, mCamera:rMat }
           };
    */
}

WebVR.prototype.Enable = function( id )
{
    /*
    this.mHMD.requestPresent([{ source: this.mCanvas }]).then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : requestPresent failed.");
        }
    );
    */
}

WebVR.prototype.Disable = function( id )
{
    /*
    if (!this.mHMD.isPresenting)
    {
        return;
    }

    this.mHMD.exitPresent().then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : exitPresent failed.");
        }
    );
    */
}

WebVR.prototype.RequestAnimationFrame = function (id)
{
    //this.mHMD.requestAnimationFrame(id);
}

WebVR.prototype.IsPresenting = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        return true;
    }
    */
    return false;
}

WebVR.prototype.Finish = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        this.mHMD.submitFrame();
    }
    */
}

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebUtils
//
//==============================================================================


// RequestAnimationFrame
window.requestAnimFrame = ( function () { return window.requestAnimationFrame    || window.webkitRequestAnimationFrame ||
                                                 window.mozRequestAnimationFrame || window.oRequestAnimationFrame ||
                                                 window.msRequestAnimationFrame  || function( cb ) { window.setTimeout(cb,1000/60); };
                                        } )();

// performance.now
window.getRealTime = ( function() { if ("performance" in window ) return function() { return window.performance.now(); }
                                                                  return function() { return (new Date()).getTime(); }
                                  } )();

window.URL = window.URL || window.webkitURL;

navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;

function htmlEntities(str) 
{
    return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g,'&apos;');
}

function piDisableTouch()
{
    document.body.addEventListener('touchstart', function(e){ e.preventDefault(); });
}

var piGetTime = function ( timestamp )
{
    if (timestamp == 0)
        return "";
    return new Date(timestamp * 1000).toISOString().substr(0, 10);
}

function piGetCoords( obj )
{
    var x = 0;
    var y = 0; 
    do
    {
         x += obj.offsetLeft;
         y += obj.offsetTop;
    }while( obj = obj.offsetParent );

    return { mX:x, mY:y };
}

function piGetMouseCoords( ev, canvasElement )
{
    var pos = piGetCoords(canvasElement );
    var mcx =                        (ev.pageX - pos.mX) * canvasElement.width / canvasElement.offsetWidth;
    var mcy = canvasElement.height - (ev.pageY - pos.mY) * canvasElement.height / canvasElement.offsetHeight;

    return { mX: mcx, mY: mcy };

}

function piGetSourceElement( e )
{
    var ele = null;
    if( e.target )     ele = e.target;
    if( e.srcElement ) ele = e.srcElement;
    return ele;
}

function piRequestFullScreen( ele )
{
    if( ele==null ) ele =   document.documentElement;
         if( ele.requestFullscreen       ) ele.requestFullscreen();
    else if( ele.msRequestFullscreen     ) ele.msRequestFullscreen();
    else if( ele.mozRequestFullScreen    ) ele.mozRequestFullScreen();
    else if( ele.webkitRequestFullscreen ) ele.webkitRequestFullscreen( Element.ALLOW_KEYBOARD_INPUT );
}

function piIsFullScreen()
{
    return document.fullscreen || document.mozFullScreen || document.webkitIsFullScreen || document.msFullscreenElement || false;
}

function piExitFullScreen()
{
       if( document.exitFullscreen       ) document.exitFullscreen();
  else if( document.msExitFullscreen     ) document.msExitFullscreen();
  else if( document.mozCancelFullScreen  ) document.mozCancelFullScreen();
  else if( document.webkitExitFullscreen ) document.webkitExitFullscreen();
}

function piIsMobile()
{
    return (navigator.userAgent.match(/Android/i) ||
            navigator.userAgent.match(/webOS/i) ||
            navigator.userAgent.match(/iPhone/i) ||
            navigator.userAgent.match(/iPad/i) ||
            navigator.userAgent.match(/iPod/i) ||
            navigator.userAgent.match(/BlackBerry/i) ||
            navigator.userAgent.match(/Windows Phone/i)) ? true : false;
}

function piCreateGlContext( cv, useAlpha, useDepth, usePreserveBuffer, useSupersampling )
{
    var opts = { alpha: useAlpha, 
                 depth: useDepth, 
                 stencil: false, 
                 premultipliedAlpha: false, 
                 antialias: useSupersampling, 
                 preserveDrawingBuffer: usePreserveBuffer, 
                 powerPreference: "high-performance" }; // "low_power", "high_performance", "default"

    var gl = null;
    if( gl === null) gl = cv.getContext( "webgl2", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl2", opts );
    if( gl === null) gl = cv.getContext( "webgl", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl", opts );

    return gl;
}

function piCreateAudioContext()
{
    var res = null;
    try
    {
        if( window.AudioContext ) res = new AudioContext();
        if( res==null && window.webkitAudioContext ) res = new webkitAudioContext();
    }
    catch( e )
    {
        res = null;
    }
    return res;
}

function piHexColorToRGB(str) // "#ff3041"
{
    var rgb = parseInt(str.slice(1), 16);
    var r = (rgb >> 16) & 255;
    var g = (rgb >> 8) & 255;
    var b = (rgb >> 0) & 255;
    return [r, g, b];
}

function piCreateFPSCounter()
{
    var mFrame;
    var mTo;
    var mFPS;

    var iReset = function( time )
    {
        mFrame = 0;
        mTo = time;
        mFPS = 60.0;
    }

    var iCount = function( time )
    {
        mFrame++;

        if( (time-mTo)>500.0 )
        {
            mFPS = 1000.0*mFrame/(time-mTo);
            mFrame = 0;
            mTo = time;
            return true;
        }
        return false;
    }

    var iGetFPS = function()
    {
        return mFPS;
    }
    
    return { Reset : iReset, Count : iCount, GetFPS : iGetFPS };
}

function piCanMediaRecorded(canvas)
{
    if (typeof window.MediaRecorder !== 'function' || typeof canvas.captureStream !== 'function') {
        return false;
    }
    return true;
}

function piCreateMediaRecorder(isRecordingCallback, canvas) 
{
    if (piCanMediaRecorded(canvas) == false)
    {
        return null;
    }
    
    var options = { audioBitsPerSecond : 0, videoBitsPerSecond : 8000000 }; 
	     if (MediaRecorder.isTypeSupported('video/webm;codecs=h264')) options.mimeType = 'video/webm;codecs=h264';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9' )) options.mimeType = 'video/webm;codecs=vp9';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8' )) options.mimeType = 'video/webm;codecs=vp8';
    else                                                              options.mimeType = 'video/webm;';

    var mediaRecorder = new MediaRecorder(canvas.captureStream(), options);
    var chunks = [];
    
    mediaRecorder.ondataavailable = function(e) 
    {
        if (e.data.size > 0) 
        {
            chunks.push(e.data);
        }
    };
 
    mediaRecorder.onstart = function(){ 
        isRecordingCallback( true );
    };
    
    mediaRecorder.onstop = function()
    {
         isRecordingCallback( false );
         let blob     = new Blob(chunks, {type: "video/webm"});
         chunks       = [];
         let videoURL = window.URL.createObjectURL(blob);
         let url      = window.URL.createObjectURL(blob);
         let a        = document.createElement("a");
         document.body.appendChild(a);
         a.style      = "display: none";
         a.href       = url;
         a.download   = "capture.webm";
         a.click();
         window.URL.revokeObjectURL(url);
     };
    
    return mediaRecorder;
}

function piExportToEXR(width, height, numComponents, type, bytes)
{
    var bytesPerComponent = 0;
    if      (type=="Uint")   bytesPerComponent = 4; 
    else if (type=="Half")   bytesPerComponent = 2;
    else if (type=="Float")  bytesPerComponent = 4;

    var tHeader = 258 + (18 * numComponents + 1);
    var tTable = 8 * height;
    var tScanlines = height * (4 + 4 + (numComponents * bytesPerComponent * width));
    var tTotal = tHeader + tTable + tScanlines;

    //console.log("    header size = " + tHeader);
    //console.log("    table size = " + tTable);
    //console.log("    scanlines size = " + tScanlines);
    //console.log("    total = " + tTotal);

    var buffer = new ArrayBuffer(tTotal); 
    var data = new DataView(buffer);

    // Header
    {
        // Header : 4 bytes -> 0x76, 0x2f, 0x31, 0x01
        var c = 0;
        data.setUint8 (c++, 0x76);
        data.setUint8 (c++, 0x2f);
        data.setUint8 (c++, 0x31);
        data.setUint8 (c++, 0x01);

        // Version : 4 bytes -> 2, 0, 0, 0
        data.setUint8 (c++, 0x02);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        
        // Write channel info
        // Write attribute name : "channels"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x73);
            data.setUint8 (c++, 0x0);

            // Write attribute type : "chlist"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : 18 x 3 + 1 = 55
            var attribSize = 18 * numComponents + 1;
            data.setUint8 (c++, attribSize); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            var i;
            for (i = 0; i < numComponents; i++)
            {
                // Attribute : "B" (42) "G" (47) "R" (52)
                if (i==0)       data.setUint8 (c++, 0x42);
                else if (i==1)  data.setUint8 (c++, 0x47);
                else if (i==2)  data.setUint8 (c++, 0x52);
                data.setUint8 (c++, 0x00);
                
                // Value : Float (2), Half (1), Uint (0)
                if      (type=="Uint")   data.setUint8 (c++, 0x00); 
                else if (type=="Half")   data.setUint8 (c++, 0x01);
                else if (type=="Float")  data.setUint8 (c++, 0x02);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);

                // Plinear
                data.setUint8 (c++, 0x01);

                // Reserved
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 

                // X sampling
                data.setUint8 (c++, 0x01); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                
                // Y sampling
                data.setUint8 (c++, 0x01);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
            }
            // End attribute
            data.setUint8 (c++, 0x00);
    
        // Write attribute name : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute type : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : "1"
            data.setUint8 (c++, 0x01); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // Write attribute value : "0" (None)
            data.setUint8 (c++, 0x00);

        // datawindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00); 

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00);

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 

            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // displayWindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x79); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00);

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00); 

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // size
            data.setUint8 (c++, 0x01);
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);
            
            // value 
            data.setUint8 (c++, 0x00);

        // PixelAspectRatio
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x41); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x52); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x00); 

            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);
        
            // size 4
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 1.0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);
        
        // screenWindowCenter
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63);
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x43); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e);
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00);

            // v2f
            data.setUint8 (c++, 0x76); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x00);

            // size 8
            data.setUint8 (c++, 0x08); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

        // screenWindowWidth
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x00); 
            
            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00); 

            // size
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);

            // value
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);

        // End of header
        data.setUint8 (c++, 0x00);
    }
    //console.log("header size = " + c);

    // Scanline table
    var initc = c + height * 8;
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        var jump = initc + scanline * (8 + width * bytesPerComponent * numComponents); 
        data.setUint32 (c, jump, true);
        c += 4; 

        data.setUint32 (c, 0x00, true);
        c += 4;
    }
    //console.log("header + scanlines table size = " + c);

    // Scanlines
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        // Scanline
        data.setUint32(c, scanline, true);
        c += 4;

        // size 24
        var size = width * numComponents * bytesPerComponent; 
        data.setUint32(c, size, true);
        c += 4;

        var numComponentsSource = 4; // number of components in the SOURCE image
        for (var component = 0; component < numComponents ; component ++) 
        {
            for (var pixel = 0 ; pixel < width ; pixel ++) 
            {
                // flip vertical, so we read OpenGL buffers without JS image flipping
                var v = bytes[(height-1-scanline) * width *numComponentsSource + pixel * numComponentsSource + (2-component)];
                if      (type=="Float") data.setFloat32(c, v, true);
                else if (type=="Half")  data.setUint16(c, v, true);

                c += bytesPerComponent;
            }
        }
    }
    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}


function piExportToWAV(numSamples, rate, bits, numChannels, words)
{
    let numBytes = numSamples * numChannels * bits/8;

    let buffer = new ArrayBuffer(44 + numBytes); 
    let data = new DataView(buffer);

    {
        data.setUint32( 0, 0x46464952, true );  // RIFF
        data.setUint32( 4, numBytes + 36, true);
        {
            data.setUint32( 8, 0x45564157, true );  // WAV_WAVE
            data.setUint32( 12, 0x20746D66, true );  // WAV_FMT
            {
                data.setUint32( 16, 16, true);
                data.setUint16( 20, 1, true ); // WAV_FORMAT_PCM
                data.setUint16( 22, numChannels, true);
                data.setUint32( 24, rate, true);
                data.setUint32( 28, rate*numChannels*bits / 8, true);
                data.setUint16( 32, numChannels*bits / 8, true);
                data.setUint16( 34, bits, true);
            }

            data.setUint32( 36, 0x61746164, true);  // WAV_DATA
            {
                data.setUint32( 40, numBytes, true);
                let numWords = numSamples * numChannels;
                for(let i=0; i<numWords; i++ )
                {
                    data.setInt16( 44 + i*2, words[i], true );
                }
            }
        }
    }


    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}

function piTriggerDownload(name, blob)
{
    let url = URL.createObjectURL(blob);
    let aElement = document.createElement("a");
    aElement.href     = url;
    aElement.target   = "_self";
    aElement.download = name;
    document.body.appendChild(aElement);
    aElement.click();
    document.body.removeChild(aElement);
}</script>
    <script>"use strict"

function bufferID_to_assetID( id )
{
    if( id===0 ) return '4dXGR8';
    if( id===1 ) return 'XsXGR8';
    if( id===2 ) return '4sXGR8';
    if( id===3 ) return 'XdfGR8';
    return 'none';
}
function assetID_to_bufferID( id )
{
    if( id==='4dXGR8' ) return 0;
    if( id==='XsXGR8' ) return 1;
    if( id==='4sXGR8' ) return 2;
    if( id==='XdfGR8' ) return 3;
    return -1;
}

function assetID_to_cubemapBuferID( id )
{
    if( id==='4dX3Rr' ) return 0;
    return -1;
}
function cubamepBufferID_to_assetID( id )
{
    if( id===0 ) return '4dX3Rr';
    return 'none';
}

function EffectPass( renderer, is20, isLowEnd, hasShaderTextureLOD, callback, obj, forceMuted, forcePaused, outputGainNode, copyProgram, id, effect  )
{
    this.mID = id;
    this.mInputs  = [null, null, null, null ];
    this.mOutputs = [null, null, null, null ];
    this.mSource = null;

    this.mGainNode = outputGainNode;
    this.mSoundShaderCompiled = false;

    this.mEffect = effect;
    this.mRenderer = renderer;
    this.mProgramCopy = copyProgram; 
    this.mCompilationTime = 0;

    this.mType = "none";
    this.mName = "none";
    this.mFrame = 0;

    this.mShaderTextureLOD = hasShaderTextureLOD;
    this.mIs20 = is20;
    this.mIsLowEnd = isLowEnd;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mForceMuted = forceMuted;
    this.mForcePaused = forcePaused;
}

EffectPass.prototype.MakeHeader_Image = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        // old API
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                   header += "uniform sampler2D iChannel" + i + ";\n";

        // new API (see shadertoy.com/view/wtdGW8)
        header += "uniform struct {\n";
             if( inp===null )                  header += "  sampler2D";
        else if( inp.mInfo.mType==="cubemap" ) header += "  samplerCube";
        else if( inp.mInfo.mType==="volume"  ) header += "  sampler3D";
        else                                  header += "  sampler2D";
        header +=        " sampler;\n";
        header += "  vec3  size;\n";
        header += "  float time;\n";
        header += "  int   loaded;\n";
        header += "}iCh" + i + ";\n";
    }
	header += "void mainImage( out vec4 c, in vec2 f );\n";
    header += "void st_assert( bool cond );\n";
    header += "void st_assert( bool cond, int v );\n";

    if( this.mIs20 ) 
    {
        header += "\nout vec4 shadertoy_out_color;\n" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)shadertoy_out_color.x=-1.0;else if(v==1)shadertoy_out_color.y=-1.0;else if(v==2)shadertoy_out_color.z=-1.0;else shadertoy_out_color.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)shadertoy_out_color.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "shadertoy_out_color = vec4(1.0,1.0,1.0,1.0);" + 
            "vec4 color = vec4(1e20);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "if(shadertoy_out_color.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(shadertoy_out_color.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(shadertoy_out_color.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(shadertoy_out_color.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "shadertoy_out_color = vec4(color.xyz,1.0);" +
        "}";
    }
    else
    {
        header += "" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)gl_FragColor.x=-1.0;else if(v==1)gl_FragColor.y=-1.0;else if(v==2)gl_FragColor.z=-1.0;else gl_FragColor.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)gl_FragColor.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "gl_FragColor = vec4(0.0,0.0,0.0,1.0);" + 
            "vec4 color = vec4(1e20);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "color.w = 1.0;" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(gl_FragColor.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "gl_FragColor = vec4(color.xyz,1.0);"+
        "}";
    }
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 ) 
        this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "void main( void )" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );" +
        "color.w = 1.0;"
    if( this.mIs20 ) 
        this.mImagePassFooterVR +=  "outColor = color;}";
    else
        this.mImagePassFooterVR +=  "gl_FragColor = color;}";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Buffer = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                  header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainImage( out vec4 c,  in vec2 f );\n"

    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +
        "mainImage( color, gl_FragCoord.xy );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
    this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        this.mImagePassFooterVR +="outColor = color; }";
    else
        this.mImagePassFooterVR +="gl_FragColor = color; }";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Cubemap = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                   header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainCubemap( out vec4 c, in vec2 f, in vec3 ro, in vec3 rd );\n"

    header += "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainCubemap( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Sound = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform float     iChannelTime[4];\n" +
              "uniform float     iTimeOffset;\n" +
              "uniform int       iSampleOffset;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n";

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp!==null && inp.mInfo.mType==="cubemap" )
            header += "uniform samplerCube iChannel" + i + ";\n";
        else
            header += "uniform sampler2D iChannel" + i + ";\n";
    }
    header += "\n";
    header += "vec2 mainSound( in int samp, float time );\n";

    if( this.mIs20 )
    {
        header += "out vec4 outColor; void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "int   s = iSampleOffset + int(gl_FragCoord.y-0.2)*512 + int(gl_FragCoord.x-0.2);" +
            "vec2 y = mainSound( s, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "outColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    else
    {
        header += "void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "vec2 y = mainSound( 0, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "gl_FragColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    header += "\n";
    this.mHeader = header;
    this.mHeaderLength = 0;
}


EffectPass.prototype.MakeHeader_Common = function ()
{
    let header = "";
    let headerlength = 0;

    header += "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n";
    headerlength += 2;

    if (this.mIs20)
    {
        header += "out vec4 outColor;\n";
        headerlength += 1;
    }
    header += "void main( void )\n";
    headerlength += 1;

    if (this.mIs20)
        header += "{ outColor = vec4(0.0); }";
    else
        header += "{ gl_FragColor = vec4(0.0); }";
    headerlength += 1;
    header += "\n";
    headerlength += 1;

    this.mHeader = header;
    this.mHeaderLength = headerlength;
}

EffectPass.prototype.MakeHeader = function()
{
         if( this.mType==="image" ) this.MakeHeader_Image();
    else if( this.mType==="sound" ) this.MakeHeader_Sound();
    else if( this.mType==="buffer") this.MakeHeader_Buffer();
    else if( this.mType==="common") this.MakeHeader_Common();
    else if( this.mType==="cubemap") this.MakeHeader_Cubemap();
    else console.log("ERROR 4");
}

EffectPass.prototype.Create_Image = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}
EffectPass.prototype.Destroy_Image = function( wa )
{
}

EffectPass.prototype.Create_Buffer = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}

EffectPass.prototype.Destroy_Buffer = function( wa )
{
}

EffectPass.prototype.Create_Cubemap = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
}

EffectPass.prototype.Destroy_Cubemap = function( wa )
{
}

EffectPass.prototype.Create_Common = function( wa )
{
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.MakeHeader();
}
EffectPass.prototype.Destroy_Common = function( wa )
{
}

EffectPass.prototype.Create_Sound = function (wa)
{
    this.MakeHeader();

    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    this.mSampleRate = 44100;
    this.mPlayTime = 60*3;
    this.mPlaySamples = this.mPlayTime*this.mSampleRate;
    this.mBuffer = wa.createBuffer( 2, this.mPlaySamples, this.mSampleRate );

    //-------------------
    this.mTextureDimensions = 512;
    this.mRenderTexture = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D, 
                                                       this.mTextureDimensions, this.mTextureDimensions,
                                                       this.mRenderer.TEXFMT.C4I8,
                                                       this.mRenderer.FILTER.NONE,
                                                       this.mRenderer.TEXWRP.CLAMP, null);
    this.mRenderFBO = this.mRenderer.CreateRenderTarget(this.mRenderTexture, null, null, null, null, false);

    //-----------------------------

    // ArrayBufferView pixels;
    this.mTmpBufferSamples = this.mTextureDimensions*this.mTextureDimensions;
    this.mData = new Uint8Array( this.mTmpBufferSamples*4 );

    this.mPlaying = false;
}

EffectPass.prototype.Destroy_Sound = function( wa )
{
    if( this.mPlayNode!==null ) this.mPlayNode.stop();
    this.mPlayNode = null;
    this.mBuffer = null;
    this.mData = null;

    this.mRenderer.DestroyRenderTarget(this.mRenderFBO);
    this.mRenderer.DestroyTexture(this.mRenderTexture);
}

EffectPass.prototype.Create = function( passType, wa )
{
    this.mType = passType;
    this.mSource = null;

         if( passType==="image" ) this.Create_Image( wa );
    else if( passType==="sound" ) this.Create_Sound( wa );
    else if( passType==="buffer") this.Create_Buffer( wa );
    else if( passType==="common") this.Create_Common( wa );
    else if( passType==="cubemap") this.Create_Cubemap( wa );
    else alert("ERROR 1");
}

EffectPass.prototype.SetName = function (passName)
{
    this.mName = passName;
}

EffectPass.prototype.SetCode = function (src)
{
    this.mSource = src;
}

EffectPass.prototype.Destroy = function( wa )
{
    this.mSource = null;
         if( this.mType==="image" ) this.Destroy_Image( wa );
    else if( this.mType==="sound" ) this.Destroy_Sound( wa );
    else if( this.mType==="buffer") this.Destroy_Buffer( wa );
    else if( this.mType==="common") this.Destroy_Common( wa );
    else if( this.mType==="cubemap") this.Destroy_Cubemap( wa );
    else alert("ERROR 2");
}

EffectPass.prototype.NewShader_Sound = function( shaderCode, commonShaderCodes)
{
    let vsSource = null;

    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for( let i=0; i<commonShaderCodes.length; i++ )
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    this.mSoundShaderCompiled = false;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader_Image = function ( shaderCode, commonShaderCodes )
{
    this.mSupportsVR = false;

    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    return [vsSource, fsSource];


    /*
    let n1 = shaderCode.indexOf("mainVR(");
    let n2 = shaderCode.indexOf("mainVR (");
    let n3 = shaderCode.indexOf("mainVR  (");
    if( n1>0 || n2>0 || n3>0 )
    {
        let vsSourceVR;
        if( this.mIs20 )
            vsSourceVR = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        else
            vsSourceVR = "attribute in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

        let fsSourceVR = this.mHeader;
        for (let i = 0; i < commonShaderCodes.length; i++) {
            fsSourceVR += commonShaderCodes[i];
        }
        fsSourceVR += shaderCode;
        fsSourceVR += this.mImagePassFooterVR;

        let res = this.mRenderer.CreateShader(vsSource, fsSourceVR, preventCache);
        if( res.mResult == false )
        {
            return res.mInfo;
        }
        if( this.mProgramVR != null )
            this.mRenderer.DestroyShader( this.mProgramVR );

        this.mSupportsVR = true;
        this.mProgramVR = res;
    }
    */
}

EffectPass.prototype.NewShader_Cubemap = function( shaderCode, commonShaderCodes )
{
    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }

    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;

    fsSource += shaderCode;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader_Common = function (shaderCode )
{
    let vsSource = null;
    if (this.mIs20)
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader + shaderCode;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader = function ( commonSourceCodes, preventCache, onResolve)
{
    if( this.mRenderer===null ) return;

    let vs_fs = null;

         if( this.mType==="sound"  ) vs_fs = this.NewShader_Sound(   this.mSource, commonSourceCodes );
    else if( this.mType==="image"  ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="buffer" ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="common" ) vs_fs = this.NewShader_Common(  this.mSource,                   );
    else if( this.mType==="cubemap") vs_fs = this.NewShader_Cubemap( this.mSource, commonSourceCodes );
    else { console.log("ERROR 3: \"" + this.mType + "\""); return; }

    let me = this;
    this.mRenderer.CreateShader(vs_fs[0], vs_fs[1], preventCache, false,
        function (worked, info)
        {
            if (worked === true)
            {
                if (me.mType === "sound")
                {
                    me.mSoundShaderCompiled = true;
                }

                me.mCompilationTime = info.mTime;
                me.mError = false;
                me.mErrorStr = "No Errors";
                if (me.mProgram !== null)
                    me.mRenderer.DestroyShader(me.mProgram);
                me.mTranslatedSource = me.mRenderer.GetTranslatedShaderSource(info);
                me.mProgram = info;
            }
            else
            {
                me.mError = true;
                me.mErrorStr = info.mErrorStr;
            }
            onResolve();
        });
}

EffectPass.prototype.DestroyInput = function( id )
{
    if( this.mInputs[id]===null ) return;

    if( this.mInputs[id].mInfo.mType==="texture" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    if( this.mInputs[id].mInfo.mType==="volume" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="webcam" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video.src = "";

        if( this.mInputs[id].video.srcObject!==null )
        {
        let tracks = this.mInputs[id].video.srcObject.getVideoTracks();
        if( tracks ) tracks[0].stop();
        }
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="video" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="music" || this.mInputs[id].mInfo.mType==="musicstream")
    {
        this.mInputs[id].audio.pause();
        this.mInputs[id].audio.mSound.mFreqData = null;
        this.mInputs[id].audio.mSound.mWaveData = null;
        this.mInputs[id].audio = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="cubemap" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="keyboard" )
    {
        //if( this.mInputs[id].globject != null )
          //  this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="mic" )
    {
        this.mInputs[id].mic = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }

    this.mInputs[id] = null;
}

EffectPass.prototype.TooglePauseInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        else
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.audio.mPaused )
        {
            if( inp.loaded )
            {
                inp.audio.play();
            }
            inp.audio.mPaused = false;
        }
        else
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }

    return null;
}

EffectPass.prototype.StopInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused === false )
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused === false )
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.ResumeInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused )
        {
            inp.audio.play();
            inp.audio.mPaused = false;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.RewindInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp==null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.loaded )
        {
            inp.video.currentTime = 0;
        }
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.loaded )
        {
            inp.audio.currentTime = 0;
        }
    }
}

EffectPass.prototype.MuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = true;
        inp.video.mMuted = true;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 0.0;
        inp.audio.mMuted = true;
    }
}

EffectPass.prototype.UnMuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = false;
        inp.video.mMuted = false;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 1.0;
        inp.audio.mMuted = false;
    }
}

EffectPass.prototype.ToggleMuteInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];
    if( inp===null ) return null;

    if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.video.mMuted;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if( inp.audio.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.audio.mMuted;
    }

    return null;
}

EffectPass.prototype.UpdateInputs = function( wa, forceUpdate, keyboard )
{
   for (let i=0; i<this.mInputs.length; i++ )
   {
        let inp = this.mInputs[i];

        if( inp===null )
        {
            if( forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, null, false, 0, 0, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.image, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mPreview, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if( inp.loaded && forceUpdate )
            {
                if( this.mTextureCallbackFun!==null )
                {
                    let img = (assetID_to_cubemapBuferID(inp.mInfo.mID)===-1) ? inp.image[0] : inp.mImage;
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, img, true, 2, 1, -1.0, this.mID );
                }
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:keyboard.mIcon,mData:keyboard.mData}, false, 6, 0, -1.0, this.mID );
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, -1, this.mID );
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
              if( inp.loaded && inp.audio.mPaused === false && inp.audio.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                      inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                  }

                  if (this.mTextureCallbackFun!==null)
                  {
                           if (inp.mInfo.mType === "music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData}, false, 4, 1, inp.audio.currentTime, this.mID);
                      else if (inp.mInfo.mType === "musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData, info: inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                  }
              }
              else if( inp.loaded===false )
              {
                  if (this.mTextureCallbackFun!==null)
                      this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:null}, false, 4, 0, -1.0, this.mID);
              }
        }
        else if( inp.mInfo.mType==="mic" )
        {
              if( inp.loaded && inp.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                      inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
                  }
                  if( this.mTextureCallbackFun!==null )
                      this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave: ((wa==null)?null:inp.mFreqData) }, false, 5, 1, 0, this.mID );
              }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:null}, true, 9, 1, -1.0, this.mID );
            }
        }
    }
}

EffectPass.prototype.Sampler2Renderer = function (sampler)
{
    let filter = this.mRenderer.FILTER.NONE;
    if (sampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
    if (sampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
    let wrap = this.mRenderer.TEXWRP.REPEAT;
    if (sampler.wrap === "clamp") wrap = this.mRenderer.TEXWRP.CLAMP;
    let vflip = false;
    if (sampler.vflip === "true") vflip = true;

    return { mFilter: filter, mWrap: wrap, mVFlip: vflip };
}

EffectPass.prototype.GetSamplerVFlip = function (id)
{
    let inp = this.mInputs[id];
    return inp.mInfo.mSampler.vflip;
}

EffectPass.prototype.GetTranslatedShaderSource = function ()
{
    return this.mTranslatedSource;
}

EffectPass.prototype.SetSamplerVFlip = function (id, str) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = false;
    if (str === "true") filter = true;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, null);
            inp.mInfo.mSampler.vflip = str;
        }
    }
}

EffectPass.prototype.GetAcceptsVFlip = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return false;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return false;
    return true;
}

EffectPass.prototype.GetSamplerFilter = function (id)
{
    let inp = this.mInputs[id];
    if( inp===null) return;
    return inp.mInfo.mSampler.filter;
}

EffectPass.prototype.SetSamplerFilter = function (id, str, buffers, cubeBuffers) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = renderer.FILTER.NONE;
    if (str === "linear") filter = renderer.FILTER.LINEAR;
    if (str === "mipmap") filter = renderer.FILTER.MIPMAP;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0)
            {
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[0], filter, true);
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[1], filter, true);
                inp.mInfo.mSampler.filter = str;
            }
            else
            {
                renderer.SetSamplerFilter(inp.globject, filter, true);
                inp.mInfo.mSampler.filter = str;
            }
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[0], filter, true);
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[1], filter, true);
        inp.mInfo.mSampler.filter = str;
    }
    else if (inp.mInfo.mType === "keyboard")
    {
        inp.mInfo.mSampler.filter = str;
    }
}

EffectPass.prototype.GetAcceptsMipmapping = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetAcceptsLinear = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return true;
    if (inp.mInfo.mType === "musicstream") return true;
    if (inp.mInfo.mType === "mic")  return true;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return true;
    return false;
}

EffectPass.prototype.GetAcceptsWrapRepeat = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return false;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetSamplerWrap = function (id)
{
    return this.mInputs[id].mInfo.mSampler.wrap;
}

EffectPass.prototype.SetSamplerWrap = function (id, str, buffers)
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let restr = renderer.TEXWRP.REPEAT;
    if (str === "clamp") restr = renderer.TEXWRP.CLAMP;

    if (inp === null) 
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "video") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap") 
    {
        if (inp.loaded)
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "webcam") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[0], restr);
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[1], restr);
        inp.mInfo.mSampler.wrap = str;
    }
}


EffectPass.prototype.GetTexture = function( slot )
{
    let inp = this.mInputs[slot];
    if( inp===null ) return null;
    return inp.mInfo;
}

EffectPass.prototype.SetOutputs = function( slot, id )
{
    this.mOutputs[slot] = id;
}

EffectPass.prototype.SetOutputsByBufferID = function( slot, id )
{
    if( this.mType==="buffer" )
    {
        this.mOutputs[slot] = bufferID_to_assetID( id );

        this.mEffect.ResizeBuffer( id, this.mEffect.mXres, this.mEffect.mYres, false );
    }
    else if( this.mType==="cubemap" )
    {
        this.mOutputs[slot] = cubamepBufferID_to_assetID( id );
        this.mEffect.ResizeCubemapBuffer(id, 1024, 1024 );
    }
}

EffectPass.prototype.NewTexture = function( wa, slot, url, buffers, cubeBuffers, keyboard )
{
    var me = this;
    var renderer = this.mRenderer;

    if( renderer===null ) return;

    let texture = null;

    if( url===null || url.mType===null )
    {
        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( this.mTextureCallbackObj, slot, null, true, 0, 0, -1.0, me.mID );
        me.DestroyInput( slot );
        me.mInputs[slot] = null;
        me.MakeHeader();
        return { mFailed:false, mNeedsShaderCompile:false };
    }
    else if( url.mType==="texture" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.image = new Image();
        texture.image.crossOrigin = '';
        texture.image.onload = function()
        {
            let rti = me.Sampler2Renderer(url.mSampler);

            // O.M.G. FIX THIS
            let channels = renderer.TEXFMT.C4I8;
            if (url.mID === "Xdf3zn" || url.mID === "4sf3Rn" || url.mID === "4dXGzn" || url.mID === "4sf3Rr")
                channels = renderer.TEXFMT.C1I8;
            
            texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.image, channels, rti.mFilter, rti.mWrap, rti.mVFlip);

            texture.loaded = true;
            if( me.mTextureCallbackFun!==null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.image, true, 1, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="volume" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mImage = { mData:null, mXres:1, mYres:0, mZres:0 };
        texture.mPreview = new Image();
        texture.mPreview.crossOrigin = '';

	    var xmlHttp = new XMLHttpRequest();
        if( xmlHttp===null ) return { mFailed:true };

        xmlHttp.open('GET', url.mSrc, true);
        xmlHttp.responseType = "arraybuffer";
        xmlHttp.onerror = function()
        {
            console.log( "Error 1 loading Volume" );
        }
        xmlHttp.onload = function()
        {
            let data = xmlHttp.response;
            if (!data ) { console.log( "Error 2 loading Volume" ); return; }

            let file = piFile(data);

            let signature = file.ReadUInt32();
            texture.mImage.mXres = file.ReadUInt32();
            texture.mImage.mYres = file.ReadUInt32();
            texture.mImage.mZres = file.ReadUInt32();
            let binNumChannels = file.ReadUInt8();
            let binLayout = file.ReadUInt8();
            let binFormat = file.ReadUInt16();
            let format = renderer.TEXFMT.C1I8;
                 if( binNumChannels===1 && binFormat===0 )  format = renderer.TEXFMT.C1I8;
            else if( binNumChannels===2 && binFormat===0 )  format = renderer.TEXFMT.C2I8;
            else if( binNumChannels===3 && binFormat===0 )  format = renderer.TEXFMT.C3I8;
            else if( binNumChannels===4 && binFormat===0 )  format = renderer.TEXFMT.C4I8;
            else if( binNumChannels===1 && binFormat===10 ) format = renderer.TEXFMT.C1F32;
            else if( binNumChannels===2 && binFormat===10 ) format = renderer.TEXFMT.C2F32;
            else if( binNumChannels===3 && binFormat===10 ) format = renderer.TEXFMT.C3F32;
            else if( binNumChannels===4 && binFormat===10 ) format = renderer.TEXFMT.C4F32;
            else return;

            let buffer = new Uint8Array(data, 20); // skip 16 bytes (header of .bin)

            let rti = me.Sampler2Renderer(url.mSampler);

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T3D, texture.mImage.mXres, texture.mImage.mYres, format, rti.mFilter, rti.mWrap, buffer);

            if( texture.globject===null )
            {
                console.log( "Error 4: loading Volume" ); 
                return { mFailed:true };
            }

            if (me.mTextureCallbackFun !== null)
            {
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }

            texture.loaded = true;

            // load icon for it
            texture.mPreview.onload = function()
            {
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }
            texture.mPreview.src = url.mPreviewSrc;
        }
        xmlHttp.send("");


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="volume")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="cubemap" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        let rti = me.Sampler2Renderer(url.mSampler);

        if( assetID_to_cubemapBuferID(url.mID)!==-1 )
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 2, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/cubemap00.png";

            this.mEffect.ResizeCubemapBuffer(0, 1024, 1024 );

        }
        else
        {
            texture.image = [ new Image(), new Image(), new Image(), new Image(), new Image(), new Image() ];

            let numLoaded = 0;
            for (var i=0; i<6; i++ )
            {
                texture.image[i].mId = i;
                texture.image[i].crossOrigin = '';
                texture.image[i].onload = function()
                {
                    var id = this.mId;
                    numLoaded++;
                    if( numLoaded===6 )
                    {
                        texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.CUBEMAP, texture.image, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                        texture.loaded = true;
                        if (me.mTextureCallbackFun !== null)
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, texture.image[0], true, 2, 1, -1.0, me.mID);
                    }
                }

                if( i === 0) 
                {
                    texture.image[i].src = url.mSrc;
                } 
                else 
                {
                    let n = url.mSrc.lastIndexOf(".");
                    texture.image[i].src = url.mSrc.substring(0, n) + "_" + i + url.mSrc.substring(n, url.mSrc.length);
                }
            }
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="cubemap")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="webcam" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        texture.video = document.createElement('video');
    	texture.video.width = 320;
    	texture.video.height = 240;
    	texture.video.autoplay = true;
    	texture.video.loop = true;
        texture.mForceMuted = this.mForceMuted;
        texture.mImage = null;

        let rti = me.Sampler2Renderer(url.mSampler);

        var loadImageInsteadOfWebCam = function()
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.mImage, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 7, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/webcam.png";
        }
        
        loadImageInsteadOfWebCam();

        if( typeof navigator.getUserMedia !== "undefined"  && texture.mForceMuted===false )
        {
            texture.video.addEventListener("canplay", function (e)
            {
				try
				{
                    texture.mImage = null;
                    if( texture.globject != null )
                        renderer.DestroyTexture( texture.globject );
					texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
					texture.loaded = true;
                }
                catch(e)
                {
                    loadImageInsteadOfWebCam();
	                alert( 'Your browser can not transfer webcam data to the GPU.');
                }
            } );

            navigator.mediaDevices.getUserMedia( 
                                { "video": { width: 1280, height: 720 }, "audio": false } )
                                .then( function(stream)
                                       {
                                            texture.video.srcObject = stream;
    	                               } )
                                .catch( function(error)
                                        {
                                            loadImageInsteadOfWebCam();
    		                                alert( 'Unable to capture WebCam. Please reload the page.' );
    	                                } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="mic" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mForceMuted = this.mForceMuted;
        texture.mAnalyser = null;
        let num = 512;
        texture.mFreqData = new Uint8Array( num );
        texture.mWaveData = new Uint8Array( num );

        if( wa === null || typeof navigator.getUserMedia === "undefined" )
        {
            if( !texture.mForceMuted ) alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.mForceMuted = true; 
        }

        if( texture.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, num, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)
            texture.loaded = true;
        }
        else
        {
        navigator.getUserMedia( { "audio": true },
                                function(stream)
                                {
                                  texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, null)
                                  texture.mic = wa.createMediaStreamSource(stream);
                                  texture.mAnalyser = wa.createAnalyser();
                                  texture.mic.connect( texture.mAnalyser );
                                  texture.loaded = true;
    	                        },
                                function(error)
                                {
    		                        alert( 'Unable open Mic. Please reload the page.' );
    	                        } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="video" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.video = document.createElement('video');
    	texture.video.loop = true;
        texture.video.preload = "auto";
        texture.video.mPaused = this.mForcePaused;
        texture.video.mMuted = true;//this.mForceMuted;
    	texture.video.muted  = true;//this.mForceMuted;
        if( this.mForceMuted===true )
            texture.video.volume = 0;
    	texture.video.autoplay = false;
        texture.video.hasFalled = false;
        
        let rti = me.Sampler2Renderer(url.mSampler);

        texture.video.addEventListener("canplay", function (e)
        {
            texture.video.play().then( function()
                                       {
                                           texture.video.mPaused = false;

                                           texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                                           texture.loaded = true;
            
                                           if( me.mTextureCallbackFun!=null )
                                               me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.video, true, 3, 1, -1.0, me.mID );
                                        } )
                               .catch( function(error)
                                       {
                                           console.log( error );
                                       }
                                );
        } );

        texture.video.addEventListener( "error", function(e)
        {
               if( texture.video.hasFalled===true ) { alert("Error: cannot load video" ); return; }
               let str = texture.video.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".mp4";
               texture.video.src = str;
               texture.video.hasFalled = true;
        } );

        texture.video.src = url.mSrc;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="music" || url.mType==="musicstream" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.audio = document.createElement('audio');
    	texture.audio.loop = true;
        texture.audio.mMuted = this.mForceMuted;
        texture.audio.mForceMuted = this.mForceMuted;
        texture.audio.muted = this.mForceMuted;
        if( this.mForceMuted===true )
            texture.audio.volume = 0;
        texture.audio.autoplay = false;
        texture.audio.hasFalled = false;
        texture.audio.mPaused = false;
        texture.audio.mSound = {};

        if( this.mForceMuted===false )
        {
            if(url.mType==="musicstream" && SC === null)
            {
                alert( "Shadertoy: Soundcloud could not be reached" );
                texture.audio.mForceMuted = true;
            }
            }

        if( wa === null && this.mForceMuted===false )
        {
            alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.audio.mForceMuted = true;
        }

        if( texture.audio.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null);
            let num = 512;
            texture.audio.mSound.mFreqData = new Uint8Array( num );
            texture.audio.mSound.mWaveData = new Uint8Array( num );
            texture.loaded = true;
        }

        texture.audio.addEventListener( "canplay", function()
        {
            if( texture===null || texture.audio===null ) return;
            if( this.mForceMuted  ) return;
            if( texture.loaded === true ) return;

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)

            texture.audio.mSound.mSource   = wa.createMediaElementSource( texture.audio );
            texture.audio.mSound.mAnalyser = wa.createAnalyser();
            texture.audio.mSound.mGain     = wa.createGain();

            texture.audio.mSound.mSource.connect(   texture.audio.mSound.mAnalyser );
            texture.audio.mSound.mAnalyser.connect( texture.audio.mSound.mGain );
            texture.audio.mSound.mGain.connect(me.mGainNode);

            texture.audio.mSound.mFreqData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );
            texture.audio.mSound.mWaveData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );

            if( texture.audio.mPaused )
            {
                texture.audio.pause();
            }
            else
            {
                texture.audio.play().then( function() {} ).catch( function(e){console.log("error " + e);} );
            }
            texture.loaded = true;
        } );

        texture.audio.addEventListener( "error", function(e)
        {
               if( this.mForceMuted  ) return;

               if( texture.audio.hasFalled===true ) { return; }
               let str = texture.audio.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".ogg";
               texture.audio.src = str;
               texture.audio.hasFalled = true;
        } );

        if( !texture.audio.mForceMuted )
        {
            if(url.mType==="musicstream")
            {
                SC.resolve(url.mSrc, 
                    function(song) 
                    {
                        if( song.streamable===true )
                        {
                            texture.audio.crossOrigin = 'anonymous';
                            texture.audio.src = song.stream_url;
                            texture.audio.soundcloudInfo = song;
                        }
                        else
                        {
                            alert('Shadertoy: Soundcloud 3 - This track cannot be streamed' );
                        }
                    },
                    function(error)
                    {
                        if (me.mTextureCallbackFun!==null)
                        {
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
                        }
                    } );
            } 
            else
            {
                texture.audio.src = url.mSrc;
            }
        }

        if (me.mTextureCallbackFun!==null)
        {
            if (url.mType === "music")            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
            else if (url.mType === "musicstream") me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null, info: texture.audio.soundcloudInfo}, false, 8, 0, -1.0, me.mID);
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="keyboard" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = true;

        texture.keyboard = {};

        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {mImage: keyboard.mIcon, mData: keyboard.mData}, false, 6, 1, -1.0, me.mID );

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="buffer" )
    {
        texture = {};
        texture.mInfo = url;

        texture.image = new Image();
        texture.image.onload = function()
        {
            if( me.mTextureCallbackFun!==null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {texture: texture.image, data:null}, true, 9, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;
        texture.id = assetID_to_bufferID( url.mID );
        texture.loaded = true;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;

        this.mEffect.ResizeBuffer(texture.id, this.mEffect.mXres, this.mEffect.mYres, false );

        this.SetSamplerFilter(slot, url.mSampler.filter, buffers, cubeBuffers, true);
        this.SetSamplerVFlip(slot, url.mSampler.vflip);
        this.SetSamplerWrap(slot, url.mSampler.wrap, buffers);

        this.MakeHeader();
        return returnValue;
    }
    else
    {
        alert( "input type error" );
        return { mFailed: true };
    }

    return { mFailed: true };
}

EffectPass.prototype.Paint_Image = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];

    //------------------------
    
    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];
    let texIsLoaded = [0, 0, 0, 0 ];
    let texID = [ null, null, null, null];

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
            texIsLoaded[i] = 1;
            resos[3*i+0] = 256;
            resos[3*i+1] = 3;
            resos[3*i+2] = 1;
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;

                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                }
            }
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {

                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                texIsLoaded[i] = 0;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    times[i] = 10.0 + time;
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            let id = inp.id;
            if( inp.loaded===true  )
            {
                texID[i] = buffers[id].mTexture[ buffers[id].mLastRenderDone ];
                texIsLoaded[i] = 1;
                resos[3*i+0] = xres;
                resos[3*i+1] = yres;
                resos[3*i+2] = 1;
                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID[i], filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    let prog = this.mProgram;

    //if( vrData!=null && this.mSupportsVR ) prog = this.mProgramVR;

    this.mRenderer.AttachShader(prog);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F("iFrameRate", fps);

    this.mRenderer.SetShaderConstant1F(  "iCh0.time", times[0] );
    this.mRenderer.SetShaderConstant1F(  "iCh1.time", times[1] );
    this.mRenderer.SetShaderConstant1F(  "iCh2.time", times[2] );
    this.mRenderer.SetShaderConstant1F(  "iCh3.time", times[3] );
    this.mRenderer.SetShaderConstant3F(  "iCh0.size", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iCh1.size", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iCh2.size", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iCh3.size", resos[9], resos[10], resos[11] );
    this.mRenderer.SetShaderConstant1I(  "iCh0.loaded", texIsLoaded[0] );
    this.mRenderer.SetShaderConstant1I(  "iCh1.loaded", texIsLoaded[1] );
    this.mRenderer.SetShaderConstant1I(  "iCh2.loaded", texIsLoaded[2] );
    this.mRenderer.SetShaderConstant1I(  "iCh3.loaded", texIsLoaded[3] );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    if( (vrData !== null) && this.mSupportsVR )
    {
        for (let i=0; i<2; i++ )
        {
            let ei = (i===0) ? vrData.mLeftEye : vrData.mRightEye;

            let vp = [i * xres / 2, 0, xres / 2, yres];

            this.mRenderer.SetViewport(vp);

            let fov = ei.mProjection;
            let corA = [ -fov[2], -fov[1], -1.0 ];
            let corB = [  fov[3], -fov[1], -1.0 ];
            let corC = [  fov[3],  fov[0], -1.0 ];
            let corD = [ -fov[2],  fov[0], -1.0 ];
            let apex = [ 0.0, 0.0, 0.0 ];

            let ma = invertFast( ei.mCamera );
            corA = matMulpoint( ma, corA ); 
            corB = matMulpoint( ma, corB ); 
            corC = matMulpoint( ma, corC ); 
            corD = matMulpoint( ma, corD ); 
            apex = matMulpoint( ma, apex ); 

            let corners = [ corA[0], corA[1], corA[2], 
                            corB[0], corB[1], corB[2], 
                            corC[0], corC[1], corC[2], 
                            corD[0], corD[1], corD[2],
                            apex[0], apex[1], apex[2]];

            this.mRenderer.SetShaderConstant3FV("unCorners", corners);
            this.mRenderer.SetShaderConstant4FV("unViewport", vp);

            this.mRenderer.DrawUnitQuad_XY(l1);
        }
    }
    else 
    {
        this.mRenderer.SetViewport([0, 0, xres, yres]);
        this.mRenderer.DrawFullScreenTriangle_XY( l1 );
    }

    this.mRenderer.DettachTextures();
}

EffectPass.prototype.iRenderSound = function(d, callback )
{
    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds() ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    this.mRenderer.SetRenderTarget(this.mRenderFBO);

    this.mRenderer.SetViewport([0, 0, this.mTextureDimensions, this.mTextureDimensions]);
    this.mRenderer.AttachShader(this.mProgram);
    this.mRenderer.SetBlend( false );

    let texID = [null, null, null, null];
    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
    }

    this.mRenderer.AttachTextures(4, texID[0], texID[1], texID[2], texID[3]);

    let l2 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iTimeOffset");
    let l3 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iSampleOffset");
    this.mRenderer.SetShaderConstant4FV("iDate", dates);
    this.mRenderer.SetShaderConstant3FV("iChannelResolution", resos);
    this.mRenderer.SetShaderConstant1F("iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit("iChannel0", 0);
    this.mRenderer.SetShaderTextureUnit("iChannel1", 1);
    this.mRenderer.SetShaderTextureUnit("iChannel2", 2);
    this.mRenderer.SetShaderTextureUnit("iChannel3", 3);

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    //--------------------------------
    let numSamples = this.mTmpBufferSamples;
    let numBlocks = this.mPlaySamples / numSamples;
    for (let j=0; j<numBlocks; j++ )
    {
        let off = j*numSamples;
        
        this.mRenderer.SetShaderConstant1F_Pos(l2, off / this.mSampleRate);
        this.mRenderer.SetShaderConstant1I_Pos(l3, off );
        this.mRenderer.DrawUnitQuad_XY(l1);

        this.mRenderer.GetPixelData(this.mData, 0, this.mTextureDimensions, this.mTextureDimensions);

        callback( off, this.mData, numSamples );
    }

    this.mRenderer.DetachShader();
    this.mRenderer.DettachTextures();
    this.mRenderer.SetRenderTarget(null);
}

EffectPass.prototype.Paint_Sound = function( wa, d )
{
    let bufL = this.mBuffer.getChannelData(0); // Float32Array
    let bufR = this.mBuffer.getChannelData(1); // Float32Array

    this.iRenderSound( d, function(off, data, numSamples)
                         {
                            for( let i=0; i<numSamples; i++ )
                            {
                                bufL[off+i] = -1.0 + 2.0*(data[4*i+0]+256.0*data[4*i+1])/65535.0;
                                bufR[off+i] = -1.0 + 2.0*(data[4*i+2]+256.0*data[4*i+3])/65535.0;
                            }
                         }
                     );
}

EffectPass.prototype.SetUniforms = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    //------------------------
    
    let texID = [ null, null, null, null];

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
        }
        else if( inp.mInfo.mType=="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
    
                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                }
            }

        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
           if( inp.loaded===true )
           { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                times[i] = 10.0 + time;
            }

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = buffers[inp.id].mTexture[ buffers[inp.id].mLastRenderDone ];
                resos[3*i+0] = buffers[inp.id].mResolution[0];
                resos[3*i+1] = buffers[inp.id].mResolution[1];
                resos[3*i+2] = 1;
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    this.mRenderer.AttachShader(this.mProgram);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F(  "iFrameRate", fps );

    this.mRenderer.SetShaderConstant1F(  "iChannel[0].time",       times[0] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[1].time",       times[1] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[2].time",       times[2] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[3].time",       times[3] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[0].resolution", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[1].resolution", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[2].resolution", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[3].resolution", resos[9], resos[10], resos[11] );
}

EffectPass.prototype.ProcessInputs = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
        }
        else if( inp.mInfo.mType==="volume" )
        {
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );
                }
                else if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                if( inp.audio.mForceMuted === true )
                {
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                let id = inp.id;
                let texID = buffers[id].mTexture[ buffers[id].mLastRenderDone ];

                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID, filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
				let id = inp.id;
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }
}

EffectPass.prototype.Paint_Cubemap = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face )
{
    this.ProcessInputs(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
    this.SetUniforms(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    let vp = [0, 0, xres, yres];

    this.mRenderer.SetViewport(vp);

    let corA = [-1.0, -1.0, -1.0];
    let corB = [ 1.0, -1.0, -1.0];
    let corC = [ 1.0,  1.0, -1.0];
    let corD = [-1.0,  1.0, -1.0];
    let apex = [ 0.0,  0.0,  0.0];

         if( face===0 ) { corA=[ 1.0,  1.0,  1.0]; corB=[ 1.0,  1.0, -1.0]; corC=[ 1.0, -1.0, -1.0]; corD=[ 1.0, -1.0,  1.0]; }
    else if( face===1 ) { corA=[-1.0,  1.0, -1.0]; corB=[-1.0,  1.0,  1.0]; corC=[-1.0, -1.0,  1.0]; corD=[-1.0, -1.0, -1.0]; }
    else if( face===2 ) { corA=[-1.0,  1.0, -1.0]; corB=[ 1.0,  1.0, -1.0]; corC=[ 1.0,  1.0,  1.0]; corD=[-1.0,  1.0,  1.0]; }
    else if( face===3 ) { corA=[-1.0, -1.0,  1.0]; corB=[ 1.0, -1.0,  1.0]; corC=[ 1.0, -1.0, -1.0]; corD=[-1.0, -1.0, -1.0]; }
    else if( face===4 ) { corA=[-1.0,  1.0,  1.0]; corB=[ 1.0,  1.0,  1.0]; corC=[ 1.0, -1.0,  1.0]; corD=[-1.0, -1.0,  1.0]; }
    else if( face===5 ) { corA=[ 1.0,  1.0, -1.0]; corB=[-1.0,  1.0, -1.0]; corC=[-1.0, -1.0, -1.0]; corD=[ 1.0, -1.0, -1.0]; }

    let corners = [ corA[0], corA[1], corA[2], 
                    corB[0], corB[1], corB[2], 
                    corC[0], corC[1], corC[2], 
                    corD[0], corD[1], corD[2],
                    apex[0], apex[1], apex[2]];

    this.mRenderer.SetShaderConstant3FV("unCorners", corners);
    this.mRenderer.SetShaderConstant4FV("unViewport", vp);

    this.mRenderer.DrawUnitQuad_XY(l1);

    this.mRenderer.DettachTextures();
}

EffectPass.prototype.Paint = function( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, bufferNeedsMimaps, buffers, cubeBuffers, keyboard, effect )
{
    if( this.mType==="sound" )
    {
        if (this.mSoundShaderCompiled === true)
        {
            // make sure all textures are loaded
            for (let i=0; i<this.mInputs.length; i++ )
            {
                let inp = this.mInputs[i];
                if (inp === null) continue;

                if (inp.mInfo.mType === "texture" && !inp.loaded) return;
                if (inp.mInfo.mType === "cubemap" && !inp.loaded) return;
            }

            this.Paint_Sound(wa, da);
            this.mSoundShaderCompiled = false;
        }
        if (this.mFrame === 0)
        {
            if (this.mPlaying===true)
            {
                this.mPlayNode.disconnect();
                this.mPlayNode.stop();
                this.mPlayNode = null;
            }
            this.mPlaying = true;

            this.mPlayNode = wa.createBufferSource();
            this.mPlayNode.buffer = this.mBuffer;
            this.mPlayNode.connect(this.mGainNode);
            this.mPlayNode.start(0);
        }
        this.mFrame++;
    }
    else if( this.mType==="image" )
    {
        this.mRenderer.SetRenderTarget( null );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );
        this.mFrame++;
    }
    else if( this.mType==="common" )
    {
    }
    else if( this.mType==="buffer" )
    {
        this.mEffect.ResizeBuffer(bufferID, this.mEffect.mXres, this.mEffect.mYres, false );

        let buffer = buffers[bufferID];

        let dstID = 1 - buffer.mLastRenderDone;

        this.mRenderer.SetRenderTarget( buffer.mTarget[dstID] );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }

        // make thumbnail
        //if( this.mTextureCallbackFun != null )
        /*
        {
            this.mRenderer.SetRenderTarget( buffer.mThumbnailRenderTarget );
            let v = [0, 0, buffer.mThumbnailRes[0], buffer.mThumbnailRes[1]];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            this.mRenderer.SetShaderConstant4FV("v", v);
            this.mRenderer.AttachTextures(1, buffer.mTexture[dstID], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);
            this.mRenderer.DettachTextures();
            this.mRenderer.DetachShader();
            this.mRenderer.GetPixelData( new Uint8Array(buffer.mThumbnailBuffer.data.buffer), buffer.mThumbnailRes[0], buffer.mThumbnailRes[1] );
            this.mRenderer.SetRenderTarget(null);
        }
        */
        buffers[bufferID].mLastRenderDone = 1 - buffers[bufferID].mLastRenderDone;
        this.mFrame++;
    }
    else if( this.mType==="cubemap" )
    {
        this.mEffect.ResizeCubemapBuffer(bufferID, 1024, 1024, false );

        let buffer = cubeBuffers[bufferID];

        xres = buffer.mResolution[0];
        yres = buffer.mResolution[1];
        let dstID = 1 - buffer.mLastRenderDone;
        for( let face=0; face<6; face++ )
        {
            this.mRenderer.SetRenderTargetCubeMap( buffer.mTarget[dstID], face );
            this.Paint_Cubemap( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
        }
        this.mRenderer.SetRenderTargetCubeMap( null, 0 );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }
        cubeBuffers[bufferID].mLastRenderDone = 1 - cubeBuffers[bufferID].mLastRenderDone;

        this.mFrame++;
    }
}

EffectPass.prototype.StopOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;
    this.mPlayNode.disconnect();
}

EffectPass.prototype.ResumeOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;

    wa.resume()
    this.mPlayNode.connect( this.mGainNode );
}

EffectPass.prototype.StopOutput_Image = function( wa )
{
}

EffectPass.prototype.ResumeOutput_Image = function( wa )
{
}

EffectPass.prototype.StopOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.StopInput(j);

    if( this.mType==="sound" )
         this.StopOutput_Sound( wa );
    else
         this.StopOutput_Image( wa );
}

EffectPass.prototype.ResumeOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.ResumeInput(j);

    if( this.mType==="sound" )
         this.ResumeOutput_Sound( wa );
    else
         this.ResumeOutput_Image( wa );
}

EffectPass.prototype.GetCompilationTime = function()
{
    return this.mCompilationTime;
}

//============================================================================================================
function Screenshots()
{
    // private
    let mTexture = null;
    let mTarget = null;
    let mXres = 0;
    let mYres = 0;
    let mCubemapToEquirectProgram;
    let mRenderer = null;

    // public
    var me = {};

    me.Initialize = function(renderer)
    {
        mRenderer = renderer;
        let caps = mRenderer.GetCaps();
        let is20 = caps.mIsGL20;

        let vsSourceC, fsSourceC;
        if( is20 )
        {
            vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; out vec4 outColor; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); outColor = texture(t, rd); }";
        }
        else
        {
            vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); gl_FragColor = texture(t, rd); }";
        }

        let compileShader = function (worked, info)
        {
            if (worked === false)
            {
                console.log("Failed to compile cubemap resample shader (" + errorType + "): " + log);
            }
            else
            {
                mCubemapToEquirectProgram = info;
            }
        }
        mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, compileShader);

        return true;
    };

    me.Allocate = function( xres, yres )
    {
        if( xres>mXres || yres>mYres )
        {
            let texture = mRenderer.CreateTexture(mRenderer.TEXTYPE.T2D, xres, yres, mRenderer.TEXFMT.C4F32, mRenderer.FILTER.NONE, mRenderer.TEXWRP.CLAMP, null);
            let target = mRenderer.CreateRenderTarget( texture, null, null, null, null, false);

            if( mXres!==0 )
            {
                mRenderer.DestroyTexture(mTexture);
                mRenderer.DestroyRenderTarget(mTarget);
            }

            mTexture = texture;
            mTarget = target;
            mXres = xres;
            mYres = yres;
        }
    };

    me.GetProgram = function()
    {
        return mCubemapToEquirectProgram;
    };
    me.GetTarget = function()
    {
        return mTarget;
    };

    return me;
};

//============================================================================================================

function Effect(vr, ac, canvas, callback, obj, forceMuted, forcePaused, resizeCallback, crashCallback )
{
    let xres = canvas.width;
    let yres = canvas.height;

    let me = this;
    this.mCanvas = canvas;
    this.mCreated = false;
    this.mRenderer = null;
    this.mAudioContext = ac;
    this.mGLContext = null;
    this.mWebVR = vr;
    this.mRenderingStereo = false;
    this.mXres = xres;
    this.mYres = yres;
    this.mForceMuted = forceMuted;
    if( ac===null ) this.mForceMuted = true;
    this.mForcePaused = forcePaused;
    this.mGainNode = null;
    this.mPasses = [];
    this.mFrame = 0;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mMaxBuffers = 4;
    this.mMaxCubeBuffers = 1;
    this.mMaxPasses = this.mMaxBuffers + 1 + 1 + 1 + 1; // some day decouple passes from buffers (4 buffers + common + Imagen + sound + cubemap)
    this.mBuffers = [];
    this.mCubeBuffers = [];
    this.mScreenshotSytem = null;
    this.mCompilationTime = 0;
    this.mIsLowEnd = piIsMobile();

    this.mGLContext = piCreateGlContext(canvas, false, false, true, false); // need preserve-buffe to true in order to capture screenshots
    if (this.mGLContext === null)
    {
        return;
    }

    canvas.addEventListener("webglcontextlost", function (event)
        {
            event.preventDefault();
            crashCallback();
        }, false);

    this.mRenderer = piRenderer();
    if (!this.mRenderer.Initialize(this.mGLContext))
        return;

    this.mScreenshotSytem = Screenshots();
    if (!this.mScreenshotSytem.Initialize(this.mRenderer))
        return;

    var caps = this.mRenderer.GetCaps();
    this.mIs20 = caps.mIsGL20;
    this.mShaderTextureLOD = caps.mShaderTextureLOD;
    //-------------
    if( ac!==null )
    {   
        this.mGainNode = ac.createGain();
        if( !forceMuted )
        {
            this.mGainNode.connect( ac.destination);
        }
        if (this.mForceMuted )
            this.mGainNode.gain.value = 0.0;
        else
            this.mGainNode.gain.value = 1.0;
    }

    //-------------
    let vsSourceC, fsSourceC;
    if( this.mIs20 )
    {
        vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { outColor = textureLod(t, gl_FragCoord.xy / v.zw, 0.0); }";
    }
    else
    {
        vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; void main() { gl_FragColor = texture2D(t, gl_FragCoord.xy / v.zw, -100.0); }";
    }

    this.mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, function(worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to copy buffers : " + info.mErrorStr);
            else me.mProgramCopy = info;
        });

    let vsSourceD, fsSourceD;
    if( this.mIs20 )
    {
        vsSourceD = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { vec2 uv = gl_FragCoord.xy / v.zw; outColor = texture(t, vec2(uv.x,1.0-uv.y)); }";
    }
    else
    {
        vsSourceD = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; void main() { vec2 uv = gl_FragCoord.xy / v.zw; gl_FragColor = texture2D(t, vec2(uv.x,1.0-uv.y)); }";
    }

    this.mRenderer.CreateShader(vsSourceD, fsSourceD, false, true, function (worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to downscale buffers : " + info.mErrorStr);
            else me.mProgramDownscale = info;
        });


    // set all buffers and cubemaps to null
    for( let i=0; i<this.mMaxBuffers; i++ )
    {
        this.mBuffers[i] = { mTexture: [null, null], 
                             mTarget:  [null, null], 
                             mResolution: [0, 0],
                             mLastRenderDone: 0,
                             mThumbnailRenderTarget: null,
                             mThumbnailTexture: null,
                             mThumbnailBuffer:  null,
                             mThumbnailRes: [0, 0] };
    }

    for( let i=0; i<this.mMaxCubeBuffers; i++ )
    {
        this.mCubeBuffers[i] = { mTexture: [null, null], 
                                mTarget:  [null, null], 
                                mResolution: [0, 0],
                                mLastRenderDone: 0,
                                mThumbnailRenderTarget: null,
                                mThumbnailTexture: null,
                                mThumbnailBuffer:  null,
                                mThumbnailRes: [0, 0] };
    }

    //-------

    let keyboardData = new Uint8Array( 256*3 );
    for (let j=0; j<(256*3); j++ ) { keyboardData[j] = 0; }
    let kayboardTexture = this.mRenderer.CreateTexture( this.mRenderer.TEXTYPE.T2D, 256, 3, this.mRenderer.TEXFMT.C1I8, this.mRenderer.FILTER.NONE, this.mRenderer.TEXWRP.CLAMP, null);
    let keyboardImage = new Image();
    if( callback!==null )
        keyboardImage.src = "/img/keyboard.png"; // don't load PNG if no UI 
    this.mKeyboard = { mData: keyboardData, mTexture: kayboardTexture, mIcon: keyboardImage };

    let iResize = function( xres, yres )
    {
        me.mCanvas.width = xres;
        me.mCanvas.height = yres;
        me.mXres = xres;
        me.mYres = yres;
        me.ResizeBuffers(xres, yres);
        resizeCallback(xres, yres);
    };

    let bestAttemptFallback = function()
    {
        let devicePixelRatio = window.devicePixelRatio || 1;
        let xres = Math.round(me.mCanvas.offsetWidth  * devicePixelRatio) | 0;
        let yres = Math.round(me.mCanvas.offsetHeight * devicePixelRatio) | 0;
        iResize(xres, yres);
    };

    if(!window.ResizeObserver)
    {
        console.log("WARNING: This browser doesn't support ResizeObserver.");
        bestAttemptFallback();
        window.addEventListener("resize", bestAttemptFallback);
    }
    else
    {
        this.mRO = new ResizeObserver( function(entries, observer)
        {
            var entry = entries[0];
            if (!entry['devicePixelContentBoxSize'])
            {
                observer.unobserve(me.mCanvas);
                console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (2)");
                bestAttemptFallback();
                window.addEventListener("resize", bestAttemptFallback);
            }
            else
            {
                let box = entry.devicePixelContentBoxSize[0];
                let xres = box.inlineSize;
                let yres = box.blockSize;
                iResize(xres, yres);
            }
        });
        try
        {
            this.mRO.observe(this.mCanvas, { box: ["device-pixel-content-box"] });
            //this.mRO.observe(this.mCanvas);
        }
        catch (e)
        {
            console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (1)");
            bestAttemptFallback();
            window.addEventListener("resize", bestAttemptFallback);
        }
    }

    this.mCreated = true;
}

Effect.prototype.ResizeCubemapBuffer = function(i, xres, yres )
{
    let oldXres = this.mCubeBuffers[i].mResolution[0];
    let oldYres = this.mCubeBuffers[i].mResolution[1];

    if( this.mCubeBuffers[i].mTexture[0]===null || oldXres !== xres || oldYres !== yres )
    {
        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);
        let target1 = this.mRenderer.CreateRenderTargetCubeMap( texture1, null, false);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target2 = this.mRenderer.CreateRenderTargetCubeMap( texture2, null, false);

        // Store new buffers
        this.mCubeBuffers[i].mTexture = [texture1,texture2], 
        this.mCubeBuffers[i].mTarget =  [target1, target2 ], 
        this.mCubeBuffers[i].mLastRenderDone = 0;
        this.mCubeBuffers[i].mResolution[0] = xres;
        this.mCubeBuffers[i].mResolution[1] = yres;
    }
}

Effect.prototype.ResizeBuffer = function( i, xres, yres, skipIfNotExists )
{
    if( skipIfNotExists && this.mBuffers[i].mTexture[0]===null ) return;

    let oldXres = this.mBuffers[i].mResolution[0];
    let oldYres = this.mBuffers[i].mResolution[1];

    if( oldXres !== xres || oldYres !== yres )
    {
        let needCopy = (this.mBuffers[i].mTexture[0]!==null);

        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[0].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[0].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[1].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[1].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target1 = this.mRenderer.CreateRenderTarget( texture1, null, null, null, null, false);
        let target2 = this.mRenderer.CreateRenderTarget( texture2, null, null, null, null, false);

        if( needCopy )
        {
            let v = [0, 0, Math.min(xres, oldXres), Math.min(yres, oldYres)];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            let vOld = [0, 0, oldXres, oldYres];
            this.mRenderer.SetShaderConstant4FV("v", vOld);

            // Copy old buffers 1 to new buffer
            this.mRenderer.SetRenderTarget(target1);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[0], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Copy old buffers 2 to new buffer
            this.mRenderer.SetRenderTarget(target2);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[1], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Deallocate old memory
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[0]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[0]);
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[1]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[1]);
            //this.mRenderer.DestroyTexture(this.mBuffers[i].thumbnailTexture);
        }

        // Store new buffers
        this.mBuffers[i].mTexture = [texture1,texture2], 
        this.mBuffers[i].mTarget =  [target1, target2 ], 
        this.mBuffers[i].mLastRenderDone = 0;
        this.mBuffers[i].mResolution[0] = xres;
        this.mBuffers[i].mResolution[1] = yres;
    }
}

Effect.prototype.saveScreenshot = function(passid)
{
    let pass = this.mPasses[passid];

    if( pass.mType === "buffer" )
    {
        let bufferID = assetID_to_bufferID( this.mPasses[passid].mOutputs[0] );

        let texture = this.mBuffers[bufferID].mTarget[ this.mBuffers[bufferID].mLastRenderDone ];

        let numComponents = 3;
        let width = texture.mTex0.mXres;
        let height = texture.mTex0.mYres;
        let type = "Float"; // Other options Float, Half, Uint
        let bytes = new Float32Array(width * height * 4 );//numComponents);
        this.mRenderer.GetPixelDataRenderTarget( texture, bytes, width, height );
        let blob = piExportToEXR(width, height, numComponents, type, bytes);

        // Offer download automatically to the user
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "cubemap" )
    {
        let xres = 4096;
        let yres = 2048;
        this.mScreenshotSytem.Allocate( xres, yres );

        let cubeBuffer = this.mCubeBuffers[0];

        let target = this.mScreenshotSytem.GetTarget();
        this.mRenderer.SetRenderTarget( target );

        let program = this.mScreenshotSytem.GetProgram();

        this.mRenderer.AttachShader(program);
        let l1 = this.mRenderer.GetAttribLocation(program, "pos");
        this.mRenderer.SetViewport( [0, 0, xres, yres] );
        this.mRenderer.AttachTextures(1, cubeBuffer.mTexture[ cubeBuffer.mLastRenderDone ], null, null, null);
        this.mRenderer.DrawUnitQuad_XY(l1);
        this.mRenderer.DettachTextures();
        this.mRenderer.SetRenderTarget( null );

        let data = new Float32Array(xres*yres*4);
        this.mRenderer.GetPixelDataRenderTarget( target, data, xres, yres );

        let blob = piExportToEXR(xres, yres, 3, "Float", data );
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "sound" )
    {
        let offset = 0;
        const bits = 16;
        const numChannels = 2;
        let words = new Int16Array(60*pass.mSampleRate*numChannels );

        pass.iRenderSound( new Date(), function(off, data, numSamples)
                                         {
                                            for( let i=0; i<numSamples; i++ )
                                            {
                                                words[offset++] = (data[4*i+0]+256.0*data[4*i+1]) - 32767;
                                                words[offset++] = (data[4*i+2]+256.0*data[4*i+3]) - 32767;
                                            }
                                         }
                                     );

        let blob = piExportToWAV( 60*pass.mSampleRate, pass.mSampleRate, bits, numChannels, words);

        piTriggerDownload("sound.wav", blob);
    }    
}

Effect.prototype.ResizeBuffers = function(xres, yres)
{
    for (let i=0; i<this.mMaxBuffers; i++ )
    {
        this.ResizeBuffer(i, xres, yres, true);
    }
}

Effect.prototype.IsEnabledVR = function ()
{
    if (this.mRenderingStereo) return true;
    return false;
}

Effect.prototype.EnableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( this.mRenderingStereo ) return;

    this.mRenderingStereo = true;
    this.mWebVR.Enable();
}

Effect.prototype.DisableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( !this.mRenderingStereo ) return;

    this.mRenderingStereo = false;
    this.mWebVR.Disable();
}

Effect.prototype.GetTexture = function( passid, slot ) { return this.mPasses[passid].GetTexture( slot ); }
Effect.prototype.NewTexture = function (passid, slot, url) { return this.mPasses[passid].NewTexture( this.mAudioContext, slot, url, this.mBuffers, this.mCubeBuffers, this.mKeyboard ); }
Effect.prototype.SetOutputs = function( passid, slot, url ) { this.mPasses[passid].SetOutputs( slot, url ); }
Effect.prototype.SetOutputsByBufferID = function( passid, slot, id ) { this.mPasses[passid].SetOutputsByBufferID( slot, id ); }
Effect.prototype.GetAcceptsLinear = function (passid, slot) { return this.mPasses[passid].GetAcceptsLinear(slot); }
Effect.prototype.GetAcceptsMipmapping = function (passid, slot) { return this.mPasses[passid].GetAcceptsMipmapping(slot); }
Effect.prototype.GetAcceptsWrapRepeat = function (passid, slot) { return this.mPasses[passid].GetAcceptsWrapRepeat(slot); }
Effect.prototype.GetAcceptsVFlip = function (passid, slot) { return this.mPasses[passid].GetAcceptsVFlip(slot); }
Effect.prototype.SetSamplerFilter = function (passid, slot, str) { this.mPasses[passid].SetSamplerFilter(slot, str, this.mBuffers, this.mCubeBuffers); }
Effect.prototype.GetTranslatedShaderSource = function (passid) { return this.mPasses[passid].GetTranslatedShaderSource(); }
Effect.prototype.GetSamplerFilter = function (passid, slot) { return this.mPasses[passid].GetSamplerFilter(slot); }
Effect.prototype.SetSamplerWrap = function (passid, slot, str) { this.mPasses[passid].SetSamplerWrap(slot, str, this.mBuffers); }
Effect.prototype.GetSamplerWrap = function (passid, slot) { return this.mPasses[passid].GetSamplerWrap(slot); }
Effect.prototype.SetSamplerVFlip = function (passid, slot, str) { this.mPasses[passid].SetSamplerVFlip(slot, str); }
Effect.prototype.GetSamplerVFlip = function (passid, slot) { return this.mPasses[passid].GetSamplerVFlip(slot); }

Effect.prototype.GetHeaderSize = function (passid)
{
    return this.mPasses[passid].mHeaderLength + 
           this.mRenderer.GetShaderHeaderLines(1);
}

Effect.prototype.ToggleVolume = function()
{
    this.mForceMuted = !this.mForceMuted;

    // outp
    if (this.mForceMuted)
        this.mGainNode.gain.value = 0.0;
    else
        this.mGainNode.gain.value = 1.0;

    // inp
    let num = this.mPasses.length;
    for( let j=0; j<num; j++ )
    {
        for( let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            if( this.mForceMuted )
                this.mPasses[j].MuteInput( this.mAudioContext, i );
            else
                this.mPasses[j].UnMuteInput( this.mAudioContext, i );
        }
    }

    return this.mForceMuted;
}

Effect.prototype.SetKeyDown = function( passid, k )
{
    if( this.mKeyboard.mData[ k + 0*256 ] == 255 ) return;

    this.mKeyboard.mData[ k + 0*256 ] = 255;
    this.mKeyboard.mData[ k + 1*256 ] = 255;
    this.mKeyboard.mData[ k + 2*256 ] = 255 - this.mKeyboard.mData[ k + 2*256 ];
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }
}

Effect.prototype.SetKeyUp = function( passid, k )
{
    this.mKeyboard.mData[ k + 0*256 ] = 0;
    this.mKeyboard.mData[ k + 1*256 ] = 0;
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }
}

Effect.prototype.StopOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].StopOutput( wa );
    }
}

Effect.prototype.ResumeOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].ResumeOutput( wa );
    }
}

Effect.prototype.PauseInput = function( passid, id )
{
    return this.mPasses[passid].TooglePauseInput( this.mAudioContext, id );
}

Effect.prototype.ToggleMuteInput = function( passid, id )
{
    return this.mPasses[passid].ToggleMuteInput( this.mAudioContext, id );
}

Effect.prototype.RewindInput = function( passid, id )
{
    this.mPasses[passid].RewindInput( this.mAudioContext, id );
}

Effect.prototype.UpdateInputs = function( passid, forceUpdate )
{
   this.mPasses[passid].UpdateInputs( this.mAudioContext, forceUpdate, this.mKeyboard );
}

Effect.prototype.ResetTime = function()
{
    this.mFrame = 0;
    this.mAudioContext.resume()

    let num = this.mPasses.length;
    for( let i=0; i<num; i++ )
    {
        this.mPasses[i].mFrame = 0;
        for( let j=0; j<this.mPasses[i].mInputs.length; j++ )
            this.mPasses[i].RewindInput(this.mAudioContext, j)
    }
}

Effect.prototype.RequestAnimationFrame = function (id)
{
    if (this.mRenderingStereo && this.mWebVR.IsPresenting())
    {
        this.mWebVR.RequestAnimationFrame(id);
    }
    else
    {
        requestAnimFrame(id);
    }
}

Effect.prototype.Paint = function(time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, isPaused)
{
    let wa = this.mAudioContext;
    let da = new Date();
    let vrData = null; if (this.mRenderingStereo) vrData = this.mWebVR.GetData();
    let xres = this.mXres / 1;
    let yres = this.mYres / 1;

    if( this.mFrame===0 )
    {
        for( let i=0; i<this.mMaxBuffers; i++ )
        {
            if( this.mBuffers[i].mTexture[0]!==null )
            {
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[0] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[1] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
				
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[0] );
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[1] );
            }
        }
        for( let i=0; i<this.mMaxCubeBuffers; i++ )
        {
            if( this.mCubeBuffers[i].mTexture[0]!==null )
            {
                for( let face=0; face<6; face++ )
                {
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[0], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[1], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
					this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[0] );
				    this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[1] );
                }
            }
        }
    }

    let num = this.mPasses.length;

    // render sound first
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "sound" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "buffer" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;
        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="buffer" && inp.id === bufferID && inp.mInfo.mSampler.filter === "mipmap")
                {
                    needMipMaps = true;
                    break;
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render cubemap buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "cubemap" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = 0;//assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;

        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="cubemap" )
                {
                    if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0 && inp.mInfo.mSampler.filter === "mipmap" )
                    {
                        needMipMaps = true;
                        break;
                    }
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render image last
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "image" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }   

    // erase keypresses
    for (let k=0; k<256; k++ )
    {
       this.mKeyboard.mData[ k + 1*256 ] = 0;
    }
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    if( this.mRenderingStereo ) this.mWebVR.Finish();

    this.mFrame++;
}

Effect.prototype.NewShader = function( passid, preventCache, onResolve )
{
    let commonSourceCodes = [];
    for (let i=0; i<this.mPasses.length; i++ )
    {
        if( this.mPasses[i].mType==="common")
        {
            commonSourceCodes.push(this.mPasses[i].mSource);
        }
    }

    this.mPasses[passid].NewShader(commonSourceCodes, preventCache, onResolve );
}

Effect.prototype.GetNumPasses = function()
{
    return this.mPasses.length;
}

Effect.prototype.GetNumOfType = function(passtype)
{
    let id = 0;
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType===passtype )
        {
            id++;
        }
    }
    return id;
}

Effect.prototype.GetPassType = function( id ) { return this.mPasses[id].mType; }
Effect.prototype.GetPassName = function( id ) { return this.mPasses[id].mName; }
Effect.prototype.GetCode = function( id ) { return this.mPasses[id].mSource; }
Effect.prototype.SetCode = function( id, source ) { this.mPasses[id].SetCode(source); }
Effect.prototype.GetError = function (id) { return this.mPasses[id].mError; }
Effect.prototype.GetErrorStr = function (id) { return this.mPasses[id].mErrorStr; }
Effect.prototype.GetErrorGlobal = function()
{
    for (let i = 0; i < this.mPasses.length; i++)
    {
        if (this.mPasses[i].mError)
        {
            return true;
        }
    }
    return false;
}

Effect.prototype.Load = function (jobj )
{
    if (jobj.ver !== "0.1")
    {
        console.log("Wrong Format");
        return false;
    }

    let numPasses = jobj.renderpass.length;

    if( numPasses<1 || numPasses>this.mMaxPasses )
    {
        console.log("Corrupted Shader - " + numPasses);
        return false;
    }

    this.mPasses = [];
    for (let j = 0; j < numPasses; j++)
    {
        let rpass = jobj.renderpass[j];

        // skip sound passes if in thumbnail mode
        if( this.mForceMuted && rpass.type === "sound" ) continue;

        let wpass = new EffectPass(this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                   this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode,
                                   this.mProgramDownscale, j, this);

        wpass.Create(rpass.type, this.mAudioContext);

        let numInputs = rpass.inputs.length;

        for (let i = 0; i < 4; i++)
        {
            wpass.NewTexture(this.mAudioContext, i, null, null, null);
        }
        for (let i = 0; i < numInputs; i++)
        {
            let lid  = rpass.inputs[i].channel;
            let styp = rpass.inputs[i].type;
            let sid  = rpass.inputs[i].id;
            let ssrc = rpass.inputs[i].filepath;
            let psrc = rpass.inputs[i].previewfilepath;
            let samp = rpass.inputs[i].sampler;

            wpass.NewTexture(this.mAudioContext, lid, { mType: styp, mID: sid, mSrc: ssrc, mSampler: samp, mPreviewSrc: psrc }, this.mBuffers, this.mCubeBuffers, this.mKeyboard);
        }

        for (let i = 0; i < 4; i++)
        {
            wpass.SetOutputs(i, null);
        }

        let numOutputs = rpass.outputs.length;
        for (let i = 0; i < numOutputs; i++)
        {
            let outputID = rpass.outputs[i].id;
            let outputCH = rpass.outputs[i].channel;
            wpass.SetOutputs(outputCH, outputID);
        }

        // create some hardcoded names. This should come from the DB
        let rpassName = "";
        if (rpass.type === "common" ) rpassName = "Common";
        if (rpass.type === "sound"  ) rpassName = "Sound";
        if (rpass.type === "image"  ) rpassName = "Image";
        if (rpass.type === "buffer") rpassName = "Buffer " + String.fromCharCode(65 + assetID_to_bufferID(wpass.mOutputs[0]));
        if (rpass.type === "cubemap") rpassName = "Cube A";// " + String.fromCharCode(65 + assetID_to_bufferID(this.mPasses[j].mOutputs[0]));
        wpass.SetName(rpassName);
        wpass.SetCode(rpass.code);

        this.mPasses.push(wpass);
    }
    return true;
}

Effect.prototype.CompileSome = function ( passes, preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    for (let j = 0; j < passes.length; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(passes[j], preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < me.mPasses.length; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.Compile = function (preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(j, preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < numPasses; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.GetCompilationTime = function( id )
{
    return this.mPasses[id].GetCompilationTime()/1000.0;
}
Effect.prototype.GetTotalCompilationTime = function()
{
    return this.mCompilationTime/1000.0;
}

Effect.prototype.DestroyPass = function( id )
{
   this.mPasses[id].Destroy( this.mAudioContext );
   this.mPasses.splice(id, 1);
}

Effect.prototype.AddPass = function( passType, passName, onResolve )
{
    let shaderStr = null;

    if( passType==="sound"   ) shaderStr = "vec2 mainSound( int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n}";
    if( passType==="buffer"  ) shaderStr = "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}";
    if( passType==="common"  ) shaderStr = "vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}";
    if( passType==="cubemap" ) shaderStr = "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rayDir;\n\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}";

    let id = this.GetNumPasses();
    this.mPasses[id] = new EffectPass( this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                       this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode, 
                                       this.mProgramDownscale, id, this );

    this.mPasses[id].Create( passType, this.mAudioContext );
    this.mPasses[id].SetName( passName );
    this.mPasses[id].SetCode( shaderStr );
    this.NewShader(id, false, function ()
    {
        onResolve();
    });

    return { mId : id, mShader : shaderStr };
}

// this should be removed once we have MultiPass 2.0 and passes render to arbitrary buffers
Effect.prototype.IsBufferPassUsed = function( bufferID )
{
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType !== "buffer" ) continue;
        if( this.mPasses[j].mOutputs[0] === bufferID_to_assetID(bufferID) ) return true;
    }
    return false;
}

Effect.prototype.Save = function()
{
    var result = {};

    result.ver = "0.1";

    result.renderpass = [];

    let numPasses = this.mPasses.length;
    for (let j=0; j<numPasses; j++ )
    {
        result.renderpass[j] = {};

        result.renderpass[j].outputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            let outputID = this.mPasses[j].mOutputs[i];
            if( outputID===null ) continue;
            result.renderpass[j].outputs.push( { channel: i, id: outputID } );
        }
        result.renderpass[j].inputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            if( this.mPasses[j].mInputs[i]===null ) continue;
            result.renderpass[j].inputs.push( {channel: i,
                                               type    : this.mPasses[j].mInputs[i].mInfo.mType,
                                               id      : this.mPasses[j].mInputs[i].mInfo.mID,
                                               filepath: this.mPasses[j].mInputs[i].mInfo.mSrc,
                                               sampler : this.mPasses[j].mInputs[i].mInfo.mSampler });
        }

        result.renderpass[j].code = this.mPasses[j].mSource;
        result.renderpass[j].name = this.mPasses[j].mName
        result.renderpass[j].description = "";
        result.renderpass[j].type = this.mPasses[j].mType;
    }

    result.flags = this.calcFlags();

    return result;
}

Effect.prototype.calcFlags = function ()
{
    let flagVR = false;
    let flagWebcam = false;
    let flagSoundInput = false;
    let flagSoundOutput = false;
    let flagKeyboard = false;
    let flagMultipass = false;
    let flagMusicStream = false;

    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        let pass = this.mPasses[j];

        if (pass.mType === "sound") flagSoundOutput = true;
        if (pass.mType === "buffer") flagMultipass = true;

        for (let i = 0; i < 4; i++)
        {
            if (pass.mInputs[i] === null) continue;

            if (pass.mInputs[i].mInfo.mType === "webcam") flagWebcam = true;
            else if (pass.mInputs[i].mInfo.mType === "keyboard") flagKeyboard = true;
            else if (pass.mInputs[i].mInfo.mType === "mic") flagSoundInput = true;
            else if (pass.mInputs[i].mInfo.mType === "musicstream") flagMusicStream = true;
        }

        let n1 = pass.mSource.indexOf("mainVR(");
        let n2 = pass.mSource.indexOf("mainVR (");
        if (n1 > 0 || n2 > 0) flagVR = true;
    }

    return {
        mFlagVR: flagVR,
        mFlagWebcam: flagWebcam,
        mFlagSoundInput: flagSoundInput,
        mFlagSoundOutput: flagSoundOutput,
        mFlagKeyboard: flagKeyboard,
        mFlagMultipass: flagMultipass,
        mFlagMusicStream: flagMusicStream
    };
}</script>
    <script>"use strict"

const kMaxCompileTime = 10.0;

function iReportCrash(shaderID)
{
    let req = new XMLHttpRequest();
    req.onload = function ()
    {
        let jsn = req.response;
        if (jsn === null) return;
        if (jsn.result === 0)
        {
            // yep
        }
    };
    req.open("POST", "/shadertoy", true);
    req.responseType = "json";
    req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    req.send( "s=" + shaderID + "&r=2" );
}
</script>
    <script>"use strict"

var gActive = -1;
var mShaders = [];
var gNumCanvases = 0;

function myrefresh( id, slot, img, forceFrame, gui, guiID, renderID, time )
{
    if( mShaders[id].mReady===false ) return;
    if( forceFrame )
    {
        if (mShaders[id].mScreenshot === false)
        {
            mShaders[id].gEffect.Paint(mShaders[id].mTime / 1000.0, 1.0 / 60.0, 60.0, 0, 0, 0, 0, false);
        }
    }
}

function startRendering()
{
    if( gActive<0 ) return;
    if( mShaders[gActive].mReady===false ) return;
    if( mShaders[gActive].mScreenshot===true ) return;

    let time = getRealTime();

    mShaders[gActive].mFPS.Count( time );
    mShaders[gActive].mTime = mShaders[gActive].mTime0 + (time - mShaders[gActive].mTo);
    let dtime = 1000.0/60.0;
    mShaders[gActive].gEffect.Paint( mShaders[gActive].mTime/1000.0, dtime/1000.0, mShaders[gActive].mFPS.GetFPS(), 0,0,0,0, false);

    requestAnimFrame( startRendering );
}

function iLoadAndCompile(jsn, i )
{
    var shaderObj = jsn[i];
    if (shaderObj === null) return;

    var resizeCB = function (xres, yres) { myrefresh(i, 0, null, true, false, 0, -1.0) };
    var crashCB = function () { alert('crash');/*iReportCrash(gShaderIDs[i])*/ };
    mShaders[i].gEffect = new Effect(null, null, mShaders[i].mPreview.mCanvas, myrefresh, i, true, true, resizeCB, crashCB);

    if (!mShaders[i].gEffect.Load(shaderObj)) return;

    mShaders[i].gEffect.Compile(false, function (worked)
    {
        if (worked === true)
        {
            previewShowRender(mShaders[i].mPreview);

            mShaders[i].mScreenshot = false;
            mShaders[i].mReady = true;
            mShaders[i].mTime = 10.0 * 1000.0;
            mShaders[i].mTime0 = 0.0;
            mShaders[i].mTo = 0.0;
            mShaders[i].mFPS = piCreateFPSCounter();
            mShaders[i].mPreview.mCanvas.addEventListener("mouseout", function (ev) { gActive = -1; }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseover", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.add('isVisible'); }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseout", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.remove('isVisible'); }, true);
            mShaders[i].mPreview.mCanvas.addEventListener("mouseover", function (ev)
            {
                let ele = piGetSourceElement(ev);
                if (ele.mId === undefined) return;

                gActive = ele.mId;
                if (!mShaders[gActive].mReady) return;
                let time = getRealTime();
                mShaders[gActive].mTo = time;
                mShaders[gActive].mTime0 = mShaders[gActive].mTime;
                mShaders[gActive].mFPS.Reset(time);

                startRendering();
            }, true);


            /*
            let compilationTime = mShaders[i].gEffect.GetTotalCompilationTime();
            if (compilationTime > kMaxCompileTime)
            {
                iReportCrash(mShaders[i].mShaderID);
            }*/

            myrefresh(i, null, null, true, false, 0, -1.0);
        }
        else
        {
            mShaders[i].mReady = false;
            previewShowError(mShaders[i].mPreview);
        }
    });
};


function iProcessShader( jsn, i )
{
    var shaderObj = jsn[i];
    if( shaderObj===null ) return;

    if ((shaderObj.info.usePreview === 0 && !gUseScreenshots) || (mShaders[i].mPreviewReady !== 1))
    {
        iLoadAndCompile(jsn, i);
    }
    else
    {
        mShaders[i].mScreenshot = true;
        if( shaderObj.info.usePreview === 1 )
            previewShowScreenshot(mShaders[i].mPreview, 1); // comp
        else if (gUseScreenshots)
            previewShowScreenshot(mShaders[i].mPreview, 2); // sett
    }

    if( i<(jsn.length-1) ) setTimeout( function(){iProcessShader(jsn,i+1);}, 10 );
}

function iInitUI(numCanvases, uiCallback, windowTitle)
{
    gNumCanvases = numCanvases;
    document.getElementById("mySearch").focus();

    //-----------------------------------------------------------------
    // window
    //-----------------------------------------------------------------
    if (windowTitle !== null) {
        document.title = windowTitle;
    }

    //-----------------------------------------------------------------
    // ui
    //-----------------------------------------------------------------
    var num = Math.min(gShaders.length, gNumCanvases);

    //var base = document.getElementsByClassName( "searchResult" );

    for (let i = 0; i < gNumCanvases; i++)
    {
        let pv = createPreview(i);

        if (i >= num) {
            previewHide(pv);
            continue;
        }

        let shaderID = gShaders[i].info.id;
        
        if (pv.mUI !== null && uiCallback !== null) {
            pv.mUI.addEventListener('click', function (ev) {
                uiCallback(shaderID);
                ev.preventDefault();
            }, false);
        }
        
        previewShowLoading(pv);
        
        mShaders[i] = {};
        mShaders[i].mShaderID = shaderID;
        mShaders[i].mPreview = pv;
        mShaders[i].mScreenshot = false;
        mShaders[i].mPreview.mLink.href = "/view/" + shaderID;
        mShaders[i].mPreviewReady = 0;
        mShaders[i].mReady = false;
        mShaders[i].gEffect = null;

        previewLoadScreenshot(mShaders[i].mPreview,
            function () { mShaders[i].mPreviewReady = 1; if (mShaders[i].mReady === false) previewShowScreenshot(mShaders[i].mPreview, 0); },
            function () { mShaders[i].mPreviewReady = 2; },
            shaderID);
    }

    if (num <= 0) {
        return;
    }
}

function iInitShaders(jsn)
{
    for (let i = 0; i < jsn.length; i++)
    {
        let shaderObj = jsn[i];
        if (shaderObj === null) continue;
        let inf = shaderObj.info;
        mShaders[i].mPreview.mTextA.textContent = inf.name;
        mShaders[i].mPreview.mTextB.innerHTML = "<a class='user' href='/user/" + htmlEntities(inf.username) + "'>" + htmlEntities(inf.username) + "</a>";
        mShaders[i].mPreview.mTextC.innerHTML = "<img src='/img/themes/" + gThemeName + "/views.png' class='viewsIcon'></img>" + inf.viewed + "    &nbsp;&nbsp;  <img src='/img/themes/" + gThemeName + "/likes.png' class='likesIcon'></img>" + inf.likes;
    }

    setTimeout(function () { iProcessShader(jsn, 0); }, 10);
}

function resultsInitStatic(numCanvases, uiCallback, windowTitle)
{
    iInitUI(numCanvases, uiCallback, windowTitle);

    iInitShaders(gShaders);
}

function resultsInit(numCanvases, uiCallback, windowTitle)
{	
    iInitUI(numCanvases, uiCallback, windowTitle);

    var num = Math.min(gShaderIDs.length, gNumCanvases);

    var mHttpReq = new XMLHttpRequest();

    mHttpReq.abort();

    var str = "{ \"shaders\" : [";
    for( let i=0; i<num; i++ )
    {
         str += "\"" + gShaderIDs[i] + "\"";
         if( i!==(num-1) ) str += ", ";
    }
    str += "] }";

    str = "s=" + encodeURIComponent( str ) + "&nt=0&nl=0&np=0";

    mHttpReq.open( "POST", "/shadertoy", true );
    mHttpReq.responseType = "json";
    mHttpReq.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    mHttpReq.onload = function ()
    {
        let jsn = this.response;
        if( jsn===null )
        {
            console.log( "Could not load shaders" );
            return;
        }

        iInitShaders(jsn);
    }
    mHttpReq.send( str );
}</script>
    <style>
    .shaderPreview
    {
    display: block;
    background-color: #000000;
    background-image: url("/img/loading.gif");
    background-repeat: no-repeat;
    background-position: center;
    padding: 0px;
    margin: 0px;
    border: 0px solid #000000;
    border-radius: 8px;
    width:100%;
    height:100%;
    position: absolute;
    overflow:hidden;
    }

    .previewInfo
    {
    width: 100%;
    left: 0px;
    top: 2px;
    position: relative;
    visibility: hidden;
    }

    .previewCanvas
    {
    left: 0px;
    top: 0px;
    padding: 0px;
    margin: 0px;
    position: absolute;
    cursor: pointer;
    width:100%;
    height:100%;
    border-radius: 8px;
    border: 0px solid #000000;
    backgroundColor: transparent;
visibility: hidden;
opacity:0;
transition: opacity 1.0s ease;
    }

    .previewText
    {
        text-overflow: ellipsis;
    white-space: nowrap;
    padding-right: 1px;
    }

    .previewTextUser
    {
    text-overflow: ellipsis;
    white-space: nowrap;
    padding-left: 3px;
    }

    .previewStats
    {
    padding-right: 1px;
    right: 0px;
    top: 0px;
    position: absolute;
    }

    .previewErrorContainer
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    visibility:hidden;
    }

    .previewErrorMessage
    {
    top:50%;
    position:absolute;
    width:100%;
    text-align:center;
    padding:0;
    margin:auto;
    color:#ff0000;
    font-size:2em;
    font-style:italic;
    }

    .previewNoGLContainter
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    position:absolute;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    pointer-events:none;
    visibility:hidden;
    font-size:2em;
    }

    .previewNoGLMessage
    {
    width:86%;
    height:90%;
    padding-left:7%;
    padding-right:7%;
    padding-top:10%;
    padding-bottom:0px;
    color:#ff0000;
    position:absolute;
    visibility:hidden;
    }

    .previewThumbnailContainer
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    visibility:hidden;
    border-radius:8px;
    border:0px solid #000000;
    }

    .previewThumbnailImage
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    border-radius:8px;
    border:0px solid #000000;
opacity: 0.0;
transition: opacity 1.0s ease;
    }

    .previewThumbnailIcon
    {
    width:64px;
    height:32px;
    left:0px;
    top:0px;
    padding:0px;
    padding-top:12px;
    margin:0px;
    position:absolute;
    color:#ffffff;
    background-color:#ff8020;
    font-weight:bold;
    border-radius:0px 0px 8px 0px;
    text-align:center;
    //visibility:hidden;
    }


    .previewUIContainter
    {
    display: block;
    right:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    //cursor:pointer;
    //pointer-events:none;
    //visibility:hidden;
    }
</style>

<script>
    function previewHide(me)
    {
    me.mBase.style.visibility = "hidden";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";
    }

    function previewShowRender(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "visible";
me.mCanvas.style.opacity = 1.0;
    me.mCanvas.style.borderRadius ="8px;";
//  me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    }

    function previewShowScreenshot(me, message)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "visible";
me.mThumbnailImg.style.opacity = 1.0;
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    me.mThumbnailWar1.style.visibility = (message===1)?"visible":"hidden";
    me.mThumbnailWar2.style.visibility = (message===2)?"visible":"hidden";
    }

    function previewShowLoading(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";

    me.mLink.style.visibility = "visible";
    me.mBase.style.backgroundColor = "#ff0000;"
    me.mCont.style.visibility = "visible";
    }

    function previewShowNoWebGL(me, shaderID)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "visible";
    me.mError.style.visibility = "visible";
    me.mThumbnailImgNoWebGL.onerror = function(ev) 
                                      { 
                                            me.mThumbnailImgNoWebGL.style.visibility="hidden"; 
                                            me.mMessageNoWebGL.style.visibility="visible"; 
                                      };
    me.mThumbnailImgNoWebGL.src = "/media/shaders/" + shaderID + ".jpg";
    }

    function previewShowError(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "visible";
    me.mCont.style.visibility = "visible";
    }

    function previewLoadScreenshot( me, cbSuccess, cbError, shaderID )
    {
    var url = "/media/shaders/" + shaderID + ".jpg";
    me.mThumbnailImg.onload = cbSuccess;
    me.mThumbnailImg.onerror = function(ev) { cbError(); };
    me.mThumbnailImg.src = url;
    }
        
    function createPreview(id)
    {
        var bar = document.getElementById( "Preview_"+id+"_Canvas" );
        bar.width = bar.offsetWidth;
        bar.height = bar.offsetHeight;
        bar.mId = id;

        return { mBase: document.getElementById( "Preview_"+id+"_Container" ),
        mLink: document.getElementById( "Preview_"+id+"_Link" ),
        mCanvas: bar,
        mCont: document.getElementById( "Preview_"+id+"_Info" ),
        mTextA: document.getElementById( "Preview_"+id+"_Text" ),
        mTextB: document.getElementById( "Preview_"+id+"_TextUser" ),
        mTextC: document.getElementById( "Preview_"+id+"_Stats" ),
        mNoWebGL: document.getElementById( "Preview_"+id+"_NoWebGL" ),
        mError: document.getElementById( "Preview_"+id+"_Error" ),
        mCanvas2D: document.getElementById( "Preview_"+id+"_Thumnail" ),
        mThumbnailImg: document.getElementById( "Preview_"+id+"_ThumnailImage" ),
        mThumbnailWar1: document.getElementById( "Preview_"+id+"_ThumnailWarning1" ),
        mThumbnailWar2: document.getElementById( "Preview_"+id+"_ThumnailWarning2" ),
        mThumbnailImgNoWebGL: document.getElementById( "Preview_"+id+"_ThumnailImageNoWebGL" ),
        mMessageNoWebGL: document.getElementById( "Preview_"+id+"_MessageNoWebGL"),
        mUI: document.getElementById( "Preview_"+id+"_UI" )
        };
    }
</script>

    <style>

    div#shaderGrid
    {
        width:100%;
        padding:0px;
        margin:0px;
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        grid-template-rows: repeat(3, 1fr);
        grid-column-gap: 64px;
        grid-row-gap: 24px;
    }
    .searchResult
    {
        margin: 0px;
        padding: 0px;
        width: 100%;
    }
    .searchResultContainer
    {
        width: 100%;
        padding-bottom:56.25%;
        height: 0;
        position: relative;
    }
    .navigation
    {
        display:flex;
        align-items:center;
    }
    div#navBottom
    {
        display:none;
        justify-content:center;
    }
    a.pageButtons, .pageButtonsCurrent
    {
        border-style: solid;
        border-width: 1px;
        border-color: #808080;
        text-align: center;
        vertical-align: middle;
        margin-left: 12px;
        display: inline-block;
        border-radius: 4px;
		font-weight:bold;
        cursor: pointer;
        padding-bottom:5px;
        padding-top:4px;
        padding-left: 8px;
        padding-right: 8px;
        margin:8px;
    }
    a.pageButtons
    {
        text-decoration: none;
        -moz-transition:    background-color 0.15s linear, color 0.15s linear;
        -webkit-transition: background-color 0.15s linear, color 0.15s linear;
        transition:         background-color 0.15s linear, color 0.15s linear;
    }
    a.pageButtons:hover
    {
      background-color:#808080;
      color : #ff8020;
    }
    .pageButtonsCurrent
    {
        background-color: #808080;
        color:#000000;
    }
    div#controls
    {
        width:100%;
        padding-top:16px;
        padding-bottom:16px;
        display:flex;
        justify-content:space-between; 
        flex-wrap:wrap;
    }
    div#controls > div
    {
        display:inline-flex;
    }
    .controlOptions
    {
        display:inline-block;
    }

    /* ----------------------- media resolutions ------------------------ */

    @media screen and (max-width:799px) 
    {
        div#shaderGrid  { grid-template-columns: 1fr; grid-template-rows: repeat(12, 1fr); grid-column-gap: 0px; grid-row-gap: 16px; }
        div#controls
        {
            width:100%;
            display:flex;
            justify-content:flex-start; 
            flex-wrap:wrap;
        }
        div#controls > div
        {
            display:inline-flex;
            width:100%;
            margin-left: 0px;
            margin-right: 0px;
            padding-bottom:16px;
        }
        div#navBottom
        {
            display: flex;
        }
    }
    
    </style>
    <script>
    var gShaders=[{"ver":"0.1","info":{"id":"ltB3zD","date":"1427241319","viewed":20151,"name":"Gold Noise Uniform Random Static","username":"dcerisano","description":"- based on the Golden Ratio\n- uniform normalized distribution\n- fastest static noise generator function (also runs at low precision)\n- use with indicated fractional seeding method\n","likes":102,"published":3,"flags":8,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Generate Gold Noise image\n\n   precision lowp    float;\n\/\/ precision mediump float;\n\/\/ precision highp   float;\n\nvoid mainImage(out vec4 rgba, in vec2 xy)\n{\n    float seed = fract(iTime);                    \/\/ fractional base seed\n    rgba       = vec4 (gold_noise(xy, seed+0.1),  \/\/ r\n                       gold_noise(xy, seed+0.2),  \/\/ g\n                       gold_noise(xy, seed+0.3),  \/\/ b\n                       gold_noise(xy, seed+0.4)); \/\/ \u03b1\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\/\/ Generate Gold Noise sound\n\n\n\nvec2 mainSound( in int samp,float time)\n{\n    return vec2(gold_noise(vec2(iSampleRate*fract(time\/100.0)), 1.0));\n}","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"\/\/ Gold Noise \u00a92015 dcerisano@standard3d.com\n\/\/ - based on the Golden Ratio\n\/\/ - uniform normalized distribution\n\/\/ - fastest static noise generator function (also runs at low precision)\n\/\/ - use with indicated fractional seeding method\n\n  const float PHI = 1.61803398874989484820459; \/\/ \u03a6 = Golden Ratio \n\n  float gold_noise(in vec2 xy, in float seed)\n  {\n    return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);\n  }\n","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"4slGWH","date":"1368915920","viewed":20111,"name":"Fractal Nyancat","username":"iq","description":"Instead of using a mathematically defined shape for orbit trapping in fractals, a bitmap can be used just as easily ^_^","likes":92,"published":3,"flags":64,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"Xsf3Rn","filepath":"\/media\/a\/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"\/media\/ap\/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dlGDB","filepath":"https:\/\/soundcloud.com\/obviouslyfake\/nyan-cat-2","previewfilepath":"https:\/\/soundcloud.com\/obviouslyfake\/nyan-cat-2","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Created by inigo quilez - iq\/2013\n\/\/ https:\/\/www.youtube.com\/c\/InigoQuilez\n\/\/ https:\/\/iquilezles.org\n\n\/\/ Instead of using a pont, circle, line or any mathematical shape for traping the orbit\n\/\/ of fc(z), one can use any arbitrary shape. For example, a NyanCat :)\n\/\/\n\/\/ I invented this technique more than 10 years ago (can have a look to those experiments \n\/\/ here https:\/\/iquilezles.org\/articles\/ftrapsbitmap).\n\nvec4 getNyanCatColor( vec2 p, float time )\n{\n\tp = clamp(p,0.0,1.0);\n\tp.x = p.x*40.0\/256.0;\n\tp.y = 0.5 + 1.2*(0.5-p.y);\n\tp = clamp(p,0.0,1.0);\n\tfloat fr = floor( mod( 20.0*time, 6.0 ) );\n\tp.x += fr*40.0\/256.0;\n\treturn texture( iChannel0, p );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)\/iResolution.y;\n    \n    float time = max( iTime-5.5, 0.0 );\n    \n    \/\/ zoom\t\n\tp = vec2(0.5,-0.05)  + p*0.75 * pow( 0.9, 20.0*(0.5+0.5*cos(0.25*time)) );\n\t\n    vec4 col = vec4(0.0);\n\tvec3 s = mix( vec3( 0.2,0.2, 1.0 ), vec3( 0.5,-0.2,0.5), 0.5+0.5*sin(0.5*time) );\n\n    \/\/ iterate Jc\t\n\tvec2 c = vec2(-0.76, 0.15);\n\tfloat f = 0.0;\n\tvec2 z = p;\n\tfor( int i=0; i<100; i++ )\n\t{\n\t\tif( (dot(z,z)>4.0) || (col.w>0.1) ) break;\n\n        \/\/ fc(z) = z\u00b2 + c\t\t\n\t\tz = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;\n\t\t\n\t\tcol = getNyanCatColor( s.xy + s.z*z, time );\n\t\tf += 1.0;\n\t}\n\t\n\tvec3 bg = 0.5*vec3(1.0,0.5,0.5) * sqrt(f\/100.0);\n\t\n\tcol.xyz = mix( bg, col.xyz, col.w );\n    \n    col *= step( 2.0, iTime );\n    col += texture( iChannel1, vec2(0.01,0.2) ).x * (1.0-step( 5.5, iTime ));\n\t\n\tfragColor = vec4( col.xyz,1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4sX3Rs","date":"1376406691","viewed":20104,"name":"Lens Flare Example","username":"mu6k","description":" Trying to get some interesting looking lens flares.","likes":260,"published":3,"flags":0,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\/* This is free and unencumbered software released into the public domain. https:\/\/unlicense.org\/\n\nTrying to get some interesting looking lens flares, seems like it worked. \nSee https:\/\/www.shadertoy.com\/view\/lsBGDK for a more avanced, generalized solution\n\nIf you find this useful send me an email at peterekepeter at gmail dot com, \nI've seen this shader pop up before in other works, but I'm curious where it ends up.\n\nIf you want to use it, feel free to do so, there is no need to credit but it is appreciated.\n\n\nUsed in:\n\n Water World - https:\/\/www.shadertoy.com\/view\/lslGDB\n\n Floating Mountains - https:\/\/www.shadertoy.com\/view\/XsSGDy\n \n Clouds and Sun With Flare - https:\/\/www.shadertoy.com\/view\/4sl3zl\n \n musk's lens flare mod - https:\/\/www.shadertoy.com\/view\/XdfXRX\n\n Land of Dreams - https:\/\/github.com\/Tomius\/LoD\n\n Where is Starman? - https:\/\/spacein3d.com\/starman\n\n\nChangelog:\n\n 13\/08\/13: \n\tfirst published\n\n 17\/11\/27\n    fixed seam, thanks to Shane\n\n 19\/08\/08:\n    updated description and license change\n\n 20\/06\/24:\n    renamed to Lens Flare Example, updated description\n\n*\/\n\nfloat noise(float t)\n{\n\treturn texture(iChannel0,vec2(t,.0)\/iChannelResolution[0].xy).x;\n}\nfloat noise(vec2 t)\n{\n\treturn texture(iChannel0,t\/iChannelResolution[0].xy).x;\n}\n\nvec3 lensflare(vec2 uv,vec2 pos)\n{\n\tvec2 main = uv-pos;\n\tvec2 uvd = uv*(length(uv));\n\t\n\tfloat ang = atan(main.x,main.y);\n\tfloat dist=length(main); dist = pow(dist,.1);\n\tfloat n = noise(vec2(ang*16.0,dist*32.0));\n\t\n\tfloat f0 = 1.0\/(length(uv-pos)*16.0+1.0);\n\t\n\tf0 = f0 + f0*(sin(noise(sin(ang*2.+pos.x)*4.0 - cos(ang*3.+pos.y))*16.)*.1 + dist*.1 + .8);\n\t\n\tfloat f1 = max(0.01-pow(length(uv+1.2*pos),1.9),.0)*7.0;\n\n\tfloat f2 = max(1.0\/(1.0+32.0*pow(length(uvd+0.8*pos),2.0)),.0)*00.25;\n\tfloat f22 = max(1.0\/(1.0+32.0*pow(length(uvd+0.85*pos),2.0)),.0)*00.23;\n\tfloat f23 = max(1.0\/(1.0+32.0*pow(length(uvd+0.9*pos),2.0)),.0)*00.21;\n\t\n\tvec2 uvx = mix(uv,uvd,-0.5);\n\t\n\tfloat f4 = max(0.01-pow(length(uvx+0.4*pos),2.4),.0)*6.0;\n\tfloat f42 = max(0.01-pow(length(uvx+0.45*pos),2.4),.0)*5.0;\n\tfloat f43 = max(0.01-pow(length(uvx+0.5*pos),2.4),.0)*3.0;\n\t\n\tuvx = mix(uv,uvd,-.4);\n\t\n\tfloat f5 = max(0.01-pow(length(uvx+0.2*pos),5.5),.0)*2.0;\n\tfloat f52 = max(0.01-pow(length(uvx+0.4*pos),5.5),.0)*2.0;\n\tfloat f53 = max(0.01-pow(length(uvx+0.6*pos),5.5),.0)*2.0;\n\t\n\tuvx = mix(uv,uvd,-0.5);\n\t\n\tfloat f6 = max(0.01-pow(length(uvx-0.3*pos),1.6),.0)*6.0;\n\tfloat f62 = max(0.01-pow(length(uvx-0.325*pos),1.6),.0)*3.0;\n\tfloat f63 = max(0.01-pow(length(uvx-0.35*pos),1.6),.0)*5.0;\n\t\n\tvec3 c = vec3(.0);\n\t\n\tc.r+=f2+f4+f5+f6; c.g+=f22+f42+f52+f62; c.b+=f23+f43+f53+f63;\n\tc = c*1.3 - vec3(length(uvd)*.05);\n\tc+=vec3(f0);\n\t\n\treturn c;\n}\n\nvec3 cc(vec3 color, float factor,float factor2) \/\/ color modifier\n{\n\tfloat w = color.x+color.y+color.z;\n\treturn mix(color,vec3(w)*factor,w*factor2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy - 0.5;\n\tuv.x *= iResolution.x\/iResolution.y; \/\/fix aspect ratio\n\tvec3 mouse = vec3(iMouse.xy\/iResolution.xy - 0.5,iMouse.z-.5);\n\tmouse.x *= iResolution.x\/iResolution.y; \/\/fix aspect ratio\n\tif (iMouse.z<.5)\n\t{\n\t\tmouse.x=sin(iTime)*.5;\n\t\tmouse.y=sin(iTime*.913)*.5;\n\t}\n\t\n\tvec3 color = vec3(1.4,1.2,1.0)*lensflare(uv,mouse.xy);\n\tcolor -= noise(fragCoord.xy)*.015;\n\tcolor = cc(color,.5,.1);\n\tfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"wlGXRD","date":"1582294961","viewed":20096,"name":"PsychedelicSakura","username":"Reva","description":"Ex02","likes":31,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Author Reva - 2020-02-21\n\nfloat plot(float r, float pct){\n\treturn  smoothstep( pct-0.2, pct, r) -smoothstep( pct, pct+0.2, r);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n        return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord\/iResolution.xy;\n    vec3 col = vec3(1.0);\n    vec2 pos = vec2(0.5) - uv;\n    pos.x *= iResolution.x\/iResolution.y;\n    pos *= cos(iTime)*1.0+1.5;\n\n    float r = length(pos)*2.0;\n    float a = atan(pos.y,pos.x);\n\n    float f = abs(cos(a*2.5+iTime*0.5))*sin(iTime*2.0)*0.698+cos(iTime)-4.0;\n    float d = f-r;\n    \n    col = (vec3(smoothstep(fract(d),fract(d)+-0.200,0.160))-vec3(smoothstep(fract(d),fract(d)+-1.184,0.160)) ) \n\t* pal( f, vec3(0.725,0.475,0.440),vec3(0.605,0.587,0.007),vec3(1.0,1.0,1.0),vec3(0.310,0.410,0.154) );\n    float pct = plot(r*0.272,fract(d*(sin(iTime)*0.45+0.5)));\n\t\n    col += pct*pal( r, vec3(0.750,0.360,0.352),vec3(0.450,0.372,0.271),vec3(0.540,0.442,0.264),vec3(0.038,0.350,0.107) );\n\n    \/\/ Output to screen\n    fragColor = vec4(col,pct*0.3);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"XltGDr","date":"1469367906","viewed":20087,"name":"[SH16C] Contra","username":"knarkowicz","description":"Brings me back memories of the 90s in grim Eastern Europe (just after Soviet Union fell). Loved to watch western action movies (Rambo!) and of course to play Contra! Can you finish 1st lvl?\nA\/Q - fire S\/W - jump Arrows - move, jump, lie down, dive","likes":171,"published":3,"flags":112,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"\/media\/previz\/buffer03.png","previewfilepath":"\/media\/previz\/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"lsjGzR","filepath":"https:\/\/soundcloud.com\/somari_musics\/nes_contra_jungle-stage","previewfilepath":"https:\/\/soundcloud.com\/somari_musics\/nes_contra_jungle-stage","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define POST_PROCESS\n\nvec2 CRTCurveUV( vec2 uv, float str )\n{\n    uv = uv * 2.0 - 1.0;\n    vec2 offset = ( str * abs( uv.yx ) ) \/ vec2( 6.0, 4.0 );\n    uv = uv + uv * offset * offset;\n    uv = uv * 0.5 + 0.5;\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 baseUV = fragCoord.xy \/ iResolution.xy;\n    \n#ifdef POST_PROCESS    \n    vec2 uv = CRTCurveUV( baseUV, 0.5 );\n    \n    \/\/ chromatic abberation\n\tfloat caStrength    = 0.003;\n    vec2 caOffset       = uv - 0.5;\n    \/\/caOffset = vec2( 1.0, 0.0 ) * 0.3;\n    vec2 caUVG          = uv + caOffset * caStrength;\n    vec2 caUVB          = uv + caOffset * caStrength * 2.0;\n    \n    vec3 color;\n    color.x = texture( iChannel0, uv ).x;\n    color.y = texture( iChannel0, caUVG ).y;\n    color.z = texture( iChannel0, caUVB ).z;\n    \n    uv = CRTCurveUV( baseUV, 1.0 );\n    if ( uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0 )\n    {\n        color = vec3( 0.0, 0.0, 0.0 );\n    }    \n    float vignette = uv.x * uv.y * ( 1.0 - uv.x ) * ( 1.0 - uv.y );\n    vignette = clamp( pow( 16.0 * vignette, 0.3 ), 0.0, 1.0 );\n    color *= vignette * 1.1;\n    \n#else\n    vec3 color = texture( iChannel0, baseUV ).xyz;\n    \n#endif\n    \n    fragColor = vec4( color, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"\/presets\/tex00.jpg","previewfilepath":"\/presets\/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ Gameplay\n\n\/\/ debug cheats\n\/\/#define KONAMI_CODE\n\/\/#define SPEED_RUN\n\/\/#define GOD_MODE\n\n\/\/ storage\nconst vec2 txPlayer \t\t\t= vec2( 0.0, 0.0 ); \t\/\/ xy - pos, z - jump start, w - jump dir\nconst vec2 txPlayerState\t\t= vec2( 1.0, 0.0 ); \t\/\/ x - state, y - frame, z - jump tick, w - lifes\nconst vec2 txPlayerDir\t\t\t= vec2( 2.0, 0.0 ); \t\/\/ xy - dir, z - flip, w - immortality\nconst vec2 txPlayerWeapon\t\t= vec2( 3.0, 0.0 ); \t\/\/ x - weapon, y - weapon cooldown, z - weapon fire rate, w - weapon bullet num\nconst vec2 txCamera \t\t\t= vec2( 4.0, 0.0 ); \t\/\/ x - cam offset, y - spawn counter, z - soldier spawn counter\nconst vec2 txSoldier0 \t\t\t= vec2( 5.0, 0.0 ); \t\/\/ xy - pos, z - flip\nconst vec2 txSoldier1 \t\t\t= vec2( 5.0, 1.0 ); \t\/\/ xy - pos, z - flip\nconst vec2 txSoldier2 \t\t\t= vec2( 5.0, 2.0 ); \t\/\/ xy - pos, z - flip\nconst vec2 txSoldier0State \t\t= vec2( 6.0, 0.0 ); \t\/\/ x - state, y - frame, z - jump tick\nconst vec2 txSoldier1State \t\t= vec2( 6.0, 1.0 ); \t\/\/ x - state, y - frame, z - jump tick\nconst vec2 txSoldier2State \t\t= vec2( 6.0, 2.0 ); \t\/\/ x - state, y - frame, z - jump tick\nconst vec2 txSniper\t \t\t\t= vec2( 7.0, 0.0 ); \t\/\/ xy - pos, z - flip, w - weapon cooldown\nconst vec2 txPlayerBullet0 \t\t= vec2( 8.0, 0.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txPlayerBullet1 \t\t= vec2( 8.0, 1.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txPlayerBullet2 \t\t= vec2( 8.0, 2.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txPlayerBullet3 \t\t= vec2( 8.0, 3.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txPlayerBullet4 \t\t= vec2( 8.0, 4.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txPlayerBullet5 \t\t= vec2( 8.0, 5.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txEnemyBullet0 \t\t= vec2( 9.0, 0.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txEnemyBullet1 \t\t= vec2( 9.0, 1.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txEnemyBullet2 \t\t= vec2( 9.0, 2.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txEnemyBullet3 \t\t= vec2( 9.0, 3.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txExplosion \t\t\t= vec2( 10.0, 0.0 ); \t\/\/ xy - pos, z - frame\nconst vec2 txHit \t\t\t\t= vec2( 11.0, 0.0 ); \t\/\/ xy - pos, z - frame\nconst vec2 txTurret0\t\t\t= vec2( 12.0, 0.0 ); \t\/\/ xy - pos, z - angle\nconst vec2 txTurret1\t\t\t= vec2( 12.0, 1.0 ); \t\/\/ xy - pos, z - angle\nconst vec2 txTurret0State\t\t= vec2( 13.0, 0.0 ); \t\/\/ x - HP, y - weapon cooldown\nconst vec2 txTurret1State\t\t= vec2( 13.0, 1.0 ); \t\/\/ x - HP, y - weapon cooldown\nconst vec2 txPowerUp\t\t\t= vec2( 14.0, 0.0 ); \t\/\/ xy - pos, z - frame\nconst vec2 txPowerUpState\t\t= vec2( 15.0, 0.0 ); \t\/\/ x - state, y - initial height, z - jump tick\nconst vec2 txBossCore\t\t\t= vec2( 16.0, 0.0 ); \t\/\/ xy - pos, z - HP\nconst vec2 txBossCannon0\t\t= vec2( 17.0, 0.0 ); \t\/\/ xy - pos, z - cooldown, w - HP\nconst vec2 txBossCannon1\t\t= vec2( 17.0, 1.0 ); \t\/\/ xy - pos, z - cooldown, w - HP\nconst vec2 txBossBullet0\t\t= vec2( 18.0, 0.0 ); \t\/\/ xy - pos, zw - velocity\nconst vec2 txBossBullet1\t\t= vec2( 18.0, 1.0 ); \t\/\/ xy - pos, zw - velocity\nconst vec2 txGameState\t\t\t= vec2( 19.0, 0.0 ); \t\/\/ x - state, y - state tick\nconst vec2 txBridge\t\t\t\t= vec2( 20.0, 0.0 ); \t\/\/ x - draw start, y - explode tick\n\n#ifdef KONAMI_CODE\n\tconst float PLAYER_LIFE_NUM\t\t= 10.0;\n#else\n\tconst float PLAYER_LIFE_NUM\t\t= 3.0;\n#endif\n\n#ifdef SPEED_RUN\n\tconst float PLAYER_RUN_SPEED \t= 5.0;\n#else\n\tconst float PLAYER_RUN_SPEED \t= 1.0;\n#endif\n\nconst float MATH_PI \t\t\t\t= 3.14159265359;\nconst float NES_RES_X\t\t\t\t= 224.0;\nconst float NES_RES_Y \t\t\t\t= 192.0;\nconst float KEY_A    \t\t\t\t= 65.5 \/ 256.0;\nconst float KEY_Q    \t\t\t\t= 81.5 \/ 256.0;\nconst float KEY_S    \t\t\t\t= 83.5 \/ 256.0;\nconst float KEY_W    \t\t\t\t= 87.5 \/ 256.0;\nconst float KEY_LEFT  \t\t\t\t= 37.5 \/ 256.0;\nconst float KEY_UP    \t\t\t\t= 38.5 \/ 256.0;\nconst float KEY_RIGHT \t\t\t\t= 39.5 \/ 256.0;\nconst float KEY_DOWN  \t\t\t\t= 40.5 \/ 256.0;\nconst float STATE_RUN\t\t\t\t= 0.0;\nconst float STATE_PRONE \t\t\t= 1.0;\nconst float STATE_JUMP \t\t\t\t= 2.0;\nconst float STATE_FALL \t\t\t\t= 3.0;\nconst float STATE_WATER \t\t\t= 4.0;\nconst float STATE_UNDER_WATER \t\t= 5.0;\nconst float WEAPON_RIFLE\t\t\t= 0.0;\nconst float WEAPON_MACHINE_GUN\t\t= 1.0;\nconst float RIFLE_FIRE_RATE\t\t\t= 20.0;\nconst float RIFLE_BULLET_NUM\t\t= 4.0;\nconst float MACHINE_GUN_FIRE_RATE\t= 10.0;\nconst float MACHINE_GUN_BULLET_NUM\t= 6.0;\nconst float SNIPER_FIRE_RATE\t\t= 160.0;\nconst float TURRET_FIRE_RATE\t\t= 100.0;\nconst float PLAYER_SPAWN_HEIGHT\t\t= 200.0;\nconst float PLAYER_JUMP_HEIGHT\t\t= 16.0 * 3.0;\nconst float PLAYER_IMMORTALITY_LEN\t= 60.0 * 3.0;\nconst float PLAYER_RUN_ANIM_SPEED \t= 0.13;\nconst float PLAYER_JUMP_ANIM_SPEED\t= 0.13;\nconst float PLAYER_FALL_SPEED \t\t= 3.0;\nconst float PLAYER_BULLET_SPEED\t\t= 3.0;\nconst float PLAYER_HIT_BOX_SIZE_MUL\t= 0.7;\nconst float ENEMY_RUN_SPEED \t\t= 1.0;\nconst float ENEMY_BULLET_SPEED \t\t= 1.0;\nconst float ENEMY_ANIM_SPEED\t\t= 0.13;\nconst float SOLDIER_SPAWN_RATE\t\t= 180.0;\nconst float BOSS_CORE_HP\t\t\t= 32.0;\nconst float BOSS_CANNON_HP\t\t\t= 8.0;\nconst float BOSS_CANNON_FIRE_RATE\t= 120.0;\nconst float WATER_HEIGHT\t\t\t= 8.0;\nconst float WATER_END\t\t\t\t= 32.0 * 63.0;\nconst float BRIDGE_0_START_TILE\t\t= 30.0;\nconst float BRIDGE_0_END_TILE\t\t= 35.0;\nconst float BRIDGE_1_START_TILE\t\t= 40.0;\nconst float BRIDGE_1_END_TILE\t\t= 45.0;\nconst float BRIGDE_EXPLODE_TIME\t\t= 70.0;\nconst float CAMERA_END\t\t\t\t= 32.0 * 102.0;\nconst float PLAYER_END\t\t\t\t= 32.0 * 108.0 + 16.0;\nconst float SOLDIER_SPAWN_END\t\t= 32.0 * 99.0 - 32.0 * 2.0;\nconst vec2 \tBILL_PRONE_SIZE\t\t\t= vec2( 32.0, 18.0 );\nconst vec2 \tBILL_RUN_SIZE\t\t\t= vec2( 24.0, 34.0 );\nconst vec2 \tBILL_JUMP_SIZE\t\t\t= vec2( 20.0, 20.0 );\nconst vec2 \tSOLDIER_SIZE \t\t\t= vec2( 16.0, 32.0 );\nconst vec2 \tSNIPER_SIZE\t\t\t\t= vec2( 24.0, 32.0 );\nconst vec2 \tBULLET_SIZE\t\t\t\t= vec2( 3.0,  3.0  );\nconst vec2 \tPOWER_BULLET_SIZE\t\t= vec2( 5.0,  5.0  );\nconst vec2 \tTURRET_SIZE\t\t\t\t= vec2( 32.0, 32.0 );\nconst vec2 \tPOWER_UP_SIZE\t\t\t= vec2( 24.0, 14.0 );\nconst vec2 \tBOSS_CORE_SIZE\t\t\t= vec2( 24.0, 31.0 );\nconst vec2 \tBOSS_CANNON_SIZE\t\t= vec2( 14.0, 6.0 );\nconst float TURRET_HP\t\t\t\t= 8.0;\nconst float GAME_STATE_TITLE\t\t= 0.0;\nconst float GAME_STATE_LEVEL\t\t= 1.0;\nconst float GAME_STATE_LEVEL_DIE\t= 2.0;\nconst float GAME_STATE_LEVEL_WIN\t= 3.0;\nconst float GAME_STATE_GAME_OVER\t= 4.0;\nconst float GAME_STATE_VICTORY\t\t= 5.0;\nconst float UI_TITLE_TIME\t\t\t= 120.0;\nconst float UI_GAME_START_TIME\t\t= 60.0;\nconst float UI_VICTORY_TIME\t\t\t= 300.0;\n\nvec4 gPlayer;\nvec4 gPlayerState;\nvec4 gPlayerDir;\nvec4 gPlayerWeapon;\nvec4 gCamera;\nvec4 gSoldier0;\nvec4 gSoldier1;\nvec4 gSoldier2;\nvec4 gSoldier0State;\nvec4 gSoldier1State;\nvec4 gSoldier2State;\nvec4 gSniper;\nvec4 gPlayerBullet0;\nvec4 gPlayerBullet1;\nvec4 gPlayerBullet2;\nvec4 gPlayerBullet3;\nvec4 gPlayerBullet4;\nvec4 gPlayerBullet5;\nvec4 gEnemyBullet0;\nvec4 gEnemyBullet1;\nvec4 gEnemyBullet2;\nvec4 gEnemyBullet3;\nvec4 gExplosion;\nvec4 gHit;\nvec4 gTurret0;\nvec4 gTurret1;\nvec4 gTurret0State;\nvec4 gTurret1State;\nvec4 gPowerUp;\nvec4 gPowerUpState;\nvec4 gBossCore;\nvec4 gBossCannon0;\nvec4 gBossCannon1;\nvec4 gBossBullet0;\nvec4 gBossBullet1;\nvec4 gGameState;\nvec4 gBridge;\n\nfloat IsInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\n\nfloat Rand()\n{\n    vec2 co = vec2( iTime, iTime );\n    return fract( sin( dot( co.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\n}\n\nvec4 LoadValue( vec2 tx )\n{\n    return texture( iChannel0, ( tx + 0.5 ) \/ iChannelResolution[ 0 ].xy );\n}\n\nvoid StoreValue( vec2 re, vec4 va, inout vec4 fragColor, vec2 fragCoord )\n{\n    fragCoord = floor( fragCoord );\n    fragColor = ( fragCoord.x == re.x && fragCoord.y == re.y ) ? va : fragColor;\n}\n\nbool Collide( vec2 p0, vec2 s0, vec2 p1, vec2 s1 )\n{\n    \/\/ pivot x in the middle, and y in the bottom\n    p0.x -= s0.x * 0.5;\n    p1.x -= s1.x * 0.5;\n    \n    return \t\tp0.x <= p1.x + s1.x\n        \t&& \tp0.y <= p1.y + s1.y\n        \t&& \tp1.x <= p0.x + s0.x\n        \t&& \tp1.y <= p0.y + s0.y;\n}\n\nfloat GetSupport( vec2 p )\n{\n    float tileX\t= floor( p.x \/ 32.0 );\n    float tileY\t= floor( p.y \/ 16.0 );\n    \n    bool grass0 = false;\n    bool grass2 = false;\n    bool grass3 = false;\n    bool grass4 = false;\n    bool grass6 = false;\n    bool grass8 = false;\n    \n\tif ( \t\t( tileX >= 52.0 && tileX < 67.0 ) \n\t\t\t|| \t( tileX >= 72.0 && tileX < 77.0 )   \n\t\t\t|| \t( tileX >= 86.0 && tileX < 88.0 ) )\n    {\n        grass8 = true;\n    }\n    \n\tif ( \t\t( tileX >= 3.0   && tileX < 30.0 ) \n        \t|| \t( tileX >= 35.0  && tileX < 40.0 ) \n        \t|| \t( tileX >= 45.0  && tileX < 53.0 ) \n        \t|| \t( tileX >= 66.0  && tileX < 73.0 )\n            || \t( tileX >= 78.0  && tileX < 80.0 )\n            || \t( tileX >= 85.0  && tileX < 87.0 )\n            || \t( tileX >= 89.0  && tileX < 91.0 )\n            ||  ( tileX >= 102.0 && tileX < 106.0 ) )\n    {\n        grass6 = true;\n    }\n    \n\tif ( \t\t( tileX >= 10.0 && tileX < 13.0 )\n\t\t\t||\t( tileX >= 18.0 && tileX < 20.0 )\n        \t|| \t( tileX >= 58.0 && tileX < 65.0 )\n\t\t\t|| \t( tileX >= 76.0 && tileX < 79.0 )\n            || \t( tileX >= 81.0 && tileX < 83.0 )\n            || \t( tileX >= 90.0 && tileX < 95.0 )\n            ||  ( tileX >= 100.0 && tileX < 102.0 )\n            || \t( tileX == 106.0 ) )\n    {\n        grass4 = true;\n    }\n    \n    if ( \t\t( tileX >= 26.0 && tileX < 29.0 )\n            ||  ( tileX >= 55.0 && tileX < 57.0 )\n            || \t( tileX == 74.0 )\n\t\t\t||  ( tileX == 87.0 )\n\t\t\t|| \t( tileX >= 103.0 && tileX < 106.0 ) )\n    {\n        grass3 = true;\n    }\n        \n\tif ( \t\t( tileX == 13.0 || tileX == 16.0 )\n            ||  ( tileX >= 68.0 && tileX < 70.0 )\n            ||  ( tileX >= 71.0 && tileX < 73.0 )\n            || \t( tileX >= 82.0 && tileX < 85.0 )\n            ||  ( tileX >= 97.0 && tileX < 99.0 )\n            || \t( tileX == 107.0 ) )\n    {\n        grass2 = true;\n    }\n        \n\tif ( \t\t( tileX >= 14.0 && tileX < 16.0 ) \n            || \t( tileX >= 24.0 && tileX < 26.0 ) \n            || \t( tileX >= 52.0 && tileX < 55.0 ) \n            || \t( tileX >= 62.0 && tileX < 68.0 )\n            || \t( tileX == 81.0 )\n\t\t\t||  ( tileX == 86.0 )\n            || \t( tileX >= 93.0 && tileX < 96.0 )\n            ||  ( tileX >= 102.0 ) )      \n\t{\n        grass0 = true;\n    }\n    \n\tif ( tileX >= BRIDGE_0_START_TILE && tileX < BRIDGE_0_END_TILE && gBridge.x < tileX )\n    {\n        grass6 = true;\n    }\n\n\tif ( tileX >= BRIDGE_1_START_TILE && tileX < BRIDGE_1_END_TILE && gBridge.x < tileX )\n    {\n        grass6 = true;\n    } \n    \n    float height = 8.0;\n    if ( grass0 )\n    {\n        height = 1.0 * 16.0;\n    }    \n    if ( grass2 && tileY >= 2.0 )\n    {\n        height = 3.0 * 16.0;\n    }\n    if ( grass3 && tileY >= 3.0 )\n    {\n        height = 4.0 * 16.0;\n    }    \n    if ( grass4 && tileY >= 4.0 )\n    {\n        height = 5.0 * 16.0;\n    }\n    if ( grass6 && tileY >= 6.0 )\n    {\n        height = 7.0 * 16.0;\n    } \n   \tif ( grass8 && tileY >= 8.0 )\n    {\n        height = 9.0 * 16.0;\n    }     \n    \n    return height - 4.0;\n}\n\nvoid SpawnSniper( float tileX, float tileY, float screenWidth )\n{\n    float spawnX = tileX * 32.0 - screenWidth;\n    if ( gCamera.x > spawnX && gCamera.y < spawnX )\n    {\n\t\tgSniper = vec4( tileX * 32.0, tileY * 32.0 + 12.0, 0.0, 0.0 );\n        gCamera.y = spawnX;\n    }\n}\n\nvoid SpawnTurret( float tileX, float tileY, float screenWidth )\n{\n    float spawnX = tileX * 32.0 - screenWidth;\n    if ( gCamera.x >= spawnX && gCamera.y < spawnX )\n    {\n        if ( gTurret0.x == 0.0 || ( gTurret1.x > 0.0 && gTurret0.x < gTurret1.x ) )\n        {\n\t\t\tgTurret0 \t\t= vec4( tileX * 32.0 + 16.0, tileY * 32.0, 0.0, 0.0 );\n        \tgTurret0State\t= vec4( TURRET_HP, 0.0, 0.0, 0.0 );\n        }\n        else\n        {\n\t\t\tgTurret1 \t\t= vec4( tileX * 32.0 + 16.0, tileY * 32.0, 0.0, 0.0 );\n        \tgTurret1State\t= vec4( TURRET_HP, 0.0, 0.0, 0.0 );\n        }\n\n        gCamera.y = spawnX;\n    }\n}\n\nvoid SpawnPowerUp( float tileX, float screenWidth )\n{\n    float spawnX = tileX * 32.0 - screenWidth;\n    if ( gCamera.x > spawnX && gCamera.y < spawnX )\n    {\n    \tgPowerUp \t\t= vec4( spawnX, 150.0, 0.0, 0.0 );\n        gPowerUpState\t= vec4( STATE_RUN, 150.0, 0.0, 0.0 );  \n        gCamera.y = spawnX;\n    }\n}\n\nvoid UpdateSpawner( float screenWidth )\n{\n    SpawnSniper( 15.0, 0.0, screenWidth );\n    SpawnPowerUp( 23.0, screenWidth );    \n    SpawnSniper( 25.0, 0.0, screenWidth );\n    SpawnTurret( 47.0, 2.0, screenWidth );\n    SpawnSniper( 48.0, 3.0, screenWidth );\n    SpawnSniper( 56.0, 4.0, screenWidth );\n    SpawnPowerUp( 55.0, screenWidth ); \n    SpawnTurret( 59.0, 3.0, screenWidth );\n    SpawnTurret( 65.0, 3.0, screenWidth );\n    SpawnTurret( 72.0, 2.0, screenWidth );\n    SpawnTurret( 76.0, 5.0, screenWidth );\n    SpawnSniper( 82.0, 2.0, screenWidth );\n    SpawnPowerUp( 89.0, screenWidth );    \n    SpawnTurret( 94.0, 3.0, screenWidth );\n    SpawnTurret( 101.0, 1.0, screenWidth );\n    SpawnTurret( 105.0, 1.0, screenWidth );\n    SpawnSniper( 109.8, 4.875, screenWidth );\n\n    if ( gCamera.z == 0.0 && Rand() > 0.5 )\n    {\n        gCamera.z = SOLDIER_SPAWN_RATE - 20.0;\n    }\n\n    ++gCamera.z;\n    vec4 newSoldier \t\t= vec4( gCamera.x + screenWidth, 300.0, -1.0, 0.0 );\n    vec4 newSoldierState \t= vec4( 0.0, 0.0, 0.0, 0.0 );\n\tnewSoldier.y = GetSupport( newSoldier.xy );    \n    if ( gCamera.x < SOLDIER_SPAWN_END && gCamera.z > SOLDIER_SPAWN_RATE && newSoldier.y > WATER_HEIGHT )\n    {\n        gCamera.z = 0.0;\n        \n        if ( gSoldier0.x <= 0.0 )\n        {\n            gSoldier0 \t\t= newSoldier;\n            gSoldier0State \t= newSoldierState;\n        }\n\t\telse if ( gSoldier1.x <= 0.0 )\n        {\n            gSoldier1 \t\t= newSoldier;\n            gSoldier1State \t= newSoldierState;\n        }\n\t\telse if ( gSoldier2.x <= 0.0 )\n        {\n            gSoldier2 \t\t= newSoldier;\n            gSoldier2State \t= newSoldierState;\n        }        \n    }\n}\n\nvoid SpawnEnemyBullet( vec2 pos, vec2 dir )\n{\n    if ( gEnemyBullet0.x <= 0.0 )\n    {\n\t\tgEnemyBullet0 = vec4( pos, dir );\n    }\n    else if ( gEnemyBullet1.x <= 0.0 )\n    {\n        gEnemyBullet1 = vec4( pos, dir );\n    }\n    else if ( gEnemyBullet2.x <= 0.0 )\n    {\n        gEnemyBullet2 = vec4( pos, dir );\n    }\n    else if ( gEnemyBullet3.x <= 0.0 )\n    {\n        gEnemyBullet3 = vec4( pos, dir );\n    }    \n}\n\nvoid UpdateSniper( inout vec4 sniper, vec2 playerTarget )\n{\n    if ( sniper.x + SNIPER_SIZE.x * 0.5 < gCamera.x )\n    {\n        sniper.x = 0.0;\n    }  \n    \n    ++sniper.w;\n\tif ( sniper.x > 0.0 && sniper.w > SNIPER_FIRE_RATE )\n    {\n        sniper.w = 0.0;\n        vec2 pos = sniper.xy + vec2( 0.0, 24.0 );\n        SpawnEnemyBullet( pos, normalize( playerTarget - pos ) );\n    }\n    sniper.z = playerTarget.x > sniper.x ? 1.0 : -1.0;    \n}\n\nvoid UpdateTurret( inout vec4 turret, inout vec4 turretState, vec2 playerTarget )\n{\n    if ( turret.x + TURRET_SIZE.x * 0.5 < gCamera.x )\n    {\n        turret.x = 0.0;\n    }    \n    \n\tvec2 turretAim = normalize( playerTarget - turret.xy );\n\n    \/\/ constrain barrel to one of the 12 possible rotations\n    float turretAimAngle = atan( -turretAim.y, turretAim.x );    \n    turretAimAngle = turretAimAngle \/ ( 2.0 * MATH_PI );\n    turretAimAngle = floor( turretAimAngle * 12.0 + 0.5 );\n    turret.z = mod( turretAimAngle + 6.0, 12.0 );\n    turretAimAngle = turretAimAngle * 2.0 * MATH_PI \/ 12.0;\n    turretAim = vec2( cos( turretAimAngle ), -sin( turretAimAngle ) );\n    \n    ++turretState.y;\n\tif ( turret.x > 0.0 && turretState.y > TURRET_FIRE_RATE )\n    {\n        turretState.y = 0.0;\n\t\tSpawnEnemyBullet( turret.xy, turretAim );\n    }\n}\n\nvoid UpdateBossCannon( inout vec4 bossCannon )\n{\n    float accX \t\t= -fract( iTime * 1.069 + bossCannon.x * 7.919 ) * 5.0;\n    vec4 newBullet\t= vec4( bossCannon.xy - vec2( BOSS_CANNON_SIZE.x * 0.5, 0.0), accX, 0.0 );\n    \n    ++bossCannon.z;\n    if ( bossCannon.z > BOSS_CANNON_FIRE_RATE )\n    {\n        bossCannon.z = 0.0;\n        if ( gBossBullet0.x <= 0.0 )\n        {\n            gBossBullet0 = newBullet;\n        }\n        else if ( gBossBullet1.x <= 0.0 )\n        {\n            gBossBullet1 = newBullet;\n        }\n    }\n}\n\nvoid PlayerBulletSoldierTest( inout vec4 playerBullet, inout vec4 soldier )\n{\n    if ( playerBullet.x > 0.0 && Collide( playerBullet.xy, BULLET_SIZE, soldier.xy, SOLDIER_SIZE ) )\n    {\n        gExplosion \t\t= vec4( soldier.xy + vec2( 0.0, SOLDIER_SIZE.y * 0.5 ), 0.0, 0.0 );\n        gHit\t\t \t= vec4( playerBullet.xy, 0.0, 0.0 );\n\t\tsoldier.x \t\t= 0.0;\n        playerBullet.x \t= 0.0;\n    }\n}\n\nvoid PlayerBulletSniperTest( inout vec4 playerBullet, inout vec4 sniper )\n{\n\tif ( playerBullet.x > 0.0 && Collide( playerBullet.xy, BULLET_SIZE, sniper.xy, SNIPER_SIZE ) )\n    {\n        gExplosion\t\t= vec4( sniper.xy + vec2( 0.0, SNIPER_SIZE.y * 0.5 ), 0.0, 0.0 );\n        gHit\t\t  \t= vec4( playerBullet.xy, 0.0, 0.0 );\n\t\tsniper.x\t\t= 0.0;\n        playerBullet.x \t= 0.0;\n    }\n}\n\nvoid PlayerBulletTurretTest( inout vec4 playerBullet, inout vec4 turret, inout vec4 turretState )\n{\n\tif ( playerBullet.x > 0.0 && Collide( playerBullet.xy, BULLET_SIZE, turret.xy + vec2( 0.0, -TURRET_SIZE.y * 0.5 ), TURRET_SIZE ) )\n    {\n        gHit\t\t\t= vec4( playerBullet.xy, 0.0, 0.0 );\n        playerBullet.x \t= 0.0;\n        \n        --turretState.x;        \n        if ( turretState.x <= 0.0 )\n        {\n\t\t\tgExplosion = vec4( turret.xy, 0.0, 0.0 );\n        \tturret.x = 0.0;\n        }\n    }\n}\n\nvoid PlayerBulletPowerUpTest( inout vec4 playerBullet )\n{\n\tif ( playerBullet.x > 0.0 && gPowerUpState.x == STATE_RUN && Collide( playerBullet.xy, BULLET_SIZE, gPowerUp.xy, POWER_UP_SIZE ) )\n    {\n\t\tgHit\t\t\t= vec4( playerBullet.xy, 0.0, 0.0 );\n        gExplosion \t\t= vec4( gPowerUp.xy + vec2( 0.0, POWER_UP_SIZE.y * 0.5 ), 0.0, 0.0 );        \n        playerBullet.x \t= 0.0;\n        gPowerUpState.x = STATE_JUMP;\n        gPowerUp.z\t\t= 1.0;\n    }\n}\n\nvoid PlayerBulletBossCoreTest( inout vec4 playerBullet )\n{\n\tif ( playerBullet.x > 0.0 && Collide( playerBullet.xy, BULLET_SIZE, gBossCore.xy + vec2( 0.0, BOSS_CORE_SIZE.y * 0.25 ), BOSS_CORE_SIZE * 0.5 ) )\n    {\n\t\tgHit\t\t\t= vec4( playerBullet.xy, 0.0, 0.0 );\n        playerBullet.x \t= 0.0;\n\t\t--gBossCore.z;\n        if ( gBossCore.z < 0.0 )\n        {\n            gExplosion \t\t= vec4( gBossCore.xy + vec2( 0.0, BOSS_CORE_SIZE.y * 0.5 ), 0.0, 0.0 );\n            gBossCore.x \t= 0.0;\n            gGameState.x \t= GAME_STATE_LEVEL_WIN;\n\t\t\tgGameState.y \t= 0.0;\n        }\n    }\n}\n\nvoid PlayerBulletBossCannonTest( inout vec4 playerBullet, inout vec4 bossCannon )\n{\n\tif ( playerBullet.x > 0.0 && Collide( playerBullet.xy, BULLET_SIZE, bossCannon.xy, BOSS_CANNON_SIZE ) )\n    {\n\t\tgHit\t\t\t= vec4( playerBullet.xy, 0.0, 0.0 );\n        playerBullet.x \t= 0.0;\n\t\t--bossCannon.w;\n        if ( bossCannon.w < 0.0 )\n        {\n            gExplosion \t\t= vec4( bossCannon.xy + vec2( 0.0, BOSS_CANNON_SIZE.y * 0.5 ), 0.0, 0.0 );\n            bossCannon.x \t= 0.0;\n        }\n    }\n}\n\nvoid UpdatePlayerBullet( inout vec4 playerBullet, float screenWidth, float screenHeight )\n{\n    if ( !Collide( playerBullet.xy, BULLET_SIZE, vec2( gCamera.x + screenWidth * 0.5, 0.0 ), vec2( screenWidth, screenHeight ) ) )\n    {\n        playerBullet.x = 0.0;\n    }\n    if ( playerBullet.x > 0.0 )\n    {\n    \tplayerBullet.xy += playerBullet.zw * PLAYER_BULLET_SPEED;\n    }\n}\n\nvoid PlayerHit( vec4 playerHitBox )\n{\n#ifndef GOD_MODE\n    if ( gGameState.x == GAME_STATE_LEVEL && gGameState.y > UI_GAME_START_TIME )\n    {\n        gPlayerState.x \t= STATE_JUMP;\n        gPlayerState.y \t= 0.0;        \n        gPlayerState.z \t= 1.0;\n        gPlayerState.w -= 1.0;    \n        gExplosion \t\t= vec4( gPlayer.xy + vec2( 0.0, playerHitBox.z * 0.5 ), 0.0, 0.0 );\n        gPlayer \t\t= vec4( gCamera.x + 32.0 * 2.0 + 24.0, PLAYER_SPAWN_HEIGHT, PLAYER_SPAWN_HEIGHT, 0.0 );\n        gPlayerDir\t\t= vec4( 1.0, 0.0, 0.0, PLAYER_IMMORTALITY_LEN );\n        gPlayerWeapon \t= vec4( WEAPON_RIFLE, 0.0, RIFLE_FIRE_RATE, RIFLE_BULLET_NUM );\n\n        if ( gPlayerState.w <= 0.0 )\n        {\n            gGameState.x \t= GAME_STATE_LEVEL_DIE;\n            gGameState.y \t= 0.0;\n            gPlayer\t\t\t= vec4( 0.0, 1000000.0, 0.0, 0.0 );\n            gPlayerState.x \t= STATE_FALL;\n        }\n    }\n#endif\n}\n\nvoid UpdateEnemyBullet( inout vec4 enemyBullet, vec4 playerHitBox, float screenWidth, float screenHeight )\n{\n    if ( !Collide( enemyBullet.xy, BULLET_SIZE, vec2( gCamera.x + screenWidth * 0.5, 0.0 ), vec2( screenWidth, screenHeight ) ) )\n    {\n        enemyBullet.x = 0.0;\n    }\n    \n\tif ( enemyBullet.x > 0.0 )\n    {\n    \tenemyBullet.xy += enemyBullet.zw * ENEMY_BULLET_SPEED;\n    }\n   \n\tif ( Collide( playerHitBox.xy, playerHitBox.zw, enemyBullet.xy, BULLET_SIZE ) )\n    {\n        PlayerHit( playerHitBox );\n        enemyBullet.x = 0.0;\n    }        \n}\n\nvoid UpdateBossBullet( inout vec4 bossBullet, vec4 playerHitBox, float screenWidth, float screenHeight )\n{\n    if ( !Collide( bossBullet.xy, POWER_BULLET_SIZE, vec2( gCamera.x + screenWidth * 0.5, 0.0 ), vec2( screenWidth, screenHeight ) ) )\n    {\n        bossBullet.x = 0.0;\n    }\n    \n\tif ( bossBullet.x > 0.0 )\n    {\n        bossBullet.xy += bossBullet.zw;\n        bossBullet.w -= 1.0 \/ 10.0;\n    }\n   \n\tif ( Collide( playerHitBox.xy, playerHitBox.zw, bossBullet.xy, POWER_BULLET_SIZE ) )\n    {\n        PlayerHit( playerHitBox );\n        bossBullet.x = 0.0;\n    }        \n}\n\nvoid UpdateSoldier( inout vec4 soldier, inout vec4 soldierState, vec4 playerHitBox, float screenWidth, float screenHeight )\n{\n    float soldierSupport = GetSupport( soldier.xy );    \n    if ( soldierState.x == STATE_RUN )\n    {\n\t\tsoldierState.y = mod( soldierState.y + ENEMY_ANIM_SPEED, 2.0 );        \n        \n        if ( soldier.y != soldierSupport )\n        {\n            \/\/ lost support - either jump or go back\n            if ( Rand() > 0.3 )\n            {\n            \tsoldierState.x = STATE_JUMP;\n            \tsoldierState.y = 1.0;\n            \tsoldierState.z = 0.0;\n\t\t\t}\n            else\n            {\n            \tsoldier.z = -soldier.z;\n            }\n        }\n    }\n    else if ( soldierState.x == STATE_JUMP )\n    {\n\t\tsoldierState.z += 1.0 \/ 20.0;\n        soldier.y += 3.0 * ( 1.0 - soldierState.z );\n        if ( soldierState.z > 1.0 && soldier.y <= soldierSupport )\n        {\n            soldier.y = soldierSupport;\n            soldierState.x = STATE_RUN;\n        }\n    }\n\tsoldier.x += soldier.z * ENEMY_RUN_SPEED;\n\n    if ( soldier.x > gCamera.x + screenWidth || soldier.x < gCamera.x )\n    {\n    \tsoldier.x = -1.0;        \n    }\n\n    \/\/ soldier death\n    if ( soldier.x > 0.0 && soldier.y < WATER_HEIGHT )   \n    {\n        gExplosion \t= vec4( soldier.xy + vec2( 0.0, SOLDIER_SIZE.y * 0.5 ), 0.0, 0.0 );\n\t\tsoldier \t= vec4( 0.0, 0.0, 0.0, 0.0 );\n    }\n    \n\tif ( soldier.x > 0.0 && Collide( playerHitBox.xy, playerHitBox.zw, soldier.xy, SOLDIER_SIZE ) )\n    {\n        PlayerHit( playerHitBox );\n    }    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ don't compute gameplay outside of the data area\n    if ( fragCoord.x > 32.0 || fragCoord.y > 32.0 ) \n    {\n        discard;    \n    }\n\n    float resMultX  \t= floor( iResolution.x \/ NES_RES_X );\n    float resMultY  \t= floor( iResolution.y \/ NES_RES_Y );\n    float resRcp\t\t= 1.0 \/ max( min( resMultX, resMultY ), 1.0 );\n    float screenWidth\t= floor( iResolution.x * resRcp );\n    float screenHeight\t= floor( iResolution.y * resRcp );\n    \n    \/\/ keys\n    bool keyLeft  \t= texture( iChannel1, vec2( KEY_LEFT, 0.25 ) ).x > 0.5;\n    bool keyRight \t= texture( iChannel1, vec2( KEY_RIGHT, 0.25 ) ).x > 0.5;\n    bool keyUp  \t= texture( iChannel1, vec2( KEY_UP, 0.25 ) ).x > 0.5;\n    bool keyDown \t= texture( iChannel1, vec2( KEY_DOWN, 0.25 ) ).x > 0.5;    \n    bool keyShoot\t= texture( iChannel1, vec2( KEY_A, 0.25 ) ).x > 0.5 || texture( iChannel1, vec2( KEY_Q, 0.25 ) ).x > 0.5;\n    bool keyJump \t= texture( iChannel1, vec2( KEY_S, 0.25 ) ).x > 0.5 || texture( iChannel1, vec2( KEY_W, 0.25 ) ).x > 0.5;\n    \n\tgPlayer        \t= LoadValue( txPlayer );\n\tgPlayerState   \t= LoadValue( txPlayerState );\n\tgPlayerDir    \t= LoadValue( txPlayerDir );\n    gPlayerWeapon  \t= LoadValue( txPlayerWeapon );\n\tgCamera       \t= LoadValue( txCamera );\n\tgSoldier0     \t= LoadValue( txSoldier0 );\n    gSoldier1      \t= LoadValue( txSoldier1 );\n    gSoldier2      \t= LoadValue( txSoldier2 );\n\tgSoldier0State \t= LoadValue( txSoldier0State );\n    gSoldier1State \t= LoadValue( txSoldier1State );\n    gSoldier2State \t= LoadValue( txSoldier2State );\n\tgSniper        \t= LoadValue( txSniper );\n\tgPlayerBullet0 \t= LoadValue( txPlayerBullet0 );\n    gPlayerBullet1 \t= LoadValue( txPlayerBullet1 );\n    gPlayerBullet2 \t= LoadValue( txPlayerBullet2 );\n\tgPlayerBullet3 \t= LoadValue( txPlayerBullet3 );\n    gPlayerBullet4 \t= LoadValue( txPlayerBullet4 );\n    gPlayerBullet5 \t= LoadValue( txPlayerBullet5 );    \n\tgEnemyBullet0  \t= LoadValue( txEnemyBullet0 );\n\tgEnemyBullet1  \t= LoadValue( txEnemyBullet1 );\n    gEnemyBullet2  \t= LoadValue( txEnemyBullet2 );\n    gEnemyBullet3  \t= LoadValue( txEnemyBullet3 );\n\tgExplosion     \t= LoadValue( txExplosion );\n\tgHit           \t= LoadValue( txHit );\n\tgTurret0       \t= LoadValue( txTurret0 );\n\tgTurret1       \t= LoadValue( txTurret1 );\n\tgTurret0State   = LoadValue( txTurret0State );\n\tgTurret1State   = LoadValue( txTurret1State );    \n    gPowerUp\t\t= LoadValue( txPowerUp );\n    gPowerUpState\t= LoadValue( txPowerUpState );\n    gBossCore\t\t= LoadValue( txBossCore );\n    gBossCannon0\t= LoadValue( txBossCannon0 );\n    gBossCannon1\t= LoadValue( txBossCannon1 );\n    gBossBullet0\t= LoadValue( txBossBullet0 );\n    gBossBullet1\t= LoadValue( txBossBullet1 );\n    gGameState\t\t= LoadValue( txGameState );\n    gBridge\t\t\t= LoadValue( txBridge );\n\n    \/\/ game state machine\n    ++gGameState.y;    \n    if ( gGameState.x == GAME_STATE_TITLE )\n    {\n        if ( gGameState.y > UI_TITLE_TIME )\n        {\n            gGameState.x = GAME_STATE_LEVEL;\n            gGameState.y = 0.0;\n        }\n    }\n    else if ( gGameState.x == GAME_STATE_LEVEL )\n    {\n\t\tif ( gGameState.y <= UI_GAME_START_TIME )\n    \t{\n        \tgCamera \t\t= vec4( 32.0, -100.0, 0.0, 0.0 );\n\t\t\tgPlayer \t\t= vec4( gCamera.x + 32.0 * 2.0 + 24.0, PLAYER_SPAWN_HEIGHT, PLAYER_SPAWN_HEIGHT, 0.0 );\n    \t\tgPlayerState.x \t= STATE_JUMP;\n        \tgPlayerState.y \t= 0.0;        \n        \tgPlayerState.z \t= 1.0;\n        \tgPlayerState.w \t= PLAYER_LIFE_NUM;\n        \tgPlayerWeapon \t= vec4( WEAPON_RIFLE, 0.0, RIFLE_FIRE_RATE, RIFLE_BULLET_NUM );\n        \tgBossCore\t\t= vec4( 32.0 * 108.0 + 23.0 + 12.0, 34.0, BOSS_CORE_HP, 0.0 );\n            gBossCannon0\t= vec4( 3478.0, 92.0, 0.0, BOSS_CANNON_HP );\n            gBossCannon1\t= gBossCannon0 + vec4( 22.0, 0.0, 0.0, 0.0 );\n            gSoldier0\t\t= vec4( 0.0, 0.0, 0.0, 0.0 );\n            gSoldier1\t\t= vec4( 0.0, 0.0, 0.0, 0.0 );\n            gSoldier2\t\t= vec4( 0.0, 0.0, 0.0, 0.0 );\n            gBridge\t\t\t= vec4( 0.0, 0.0, 0.0, 0.0 );\n            gPowerUp\t\t= vec4( 0.0, 0.0, 0.0, 0.0 );\n            gTurret0\t\t= vec4( 0.0, 0.0, 0.0, 0.0 );\n            gTurret1\t\t= vec4( 0.0, 0.0, 0.0, 0.0 );\n    \t}\n    }\n    else if ( gGameState.x == GAME_STATE_LEVEL_DIE )\n    {\n        if ( gGameState.y > UI_TITLE_TIME )\n        {\n            gGameState.x = GAME_STATE_GAME_OVER;\n            gGameState.y = 0.0;\n        }\n    }    \n    else if ( gGameState.x == GAME_STATE_LEVEL_WIN )\n    {\n        if ( gGameState.y > UI_TITLE_TIME )\n        {\n            gGameState.x = GAME_STATE_VICTORY;\n            gGameState.y = 0.0;\n        }\n    }\n    else if ( gGameState.x == GAME_STATE_VICTORY )\n    {\n        if ( gGameState.y > UI_VICTORY_TIME )\n        {\n            gGameState.x = GAME_STATE_TITLE;\n            gGameState.y = 0.0;\n        }\n    } \n\tif ( gGameState.x == GAME_STATE_GAME_OVER )\n    {\n\t\tif ( gGameState.y > UI_TITLE_TIME )\n        {\n            gGameState.x = GAME_STATE_TITLE;\n            gGameState.y = 0.0;\n        }\n    }\n\n \n\tUpdateSpawner( screenWidth );\n        \n    \/\/ player state machine\n\tfloat playerSupport = GetSupport( gPlayer.xy );\n    if ( gPlayerState.x == STATE_RUN )\n    {\n        if ( keyJump )\n    \t{\n            gPlayer.z\t\t= gPlayer.y;\n            gPlayer.w\t\t= 0.0;\n\t        gPlayerState.x \t= STATE_JUMP;\n            gPlayerState.y \t= 0.0;\n\t\t\tgPlayerState.z \t= 0.0;\n    \t}\n        else if ( keyRight || keyLeft )\n        {\n    \t\tgPlayerState.y = mod( gPlayerState.y + PLAYER_RUN_ANIM_SPEED, 3.0 );\n        }        \n        else\n        {\n            if ( keyDown )\n            {\n                gPlayerState.x = STATE_PRONE;\n            }\n            gPlayerState.y = 0.0;\n        }\n\n        if ( gPlayer.y != playerSupport )\n        {\n\t\t\tgPlayerState.x = STATE_FALL;\n        }\n        if ( gPlayer.y <= WATER_HEIGHT )\n        {\n            if ( gPlayer.x < WATER_END )\n            {\n            \tgPlayerState.x = STATE_WATER;\n            }\n            else\n            {\n                PlayerHit( vec4( gPlayer.xy, BILL_PRONE_SIZE ) );\n            }\n        }\n    }        \n    else if ( gPlayerState.x == STATE_PRONE )\n    {\n        if ( !keyDown || keyRight || keyLeft )\n        {\n            gPlayerState.x = STATE_RUN;\n        }\n        else if ( keyJump )\n    \t{\n     \t\tgPlayerState.x = STATE_FALL;\n        \tgPlayer.y -= PLAYER_FALL_SPEED + 20.0;\n\t\t}        \n    }\n    else if ( gPlayerState.x == STATE_JUMP )\n    {\n        if ( keyRight )\n        {\n            gPlayer.w = 1.0;\n        }\n        else if ( keyLeft )\n        {\n            gPlayer.w = -1.0;\n        }\n        \n        gPlayerState.y = mod( gPlayerState.y + PLAYER_JUMP_ANIM_SPEED, 2.0 );\n\t\tgPlayerState.z += 1.0 \/ 30.0;\n        gPlayer.x += gPlayer.w * PLAYER_RUN_SPEED;\n        gPlayer.y += 4.5 * ( 1.0 - gPlayerState.z );\n        if ( gPlayerState.z > 1.0 && gPlayer.y <= playerSupport && gPlayer.y - gPlayer.z < PLAYER_JUMP_HEIGHT )\n        {\n            gPlayer.y = playerSupport;\n            gPlayerState.x = STATE_RUN;\n        }\n    }\n    else if ( gPlayerState.x == STATE_FALL )\n    {\n        if ( gPlayer.y <= playerSupport )\n        {\n            gPlayer.y = playerSupport;\n            gPlayerState.x = STATE_RUN;\n        }\n        else\n        {\n            gPlayer.y -= PLAYER_FALL_SPEED;\n        }\n    }    \n    else if ( gPlayerState.x == STATE_WATER )\n    {\n        if ( keyDown )\n        {\n\t\t\tgPlayerState.x = STATE_UNDER_WATER;\n        }\n        \n\t\tif ( playerSupport > WATER_HEIGHT )\n        {\n            gPlayerState.x \t= STATE_RUN;\n            gPlayer.y\t\t= playerSupport;\n        }\n    }\n    else if ( gPlayerState.x == STATE_UNDER_WATER )\n    {\n        if ( !keyDown )\n        {\n        \tgPlayerState.x = STATE_WATER;\n        }\n    }\n    \n    \/\/ importality tick\n    --gPlayerDir.w;\n    \n    \/\/ look dir\n    vec2 newDir;\n    gPlayerDir.x = keyRight ? 1.0 : ( keyLeft ? -1.0 : 0.0 );\n\tgPlayerDir.y = keyUp \t? 1.0 : ( keyDown ? -1.0 : 0.0 );\n    if ( ( gPlayerDir.x == 0.0 && gPlayerDir.y == 0.0 ) || gPlayerState.x == STATE_PRONE )\n    {\n        gPlayerDir.xy = gPlayerDir.z < 0.0 ? vec2( -1.0, 0.0 ) : vec2( 1.0, 0.0 );\n    }\n    \n    \/\/ flip\n    if ( keyRight && gPlayerState.x != STATE_UNDER_WATER )\n    {\n        gPlayerDir.z = 1.0;\n    }\n    else if ( keyLeft && gPlayerState.x != STATE_UNDER_WATER )\n    {\n        gPlayerDir.z = -1.0;\n    }    \n    \n    \/\/ move\n    if ( gPlayerState.x != STATE_PRONE && gPlayerState.x != STATE_UNDER_WATER && gPlayerState.x != STATE_JUMP )\n    {\n        if ( keyLeft )\n        {\n            gPlayer.x -= PLAYER_RUN_SPEED;\n        }\n        else if ( keyRight )\n        {\n            gPlayer.x += PLAYER_RUN_SPEED;\n        }\n    }\n    \n\n    \/\/ clamp player to edge of the screen\n    gPlayer.x = clamp( gPlayer.x, gCamera.x, PLAYER_END );\n    \n    \/\/ scroll camera\n   \tif ( gPlayer.x - screenWidth * 0.5 + 24.0 > gCamera.x )\n    {\n        gCamera.x = min( gPlayer.x - screenWidth * 0.5 + 24.0, CAMERA_END );\n    }\n        \n    \n    \/\/ player size and center\n    vec4 playerHitBox \t\t= vec4( 0.0, 0.0, BILL_RUN_SIZE );\n    vec2 playerWeaponOffset = gPlayerDir.y == 1.0 && gPlayerDir.x != 0.0 ? vec2( 6.0, 30.0 ) : ( gPlayerDir.y == 1.0 ? vec2( -2.0, 40.0 ) : ( gPlayerDir.y == -1.0 ? vec2( 7.0, 14.0 ) : vec2( 10.0, 19.0 ) ) );    \n    if ( gPlayerState.x == STATE_PRONE )\n    {\n        playerHitBox.zw\t\t= BILL_PRONE_SIZE;\n        playerWeaponOffset \t= vec2( 14.0, 7.0 );\n    }\n    else if ( gPlayerState.x == STATE_JUMP )\n    {    \n        playerHitBox.zw \t= BILL_JUMP_SIZE;\n        playerWeaponOffset \t= vec2( 0.0, BILL_JUMP_SIZE.y * 0.5 );\n    }\n    else if ( gPlayerState.x == STATE_WATER )\n    {\n        playerWeaponOffset.y -= 12.0;\n    }\n\n    playerHitBox.x = gPlayer.x;\n    playerHitBox.y = floor( gPlayer.y + playerHitBox.w * 0.5 * ( 1.0 - PLAYER_HIT_BOX_SIZE_MUL ) + 0.5 );\n    playerHitBox.zw *= PLAYER_HIT_BOX_SIZE_MUL;\n\n    if ( gPlayerDir.w > 0.0 || gPlayerState.x == STATE_UNDER_WATER )\n    {\n    \t\/\/ player is immortal        \n        playerHitBox = vec4( -1000000.0 );\n    }\n\n    playerWeaponOffset.x = gPlayerDir.z < 0.0 ? -playerWeaponOffset.x : playerWeaponOffset.x;\n    vec2 playerWeapon = gPlayer.xy + playerWeaponOffset;\n    vec2 playerTarget = gPlayer.xy + vec2( 0.0, BILL_RUN_SIZE.y * 0.5 );\n    \n    \/\/ player shooting\n    ++gPlayerWeapon.y;\n    float playerBulletNum = \tfloat( gPlayerBullet0.x > 0.0 ) \n        \t\t\t\t\t+ \tfloat( gPlayerBullet1.x > 0.0 )\n    \t\t\t\t\t\t+ \tfloat( gPlayerBullet2.x > 0.0 )\n    \t\t\t\t\t\t+ \tfloat( gPlayerBullet3.x > 0.0 )\n    \t\t\t\t\t\t+ \tfloat( gPlayerBullet4.x > 0.0 )\n    \t\t\t\t\t\t+ \tfloat( gPlayerBullet5.x > 0.0 );\n\n    if ( keyShoot && gPlayerWeapon.y > gPlayerWeapon.z && playerBulletNum < gPlayerWeapon.w && gPlayerState.x != STATE_UNDER_WATER )\n    {\n        gPlayerWeapon.y = 0.0;\n        if ( gPlayerBullet0.x <= 0.0 )\n        {\n        \tgPlayerBullet0.xy = playerWeapon;\n            gPlayerBullet0.zw = normalize( gPlayerDir.xy );\n        }\n        else if ( gPlayerBullet1.x <= 0.0 )\n        {\n        \tgPlayerBullet1.xy = playerWeapon;\n            gPlayerBullet1.zw = normalize( gPlayerDir.xy );\n        }\n        else if ( gPlayerBullet2.x <= 0.0 )\n        {\n        \tgPlayerBullet2.xy = playerWeapon;\n            gPlayerBullet2.zw = normalize( gPlayerDir.xy );\n        }     \n        else if ( gPlayerBullet3.x <= 0.0 )\n        {\n        \tgPlayerBullet3.xy = playerWeapon;\n            gPlayerBullet3.zw = normalize( gPlayerDir.xy );\n        }\n        else if ( gPlayerBullet4.x <= 0.0 )\n        {\n        \tgPlayerBullet4.xy = playerWeapon;\n            gPlayerBullet4.zw = normalize( gPlayerDir.xy );\n        }  \n        else if ( gPlayerBullet5.x <= 0.0 )\n        {\n        \tgPlayerBullet5.xy = playerWeapon;\n            gPlayerBullet5.zw = normalize( gPlayerDir.xy );\n        }          \n    }\n    \n    UpdatePlayerBullet( gPlayerBullet0, screenWidth, screenHeight );\n    UpdatePlayerBullet( gPlayerBullet1, screenWidth, screenHeight );\n    UpdatePlayerBullet( gPlayerBullet2, screenWidth, screenHeight );\n    UpdatePlayerBullet( gPlayerBullet3, screenWidth, screenHeight );\n    UpdatePlayerBullet( gPlayerBullet4, screenWidth, screenHeight );\n    UpdatePlayerBullet( gPlayerBullet5, screenWidth, screenHeight );    \n    UpdateEnemyBullet( gEnemyBullet0, playerHitBox, screenWidth, screenHeight );\n    UpdateEnemyBullet( gEnemyBullet1, playerHitBox, screenWidth, screenHeight );\n    UpdateEnemyBullet( gEnemyBullet2, playerHitBox, screenWidth, screenHeight );\n    UpdateEnemyBullet( gEnemyBullet3, playerHitBox, screenWidth, screenHeight );\n    UpdateBossBullet( gBossBullet0, playerHitBox, screenWidth, screenHeight );\n    UpdateBossBullet( gBossBullet1, playerHitBox, screenWidth, screenHeight );\n    UpdateSoldier( gSoldier0, gSoldier0State, playerHitBox, screenWidth, screenHeight );\n    UpdateSoldier( gSoldier1, gSoldier1State, playerHitBox, screenWidth, screenHeight );\n    UpdateSoldier( gSoldier2, gSoldier2State, playerHitBox, screenWidth, screenHeight );\n\n    PlayerBulletSoldierTest( gPlayerBullet0, gSoldier0 );\n    PlayerBulletSoldierTest( gPlayerBullet1, gSoldier0 );\n    PlayerBulletSoldierTest( gPlayerBullet2, gSoldier0 );\n    PlayerBulletSoldierTest( gPlayerBullet3, gSoldier0 );\n    PlayerBulletSoldierTest( gPlayerBullet4, gSoldier0 );\n    PlayerBulletSoldierTest( gPlayerBullet5, gSoldier0 );    \n    \n    PlayerBulletSoldierTest( gPlayerBullet0, gSoldier1 );\n    PlayerBulletSoldierTest( gPlayerBullet1, gSoldier1 );\n    PlayerBulletSoldierTest( gPlayerBullet2, gSoldier1 );\n    PlayerBulletSoldierTest( gPlayerBullet3, gSoldier1 );\n    PlayerBulletSoldierTest( gPlayerBullet4, gSoldier1 );\n    PlayerBulletSoldierTest( gPlayerBullet5, gSoldier1 );    \n    \n    PlayerBulletSoldierTest( gPlayerBullet0, gSoldier2 );\n    PlayerBulletSoldierTest( gPlayerBullet1, gSoldier2 );\n    PlayerBulletSoldierTest( gPlayerBullet2, gSoldier2 );\n    PlayerBulletSoldierTest( gPlayerBullet3, gSoldier2 );\n    PlayerBulletSoldierTest( gPlayerBullet4, gSoldier2 );\n    PlayerBulletSoldierTest( gPlayerBullet5, gSoldier2 );    \n    \n    PlayerBulletSniperTest( gPlayerBullet0, gSniper );\n    PlayerBulletSniperTest( gPlayerBullet1, gSniper );\n    PlayerBulletSniperTest( gPlayerBullet2, gSniper );\n    PlayerBulletSniperTest( gPlayerBullet3, gSniper );\n    PlayerBulletSniperTest( gPlayerBullet4, gSniper );\n    PlayerBulletSniperTest( gPlayerBullet5, gSniper );    \n    \n    PlayerBulletTurretTest( gPlayerBullet0, gTurret0, gTurret0State );\n    PlayerBulletTurretTest( gPlayerBullet1, gTurret0, gTurret0State );\n    PlayerBulletTurretTest( gPlayerBullet2, gTurret0, gTurret0State );\n    PlayerBulletTurretTest( gPlayerBullet3, gTurret0, gTurret0State );\n    PlayerBulletTurretTest( gPlayerBullet4, gTurret0, gTurret0State );\n    PlayerBulletTurretTest( gPlayerBullet5, gTurret0, gTurret0State );    \n    \n    PlayerBulletTurretTest( gPlayerBullet0, gTurret1, gTurret1State );\n    PlayerBulletTurretTest( gPlayerBullet1, gTurret1, gTurret1State );\n    PlayerBulletTurretTest( gPlayerBullet2, gTurret1, gTurret1State );\n    PlayerBulletTurretTest( gPlayerBullet3, gTurret1, gTurret1State );\n    PlayerBulletTurretTest( gPlayerBullet4, gTurret1, gTurret1State );\n    PlayerBulletTurretTest( gPlayerBullet5, gTurret1, gTurret1State );    \n    \n    PlayerBulletPowerUpTest( gPlayerBullet0 );\n    PlayerBulletPowerUpTest( gPlayerBullet1 );\n    PlayerBulletPowerUpTest( gPlayerBullet2 );\n    PlayerBulletPowerUpTest( gPlayerBullet3 );\n    PlayerBulletPowerUpTest( gPlayerBullet4 );\n    PlayerBulletPowerUpTest( gPlayerBullet5 );    \n    \n    PlayerBulletBossCoreTest( gPlayerBullet0 );\n    PlayerBulletBossCoreTest( gPlayerBullet1 );\n    PlayerBulletBossCoreTest( gPlayerBullet2 );\n    PlayerBulletBossCoreTest( gPlayerBullet3 );\n    PlayerBulletBossCoreTest( gPlayerBullet4 );\n    PlayerBulletBossCoreTest( gPlayerBullet5 );  \n    \n    PlayerBulletBossCannonTest( gPlayerBullet0, gBossCannon0 );\n    PlayerBulletBossCannonTest( gPlayerBullet1, gBossCannon0 );\n    PlayerBulletBossCannonTest( gPlayerBullet2, gBossCannon0 );\n    PlayerBulletBossCannonTest( gPlayerBullet3, gBossCannon0 );\n    PlayerBulletBossCannonTest( gPlayerBullet4, gBossCannon0 );\n\tPlayerBulletBossCannonTest( gPlayerBullet5, gBossCannon0 );  \n\n    PlayerBulletBossCannonTest( gPlayerBullet0, gBossCannon1 );\n    PlayerBulletBossCannonTest( gPlayerBullet1, gBossCannon1 );\n    PlayerBulletBossCannonTest( gPlayerBullet2, gBossCannon1 );\n    PlayerBulletBossCannonTest( gPlayerBullet3, gBossCannon1 );\n    PlayerBulletBossCannonTest( gPlayerBullet4, gBossCannon1 );\n\tPlayerBulletBossCannonTest( gPlayerBullet5, gBossCannon1 );  \t    \n     \n    \n    \/\/ powerup state machine\n\tfloat powerUpSupport = GetSupport( gPowerUp.xy );    \n    if ( gPowerUp.x > 0.0 )\n    {\n        if( gPowerUpState.x == STATE_RUN )\n        {        \n            gPowerUp.x += 2.0;\n            gPowerUp.y = gPowerUpState.y + 32.0 * sin( 5.0 * iTime );\n        }\n        else if( gPowerUpState.x == STATE_JUMP )\n        {\n            gPowerUpState.z += 1.0 \/ 30.0;\n            gPowerUp.x += 1.0;\n            gPowerUp.y += 4.5 * ( 1.0 - gPowerUpState.z );\n            if ( gPowerUpState.z > 1.0 && gPowerUp.y <= powerUpSupport )\n            {\n                if ( gPowerUp.y <= WATER_HEIGHT )\n                {\n                    gPowerUp.x = 0.0;\n                    gExplosion = vec4( gPowerUp.xy + vec2( 0.0, POWER_UP_SIZE.y * 0.5 ), 0.0, 0.0 );\n                }\n                else\n                {\t\n                    gPowerUp.y = powerUpSupport;\n                \tgPowerUpState.x = STATE_WATER;\n                }\n            } \n        }\n        \n        if ( gPowerUpState.x != STATE_RUN )\n        {\n            if ( Collide( gPlayer.xy, BILL_RUN_SIZE, gPowerUp.xy, POWER_UP_SIZE ) )\n            {\n                gPowerUp.x \t\t= 0.0;\n\t\t\t\tgPlayerWeapon \t= vec4( WEAPON_MACHINE_GUN, 0.0, MACHINE_GUN_FIRE_RATE, MACHINE_GUN_BULLET_NUM );\n            }  \n        }\n    }\n    \n    \/\/ first exploding bridge\n    if ( gPlayer.x > BRIDGE_0_START_TILE * 32.0 - 16.0 && gBridge.x == 0.0 )\n    {\n        gBridge.x \t= BRIDGE_0_START_TILE;\n        gBridge.y \t= 0.0;\n        gExplosion \t= vec4( gBridge.x * 32.0 + 16.0, 16.0 * 6.0, 0.0, 0.0 );\n    }\n    if ( gBridge.x > 0.0 && gBridge.x < BRIDGE_0_END_TILE - 1.0 )\n    {\n        ++gBridge.y;\n        if ( gBridge.y > BRIGDE_EXPLODE_TIME )\n        {\n            ++gBridge.x;\n            gBridge.y = 0.0;\n            gExplosion = vec4( gBridge.x * 32.0 + 16.0, 16.0 * 6.0, 0.0, 0.0 );\n        }\n    }\n    \n    \/\/ second exploding bridge\n    if ( gPlayer.x > BRIDGE_1_START_TILE * 32.0 - 16.0 && gBridge.x == BRIDGE_0_END_TILE - 1.0 )\n    {\n        gBridge.x \t= BRIDGE_1_START_TILE;\n        gBridge.y \t= 0.0;\n        gExplosion \t= vec4( gBridge.x * 32.0 + 16.0, 16.0 * 6.0, 0.0, 0.0 );\n    }\n    if ( gBridge.x >= BRIDGE_1_START_TILE - 1.0 && gBridge.x < BRIDGE_1_END_TILE - 1.0 )\n    {\n        ++gBridge.y;\n        if ( gBridge.y > BRIGDE_EXPLODE_TIME )\n        {\n            ++gBridge.x;\n            gBridge.y = 0.0;\n            gExplosion = vec4( gBridge.x * 32.0 + 16.0, 16.0 * 6.0, 0.0, 0.0 );\n        }\n    }    \n    \n\tUpdateSniper( gSniper, playerTarget );    \n\tUpdateTurret( gTurret0, gTurret0State, playerTarget );\n    UpdateTurret( gTurret1, gTurret1State, playerTarget );\n    UpdateBossCannon( gBossCannon0 );\n    UpdateBossCannon( gBossCannon1 );\n    \n    \/\/ explosion\n    if ( gExplosion.z >= 3.0 )\n    {\n        gExplosion.xy = vec2( 0.0 );\n    }\n    else\n    {\n        gExplosion.z += 0.2;\n    }\n    \n    \/\/ hits\n    if ( gHit.z >= 1.0 )\n    {\n\t\tgHit.xy = vec2( 0.0 );\n    }\n    else\n    {\n        gHit.z += 0.2;\n    }    \n    \n    fragColor = vec4( 0.0 );\n    StoreValue( txPlayer, gPlayer, fragColor, fragCoord );\n    StoreValue( txPlayerState, gPlayerState, fragColor, fragCoord );\n    StoreValue( txPlayerWeapon, gPlayerWeapon, fragColor, fragCoord );\n    StoreValue( txPlayerDir, gPlayerDir, fragColor, fragCoord );\n    StoreValue( txCamera, gCamera, fragColor, fragCoord );\n    StoreValue( txSoldier0, gSoldier0, fragColor, fragCoord );\n    StoreValue( txSoldier1, gSoldier1, fragColor, fragCoord );\n    StoreValue( txSoldier2, gSoldier2, fragColor, fragCoord );\n    StoreValue( txSoldier0State, gSoldier0State, fragColor, fragCoord );\n    StoreValue( txSoldier1State, gSoldier1State, fragColor, fragCoord );\n    StoreValue( txSoldier2State, gSoldier2State, fragColor, fragCoord );\n    StoreValue( txSniper, gSniper, fragColor, fragCoord );\n    StoreValue( txPlayerBullet0, gPlayerBullet0, fragColor, fragCoord );\n    StoreValue( txPlayerBullet1, gPlayerBullet1, fragColor, fragCoord );\n    StoreValue( txPlayerBullet2, gPlayerBullet2, fragColor, fragCoord );\n    StoreValue( txPlayerBullet3, gPlayerBullet3, fragColor, fragCoord );\n    StoreValue( txPlayerBullet4, gPlayerBullet4, fragColor, fragCoord );\n    StoreValue( txPlayerBullet5, gPlayerBullet5, fragColor, fragCoord );    \n    StoreValue( txEnemyBullet0, gEnemyBullet0, fragColor, fragCoord );\n    StoreValue( txEnemyBullet1, gEnemyBullet1, fragColor, fragCoord );\n    StoreValue( txEnemyBullet2, gEnemyBullet2, fragColor, fragCoord );\n    StoreValue( txEnemyBullet3, gEnemyBullet3, fragColor, fragCoord );\n    StoreValue( txExplosion, gExplosion, fragColor, fragCoord );\n    StoreValue( txHit, gHit, fragColor, fragCoord );\n    StoreValue( txTurret0, gTurret0, fragColor, fragCoord );\n    StoreValue( txTurret1, gTurret1, fragColor, fragCoord );\n    StoreValue( txTurret0State, gTurret0State, fragColor, fragCoord );\n    StoreValue( txTurret1State, gTurret1State, fragColor, fragCoord );    \n    StoreValue( txPowerUp, gPowerUp, fragColor, fragCoord );\n    StoreValue( txPowerUpState, gPowerUpState, fragColor, fragCoord );\n    StoreValue( txBossCore, gBossCore, fragColor, fragCoord );\n    StoreValue( txBossCannon0, gBossCannon0, fragColor, fragCoord );\n    StoreValue( txBossCannon1, gBossCannon1, fragColor, fragCoord );\n    StoreValue( txBossBullet0, gBossBullet0, fragColor, fragCoord );\n    StoreValue( txBossBullet1, gBossBullet1, fragColor, fragCoord );    \n    StoreValue( txGameState, gGameState, fragColor, fragCoord );\n    StoreValue( txBridge, gBridge, fragColor, fragCoord );\n    \n    \/\/ clear to 0 on first frame\n    fragColor = iFrame < 1 ? vec4( 0.0 ) : fragColor;\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/\/ Background\n\n#define SPRITE_DEC_2( x, i ) mod( floor( i \/ pow( 2.0, mod( x, 24.0 ) ) ), 2.0 )\n#define SPRITE_DEC_3( x, i ) mod( floor( i \/ pow( 4.0, mod( x, 11.0 ) ) ), 4.0 )\n#define SPRITE_DEC_4( x, i ) mod( floor( i \/ pow( 4.0, mod( x, 8.0 ) ) ), 4.0 )\n#define RGB( r, g, b ) vec3( float( r ) \/ 255.0, float( g ) \/ 255.0, float( b ) \/ 255.0 )\n\nconst float NES_RES_X           = 224.0;\nconst float NES_RES_Y           = 192.0;\nconst float JUNGLE_START        = 32.0 * 52.0;\nconst float JUNGLE_END          = 32.0 * 108.0 + 16.0;\nconst float WATER_END           = 32.0 * 63.0;\nconst vec2  BOSS_CORE_SIZE      = vec2( 24.0, 31.0 );\nconst vec2  BOSS_CANNON_SIZE    = vec2( 14.0, 6.0 );\nconst float BRIDGE_0_START_TILE = 30.0;\nconst float BRIDGE_0_END_TILE   = 35.0;\nconst float BRIDGE_1_START_TILE = 40.0;\nconst float BRIDGE_1_END_TILE   = 45.0;\n\n\/\/ storage\nconst vec2 txPlayer \t\t\t= vec2( 0.0, 0.0 ); \t\/\/ xy - pos, z - jump start, w - jump dir\nconst vec2 txPlayerState\t\t= vec2( 1.0, 0.0 ); \t\/\/ x - state, y - frame, z - jump tick, w - lifes\nconst vec2 txPlayerDir\t\t\t= vec2( 2.0, 0.0 ); \t\/\/ xy - dir, z - flip, w - immortality\nconst vec2 txPlayerWeapon\t\t= vec2( 3.0, 0.0 ); \t\/\/ x - weapon, y - weapon cooldown, z - weapon fire rate, w - weapon bullet num\nconst vec2 txCamera \t\t\t= vec2( 4.0, 0.0 ); \t\/\/ x - cam offset, y - spawn counter, z - soldier spawn counter\nconst vec2 txSoldier0 \t\t\t= vec2( 5.0, 0.0 ); \t\/\/ xy - pos, z - flip\nconst vec2 txSoldier1 \t\t\t= vec2( 5.0, 1.0 ); \t\/\/ xy - pos, z - flip\nconst vec2 txSoldier2 \t\t\t= vec2( 5.0, 2.0 ); \t\/\/ xy - pos, z - flip\nconst vec2 txSoldier0State \t\t= vec2( 6.0, 0.0 ); \t\/\/ x - state, y - frame, z - jump tick\nconst vec2 txSoldier1State \t\t= vec2( 6.0, 1.0 ); \t\/\/ x - state, y - frame, z - jump tick\nconst vec2 txSoldier2State \t\t= vec2( 6.0, 2.0 ); \t\/\/ x - state, y - frame, z - jump tick\nconst vec2 txSniper\t \t\t\t= vec2( 7.0, 0.0 ); \t\/\/ xy - pos, z - flip, w - weapon cooldown\nconst vec2 txPlayerBullet0 \t\t= vec2( 8.0, 0.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txPlayerBullet1 \t\t= vec2( 8.0, 1.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txPlayerBullet2 \t\t= vec2( 8.0, 2.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txPlayerBullet3 \t\t= vec2( 8.0, 3.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txPlayerBullet4 \t\t= vec2( 8.0, 4.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txPlayerBullet5 \t\t= vec2( 8.0, 5.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txEnemyBullet0 \t\t= vec2( 9.0, 0.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txEnemyBullet1 \t\t= vec2( 9.0, 1.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txEnemyBullet2 \t\t= vec2( 9.0, 2.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txEnemyBullet3 \t\t= vec2( 9.0, 3.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txExplosion \t\t\t= vec2( 10.0, 0.0 ); \t\/\/ xy - pos, z - frame\nconst vec2 txHit \t\t\t\t= vec2( 11.0, 0.0 ); \t\/\/ xy - pos, z - frame\nconst vec2 txTurret0\t\t\t= vec2( 12.0, 0.0 ); \t\/\/ xy - pos, z - angle\nconst vec2 txTurret1\t\t\t= vec2( 12.0, 1.0 ); \t\/\/ xy - pos, z - angle\nconst vec2 txTurret0State\t\t= vec2( 13.0, 0.0 ); \t\/\/ x - HP, y - weapon cooldown\nconst vec2 txTurret1State\t\t= vec2( 13.0, 1.0 ); \t\/\/ x - HP, y - weapon cooldown\nconst vec2 txPowerUp\t\t\t= vec2( 14.0, 0.0 ); \t\/\/ xy - pos, z - frame\nconst vec2 txPowerUpState\t\t= vec2( 15.0, 0.0 ); \t\/\/ x - state, y - initial height, z - jump tick\nconst vec2 txBossCore\t\t\t= vec2( 16.0, 0.0 ); \t\/\/ xy - pos, z - HP\nconst vec2 txBossCannon0\t\t= vec2( 17.0, 0.0 ); \t\/\/ xy - pos, z - cooldown, w - HP\nconst vec2 txBossCannon1\t\t= vec2( 17.0, 1.0 ); \t\/\/ xy - pos, z - cooldown, w - HP\nconst vec2 txBossBullet0\t\t= vec2( 18.0, 0.0 ); \t\/\/ xy - pos, zw - velocity\nconst vec2 txBossBullet1\t\t= vec2( 18.0, 1.0 ); \t\/\/ xy - pos, zw - velocity\nconst vec2 txGameState\t\t\t= vec2( 19.0, 0.0 ); \t\/\/ x - state, y - state tick\nconst vec2 txBridge\t\t\t\t= vec2( 20.0, 0.0 ); \t\/\/ x - draw start, y - explode tick\n\nfloat Rand( vec2 co )\n{\n    return fract( sin( dot( co.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\n}\n\nvec4 LoadValue( vec2 tx )\n{\n    return floor( texture( iChannel0, ( tx + 0.5 ) \/ iChannelResolution[ 0 ].xy ) );\n}\n\nvoid SpriteBush( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;    \n    \n    idx = y == 8.0 ? ( x <= 10.0 ? 1419584.0 : ( x <= 21.0 ? 1.0 : 1360.0 ) ) : idx;\n    idx = y == 7.0 ? ( x <= 10.0 ? 2796196.0 : ( x <= 21.0 ? 21.0 : 22176.0 ) ) : idx;\n    idx = y == 6.0 ? ( x <= 10.0 ? 2796201.0 : ( x <= 21.0 ? 87125.0 : 87721.0 ) ) : idx;\n    idx = y == 5.0 ? ( x <= 10.0 ? 2534058.0 : ( x <= 21.0 ? 436310.0 : 88681.0 ) ) : idx;\n    idx = y == 4.0 ? ( x <= 10.0 ? 1681065.0 : ( x <= 21.0 ? 365637.0 : 71061.0 ) ) : idx;\n    idx = y == 3.0 ? ( x <= 10.0 ? 1464937.0 : ( x <= 21.0 ? 91137.0 : 1381.0 ) ) : idx;\n    idx = y == 2.0 ? ( x <= 10.0 ? 1332565.0 : ( x <= 21.0 ? 283908.0 : 266564.0 ) ) : idx;\n    idx = y == 1.0 ? ( x <= 10.0 ? 332884.0 : ( x <= 21.0 ? 267328.0 : 65616.0 ) ) : idx;\n\n    idx = SPRITE_DEC_3( x, idx );\n\n    color = y >= 0.0 && y < 9.0 ? RGB( 0, 0, 0 ) : color;\n    color = idx == 1.0 ? RGB( 0,   144, 0 ) : color;\n    color = idx == 2.0 ? RGB( 144, 213, 0 ) : color;\n}\n\nvoid SpriteRockTop( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;    \n    \n    idx = y == 7.0 ? ( x <= 7.0 ? 20480.0 : ( x <= 15.0 ? 89.0 : ( x <= 23.0 ? 0.0 : 341.0 ) ) ) : idx;\n    idx = y == 6.0 ? ( x <= 7.0 ? 38144.0 : ( x <= 15.0 ? 5466.0 : ( x <= 23.0 ? 20480.0 : 5466.0 ) ) ) : idx;\n    idx = y == 5.0 ? ( x <= 7.0 ? 43604.0 : ( x <= 15.0 ? 21851.0 : ( x <= 23.0 ? 42305.0 : 1386.0 ) ) ) : idx;\n    idx = y == 4.0 ? ( x <= 7.0 ? 65168.0 : ( x <= 15.0 ? 21866.0 : ( x <= 23.0 ? 43345.0 : 1387.0 ) ) ) : idx;\n    idx = y == 3.0 ? ( x <= 7.0 ? 47680.0 : ( x <= 15.0 ? 21914.0 : ( x <= 23.0 ? 64144.0 : 5547.0 ) ) ) : idx;\n    idx = y == 2.0 ? ( x <= 7.0 ? 43269.0 : ( x <= 15.0 ? 5718.0 : ( x <= 23.0 ? 65188.0 : 5526.0 ) ) ) : idx;\n    idx = y == 1.0 ? ( x <= 7.0 ? 20584.0 : ( x <= 15.0 ? 1.0 : ( x <= 23.0 ? 60329.0 : 22102.0 ) ) ) : idx;\n    idx = y == 0.0 ? ( x <= 7.0 ? 5860.0 : ( x <= 15.0 ? 0.0 : ( x <= 23.0 ? 43769.0 : 22101.0 ) ) ) : idx;\n    \n    idx = SPRITE_DEC_4( x, idx );\n    idx = x >= 0.0 && x < 32.0 ? idx : 0.0;\n    \n    color = x >= 0.0 && x < 32.0 && y >= 0.0 && y < 8.0 ? RGB( 0, 0, 0 ) : color;\n    color = idx == 1.0 ? RGB( 68,  80,  0 ) : color;\n    color = idx == 2.0 ? RGB( 126, 126, 0 ) : color;\n    color = idx == 3.0 ? RGB( 208, 190, 0 ) : color;\n}\n\nvoid SpriteRock( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;    \n    \n    idx = y == 31.0 ? ( x <= 7.0 ? 5860.0 : ( x <= 15.0 ? 0.0 : ( x <= 23.0 ? 43769.0 : 22101.0 ) ) ) : idx;\n    idx = y == 30.0 ? ( x <= 7.0 ? 1444.0 : ( x <= 15.0 ? 1365.0 : ( x <= 23.0 ? 45049.0 : 22869.0 ) ) ) : idx;\n    idx = y == 29.0 ? ( x <= 7.0 ? 17809.0 : ( x <= 15.0 ? 6826.0 : ( x <= 23.0 ? 32420.0 : 22869.0 ) ) ) : idx;\n    idx = y == 28.0 ? ( x <= 7.0 ? 37201.0 : ( x <= 15.0 ? 27311.0 : ( x <= 23.0 ? 27284.0 : 25941.0 ) ) ) : idx;\n    idx = y == 27.0 ? ( x <= 7.0 ? 57669.0 : ( x <= 15.0 ? 27327.0 : ( x <= 23.0 ? 43668.0 : 25941.0 ) ) ) : idx;\n    idx = y == 26.0 ? ( x <= 7.0 ? 58373.0 : ( x <= 15.0 ? 43695.0 : ( x <= 23.0 ? 43601.0 : 38229.0 ) ) ) : idx;\n    idx = y == 25.0 ? ( x <= 7.0 ? 63765.0 : ( x <= 15.0 ? 43695.0 : ( x <= 23.0 ? 43345.0 : 38230.0 ) ) ) : idx;\n    idx = y == 24.0 ? ( x <= 7.0 ? 63764.0 : ( x <= 15.0 ? 43695.0 : ( x <= 23.0 ? 42322.0 : 38234.0 ) ) ) : idx;\n    idx = y == 23.0 ? ( x <= 7.0 ? 63748.0 : ( x <= 15.0 ? 43695.0 : ( x <= 23.0 ? 42310.0 : 21866.0 ) ) ) : idx;\n    idx = y == 22.0 ? ( x <= 7.0 ? 65088.0 : ( x <= 15.0 ? 43711.0 : ( x <= 23.0 ? 42266.0 : 5486.0 ) ) ) : idx;\n    idx = y == 21.0 ? ( x <= 7.0 ? 65092.0 : ( x <= 15.0 ? 43711.0 : ( x <= 23.0 ? 37914.0 : 5566.0 ) ) ) : idx;\n    idx = y == 20.0 ? ( x <= 7.0 ? 65088.0 : ( x <= 15.0 ? 43775.0 : ( x <= 23.0 ? 20570.0 : 5886.0 ) ) ) : idx;\n    idx = y == 19.0 ? ( x <= 7.0 ? 65089.0 : ( x <= 15.0 ? 43775.0 : ( x <= 23.0 ? 20570.0 : 5881.0 ) ) ) : idx;\n    idx = y == 18.0 ? ( x <= 7.0 ? 64145.0 : ( x <= 15.0 ? 44031.0 : ( x <= 23.0 ? 20570.0 : 1445.0 ) ) ) : idx;\n    idx = y == 17.0 ? ( x <= 7.0 ? 43664.0 : ( x <= 15.0 ? 44031.0 : ( x <= 23.0 ? 16730.0 : 1429.0 ) ) ) : idx;\n    idx = y == 16.0 ? ( x <= 7.0 ? 43664.0 : ( x <= 15.0 ? 44798.0 : ( x <= 23.0 ? 16730.0 : 18005.0 ) ) ) : idx;\n    idx = y == 15.0 ? ( x <= 7.0 ? 44004.0 : ( x <= 15.0 ? 22266.0 : ( x <= 23.0 ? 16741.0 : 18005.0 ) ) ) : idx;\n    idx = y == 14.0 ? ( x <= 7.0 ? 45049.0 : ( x <= 15.0 ? 21930.0 : ( x <= 23.0 ? 1381.0 : 1621.0 ) ) ) : idx;\n    idx = y == 13.0 ? ( x <= 7.0 ? 49065.0 : ( x <= 15.0 ? 21930.0 : ( x <= 23.0 ? 1429.0 : 1365.0 ) ) ) : idx;\n    idx = y == 12.0 ? ( x <= 7.0 ? 60073.0 : ( x <= 15.0 ? 21867.0 : ( x <= 23.0 ? 1429.0 : 340.0 ) ) ) : idx;\n    idx = y == 11.0 ? ( x <= 7.0 ? 43689.0 : ( x <= 15.0 ? 21846.0 : ( x <= 23.0 ? 1109.0 : 340.0 ) ) ) : idx;\n    idx = y == 10.0 ? ( x <= 7.0 ? 43690.0 : ( x <= 15.0 ? 21846.0 : ( x <= 23.0 ? 357.0 : 340.0 ) ) ) : idx;\n    idx = y == 9.0 ? ( x <= 7.0 ? 38566.0 : ( x <= 15.0 ? 21849.0 : ( x <= 23.0 ? 1049.0 : 336.0 ) ) ) : idx;\n    idx = y == 8.0 ? ( x <= 7.0 ? 25941.0 : ( x <= 15.0 ? 21849.0 : ( x <= 23.0 ? 4101.0 : 256.0 ) ) ) : idx;\n    idx = y == 7.0 ? ( x <= 7.0 ? 25941.0 : ( x <= 15.0 ? 21861.0 : ( x <= 23.0 ? 1.0 : 21.0 ) ) ) : idx;\n    idx = y == 6.0 ? ( x <= 7.0 ? 22868.0 : ( x <= 15.0 ? 23141.0 : ( x <= 23.0 ? 20480.0 : 361.0 ) ) ) : idx;\n    idx = y == 5.0 ? ( x <= 7.0 ? 21840.0 : ( x <= 15.0 ? 5525.0 : ( x <= 23.0 ? 42240.0 : 5546.0 ) ) ) : idx;\n    idx = y == 4.0 ? ( x <= 7.0 ? 20800.0 : ( x <= 15.0 ? 5377.0 : ( x <= 23.0 ? 64080.0 : 1451.0 ) ) ) : idx;\n    idx = y == 3.0 ? ( x <= 7.0 ? 4096.0 : ( x <= 15.0 ? 1024.0 : ( x <= 23.0 ? 65428.0 : 1391.0 ) ) ) : idx;\n    idx = y == 2.0 ? ( x <= 7.0 ? 16464.0 : ( x <= 15.0 ? 1024.0 : ( x <= 23.0 ? 65188.0 : 5531.0 ) ) ) : idx;\n    idx = y == 1.0 ? ( x <= 7.0 ? 5541.0 : ( x <= 15.0 ? 4097.0 : ( x <= 23.0 ? 60069.0 : 5526.0 ) ) ) : idx;\n    idx = y == 0.0 ? ( x <= 7.0 ? 23288.0 : ( x <= 15.0 ? 0.0 : ( x <= 23.0 ? 43705.0 : 22101.0 ) ) ) : idx;\n\n    idx = SPRITE_DEC_4( x, idx );\n    idx = x >= 0.0 && x < 32.0 ? idx : 0.0;\n    \n    color = x >= 0.0 && x < 32.0 && y >= 0.0 && y < 32.0 ? RGB( 0, 0, 0 ) : color;\n    color = idx == 1.0 ? RGB( 68,  80,  0 ) : color;\n    color = idx == 2.0 ? RGB( 126, 126, 0 ) : color;\n    color = idx == 3.0 ? RGB( 208, 190, 0 ) : color;\n}\n\nvoid SpriteTreeTrunk( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n    \n    idx = y == 1.0 ? 2918701.0 : idx;\n    idx = y == 0.0 ? 1263122.0 : idx;\n    \n    idx = SPRITE_DEC_2( x, idx );\n    \n    color = idx == 1.0 ? RGB( 64,  44,  0 ) : RGB( 0,  0,  0 );\n}\n\nvoid SpriteTreeStart( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n    \n\tidx = y == 22.0 ? 32768.0 : idx;\n\tidx = y == 21.0 ? 10240.0 : idx;\n\tidx = y == 20.0 ? 9088.0 : idx;\n\tidx = y == 19.0 ? 10976.0 : idx;\n\tidx = y == 18.0 ? 9016.0 : idx;\n\tidx = y == 17.0 ? 33580.0 : idx;\n\tidx = y == 16.0 ? 2874.0 : idx;\n\tidx = y == 15.0 ? 41644.0 : idx;\n\tidx = y == 14.0 ? 13240.0 : idx;\n\tidx = y == 13.0 ? 824.0 : idx;\n\tidx = y == 12.0 ? 4128.0 : idx;\n\tidx = y == 11.0 ? 17408.0 : idx;\n\tidx = y == 10.0 ? 1024.0 : idx;\n\tidx = y == 9.0 ? 34048.0 : idx;\n\tidx = y == 8.0 ? 33024.0 : idx;\n\tidx = y == 7.0 ? 0.0 : idx;\n\tidx = y == 6.0 ? 51840.0 : idx;\n\tidx = y == 5.0 ? 44000.0 : idx;\n\tidx = y == 4.0 ? 1760.0 : idx;\n\tidx = y == 3.0 ? 17584.0 : idx;\n\tidx = y == 2.0 ? 17440.0 : idx;\n\tidx = y == 1.0 ? 17440.0 : idx;\n\tidx = y == 0.0 ? 16384.0 : idx;\n    \n    idx = SPRITE_DEC_4( x, idx );\n    idx = x >= 0.0 && x < 8.0 ? idx : 0.0;\n\n    color = x >= 0.0 && x < 8.0 && y >= 0.0 && y < 24.0 ? RGB( 0, 0, 0 ) : color;\n    color = idx == 1.0 ? RGB( 64, 44, 0 ) : color;\n    color = idx == 2.0 ? RGB( 0, 148, 0 ) : color;    \n    color = idx == 3.0 ? RGB( 128, 208, 16 ) : color;\n}\n\nvoid SpriteTreeMiddle( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n    \n    idx = y == 23.0 ? ( x <= 7.0 ? 10240.0 : 0.0 ) : idx;\n    idx = y == 22.0 ? ( x <= 7.0 ? 48770.0 : 2688.0 ) : idx;\n    idx = y == 21.0 ? ( x <= 7.0 ? 10283.0 : 12266.0 ) : idx;\n    idx = y == 20.0 ? ( x <= 7.0 ? 32959.0 : 48059.0 ) : idx;\n    idx = y == 19.0 ? ( x <= 7.0 ? 58080.0 : 44782.0 ) : idx;\n    idx = y == 18.0 ? ( x <= 7.0 ? 35470.0 : 12012.0 ) : idx;\n    idx = y == 17.0 ? ( x <= 7.0 ? 8763.0 : 2248.0 ) : idx;\n    idx = y == 16.0 ? ( x <= 7.0 ? 35723.0 : 32898.0 ) : idx;\n    idx = y == 15.0 ? ( x <= 7.0 ? 11835.0 : 57866.0 ) : idx;\n    idx = y == 14.0 ? ( x <= 7.0 ? 15155.0 : 57896.0 ) : idx;\n    idx = y == 13.0 ? ( x <= 7.0 ? 60450.0 : 45240.0 ) : idx;\n    idx = y == 12.0 ? ( x <= 7.0 ? 60480.0 : 8930.0 ) : idx;\n    idx = y == 11.0 ? ( x <= 7.0 ? 60481.0 : 930.0 ) : idx;\n    idx = y == 10.0 ? ( x <= 7.0 ? 51280.0 : 4738.0 ) : idx;\n    idx = y == 9.0 ? ( x <= 7.0 ? 49234.0 : 4226.0 ) : idx;\n    idx = y == 8.0 ? ( x <= 7.0 ? 32848.0 : 4096.0 ) : idx;\n    idx = y == 7.0 ? ( x <= 7.0 ? 32852.0 : 16416.0 ) : idx;\n    idx = y == 6.0 ? ( x <= 7.0 ? 23.0 : 18528.0 ) : idx;\n    idx = y == 5.0 ? ( x <= 7.0 ? 30.0 : 18536.0 ) : idx;\n    idx = y == 4.0 ? ( x <= 7.0 ? 17464.0 : 18536.0 ) : idx;\n    idx = y == 3.0 ? ( x <= 7.0 ? 1064.0 : 18504.0 ) : idx;\n    idx = y == 2.0 ? ( x <= 7.0 ? 1312.0 : 16448.0 ) : idx;\n    idx = y == 1.0 ? ( x <= 7.0 ? 17668.0 : 18496.0 ) : idx;\n    idx = y == 0.0 ? ( x <= 7.0 ? 16660.0 : 16448.0 ) : idx;\n    \n    idx = SPRITE_DEC_4( x, idx );\n    idx = x >= 0.0 && x < 16.0 ? idx : 0.0;\n\n    color = x >= 0.0 && x < 16.0 && y >= 0.0 && y < 24.0 ? RGB( 0, 0, 0 ) : color;\n    color = idx == 1.0 ? RGB( 64, 44, 0 ) : color;\n    color = idx == 2.0 ? RGB( 0, 148, 0 ) : color;    \n    color = idx == 3.0 ? RGB( 128, 208, 16 ) : color;\n}\n\nvoid SpriteTreeEnd( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n    \n\tidx = y == 17.0 ? 960.0 : idx;\n\tidx = y == 16.0 ? 2744.0 : idx;\n\tidx = y == 15.0 ? 8227.0 : idx;\n\tidx = y == 14.0 ? 3022.0 : idx;\n\tidx = y == 13.0 ? 48674.0 : idx;\n\tidx = y == 12.0 ? 41136.0 : idx;\n\tidx = y == 11.0 ? 52192.0 : idx;\n\tidx = y == 10.0 ? 36516.0 : idx;\n\tidx = y == 9.0 ? 15140.0 : idx;\n\tidx = y == 8.0 ? 15108.0 : idx;\n\tidx = y == 7.0 ? 12292.0 : idx;\n\tidx = y == 6.0 ? 8452.0 : idx;\n\tidx = y == 5.0 ? 68.0 : idx;\n\tidx = y == 4.0 ? 68.0 : idx;\n\tidx = y == 3.0 ? 68.0 : idx;\n\tidx = y == 2.0 ? 20.0 : idx;\n\tidx = y == 1.0 ? 20.0 : idx;\n\tidx = y == 0.0 ? 20.0 : idx;\n    \n    idx = SPRITE_DEC_4( x, idx );\n    idx = x >= 0.0 && x < 8.0 ? idx : 0.0;\n\n    color = x >= 0.0 && x < 8.0 && y >= 0.0 && y < 24.0 ? RGB( 0, 0, 0 ) : color;\n    color = idx == 1.0 ? RGB( 64, 44, 0 ) : color;\n    color = idx == 2.0 ? RGB( 0, 148, 0 ) : color;    \n    color = idx == 3.0 ? RGB( 128, 208, 16 ) : color;\n}\n\nvoid SpriteBridge( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n    \n\tidx = y == 26.0 ? ( x <= 10.0 ? 349509.0 : ( x <= 21.0 ? 1381717.0 : 349269.0 ) ) : idx;\n\tidx = y == 25.0 ? ( x <= 10.0 ? 349573.0 : ( x <= 21.0 ? 1447254.0 : 350293.0 ) ) : idx;\n\tidx = y == 24.0 ? ( x <= 10.0 ? 2184545.0 : ( x <= 21.0 ? 1410389.0 : 349717.0 ) ) : idx;\n\tidx = y == 23.0 ? ( x <= 10.0 ? 2184545.0 : ( x <= 21.0 ? 1410389.0 : 349717.0 ) ) : idx;\n\tidx = y == 22.0 ? ( x <= 10.0 ? 1594712.0 : ( x <= 21.0 ? 1401173.0 : 349573.0 ) ) : idx;\n\tidx = y == 21.0 ? ( x <= 10.0 ? 1594712.0 : ( x <= 21.0 ? 1401173.0 : 349573.0 ) ) : idx;\n\tidx = y == 20.0 ? ( x <= 10.0 ? 2730665.0 : ( x <= 21.0 ? 2795178.0 : 699034.0 ) ) : idx;\n\tidx = y == 19.0 ? ( x <= 10.0 ? 1594712.0 : ( x <= 21.0 ? 1398101.0 : 349573.0 ) ) : idx;\n\tidx = y == 18.0 ? ( x <= 10.0 ? 546136.0 : ( x <= 21.0 ? 0.0 : 349576.0 ) ) : idx;\n\tidx = y == 17.0 ? ( x <= 10.0 ? 524288.0 : ( x <= 21.0 ? 0.0 : 8.0 ) ) : idx;\n\tidx = y == 16.0 ? ( x <= 10.0 ? 567976.0 : ( x <= 21.0 ? 0.0 : 699016.0 ) ) : idx;\n\tidx = y == 15.0 ? ( x <= 10.0 ? 2643288.0 : ( x <= 21.0 ? 2796202.0 : 349578.0 ) ) : idx;\n\tidx = y == 14.0 ? ( x <= 10.0 ? 1594712.0 : ( x <= 21.0 ? 1398101.0 : 349573.0 ) ) : idx;\n\tidx = y == 11.0 ? ( x <= 10.0 ? 26729.0 : ( x <= 21.0 ? 2204672.0 : 6.0 ) ) : idx;\n\tidx = y == 10.0 ? ( x <= 10.0 ? 5140.0 : ( x <= 21.0 ? 1069056.0 : 1.0 ) ) : idx;\n\tidx = y == 9.0 ? ( x <= 10.0 ? 1397865.0 : ( x <= 21.0 ? 1156437.0 : 349525.0 ) ) : idx;\n\tidx = y == 8.0 ? ( x <= 10.0 ? 2791700.0 : ( x <= 21.0 ? 2380458.0 : 699049.0 ) ) : idx;\n\tidx = y == 7.0 ? ( x <= 10.0 ? 1393769.0 : ( x <= 21.0 ? 1156437.0 : 349524.0 ) ) : idx;\n\tidx = y == 6.0 ? ( x <= 10.0 ? 20.0 : ( x <= 21.0 ? 20480.0 : 0.0 ) ) : idx;\n\tidx = y == 5.0 ? ( x <= 10.0 ? 105.0 : ( x <= 21.0 ? 107520.0 : 0.0 ) ) : idx;\n\tidx = y == 4.0 ? ( x <= 10.0 ? 20.0 : ( x <= 21.0 ? 20480.0 : 0.0 ) ) : idx;\n\tidx = y == 3.0 ? ( x <= 10.0 ? 1398149.0 : ( x <= 21.0 ? 1447253.0 : 349525.0 ) ) : idx;\n\tidx = y == 2.0 ? ( x <= 10.0 ? 2796193.0 : ( x <= 21.0 ? 2786986.0 : 699050.0 ) ) : idx;\n\tidx = y == 1.0 ? ( x <= 10.0 ? 1398113.0 : ( x <= 21.0 ? 1410389.0 : 349525.0 ) ) : idx;\n\tidx = y == 0.0 ? ( x <= 10.0 ? 1398085.0 : ( x <= 21.0 ? 1381717.0 : 349525.0 ) ) : idx;  \n\n    idx = SPRITE_DEC_3( x, idx );\n    idx = x >= 0.0 && x < 32.0 ? idx : 0.0;\n    \n    color = x >= 0.0 && x < 32.0 && y >= 0.0 && y < 13.0 ? RGB( 0, 0, 0 ) : color;\n    \n    float blink = abs( sin( iTime * 3.0 ) ) + 0.5;\n    color = x >= 12.0 && x < 24.0 && y >= 17.0 && y < 19.0 ? blink * RGB( 228, 68, 52 ) : color;\n    color = idx == 1.0 ? RGB( 179, 179, 179 ) : color;\n    color = idx == 2.0 ? RGB( 255, 255, 255 ) : color;    \n}\n\nvoid SpriteGrass( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n    \n    idx = y == 15.0 ? ( x <= 10.0 ? 1398096.0 : ( x <= 21.0 ? 1398101.0 : 87381.0 ) ) : idx;\n    idx = y == 14.0 ? ( x <= 10.0 ? 1398101.0 : ( x <= 21.0 ? 1398101.0 : 349525.0 ) ) : idx;\n    idx = y == 13.0 ? ( x <= 10.0 ? 1398101.0 : ( x <= 21.0 ? 1398101.0 : 349525.0 ) ) : idx;\n    idx = y == 12.0 ? ( x <= 10.0 ? 1398101.0 : ( x <= 21.0 ? 1398101.0 : 349525.0 ) ) : idx;\n    idx = y == 11.0 ? ( x <= 10.0 ? 1398102.0 : ( x <= 21.0 ? 1398101.0 : 349525.0 ) ) : idx;\n    idx = y == 10.0 ? ( x <= 10.0 ? 1418921.0 : ( x <= 21.0 ? 1398102.0 : 419158.0 ) ) : idx;\n    idx = y == 9.0 ? ( x <= 10.0 ? 2779749.0 : ( x <= 21.0 ? 2796202.0 : 285353.0 ) ) : idx;\n    idx = y == 8.0 ? ( x <= 10.0 ? 2796197.0 : ( x <= 21.0 ? 2791078.0 : 345494.0 ) ) : idx;\n    idx = y == 7.0 ? ( x <= 10.0 ? 1681049.0 : ( x <= 21.0 ? 1468826.0 : 70997.0 ) ) : idx;\n    idx = y == 6.0 ? ( x <= 10.0 ? 2517412.0 : ( x <= 21.0 ? 2463126.0 : 280153.0 ) ) : idx;\n    idx = y == 5.0 ? ( x <= 10.0 ? 1681057.0 : ( x <= 21.0 ? 2459241.0 : 71013.0 ) ) : idx;\n    idx = y == 4.0 ? ( x <= 10.0 ? 2468240.0 : ( x <= 21.0 ? 1448218.0 : 267413.0 ) ) : idx;\n    idx = y == 3.0 ? ( x <= 10.0 ? 1137172.0 : ( x <= 21.0 ? 332905.0 : 20818.0 ) ) : idx;\n    idx = y == 2.0 ? ( x <= 10.0 ? 1148161.0 : ( x <= 21.0 ? 332900.0 : 325.0 ) ) : idx;\n    idx = y == 1.0 ? ( x <= 10.0 ? 16640.0 : ( x <= 21.0 ? 69648.0 : 68.0 ) ) : idx;\n    \n    idx = SPRITE_DEC_3( x, idx );\n    idx = x >= 0.0 && x < 32.0 ? idx : 0.0;\n\n    color = x >= 0.0 && x < 32.0 && y >= 0.0 && y < 16.0 ? RGB( 0, 0, 0 ) : color;\n    color = idx == 1.0 ? RGB( 0,   144, 0 ) : color;\n    color = idx == 2.0 ? RGB( 144, 213, 0 ) : color;\n}\n\nvoid SpriteLeaves( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n    \n    idx = y == 29.0 ? ( x <= 7.0 ? 8224.0 : ( x <= 15.0 ? 514.0 : ( x <= 23.0 ? 10400.0 : 41122.0 ) ) ) : idx;\n    idx = y == 28.0 ? ( x <= 7.0 ? 35330.0 : ( x <= 15.0 ? 2110.0 : ( x <= 23.0 ? 14496.0 : 35723.0 ) ) ) : idx;\n    idx = y == 27.0 ? ( x <= 7.0 ? 41090.0 : ( x <= 15.0 ? 995.0 : ( x <= 23.0 ? 12996.0 : 11788.0 ) ) ) : idx;\n    idx = y == 26.0 ? ( x <= 7.0 ? 14466.0 : ( x <= 15.0 ? 3595.0 : ( x <= 23.0 ? 58256.0 : 14380.0 ) ) ) : idx;\n    idx = y == 25.0 ? ( x <= 7.0 ? 36352.0 : ( x <= 15.0 ? 2223.0 : ( x <= 23.0 ? 57860.0 : 47928.0 ) ) ) : idx;\n    idx = y == 24.0 ? ( x <= 7.0 ? 58240.0 : ( x <= 15.0 ? 8958.0 : ( x <= 23.0 ? 57424.0 : 64312.0 ) ) ) : idx;\n    idx = y == 23.0 ? ( x <= 7.0 ? 47810.0 : ( x <= 15.0 ? 2956.0 : ( x <= 23.0 ? 12288.0 : 51772.0 ) ) ) : idx;\n    idx = y == 22.0 ? ( x <= 7.0 ? 14338.0 : ( x <= 15.0 ? 3631.0 : ( x <= 23.0 ? 0.0 : 52012.0 ) ) ) : idx;\n    idx = y == 21.0 ? ( x <= 7.0 ? 35842.0 : ( x <= 15.0 ? 2091.0 : ( x <= 23.0 ? 10250.0 : 776.0 ) ) ) : idx;\n    idx = y == 20.0 ? ( x <= 7.0 ? 51200.0 : ( x <= 15.0 ? 50.0 : ( x <= 23.0 ? 8352.0 : 712.0 ) ) ) : idx;\n    idx = y == 19.0 ? ( x <= 7.0 ? 34818.0 : ( x <= 15.0 ? 40992.0 : ( x <= 23.0 ? 43650.0 : 32896.0 ) ) ) : idx;\n    idx = y == 18.0 ? ( x <= 7.0 ? 40.0 : ( x <= 15.0 ? 2048.0 : ( x <= 23.0 ? 552.0 : 2570.0 ) ) ) : idx;\n    idx = y == 17.0 ? ( x <= 7.0 ? 128.0 : ( x <= 15.0 ? 11256.0 : ( x <= 23.0 ? 8367.0 : 8232.0 ) ) ) : idx;\n    idx = y == 16.0 ? ( x <= 7.0 ? 42.0 : ( x <= 15.0 ? 64010.0 : ( x <= 23.0 ? 35458.0 : 35328.0 ) ) ) : idx;\n    idx = y == 15.0 ? ( x <= 7.0 ? 128.0 : ( x <= 15.0 ? 44960.0 : ( x <= 23.0 ? 34863.0 : 49282.0 ) ) ) : idx;\n    idx = y == 14.0 ? ( x <= 7.0 ? 32783.0 : ( x <= 15.0 ? 3055.0 : ( x <= 23.0 ? 12472.0 : 63522.0 ) ) ) : idx;\n    idx = y == 13.0 ? ( x <= 7.0 ? 63544.0 : ( x <= 15.0 ? 63738.0 : ( x <= 23.0 ? 58080.0 : 52736.0 ) ) ) : idx;\n    idx = y == 12.0 ? ( x <= 7.0 ? 11778.0 : ( x <= 15.0 ? 33772.0 : ( x <= 23.0 ? 52111.0 : 50050.0 ) ) ) : idx;\n    idx = y == 11.0 ? ( x <= 7.0 ? 49195.0 : ( x <= 15.0 ? 16014.0 : ( x <= 23.0 ? 2606.0 : 45187.0 ) ) ) : idx;\n    idx = y == 10.0 ? ( x <= 7.0 ? 64686.0 : ( x <= 15.0 ? 14383.0 : ( x <= 23.0 ? 3128.0 : 60419.0 ) ) ) : idx;\n    idx = y == 9.0 ? ( x <= 7.0 ? 11020.0 : ( x <= 15.0 ? 57599.0 : ( x <= 23.0 ? 3248.0 : 58114.0 ) ) ) : idx;\n    idx = y == 8.0 ? ( x <= 7.0 ? 35532.0 : ( x <= 15.0 ? 50419.0 : ( x <= 23.0 ? 35040.0 : 12800.0 ) ) ) : idx;\n    idx = y == 7.0 ? ( x <= 7.0 ? 57480.0 : ( x <= 15.0 ? 50050.0 : ( x <= 23.0 ? 227.0 : 12304.0 ) ) ) : idx;\n    idx = y == 6.0 ? ( x <= 7.0 ? 45232.0 : ( x <= 15.0 ? 35595.0 : ( x <= 23.0 ? 131.0 : 8257.0 ) ) ) : idx;\n    idx = y == 5.0 ? ( x <= 7.0 ? 59428.0 : ( x <= 15.0 ? 3640.0 : ( x <= 23.0 ? 258.0 : 20.0 ) ) ) : idx;\n    idx = y == 4.0 ? ( x <= 7.0 ? 35361.0 : ( x <= 15.0 ? 10272.0 : ( x <= 23.0 ? 1104.0 : 32833.0 ) ) ) : idx;\n    idx = y == 3.0 ? ( x <= 7.0 ? 33284.0 : ( x <= 15.0 ? 8354.0 : ( x <= 23.0 ? 261.0 : 8212.0 ) ) ) : idx;\n    idx = y == 2.0 ? ( x <= 7.0 ? 1105.0 : ( x <= 15.0 ? 8706.0 : ( x <= 23.0 ? 1104.0 : 10305.0 ) ) ) : idx;\n    idx = y == 1.0 ? ( x <= 7.0 ? 260.0 : ( x <= 15.0 ? 532.0 : ( x <= 23.0 ? 261.0 : 8212.0 ) ) ) : idx;\n    idx = y == 0.0 ? ( x <= 7.0 ? 1105.0 : ( x <= 15.0 ? 16449.0 : ( x <= 23.0 ? 1104.0 : 2113.0 ) ) ) : idx;\n    \n    idx = SPRITE_DEC_4( x, idx );\n\n    color = RGB( 0, 0, 0 );\n    color = idx == 1.0 ? RGB( 64,  44,  0  ) : color;\n    color = idx == 2.0 ? RGB( 0,   148, 0  ) : color;    \n    color = idx == 3.0 ? RGB( 128, 208, 16 ) : color;\n}\n\nvoid SpriteShoreSide( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;    \n    \n\tidx = y == 19.0 ? 43.0 : idx;\n\tidx = y == 18.0 ? 190.0 : idx;\n\tidx = y == 17.0 ? 2025.0 : idx;\n\tidx = y == 16.0 ? 3773.0 : idx;\n\tidx = y == 15.0 ? 3050.0 : idx;\n\tidx = y == 14.0 ? 445.0 : idx;\n\tidx = y == 13.0 ? 2981.0 : idx;\n\tidx = y == 12.0 ? 765.0 : idx;\n\tidx = y == 11.0 ? 4005.0 : idx;\n\tidx = y == 10.0 ? 6869.0 : idx;\n\tidx = y == 9.0 ? 3669.0 : idx;\n\tidx = y == 8.0 ? 15189.0 : idx;\n\tidx = y == 7.0 ? 3029.0 : idx;\n\tidx = y == 6.0 ? 16037.0 : idx;\n\tidx = y == 5.0 ? 11221.0 : idx;\n\tidx = y == 4.0 ? 32341.0 : idx;\n\tidx = y == 3.0 ? 43989.0 : idx;\n\tidx = y == 2.0 ? 64853.0 : idx;\n\tidx = y == 1.0 ? 22869.0 : idx;\n\tidx = y == 0.0 ? 21850.0 : idx;\n    \n    idx = SPRITE_DEC_4( x, idx );\n    \n    float blink = fract( iTime * 3.0 );\n    idx = blink > 0.5 && ( idx == 2.0 || idx == 3.0 ) ? 5.0 - idx : idx;\n    \n    color = y >= 0.0 && y < 20.0 ? RGB( 0, 0, 0 ) : color;\n    color = idx == 1.0 ? RGB( 0,   112, 236 ) : color;\n    color = idx == 2.0 ? RGB( 60,  188, 252 ) : color;\n    color = idx == 3.0 ? RGB( 255, 255, 255 ) : color;\n}\n\nvoid SpriteShore( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;    \n    \n    idx = y == 6.0 ? 0.0 : idx;\n    idx = y == 5.0 ? ( x <= 7.0 ? 65024.0 : ( x <= 15.0 ? 2.0 : ( x <= 23.0 ? 760.0 : 188.0 ) ) ) : idx;\n    idx = y == 4.0 ? ( x <= 7.0 ? 43904.0 : ( x <= 15.0 ? 60143.0 : ( x <= 23.0 ? 2990.0 : 3051.0 ) ) ) : idx;\n    idx = y == 3.0 ? ( x <= 7.0 ? 24303.0 : ( x <= 15.0 ? 49061.0 : ( x <= 23.0 ? 48789.0 : 61095.0 ) ) ) : idx;\n    idx = y == 2.0 ? ( x <= 7.0 ? 21926.0 : ( x <= 15.0 ? 21909.0 : ( x <= 23.0 ? 58709.0 : 42902.0 ) ) ) : idx;\n    idx = y == 1.0 ? ( x <= 7.0 ? 38229.0 : ( x <= 15.0 ? 22869.0 : ( x <= 23.0 ? 21845.0 : 21925.0 ) ) ) : idx;\n    idx = y == 0.0 ? ( x <= 7.0 ? 21865.0 : ( x <= 15.0 ? 22137.0 : 21845.0 ) ) : idx;\n    \n    idx = SPRITE_DEC_4( x, idx );\n    \n    float blink = fract( iTime * 3.0 );\n    idx = blink > 0.5 && ( idx == 2.0 || idx == 3.0 ) ? 5.0 - idx : idx;\n    \n    color = RGB( 0, 0, 0 );\n    color = idx == 1.0 ? RGB( 0,   112, 236 ) : color;\n    color = idx == 2.0 ? RGB( 60,  188, 252 ) : color;\n    color = idx == 3.0 ? RGB( 255, 255, 255 ) : color;\n}\n\nvoid SpriteBossCore( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n    \n    idx = y == 30.0 ? ( x <= 7.0 ? 21844.0 : ( x <= 15.0 ? 85.0 : 0.0 ) ) : idx;\n    idx = y == 29.0 ? ( x <= 7.0 ? 65533.0 : ( x <= 15.0 ? 21845.0 : 5461.0 ) ) : idx;\n    idx = y == 28.0 ? ( x <= 7.0 ? 43689.0 : ( x <= 15.0 ? 65345.0 : 28671.0 ) ) : idx;\n    idx = y == 27.0 ? ( x <= 7.0 ? 43689.0 : ( x <= 15.0 ? 43861.0 : 21930.0 ) ) : idx;\n    idx = y == 26.0 ? ( x <= 7.0 ? 43685.0 : ( x <= 15.0 ? 43841.0 : 21610.0 ) ) : idx;\n    idx = y == 25.0 ? ( x <= 7.0 ? 43665.0 : ( x <= 15.0 ? 43861.0 : 21850.0 ) ) : idx;\n    idx = y == 24.0 ? ( x <= 7.0 ? 43605.0 : ( x <= 15.0 ? 43841.0 : 27462.0 ) ) : idx;\n    idx = y == 23.0 ? ( x <= 7.0 ? 43293.0 : ( x <= 15.0 ? 43861.0 : 27605.0 ) ) : idx;\n    idx = y == 22.0 ? ( x <= 7.0 ? 42361.0 : ( x <= 15.0 ? 27457.0 : 23476.0 ) ) : idx;\n    idx = y == 21.0 ? ( x <= 7.0 ? 20969.0 : ( x <= 15.0 ? 23381.0 : 27565.0 ) ) : idx;\n    idx = y == 20.0 ? ( x <= 7.0 ? 38825.0 : ( x <= 15.0 ? 17855.0 : 23467.0 ) ) : idx;\n    idx = y == 19.0 ? ( x <= 7.0 ? 26281.0 : ( x <= 15.0 ? 55009.0 : 27562.0 ) ) : idx;\n    idx = y == 18.0 ? ( x <= 7.0 ? 26276.0 : ( x <= 15.0 ? 38592.0 : 32746.0 ) ) : idx;\n    idx = y == 17.0 ? ( x <= 7.0 ? 22928.0 : ( x <= 15.0 ? 39808.0 : 23162.0 ) ) : idx;\n    idx = y == 16.0 ? ( x <= 7.0 ? 6544.0 : ( x <= 15.0 ? 39808.0 : 23390.0 ) ) : idx;\n    idx = y == 15.0 ? ( x <= 7.0 ? 6544.0 : ( x <= 15.0 ? 39808.0 : 23390.0 ) ) : idx;\n    idx = y == 14.0 ? ( x <= 7.0 ? 6544.0 : ( x <= 15.0 ? 39808.0 : 23390.0 ) ) : idx;\n    idx = y == 13.0 ? ( x <= 7.0 ? 6564.0 : ( x <= 15.0 ? 39808.0 : 23390.0 ) ) : idx;\n    idx = y == 12.0 ? ( x <= 7.0 ? 22953.0 : ( x <= 15.0 ? 39808.0 : 23162.0 ) ) : idx;\n    idx = y == 11.0 ? ( x <= 7.0 ? 26281.0 : ( x <= 15.0 ? 38592.0 : 32746.0 ) ) : idx;\n    idx = y == 10.0 ? ( x <= 7.0 ? 26281.0 : ( x <= 15.0 ? 38625.0 : 27562.0 ) ) : idx;\n    idx = y == 9.0 ? ( x <= 7.0 ? 38569.0 : ( x <= 15.0 ? 17850.0 : 23466.0 ) ) : idx;\n    idx = y == 8.0 ? ( x <= 7.0 ? 20905.0 : ( x <= 15.0 ? 24405.0 : 27561.0 ) ) : idx;\n    idx = y == 7.0 ? ( x <= 7.0 ? 46441.0 : ( x <= 15.0 ? 27457.0 : 23460.0 ) ) : idx;\n    idx = y == 6.0 ? ( x <= 7.0 ? 44313.0 : ( x <= 15.0 ? 43861.0 : 27541.0 ) ) : idx;\n    idx = y == 5.0 ? ( x <= 7.0 ? 43861.0 : ( x <= 15.0 ? 43841.0 : 27462.0 ) ) : idx;\n    idx = y == 4.0 ? ( x <= 7.0 ? 43729.0 : ( x <= 15.0 ? 43861.0 : 21850.0 ) ) : idx;\n    idx = y == 3.0 ? ( x <= 7.0 ? 45045.0 : ( x <= 15.0 ? 43841.0 : 21610.0 ) ) : idx;\n    idx = y == 2.0 ? ( x <= 7.0 ? 62804.0 : ( x <= 15.0 ? 65365.0 : 21930.0 ) ) : idx;\n    idx = y == 1.0 ? ( x <= 7.0 ? 21504.0 : ( x <= 15.0 ? 21845.0 : 27391.0 ) ) : idx;\n    idx = y == 0.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 20480.0 : 5461.0 ) ) : idx;\n    \n    idx = SPRITE_DEC_4( x, idx );\n    idx = x >= 0.0 && x < 24.0 ? idx : 0.0;\n\n    float blink = abs( sin( iTime * 3.0 ) ) + 0.5;\n    color = idx == 1.0 ? RGB( 0,   0,   0   ) : color;\n    color = idx == 2.0 ? RGB( 192, 192, 192 ) : color;\n    color = idx == 3.0 ? RGB( 255, 255, 255 ) : color;\n    color = idx == 0.0 && x >= 1.0 && x < 21.0 && y >= 3.0 && y < 30.0 ? blink * RGB( 228, 68, 52 ) : color;\n}\n\nvoid SpriteBossCannonBase( inout vec3 color, float x, float y )\n{\n\tfloat idx = 0.0;\n    \n\tidx = y == 41.0 ? ( x <= 7.0 ? 11606.0 : ( x <= 15.0 ? 395.0 : ( x <= 23.0 ? 43584.0 : 21946.0 ) ) ) : idx;\n\tidx = y == 40.0 ? ( x <= 7.0 ? 11611.0 : ( x <= 15.0 ? 32774.0 : ( x <= 23.0 ? 43595.0 : 22250.0 ) ) ) : idx;\n\tidx = y == 39.0 ? ( x <= 7.0 ? 6491.0 : ( x <= 15.0 ? 11520.0 : ( x <= 23.0 ? 43298.0 : 22250.0 ) ) ) : idx;\n\tidx = y == 38.0 ? ( x <= 7.0 ? 366.0 : ( x <= 15.0 ? 35042.0 : ( x <= 23.0 ? 43275.0 : 23466.0 ) ) ) : idx;\n\tidx = y == 37.0 ? ( x <= 7.0 ? 5486.0 : ( x <= 15.0 ? 11532.0 : ( x <= 23.0 ? 42082.0 : 43946.0 ) ) ) : idx;\n\tidx = y == 36.0 ? ( x <= 7.0 ? 5562.0 : ( x <= 15.0 ? 35042.0 : ( x <= 23.0 ? 41995.0 : 21850.0 ) ) ) : idx;\n\tidx = y == 35.0 ? ( x <= 7.0 ? 5866.0 : ( x <= 15.0 ? 11532.0 : ( x <= 23.0 ? 20578.0 : 5.0 ) ) ) : idx;\n\tidx = y == 34.0 ? ( x <= 7.0 ? 5866.0 : ( x <= 15.0 ? 35042.0 : ( x <= 23.0 ? 11.0 : 27744.0 ) ) ) : idx;\n\tidx = y == 33.0 ? ( x <= 7.0 ? 11178.0 : ( x <= 15.0 ? 11532.0 : ( x <= 23.0 ? 24674.0 : 27756.0 ) ) ) : idx;\n\tidx = y == 32.0 ? ( x <= 7.0 ? 5466.0 : ( x <= 15.0 ? 35042.0 : ( x <= 23.0 ? 24587.0 : 27756.0 ) ) ) : idx;\n\tidx = y == 31.0 ? ( x <= 7.0 ? 21.0 : ( x <= 15.0 ? 11532.0 : ( x <= 23.0 ? 24674.0 : 27756.0 ) ) ) : idx;\n\tidx = y == 30.0 ? ( x <= 7.0 ? 11264.0 : ( x <= 15.0 ? 35042.0 : ( x <= 23.0 ? 24587.0 : 27756.0 ) ) ) : idx;\n\tidx = y == 29.0 ? ( x <= 7.0 ? 11372.0 : ( x <= 15.0 ? 11532.0 : ( x <= 23.0 ? 24674.0 : 27756.0 ) ) ) : idx;\n\tidx = y == 28.0 ? ( x <= 7.0 ? 11372.0 : ( x <= 15.0 ? 35042.0 : ( x <= 23.0 ? 24587.0 : 27756.0 ) ) ) : idx;\n\tidx = y == 27.0 ? ( x <= 7.0 ? 11372.0 : ( x <= 15.0 ? 11532.0 : ( x <= 23.0 ? 24674.0 : 21612.0 ) ) ) : idx;\n\tidx = y == 26.0 ? ( x <= 7.0 ? 11372.0 : ( x <= 15.0 ? 35042.0 : ( x <= 23.0 ? 20491.0 : 84.0 ) ) ) : idx;\n\tidx = y == 25.0 ? ( x <= 7.0 ? 11372.0 : ( x <= 15.0 ? 11532.0 : ( x <= 23.0 ? 98.0 : 27648.0 ) ) ) : idx;\n\tidx = y == 24.0 ? ( x <= 7.0 ? 5228.0 : ( x <= 15.0 ? 35042.0 : ( x <= 23.0 ? 24587.0 : 27756.0 ) ) ) : idx;\n\tidx = y == 23.0 ? ( x <= 7.0 ? 84.0 : ( x <= 15.0 ? 11532.0 : ( x <= 23.0 ? 24674.0 : 27756.0 ) ) ) : idx;\n\tidx = y == 22.0 ? ( x <= 7.0 ? 11264.0 : ( x <= 15.0 ? 35042.0 : ( x <= 23.0 ? 24587.0 : 27756.0 ) ) ) : idx;\n\tidx = y == 21.0 ? ( x <= 7.0 ? 11372.0 : ( x <= 15.0 ? 11532.0 : ( x <= 23.0 ? 24674.0 : 27756.0 ) ) ) : idx;\n\tidx = y == 20.0 ? ( x <= 7.0 ? 11372.0 : ( x <= 15.0 ? 35042.0 : ( x <= 23.0 ? 24587.0 : 27756.0 ) ) ) : idx;\n\tidx = y == 19.0 ? ( x <= 7.0 ? 11372.0 : ( x <= 15.0 ? 11532.0 : ( x <= 23.0 ? 24674.0 : 21612.0 ) ) ) : idx;\n\tidx = y == 18.0 ? ( x <= 7.0 ? 11372.0 : ( x <= 15.0 ? 35042.0 : ( x <= 23.0 ? 20491.0 : 84.0 ) ) ) : idx;\n\tidx = y == 17.0 ? ( x <= 7.0 ? 11372.0 : ( x <= 15.0 ? 11532.0 : ( x <= 23.0 ? 98.0 : 27648.0 ) ) ) : idx;\n\tidx = y == 16.0 ? ( x <= 7.0 ? 5228.0 : ( x <= 15.0 ? 35042.0 : ( x <= 23.0 ? 24587.0 : 27756.0 ) ) ) : idx;\n\tidx = y == 15.0 ? ( x <= 7.0 ? 11348.0 : ( x <= 15.0 ? 11532.0 : ( x <= 23.0 ? 24674.0 : 27756.0 ) ) ) : idx;\n\tidx = y == 14.0 ? ( x <= 7.0 ? 11264.0 : ( x <= 15.0 ? 35042.0 : ( x <= 23.0 ? 24587.0 : 11372.0 ) ) ) : idx;\n\tidx = y == 13.0 ? ( x <= 7.0 ? 11372.0 : ( x <= 15.0 ? 11532.0 : ( x <= 23.0 ? 24674.0 : 35948.0 ) ) ) : idx;\n\tidx = y == 12.0 ? ( x <= 7.0 ? 11372.0 : ( x <= 15.0 ? 35042.0 : ( x <= 23.0 ? 24587.0 : 34924.0 ) ) ) : idx;\n\tidx = y == 11.0 ? ( x <= 7.0 ? 11372.0 : ( x <= 15.0 ? 11532.0 : ( x <= 23.0 ? 24674.0 : 57452.0 ) ) ) : idx;\n\tidx = y == 10.0 ? ( x <= 7.0 ? 11372.0 : ( x <= 15.0 ? 35042.0 : ( x <= 23.0 ? 20491.0 : 57428.0 ) ) ) : idx;\n\tidx = y == 9.0 ? ( x <= 7.0 ? 5228.0 : ( x <= 15.0 ? 11532.0 : ( x <= 23.0 ? 98.0 : 47104.0 ) ) ) : idx;\n\tidx = y == 8.0 ? ( x <= 7.0 ? 108.0 : ( x <= 15.0 ? 35042.0 : ( x <= 23.0 ? 4107.0 : 47125.0 ) ) ) : idx;\n\tidx = y == 7.0 ? ( x <= 7.0 ? 84.0 : ( x <= 15.0 ? 11532.0 : ( x <= 23.0 ? 98.0 : 44544.0 ) ) ) : idx;\n\tidx = y == 6.0 ? ( x <= 7.0 ? 16128.0 : ( x <= 15.0 ? 0.0 : ( x <= 23.0 ? 0.0 : 45044.0 ) ) ) : idx;\n\tidx = y == 5.0 ? ( x <= 7.0 ? 10752.0 : ( x <= 15.0 ? 43689.0 : ( x <= 23.0 ? 5467.0 : 47780.0 ) ) ) : idx;\n\tidx = y == 4.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 43689.0 : ( x <= 23.0 ? 5467.0 : 0.0 ) ) ) : idx;\n\tidx = y == 3.0 ? ( x <= 7.0 ? 10896.0 : ( x <= 15.0 ? 43689.0 : ( x <= 23.0 ? 5467.0 : 64169.0 ) ) ) : idx;\n\tidx = y == 2.0 ? ( x <= 7.0 ? 10916.0 : ( x <= 15.0 ? 43689.0 : ( x <= 23.0 ? 17755.0 : 44714.0 ) ) ) : idx;\n\tidx = y == 1.0 ? ( x <= 7.0 ? 15017.0 : ( x <= 15.0 ? 43689.0 : ( x <= 23.0 ? 37211.0 : 43946.0 ) ) ) : idx;\n\tidx = y == 0.0 ? ( x <= 7.0 ? 15017.0 : ( x <= 15.0 ? 43689.0 : ( x <= 23.0 ? 37211.0 : 43946.0 ) ) ) : idx;\n\n    idx = SPRITE_DEC_4( x, idx );\n    idx = x >= 0.0 && x < 32.0 ? idx : 0.0;    \n    \n    color = idx == 0.0 && x >= 0.0 && x < 32.0 && y >= 0.0 && y < 42.0 ? RGB( 0, 0, 0 ) : color;\n    color = idx == 1.0 ? RGB( 4,   88,  180 ) : color;\n    color = idx == 2.0 ? RGB( 192, 192, 192 ) : color;\n    color = idx == 3.0 ? RGB( 255, 255, 255 ) : color;    \n}\n\nvoid SpriteBossTopPanel( inout vec3 color, float x, float y )\n{\n\tfloat idx = 0.0;    \n\n\tidx = y == 51.0 ? ( x <= 7.0 ? 16384.0 : 10922.0 ) : idx;\n\tidx = y == 50.0 ? ( x <= 7.0 ? 62464.0 : 9558.0 ) : idx;\n\tidx = y == 49.0 ? ( x <= 7.0 ? 61248.0 : 9558.0 ) : idx;\n\tidx = y == 48.0 ? ( x <= 7.0 ? 60148.0 : 9558.0 ) : idx;\n\tidx = y == 47.0 ? ( x <= 7.0 ? 60078.0 : 9558.0 ) : idx;\n\tidx = y == 46.0 ? ( x <= 7.0 ? 58793.0 : 9558.0 ) : idx;\n\tidx = y == 45.0 ? ( x <= 7.0 ? 57433.0 : 9558.0 ) : idx;\n\tidx = y == 44.0 ? ( x <= 7.0 ? 57353.0 : 9558.0 ) : idx;\n\tidx = y == 43.0 ? ( x <= 7.0 ? 61193.0 : 9558.0 ) : idx;\n\tidx = y == 42.0 ? ( x <= 7.0 ? 60153.0 : 9558.0 ) : idx;\n\tidx = y == 41.0 ? ( x <= 7.0 ? 58761.0 : 9558.0 ) : idx;\n\tidx = y == 40.0 ? ( x <= 7.0 ? 57609.0 : 9558.0 ) : idx;\n\tidx = y == 39.0 ? ( x <= 7.0 ? 61193.0 : 9558.0 ) : idx;\n\tidx = y == 38.0 ? ( x <= 7.0 ? 60153.0 : 9558.0 ) : idx;\n\tidx = y == 37.0 ? ( x <= 7.0 ? 58761.0 : 9558.0 ) : idx;\n\tidx = y == 36.0 ? ( x <= 7.0 ? 57609.0 : 9558.0 ) : idx;\n\tidx = y == 35.0 ? ( x <= 7.0 ? 61193.0 : 9558.0 ) : idx;\n\tidx = y == 34.0 ? ( x <= 7.0 ? 60153.0 : 9558.0 ) : idx;\n\tidx = y == 33.0 ? ( x <= 7.0 ? 58761.0 : 9558.0 ) : idx;\n\tidx = y == 32.0 ? ( x <= 7.0 ? 57609.0 : 9558.0 ) : idx;\n\tidx = y == 31.0 ? ( x <= 7.0 ? 61193.0 : 9558.0 ) : idx;\n\tidx = y == 30.0 ? ( x <= 7.0 ? 60153.0 : 9558.0 ) : idx;\n\tidx = y == 29.0 ? ( x <= 7.0 ? 58761.0 : 9558.0 ) : idx;\n\tidx = y == 28.0 ? ( x <= 7.0 ? 57609.0 : 9558.0 ) : idx;\n\tidx = y == 27.0 ? ( x <= 7.0 ? 61193.0 : 9558.0 ) : idx;\n\tidx = y == 26.0 ? ( x <= 7.0 ? 60153.0 : 9558.0 ) : idx;\n\tidx = y == 25.0 ? ( x <= 7.0 ? 58761.0 : 9558.0 ) : idx;\n\tidx = y == 24.0 ? ( x <= 7.0 ? 57609.0 : 9558.0 ) : idx;\n\tidx = y == 23.0 ? ( x <= 7.0 ? 61193.0 : 10582.0 ) : idx;\n\tidx = y == 22.0 ? ( x <= 7.0 ? 60153.0 : 11606.0 ) : idx;\n\tidx = y == 21.0 ? ( x <= 7.0 ? 58761.0 : 11606.0 ) : idx;\n\tidx = y == 20.0 ? ( x <= 7.0 ? 57609.0 : 11606.0 ) : idx;\n\tidx = y == 19.0 ? ( x <= 7.0 ? 61193.0 : 11606.0 ) : idx;\n\tidx = y == 18.0 ? ( x <= 7.0 ? 60153.0 : 11606.0 ) : idx;\n\tidx = y == 17.0 ? ( x <= 7.0 ? 58761.0 : 11606.0 ) : idx;\n\tidx = y == 16.0 ? ( x <= 7.0 ? 57609.0 : 11606.0 ) : idx;\n\tidx = y == 15.0 ? ( x <= 7.0 ? 61193.0 : 11606.0 ) : idx;\n\tidx = y == 14.0 ? ( x <= 7.0 ? 60153.0 : 11606.0 ) : idx;\n\tidx = y == 13.0 ? ( x <= 7.0 ? 58761.0 : 11606.0 ) : idx;\n\tidx = y == 12.0 ? ( x <= 7.0 ? 57609.0 : 11606.0 ) : idx;\n\tidx = y == 11.0 ? ( x <= 7.0 ? 59913.0 : 11606.0 ) : idx;\n\tidx = y == 10.0 ? ( x <= 7.0 ? 60073.0 : 11606.0 ) : idx;\n\tidx = y == 9.0 ? ( x <= 7.0 ? 65449.0 : 11611.0 ) : idx;\n\tidx = y == 8.0 ? ( x <= 7.0 ? 60158.0 : 6491.0 ) : idx;\n\tidx = y == 7.0 ? ( x <= 7.0 ? 43684.0 : 366.0 ) : idx;\n\tidx = y == 6.0 ? ( x <= 7.0 ? 43684.0 : 5486.0 ) : idx;\n\tidx = y == 5.0 ? ( x <= 7.0 ? 43664.0 : 5562.0 ) : idx;\n\tidx = y == 4.0 ? ( x <= 7.0 ? 43664.0 : 5866.0 ) : idx;\n\tidx = y == 3.0 ? ( x <= 7.0 ? 43584.0 : 5866.0 ) : idx;\n\tidx = y == 2.0 ? ( x <= 7.0 ? 43264.0 : 11178.0 ) : idx;\n\tidx = y == 1.0 ? ( x <= 7.0 ? 43264.0 : 5466.0 ) : idx;\n\tidx = y == 0.0 ? ( x <= 7.0 ? 21504.0 : 21.0 ) : idx;\n    \n    idx = SPRITE_DEC_4( x, idx );\n    idx = x >= 0.0 && x < 15.0 ? idx : 0.0;    \n    \n    color = idx == 0.0 && x >= 0.0 && x < 15.0 && y >= 8.0 && y < 48.0 ? RGB( 0, 0, 0 ) : color;\n    color = idx == 1.0 ? RGB( 4,   88,  180 ) : color;\n    color = idx == 2.0 ? RGB( 192, 192, 192 ) : color;\n    color = idx == 3.0 ? RGB( 255, 255, 255 ) : color;        \n}\n\nvoid SpriteBossCannon0( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n    \n\tidx = y == 5.0 ? ( x <= 7.0 ? 39340.0 : 1706.0 ) : idx;\n\tidx = y == 4.0 ? ( x <= 7.0 ? 30663.0 : 2044.0 ) : idx;\n\tidx = y == 3.0 ? ( x <= 7.0 ? 17415.0 : 1024.0 ) : idx;\n\tidx = y == 2.0 ? ( x <= 7.0 ? 30663.0 : 2044.0 ) : idx;\n\tidx = y == 1.0 ? ( x <= 7.0 ? 26615.0 : 2047.0 ) : idx;\n\tidx = y == 0.0 ? ( x <= 7.0 ? 39340.0 : 682.0 ) : idx;\n\n    idx = SPRITE_DEC_4( x, idx );\n    idx = x >= 0.0 && x < 14.0 ? idx : 0.0;\n\n    color = idx == 0.0 && x >= 1.0 && x < 11.0 && y >= 0.0 && y < 6.0 ? RGB( 255, 255, 255 ) : color;    \n    color = idx == 1.0 ? RGB( 0,   0,   0 )   : color;\n    color = idx == 2.0 ? RGB( 4,   88,  180 ) : color;\n    color = idx == 3.0 ? RGB( 192, 192, 192 ) : color;\n}\n\nvoid SpriteBossCannon1( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n    \n\tidx = y == 5.0 ? ( x <= 7.0 ? 39340.0 : 1706.0 ) : idx;\n\tidx = y == 4.0 ? ( x <= 7.0 ? 30663.0 : 2044.0 ) : idx;\n\tidx = y == 3.0 ? ( x <= 7.0 ? 17415.0 : 256.0 ) : idx;\n\tidx = y == 2.0 ? ( x <= 7.0 ? 30663.0 : 508.0 ) : idx;\n\tidx = y == 1.0 ? ( x <= 7.0 ? 26615.0 : 127.0 ) : idx;\n\tidx = y == 0.0 ? ( x <= 7.0 ? 39340.0 : 106.0 ) : idx;\n\n    idx = SPRITE_DEC_4( x, idx );\n    idx = x >= 0.0 && x < 14.0 ? idx : 0.0;\n\n    color = idx == 0.0 && x >= 1.0 && x < 12.0 && y >= 0.0 && y < 6.0 ? RGB( 255, 255, 255 ) : color;    \n    color = idx == 1.0 ? RGB( 0,   0,   0 )   : color;\n    color = idx == 2.0 ? RGB( 4,   88,  180 ) : color;\n    color = idx == 3.0 ? RGB( 192, 192, 192 ) : color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float resMultX      = floor( iResolution.x \/ NES_RES_X );\n    float resMultY      = floor( iResolution.y \/ NES_RES_Y );\n    float resRcp        = 1.0 \/ max( min( resMultX, resMultY ), 1.0 );\n    float screenWidth   = floor( iResolution.x * resRcp );\n    float screenHeight  = floor( iResolution.y * resRcp );\n    float pixelX        = floor( fragCoord.x * resRcp );\n    float pixelY        = floor( fragCoord.y * resRcp );\n    \n    vec4 camera         = LoadValue( txCamera );\n    vec4 bridge         = LoadValue( txBridge );\n    vec4 bossCore       = LoadValue( txBossCore );\n    vec4 bossCannon0    = LoadValue( txBossCannon0 );\n    vec4 bossCannon1    = LoadValue( txBossCannon1 );\n    \n    float worldX        = pixelX + camera.x;\n    float worldY        = pixelY - 8.0;\n    float tileX         = floor( worldX \/ 32.0 );\n    float tile8X        = floor( worldX \/ 8.0 );\n    float tile32Y       = floor( worldY \/ 32.0 );\n    float tile16Y       = floor( worldY \/ 16.0 );\n    float tile8Y        = floor( worldY \/ 8.0 );\n    float worldXMod16   = mod( worldX, 16.0 );\n    float worldYMod16   = mod( worldY, 16.0 );    \n    float worldYMod8    = mod( worldY,  8.0 );\n    float worldXMod32   = mod( worldX, 32.0 );\n    float worldYMod32   = mod( worldY, 32.0 );\n    \n\n    vec3 color = RGB( 0, 0, 0 );\n    \n    \/\/ stars\n    float starRand = Rand( vec2( worldX * 0.01, worldY * 0.01 ) );\n    if ( starRand > 0.998 && worldY > 160.0 )\n    {\n        color = fract( iTime + starRand * 113.17 + worldX * 3.14 ) < 0.5 ? RGB( 255, 255, 255 ) : RGB( 0, 112, 236 );\n    }\n    \n    \/\/ background water\n    if ( worldY < 80.0 && worldX < WATER_END )\n    {\n        color = RGB( 0, 112, 236 );\n    }\n   \n    if ( worldX >= JUNGLE_START + 3.0 && worldX < JUNGLE_END )\n    {\n        SpriteTreeTrunk( color, mod( worldX - 3.0, 16.0 ), mod( worldY, 2.0 ) );    \n        \n    }\n\n    if ( worldX >= JUNGLE_START + 3.0 && worldX < JUNGLE_END && floor( ( worldY + 5.0 ) \/ 32.0 ) == 6.0 )\n    {\n        SpriteLeaves( color, mod( worldX - 3.0, 32.0 ), mod( worldY + 5.0, 32.0 ) );\n    }\n    \n    bool grass0 = false;\n    bool grass2 = false;\n    bool grass3 = false;\n    bool grass4 = false;\n    bool grass6 = false;\n    bool grass8 = false;\n    \n    if (        ( tileX >= 52.0 && tileX < 67.0 ) \n            ||  ( tileX >= 72.0 && tileX < 77.0 )   \n            ||  ( tileX >= 86.0 && tileX < 88.0 ) )\n    {\n        grass8 = true;\n    }\n    \n    if (        ( tileX >= 3.0   && tileX < 30.0 ) \n            ||  ( tileX >= 35.0  && tileX < 40.0 ) \n            ||  ( tileX >= 45.0  && tileX < 53.0 ) \n            ||  ( tileX >= 66.0  && tileX < 73.0 )\n            ||  ( tileX >= 78.0  && tileX < 80.0 )\n            ||  ( tileX >= 85.0  && tileX < 87.0 )\n            ||  ( tileX >= 89.0  && tileX < 91.0 )\n            ||  ( tileX >= 102.0 && tileX < 106.0 ) )\n    {\n        grass6 = true;\n    }\n    \n    if (        ( tileX >= 10.0 && tileX < 13.0 )\n            ||  ( tileX >= 18.0 && tileX < 20.0 )\n            ||  ( tileX >= 58.0 && tileX < 65.0 )\n            ||  ( tileX >= 76.0 && tileX < 79.0 )\n            ||  ( tileX >= 81.0 && tileX < 83.0 )\n            ||  ( tileX >= 90.0 && tileX < 95.0 )\n            ||  ( tileX >= 100.0 && tileX < 102.0 )\n            ||  ( tileX == 106.0 ) )\n    {\n        grass4 = true;\n    }\n    \n    if (        ( tileX >= 26.0 && tileX < 29.0 )\n            ||  ( tileX >= 55.0 && tileX < 57.0 )\n            ||  ( tileX == 74.0 )\n            ||  ( tileX == 87.0 )\n            ||  ( tileX >= 103.0 && tileX < 106.0 ) )\n    {\n        grass3 = true;\n    }\n        \n    if (        ( tileX == 13.0 || tileX == 16.0 )\n            ||  ( tileX >= 68.0 && tileX < 70.0 )\n            ||  ( tileX >= 71.0 && tileX < 73.0 )\n            ||  ( tileX >= 82.0 && tileX < 85.0 )\n            ||  ( tileX >= 97.0 && tileX < 99.0 )\n            ||  ( tileX == 107.0 ) )\n    {\n        grass2 = true;\n    }\n        \n    if (        ( tileX >= 14.0 && tileX < 16.0 ) \n            ||  ( tileX >= 24.0 && tileX < 26.0 ) \n            ||  ( tileX >= 52.0 && tileX < 55.0 ) \n            ||  ( tileX >= 62.0 && tileX < 68.0 )\n            ||  ( tileX == 81.0 )\n            ||  ( tileX == 86.0 )\n            ||  ( tileX >= 93.0 && tileX < 96.0 )\n            ||  ( tileX >= 102.0 ) )      \n    {\n        grass0 = true;\n    }\n    \n    float rockTile32Y = -1.0;\n    if ( grass2 )\n    {\n        rockTile32Y = 1.0;\n    }       \n    if ( grass4 )\n    {\n        rockTile32Y = 2.0;\n    }        \n    if ( grass6 )\n    {\n        rockTile32Y = 3.0;\n    }\n    if ( grass8 )\n    {\n        rockTile32Y = 4.0;\n    }    \n    \n    if ( tile32Y < rockTile32Y )\n    {\n        SpriteRock( color, worldXMod32, mod( worldY + 8.0, 32.0 ) );    \n    }\n    \n    if (        ( tile8Y == -1.0 && grass0 ) \n            ||  ( tile8Y == 3.0 && grass2 )\n            ||  ( tile8Y == 5.0 && grass3 )\n            ||  ( tile8Y == 7.0 && grass4 )\n            ||  ( tile8Y == 11.0 && grass6 )\n            ||  ( tile8Y == 15.0 && grass8 ) )\n    {\n        SpriteRockTop( color, worldXMod32, worldYMod8 );\n    }    \n    \n    \/\/ foreground water\n    if ( ( worldY < 16.0 && worldX < WATER_END ) \n        || ( tile16Y < 2.0 && (\n                    ( tileX < 10.0 ) \n                ||  ( tileX == 17.0 )\n                ||  ( tileX >= 20.0 && tileX < 23.0 )\n                ||  ( tileX >= 33.0 && tileX < 47.0 )\n                ||  ( tileX == 57.0 ) \n           ) )\n       )\n    {\n        color = RGB( 0, 112, 236 );\n    }    \n    \n    if (    ( floor( ( worldY - 1.0 ) \/ 8.0 ) == 3.0 && ( ( tileX >= 3.0 && tileX < 10.0 ) || ( tileX == 17.0 ) || ( tileX >= 20.0 && tileX < 23.0 ) || ( tileX >= 35.0 && tileX < 40.0 ) || ( tileX >= 45.0 && tileX < 47.0 ) || ( tileX == 57.0 ) ) )\n         || ( floor( ( worldY - 1.0 ) \/ 8.0 ) == 1.0 && ( ( tileX >= 10.0 && tileX < 17.0 ) || ( tileX >= 18.0 && tileX < 20.0 ) || ( tileX >= 23.0 && tileX < 30.0 ) || ( tileX >= 47.0 && tileX < 57.0 ) || ( tileX >= 58.0 && tileX < 63.0 ) ) )\n         || ( floor( ( worldY - 1.0 ) \/ 8.0 ) == -1.0 && ( ( tileX >= 14.0 && tileX < 16.0 ) || ( tileX >= 24.0 && tileX < 26.0 ) || ( tileX >= 52.0 && tileX < 55.0 ) || ( tileX == 62.0 ) ) )\n       )\n    {\n        SpriteShore( color, mod( worldX, 32.0 ), mod( worldY - 1.0, 8.0 ) );  \n    }    \n    \n    if ( floor( ( worldY ) \/ 24.0 ) == 1.0 && ( tile8X == 11.0 || tile8X == 139.0 || tile8X == 160.0 || tile8X == 179.0 ) )\n    {\n        float shoreX = ( tile8X == 160.0 ) ? 7.0 - worldX : worldX;\n        SpriteShoreSide( color, mod( shoreX, 8.0 ), mod( worldY, 24.0 ) );\n    }        \n    \n\tif ( floor( ( worldY + 14.0 ) \/ 24.0 ) == 1.0 && ( tile8X == 39.0 || tile8X == 68.0 || tile8X == 72.0 || tile8X == 80.0 || tile8X == 91.0 || tile8X == 120.0 || tile8X == 187.0 || tile8X == 228.0 || tile8X == 231.0 ) )\n    {\n        float shoreX = ( tile8X == 68.0 || tile8X == 80.0 || tile8X == 120.0 || tile8X == 228.0 ) ? 7.0 - worldX : worldX;\n        SpriteShoreSide( color, mod( shoreX, 8.0 ), mod( worldY + 14.0, 24.0 ) );\n    }    \n    \n    if ( floor( ( worldY + 6.0 ) \/ 24.0 ) == 0.0 && ( tile8X == 55.0 || tile8X == 64.0 || tile8X == 95.0 || tile8X == 104.0 || tile8X == 207.0 || tile8X == 220.0 || tile8X == 247.0 ) )\n    {\n        float shoreX = ( tile8X == 64.0 || tile8X == 104.0 || tile8X == 220.0 ) ? 7.0 - worldX : worldX;\n    \tSpriteShoreSide( color, mod( shoreX, 8.0 ), mod( worldY + 6.0, 24.0 ) );\n    }\n    \n    if (        ( tile16Y == 0.0 && grass0 ) \n            ||  ( tile16Y == 2.0 && grass2 )\n            ||  ( tile16Y == 3.0 && grass3 )\n            ||  ( tile16Y == 4.0 && grass4 )\n            ||  ( tile16Y == 6.0 && grass6 )\n            ||  ( tile16Y == 8.0 && grass8 ) )\n    {\n        SpriteGrass( color, worldXMod32, worldYMod16 );\n    }\n    \n    if (        ( grass8 && tile16Y == 9.0 )\n            ||  ( !grass8 && grass6 && tile16Y == 7.0 )\n            ||  ( !grass8 && !grass6 && grass4 && tile16Y == 5.0 )\n            ||  ( !grass8 && !grass6 && !grass4 && grass2 && tile16Y == 3.0 )\n            ||  ( !grass8 && !grass6 && !grass4 && !grass2 && grass0 && tile16Y == 1.0 ) )\n    {\n        SpriteBush( color, worldXMod32, worldYMod16 );\n    }\n    \n    if ( floor( ( worldY - 1.0 ) \/ 24.0 ) == 5.0 && ( \n                ( tileX >= 3.0 && tileX < 30.0 ) \n            ||  ( tileX >= 35.0 && tileX < 40.0 )\n            ||  ( tileX >= 45.0 && tileX < 52.0 )) )\n    {\n\t\tSpriteTreeMiddle( color, mod( worldX + 8.0, 16.0 ), mod( worldY - 1.0, 24.0 ) );\n    }\n    \n    if ( floor( ( worldY - 1.0 ) \/ 24.0 ) == 5.0 && \n        ( ( tile8X == 12.0 || tile8X == 34.0 || tile8X == 140.0 || tile8X == 180.0 )\n        || ( mod( tile8X, 16.0 ) == 0.0 ) && tile8X < 119.0 ) )\n    {\n    \tSpriteTreeStart( color, mod( worldX, 8.0 ), mod( worldY - 1.0, 24.0 ) );\n    }\n    \n    if ( floor( ( worldY - 1.0 ) \/ 24.0 ) == 5.0 && \n        ( ( tile8X == 119.0 || tile8X == 159.0 || tile8X == 207.0 )\n        || ( mod( tile8X + 1.0, 16.0 ) == 0.0 ) && tile8X < 119.0 ) )\n    {\n    \tSpriteTreeEnd( color, mod( worldX, 8.0 ), mod( worldY - 1.0, 24.0 ) );\n    }    \n    \n    if ( floor( ( worldY + 12.0 ) \/ 32.0 ) == 3.0 && bridge.x < tileX && (\n            ( tileX >= BRIDGE_0_START_TILE && tileX < BRIDGE_0_END_TILE )\n        ||  ( tileX >= BRIDGE_1_START_TILE && tileX < BRIDGE_1_END_TILE )\n       ) )\n    {\n        SpriteBridge( color, worldXMod32, mod( worldY + 12.0, 32.0 ) );\n    }  \n    \n    \/\/ boss back\n    if ( worldX > 3506.0 && worldY < 168.0 )\n    {\n        float idx = 2.0;\n                \n        \/\/ horizontal bars\n        idx = mod( worldX, 16.0 ) == 0.0 && mod( worldY + 8.0, 88.0 ) < 76.0 ? 3.0 : idx;\n        idx = mod( worldX + 8.0, 16.0 ) == 0.0 && mod( worldY + 8.0, 88.0 ) < 76.0 ? 1.0 : idx;\n        idx = mod( worldX, 16.0 ) > 8.0 && mod( worldY + 8.0, 88.0 ) == 76.0 ? 1.0 : idx;\n        \n        \/\/ vertical bars\n        idx = mod( worldY + 8.0, 88.0 ) == 0.0 ? 1.0 : idx;\n        idx = mod( worldY + 9.0, 88.0 ) == 0.0 ? 3.0 : idx;\n        idx = mod( worldY + 10.0, 88.0 ) == 0.0 ? 4.0 : idx;\n        idx = mod( worldY + 11.0, 88.0 ) == 0.0 ? 3.0 : idx;\n        idx = mod( worldY + 12.0, 88.0 ) == 0.0 ? 3.0 : idx;\n        idx = mod( worldY + 13.0, 88.0 ) == 0.0 ? 1.0 : idx;\n        idx = worldX == 3506.0 + 1.0 ? 3.0 : idx;\n        idx = worldX == 3506.0 + 2.0 ? 4.0 : idx;\n        \n        color = idx == 1.0 ? RGB( 0,   0,   0   ) : color;\n        color = idx == 2.0 ? RGB( 4,   88,  180 ) : color;\n        color = idx == 3.0 ? RGB( 192, 192, 192 ) : color;\n        color = idx == 4.0 ? RGB( 255, 255, 255 ) : color;\n    }\n    \n    \/\/ boss front\n    if ( worldX >= 3476.0 && worldX <= 3506.0 && worldY >= 16.0 && worldY <= 152.0 + floor( 0.5 * ( worldX - 3476.0 ) ) )\n    {\n        float idx = 3.0;\n        \n        \/\/ vertical bars\n        idx = mod( worldX, 4.0 ) == 0.0       ? 1.0 : idx;\n        idx = mod( worldX - 1.0, 8.0 ) == 0.0 ? 4.0 : idx;\n        idx = mod( worldX - 3.0, 8.0 ) == 0.0 ? 2.0 : idx;\n        \n        \/\/ top\n        idx = worldY == 152.0 + floor( 0.5 * ( worldX - 3476.0 ) ) ? 2.0 : idx;\n        \n        \/\/ middle\n        idx = worldY == 83.0 && worldX < 3504.0 ? 1.0 : idx;\n        idx = worldY == 82.0 && worldX >= 3477.0 && worldX < 3504.0 ? 3.0 : idx;\n        idx = worldY == 81.0 && worldX >= 3477.0 && worldX < 3504.0 ? 3.0 : idx;\n        idx = worldY == 81.0 && mod( worldX + 4.0, 8.0 ) > 4.0 && worldX < 3504.0 ? 1.0 : idx;\n        \n        \/\/ bottom\n        idx = worldY < 20.0 - floor( 0.2 * ( worldX - 3476.0 ) ) ? 1.0 : idx;\n        idx = worldY == 20.0 - floor( 0.2 * ( worldX - 3476.0 ) ) ? 2.0 : idx;\n        \n        \n        color = idx == 1.0 ? RGB( 0,   0,   0   ) : color;\n        color = idx == 2.0 ? RGB( 4,   88,  180 ) : color;\n        color = idx == 3.0 ? RGB( 192, 192, 192 ) : color;\n        color = idx == 4.0 ? RGB( 255, 255, 255 ) : color;        \n    }\n    \n    SpriteBossCore( color, worldX - bossCore.x + BOSS_CORE_SIZE.x * 0.5, worldY - bossCore.y );\n    SpriteBossCannonBase( color, worldX - 3477.0, worldY - 84.0 );\n    SpriteBossTopPanel( color, worldX - 3469.0, worldY - 116.0 );\n    SpriteBossTopPanel( color, worldX - 3493.0, worldY - 120.0 );\n    SpriteBossCannon0( color, worldX - bossCannon0.x + BOSS_CANNON_SIZE.x * 0.5, worldY - bossCannon0.y );\n    SpriteBossCannon1( color, worldX - bossCannon1.x + BOSS_CANNON_SIZE.x * 0.5, worldY - bossCannon1.y );\n    \n    fragColor = vec4( color, 1.0 );\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\/\/ Foreground\n\n#define SPRITE_DEC_2( x, i ) mod( floor( i \/ pow( 2.0, mod( x, 24.0 ) ) ), 2.0 )\n#define SPRITE_DEC_3( x, i ) mod( floor( i \/ pow( 4.0, mod( x, 11.0 ) ) ), 4.0 )\n#define SPRITE_DEC_4( x, i ) mod( floor( i \/ pow( 4.0, mod( x, 8.0 ) ) ), 4.0 )\n#define RGB( r, g, b ) vec3( float( r ) \/ 255.0, float( g ) \/ 255.0, float( b ) \/ 255.0 )\n\nconst float NES_RES_X           = 224.0;\nconst float NES_RES_Y           = 192.0;\nconst float STATE_RUN           = 0.0;\nconst float STATE_PRONE         = 1.0;\nconst float STATE_JUMP          = 2.0;\nconst float STATE_FALL          = 3.0;\nconst float STATE_WATER         = 4.0;\nconst float STATE_UNDER_WATER   = 5.0;\nconst vec2  BILL_PRONE_SIZE     = vec2( 32.0, 18.0 );\nconst vec2  BILL_RUN_SIZE       = vec2( 24.0, 34.0 );\nconst vec2  BILL_JUMP_SIZE      = vec2( 20.0, 20.0 );\nconst vec2  SOLDIER_SIZE        = vec2( 18.0, 32.0 );\nconst vec2  SNIPER_SIZE         = vec2( 24.0, 32.0 );\nconst vec2  TURRET_SIZE         = vec2( 32.0, 32.0 );\nconst vec2  BOSS_CORE_SIZE      = vec2( 24.0, 31.0 );\n\n\/\/ storage\nconst vec2 txPlayer \t\t\t= vec2( 0.0, 0.0 ); \t\/\/ xy - pos, z - jump start, w - jump dir\nconst vec2 txPlayerState\t\t= vec2( 1.0, 0.0 ); \t\/\/ x - state, y - frame, z - jump tick, w - lifes\nconst vec2 txPlayerDir\t\t\t= vec2( 2.0, 0.0 ); \t\/\/ xy - dir, z - flip, w - immortality\nconst vec2 txPlayerWeapon\t\t= vec2( 3.0, 0.0 ); \t\/\/ x - weapon, y - weapon cooldown, z - weapon fire rate, w - weapon bullet num\nconst vec2 txCamera \t\t\t= vec2( 4.0, 0.0 ); \t\/\/ x - cam offset, y - spawn counter, z - soldier spawn counter\nconst vec2 txSoldier0 \t\t\t= vec2( 5.0, 0.0 ); \t\/\/ xy - pos, z - flip\nconst vec2 txSoldier1 \t\t\t= vec2( 5.0, 1.0 ); \t\/\/ xy - pos, z - flip\nconst vec2 txSoldier2 \t\t\t= vec2( 5.0, 2.0 ); \t\/\/ xy - pos, z - flip\nconst vec2 txSoldier0State \t\t= vec2( 6.0, 0.0 ); \t\/\/ x - state, y - frame, z - jump tick\nconst vec2 txSoldier1State \t\t= vec2( 6.0, 1.0 ); \t\/\/ x - state, y - frame, z - jump tick\nconst vec2 txSoldier2State \t\t= vec2( 6.0, 2.0 ); \t\/\/ x - state, y - frame, z - jump tick\nconst vec2 txSniper\t \t\t\t= vec2( 7.0, 0.0 ); \t\/\/ xy - pos, z - flip, w - weapon cooldown\nconst vec2 txPlayerBullet0 \t\t= vec2( 8.0, 0.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txPlayerBullet1 \t\t= vec2( 8.0, 1.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txPlayerBullet2 \t\t= vec2( 8.0, 2.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txPlayerBullet3 \t\t= vec2( 8.0, 3.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txPlayerBullet4 \t\t= vec2( 8.0, 4.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txPlayerBullet5 \t\t= vec2( 8.0, 5.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txEnemyBullet0 \t\t= vec2( 9.0, 0.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txEnemyBullet1 \t\t= vec2( 9.0, 1.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txEnemyBullet2 \t\t= vec2( 9.0, 2.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txEnemyBullet3 \t\t= vec2( 9.0, 3.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txExplosion \t\t\t= vec2( 10.0, 0.0 ); \t\/\/ xy - pos, z - frame\nconst vec2 txHit \t\t\t\t= vec2( 11.0, 0.0 ); \t\/\/ xy - pos, z - frame\nconst vec2 txTurret0\t\t\t= vec2( 12.0, 0.0 ); \t\/\/ xy - pos, z - angle\nconst vec2 txTurret1\t\t\t= vec2( 12.0, 1.0 ); \t\/\/ xy - pos, z - angle\nconst vec2 txTurret0State\t\t= vec2( 13.0, 0.0 ); \t\/\/ x - HP, y - weapon cooldown\nconst vec2 txTurret1State\t\t= vec2( 13.0, 1.0 ); \t\/\/ x - HP, y - weapon cooldown\nconst vec2 txPowerUp\t\t\t= vec2( 14.0, 0.0 ); \t\/\/ xy - pos, z - frame\nconst vec2 txPowerUpState\t\t= vec2( 15.0, 0.0 ); \t\/\/ x - state, y - initial height, z - jump tick\nconst vec2 txBossCore\t\t\t= vec2( 16.0, 0.0 ); \t\/\/ xy - pos, z - HP\nconst vec2 txBossCannon0\t\t= vec2( 17.0, 0.0 ); \t\/\/ xy - pos, z - cooldown, w - HP\nconst vec2 txBossCannon1\t\t= vec2( 17.0, 1.0 ); \t\/\/ xy - pos, z - cooldown, w - HP\nconst vec2 txBossBullet0\t\t= vec2( 18.0, 0.0 ); \t\/\/ xy - pos, zw - velocity\nconst vec2 txBossBullet1\t\t= vec2( 18.0, 1.0 ); \t\/\/ xy - pos, zw - velocity\nconst vec2 txGameState\t\t\t= vec2( 19.0, 0.0 ); \t\/\/ x - state, y - state tick\nconst vec2 txBridge\t\t\t\t= vec2( 20.0, 0.0 ); \t\/\/ x - draw start, y - explode tick\n\nvoid Swap( inout float a, inout float b )\n{\n    float tmp = a;\n    a = b;\n    b = tmp;\n}\n\nvec4 LoadValue( vec2 tx )\n{\n    return floor( texture( iChannel0, ( tx + 0.5 ) \/ iChannelResolution[ 0 ].xy ) );\n}\n\nvoid SpriteTurret( inout vec3 color, float x, float y, float frame )\n{\n    float idx = 0.0;    \n    \n    if ( frame == 0.0 )\n    {\n        \/\/ left\n        idx = y == 13.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 21844.0 : 0.0 ) ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 65533.0 : 21.0 ) ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 16384.0 : ( x <= 15.0 ? 48927.0 : 127.0 ) ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 16384.0 : ( x <= 15.0 ? 44922.0 : 426.0 ) ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 21780.0 : ( x <= 15.0 ? 27621.0 : 425.0 ) ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 43625.0 : ( x <= 15.0 ? 11162.0 : 681.0 ) ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 65469.0 : ( x <= 15.0 ? 11127.0 : 681.0 ) ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 43625.0 : ( x <= 15.0 ? 11262.0 : 681.0 ) ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 21845.0 : ( x <= 15.0 ? 27509.0 : 425.0 ) ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 21844.0 : ( x <= 15.0 ? 44650.0 : 427.0 ) ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 17680.0 : ( x <= 15.0 ? 47642.0 : 362.0 ) ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 16384.0 : ( x <= 15.0 ? 43689.0 : 341.0 ) ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 21845.0 : 85.0 ) ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 21844.0 : 5.0 ) ) : idx; \n    }\n    else if ( frame == 1.0 )\n    {\n        \/\/ up - left\n        idx = y == 14.0 ? ( x <= 7.0 ? 276.0 : ( x <= 15.0 ? 64.0 : 0.0 ) ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 361.0 : ( x <= 15.0 ? 1488.0 : 0.0 ) ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 5753.0 : ( x <= 15.0 ? 24564.0 : 0.0 ) ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 27541.0 : ( x <= 15.0 ? 48253.0 : 1.0 ) ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 47701.0 : ( x <= 15.0 ? 65014.0 : 7.0 ) ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 58708.0 : ( x <= 15.0 ? 45018.0 : 30.0 ) ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 38208.0 : ( x <= 15.0 ? 43766.0 : 106.0 ) ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 25856.0 : ( x <= 15.0 ? 27381.0 : 169.0 ) ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 41984.0 : ( x <= 15.0 ? 10939.0 : 169.0 ) ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 41984.0 : ( x <= 15.0 ? 19129.0 : 169.0 ) ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 41984.0 : ( x <= 15.0 ? 19124.0 : 170.0 ) ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 37888.0 : ( x <= 15.0 ? 38587.0 : 106.0 ) ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 20480.0 : ( x <= 15.0 ? 44713.0 : 106.0 ) ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 43669.0 : 90.0 ) ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 21844.0 : 85.0 ) ) : idx;   \n    }\n    else\n    {\n        \/\/ down - left\n        idx = y == 14.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 21824.0 : 5.0 ) ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 65428.0 : 27.0 ) ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 16384.0 : ( x <= 15.0 ? 45053.0 : 106.0 ) ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 53248.0 : ( x <= 15.0 ? 38591.0 : 106.0 ) ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 62464.0 : ( x <= 15.0 ? 19188.0 : 170.0 ) ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 58368.0 : ( x <= 15.0 ? 19133.0 : 169.0 ) ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 41984.0 : ( x <= 15.0 ? 10938.0 : 169.0 ) ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 25600.0 : ( x <= 15.0 ? 27365.0 : 169.0 ) ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 37888.0 : ( x <= 15.0 ? 43750.0 : 107.0 ) ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 58624.0 : ( x <= 15.0 ? 44954.0 : 90.0 ) ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 47680.0 : ( x <= 15.0 ? 47526.0 : 86.0 ) ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 27540.0 : ( x <= 15.0 ? 43113.0 : 85.0 ) ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 22137.0 : ( x <= 15.0 ? 23205.0 : 5.0 ) ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 38249.0 : ( x <= 15.0 ? 21909.0 : 1.0 ) ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 21844.0 : ( x <= 15.0 ? 21845.0 : 0.0 ) ) : idx;      \n    }\n\n    idx = SPRITE_DEC_4( x, idx );    \n    idx = x >= 0.0 && x < 21.0 ? idx : 0.0;\n\n    float blink = abs( sin( iTime * 3.0 ) ) + 0.5;\n    \n    color = idx == 0.0 && x >= 8.0 && x < 16.0 && y >= 3.0 && y < 12.0 ? blink * RGB( 228, 68, 52 ) : color;\n    color = idx == 1.0 ? RGB( 0,   0,   0   ) : color;\n    color = idx == 2.0 ? RGB( 192, 192, 192 ) : color;\n    color = idx == 3.0 ? RGB( 255, 255, 255 ) : color;\n}\n\nvoid SpriteTurretBase( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;    \n    \n    idx = y == 31.0 ? ( x <= 10.0 ? 2796201.0 : ( x <= 21.0 ? 2796202.0 : 174762.0 ) ) : idx;\n    idx = y == 30.0 ? ( x <= 10.0 ? 1398102.0 : ( x <= 21.0 ? 1398101.0 : 349525.0 ) ) : idx;\n    idx = y == 29.0 ? ( x <= 10.0 ? 2796182.0 : ( x <= 21.0 ? 2796202.0 : 289450.0 ) ) : idx;\n    idx = y == 28.0 ? ( x <= 10.0 ? 2796198.0 : ( x <= 21.0 ? 2796202.0 : 285354.0 ) ) : idx;\n    idx = y == 27.0 ? ( x <= 10.0 ? 1398182.0 : ( x <= 21.0 ? 1398101.0 : 279893.0 ) ) : idx;\n    idx = y == 26.0 ? ( x <= 10.0 ? 1397158.0 : ( x <= 21.0 ? 1398101.0 : 279637.0 ) ) : idx;\n    idx = y == 25.0 ? ( x <= 10.0 ? 1399206.0 : ( x <= 21.0 ? 1398101.0 : 280149.0 ) ) : idx;\n    idx = y == 24.0 ? ( x <= 10.0 ? 21926.0 : ( x <= 21.0 ? 0.0 : 279888.0 ) ) : idx;\n    idx = y == 23.0 ? ( x <= 10.0 ? 2692518.0 : ( x <= 21.0 ? 2796202.0 : 279905.0 ) ) : idx;\n    idx = y == 22.0 ? ( x <= 10.0 ? 1709478.0 : ( x <= 21.0 ? 1398101.0 : 279905.0 ) ) : idx;\n    idx = y == 21.0 ? ( x <= 10.0 ? 1447334.0 : ( x <= 21.0 ? 1398101.0 : 279905.0 ) ) : idx;\n    idx = y == 20.0 ? ( x <= 10.0 ? 1447334.0 : ( x <= 21.0 ? 1398101.0 : 279905.0 ) ) : idx;\n    idx = y == 19.0 ? ( x <= 10.0 ? 1447334.0 : ( x <= 21.0 ? 1398101.0 : 279905.0 ) ) : idx;\n    idx = y == 18.0 ? ( x <= 10.0 ? 1447334.0 : ( x <= 21.0 ? 1398101.0 : 279905.0 ) ) : idx;\n    idx = y == 17.0 ? ( x <= 10.0 ? 1447334.0 : ( x <= 21.0 ? 1398101.0 : 279905.0 ) ) : idx;\n    idx = y == 16.0 ? ( x <= 10.0 ? 1447334.0 : ( x <= 21.0 ? 1398101.0 : 279905.0 ) ) : idx;\n    idx = y == 15.0 ? ( x <= 10.0 ? 1447334.0 : ( x <= 21.0 ? 1398101.0 : 279905.0 ) ) : idx;\n    idx = y == 14.0 ? ( x <= 10.0 ? 1447334.0 : ( x <= 21.0 ? 1398101.0 : 279905.0 ) ) : idx;\n    idx = y == 13.0 ? ( x <= 10.0 ? 1447334.0 : ( x <= 21.0 ? 1398101.0 : 279905.0 ) ) : idx;\n    idx = y == 12.0 ? ( x <= 10.0 ? 1447334.0 : ( x <= 21.0 ? 1398101.0 : 279905.0 ) ) : idx;\n    idx = y == 11.0 ? ( x <= 10.0 ? 1447334.0 : ( x <= 21.0 ? 1398101.0 : 279905.0 ) ) : idx;\n    idx = y == 10.0 ? ( x <= 10.0 ? 1447334.0 : ( x <= 21.0 ? 1398101.0 : 279905.0 ) ) : idx;\n    idx = y == 9.0 ? ( x <= 10.0 ? 1381798.0 : ( x <= 21.0 ? 1398101.0 : 279905.0 ) ) : idx;\n    idx = y == 8.0 ? ( x <= 10.0 ? 5542.0 : ( x <= 21.0 ? 0.0 : 279904.0 ) ) : idx;\n    idx = y == 7.0 ? ( x <= 10.0 ? 2774438.0 : ( x <= 21.0 ? 2796202.0 : 279898.0 ) ) : idx;\n    idx = y == 6.0 ? ( x <= 10.0 ? 1398182.0 : ( x <= 21.0 ? 1398101.0 : 279893.0 ) ) : idx;\n    idx = y == 5.0 ? ( x <= 10.0 ? 1397158.0 : ( x <= 21.0 ? 1398101.0 : 279637.0 ) ) : idx;\n    idx = y == 4.0 ? ( x <= 10.0 ? 1399206.0 : ( x <= 21.0 ? 1398101.0 : 280149.0 ) ) : idx;\n    idx = y == 3.0 ? ( x <= 10.0 ? 102.0 : ( x <= 21.0 ? 0.0 : 278528.0 ) ) : idx;\n    idx = y == 2.0 ? ( x <= 10.0 ? 1398102.0 : ( x <= 21.0 ? 1398101.0 : 283989.0 ) ) : idx;\n    idx = y == 1.0 ? ( x <= 10.0 ? 6.0 : ( x <= 21.0 ? 0.0 : 262144.0 ) ) : idx;\n    idx = y == 0.0 ? ( x <= 10.0 ? 1398100.0 : ( x <= 21.0 ? 1398101.0 : 87381.0 ) ) : idx;\n\n    idx = SPRITE_DEC_3( x, idx );    \n    if ( x >= 0.0 && x < 32.0 && y >= 0.0 && y < 32.0 )\n    {\n        color = RGB( 0, 0, 0 );\n        color = idx == 1.0 ? RGB( 192, 192, 192 ) : color;\n        color = idx == 2.0 ? RGB( 255, 255, 255 ) : color;  \n    }\n}\n\nvoid SpriteSniper( inout vec3 color, float x, float y )\n{\n    float idx = 0.0; \n    \n    idx = y == 30.0 ? ( x <= 7.0 ? 21504.0 : 0.0 ) : idx;\n    idx = y == 29.0 ? ( x <= 7.0 ? 43264.0 : ( x <= 15.0 ? 1.0 : 0.0 ) ) : idx;\n    idx = y == 28.0 ? ( x <= 7.0 ? 48704.0 : ( x <= 15.0 ? 6.0 : 0.0 ) ) : idx;\n    idx = y == 27.0 ? ( x <= 7.0 ? 23104.0 : ( x <= 15.0 ? 5125.0 : ( x <= 23.0 ? 20821.0 : 0.0 ) ) ) : idx;\n    idx = y == 26.0 ? ( x <= 7.0 ? 62720.0 : ( x <= 15.0 ? 32085.0 : ( x <= 23.0 ? 30711.0 : 0.0 ) ) ) : idx;\n    idx = y == 25.0 ? ( x <= 7.0 ? 30032.0 : ( x <= 15.0 ? 65021.0 : ( x <= 23.0 ? 20863.0 : 0.0 ) ) ) : idx;\n    idx = y == 24.0 ? ( x <= 7.0 ? 21924.0 : ( x <= 15.0 ? 21855.0 : ( x <= 23.0 ? 117.0 : 0.0 ) ) ) : idx;\n    idx = y == 23.0 ? ( x <= 7.0 ? 55993.0 : ( x <= 15.0 ? 58869.0 : ( x <= 23.0 ? 21.0 : 0.0 ) ) ) : idx;\n    idx = y == 22.0 ? ( x <= 7.0 ? 22185.0 : ( x <= 15.0 ? 63997.0 : ( x <= 23.0 ? 1.0 : 0.0 ) ) ) : idx;\n    idx = y == 21.0 ? ( x <= 7.0 ? 64917.0 : ( x <= 15.0 ? 23903.0 : 0.0 ) ) : idx;\n    idx = y == 20.0 ? ( x <= 7.0 ? 64852.0 : ( x <= 15.0 ? 1893.0 : 0.0 ) ) : idx;\n    idx = y == 19.0 ? ( x <= 7.0 ? 21860.0 : ( x <= 15.0 ? 342.0 : 0.0 ) ) : idx;\n    idx = y == 18.0 ? ( x <= 7.0 ? 27280.0 : ( x <= 15.0 ? 5.0 : 0.0 ) ) : idx;\n    idx = y == 17.0 ? ( x <= 7.0 ? 54608.0 : ( x <= 15.0 ? 23.0 : 0.0 ) ) : idx;\n    idx = y == 16.0 ? ( x <= 7.0 ? 21824.0 : ( x <= 15.0 ? 26.0 : 0.0 ) ) : idx;\n    idx = y == 15.0 ? ( x <= 7.0 ? 43664.0 : ( x <= 15.0 ? 90.0 : 0.0 ) ) : idx;\n    idx = y == 14.0 ? ( x <= 7.0 ? 43664.0 : ( x <= 15.0 ? 105.0 : 0.0 ) ) : idx;\n    idx = y == 13.0 ? ( x <= 7.0 ? 27200.0 : ( x <= 15.0 ? 426.0 : 0.0 ) ) : idx;\n    idx = y == 12.0 ? ( x <= 7.0 ? 28304.0 : ( x <= 15.0 ? 490.0 : 0.0 ) ) : idx;\n    idx = y == 11.0 ? ( x <= 7.0 ? 7824.0 : ( x <= 15.0 ? 489.0 : 0.0 ) ) : idx;\n    idx = y == 10.0 ? ( x <= 7.0 ? 7824.0 : ( x <= 15.0 ? 421.0 : 0.0 ) ) : idx;\n    idx = y == 9.0 ? ( x <= 7.0 ? 1956.0 : ( x <= 15.0 ? 1700.0 : 0.0 ) ) : idx;\n    idx = y == 8.0 ? ( x <= 7.0 ? 420.0 : ( x <= 15.0 ? 1700.0 : 0.0 ) ) : idx;\n    idx = y == 7.0 ? ( x <= 7.0 ? 420.0 : ( x <= 15.0 ? 1680.0 : 0.0 ) ) : idx;\n    idx = y == 6.0 ? ( x <= 7.0 ? 404.0 : ( x <= 15.0 ? 1680.0 : 0.0 ) ) : idx;\n    idx = y == 5.0 ? ( x <= 7.0 ? 84.0 : ( x <= 15.0 ? 1360.0 : 0.0 ) ) : idx;\n    idx = y == 4.0 ? ( x <= 7.0 ? 84.0 : ( x <= 15.0 ? 1344.0 : 0.0 ) ) : idx;\n    idx = y == 3.0 ? ( x <= 7.0 ? 21.0 : ( x <= 15.0 ? 1344.0 : 0.0 ) ) : idx;\n    idx = y == 2.0 ? ( x <= 7.0 ? 53.0 : ( x <= 15.0 ? 7488.0 : 0.0 ) ) : idx;\n    idx = y == 1.0 ? ( x <= 7.0 ? 213.0 : ( x <= 15.0 ? 30016.0 : 0.0 ) ) : idx;\n    idx = y == 0.0 ? ( x <= 7.0 ? 340.0 : ( x <= 15.0 ? 21824.0 : 0.0 ) ) : idx;\n\n    idx = SPRITE_DEC_4( x, idx );\n    idx = x >= 0.0 && x < 24.0 ? idx : 0.0;\n\n    color = idx == 1.0 ? RGB( 0,   0,  0 ) : color;\n    color = idx == 2.0 ? RGB( 248, 56, 0 ) : color;\n    color = idx == 3.0 ? y > 16.0 ? RGB( 240, 208, 176 ) : RGB( 255, 255, 255 ) : color;      \n}\n\nvoid SpriteSoldier( inout vec3 color, float x, float y, float frame )\n{\n    float idx = 0.0;    \n    \n    if ( frame == 0.0 )\n    {\n        idx = y == 31.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 1344.0 : 0.0 ) ) : idx;\n        idx = y == 30.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 6804.0 : 0.0 ) ) : idx;\n        idx = y == 29.0 ? ( x <= 7.0 ? 21504.0 : ( x <= 15.0 ? 27621.0 : 0.0 ) ) : idx;\n        idx = y == 28.0 ? ( x <= 7.0 ? 64768.0 : ( x <= 15.0 ? 5781.0 : 0.0 ) ) : idx;\n        idx = y == 27.0 ? ( x <= 7.0 ? 65344.0 : ( x <= 15.0 ? 7510.0 : 0.0 ) ) : idx;\n        idx = y == 26.0 ? ( x <= 7.0 ? 65492.0 : ( x <= 15.0 ? 7514.0 : 0.0 ) ) : idx;\n        idx = y == 25.0 ? ( x <= 7.0 ? 65497.0 : ( x <= 15.0 ? 5542.0 : 0.0 ) ) : idx;\n        idx = y == 24.0 ? ( x <= 7.0 ? 49113.0 : ( x <= 15.0 ? 5561.0 : 0.0 ) ) : idx;\n        idx = y == 23.0 ? ( x <= 7.0 ? 28629.0 : ( x <= 15.0 ? 30125.0 : 0.0 ) ) : idx;\n        idx = y == 22.0 ? ( x <= 7.0 ? 27229.0 : ( x <= 15.0 ? 29802.0 : 0.0 ) ) : idx;\n        idx = y == 21.0 ? ( x <= 7.0 ? 38260.0 : ( x <= 15.0 ? 21845.0 : 0.0 ) ) : idx;\n        idx = y == 20.0 ? ( x <= 7.0 ? 38388.0 : ( x <= 15.0 ? 62973.0 : ( x <= 23.0 ? 1.0 : 0.0 ) ) ) : idx;\n        idx = y == 19.0 ? ( x <= 7.0 ? 27088.0 : ( x <= 15.0 ? 65525.0 : ( x <= 23.0 ? 1.0 : 0.0 ) ) ) : idx;\n        idx = y == 18.0 ? ( x <= 7.0 ? 43328.0 : ( x <= 15.0 ? 21845.0 : ( x <= 23.0 ? 1.0 : 0.0 ) ) ) : idx;\n        idx = y == 17.0 ? ( x <= 7.0 ? 21760.0 : ( x <= 15.0 ? 29701.0 : 0.0 ) ) : idx;\n        idx = y == 16.0 ? ( x <= 7.0 ? 21760.0 : ( x <= 15.0 ? 21509.0 : 0.0 ) ) : idx;\n        idx = y == 15.0 ? ( x <= 7.0 ? 21504.0 : ( x <= 15.0 ? 23.0 : 0.0 ) ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 21504.0 : ( x <= 15.0 ? 87.0 : 0.0 ) ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 20480.0 : ( x <= 15.0 ? 93.0 : 0.0 ) ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 20480.0 : ( x <= 15.0 ? 93.0 : 0.0 ) ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 20480.0 : ( x <= 15.0 ? 93.0 : 0.0 ) ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 21504.0 : ( x <= 15.0 ? 93.0 : 0.0 ) ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 21504.0 : ( x <= 15.0 ? 87.0 : 0.0 ) ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 21504.0 : ( x <= 15.0 ? 23.0 : 0.0 ) ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 23808.0 : ( x <= 15.0 ? 5.0 : 0.0 ) ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 23808.0 : ( x <= 15.0 ? 5.0 : 0.0 ) ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 55104.0 : ( x <= 15.0 ? 7.0 : 0.0 ) ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 57296.0 : ( x <= 15.0 ? 7.0 : 0.0 ) ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 55104.0 : ( x <= 15.0 ? 5.0 : 0.0 ) ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 62720.0 : ( x <= 15.0 ? 23.0 : 0.0 ) ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 62464.0 : ( x <= 15.0 ? 127.0 : 0.0 ) ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 21504.0 : ( x <= 15.0 ? 85.0 : 0.0 ) ) : idx;\n    }\n    else\n    {\n        idx = y == 30.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 5376.0 : 0.0 ) ) : idx;\n        idx = y == 29.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 27200.0 : 0.0 ) ) : idx;\n        idx = y == 28.0 ? ( x <= 7.0 ? 20480.0 : ( x <= 15.0 ? 44949.0 : ( x <= 23.0 ? 1.0 : 0.0 ) ) ) : idx;\n        idx = y == 27.0 ? ( x <= 7.0 ? 62464.0 : ( x <= 15.0 ? 23127.0 : ( x <= 23.0 ? 1.0 : 0.0 ) ) ) : idx;\n        idx = y == 26.0 ? ( x <= 7.0 ? 64768.0 : ( x <= 15.0 ? 30107.0 : 0.0 ) ) : idx;\n        idx = y == 25.0 ? ( x <= 7.0 ? 65344.0 : ( x <= 15.0 ? 30038.0 : 0.0 ) ) : idx;\n        idx = y == 24.0 ? ( x <= 7.0 ? 65344.0 : ( x <= 15.0 ? 21925.0 : 0.0 ) ) : idx;\n        idx = y == 23.0 ? ( x <= 7.0 ? 48960.0 : ( x <= 15.0 ? 5561.0 : 0.0 ) ) : idx;\n        idx = y == 22.0 ? ( x <= 7.0 ? 28224.0 : ( x <= 15.0 ? 7597.0 : 0.0 ) ) : idx;\n        idx = y == 21.0 ? ( x <= 7.0 ? 26880.0 : ( x <= 15.0 ? 7530.0 : 0.0 ) ) : idx;\n        idx = y == 20.0 ? ( x <= 7.0 ? 21760.0 : ( x <= 15.0 ? 21845.0 : 0.0 ) ) : idx;\n        idx = y == 19.0 ? ( x <= 7.0 ? 54272.0 : ( x <= 15.0 ? 32095.0 : 0.0 ) ) : idx;\n        idx = y == 18.0 ? ( x <= 7.0 ? 25600.0 : ( x <= 15.0 ? 32767.0 : 0.0 ) ) : idx;\n        idx = y == 17.0 ? ( x <= 7.0 ? 20480.0 : ( x <= 15.0 ? 21845.0 : 0.0 ) ) : idx;\n        idx = y == 16.0 ? ( x <= 7.0 ? 20480.0 : ( x <= 15.0 ? 7509.0 : 0.0 ) ) : idx;\n        idx = y == 15.0 ? ( x <= 7.0 ? 16384.0 : ( x <= 15.0 ? 1397.0 : 0.0 ) ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 16384.0 : ( x <= 15.0 ? 1525.0 : 0.0 ) ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 16469.0 : ( x <= 15.0 ? 6101.0 : 0.0 ) ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 22013.0 : ( x <= 15.0 ? 23893.0 : 0.0 ) ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 63485.0 : ( x <= 15.0 ? 30039.0 : 0.0 ) ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 21885.0 : ( x <= 15.0 ? 30021.0 : 0.0 ) ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 93.0 : ( x <= 15.0 ? 29952.0 : 0.0 ) ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 93.0 : ( x <= 15.0 ? 23808.0 : 0.0 ) ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 21.0 : ( x <= 15.0 ? 5440.0 : 0.0 ) ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 5440.0 : 0.0 ) ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 5952.0 : 0.0 ) ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 8144.0 : 0.0 ) ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 2000.0 : 0.0 ) ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 24564.0 : 0.0 ) ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 65360.0 : ( x <= 23.0 ? 1.0 : 0.0 ) ) ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 21760.0 : ( x <= 23.0 ? 1.0 : 0.0 ) ) ) : idx;\n    }\n    \n    idx = SPRITE_DEC_4( x, idx );\n    idx = x >= 0.0 && x < 18.0 ? idx : 0.0;\n\n    color = idx == 1.0 ? RGB( 0,   0,     0 ) : color;\n    color = idx == 2.0 ? RGB( 248, 56,    0 ) : color;\n    color = idx == 3.0 ? y > 16.0 ? RGB( 240, 208, 176 ) : RGB( 255, 255, 255 ) : color;  \n}\n\nvoid SpriteBillTorsoR( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n    \n    idx = y == 13.0 ? ( x <= 7.0 ? 20480.0 : ( x <= 15.0 ? 5.0 : 0.0 ) ) : idx;\n    idx = y == 12.0 ? ( x <= 7.0 ? 42240.0 : ( x <= 15.0 ? 6.0 : 0.0 ) ) : idx;\n    idx = y == 11.0 ? ( x <= 7.0 ? 21824.0 : ( x <= 15.0 ? 21.0 : 0.0 ) ) : idx;\n    idx = y == 10.0 ? ( x <= 7.0 ? 58688.0 : ( x <= 15.0 ? 23.0 : 0.0 ) ) : idx;\n    idx = y == 9.0 ? ( x <= 7.0 ? 58624.0 : ( x <= 15.0 ? 7.0 : 0.0 ) ) : idx;\n    idx = y == 8.0 ? ( x <= 7.0 ? 28240.0 : ( x <= 15.0 ? 87.0 : 0.0 ) ) : idx;\n    idx = y == 7.0 ? ( x <= 7.0 ? 44004.0 : ( x <= 15.0 ? 117.0 : 0.0 ) ) : idx;\n    idx = y == 6.0 ? ( x <= 7.0 ? 61433.0 : ( x <= 15.0 ? 494.0 : 0.0 ) ) : idx;\n    idx = y == 5.0 ? ( x <= 7.0 ? 61433.0 : ( x <= 15.0 ? 491.0 : 0.0 ) ) : idx;\n    idx = y == 4.0 ? ( x <= 7.0 ? 56313.0 : ( x <= 15.0 ? 1947.0 : 1024.0 ) ) : idx;\n    idx = y == 3.0 ? ( x <= 7.0 ? 63165.0 : ( x <= 15.0 ? 21867.0 : 6485.0 ) ) : idx;\n    idx = y == 2.0 ? ( x <= 7.0 ? 23540.0 : ( x <= 15.0 ? 57301.0 : 31671.0 ) ) : idx;\n    idx = y == 1.0 ? ( x <= 7.0 ? 65488.0 : ( x <= 15.0 ? 21851.0 : 5461.0 ) ) : idx;\n    idx = y == 0.0 ? ( x <= 7.0 ? 64848.0 : ( x <= 15.0 ? 39515.0 : 425.0 ) ) : idx;\n    \n    idx = SPRITE_DEC_4( x, idx );\n    idx = x >= 0.0 && x < 24.0 ? idx : 0.0;    \n    color = idx == 1.0 ? RGB( 0,   0,     0 ) : color;\n    color = idx == 2.0 ? RGB( 248, 56,    0 ) : color;\n    color = idx == 3.0 ? RGB( 240, 208, 176 ) : color;\n}\n\nvoid SpriteBillTorsoT( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n    \n    idx = y == 25.0 ? ( x <= 7.0 ? 0.0 : 16.0 ) : idx;\n    idx = y == 24.0 ? ( x <= 7.0 ? 0.0 : 116.0 ) : idx;\n    idx = y == 23.0 ? ( x <= 7.0 ? 0.0 : 105.0 ) : idx;\n    idx = y == 22.0 ? ( x <= 7.0 ? 0.0 : 116.0 ) : idx;\n    idx = y == 21.0 ? ( x <= 7.0 ? 0.0 : 356.0 ) : idx;\n    idx = y == 20.0 ? ( x <= 7.0 ? 0.0 : 1652.0 ) : idx;\n    idx = y == 19.0 ? ( x <= 7.0 ? 0.0 : 1652.0 ) : idx;\n    idx = y == 18.0 ? ( x <= 7.0 ? 0.0 : 1636.0 ) : idx;\n    idx = y == 17.0 ? ( x <= 7.0 ? 0.0 : 1397.0 ) : idx;\n    idx = y == 16.0 ? ( x <= 7.0 ? 16384.0 : 1654.0 ) : idx;\n    idx = y == 15.0 ? ( x <= 7.0 ? 16384.0 : 1382.0 ) : idx;\n    idx = y == 14.0 ? ( x <= 7.0 ? 16384.0 : 1655.0 ) : idx;\n    idx = y == 13.0 ? ( x <= 7.0 ? 16384.0 : 1399.0 ) : idx;\n    idx = y == 12.0 ? ( x <= 7.0 ? 36928.0 : 1654.0 ) : idx;\n    idx = y == 11.0 ? ( x <= 7.0 ? 57744.0 : 1639.0 ) : idx;\n    idx = y == 10.0 ? ( x <= 7.0 ? 55140.0 : 1398.0 ) : idx;\n    idx = y == 9.0 ? ( x <= 7.0 ? 40921.0 : 2038.0 ) : idx;\n    idx = y == 8.0 ? ( x <= 7.0 ? 40868.0 : 2038.0 ) : idx;\n    idx = y == 7.0 ? ( x <= 7.0 ? 26256.0 : 1957.0 ) : idx;\n    idx = y == 6.0 ? ( x <= 7.0 ? 39908.0 : 505.0 ) : idx;\n    idx = y == 5.0 ? ( x <= 7.0 ? 31737.0 : 510.0 ) : idx;\n    idx = y == 4.0 ? ( x <= 7.0 ? 65529.0 : 123.0 ) : idx;\n    idx = y == 3.0 ? ( x <= 7.0 ? 64116.0 : 127.0 ) : idx;\n    idx = y == 2.0 ? ( x <= 7.0 ? 21968.0 : 21.0 ) : idx;\n    idx = y == 1.0 ? ( x <= 7.0 ? 27600.0 : 0.0 ) : idx;\n    idx = y == 0.0 ? ( x <= 7.0 ? 44880.0 : 1.0 ) : idx;\n    \n    idx = SPRITE_DEC_4( x, idx );\n    idx = x >= 0.0 && x < 14.0 ? idx : 0.0;    \n    color = idx == 1.0 ? RGB( 0,   0,     0 ) : color;\n    color = idx == 2.0 ? RGB( 248, 56,    0 ) : color;\n    color = idx == 3.0 ? RGB( 240, 208, 176 ) : color;\n}\n\nvoid SpriteBillTorsoTR( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n    \n    idx = y == 15.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 16384.0 : 0.0 ) ) : idx;\n    idx = y == 14.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 54272.0 : 1.0 ) ) : idx;\n    idx = y == 13.0 ? ( x <= 7.0 ? 1280.0 : ( x <= 15.0 ? 47360.0 : 1.0 ) ) : idx;\n    idx = y == 12.0 ? ( x <= 7.0 ? 6736.0 : ( x <= 15.0 ? 26964.0 : 0.0 ) ) : idx;\n    idx = y == 11.0 ? ( x <= 7.0 ? 1445.0 : ( x <= 15.0 ? 7037.0 : 0.0 ) ) : idx;\n    idx = y == 10.0 ? ( x <= 7.0 ? 24405.0 : ( x <= 15.0 ? 1757.0 : 0.0 ) ) : idx;\n    idx = y == 9.0 ? ( x <= 7.0 ? 24485.0 : ( x <= 15.0 ? 6583.0 : 0.0 ) ) : idx;\n    idx = y == 8.0 ? ( x <= 7.0 ? 43348.0 : ( x <= 15.0 ? 6765.0 : 0.0 ) ) : idx;\n    idx = y == 7.0 ? ( x <= 7.0 ? 26356.0 : ( x <= 15.0 ? 6747.0 : 0.0 ) ) : idx;\n    idx = y == 6.0 ? ( x <= 7.0 ? 56317.0 : ( x <= 15.0 ? 1654.0 : 0.0 ) ) : idx;\n    idx = y == 5.0 ? ( x <= 7.0 ? 23549.0 : ( x <= 15.0 ? 1657.0 : 0.0 ) ) : idx;\n    idx = y == 4.0 ? ( x <= 7.0 ? 32509.0 : ( x <= 15.0 ? 509.0 : 0.0 ) ) : idx;\n    idx = y == 3.0 ? ( x <= 7.0 ? 49005.0 : ( x <= 15.0 ? 507.0 : 0.0 ) ) : idx;\n    idx = y == 2.0 ? ( x <= 7.0 ? 64953.0 : ( x <= 15.0 ? 95.0 : 0.0 ) ) : idx;\n    idx = y == 1.0 ? ( x <= 7.0 ? 63161.0 : ( x <= 15.0 ? 7.0 : 0.0 ) ) : idx;\n    idx = y == 0.0 ? ( x <= 7.0 ? 42724.0 : ( x <= 15.0 ? 1.0 : 0.0 ) ) : idx;\n    \n    idx = SPRITE_DEC_4( x, idx );\n    idx = x >= 0.0 && x < 18.0 ? idx : 0.0;    \n    color = idx == 1.0 ? RGB( 0,   0,     0 ) : color;\n    color = idx == 2.0 ? RGB( 248, 56,    0 ) : color;\n    color = idx == 3.0 ? RGB( 240, 208, 176 ) : color;\n}\n\nvoid SpriteBillTorsoBR( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n    \n    idx = y == 21.0 ? ( x <= 7.0 ? 16384.0 : ( x <= 15.0 ? 1.0 : 0.0 ) ) : idx;\n    idx = y == 20.0 ? ( x <= 7.0 ? 38208.0 : ( x <= 15.0 ? 6.0 : 0.0 ) ) : idx;\n    idx = y == 19.0 ? ( x <= 7.0 ? 25680.0 : ( x <= 15.0 ? 26.0 : 0.0 ) ) : idx;\n    idx = y == 18.0 ? ( x <= 7.0 ? 59648.0 : ( x <= 15.0 ? 5.0 : 0.0 ) ) : idx;\n    idx = y == 17.0 ? ( x <= 7.0 ? 59984.0 : ( x <= 15.0 ? 7.0 : 0.0 ) ) : idx;\n    idx = y == 16.0 ? ( x <= 7.0 ? 63460.0 : ( x <= 15.0 ? 1.0 : 0.0 ) ) : idx;\n    idx = y == 15.0 ? ( x <= 7.0 ? 22521.0 : ( x <= 15.0 ? 21.0 : 0.0 ) ) : idx;\n    idx = y == 14.0 ? ( x <= 7.0 ? 49145.0 : ( x <= 15.0 ? 118.0 : 0.0 ) ) : idx;\n    idx = y == 13.0 ? ( x <= 7.0 ? 64505.0 : ( x <= 15.0 ? 474.0 : 0.0 ) ) : idx;\n    idx = y == 12.0 ? ( x <= 7.0 ? 64505.0 : ( x <= 15.0 ? 1946.0 : 0.0 ) ) : idx;\n    idx = y == 11.0 ? ( x <= 7.0 ? 63396.0 : ( x <= 15.0 ? 1894.0 : 0.0 ) ) : idx;\n    idx = y == 10.0 ? ( x <= 7.0 ? 39908.0 : ( x <= 15.0 ? 7653.0 : 0.0 ) ) : idx;\n    idx = y == 9.0 ? ( x <= 7.0 ? 32720.0 : ( x <= 15.0 ? 1951.0 : 0.0 ) ) : idx;\n    idx = y == 8.0 ? ( x <= 7.0 ? 49104.0 : ( x <= 15.0 ? 6783.0 : 0.0 ) ) : idx;\n    idx = y == 7.0 ? ( x <= 7.0 ? 60736.0 : ( x <= 15.0 ? 30063.0 : 0.0 ) ) : idx;\n    idx = y == 6.0 ? ( x <= 7.0 ? 37888.0 : ( x <= 15.0 ? 58970.0 : 1.0 ) ) : idx;\n    idx = y == 5.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 39504.0 : 22.0 ) ) : idx;\n    idx = y == 4.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 26896.0 : 109.0 ) ) : idx;\n    idx = y == 3.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 41984.0 : 105.0 ) ) : idx;\n    idx = y == 2.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 36864.0 : 485.0 ) ) : idx;\n    idx = y == 1.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 16384.0 : 400.0 ) ) : idx;\n    idx = y == 0.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 0.0 : 64.0 ) ) : idx;\n    \n    idx = SPRITE_DEC_4( x, idx );\n    idx = x >= 0.0 && x < 21.0 ? idx : 0.0;    \n    color = idx == 1.0 ? RGB( 0,   0,     0 ) : color;\n    color = idx == 2.0 ? RGB( 248, 56,    0 ) : color;\n    color = idx == 3.0 ? RGB( 240, 208, 176 ) : color;\n}\n\nvoid SpriteBillLegs( inout vec3 color, float x, float y, float frame )\n{\n    \/\/ lower body\n    float idx = 0.0;\n    \n    if ( frame == 0.0 )\n    {\n        x -= 2.0;\n        idx = y == 19.0 ? ( x <= 7.0 ? 62800.0 : 1.0 ) : idx;\n        idx = y == 18.0 ? ( x <= 7.0 ? 43664.0 : 1.0 ) : idx;\n        idx = y == 17.0 ? ( x <= 7.0 ? 43664.0 : 1.0 ) : idx;\n        idx = y == 16.0 ? ( x <= 7.0 ? 64080.0 : 1.0 ) : idx;\n        idx = y == 15.0 ? ( x <= 7.0 ? 42320.0 : 6.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 43328.0 : 27.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 42560.0 : 26.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 22848.0 : 110.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 38144.0 : 26.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 39168.0 : 26.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 42560.0 : 7.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 43344.0 : 6.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 63892.0 : 1.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 27241.0 : 0.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 32357.0 : 0.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 6756.0 : 0.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 27216.0 : 0.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 43584.0 : 5.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 43584.0 : 26.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 21824.0 : 21.0 ) : idx;\n        idx = x >= 0.0 && x < 12.0 ? idx : 0.0;\n    }\n    else if ( frame == 1.0 )\n    {\n        idx = y == 19.0 ? ( x <= 7.0 ? 20480.0 : ( x <= 15.0 ? 341.0 : 0.0 ) ) : idx;\n        idx = y == 18.0 ? ( x <= 7.0 ? 36864.0 : ( x <= 15.0 ? 1466.0 : 0.0 ) ) : idx;\n        idx = y == 17.0 ? ( x <= 7.0 ? 36864.0 : ( x <= 15.0 ? 6570.0 : 0.0 ) ) : idx;\n        idx = y == 16.0 ? ( x <= 7.0 ? 16384.0 : ( x <= 15.0 ? 27246.0 : 0.0 ) ) : idx;\n        idx = y == 15.0 ? ( x <= 7.0 ? 16384.0 : ( x <= 15.0 ? 43626.0 : 1.0 ) ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 36864.0 : ( x <= 15.0 ? 43374.0 : 6.0 ) ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 36864.0 : ( x <= 15.0 ? 42090.0 : 6.0 ) ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 20480.0 : ( x <= 15.0 ? 42267.0 : 1.0 ) ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 41984.0 : ( x <= 15.0 ? 43610.0 : 1.0 ) ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 59648.0 : ( x <= 15.0 ? 27206.0 : 0.0 ) ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 43264.0 : ( x <= 15.0 ? 6721.0 : 0.0 ) ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 28224.0 : ( x <= 15.0 ? 1616.0 : 0.0 ) ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 6800.0 : ( x <= 15.0 ? 1700.0 : 0.0 ) ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 2000.0 : ( x <= 15.0 ? 425.0 : 0.0 ) ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 420.0 : ( x <= 15.0 ? 420.0 : 0.0 ) ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 425.0 : ( x <= 15.0 ? 1680.0 : 0.0 ) ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 1961.0 : ( x <= 15.0 ? 6720.0 : 0.0 ) ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 5796.0 : ( x <= 15.0 ? 1280.0 : 0.0 ) ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 31376.0 : 0.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 21824.0 : 0.0 ) : idx;\n        idx = x >= 0.0 && x < 18.0 ? idx : 0.0;\n    }\n    else\n    {   \n        idx = y == 18.0 ? ( x <= 7.0 ? 37888.0 : ( x <= 15.0 ? 422.0 : 0.0 ) ) : idx;\n        idx = y == 17.0 ? ( x <= 7.0 ? 36864.0 : ( x <= 15.0 ? 342.0 : 0.0 ) ) : idx;\n        idx = y == 16.0 ? ( x <= 7.0 ? 36880.0 : ( x <= 15.0 ? 362.0 : 0.0 ) ) : idx;\n        idx = y == 15.0 ? ( x <= 7.0 ? 21860.0 : ( x <= 15.0 ? 489.0 : 0.0 ) ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 43428.0 : ( x <= 15.0 ? 421.0 : 0.0 ) ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 44457.0 : ( x <= 15.0 ? 1962.0 : 0.0 ) ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 54377.0 : ( x <= 15.0 ? 1710.0 : 0.0 ) ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 16489.0 : ( x <= 15.0 ? 1765.0 : 0.0 ) ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 25.0 : ( x <= 15.0 ? 6480.0 : 0.0 ) ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 25.0 : ( x <= 15.0 ? 27200.0 : 0.0 ) ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 25.0 : ( x <= 15.0 ? 26880.0 : 0.0 ) ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 4.0 : ( x <= 15.0 ? 30976.0 : 0.0 ) ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 43264.0 : 1.0 ) ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 41984.0 : 1.0 ) ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 21504.0 : 0.0 ) ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 41984.0 : 5.0 ) ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 41984.0 : 90.0 ) ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 41984.0 : 426.0 ) ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 20480.0 : 85.0 ) ) : idx;\n        idx = x >= 0.0 && x < 22.0 ? idx : 0.0;\n    }\n    \n    idx = SPRITE_DEC_4( x, idx );\n    \n\n    color = idx == 1.0 ? RGB( 0,   0,   0   ) : color;\n    color = idx == 2.0 ? RGB( 0,   88,  248 ) : color;\n    color = idx == 3.0 ? RGB( 255, 224, 168 ) : color;   \n}\n\nvoid SpriteBillProne( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n    \n    idx = y == 16.0 ? ( x <= 7.0 ? 64.0 : 0.0 ) : idx;\n    idx = y == 15.0 ? ( x <= 7.0 ? 400.0 : 0.0 ) : idx;\n    idx = y == 14.0 ? ( x <= 7.0 ? 1940.0 : 0.0 ) : idx;\n    idx = y == 13.0 ? ( x <= 7.0 ? 6745.0 : ( x <= 15.0 ? 0.0 : ( x <= 23.0 ? 84.0 : 0.0 ) ) ) : idx;\n    idx = y == 12.0 ? ( x <= 7.0 ? 27044.0 : ( x <= 15.0 ? 0.0 : ( x <= 23.0 ? 425.0 : 0.0 ) ) ) : idx;\n    idx = y == 11.0 ? ( x <= 7.0 ? 27024.0 : ( x <= 15.0 ? 0.0 : ( x <= 23.0 ? 341.0 : 1280.0 ) ) ) : idx;\n    idx = y == 10.0 ? ( x <= 7.0 ? 7744.0 : ( x <= 15.0 ? 20480.0 : ( x <= 23.0 ? 22005.0 : 6485.0 ) ) ) : idx;\n    idx = y == 9.0 ? ( x <= 7.0 ? 6800.0 : ( x <= 15.0 ? 41984.0 : ( x <= 23.0 ? 62966.0 : 31710.0 ) ) ) : idx;\n    idx = y == 8.0 ? ( x <= 7.0 ? 18128.0 : ( x <= 15.0 ? 64773.0 : ( x <= 23.0 ? 38747.0 : 27306.0 ) ) ) : idx;\n    idx = y == 7.0 ? ( x <= 7.0 ? 38564.0 : ( x <= 15.0 ? 65370.0 : ( x <= 23.0 ? 65435.0 : 5461.0 ) ) ) : idx;\n    idx = y == 6.0 ? ( x <= 7.0 ? 59833.0 : ( x <= 15.0 ? 65390.0 : ( x <= 23.0 ? 49051.0 : 501.0 ) ) ) : idx;\n    idx = y == 5.0 ? ( x <= 7.0 ? 60009.0 : ( x <= 15.0 ? 48602.0 : ( x <= 23.0 ? 44774.0 : 101.0 ) ) ) : idx;\n    idx = y == 4.0 ? ( x <= 7.0 ? 44718.0 : ( x <= 15.0 ? 64986.0 : ( x <= 23.0 ? 22267.0 : 126.0 ) ) ) : idx;\n    idx = y == 3.0 ? ( x <= 7.0 ? 43753.0 : ( x <= 15.0 ? 63125.0 : ( x <= 23.0 ? 43454.0 : 31.0 ) ) ) : idx;\n    idx = y == 2.0 ? ( x <= 7.0 ? 22185.0 : ( x <= 15.0 ? 62784.0 : ( x <= 23.0 ? 58495.0 : 5.0 ) ) ) : idx;\n    idx = y == 1.0 ? ( x <= 7.0 ? 340.0 : ( x <= 15.0 ? 54272.0 : ( x <= 23.0 ? 20511.0 : 0.0 ) ) ) : idx;\n    idx = y == 0.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 16384.0 : ( x <= 23.0 ? 5.0 : 0.0 ) ) ) : idx;\n    \n    idx = SPRITE_DEC_4( x, idx );\n    \n    idx = x >= 0.0 && x < 32.0 ? idx : 0.0;\n    color = idx == 1.0 ? RGB( 0,   0,   0   ) : color;\n    color = idx == 2.0 ? x < 15.0 ? RGB( 0,   88,  248 ) : RGB( 248, 56,  0   ) : color;\n    color = idx == 3.0 ? x < 15.0 ? RGB( 255, 224, 168 ) : RGB( 240, 208, 176 ) : color;   \n}\n\nvoid SpriteBillJump( inout vec3 color, float x, float y, float frame )\n{\n    float idx = 0.0;\n    bool colorA;\n    \n    if ( frame == 0.0 )\n    {   \n        colorA = x > 10.0;\n        idx = y == 15.0 ? ( x <= 7.0 ? 16384.0 : ( x <= 15.0 ? 5.0 : 0.0 ) ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 53312.0 : ( x <= 15.0 ? 95.0 : 0.0 ) ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 53648.0 : ( x <= 15.0 ? 415.0 : 16.0 ) ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 25956.0 : ( x <= 15.0 ? 1947.0 : 100.0 ) ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 38745.0 : ( x <= 15.0 ? 7787.0 : 109.0 ) ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 24549.0 : ( x <= 15.0 ? 27247.0 : 107.0 ) ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 38825.0 : ( x <= 15.0 ? 43375.0 : 26.0 ) ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 59748.0 : ( x <= 15.0 ? 38527.0 : 26.0 ) ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 65428.0 : ( x <= 15.0 ? 27295.0 : 5.0 ) ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 49124.0 : ( x <= 15.0 ? 27287.0 : 0.0 ) ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 49120.0 : ( x <= 15.0 ? 43737.0 : 1.0 ) ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 27600.0 : ( x <= 15.0 ? 43882.0 : 1.0 ) ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 48960.0 : ( x <= 15.0 ? 27247.0 : 0.0 ) ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 64768.0 : ( x <= 15.0 ? 27263.0 : 0.0 ) ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 54272.0 : ( x <= 15.0 ? 5759.0 : 0.0 ) ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 16384.0 : ( x <= 15.0 ? 341.0 : 0.0 ) ) : idx;\n        idx = x >= 0.0 && x < 20.0 ? idx : 0.0;\n    }\n    else\n    {\n        colorA = y < 9.0;\n        idx = y == 19.0 ? ( x <= 7.0 ? 0.0 : 84.0 ) : idx;\n        idx = y == 18.0 ? ( x <= 7.0 ? 20480.0 : 409.0 ) : idx;\n        idx = y == 17.0 ? ( x <= 7.0 ? 26880.0 : 1642.0 ) : idx;\n        idx = y == 16.0 ? ( x <= 7.0 ? 48960.0 : 6521.0 ) : idx;\n        idx = y == 15.0 ? ( x <= 7.0 ? 65488.0 : 1533.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 65268.0 : 374.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 65268.0 : 5718.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 59837.0 : 32155.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 63229.0 : 32767.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 56061.0 : 32447.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 22205.0 : 5547.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 44373.0 : 6741.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 43945.0 : 1958.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 43684.0 : 489.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 43684.0 : 105.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 23120.0 : 26.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 17664.0 : 122.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 16384.0 : 490.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 0.0 : 1701.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 0.0 : 336.0 ) : idx;\n        idx = x >= 0.0 && x < 16.0 ? idx : 0.0;\n    }\n    \n    idx = SPRITE_DEC_4( x, idx );\n    \n    color = idx == 1.0 ? RGB( 0,   0,   0   ) : color;\n    color = idx == 2.0 ? colorA ? RGB( 0,   88,  248 ) : RGB( 248, 56,  0   ) : color;\n    color = idx == 3.0 ? colorA ? RGB( 255, 224, 168 ) : RGB( 240, 208, 176 ) : color;   \n}\n\nvoid SpriteWaterCircle( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n    \n    idx = y == 6.0 ? ( x <= 7.0 ? 14336.0 : 44.0 ) : idx;\n    idx = y == 5.0 ? ( x <= 7.0 ? 49360.0 : 1795.0 ) : idx;\n    idx = y == 4.0 ? ( x <= 7.0 ? 31874.0 : 33341.0 ) : idx;\n    idx = y == 3.0 ? ( x <= 7.0 ? 819.0 : 52416.0 ) : idx;\n    idx = y == 2.0 ? ( x <= 7.0 ? 47112.0 : 8238.0 ) : idx;\n    idx = y == 1.0 ? ( x <= 7.0 ? 4144.0 : 3076.0 ) : idx;\n    idx = y == 0.0 ? ( x <= 7.0 ? 36352.0 : 178.0 ) : idx;\n\n    idx = SPRITE_DEC_4( x, idx );\n    idx = x >= 0.0 && x < 16.0 ? idx : 0.0;\n    \n    color = idx == 1.0 ? RGB( 0,    0,   0   ) : color;\n    color = idx == 2.0 ? RGB( 248,  56,  0   ) : color;\n    color = idx == 3.0 ? RGB( 240,  208, 176 ) : color;\n}\n\nvoid DrawTurret( inout vec3 color, vec4 turret, float worldX, float worldY )\n{\n    SpriteTurretBase( color, worldX - turret.x + TURRET_SIZE.x * 0.5, worldY - turret.y + TURRET_SIZE.y * 0.5 );\n    \n    \/\/ left \n    float frame     = 0.0;\n    float turretX   = worldX - turret.x;\n    float turretY   = worldY - turret.y;\n\n    if ( turret.z == 0.0 )\n    {\n        frame = 0.0;\n        turretX += 14.0;\n        turretY += 7.0;\n    }\n    else if ( turret.z == 1.0 )\n    {\n        frame = 1.0;\n        turretX += 13.0;\n        turretY += 7.0;\n    }\n    else if ( turret.z == 2.0 )\n    {\n        frame = 2.0;\n        turretX += 8.0;\n        turretY += 3.0;\n        Swap( turretX, turretY );\n        turretX = 15.0 - turretX;\n    }     \n    else if ( turret.z == 3.0 )\n    {\n        frame = 0.0;\n        turretX += 15.0;\n        turretY += 2.0;\n        Swap( turretX, turretY );\n        turretX = 15.0 - turretX;\n        turretY = 21.0 - turretY;\n    }\n    else if ( turret.z == 4.0 )\n    {\n        frame = 2.0;\n        turretX += 14.0;\n        turretY += 3.0;\n        Swap( turretX, turretY );\n        turretX = 15.0 - turretX;\n        turretY = 21.0 - turretY;\n    }\n    else if ( turret.z == 5.0 )\n    {\n        frame = 1.0;\n        turretX += 4.0;\n        turretY += 7.0;\n        turretX = 15.0 - turretX;        \n    }    \n    else if ( turret.z == 6.0 )\n    {\n        frame = 0.0;\n        turretX += 9.0;\n        turretY += 7.0;\n        turretX = 21.0 - turretX;       \n    }     \n    else if ( turret.z == 7.0 )\n    {\n        frame = 2.0;\n        turretX += 10.0;\n        turretY += 7.0;\n        turretX = 21.0 - turretX;       \n    }    \n    else if ( turret.z == 8.0 )\n    {\n        frame = 1.0;\n        turretX += 8.0;\n        turretY += 12.0;\n        Swap( turretX, turretY );       \n    }  \n    else if ( turret.z == 9.0 )\n    {\n        frame = 0.0;\n        turretX += 15.0;\n        turretY += 13.0;\n        Swap( turretX, turretY );\n        turretY = 21.0 - turretY;        \n    }          \n    else if ( turret.z == 10.0 )\n    {\n        frame = 1.0;\n        turretX += 15.0;\n        turretY += 12.0;\n        Swap( turretX, turretY );\n        turretY = 21.0 - turretY;        \n    }\n    else\n    {\n        frame = 2.0;\n        turretX += 13.0;\n        turretY += 8.0;        \n    }      \n\n    SpriteTurret( color, turretX, turretY, frame );\n}\n\nvoid DrawSoldier( inout vec3 color, vec4 soldier, vec4 soldierState, float worldX, float worldY )\n{\n    float soldierX = worldX - soldier.x + SOLDIER_SIZE.x * 0.5;\n    float soldierY = worldY - soldier.y;\n    soldierX = soldier.z < 0.0 ? SOLDIER_SIZE.x - soldierX : soldierX;\n    SpriteSoldier( color, soldierX, soldierY, soldierState.y );        \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ we want 224x192 (overscan) and we want multiples of pixel size\n    float resMultX      = floor( iResolution.x \/ NES_RES_X );\n    float resMultY      = floor( iResolution.y \/ NES_RES_Y );\n    float resRcp        = 1.0 \/ max( min( resMultX, resMultY ), 1.0 );\n    float screenWidth   = floor( iResolution.x * resRcp );\n    float screenHeight  = floor( iResolution.y * resRcp );\n    float pixelX        = floor( fragCoord.x * resRcp );\n    float pixelY        = floor( fragCoord.y * resRcp );  \n    \n    vec4 player         = LoadValue( txPlayer );\n    vec4 playerState    = LoadValue( txPlayerState );\n    vec4 playerDir      = LoadValue( txPlayerDir );\n    vec4 camera         = LoadValue( txCamera );\n    vec4 soldier0       = LoadValue( txSoldier0 );\n    vec4 soldier1       = LoadValue( txSoldier1 );\n    vec4 soldier2       = LoadValue( txSoldier2 );\n    vec4 soldier0State  = LoadValue( txSoldier0State );\n    vec4 soldier1State  = LoadValue( txSoldier1State );\n    vec4 soldier2State  = LoadValue( txSoldier2State );\n    vec4 sniper         = LoadValue( txSniper );\n    vec4 turret0        = LoadValue( txTurret0 );\n    vec4 turret1        = LoadValue( txTurret1 );\n\n    float worldX        = pixelX + camera.x;\n    float worldY        = pixelY - 8.0;\n    \n    vec2 screenUV = fragCoord.xy \/ iResolution.xy;\n    vec3 color = texture( iChannel1, screenUV ).xyz;\n            \n    float sniperX = worldX - sniper.x + SNIPER_SIZE.x * 0.5;\n    float sniperY = worldY - sniper.y;\n    sniperX = sniper.z < 0.0 ? 24.0 - sniperX : sniperX;\n    SpriteSniper( color, sniperX, sniperY );\n    \n    DrawTurret( color, turret0, worldX, worldY );\n    DrawTurret( color, turret1, worldX, worldY );\n    DrawSoldier( color, soldier0, soldier0State, worldX, worldY );\n    DrawSoldier( color, soldier1, soldier1State, worldX, worldY );\n    DrawSoldier( color, soldier2, soldier2State, worldX, worldY );\n   \n    \/\/ draw player\n    float billX = worldX - player.x;\n    float billY = worldY - player.y;\n    billX = playerDir.w > 0.0 && fract( 3.0 * iTime ) < 0.5 ? 100.0 : billX;\n    if ( playerState.x == STATE_PRONE )\n    {\n        billX += BILL_PRONE_SIZE.x * 0.5;\n        billX = playerDir.z < 0.0 ? BILL_PRONE_SIZE.x - billX : billX;\n        SpriteBillProne( color, billX, billY );\n    }\n    else if ( playerState.x == STATE_JUMP )\n    {\n        billX += BILL_JUMP_SIZE.x * 0.5;\n        billX = playerDir.z < 0.0 ? BILL_JUMP_SIZE.x - billX : billX;\n        SpriteBillJump( color, billX, billY, playerState.y );\n    }\n    else\n    {           \n        billX += BILL_RUN_SIZE.x * 0.5;\n        billX = playerDir.z < 0.0 ? BILL_RUN_SIZE.x - billX : billX;        \n\n        if ( playerState.x == STATE_WATER || playerState.x == STATE_UNDER_WATER )\n        {\n            SpriteWaterCircle( color, billX, billY - 4.0 );\n        }\n        \n        if ( playerState.x != STATE_WATER && playerState.x != STATE_UNDER_WATER )\n        {\n            SpriteBillLegs( color, billX, billY, playerState.y );            \n        }\n\n        float torsoX = billX + ( playerState.y == 0.0 ? 0.0 : -2.0 );\n        float torsoY = billY + ( playerState.x == STATE_WATER ? -8.0 : -20.0 );\n        if ( playerState.x != STATE_UNDER_WATER )\n        {\n            if ( playerDir.y > 0.0 && abs( playerDir.x ) > 0.0 )\n            {\n                SpriteBillTorsoTR( color, torsoX - 2.0, torsoY + 1.0 );            \n            }\n            else if ( playerDir.y > 0.0 )        \n            {\n                SpriteBillTorsoT( color, torsoX, torsoY + 1.0 );\n            }\n            else if ( playerDir.y < 0.0 )\n            {\n                SpriteBillTorsoBR( color, torsoX, torsoY + 7.0 );\n            }\n            else\n            {\n                SpriteBillTorsoR( color, torsoX, torsoY + 1.0 );\n            }\n        }\n    }\n\n    fragColor = vec4( color, 1.0 );\n}","name":"Buf C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\/\/ UI and some foreground stuff\n\n#define SPRITE_DEC_2( x, i ) mod( floor( i \/ pow( 2.0, mod( x, 24.0 ) ) ), 2.0 )\n#define SPRITE_DEC_3( x, i ) mod( floor( i \/ pow( 4.0, mod( x, 11.0 ) ) ), 4.0 )\n#define SPRITE_DEC_4( x, i ) mod( floor( i \/ pow( 4.0, mod( x, 8.0 ) ) ), 4.0 )\n#define RGB( r, g, b ) vec3( float( r ) \/ 255.0, float( g ) \/ 255.0, float( b ) \/ 255.0 )\n\nconst float NES_RES_X               = 224.0;\nconst float NES_RES_Y               = 192.0;\nconst float GAME_STATE_TITLE\t\t= 0.0;\nconst float GAME_STATE_LEVEL\t\t= 1.0;\nconst float GAME_STATE_LEVEL_DIE\t= 2.0;\nconst float GAME_STATE_LEVEL_WIN\t= 3.0;\nconst float GAME_STATE_GAME_OVER\t= 4.0;\nconst float GAME_STATE_VICTORY\t\t= 5.0;\nconst float WEAPON_RIFLE        \t= 0.0;\nconst vec2  BULLET_SIZE         \t= vec2( 3.0,  3.0  );\nconst vec2  POWER_UP_SIZE       \t= vec2( 24.0, 14.0 );\nconst float UI_VICTORY_TIME\t\t\t= 300.0;\n\n\/\/ storage\nconst vec2 txPlayer \t\t\t= vec2( 0.0, 0.0 ); \t\/\/ xy - pos, z - jump start, w - jump dir\nconst vec2 txPlayerState\t\t= vec2( 1.0, 0.0 ); \t\/\/ x - state, y - frame, z - jump tick, w - lifes\nconst vec2 txPlayerDir\t\t\t= vec2( 2.0, 0.0 ); \t\/\/ xy - dir, z - flip, w - immortality\nconst vec2 txPlayerWeapon\t\t= vec2( 3.0, 0.0 ); \t\/\/ x - weapon, y - weapon cooldown, z - weapon fire rate, w - weapon bullet num\nconst vec2 txCamera \t\t\t= vec2( 4.0, 0.0 ); \t\/\/ x - cam offset, y - spawn counter, z - soldier spawn counter\nconst vec2 txSoldier0 \t\t\t= vec2( 5.0, 0.0 ); \t\/\/ xy - pos, z - flip\nconst vec2 txSoldier1 \t\t\t= vec2( 5.0, 1.0 ); \t\/\/ xy - pos, z - flip\nconst vec2 txSoldier2 \t\t\t= vec2( 5.0, 2.0 ); \t\/\/ xy - pos, z - flip\nconst vec2 txSoldier0State \t\t= vec2( 6.0, 0.0 ); \t\/\/ x - state, y - frame, z - jump tick\nconst vec2 txSoldier1State \t\t= vec2( 6.0, 1.0 ); \t\/\/ x - state, y - frame, z - jump tick\nconst vec2 txSoldier2State \t\t= vec2( 6.0, 2.0 ); \t\/\/ x - state, y - frame, z - jump tick\nconst vec2 txSniper\t \t\t\t= vec2( 7.0, 0.0 ); \t\/\/ xy - pos, z - flip, w - weapon cooldown\nconst vec2 txPlayerBullet0 \t\t= vec2( 8.0, 0.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txPlayerBullet1 \t\t= vec2( 8.0, 1.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txPlayerBullet2 \t\t= vec2( 8.0, 2.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txPlayerBullet3 \t\t= vec2( 8.0, 3.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txPlayerBullet4 \t\t= vec2( 8.0, 4.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txPlayerBullet5 \t\t= vec2( 8.0, 5.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txEnemyBullet0 \t\t= vec2( 9.0, 0.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txEnemyBullet1 \t\t= vec2( 9.0, 1.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txEnemyBullet2 \t\t= vec2( 9.0, 2.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txEnemyBullet3 \t\t= vec2( 9.0, 3.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txExplosion \t\t\t= vec2( 10.0, 0.0 ); \t\/\/ xy - pos, z - frame\nconst vec2 txHit \t\t\t\t= vec2( 11.0, 0.0 ); \t\/\/ xy - pos, z - frame\nconst vec2 txTurret0\t\t\t= vec2( 12.0, 0.0 ); \t\/\/ xy - pos, z - angle\nconst vec2 txTurret1\t\t\t= vec2( 12.0, 1.0 ); \t\/\/ xy - pos, z - angle\nconst vec2 txTurret0State\t\t= vec2( 13.0, 0.0 ); \t\/\/ x - HP, y - weapon cooldown\nconst vec2 txTurret1State\t\t= vec2( 13.0, 1.0 ); \t\/\/ x - HP, y - weapon cooldown\nconst vec2 txPowerUp\t\t\t= vec2( 14.0, 0.0 ); \t\/\/ xy - pos, z - frame\nconst vec2 txPowerUpState\t\t= vec2( 15.0, 0.0 ); \t\/\/ x - state, y - initial height, z - jump tick\nconst vec2 txBossCore\t\t\t= vec2( 16.0, 0.0 ); \t\/\/ xy - pos, z - HP\nconst vec2 txBossCannon0\t\t= vec2( 17.0, 0.0 ); \t\/\/ xy - pos, z - cooldown, w - HP\nconst vec2 txBossCannon1\t\t= vec2( 17.0, 1.0 ); \t\/\/ xy - pos, z - cooldown, w - HP\nconst vec2 txBossBullet0\t\t= vec2( 18.0, 0.0 ); \t\/\/ xy - pos, zw - velocity\nconst vec2 txBossBullet1\t\t= vec2( 18.0, 1.0 ); \t\/\/ xy - pos, zw - velocity\nconst vec2 txGameState\t\t\t= vec2( 19.0, 0.0 ); \t\/\/ x - state, y - state tick\nconst vec2 txBridge\t\t\t\t= vec2( 20.0, 0.0 ); \t\/\/ x - draw start, y - explode tick\n\nvec4 LoadValue( vec2 tx )\n{\n    return floor( texture( iChannel0, ( tx + 0.5 ) \/ iChannelResolution[ 0 ].xy ) );\n}\n\nfloat Rand( vec2 co )\n{\n    return fract( sin( dot( co.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\n}\n\nvoid SpritePowerBullet( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n    \n    idx = y == 4.0 ? ( x <= 7.0 ? 84.0 : 0.0 ) : idx;\n    idx = y == 3.0 ? ( x <= 7.0 ? 349.0 : 0.0 ) : idx;\n    idx = y == 2.0 ? ( x <= 7.0 ? 405.0 : 0.0 ) : idx;\n    idx = y == 1.0 ? ( x <= 7.0 ? 361.0 : 0.0 ) : idx;\n    idx = y == 0.0 ? ( x <= 7.0 ? 84.0 : 0.0 ) : idx;\n\n    idx = SPRITE_DEC_4( x, idx );\n    idx = x >= 0.0 && x < 5.0 ? idx : 0.0;\n    \n    color = idx == 1.0 ? RGB( 255,  46,   0 ) : color;\n    color = idx == 2.0 ? RGB( 255, 112,  78 ) : color;\n    color = idx == 3.0 ? RGB( 255, 255, 255 ) : color;\n}\n\nvoid SpriteBullet( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n    \n    idx = y == 2.0 ? ( x <= 7.0 ? 4.0 : 0.0 ) : idx;\n    idx = y == 1.0 ? ( x <= 7.0 ? 21.0 : 0.0 ) : idx;\n    idx = y == 0.0 ? ( x <= 7.0 ? 4.0 : 0.0 ) : idx;\n\n    idx = SPRITE_DEC_4( x, idx );\n    idx = x >= 0.0 && x < 3.0 ? idx : 0.0;\n    \n    color = idx == 1.0 ? RGB( 255, 255, 255 ) : color;\n}\n\nvoid SpriteHit( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;    \n    \n    idx = y == 6.0 ? 608.0 : idx;\n    idx = y == 5.0 ? 2056.0 : idx;\n    idx = y == 4.0 ? 8194.0 : idx;\n    idx = y == 3.0 ? 4097.0 : idx;\n    idx = y == 2.0 ? 8194.0 : idx;\n    idx = y == 1.0 ? 2056.0 : idx;\n    idx = y == 0.0 ? 608.0 : idx;\n\n    idx = SPRITE_DEC_3( x, idx );\n    idx = x >= 0.0 && x < 7.0 ? idx : 0.0;\n    \n    color = idx == 1.0 ? RGB( 228,  68,  52 ) : color;\n    color = idx == 2.0 ? RGB( 255, 140, 124 ) : color;\n}\n\nvoid SpriteExplosion( inout vec3 color, float x, float y, float frame )\n{\n    float idx = 0.0;\n    \n    x = abs( x );\n    y = abs( y );\n\n    if ( frame == 0.0 )\n    {\n        idx = y == 11.0 ? ( x <= 7.0 ? 21.0 : 0.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 342.0 : 0.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 5541.0 : 0.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 26990.0 : 0.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 32182.0 : ( x <= 15.0 ? 1.0 : 0.0 ) ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 39595.0 : ( x <= 15.0 ? 5.0 : 0.0 ) ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 64183.0 : ( x <= 15.0 ? 6.0 : 0.0 ) ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 44783.0 : ( x <= 15.0 ? 23.0 : 0.0 ) ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 48127.0 : ( x <= 15.0 ? 22.0 : 0.0 ) ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 44799.0 : ( x <= 15.0 ? 103.0 : 0.0 ) ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 64511.0 : ( x <= 15.0 ? 90.0 : 0.0 ) ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 49151.0 : ( x <= 15.0 ? 90.0 : 0.0 ) ) : idx;\n    }\n    else if ( frame == 1.0 )\n    {\n        idx = y == 13.0 ? ( x <= 7.0 ? 25.0 : 0.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 1705.0 : 0.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 23295.0 : 0.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 32682.0 : ( x <= 15.0 ? 5.0 : 0.0 ) ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 65232.0 : ( x <= 15.0 ? 22.0 : 0.0 ) ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 58384.0 : ( x <= 15.0 ? 27.0 : 0.0 ) ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 57600.0 : ( x <= 15.0 ? 107.0 : 0.0 ) ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 41216.0 : ( x <= 15.0 ? 110.0 : 0.0 ) ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 430.0 : 0.0 ) ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 32768.0 : ( x <= 15.0 ? 430.0 : 0.0 ) ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 16384.0 : ( x <= 15.0 ? 442.0 : 0.0 ) ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 4096.0 : ( x <= 15.0 ? 1462.0 : 0.0 ) ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 1520.0 : 0.0 ) ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 1460.0 : 0.0 ) ) : idx;\n    }\n    else\n    {   \n        idx = y == 15.0 ? ( x <= 7.0 ? 68.0 : 0.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 1280.0 : 0.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 16384.0 : 0.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 5.0 : 0.0 ) ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 16.0 : 0.0 ) ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 64.0 : 0.0 ) ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 256.0 : 0.0 ) ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 4096.0 : 0.0 ) ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 16384.0 : 0.0 ) ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 16384.0 : 0.0 ) ) : idx;\n        \n    }\n\n    idx = SPRITE_DEC_4( x, idx );\n    idx = x >= 0.0 && x < 12.0 + frame * 2.0 ? idx : 0.0;\n    \n    color = idx == 1.0 ? RGB( 228,  68,  52 ) : color;\n    color = idx == 2.0 ? RGB( 255, 140, 124 ) : color;\n    color = idx == 3.0 ? RGB( 255, 255, 255 ) : color;\n}\n\nvoid SpritePowerUp( inout vec3 color, float x, float y, float frame )\n{\n    float idx = 0.0;    \n    \n    if ( frame == 0.0 )\n    {\n        idx = y == 13.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 5460.0 : 0.0 ) ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 16384.0 : ( x <= 15.0 ? 32765.0 : 1.0 ) ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 54272.0 : ( x <= 15.0 ? 54615.0 : 23.0 ) ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 23808.0 : ( x <= 15.0 ? 31421.0 : 117.0 ) ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 55104.0 : ( x <= 15.0 ? 65215.0 : 471.0 ) ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 40276.0 : ( x <= 15.0 ? 43690.0 : 5494.0 ) ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 57193.0 : ( x <= 15.0 ? 43690.0 : 27127.0 ) ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 57193.0 : ( x <= 15.0 ? 64175.0 : 27127.0 ) ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 56660.0 : ( x <= 15.0 ? 65215.0 : 5495.0 ) ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 55104.0 : ( x <= 15.0 ? 64175.0 : 471.0 ) ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 23808.0 : ( x <= 15.0 ? 27305.0 : 117.0 ) ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 54272.0 : ( x <= 15.0 ? 54615.0 : 23.0 ) ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 16384.0 : ( x <= 15.0 ? 32765.0 : 1.0 ) ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 5460.0 : 0.0 ) ) : idx;\n    }\n    else\n    {\n        idx = y == 14.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 320.0 : 0.0 ) ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 1744.0 : 0.0 ) ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 6836.0 : 0.0 ) ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 2389.0 : ( x <= 15.0 ? 1680.0 : 21856.0 ) ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 8123.0 : ( x <= 15.0 ? 21845.0 : 61172.0 ) ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 31078.0 : ( x <= 15.0 ? 26969.0 : 39277.0 ) ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 42669.0 : ( x <= 15.0 ? 27241.0 : 31386.0 ) ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 39252.0 : ( x <= 15.0 ? 27305.0 : 5478.0 ) ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 27344.0 : ( x <= 15.0 ? 27305.0 : 1961.0 ) ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 42304.0 : ( x <= 15.0 ? 27033.0 : 346.0 ) ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 44288.0 : ( x <= 15.0 ? 26969.0 : 122.0 ) ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 21504.0 : ( x <= 15.0 ? 26969.0 : 21.0 ) ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 26969.0 : 0.0 ) ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 26969.0 : 0.0 ) ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 21845.0 : 0.0 ) ) : idx;\n    }\n\n    idx = SPRITE_DEC_4( x, idx );\n    idx = x >= 0.0 && x < 24.0 ? idx : 0.0;    \n    \n    color = idx == 1.0 ? RGB( 0,    0,   0   ) : color;\n    color = idx == 2.0 ? RGB( 228,  68,  52  ) : color;\n    color = idx == 3.0 ? RGB( 255,  184, 168 ) : color;\n}\n\nvoid SpriteLife( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n    \n    idx = y == 15.0 ? 21845.0 : idx;\n    idx = y == 14.0 ? 26985.0 : idx;\n    idx = y == 13.0 ? 26985.0 : idx;\n    idx = y == 12.0 ? 26985.0 : idx;\n    idx = y == 11.0 ? 26985.0 : idx;\n    idx = y == 10.0 ? 6500.0 : idx;\n    idx = y == 9.0 ? 1360.0 : idx;\n    idx = y == 8.0 ? 1744.0 : idx;\n    idx = y == 7.0 ? 1360.0 : idx;\n    idx = y == 6.0 ? 7140.0 : idx;\n    idx = y == 5.0 ? 28345.0 : idx;\n    idx = y == 4.0 ? 31725.0 : idx;\n    idx = y == 3.0 ? 31725.0 : idx;\n    idx = y == 2.0 ? 28345.0 : idx;\n    idx = y == 1.0 ? 7140.0 : idx;\n    idx = y == 0.0 ? 1360.0 : idx;    \n    \n    idx = SPRITE_DEC_4( x, idx );\n    \n    color = idx == 1.0 ? RGB( 0,    0,   0   ) : color;\n    color = idx == 2.0 ? RGB( 48,   31,  252 ) : color;\n    color = idx == 3.0 ? RGB( 255,  218, 144 ) : color;\n}\n\nvoid SpriteStage1( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n\n    idx = y == 6.0 ? ( x <= 23.0 ? 4095806.0 : ( x <= 47.0 ? 32574.0 : 30.0 ) ) : idx;\n    idx = y == 5.0 ? ( x <= 23.0 ? 8330311.0 : ( x <= 47.0 ? 1895.0 : 28.0 ) ) : idx;\n    idx = y == 4.0 ? ( x <= 23.0 ? 7412743.0 : ( x <= 47.0 ? 1799.0 : 28.0 ) ) : idx;\n    idx = y == 3.0 ? ( x <= 23.0 ? 7412798.0 : ( x <= 47.0 ? 32631.0 : 28.0 ) ) : idx;\n    idx = y == 2.0 ? ( x <= 23.0 ? 8330352.0 : ( x <= 47.0 ? 1895.0 : 28.0 ) ) : idx;\n    idx = y == 1.0 ? ( x <= 23.0 ? 7412851.0 : ( x <= 47.0 ? 1911.0 : 28.0 ) ) : idx;\n    idx = y == 0.0 ? ( x <= 23.0 ? 7412798.0 : ( x <= 47.0 ? 32606.0 : 62.0 ) ) : idx;\n    \n    idx = SPRITE_DEC_2( x, idx );\n    idx = x >= 0.0 && x < 54.0 ? idx : 0.0;\n\n    color = idx == 1.0 ? RGB( 255, 255, 255 ) : color;\n}\n\nvoid SpriteJungle( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n\n    idx = y == 6.0 ? ( x <= 23.0 ? 6776700.0 : 8324926.0 ) : idx;\n    idx = y == 5.0 ? ( x <= 23.0 ? 7300920.0 : 460647.0 ) : idx;\n    idx = y == 4.0 ? ( x <= 23.0 ? 8087352.0 : 460551.0 ) : idx;\n    idx = y == 3.0 ? ( x <= 23.0 ? 7563064.0 : 8324983.0 ) : idx;\n    idx = y == 2.0 ? ( x <= 23.0 ? 6514489.0 : 460647.0 ) : idx;\n    idx = y == 1.0 ? ( x <= 23.0 ? 6514489.0 : 460663.0 ) : idx;\n    idx = y == 0.0 ? ( x <= 23.0 ? 6503966.0 : 8355678.0 ) : idx;\n\n    idx = SPRITE_DEC_2( x, idx );\n    idx = x >= 0.0 && x < 47.0 ? idx : 0.0;\n\n    color = idx == 1.0 ? RGB( 255, 255, 255 ) : color;\n}\n\nvoid SpriteGameOver( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n\n    idx = y == 6.0 ? ( x <= 23.0 ? 6503998.0 : ( x <= 47.0 ? 4063359.0 : 4161399.0 ) ) : idx;\n    idx = y == 5.0 ? ( x <= 23.0 ? 7831399.0 : ( x <= 47.0 ? 7536647.0 : 6752119.0 ) ) : idx;\n    idx = y == 4.0 ? ( x <= 23.0 ? 8352007.0 : ( x <= 47.0 ? 7536647.0 : 6752054.0 ) ) : idx;\n    idx = y == 3.0 ? ( x <= 23.0 ? 6123895.0 : ( x <= 47.0 ? 7536767.0 : 4161334.0 ) ) : idx;\n    idx = y == 2.0 ? ( x <= 23.0 ? 4816743.0 : ( x <= 47.0 ? 7536647.0 : 3606300.0 ) ) : idx;\n    idx = y == 1.0 ? ( x <= 23.0 ? 4288887.0 : ( x <= 47.0 ? 8323079.0 : 6752028.0 ) ) : idx;\n    idx = y == 0.0 ? ( x <= 23.0 ? 4288862.0 : ( x <= 47.0 ? 4063359.0 : 6782728.0 ) ) : idx;\n\n    idx = SPRITE_DEC_2( x, idx );\n    idx = x >= 0.0 && x < 71.0 ? idx : 0.0;\n\n    color = idx == 1.0 ? RGB( 255, 255, 255 ) : color;\n}\n\nvoid SpriteHelicopter( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;    \n    \n\tidx = y == 10.0 ? ( x <= 7.0 ? 0.0 : 32768.0 ) : idx;\n\tidx = y == 9.0 ? ( x <= 7.0 ? 0.0 : 28672.0 ) : idx;\n\tidx = y == 8.0 ? ( x <= 7.0 ? 0.0 : 24672.0 ) : idx;\n\tidx = y == 7.0 ? ( x <= 7.0 ? 0.0 : 6155.0 ) : idx;\n\tidx = y == 6.0 ? ( x <= 7.0 ? 57344.0 : 1600.0 ) : idx;\n\tidx = y == 5.0 ? ( x <= 7.0 ? 6400.0 : 424.0 ) : idx;\n\tidx = y == 4.0 ? ( x <= 7.0 ? 36944.0 : 106.0 ) : idx;\n\tidx = y == 3.0 ? ( x <= 7.0 ? 58373.0 : 27.0 ) : idx;\n\tidx = y == 2.0 ? ( x <= 7.0 ? 57600.0 : 26.0 ) : idx;\n\tidx = y == 1.0 ? ( x <= 7.0 ? 43264.0 : 5.0 ) : idx;\n\tidx = y == 0.0 ? ( x <= 7.0 ? 21760.0 : 0.0 ) : idx;\n    \n    idx = SPRITE_DEC_4( x, idx );\n    idx = x >= 0.0 && x < 16.0 ? idx : 0.0;\n\n    color = idx == 1.0 ? RGB( 0,   91,  0 )   : color;\n    color = idx == 2.0 ? RGB( 0,   171, 71 )  : color;\n    color = idx == 3.0 ? RGB( 184, 248, 216 ) : color;\n}\n\nvoid SpriteVictory( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n\n    idx = y == 6.0 ? ( x <= 23.0 ? 6766142.0 : ( x <= 47.0 ? 4079422.0 : ( x <= 71.0 ? 485247.0 : ( x <= 95.0 ? 4095806.0 : ( x <= 119.0 ? 4089662.0 : 28.0 ) ) ) ) ) : idx;\n    idx = y == 5.0 ? ( x <= 23.0 ? 7304039.0 : ( x <= 47.0 ? 8349543.0 : ( x <= 71.0 ? 485148.0 : ( x <= 95.0 ? 1842303.0 : ( x <= 119.0 ? 4681587.0 : 28.0 ) ) ) ) ) : idx;\n    idx = y == 4.0 ? ( x <= 23.0 ? 8090471.0 : ( x <= 47.0 ? 7431943.0 : ( x <= 71.0 ? 485148.0 : ( x <= 95.0 ? 1842289.0 : ( x <= 119.0 ? 490355.0 : 28.0 ) ) ) ) ) : idx;\n    idx = y == 3.0 ? ( x <= 23.0 ? 7566087.0 : ( x <= 47.0 ? 7421815.0 : ( x <= 71.0 ? 485148.0 : ( x <= 95.0 ? 1842289.0 : ( x <= 119.0 ? 4092787.0 : 28.0 ) ) ) ) ) : idx;\n    idx = y == 2.0 ? ( x <= 23.0 ? 6517607.0 : ( x <= 47.0 ? 8337255.0 : ( x <= 71.0 ? 485148.0 : ( x <= 95.0 ? 1842303.0 : ( x <= 119.0 ? 7365491.0 : 0.0 ) ) ) ) ) : idx;\n    idx = y == 1.0 ? ( x <= 23.0 ? 6520679.0 : ( x <= 47.0 ? 7432055.0 : ( x <= 71.0 ? 485148.0 : ( x <= 95.0 ? 1842289.0 : ( x <= 119.0 ? 7562111.0 : 0.0 ) ) ) ) ) : idx;\n    idx = y == 0.0 ? ( x <= 23.0 ? 6503998.0 : ( x <= 47.0 ? 7432030.0 : ( x <= 71.0 ? 8338972.0 : ( x <= 95.0 ? 4070513.0 : ( x <= 119.0 ? 4088638.0 : 28.0 ) ) ) ) ) : idx;\n\n    idx = SPRITE_DEC_2( x, idx );\n    idx = x >= 0.0 && x < 125.0 ? idx : 0.0;\n\n    color = idx == 1.0 ? RGB( 255, 255, 255 ) : color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    \/\/ we want 224x192 (overscan) and we want multiples of pixel size\n    float resMultX      = floor( iResolution.x \/ NES_RES_X );\n    float resMultY      = floor( iResolution.y \/ NES_RES_Y );\n    float resRcp        = 1.0 \/ max( min( resMultX, resMultY ), 1.0 );\n    float screenWidth   = floor( iResolution.x * resRcp );\n    float screenHeight  = floor( iResolution.y * resRcp );\n    float pixelX        = floor( fragCoord.x * resRcp );\n    float pixelY        = floor( fragCoord.y * resRcp );   \n    \n    vec4 playerState    = LoadValue( txPlayerState );\n    vec4 playerWeapon   = LoadValue( txPlayerWeapon );    \n    vec4 camera         = LoadValue( txCamera );\n    vec4 playerBullet0  = LoadValue( txPlayerBullet0 );\n    vec4 playerBullet1  = LoadValue( txPlayerBullet1 );\n    vec4 playerBullet2  = LoadValue( txPlayerBullet2 );\n    vec4 playerBullet3  = LoadValue( txPlayerBullet3 );\n    vec4 playerBullet4  = LoadValue( txPlayerBullet4 );\n    vec4 playerBullet5  = LoadValue( txPlayerBullet5 );\n    vec4 enemyBullet0   = LoadValue( txEnemyBullet0 );\n    vec4 enemyBullet1   = LoadValue( txEnemyBullet1 );\n    vec4 enemyBullet2   = LoadValue( txEnemyBullet2 );\n    vec4 enemyBullet3   = LoadValue( txEnemyBullet3 );\n    vec4 bossBullet0\t= LoadValue( txBossBullet0 );\n    vec4 bossBullet1\t= LoadValue( txBossBullet1 );\n    vec4 powerUp        = LoadValue( txPowerUp );    \n    vec4 explosion      = LoadValue( txExplosion );\n    vec4 hit            = LoadValue( txHit );    \n    vec4 gameState      = LoadValue( txGameState );\n\n    float worldX        = pixelX + camera.x;\n    float worldY        = pixelY - 8.0;    \n\n    vec2 screenUV = fragCoord.xy \/ iResolution.xy;\n    vec3 color = texture( iChannel1, screenUV ).xyz; \n    \n    SpritePowerUp( color, worldX - powerUp.x + POWER_UP_SIZE.x * 0.5, worldY - powerUp.y, powerUp.z );\n    if ( playerWeapon.x == WEAPON_RIFLE )\n    {\n        SpriteBullet( color, worldX - playerBullet0.x + 1.0, worldY - playerBullet0.y );\n        SpriteBullet( color, worldX - playerBullet1.x + 1.0, worldY - playerBullet1.y );\n        SpriteBullet( color, worldX - playerBullet2.x + 1.0, worldY - playerBullet2.y );\n        SpriteBullet( color, worldX - playerBullet3.x + 1.0, worldY - playerBullet3.y );\n        SpriteBullet( color, worldX - playerBullet4.x + 1.0, worldY - playerBullet4.y );\n        SpriteBullet( color, worldX - playerBullet5.x + 1.0, worldY - playerBullet5.y );\n    }\n    else\n    {\n        SpritePowerBullet( color, worldX - playerBullet0.x + 2.0, worldY - playerBullet0.y );\n        SpritePowerBullet( color, worldX - playerBullet1.x + 2.0, worldY - playerBullet1.y );\n        SpritePowerBullet( color, worldX - playerBullet2.x + 2.0, worldY - playerBullet2.y );\n        SpritePowerBullet( color, worldX - playerBullet3.x + 2.0, worldY - playerBullet3.y );\n        SpritePowerBullet( color, worldX - playerBullet4.x + 2.0, worldY - playerBullet4.y );\n        SpritePowerBullet( color, worldX - playerBullet5.x + 2.0, worldY - playerBullet5.y );\n    }\n    SpriteBullet( color, worldX - enemyBullet0.x + 1.0, worldY - enemyBullet0.y );\n    SpriteBullet( color, worldX - enemyBullet1.x + 1.0, worldY - enemyBullet1.y );\n    SpriteBullet( color, worldX - enemyBullet2.x + 1.0, worldY - enemyBullet2.y );\n    SpriteBullet( color, worldX - enemyBullet3.x + 1.0, worldY - enemyBullet3.y );\n\tSpritePowerBullet( color, worldX - bossBullet0.x + 2.0, worldY - bossBullet0.y );\n\tSpritePowerBullet( color, worldX - bossBullet1.x + 2.0, worldY - bossBullet1.y );    \n    SpriteExplosion( color, worldX - explosion.x, worldY - explosion.y, explosion.z );\n    SpriteHit( color, worldX - hit.x, worldY - hit.y );      \n    \n    if ( pixelX > 32.0 && pixelX < 32.0 + 8.0 * ( playerState.w - 1.0 ) )\n    {\n        SpriteLife( color, pixelX, pixelY - screenHeight + 32.0 );\n    }\n    \n    if ( gameState.x == GAME_STATE_TITLE )\n    {\n        color = vec3( 0.0 );\n        SpriteStage1( color, pixelX - floor( screenWidth * 0.5 - 30.5 ), pixelY - floor( screenHeight * 0.5 - 10.5 ) );\n        SpriteJungle( color, pixelX - floor( screenWidth * 0.5 - 30.5 ), pixelY - floor( screenHeight * 0.5 + 10.5 ) );\n    }\n    else if ( gameState.x == GAME_STATE_GAME_OVER )\n    {\n        color = vec3( 0.0 );\n        SpriteGameOver( color, pixelX - floor( screenWidth * 0.5 - 36.5 ), pixelY - floor( screenHeight * 0.5 ) );\n    }\n    else if ( gameState.x == GAME_STATE_VICTORY )\n    {\n        \/\/ water \/ sky\n        color = pixelY < 80.0 ? RGB( 0, 112, 236 ) : vec3( 0.0 );\n        \n        \/\/ stars\n        float starRand = Rand( vec2( worldX * 0.01, worldY * 0.01 ) );\n        if ( starRand > 0.998 && worldY > 130.0 )\n        {\n            color = fract( iTime + starRand * 113.17 + worldX * 3.14 ) < 0.5 ? RGB( 255, 255, 255 ) : RGB( 0, 112, 236 );\n        }        \n        \n        SpriteVictory( color, pixelX - floor( screenWidth * 0.5 - 63.5 ), pixelY - floor( screenHeight * 0.5 ) - 20.0 );\n        SpriteHelicopter( color, floor( pixelX - screenWidth * ( 0.25 + 0.5 * ( 1.0 - gameState.y \/ UI_VICTORY_TIME ) ) ), pixelY - 90.0 );\n    }\n    else if ( gameState.x == GAME_STATE_LEVEL )\n    {\n\t\tfloat fadeAlpha = clamp( ( gameState.y - 30.0 ) \/ 30.0, 0.0, 1.0 );\n        color = pixelX < fadeAlpha * screenWidth ? color : vec3( 0.0 );\n    }\n    \n    fragColor = vec4( color, 1.0 );\n}","name":"Buf D","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"4sXyz2","date":"1488888506","viewed":19974,"name":"Organic segment test","username":"Zavie","description":"Playing around with a segment SDF to get something a little more life-like.","likes":24,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/*\n\nAn experiment at creating an organic looking segment.\n\nThe function was used for modelling the statue of Poseidon in the\ntemple scene of the 64kB intro \"H - Immersion\", by Ctrl-Alt-Test.\n\n > http:\/\/www.ctrl-alt-test.fr\/?page_id=444\n > https:\/\/www.youtube.com\/watch?v=27PN1SsXbjM\n\n-- \nZavie \/ Ctrl-Alt-Test\n\n*\/\n\nvec3 debugDistance(float d, vec3 color)\n{\n    float iso =\n        smoothstep(0.92, 0.98, abs(fract(d) * 2. - 1.)) +\n        smoothstep(0.8, 0.95, abs(fract(5.*d) * 2. - 1.))*0.5;\n    return mix(vec3(1.), color, iso)* mix(0.8, 1., float(d > 0.)) * smoothstep(0.02,0.06, abs(d));\n}\n\nfloat exponentialSmoothMmin(float a, float b, float k)\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )\/k;\n}\n\nfloat polynomialSmoothMmin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)\/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat segmentDistance(vec2 p, vec2 a, vec2 b, out float h)\n{\n\tvec2 ap = p - a;\n\tvec2 ab = b - a;\n\th = clamp(dot(ap, ab) \/ dot(ab, ab), 0., 1.);\n\treturn length(ap - ab * h);\n}\n\nvec4 limb(vec2 p, vec2 a, vec2 b, float ra, float rb, float fill, float k)\n{\n\tfloat da = length(a - p) - ra;\n\tfloat db = length(b - p) - rb;\n    float h;\n    float dmid = segmentDistance(p, a, b, h);\n\n    float bump = sin(2.*3.14159265358979 * (pow(h, 0.9) - 0.25)) * 0.5 + 0.5;\n    dmid -= mix(ra, rb, h + fill * bump);\n\n    float d = exponentialSmoothMmin(dmid, min(da, db), k);\n    return vec4(d, da, db, dmid);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 8.*fragCoord.xy \/ iResolution.y;\n\n    vec2 p1 = vec2(sin(2.*iTime), cos(iTime))+vec2(3.);\n    vec2 p2 = vec2(sin(3.*iTime), cos(1.2*iTime))+vec2(10., 4.);\n    \n    vec4 d = limb(uv, p1, p2, 0.85, 1.5, 0.8, 5.);\n\n    \n    vec3 color = 1.\n        * debugDistance(d.x, vec3(0.8, 0.8, 0.8))\n        * debugDistance(d.y, vec3(0.8, 0.5, 1.))\n        * debugDistance(d.z, vec3(0.5, 0.8, 1.))\n        * debugDistance(d.w, vec3(0.5, 1.0, 0.5))\n        ;\n\tfragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"wlGGWG","date":"1579844164","viewed":19965,"name":"Ashanoha","username":"coposuke","description":"traning. \u9ebb\u306e\u8449","likes":44,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI  \t3.14159265357989\n#define TAU \t(PI * 2.0)\n#define HEX_COS (0.86602540378443 * 0.5)\n#define HEX_TAN (0.57735026918962 * 0.5)\n\n\nstruct Animation\n{\n    float screenAngle;\n    float screenScale;\n    vec2  screenOffset;\n    float lineWidth;\n    float lineColorOffset;\n    float meshColorOffset;\n    float meshColorDist;\n    float lightAngle;\n    float blendLine;\n    float blendSolid;\n    float blendMesh;\n};\n\n\nmat2 rotate(float angle)\n{\n    float s = sin(angle), c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nvec2 pmod(vec2 pos, float num, out float id)\n{\n    float angle = atan(pos.x, pos.y) + PI \/ num;\n    float split = TAU \/ num;\n    id = floor(angle \/ split);\n\tangle = id * split;\n    return rotate(-angle) * pos;\n}\n\nfloat cubicInOut(float time)\n{\n  return (time < 0.5) ? (4.0 * time * time * time) : (1.0 - 4.0 * pow(1.0 - time, 3.0));\n}\n\n\/\/ for line\nvoid map(vec2 uv, out vec3 near, out vec3 neighbor)\n{\n    vec2 point;\n    near = vec3(1e+4);\n\n    for(float y=-1.0; y<=1.0; y+=2.0)\n    {\n        point = vec2(0.0, HEX_COS + y * HEX_TAN * 0.25);\n        float dist = distance(uv, point);\n        near = near.z < dist ? near : vec3(point, dist);\n    }\n    \n    for(float x=-1.0; x<=1.0; x+=2.0)\n    {\n\t    for(float y=-1.0; y<=1.0; y+=2.0)\n        {\n            for(float both=-1.0; both<=1.0; both+=2.0)\n            {\n                point = vec2(x * 0.125, HEX_COS + y * HEX_COS * 0.5);\n                point.x += both * 0.5     * 0.125 * -x;\n                point.y += both * HEX_TAN * 0.125 * -y;\n                float dist = distance(uv, point);\n                near = near.z < dist ? near : vec3(point, dist);\n            }\n        }\n    }\n    \n    neighbor = vec3(1e+4);\n    \n    for(float y=-1.0; y<=1.0; y+=2.0)\n    {\n        point = vec2(0.0, HEX_COS + y * HEX_TAN * 0.25);\n        if(near.xy != point)\n        {\n            vec2 center = (point + near.xy) * 0.5;\n            float dist = dot(uv - center, normalize(near.xy - point));\n            neighbor = neighbor.z < dist ? neighbor : vec3(point, dist);\n        }\n    }\n    \n    for(float x=-1.0; x<=1.0; x+=2.0)\n    {\n\t    for(float y=-1.0; y<=1.0; y+=2.0)\n        {\n            for(float both=-1.0; both<=1.0; both+=2.0)\n            {\n                point = vec2(x * 0.125, HEX_COS + y * HEX_COS * 0.5);\n                point.x += both * 0.5     * 0.125 * -x;\n                point.y += both * HEX_TAN * 0.125 * -y;\n                \n                if(near.xy != point)\n                {\n                    vec2 center = (point + near.xy) * 0.5;\n                    float dist = dot(uv - center, normalize(near.xy - point));\n                    neighbor = neighbor.z < dist ? neighbor : vec3(point, dist);\n                }\n            }\n        }\n    }\n}\n\n\/\/ for normal\nvec4 normalmap(vec2 uv)\n{\n    vec2 point = vec2(0);\n    vec3 near = vec3(1e+4);\n    vec3 neighbor = vec3(1e+4);\n    \n    for(float y=-1.0; y<=1.0; y+=2.0)\n    {\n        point = vec2(0.0, HEX_COS + y * HEX_TAN * 0.5);\n        float dist = distance(uv, point);\n        near = near.z < dist ? near : vec3(point, dist);\n    }\n    \n\tfor(float y=-1.0; y<=1.0; y+=2.0)\n    {\n        point = vec2(0.0, HEX_COS + y * HEX_TAN * 0.5);\n        if(near.xy != point)\n        {\n            vec2 center = (point + near.xy) * 0.5;\n            float dist = dot(uv - center, normalize(near.xy - point));\n            neighbor = neighbor.z < dist ? neighbor : vec3(point, dist);\n        }\n    }\n    \n    for(float x=-1.0; x<=1.0; x+=2.0)\n    {\n\t    for(float y=-1.0; y<=1.0; y+=2.0)\n        {\n            point = vec2(x * 0.25, HEX_COS - y * (HEX_COS - HEX_TAN * 0.5));\n            vec2 center = (point + near.xy) * 0.5;\n            float dist = dot(uv - center, normalize(near.xy - point));\n            neighbor = neighbor.z < dist ? neighbor : vec3(point, dist);\n        }\n    }\n    \n    return vec4(normalize(vec3(neighbor.xy - near.xy, 1.0)), neighbor.z);\n}\n\nvoid animate(float time, vec2 uv, inout Animation anim)\n{\n    float animLoop = floor(floor(time) \/ 13.0);\n    float animType = mod(floor(time), 13.0);\n    float animTime = fract(time);\n    float clockwise = mod(animLoop, 2.0) <= 0.0 ? 1.0 : -1.0;\n    \n    anim.screenScale = 2.0;\n    anim.screenAngle = PI * 0.166667;\n    anim.screenOffset= vec2(0, 0);\n    anim.lineWidth   = 0.01;\n    anim.blendLine = 0.0;\n    anim.blendMesh = 0.0;\n    anim.blendSolid = 0.0;\n    anim.meshColorDist = 200.0;\n    anim.lightAngle = 0.0;\n    \n    if(animType <= 0.0)\n    {\n        anim.screenScale = cubicInOut(animTime) * 1.0 + 1.0;\n    \tanim.lineWidth   = cubicInOut(1.0 - animTime) * 0.4 + 0.01;\n    \tanim.lineColorOffset = animTime;\n    \tanim.blendLine = 1.0;\n    }\n    else if(animType <= 1.0)\n    {\n        anim.screenScale -= animTime * 0.02;\n    \tanim.lineColorOffset = PI * 2.0 * animTime;\n    \tanim.blendLine = 1.0;\n    }\n    else if(animType <= 2.0)\n    {\n        anim.screenScale -= animTime * 0.02 + 0.02;\n    \tanim.lineColorOffset = PI * 2.0 * animTime;\n        anim.meshColorOffset = PI * 3.0 * animTime;\n    \tanim.blendLine = smoothstep(1.0, 0.0, animTime);\n    \tanim.blendMesh = smoothstep(0.0, 1.0, animTime);\n    }\n    else if(animType <= 3.0)\n    {\n        anim.screenScale -= animTime * 0.02 + 0.04;\n        anim.meshColorOffset = PI * 3.0 * animTime + PI;\n    \tanim.meshColorDist = smoothstep(1.0, 0.2, animTime) * 200.0;\n   \t \tanim.lightAngle  = PI * 2.0 * time;\n    \tanim.blendMesh = smoothstep(0.8, 0.2, animTime);\n    \tanim.blendSolid = smoothstep(0.0, 1.0, animTime);\n    }\n    else if(animType <= 4.0)\n    {\n        anim.screenScale -= animTime * 0.02 + 0.06;\n    \tanim.blendSolid = 1.0;\n    }\n    else if(animType <= 10.0)\n    {\n        animTime += animType - 5.0;\n        anim.screenScale -= clamp(animTime * 0.02 + 0.08, 0.0, 0.1);\n        animTime \/= 11.0 - 5.0;\n        anim.screenAngle += smoothstep(0.0, 1.0, animTime) * PI * 0.5 * clockwise;\n        \n        uv = rotate(PI * 2.0 * animTime * clockwise) * uv;\n        float pos = abs(uv.x + 0.0) + animTime;\n        float blend = smoothstep(-0.1, 0.0, sin(pos * PI * 3.0 * sin(animTime * PI)));\n    \tanim.blendSolid = blend;\n        anim.blendLine = 1.0 - blend;\n    \tanim.lineColorOffset = PI * 2.0 * animTime;\n    }\n    else if(animType <= 11.0)\n    {\n        anim.screenScale -= 0.1;\n        anim.screenAngle += PI * 0.5 * clockwise;\n        anim.lightAngle += PI * 2.0 * animTime;\n    \tanim.blendSolid = 1.0;\n    }\n    else if(animType <= 12.0)\n    {\n        anim.screenScale -= 0.1;\n        anim.screenAngle += PI * 0.5 * clockwise;\n        anim.lightAngle += PI * 2.0 * animTime;\n\n        float lineTime = (sin(animTime * PI * 3.0 - PI * 0.5) * 0.5 + 0.5);\n        lineTime = lineTime * lineTime * (animTime - (uv.x * uv.y * 0.2));\n        anim.lineWidth = clamp(lineTime, 0.0, 1.0) * 0.5;\n        anim.blendLine = 1.0;\n    \tanim.blendSolid = 1.0;\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) \/ min(iResolution.x, iResolution.y);\n \n    \/\/ animation\n    Animation anim;\n    animate(iTime, uv, anim);\n    \n    \/\/ view\n    uv *= anim.screenScale;\n    uv += anim.screenOffset;\n    uv = rotate(anim.screenAngle) * uv;\n\n    \/\/ tiling\n    vec2 uvLocal = uv;\n    uvLocal.x = mod(uv.x, 1.0) - 0.5;\n    uvLocal.y = mod(uv.y, HEX_COS * 2.0) - HEX_COS;\n    \n    \/\/ rot tiling\n    float id;\n    uvLocal = pmod(uvLocal, 6.0, id);\n\n    \/\/ scene\n    vec3 near, neighbor;\n    map(uvLocal, near, neighbor);\n    \n    \/\/ lighting\n    vec4 normal = normalmap(uvLocal);\n    normal.xy = rotate(id * PI \/ 3.0) * normal.xy;\n    float dist = normal.w;\n    dist = 1.0 - pow(1.0 - dist, 20.0);\n\n    vec3 lightDir = normalize(vec3(rotate(anim.lightAngle) * vec2(1,0), 0.25));\n    float light = dot(normal.xyz, lightDir) * 0.8 + 0.2;\n    \n    \/\/ draw\n    float lineWidth = (1.0 - smoothstep(0.0, anim.lineWidth, neighbor.z));\n    vec3 lineColor = cos(vec3(0,2,4) * PI \/ 3.0 + anim.lineColorOffset) * 0.25 + 1.0;\n    vec3 meshColor = cos(vec3(0,2,4) * PI \/ 3.0 + anim.meshColorOffset + anim.meshColorDist * neighbor.z) * 0.35 + 0.65;\n    float solid = (dist * light) * 0.6 + 0.2;\n    solid = 1.0 - pow(1.0 - solid, 3.0);\n    \n    fragColor.rgb = vec3(0);\n    fragColor.rgb = mix(fragColor.rgb, vec3(solid), anim.blendSolid);\n    fragColor.rgb = mix(fragColor.rgb, lineColor, lineWidth * anim.blendLine);\n    fragColor.rgb = mix(fragColor.rgb, meshColor, anim.blendMesh);\n    \n    \/\/ degamma\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0 \/ 2.2));\n    \n    \/\/ displacement\n    fragColor.a = mix(0.0, normal.w * 4.0, anim.blendSolid);\n    \n    \/\/ debug\n    \/\/fragColor.gb = vec2(0);\n    \/\/fragColor.r = 1.0 - pow(1.0 - near.z, 5.0);\n    \/\/fragColor.r = neighbor.z * 10.0;\n    \/\/fragColor.r = normal.w * 7.0;\n}\n\n\/** SHADERDATA\n{\n\t\"title\": \"Ashanoha\",\n\t\"description\": \"soundproof cushion\",\n\t\"model\": \"car\"\n}\n*\/","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"MljGRd","date":"1431819828","viewed":19937,"name":"Earthbound Battle Scene VR","username":"RavenWorks","description":"[url=https:\/\/www.shadertoy.com\/view\/MtsXRX]Check out the expanded version by clicking HERE![\/url]","likes":58,"published":3,"flags":9,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 diamondShine(float i){\n    float shine = abs(mod(i,2.0)-1.0);\n    shine *= 7.0;\n    return vec2(32.0+shine*24.0,4.0+shine*20.0).xxy\/255.0;\n}\n\nvec3 bgTexture(vec2 tileCoord)\n{\n\t\n    tileCoord.y += iTime*0.1;\n    tileCoord.y += pow(sin(tileCoord.y+iTime*0.75),2.0);\n    \n    vec2 withinTile = mod(tileCoord,1.0);\n    vec2 tileStep = floor(tileCoord);\n    \n    bool inDiamond = (abs(withinTile.x-0.5) + abs(withinTile.y-0.5)) < 0.5;\n    \n    vec3 color;\n    if (inDiamond) {\n        return diamondShine( tileStep.x*1.1 + tileStep.y*1.6 + iTime*0.5 );\n    } else {\n        return vec3(80.0\/255.0,96.0\/255.0,72.0\/255.0);\n    }\n\t\n}\n\n\n\n\n\n\n\n\n\n\nconst float PI =3.141592;\nconst float PI2=6.2831853;\n\n\n\n\nfloat _smooth( float a, float b, float k ){\n    float h = clamp(0.5+0.5*(b-a)\/k,0.0,1.0);\n    return mix(b,a,h) - k*h*(1.0-h);\n}\n\nvoid hardAdd(inout int curMaterial, inout float curD, int newMaterial, float newD){\n    if (newD < curD) {\n        curD = newD;\n        curMaterial = newMaterial;\n    }\n}\nvoid hardSubtract(inout float curD, float newD) {\n    curD = max( -newD, curD );\n}\nvoid smoothAdd(inout float curD, float newD, float blendPower){\/\/blend colors too?\n    curD = _smooth( newD, curD, blendPower );\n}\nvoid smoothSubtract(inout float curD, float newD, float blendPower){\n    curD = -_smooth( newD , -curD , blendPower );\n}\n\n\nfloat obj_ball(vec3 p, vec3 center, float radius){\n    return length(p-center)-radius;\n}\nfloat obj_cylinder(vec3 p, vec3 center, vec2 size, float roundness){\n    vec3 tp = p-center;\n    vec2 d = abs(vec2(length(tp.yz),tp.x)) - (size-roundness);\n    return min(max(d.x,d.y)+roundness,0.0) + length(max(d,0.0))-roundness;\n}\nfloat obj_cylForever(vec2 p, vec2 middle, float radius){\n    return abs(length(p-middle)) - radius;\n}\nfloat obj_planeY(vec3 p, float planeY){\n    return p.y-planeY;\n}\nfloat obj_roundline( vec3 p, vec3 a, vec3 b, float r ){\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\nfloat obj_box(vec3 p, vec3 center, vec3 size, float roundness){\n    vec3 d = abs(p-center) - (size-roundness);\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) - roundness;\n}\nfloat obj_torus( vec3 p, vec3 center, vec2 t ){\n    vec3 tp = p-center;\n\tvec2 q = vec2(length(tp.xy)-t.x,tp.z);\n\treturn length(q)-t.y;\n}\nfloat obj_quartertorus( vec3 p, vec3 center, vec2 t ){\n    vec3 tp = p-center;\n    tp.x = max(tp.x,0.0);\n    tp.y = max(tp.y,0.0);\n    \/\/ okay that honestly isn't what I set out to make, but it saves me several other shapes..!\n\tvec2 q = vec2(length(tp.xy)-t.x,tp.z);\n\treturn length(q)-t.y;\n}\n\n\nconst float bgDist = 10.0;\nconst float statusDist = -0.75;\nconst float statusHeight = 0.85;\nconst float enemyDist = -2.0;\nconst float enemyHeight = 1.0;\nconst float enemyOffX = 0.6;\n\nfloat sceneDistance(vec3 p, inout int material){\n    \n    float distance = 9999.9;\n    material = 0;\n    \n    \n    \n    hardAdd(material,distance,1,\n    \t-obj_cylForever(p.xz, vec2(0.0),bgDist)\n    );\n    \n    \n    const float outlineRad = 0.02;\n    float healthModX = 0.35;\n    vec2 healthSize = vec2(0.25,0.35)\/2.0;\n    if (abs(p.x)<healthModX*2.0) {\n        \n        vec3 healthP = p;\n        healthP.y -= statusHeight;\n        \n        healthP.x = mod(healthP.x,healthModX);\n        healthP.x -= healthModX\/2.0;\n        \n        vec3 healthFrameP = healthP;\n        healthFrameP.y = abs(healthFrameP.y);\n        healthFrameP.x = abs(healthFrameP.x);\n        \n        \n        const float boxThickness = 0.03;\n        hardAdd(material,distance,3,\n\t\t\tobj_box(healthFrameP,vec3(0.0,0.0,statusDist-boxThickness+0.01),vec3(healthSize.xy,boxThickness),0.0)\n\t\t);\n        \n        const float healthInset = 0.01;\n        smoothSubtract(distance,\n            obj_box(healthP,vec3(0.05,-0.1,statusDist),vec3(0.075,0.125,healthInset),0.0),\n        \t0.01\n        );\n\n        \n        hardAdd(material,distance,2,\n            obj_quartertorus(healthFrameP,vec3(healthSize.xy,statusDist),vec2(outlineRad,outlineRad-0.001))\n        );\n        \n        \n        \n        vec3 wheelP = healthP;\n        wheelP.x -= 0.05;\n        wheelP.x = abs(wheelP.x);\n\n\n        wheelP.y += 0.075;\n        wheelP.y = abs(wheelP.y);\n\n        hardAdd(material,distance,2,\n        \tobj_cylinder(wheelP,vec3(0.0,0.05,statusDist-healthInset),vec2(0.05,0.025),0.0075)\n        );\n        hardAdd(material,distance,2,\n        \tobj_cylinder(wheelP,vec3(0.05,0.05,statusDist-healthInset),vec2(0.05,0.025),0.0075)\n        );\n\n    }\n    \n    vec3 statusP = p;\n    statusP.y -= statusHeight+1.0;\n    statusP.y = abs(statusP.y);\n    \n    statusP.x += 0.25;\n    statusP.x = abs(statusP.x);\n    \n    hardAdd(material,distance,2,\n    \tobj_quartertorus(statusP,vec3(0.4,0.1,statusDist),vec2(0.02,0.01))\n    );\n    hardAdd(material,distance,4,\n    \tobj_box(statusP,vec3(0.0,0.0,statusDist-0.005),vec3(0.41,0.12,0.01),0.0)\n    );\n    \n    \n    \n    \n    float ufoHeight = enemyHeight+sin(iTime*2.5)*0.02;\n    \n    vec3 ufoRotP = p;\n    \n    vec3 ufoBodyP = ufoRotP;\n    ufoBodyP.y -= ufoHeight+0.3;\n    ufoBodyP.y = abs(ufoBodyP.y);\n    \n    hardAdd(material,distance,5,\n\t\tobj_ball(ufoBodyP,vec3(-enemyOffX,-1.0,enemyDist),1.1)\n\t);\n    smoothAdd(distance,\n\t\tobj_ball(ufoBodyP,vec3(-enemyOffX,0.03,enemyDist),0.2),\n    0.1);\n    \n    vec3 ufoEyeP = ufoRotP;\n    ufoEyeP.x -= -enemyOffX+0.05;\n    ufoEyeP.x = abs(ufoEyeP.x);\n    \n    hardAdd(material,distance,6,\n\t\tobj_ball(ufoEyeP,vec3(0.045,ufoHeight+0.41,enemyDist+0.25),0.025)\n\t);\n    \n    \n    \n    \n    const float foppyWidth = 0.1;\n    float foppyBob = pow(1.0-(sin(iTime*4.0)*0.5+0.5),1.1);\n    float foppyHeight = enemyHeight+0.3 + foppyBob*0.03;\n    hardAdd(material,distance,7,\n    \tobj_ball(p,vec3(enemyOffX+foppyWidth,foppyHeight,enemyDist),0.2)\n\t);\n    smoothAdd(distance,\n    \tobj_ball(p,vec3(enemyOffX-foppyWidth,foppyHeight,enemyDist),0.2),\n\t0.3);\n    \n    float legOff = 0.25 - foppyBob*0.02;\n    float legSize = 0.09 - foppyBob*0.01;\n    hardAdd(material,distance,7,\n    \tobj_ball(p,vec3(enemyOffX-legOff,enemyHeight+0.1,enemyDist+0.2),legSize)\n\t);\n    hardAdd(material,distance,7,\n    \tobj_ball(p,vec3(enemyOffX+legOff,enemyHeight+0.08,enemyDist-0.1),legSize)\n\t);\n    \n    \n    vec3 foppyEyeP = p;\n    foppyEyeP.x -= enemyOffX-0.05;\n    foppyEyeP.x = abs(foppyEyeP.x);\n    \n    hardAdd(material,distance,8,\n    \tobj_ball(foppyEyeP,vec3(0.1,foppyHeight+0.07,enemyDist+0.26),0.015)\n\t);\n    \n    \n    \n    return distance;\n    \n}\n\n\n\n\nconst vec3 e=vec3(0.00007,0,0);\nconst float maxd=256.0; \/\/Max depth\nfloat nearestD = maxd;\nvec3 color;\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir ) {\n    \n    \n    \n    vec3 scrCoord = fragRayOri;\n    vec3 curCameraRayUnit = fragRayDir;\n    \n    \n    color = vec3(0.0);\n    \n    \n    scrCoord.y += 1.5;\n    \n    \n    \n    \n    \n    vec3 p = scrCoord;\n\n    float f=0.0;\n    float d=0.01;\n    int mat, dummyMat;\n    for(int i=0;i<64;i++){\n        if ((abs(d) < .001) || (f > maxd)) break;\n        f+=d;\n        p=scrCoord + curCameraRayUnit*f;\n        d = sceneDistance(p,mat);\n    }\n    \n    if (f < nearestD) {\n\n        nearestD = f;\n        \n        vec3 n = normalize(vec3(d-sceneDistance(p-e.xyy,dummyMat),\n                                d-sceneDistance(p-e.yxy,dummyMat),\n                                d-sceneDistance(p-e.yyx,dummyMat)));\n        \n        \n        \n        vec3 lightDir = normalize(vec3(0.0,0.25,1.0));\n        float specP = 1.0;\n        float specA = 0.0;\n        \n        float diffMin = 0.0;\n        \n        \/\/ BG\n        if (mat == 1) {\n            color = bgTexture(vec2(atan(p.x,p.z)\/PI2*32.0,p.y\/bgDist*4.0));\n            color *= 1.0-pow(min((abs(p.y)\/30.0),1.0),2.0);\/\/1.0- should be inside, but it looks cooler this way~\n            \n        \/\/frame outline\n        } else if (mat == 2) {\n            color = vec3(1.0);\n            \n        \/\/health pattern\n        } else if (mat == 3) {\n            const float checkerSize = 0.05;\n            if ( (mod(p.x,checkerSize)<checkerSize*0.5) == (mod(p.y,checkerSize)<checkerSize*0.5) ) {\n                color = vec3(144.0\/255.0,128.0\/255.0,168.0\/255.0);\n            } else {\n                color = vec3(144.0\/255.0,144.0\/255.0,232.0\/255.0);\n            }\n            \n        \/\/status pattern\n        } else if (mat == 4) {\n            color = vec3(0.0);\n            \n        \/\/UFO skin\n        } else if (mat == 5) {\n            color = vec3(0.7);\n            specA = 1.0;\n            specP = 6.0;\n            lightDir = normalize(vec3(0.25,0.5,1.0));\n            \n        \/\/UFO eyes\n        } else if (mat == 6) {\n            color = vec3(0.2);\n            specA = 0.65;\n            specP = 16.0;\n            lightDir = normalize(vec3(0.25,0.5,1.0));\n            \n        \/\/Foppy skin\n        } else if (mat == 7) {\n            \n            float normGap = pow(dot(-curCameraRayUnit,n),1.7);\n            color = mix(\n                vec3(144.0\/255.0,0.0,48.0\/255.0)*0.75,\n                vec3(240.0\/255.0,0.0,96.0\/255.0),\n            normGap);\n            \n            specA = 0.75;\n            specP = 12.0;\n            lightDir = normalize(vec3(1.0,1.0,0.0));\n            diffMin = 1.0;\n            \n            \n            \n            \n            \n        \/\/Foppy eyes\n        } else if (mat == 8) {\n            color = vec3(0.2);\n            specA = 0.3;\n            specP = 48.0;\n        }\n        \n        color *= dot(n,lightDir)*(1.0-diffMin)+diffMin;\n        \n        float specular = max(0.0,dot(normalize(lightDir-curCameraRayUnit),n));\n        color += pow(specular,specP)*specA;\n        \n        \n        \n        const float shadowPlane = enemyHeight;\n        float stepsToPlane = (shadowPlane-scrCoord.y)\/curCameraRayUnit.y;\n        vec3 planePt = scrCoord+curCameraRayUnit*stepsToPlane;\n        planePt.x = abs(planePt.x);\n        \n        if (planePt.z < 0.0 && planePt.z > -3.0 && planePt.z > p.z) {\n            float occlusion = length(planePt.xz-vec2(enemyOffX,enemyDist));\n            occlusion = pow(occlusion,0.5);\n            occlusion = max(0.0,min(1.0,(occlusion*1.7)));\n            occlusion = 0.3+occlusion*0.7;\n        \tcolor *= occlusion;\n        }\n        \n        \n        \n    }\n\n\n    \n    \n    \n    fragColor = vec4(color,1.0);\n    \n    \n}\n\n\nconst float transitionTime = 2.5;\nconst float fadeSpd = 1.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    \n    float introTime = iTime - 1.25;\n    \n    \n    if (introTime < transitionTime) {\n        \n        \n        float extent = min(iResolution.x,iResolution.y);\n        vec2 uv = fragCoord.xy \/ extent;\n        uv *= 2.0;\n        uv -= 1.0;\n        uv -= ((iResolution.xy\/extent)-1.0);\n        \n        uv.x *= 0.8;\n        \n        \n        vec3 color = vec3(0.35+sin(uv.x*16.0+uv.y*6.0)*0.15);\n        \n\n        float dist = length(uv);\n        dist = pow(dist,0.42);\n        float ang = atan(uv.y,uv.x);\n        float angFrac = ang\/(PI*2.0)+0.5;\n\n        const float stripeWidth = 0.15;\n\n        dist += angFrac*stripeWidth*2.0;\n\n        float stripeProgress = floor(dist\/stripeWidth)-angFrac*2.0;\n        \n        float swirlOff = introTime*10.0;\n        if (mod(dist,stripeWidth*2.0) < stripeWidth) swirlOff -= 1.5;\n        \n        float stripeLit = (stripeProgress-swirlOff)*16.0;\n        float greenVal = max(0.0,min(1.0,(0.8-stripeLit)));\n        \n        \n        float fadeOutAmt = pow(min(1.0,(transitionTime-introTime)*fadeSpd),2.0);\n        \n        \n        color *= vec3(1.0-greenVal,1.0,1.0-greenVal);\n        color *= fadeOutAmt;\n        \n        fragColor = vec4(color,1.0);\n        \n        \n        \n    } else {\n\n\n\n        vec3 cameraPos = vec3(0.0,0.06,0.75);\n\n        vec2 mouseFrac = iMouse.xy\/iResolution.xy;\n        mouseFrac -= 0.5;\n        mouseFrac *= 2.0;\n\n        if (iMouse.z != 0.0) {\n\n            cameraPos.x -= mouseFrac.x*0.75;\n            cameraPos.y -= mouseFrac.y*0.75;\n\n        } else {\n            \n            float waveTime = iTime - transitionTime - 2.0;\n            cameraPos.x += sin(waveTime*0.5)*0.4;\n            cameraPos.y += sin(waveTime*1.0)*-0.05;\n            \n        }\n        \n        \n        vec3 cameraFwd = normalize(vec3(0.0,-0.4,-2.0)-cameraPos);\n        vec3 cameraUp = vec3(0.0,1.0,0.0);\n        vec3 cameraRight = normalize(-cross(cameraUp,cameraFwd));\n        \n        \n        \n        \n        \/\/ all this stuff with working from FOVs is for the sake of WebVR compatibility,\n        \/\/ which is redundant for shadertoy, but handy for my personal site\n\n        float vertFov = 50.0;\n        float horizFov = 2.0*atan(tan((vertFov\/180.0*PI)\/2.0)*(iResolution.x\/iResolution.y))*180.0\/PI;\n        vec4 fovAngsMono = vec4(horizFov\/2.0, horizFov\/2.0, vertFov\/2.0, vertFov\/2.0);\n\n\n\n        vec2 fragFrac = fragCoord.xy\/iResolution.xy;\n\n        vec2 eyeRes = iResolution.xy;\n        vec4 fovAngs = fovAngsMono;\n\n        \n\n\n\n\n\n\n\n        float fovL = -fovAngs.x\/180.0*PI;\n        float fovR =  fovAngs.y\/180.0*PI;\n        float fovU = -fovAngs.z\/180.0*PI;\n        float fovD =  fovAngs.w\/180.0*PI;\n\n        float fovMiddleX = (fovR + fovL) * 0.5;\n        float fovMiddleY = (fovU + fovD) * 0.5;\n        float fovHalfX = (fovR - fovL) * 0.5;\n        float fovHalfY = (fovD - fovU) * 0.5;\n\n\n\n        float scrWorldHalfX = sin(fovHalfX)\/sin(PI*0.5 - fovHalfX);\n        float scrWorldHalfY = sin(fovHalfY)\/sin(PI*0.5 - fovHalfY);\n\n\n        \/\/ determine screen plane size from FOV values, then interpolate to find current pixel's world coord\n\n        vec2 vPos = fragFrac;\/\/0 to 1\n        vPos.x -= (-fovL\/(fovHalfX*2.0));\n        vPos.y -= (-fovU\/(fovHalfY*2.0));\n\n        vec3 screenPlaneCenter = cameraPos+cameraFwd;\n        vec3 scrCoord = screenPlaneCenter + vPos.x*cameraRight*scrWorldHalfX*2.0 + vPos.y*cameraUp*scrWorldHalfY*2.0;\n        vec3 curCameraRayUnit = normalize(scrCoord-cameraPos);\n\n\n\n        mainVR(fragColor,fragCoord,cameraPos,curCameraRayUnit);\n        \n        \n        \n        float fadeInAmt = min(1.0,(introTime-transitionTime)*fadeSpd);\n        fragColor.xyz *= pow(fadeInAmt,2.0);\n        \n\n    }\n    \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"XsfGRr","channel":0}],"code":"\nvec2 pan(float panAmt){\n    return vec2(0.5-panAmt*0.5,0.5+panAmt*0.5);\n}\n\nfloat noteFreq(int note){\n    float oct = 1.0;\n    if (note >= 12) {\n        note -= 12;\n        oct = 2.0;\n    }\n    if (note < 0) {\n        note += 12;\n        oct = 0.5;\n    }\n    if (note ==  0) return oct*440.000;\n    if (note ==  1) return oct*466.164;\n    if (note ==  2) return oct*493.883;\n    if (note ==  3) return oct*523.251;\n    if (note ==  4) return oct*554.365;\n    if (note ==  5) return oct*587.330;\n    if (note ==  6) return oct*622.254;\n    if (note ==  7) return oct*659.255;\n    if (note ==  8) return oct*698.456;\n    if (note ==  9) return oct*739.989;\n    if (note == 10) return oct*391.995*2.0;\n    if (note == 11) return oct*415.305*2.0;\n    return 0.0;\n}\n\n\nfloat introHorn(int note, float time){\n    \n    float glissandoTime = time - 0.5;\n    if (glissandoTime < 0.0) {\n        glissandoTime = -pow(1.0-glissandoTime,1.0-glissandoTime*0.4);\n    } else {\n        glissandoTime = -(1.0-glissandoTime);\n    }\n    \n    float baseFreq = 6.2831*noteFreq(note)*glissandoTime*0.5;\n    \n    float mix = 0.0;\n    \n    mix += sin(baseFreq*1.0)*1.0;\n    mix += sin(baseFreq*2.0)*0.75;\n    mix += sin(baseFreq*3.0)*0.75;\n    mix += sin(baseFreq*4.0)*0.5;\n    mix += sin(baseFreq*5.0)*0.75;\n    mix += sin(baseFreq*6.0)*0.5;\n    \n    mix *= 0.25;\n    \n    return mix;\n    \n}\n\n\nconst float beatLength = 1.0\/7.5;\n\nfloat krakenSynth(int note, float time, float octave, float sawTweak){\n    \n    float baseFreq = noteFreq(note);\n    \n    float sinFreq = baseFreq*pow(2.0,octave+2.0);\n    float sawFreq = baseFreq*pow(2.0,octave-3.0-sawTweak);\n    \n    float sinWave = cos(6.2831*time*sinFreq);\n    float sawWave = 1.0-mod(time*sawFreq,1.0);\n    sawWave = pow(sawWave,8.0);\n    \n    return sawWave*sinWave - sawWave;\n    \n}\n\nfloat krakenLead(float songTime){\n    \n    float beatNum = songTime\/beatLength;\n    float beatStep = mod(floor(beatNum),32.0);\n    float barStep = floor(beatNum\/32.0);\n\n\n    if (mod(beatNum,1.0)<0.68){\n\n        float triplet = floor(beatStep\/3.0);\n        float withinTriplet = mod(beatStep,3.0);\n        if (beatStep >= 16.0) {\n            triplet = 5.0-floor((beatStep-16.0)\/3.0);\n            withinTriplet = mod(beatStep-16.0,3.0);\n        }\n        if (beatStep >= 29.0) {\n            withinTriplet++;\n        }\n\n\n\n        int curNote = 3;\n        if ((barStep > 0.0) && (mod(barStep,2.0)==0.0)) curNote += 4;\n\n        float octave = -triplet;\n        if (withinTriplet == 2.0) octave++;\n\n        return krakenSynth(curNote,mod(songTime,beatLength),octave,-triplet);\n\n    } else {\n        \n        return 0.0;\n        \n    }\n    \n}\n\n\nfloat bassSynth(int note, float time){\n    \n    const float noteLength = 0.5;\n    \n    if (time > noteLength) return 0.0;\n    \n    float baseFreq = 6.2831*time*noteFreq(note);\n    \n    float fadeIn = 1.0-pow(1.0-(time\/noteLength),32.0);\n    float fadeOut = 1.0-pow(time\/noteLength,8.0);\n    \n    return (\n        sin(baseFreq*pow(2.0,-6.0))*1.5 +\n        sin(baseFreq*pow(2.0,-5.0))*0.5 + \n        sin(baseFreq*pow(2.0,-4.0))*0.05\n    )*fadeIn*fadeOut;\n    \n}\n\nfloat krakenBass(float songTime){\n    \n    \/\/ this redundancy isn't great but whatev\n    float beatNum = songTime\/beatLength;\n    float beatStep = mod(floor(beatNum),8.0);\/\/DIFFERENT BAR LENGTH FOR BASSLINE\n    float barStep = mod(floor(beatNum\/8.0),4.0);\n    \n    if ( beatStep == 3.0 && barStep < 2.0) return 0.0;\n    if ( beatStep == 6.0 && barStep < 3.0) return 0.0;\n    if ( beatStep == 7.0 && barStep == 3.0) return 0.0;\n    \n    int bassNote = (mod(floor(beatNum\/32.0),2.0) == 0.0) ? 8 : 4 ;\n    \n    return bassSynth(bassNote, mod(beatNum,1.0));\n    \n}\n\n\nfloat wailSynth(int note, float time){\n    \n    const float noteEnd = 32.0;\n    const float noteStart = 4.0;\n    \n    float noteFrac = max(0.0,min(1.0,(time-noteStart)\/(noteEnd-noteStart)));\n    float fadeIn = pow(noteFrac,2.0);\n    float fadeOut = 1.0-(pow(noteFrac,2.0));\n    \n    float baseFreq = 6.2831*time*noteFreq(note)*0.25;\n    baseFreq += sin(time*4.5)*3.0;\n    \n    return (\n        sin(baseFreq)+\n        sin(baseFreq*3.0)+\n        sin(baseFreq*4.0)*0.75\n    )*fadeIn*fadeOut*0.5;\n    \n}\n\nfloat krakenWail(float songTime){\n    \n    float beatNum = songTime\/beatLength;\n    \n    int wailNote = (mod(floor(beatNum\/32.0),2.0) == 0.0) ? 2 : 3;\n    \n    return wailSynth(wailNote, mod(beatNum,32.0));\n    \n}\n\n\nfloat noise(float time){\n    return sin( time*200034.2666 * sin(time*600078.6576) );\n}\n\nfloat kick(float time) {\n    \n    float sinWave = sin(pow(time*1000.0,0.6));\n    \n    const float fadeInTime = 0.00015;\n    float fadeIn = max(0.0,min(1.0,(time\/fadeInTime)));\n    \n    const float fadeOutTime = 1.0;\n    float fadeOut = max(0.0,min(1.0,((fadeOutTime-time)\/fadeOutTime)));\n    \n    return sinWave*fadeIn*fadeOut;\n    \n}\n\nfloat snare(float time) {\n    \n    float sinWave = sin(pow(time*1000.0,0.7));\n    float sineFadeIn = max(0.0,min(1.0,(time\/0.00015)));\n    float sineFadeOut = max(0.0,min(1.0,(1.0-(time\/0.25))));\n    \n    float noiseWave = noise(time);\n    float noiseFadeIn = max(0.0,min(1.0,(time\/0.00015)));\n    float noiseFadeOut = max(0.0,min(1.0,(1.0-(time\/0.25))));\n    \n    return noiseWave*noiseFadeIn*noiseFadeOut*0.75 + sinWave*sineFadeIn*sineFadeOut*0.5;\n    \n}\n\nfloat hihatClosed(float time){\n    \n    float sinWaveA = sin(pow(time*8700.0,0.99));\n    float sinWaveB = sin(pow(time*7200.0,0.99));\n    float sineFadeIn = max(0.0,min(1.0,(time\/0.15)));\n    float sineFadeOut = max(0.0,min(1.0,(1.0-(time))));\n    \n    float noiseWave = noise(time);\n    float noiseFadeOut = max(0.0,min(1.0,(1.0-(time\/0.75))));\n    noiseFadeOut = pow(noiseFadeOut,2.0);\n    \n    return noiseWave*noiseFadeOut*0.5 + (sinWaveA+sinWaveB)*sineFadeIn*sineFadeOut*0.05;\n    \n}\n\nfloat hihatOpen(float time){\n    \n    float noiseVol;\n    float sineVolA;\n    float sineVolB;\n    \n    if (time < 0.125) {\n    \t\n        noiseVol = 2.0;\n        \n        sineVolA = 0.1;\n        sineVolB = 0.15;\n        \n    } else if (time < 1.0) {\n        \n        noiseVol = 0.6;\n        \n        sineVolA = 0.1;\n        sineVolB = 0.15;\n        \n    } else if (time < 2.0) {\n        \n        noiseVol = max(0.0,min(1.0,(2.0-(time*1.0))));\n        noiseVol = pow(1.0-noiseVol,1.0);\n        noiseVol *= 0.1;\n        \n        sineVolA = max(0.0,min(1.0,(2.0-(time*0.5))));\n        sineVolA = 1.0-pow(1.0-sineVolA,1.0);\n        sineVolA *= 0.0125;\n        \n        sineVolB = sineVolA*1.5;\n        \n    } else {\n        \n        return 0.0;\n        \n    }\n    \n    float mix = 0.0;\n    \n    mix += noise(time)*noiseVol;\n    \n    mix += sin(time*6300.0) * sineVolA;\n    mix += sin(time*7200.0) * sineVolB;\n    \n    return mix;\n    \n}\n\n\n\nvec2 mainSound( in int samp,float time){\n    \n    \n    \n    const float introStartTime = 1.35;\n    const float introEndTime = 4.0;\n    \n    if (time < introStartTime) {\n        return vec2(0.0);\n    } else if (time < introEndTime) {\n        \n        float introTime = time - introStartTime;\n        \n        vec2 mix = vec2(0.0);\n        \n        const float numEchos = 3.0;\n        for(float i=0.0; i<numEchos; i++){\n            \n            float echoTime = introTime - i*0.03;\n            float echoVol = 1.0-(i\/numEchos);\n            \n            const float hornOffset = 0.0;\n            \n            mix += (\n                (introHorn(-4,echoTime)*1.0*pan(-0.6))+\n                (introHorn( 3,echoTime)*1.0*pan(-0.2))+\n                (introHorn( 5,echoTime)*1.0*pan( 0.2))+\n                (introHorn(10,echoTime)*1.0*pan( 0.6))+\n                (introHorn(14,echoTime)*0.5*pan( 0.0))\n            )*0.5*echoVol;\n        }\n        \n        \n        float volEnv = cos(pow(introTime*0.5,0.8)*6.2831)*0.5+0.5;\n        const float volEnvMin = 0.3;\n        volEnv = volEnv*(1.0-volEnvMin)+volEnvMin;\n        \n        \n        const float fadeInStart = introStartTime;\n        const float fadeInEnd = introStartTime + 0.3;\n        float fadeIn = max(0.0,min(1.0,(time-fadeInStart)\/(fadeInEnd-fadeInStart)));\n        fadeIn = 1.0-pow(1.0-fadeIn,2.0);\n        \n        const float fadeOutStart = introEndTime - 0.45;\n        const float fadeOutEnd = introEndTime - 0.1;\n        float fadeOut = max(0.0,min(1.0,(time-fadeOutStart)\/(fadeOutEnd-fadeOutStart)));\n        fadeOut = 1.0-pow(fadeOut,4.0);\n        \n        return mix*volEnv*fadeOut*fadeIn;\n        \n    } else {\n        \n        \n        \n        float songTime = time - introEndTime;\n    \n\n\n        float mix = 0.0;\n\n\n        float beatNum = songTime\/beatLength;\n        float beatStep = mod(floor(beatNum),32.0);\n        float barStep = floor(beatNum\/32.0);\n\n\n        if (barStep == 0.0) {\n            mix += krakenLead(songTime);\n        } else {\n            mix += krakenLead(songTime);\n            mix += krakenLead(songTime-0.1)*0.3;\n        }\n\n\n        if (barStep > 0.0) {\n            if (barStep == 1.0) {\n                if (beatStep < 28.0) {\n                    mix += kick(mod(beatNum,4.0))*1.5;\n                } else {\n                    mix += kick(mod(beatNum,1.0))*1.5;\n                }\n                float snareHatBeat;\n                float snareHatVol;\n                if (beatStep < 24.0) {\n                    snareHatBeat = mod(beatNum,2.0);\n                    if (mod(beatStep,8.0) > 4.0) snareHatBeat = mod(beatNum+1.0,2.0);\n                    snareHatVol = 1.0;\n                } else {\n                    snareHatBeat = mod(beatNum,1.0);\n                    snareHatVol = 1.25 + 0.5*((beatStep-24.0)\/8.0);\n                }\n                mix += snare(snareHatBeat)*snareHatVol;\n                mix += hihatClosed(snareHatBeat)*0.5*snareHatVol;\n            } else {\n\n                float beatStepHalf = mod(beatStep,16.0);\n\n                if (\n                    beatStepHalf ==  0.0 ||\n                    beatStepHalf ==  8.0 ||\n                    beatStepHalf == 10.0 ||\n                    beatStepHalf == 14.0 ||\n                    beatStep == 21.0\n                ) {\n                    mix += kick(mod(beatNum,1.0))*1.5;\n                }\n\n                if (\n                    beatStepHalf ==  4.0 ||\n                    beatStepHalf ==  7.0 ||\n                    beatStepHalf ==  9.0 ||\n                    beatStepHalf == 12.0 \n                ){\n                    mix += snare(mod(beatNum,1.0))*1.5;\n                }\n                if (\n                    beatStepHalf ==  3.0 ||\n                    beatStepHalf == 11.0 ||\n                    beatStepHalf == 13.0 \n                ){\n                    mix += snare(mod(beatNum,1.0))*0.5;\n                }\n\n                float hihatBeatNum = beatNum-2.0;\n                if (mod(floor(beatStep\/2.0),8.0)==4.0) hihatBeatNum += 2.0;\n                mix += hihatOpen(mod(hihatBeatNum,4.0))*0.3;\n\n\n                mix += krakenBass(songTime)*1.15;\n\n                mix += krakenWail(songTime)*0.8;\n                mix += krakenWail(songTime-0.1)*0.4;\n\n\n            }\n        }\n\n\n        const float fadeStart = 128.0;\n        const float fadeEnd = fadeStart+64.0;\n        float fadeOut = max(0.0,min(1.0,(beatNum-fadeStart)\/(fadeEnd-fadeStart)));\n        fadeOut = (1.0-fadeOut);\n        fadeOut = 1.0-pow(1.0-fadeOut,2.0);\n\n\n        return vec2(mix)*0.3*fadeOut;\n        \n        \n    }\n    \n    \n}","name":"Sound","description":"","type":"sound"}]},{"ver":"0.1","info":{"id":"4sXBRn","date":"1495514713","viewed":19914,"name":"Luminescence","username":"BigWIngs","description":"My entry for the monthly challenge on r\/proceduralgeneration \nUse the mouse to look around. Uncomment the SINGLE define to see one specimen by itself.\nCode is a bit of a mess, too lazy to clean up. Hope you like it!","likes":345,"published":1,"flags":64,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dlXz7","filepath":"https:\/\/soundcloud.com\/klauslunde\/zebra-tribute","previewfilepath":"https:\/\/soundcloud.com\/klauslunde\/zebra-tribute","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Luminescence by Martijn Steinrucken aka BigWings - 2017\n\/\/ Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ My entry for the monthly challenge (May 2017) on r\/proceduralgeneration \n\/\/ Use the mouse to look around. Uncomment the SINGLE define to see one specimen by itself.\n\/\/ Code is a bit of a mess, too lazy to clean up. Hope you like it!\n\n\/\/ Music by Klaus Lunde\n\/\/ https:\/\/soundcloud.com\/klauslunde\/zebra-tribute\n\n\/\/ YouTube: The Art of Code -> https:\/\/www.youtube.com\/channel\/UCcAlTqd9zID6aNX3TzwxJXg\n\/\/ Twitter: @The_ArtOfCode\n\n#define INVERTMOUSE -1.\n\n#define MAX_STEPS 100.\n#define VOLUME_STEPS 8.\n\/\/#define SINGLE\n#define MIN_DISTANCE 0.1\n#define MAX_DISTANCE 100.\n#define HIT_DISTANCE .01\n\n#define S(x,y,z) smoothstep(x,y,z)\n#define B(x,y,z,w) S(x-z, x+z, w)*S(y+z, y-z, w)\n#define sat(x) clamp(x,0.,1.)\n#define SIN(x) sin(x)*.5+.5\n\nconst vec3 lf=vec3(1., 0., 0.);\nconst vec3 up=vec3(0., 1., 0.);\nconst vec3 fw=vec3(0., 0., 1.);\n\nconst float halfpi = 1.570796326794896619;\nconst float pi = 3.141592653589793238;\nconst float twopi = 6.283185307179586;\n\n\nvec3 accentColor1 = vec3(1., .1, .5);\nvec3 secondColor1 = vec3(.1, .5, 1.);\n\nvec3 accentColor2 = vec3(1., .5, .1);\nvec3 secondColor2 = vec3(.1, .5, .6);\n\nvec3 bg;\t \t\/\/ global background color\nvec3 accent;\t\/\/ color of the phosphorecence\n\nfloat N1( float x ) { return fract(sin(x)*5346.1764); }\nfloat N2(float x, float y) { return N1(x + y*23414.324); }\n\nfloat N3(vec3 p) {\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nstruct ray {\n    vec3 o;\n    vec3 d;\n};\n\nstruct camera {\n    vec3 p;\t\t\t\/\/ the position of the camera\n    vec3 forward;\t\/\/ the camera forward vector\n    vec3 left;\t\t\/\/ the camera left vector\n    vec3 up;\t\t\/\/ the camera up vector\n\t\n    vec3 center;\t\/\/ the center of the screen, in world coords\n    vec3 i;\t\t\t\/\/ where the current ray intersects the screen, in world coords\n    ray ray;\t\t\/\/ the current ray: from cam pos, through current uv projected on screen\n    vec3 lookAt;\t\/\/ the lookat point\n    float zoom;\t\t\/\/ the zoom factor\n};\n\nstruct de {\n    \/\/ data type used to pass the various bits of information used to shade a de object\n\tfloat d;\t\/\/ final distance to field\n    float m; \t\/\/ material\n    vec3 uv;\n    float pump;\n    \n    vec3 id;\n    vec3 pos;\t\t\/\/ the world-space coordinate of the fragment\n};\n    \nstruct rc {\n    \/\/ data type used to handle a repeated coordinate\n\tvec3 id;\t\/\/ holds the floor'ed coordinate of each cell. Used to identify the cell.\n    vec3 h;\t\t\/\/ half of the size of the cell\n    vec3 p;\t\t\/\/ the repeated coordinate\n    \/\/vec3 c;\t\t\/\/ the center of the cell, world coordinates\n};\n    \nrc Repeat(vec3 pos, vec3 size) {\n\trc o;\n    o.h = size*.5;\t\t\t\t\t\n    o.id = floor(pos\/size);\t\t\t\/\/ used to give a unique id to each cell\n    o.p = mod(pos, size)-o.h;\n    \/\/o.c = o.id*size+o.h;\n    \n    return o;\n}\n    \ncamera cam;\n\n\nvoid CameraSetup(vec2 uv, vec3 position, vec3 lookAt, float zoom) {\n\t\n    cam.p = position;\n    cam.lookAt = lookAt;\n    cam.forward = normalize(cam.lookAt-cam.p);\n    cam.left = cross(up, cam.forward);\n    cam.up = cross(cam.forward, cam.left);\n    cam.zoom = zoom;\n    \n    cam.center = cam.p+cam.forward*cam.zoom;\n    cam.i = cam.center+cam.left*uv.x+cam.up*uv.y;\n    \n    cam.ray.o = cam.p;\t\t\t\t\t\t\/\/ ray origin = camera position\n    cam.ray.d = normalize(cam.i-cam.p);\t\/\/ ray direction is the vector from the cam pos through the point on the imaginary screen\n}\n\n\n\/\/ ============== Functions I borrowed ;)\n\n\/\/  3 out, 1 in... DAVE HOSKINS\nvec3 N31(float p) {\n   vec3 p3 = fract(vec3(p) * vec3(.1031,.11369,.13787));\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n\/\/ DE functions from IQ\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)\/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)\/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\nfloat sdSphere( vec3 p, vec3 pos, float s ) { return (length(p-pos)-s); }\n\n\/\/ From http:\/\/mercury.sexy\/hg_sdf\nvec2 pModPolar(inout vec2 p, float repetitions, float fix) {\n\tfloat angle = twopi\/repetitions;\n\tfloat a = atan(p.y, p.x) + angle\/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a\/angle);\n\ta = mod(a,angle) - (angle\/2.)*fix;\n\tp = vec2(cos(a), sin(a))*r;\n\n\treturn p;\n}\n    \n\/\/ -------------------------\n\n\nfloat Dist( vec2 P,  vec2 P0, vec2 P1 ) {\n    \/\/2d point-line distance\n    \n\tvec2 v = P1 - P0;\n    vec2 w = P - P0;\n\n    float c1 = dot(w, v);\n    float c2 = dot(v, v);\n    \n    if (c1 <= 0. )  \/\/ before P0\n    \treturn length(P-P0);\n    \n    float b = c1 \/ c2;\n    vec2 Pb = P0 + b*v;\n    return length(P-Pb);\n}\n\nvec3 ClosestPoint(vec3 ro, vec3 rd, vec3 p) {\n    \/\/ returns the closest point on ray r to point p\n    return ro + max(0., dot(p-ro, rd))*rd;\n}\n\nvec2 RayRayTs(vec3 ro1, vec3 rd1, vec3 ro2, vec3 rd2) {\n\t\/\/ returns the two t's for the closest point between two rays\n    \/\/ ro+rd*t1 = ro2+rd2*t2\n    \n    vec3 dO = ro2-ro1;\n    vec3 cD = cross(rd1, rd2);\n    float v = dot(cD, cD);\n    \n    float t1 = dot(cross(dO, rd2), cD)\/v;\n    float t2 = dot(cross(dO, rd1), cD)\/v;\n    return vec2(t1, t2);\n}\n\nfloat DistRaySegment(vec3 ro, vec3 rd, vec3 p1, vec3 p2) {\n\t\/\/ returns the distance from ray r to line segment p1-p2\n    vec3 rd2 = p2-p1;\n    vec2 t = RayRayTs(ro, rd, p1, rd2);\n    \n    t.x = max(t.x, 0.);\n    t.y = clamp(t.y, 0., length(rd2));\n                \n    vec3 rp = ro+rd*t.x;\n    vec3 sp = p1+rd2*t.y;\n    \n    return length(rp-sp);\n}\n\nvec2 sph(vec3 ro, vec3 rd, vec3 pos, float radius) {\n\t\/\/ does a ray sphere intersection\n    \/\/ returns a vec2 with distance to both intersections\n    \/\/ if both a and b are MAX_DISTANCE then there is no intersection\n    \n    vec3 oc = pos - ro;\n    float l = dot(rd, oc);\n    float det = l*l - dot(oc, oc) + radius*radius;\n    if (det < 0.0) return vec2(MAX_DISTANCE);\n    \n    float d = sqrt(det);\n    float a = l - d;\n    float b = l + d;\n    \n    return vec2(a, b);\n}\n\n\nvec3 background(vec3 r) {\n\t\n    float x = atan(r.x, r.z);\t\t\/\/ from -pi to pi\t\n\tfloat y = pi*0.5-acos(r.y);  \t\t\/\/ from -1\/2pi to 1\/2pi\t\t\n    \n    vec3 col = bg*(1.+y);\n    \n\tfloat t = iTime;\t\t\t\t\/\/ add god rays\n    \n    float a = sin(r.x);\n    \n    float beam = sat(sin(10.*x+a*y*5.+t));\n    beam *= sat(sin(7.*x+a*y*3.5-t));\n    \n    float beam2 = sat(sin(42.*x+a*y*21.-t));\n    beam2 *= sat(sin(34.*x+a*y*17.+t));\n    \n    beam += beam2;\n    col *= 1.+beam*.05;\n\n    return col;\n}\n\n\n\n\nfloat remap(float a, float b, float c, float d, float t) {\n\treturn ((t-a)\/(b-a))*(d-c)+c;\n}\n\n\n\nde map( vec3 p, vec3 id ) {\n\n    float t = iTime*2.;\n    \n    float N = N3(id);\n    \n    de o;\n    o.m = 0.;\n    \n    float x = (p.y+N*twopi)*1.+t;\n    float r = 1.;\n    \n    float pump = cos(x+cos(x))+sin(2.*x)*.2+sin(4.*x)*.02;\n    \n    x = t + N*twopi;\n    p.y -= (cos(x+cos(x))+sin(2.*x)*.2)*.6;\n    p.xz *= 1. + pump*.2;\n    \n    float d1 = sdSphere(p, vec3(0., 0., 0.), r);\n    float d2 = sdSphere(p, vec3(0., -.5, 0.), r);\n    \n    o.d = smax(d1, -d2, .1);\n    o.m = 1.;\n    \n    if(p.y<.5) {\n        float sway = sin(t+p.y+N*twopi)*S(.5, -3., p.y)*N*.3;\n        p.x += sway*N;\t\/\/ add some sway to the tentacles\n        p.z += sway*(1.-N);\n        \n        vec3 mp = p;\n    \tmp.xz = pModPolar(mp.xz, 6., 0.);\n        \n        float d3 = length(mp.xz-vec2(.2, .1))-remap(.5, -3.5, .1, .01, mp.y);\n    \tif(d3<o.d) o.m=2.;\n        d3 += (sin(mp.y*10.)+sin(mp.y*23.))*.03;\n        \n        float d32 = length(mp.xz-vec2(.2, .1))-remap(.5, -3.5, .1, .04, mp.y)*.5;\n        d3 = min(d3, d32);\n        o.d = smin(o.d, d3, .5);\n        \n        if( p.y<.2) {\n             vec3 op = p;\n    \t\top.xz = pModPolar(op.xz, 13., 1.);\n            \n        \tfloat d4 = length(op.xz-vec2(.85, .0))-remap(.5, -3., .04, .0, op.y);\n    \t\tif(d4<o.d) o.m=3.;\n            o.d = smin(o.d, d4, .15);\n        }\n    }    \n    o.pump = pump;\n    o.uv = p;\n    \n    o.d *= .8;\n    return o;\n}\n\nvec3 calcNormal( de o ) {\n\tvec3 eps = vec3( 0.01, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(o.pos+eps.xyy, o.id).d - map(o.pos-eps.xyy, o.id).d,\n\t    map(o.pos+eps.yxy, o.id).d - map(o.pos-eps.yxy, o.id).d,\n\t    map(o.pos+eps.yyx, o.id).d - map(o.pos-eps.yyx, o.id).d );\n\treturn normalize(nor);\n}\n\nde CastRay(ray r) {\n    float d = 0.;\n    float dS = MAX_DISTANCE;\n    \n    vec3 pos = vec3(0., 0., 0.);\n    vec3 n = vec3(0.);\n    de o, s;\n    \n    float dC = MAX_DISTANCE;\n    vec3 p;\n    rc q;\n    float t = iTime;\n    vec3 grid = vec3(6., 30., 6.);\n        \n    for(float i=0.; i<MAX_STEPS; i++) {\n        p = r.o + r.d*d;\n        \n        #ifdef SINGLE\n        s = map(p, vec3(0.));\n        #else\n        p.y -= t;  \/\/ make the move up\n        p.x += t;  \/\/ make cam fly forward\n            \n        q = Repeat(p, grid);\n    \t\n        vec3 rC = ((2.*step(0., r.d)-1.)*q.h-q.p)\/r.d;\t\/\/ ray to cell boundary\n        dC = min(min(rC.x, rC.y), rC.z)+.01;\t\t\/\/ distance to cell just past boundary\n        \n        float N = N3(q.id);\n        q.p += (N31(N)-.5)*grid*vec3(.5, .7, .5);\n        \n\t\tif(Dist(q.p.xz, r.d.xz, vec2(0.))<1.1)\n        \/\/if(DistRaySegment(q.p, r.d, vec3(0., -6., 0.), vec3(0., -3.3, 0)) <1.1) \n        \ts = map(q.p, q.id);\n        else\n            s.d = dC;\n        \n        \n        #endif\n           \n        if(s.d<HIT_DISTANCE || d>MAX_DISTANCE) break;\n        d+=min(s.d, dC);\t\/\/ move to distance to next cell or surface, whichever is closest\n    }\n    \n    if(s.d<HIT_DISTANCE) {\n        o.m = s.m;\n        o.d = d;\n        o.id = q.id;\n        o.uv = s.uv;\n        o.pump = s.pump;\n        \n        #ifdef SINGLE\n        o.pos = p;\n        #else\n        o.pos = q.p;\n        #endif\n    }\n    \n    return o;\n}\n\nfloat VolTex(vec3 uv, vec3 p, float scale, float pump) {\n    \/\/ uv = the surface pos\n    \/\/ p = the volume shell pos\n    \n\tp.y *= scale;\n    \n    float s2 = 5.*p.x\/twopi;\n    float id = floor(s2);\n    s2 = fract(s2);\n    vec2 ep = vec2(s2-.5, p.y-.6);\n    float ed = length(ep);\n    float e = B(.35, .45, .05, ed);\n    \n   \tfloat s = SIN(s2*twopi*15. );\n\ts = s*s; s = s*s;\n    s *= S(1.4, -.3, uv.y-cos(s2*twopi)*.2+.3)*S(-.6, -.3, uv.y);\n    \n    float t = iTime*5.;\n    float mask = SIN(p.x*twopi*2. + t);\n    s *= mask*mask*2.;\n    \n    return s+e*pump*2.;\n}\n\nvec4 JellyTex(vec3 p) { \n    vec3 s = vec3(atan(p.x, p.z), length(p.xz), p.y);\n    \n    float b = .75+sin(s.x*6.)*.25;\n    b = mix(1., b, s.y*s.y);\n    \n    p.x += sin(s.z*10.)*.1;\n    float b2 = cos(s.x*26.) - s.z-.7;\n   \n    b2 = S(.1, .6, b2);\n    return vec4(b+b2);\n}\n\nvec3 render( vec2 uv, ray camRay, float depth ) {\n    \/\/ outputs a color\n    \n    bg = background(cam.ray.d);\n    \n    vec3 col = bg;\n    de o = CastRay(camRay);\n    \n    float t = iTime;\n    vec3 L = up;\n    \n\n    if(o.m>0.) {\n        vec3 n = calcNormal(o);\n        float lambert = sat(dot(n, L));\n        vec3 R = reflect(camRay.d, n);\n        float fresnel = sat(1.+dot(camRay.d, n));\n        float trans = (1.-fresnel)*.5;\n        vec3 ref = background(R);\n        float fade = 0.;\n        \n        if(o.m==1.) {\t\/\/ hood color\n            float density = 0.;\n            for(float i=0.; i<VOLUME_STEPS; i++) {\n                float sd = sph(o.uv, camRay.d, vec3(0.), .8+i*.015).x;\n                if(sd!=MAX_DISTANCE) {\n                    vec2 intersect = o.uv.xz+camRay.d.xz*sd;\n\n                    vec3 uv = vec3(atan(intersect.x, intersect.y), length(intersect.xy), o.uv.z);\n                    density += VolTex(o.uv, uv, 1.4+i*.03, o.pump);\n                }\n            }\n            vec4 volTex = vec4(accent, density\/VOLUME_STEPS); \n            \n            \n            vec3 dif = JellyTex(o.uv).rgb;\n            dif *= max(.2, lambert);\n\n            col = mix(col, volTex.rgb, volTex.a);\n            col = mix(col, vec3(dif), .25);\n\n            col += fresnel*ref*sat(dot(up, n));\n\n            \/\/fade\n            fade = max(fade, S(.0, 1., fresnel));\n        } else if(o.m==2.) {\t\t\t\t\t\t\/\/ inside tentacles\n            vec3 dif = accent;\n    \t\tcol = mix(bg, dif, fresnel);\n            \n            col *= mix(.6, 1., S(0., -1.5, o.uv.y));\n            \n            float prop = o.pump+.25;\n            prop *= prop*prop;\n            col += pow(1.-fresnel, 20.)*dif*prop;\n            \n            \n            fade = fresnel;\n        } else if(o.m==3.) {\t\t\t\t\t\t\/\/ outside tentacles\n        \tvec3 dif = accent;\n            float d = S(100., 13., o.d);\n    \t\tcol = mix(bg, dif, pow(1.-fresnel, 5.)*d);\n        }\n        \n        fade = max(fade, S(0., 100., o.d));\n        col = mix(col, bg, fade);\n        \n        if(o.m==4.)\n            col = vec3(1., 0., 0.);\n    } \n     else\n        col = bg;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = iTime*.04;\n    \n    vec2 uv = (fragCoord.xy \/ iResolution.xy);\n    uv -= .5;\n    uv.y *= iResolution.y\/iResolution.x; \n    \n    vec2 m = iMouse.xy\/iResolution.xy;\n    \n    if(m.x<0.05 || m.x>.95) {\t\t\t\t\/\/ move cam automatically when mouse is not used\n    \tm = vec2(t*.25, SIN(t*pi)*.5+.5);\n    }\n\t\n    accent = mix(accentColor1, accentColor2, SIN(t*15.456));\n    bg = mix(secondColor1, secondColor2, SIN(t*7.345231));\n    \n    float turn = (.1-m.x)*twopi;\n    float s = sin(turn);\n    float c = cos(turn);\n    mat3 rotX = mat3(c,  0., s, 0., 1., 0., s,  0., -c);\n    \n    #ifdef SINGLE\n    float camDist = -10.;\n    #else\n    float camDist = -.1;\n    #endif\n    \n    vec3 lookAt = vec3(0., -1., 0.);\n    \n    vec3 camPos = vec3(0., INVERTMOUSE*camDist*cos((m.y)*pi), camDist)*rotX;\n   \t\n    CameraSetup(uv, camPos+lookAt, lookAt, 1.);\n    \n    vec3 col = render(uv, cam.ray, 0.);\n    \n    col = pow(col, vec3(mix(1.5, 2.6, SIN(t+pi))));\t\t\/\/ post-processing\n    float d = 1.-dot(uv, uv);\t\t\/\/ vignette\n    col *= (d*d*d)+.1;\n    \n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"lsVXRh","date":"1466849689","viewed":19876,"name":"Lightsaber Duel","username":"Maurogik","description":"Here goes 6 months worth of lunch time programming !\nSort of procedural animation and a healthy dose of @SebHillaire volumetric light integration.","likes":198,"published":3,"flags":0,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"\/media\/a\/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"\/media\/ap\/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"\/media\/a\/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"\/media\/ap\/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define FOCAL_LENGTH 1.2\n#define MOVE_SPEED 20.0\n#define MAX_STEPS 256\n#define MIN_DIST 0.01\n#define MAX_DIST 75.0\n#define AMBIANT_LIGHT 0.01\n#define DAY_LENGTH 15.0 \n\n#define PI 3.14159265359\n\n\/\/comment this out if your GPU can't handle the shader,\n\/\/you'll only get ont character, but it should run much faster\n#define TWO_EGGS\n\n\/\/quality settings, uncomment higher quality for better results\n\/\/or comment out higher quality for better performances\n\n\/\/#define QUALITY_HIGH\n#define QUALITY_MEDIUM \n\/\/#define QUALITY_LOW \n\/\/#define QUALITY_OFF\n\n#if defined(QUALITY_HIGH)\n\n\t#define VOL_SHADOW_STEPS 5.0\n\t#define MIN_STEP_BIAS 0.3\n\t#define VOL_FOG 1\n\t#define VOL_SHADOW 1\n\t#define LIGHT_QUALITY 1\n\n#elif defined(QUALITY_MEDIUM)\n\n\t#define VOL_SHADOW_STEPS 2.0\n\t#define MIN_STEP_BIAS 0.6\n\t#define VOL_FOG 1\n\t#define VOL_SHADOW 1\n\t#define LIGHT_QUALITY 1\n\n#elif defined(QUALITY_LOW)\n\n\t#define VOL_SHADOW_STEPS 1.0\n\t#define MIN_STEP_BIAS 0.9\n\t#define VOL_FOG 1\n\t#define VOL_SHADOW 0\n\t#define LIGHT_QUALITY 0\n\n#elif defined(QUALITY_OFF)\n\n\t#define VOL_SHADOW_STEPS 1.0\n\t#define MIN_STEP_BIAS 1.0\n\t#define VOL_FOG 0\n\t#define VOL_SHADOW 0\n\t#define LIGHT_QUALITY 0\n\n#endif\n\n\/\/saber colors\n#define LASER_STR 1.5\n#define LASER_CORE vec3(0.5)\n#define LASER_LIGHT_STR 1.5\n#define PURPLE vec3(0.5, 0.0, 1.5)\n#define GREEN vec3(0.0, 1.0, 0.0)\n#define BLUE vec3(0., 0., 1.0)*2.\n#define RED vec3(1.0, 0.0, 0.0)*1.5\n#define YELLOW vec3(0.6, 0.6, 0.0)\n\n\/\/paste in one of the colors from above\n#define JEDI GREEN\n#define SITH RED\n\n#define JEDI_SABER_NOISE 2.\n#define SITH_SABER_NOISE 5.\n\n\/\/helpers\nvec3 zero = vec3(0.0);\n\n\/\/scene data\nvec3 projectionUp;\nvec3 projectionRight;\nvec3 projectionForward;\nvec3 projectionCenter;\nvec3 cameraOffset;\nfloat dayProgress;\nfloat minSurfaceDist;\n\n\/\/positions\nvec4  plane         = vec4(vec3(0.0, 1.0, 0.0), 1.0);\nvec3  sunLightPos;\n\n\/\/colors\nvec4 groundColor    = vec4(vec3(0.08), 0.7);\nvec4 handleColor    = vec4(vec3(0.1), 0.3);\nvec3 sunLightColor;\nvec3 skyColor;\nvec3 fogColor;\n\nfloat s_pixelRand = 0.0;\nfloat s_time = 0.0;\n\nfloat mapToRange(float fromMin, float fromMax, float toMin, float toMax, float val)\n{\n    val = max(fromMin, (min(fromMax, val)));\/\/clamp in range if outside\n    float fromSize = fromMax - fromMin;\n    val = (val - fromMin) \/ fromSize;\n    return mix(toMin, toMax, val);\n}\n\n\/\/fast noise\nvec3 noise3( in vec3 x )\n{\n    return textureLod(iChannel0, x.xy\/x.z, 0.0).xyz;   \n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#if VOL_FOG\n\nfloat layeredNoise( vec3 p )\n{\n    float f;\n    f  = 0.5000* textureLod( iChannel1, p, 0.0 ).x; p = p*2.0;\n    f += 0.2500* textureLod( iChannel1, p, 0.0 ).x; p = p*2.0;\n    f += 0.1250* textureLod( iChannel1, p, 0.0 ).x; p = p*2.0;\n    f += 0.0800* textureLod( iChannel1, p, 0.0 ).x; p = p*2.0;\n    f += 0.0625* textureLod( iChannel1, p, 0.0 ).x; p = p*2.0;\n    \n    return f;\n}\n\n#define CONSTANT_FOG 0.03\n\/\/ To simplify: wavelength independent scattering and extinction\nfloat atmThickness(in vec3 pos)\n{\n    float disp1 = 0.5;\n    float disp2 = 0.5;\n    \n    \/\/disp1 = mapToRange(0.5, 1.0, 0.1, 1.0, layeredNoise(pos.xz*0.015 + s_time*0.008));\n    disp1 = mapToRange(0.3, 1.0, 0.1, 1.0, layeredNoise(pos*0.02 - vec3(0.0, 1.0, 0.0)*s_time*0.01));\n    \/\/float noise = clamp(mapToRange(0.4, 0.8, 0.0, 1.0, disp2),0.0,1.0);\n    float fogMax  = -1. - smoothstep(8.0, -3.0, length(pos.xz));\n   \tfloat fogMin = fogMax + disp1*3.0;    \n    float heightFog = smoothstep(fogMin, fogMax, pos.y);\n\n    heightFog = min(1.0, heightFog * 3.0);\n    \n    return CONSTANT_FOG + heightFog * 2.0;  \n}\n\nfloat phaseFunctionVal = 1.0\/(4.0*PI);\n#define PHASE_FUNC phaseFunctionVal\n\nfloat volumetricShadow(in vec3 from, in vec3 dir)\n{\n    float shadow = 1.0;\n    float cloud = 0.0;\n    float dd = 1.0 \/ VOL_SHADOW_STEPS;    \n    vec3 pos;\n    for(float s=0.5; s < VOL_SHADOW_STEPS - 0.1; s+=1.0)\/\/ start at 0.5 to sample at center of integral part\n    {\n        pos = from + dir*(s\/VOL_SHADOW_STEPS);\n        cloud = atmThickness(pos);\n        shadow *= exp(-cloud * dd);\n    }\n    return shadow;\n}\n\n#endif \n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec2 pixelToNormalizedspace(vec2 pixel)\n{\n    vec2 res;\n    res.x = pixel.x * 2.0 \/ iResolution.x - 1.0;\n    res.y = pixel.y * 2.0 \/ iResolution.y - 1.0;\n    res.y *= iResolution.y \/ iResolution.x;\/\/correct aspect ratio\n    return res;\n}\n\nfloat fCapsule(vec3 p, float r, float c) {\n    return mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\nfloat fSphere(vec3 d, float r)\n{\n    return length(d) - r;\n}\n\nfloat fPlane(vec4 plane, vec3 point)\n{    \n    return abs(dot(plane, vec4(point, 1.0)));\n}\n\n\/\/ Hexagonal prism, circumcircle variant\nfloat fHexagonCircumcircle(vec3 p, vec2 h) {\n\tvec3 q = abs(p);\n\t\/\/return max(q.y - h.y, max(q.x*sqrt(3)*0.5 + q.z*0.5, q.z) - h.x);\n\t\/\/this is mathematically equivalent to this line, but less efficient:\n\treturn max(q.y - h.y, max(dot(vec2(cos(PI\/3.0), sin(PI\/3.0)), q.zx), q.z) - h.x);\n}\n\n\/\/ Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)\/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nfloat linearstep(float e1, float e2, float v)\n{\n \tv = clamp(v, e1, e2);\n    return (v - e1)\/(e2 - e1);\n}\n\nfloat fEgg(vec3 d, float r, vec3 deform)\n{\n    return length(d\/deform) - r;\n}\n\n#define IMAT3 mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0))\n\nfloat maxDist = 100.0;\n\n\/\/constants\nfloat   handRSize = 0.15;\nfloat   handLSize = 0.15;\nfloat   footRSize = 0.22;\nfloat   footLSize = 0.22;\nvec3    eyeRPos = vec3(0.2, 0.2, 0.0);\nvec3    eyeLPos = vec3(-0.2, 0.2, 0.0);\nfloat   eyeRSize = 0.105;\nfloat   eyeLSize = 0.105;\nvec3    mouthPos = vec3(0.0, 0.0, -0.03);\nfloat   mouthSize = 0.1;\nfloat   mouthXRot = PI*0.325;\nfloat   handleRadius = 0.1;\nfloat   handleLen = 0.35;   \nvec4 \tbodyColor = vec4(vec3(0.1), 0.8);\nvec4    eyeColor = vec4(vec3(0.9), 0.1);\nvec4    eyeInsideColor = vec4(vec3(0.1), 0.1);\nvec4\tmouthColor = vec4(1.0, 1.0, 0.0, 0.1);\n\nstruct StickmanData\n{\n    vec3 stickmanPos;\n    \/\/relative to stickManPos\n    vec3 bodyPos;\n    vec3 bodyDeform;\n    vec3 headPos;\n    vec3 handRPos;\n    vec3 handLPos;\n    vec3 handRDeform;\n    vec3 handLDeform;\n    mat3 handRRot;\n    mat3 handLRot;\n\n    vec3 footRPos;\n    vec3 footLPos;\n    mat3 footRRot;\n    mat3 footLRot;\n    vec3 footRDeform;\n    vec3 footLDeform;\n\n    mat3 invBodyRot;\n    mat3 invStickmanRot;\n    mat3 invMouthRot;\n\n    \/\/relative to headPos\n\n    vec3 eyeRDeform;\n    vec3 eyeLDeform;\n    \n    vec3 mouthDeform;    \n\n    vec3 saberTarget;\n    vec3 saberPos;\n    float saberRadius;\n    float saberLen;\n    float saberNoise;\n    mat3 invSaberRot;\n    \n    vec3 laserColor;\n    vec3 laserLight;\n};\n\nStickmanData jediData;\nStickmanData sithData;\n\nstruct FieldData\n{\n    vec3 saberDiff;\n    vec3 saberOffset;\n    vec3 handleOffset;\n    float fSaber;\n};\n    \nFieldData jediFieldData;\nFieldData sithFieldData;\n    \nvoid rotationZ(float r, out mat3 mat)\n{\n    mat[0].x = cos(r);  mat[0].y = sin(r);  mat[0].z = 0.;\n    mat[1].x = -sin(r); mat[1].y = cos(r);  mat[1].z = 0.;\n    mat[2].x = 0.;      mat[2].y = 0.;      mat[2].z = 1.;\n}\n\nvoid rotationY(float r, out mat3 mat)\n{\n    mat[0].x = cos(r);  mat[0].y = 0.;      mat[0].z = -sin(r);\n    mat[1].x = 0.;      mat[1].y = 1.;      mat[1].z = 0.;\n    mat[2].x = sin(r);  mat[2].y = 0.;      mat[2].z = cos(r);\n}\n\nvoid rotationX(float r, out mat3 mat)\n{\n    mat[0].x = 1.;      mat[0].y = 0.;      mat[0].z = 0.;\n    mat[1].x = 0.;      mat[1].y = cos(r);  mat[1].z = sin(r);\n    mat[2].x = 0.;      mat[2].y = -sin(r); mat[2].z = cos(r);\n}\n\n\/\/wonderfull function from iq's article \n\/\/https:\/\/iquilezles.org\/articles\/noacos\nvoid rotationAlign( vec3 d, vec3 z, out mat3 mat )\n{\n    vec3  v = cross( z, d );\n    float c = dot( z, d );\n    float k = 1.\/(1. + c);\n\n    mat = mat3(    v.x*v.x*k + c,     v.y*v.x*k - v.z,    v.z*v.x*k + v.y,\n                   v.x*v.y*k + v.z,   v.y*v.y*k + c,      v.z*v.y*k - v.x,\n                   v.x*v.z*k - v.y,   v.y*v.z*k + v.x,    v.z*v.z*k + c    );\n}\n\n\/\/ugly hack to get partial look at rotation, works well enough\nvoid rotationAlign( vec3 targ, vec3 dir, float i, out mat3 mat )\n{\n    vec3 diff = targ - dir;\n    if(dot(diff, diff) > 0.1)\n    {\n \t\tvec3 mixed = normalize(mix(targ, dir, 1.0 - i));\n    \trotationAlign(mixed, dir, mat);\n    }\n    else\n    {\n        mat = IMAT3;\n    }\n}\n\n\/\/pre-computes field data that doesn't change during the raymarching\nvoid computeFieldData(in StickmanData data, out FieldData fieldData)\n{\n    fieldData.saberDiff = data.bodyPos + data.saberPos*data.bodyDeform;\n    fieldData.saberOffset = vec3(0.0, -data.saberLen - handleLen, 0.0);\n    fieldData.handleOffset = vec3(0.0, handleLen*0.5, 0.0);\n    fieldData.fSaber = MAX_DIST;\n}\n\nfloat fSaber(vec3 d, in StickmanData data, in FieldData fieldData)\n{\n    vec3 saberDiff = d - fieldData.saberDiff;\n    saberDiff = data.invSaberRot*saberDiff;\n    float saber = fCapsule(saberDiff + fieldData.saberOffset,\n                           data.saberRadius\n                           *(pow(mapToRange(data.saberLen*1.95, data.saberLen*2.+handleLen, 1.0, 0.01, saberDiff.y), 0.35)) \n                           *mapToRange(0.0, 1.0, 0.85, 1., sin(s_time*30.-saberDiff.y*data.saberNoise)),\n                           data.saberLen);\n    \n    return saber;\n}\n\nfloat fHandle(vec3 d, in StickmanData data, in FieldData fieldData)\n{\n    vec3 saberDiff = d - fieldData.saberDiff;\n    saberDiff = data.invSaberRot*saberDiff;\n    float handle = fCapsule(saberDiff + fieldData.handleOffset,\n                           handleRadius, \n                           handleLen);\n    return handle;\n}\n\nvec4 fStickman(vec3 d, in StickmanData data, in FieldData fieldData, inout float minDist)\n{\n    float r = s_time * 3.14 * 0.5;        \n    \n    vec3 bodyD = data.invBodyRot*(d - data.bodyPos);\n    vec3 fixedBodyD = d - data.bodyPos;\n    \/\/main body\n    float body = fEgg(bodyD, 1.0, data.bodyDeform); \n    float subBody = fEgg(bodyD + vec3(0.0, 0.6, 0.5), 1.0, data.bodyDeform*vec3(0.8, 0.8, 0.8));\n    \/\/eyes\n    float eye = fEgg(bodyD - (data.headPos + eyeLPos)*data.bodyDeform, eyeLSize, data.eyeLDeform);   \n    eye = min(eye, fEgg(bodyD - (data.headPos + eyeRPos)*data.bodyDeform, eyeRSize, data.eyeRDeform));\n    \n    float subEye = fEgg(bodyD - (data.headPos + eyeLPos + vec3(0.07, -0.03 , -0.1))*data.bodyDeform, \n                        eyeLSize, data.eyeLDeform*vec3(0.3, 0.4, 0.3));    \n    subEye = min(subEye, fEgg(bodyD - (data.headPos + eyeRPos + vec3(-0.07, -0.03 , -0.1))*data.bodyDeform, \n                        eyeLSize, data.eyeLDeform*vec3(0.3, 0.4, 0.3)));    \n    eye = min(eye, subEye);\n    \n    \/\/mouth\n    float mouth = fEgg(\n        data.invMouthRot*(bodyD - (data.headPos + mouthPos)*data.bodyDeform),\n        mouthSize, data.mouthDeform);\n    \n    \/\/hands\n    float hands;\n    hands = fEgg(data.handRRot*(fixedBodyD - data.handRPos*data.bodyDeform), \n                          handRSize, data.handRDeform);\n    hands = min(hands, fEgg(data.handLRot*(fixedBodyD - data.handLPos*data.bodyDeform),  \n                          handLSize, data.handLDeform));\n    \/\/feet  \n    float feet;\n    feet = fEgg(data.footRRot*(d - (data.footRPos)),\n                          footRSize, data.footRDeform);\n    feet = min(feet, fEgg(data.footLRot*(d - (data.footLPos)),\n                          footLSize, data.footLDeform));\n    \/\/saber\n    float saber = fieldData.fSaber;\/\/fSaber(d, data, fieldData);\n    float handle = fHandle(d, data, fieldData);\n    \n    minDist = min(minDist, body);\n    minDist = min(minDist, eye);\n    minDist = min(minDist, mouth);\n    minDist = min(minDist, hands);\n    minDist = min(minDist, feet);\n    minDist = min(minDist, saber);\n    minDist = min(minDist, handle);\n    \n    vec4 color = vec4(0.0);\/\/egg bolor\n    color += mix(bodyColor, vec4(vec3(0.9), 0.8), step(subBody, body))*step(body, minDist);\n    color += mix(eyeColor, bodyColor, step(subEye, eye))*step(eye, minDist);\n    color += bodyColor*step(hands, minDist);\n    color += bodyColor*step(feet, minDist);\n    color += mouthColor*step(mouth, minDist);\n    color += vec4(data.laserColor, 0.0)*step(saber, minDist);\n    color += handleColor*step(handle, minDist);\n    \n    return color;\n}\n\n\/\/transition functions\nfloat pingPong(float p)\n{\n    return 1.0-abs(p*2.0 - 1.0);   \n}  \n\nfloat minHandDist = 1.2;\nfloat maxHandDist = 1.7;\n\nvoid invKinOneHand(float i, mat3 alignRot, inout StickmanData data)\n{\n    data.handLPos = data.handLPos*alignRot;\n}\n\nvoid invKinTwoHand(float i, mat3 alignRot, inout StickmanData data)\n{\n    vec3 f = vec3(0.0, 0.0, 1.0);\n    vec3 dir = normalize(mix(f, data.invSaberRot*f, i));\n    \n    mat3 rot;\n    rotationAlign(f, dir, rot);        \n    data.handLRot = data.handLRot*rot;\n    \n    vec3 target = data.handRPos + vec3(0.0, -0.3, 0.)*data.invSaberRot;\n    float l = mix(length(data.handLPos), max(length(target), minHandDist), i);\n    data.handLPos = normalize(mix(data.handLPos, target, pow(i, 0.5)))*l;\n}\n\nvec3 neutralTarget = vec3(0.0, 0.0, -1.0);\nfloat ll = 1.0;\/\/leg length ratio\n\nvoid invKinematics(float twoHanded, float hit, inout StickmanData data)\n{    \n    data.saberTarget = normalize(data.saberTarget);\n    mat3 alignRot;\n    \n    \/\/rotate saber\n    rotationAlign(data.saberTarget, vec3(0.0, 1.0, 0.0)*data.invSaberRot, hit, alignRot);\n    data.invSaberRot = data.invSaberRot*alignRot; \n    \n    \/\/move hand\/handle\n    data.saberPos = mix(data.saberPos, maxHandDist*normalize(data.saberPos), hit);\n    rotationAlign(data.saberTarget, neutralTarget, .8, alignRot);\n    vec3 armTarget = neutralTarget * alignRot;\n    rotationAlign(armTarget, normalize(data.saberPos), hit, alignRot);\n    data.saberPos *= alignRot;\n    \n    data.saberPos = max(length(data.saberPos), minHandDist) * normalize(data.saberPos);\n    data.handRPos = data.saberPos;\n    data.handRRot = data.invSaberRot;\n    \/\/move body stance\n    data.bodyPos = mix(data.footRPos, data.footLPos, 0.5) + vec3(0.0, data.bodyPos.y, 0.1);\n    \/\/turn body\n    vec3 bodyRestDir = normalize(vec3(1.0, -0.5, -.5));\n    vec3 saberDir = normalize(mix(bodyRestDir, data.saberPos, 0.3));    \n    rotationAlign(saberDir, bodyRestDir, alignRot);\n    data.invBodyRot *= alignRot;\n    \/\/back hand rot\n    saberDir = normalize(mix(bodyRestDir, data.saberPos, 1.0 - twoHanded));    \n    rotationAlign(saberDir, bodyRestDir, alignRot);\n    \n    \/\/squint eyes while you hit, just because ....\n    data.eyeLDeform.y *= 1.0 - hit*0.4;\n    data.eyeRDeform.y *= 1.0 - hit*0.5;\n    \n    invKinOneHand(1.0 - twoHanded, alignRot, data);\n    invKinTwoHand(twoHanded, alignRot, data);\n}\n\nfloat frontLoop(float i, float t, inout StickmanData data)\n{\n    float dur = 1.0;\n    float r = mod(t, dur)\/dur;\n    float p = pingPong(r)*i;\n    \n    mat3 rotY;\n    rotationY(PI*i*-0.15, rotY);\n    \n    mat3 rotX;\n    rotationX(PI*2.0*r*i, rotX);\n    \n    data.invSaberRot = rotX*data.invSaberRot*rotY;\n    \n    vec3 offset = vec3(0., .7, .7)*.4*data.invSaberRot;\n    data.saberPos.x += 0.7*i;\n    data.saberPos.y += 0.6*i;\n    data.saberPos.z += 0.3*i;\n    data.saberPos -= offset;\n            \n    return 0.0;\n}\n\nfloat backLoop(float i, float t, inout StickmanData data)\n{\n    float dur = 1.0;\n    float r = mod(t, dur)\/dur;\n    float p = pingPong(r)*i;\n    \n    mat3 rotY;\n    rotationY(PI*i*-0.1, rotY);\n    \n    mat3 rotX;\n    rotationX(PI*2.*r*i, rotX);\n    \n    data.invSaberRot = rotX*data.invSaberRot*rotY;\n    \n    vec3 offset = vec3(0., .65, .7)*.3*data.invSaberRot;\n        \n    data.saberPos.y += 0.55*i;\n    data.saberPos -= offset;\n            \n    return 0.0;    \n}\n\nfloat nullMove(float i, float m, inout StickmanData data)\n{ \n    return 0.0;\n}\n\nfloat nullPose(float i, inout StickmanData data)\n{ \n    return 0.0;\n}\n\nfloat whirlingHit(float i, float m, inout StickmanData data)\n{    \n    float p1d = 0.3;\n    float p2d = 0.4;\n    float p3d = 0.3;\n    \n    float t = i;\n    \/\/arming part\n    float p1 = smoothstep(0.0, p1d, t);    \n    \/\/hitting part\n    float p2 = linearstep(p1d, p1d + p2d, t);\n    p2 = min(m, p2);\n    \/\/back to rest part\n    float p3 = linearstep(p1d + p2d, p1d + p2d + p3d, t);\n    \n    \/\/move the target on trajectory\n    vec3 start = vec3(0.8, -0.3, 0.3);\n    vec3 end = vec3(-0.5, -.1, -0.45);\n    vec3 target = mix(start, end, p2);\n    target.y += 0.3*pingPong(p2);\n    \/\/target = mix(target, neutralTarget, pow(p3, 0.4));\n    data.saberTarget = mix(data.saberTarget, target, p1);\n\n    \/\/stance\n    data.footRPos = mix(data.footRPos, ll*vec3(0.4, 0.1, data.footLPos.z + 1.2), (p1 - p3));\n    data.footRPos = mix(data.footRPos, ll*vec3(0.4, 0.1, data.footLPos.z - 1.2), pow(p2 - p3, 2.0));\n    data.footRPos.y += pingPong(p1 - p3)*ll*0.1;\n    \/\/footRPos.y += pingPong(p2 - p3)*ll*0.1;\n    \n    float landing = pingPong(linearstep(p1d + p2d*.7, p1d + p2d + p3d*.5, t));\n    float takeoff = 1.0 - pow(1.0 - (smoothstep(0., p1d*0.6, t) - smoothstep(p1d*0.6, p1d + p2d*0.1, t)), 2.0);    \n    float jump = 1.0 - pow(1.0 - (smoothstep(p1d, p1d + p2d*0.5, t) - smoothstep(p1d + p2d*0.5, p1d + p2d, t)), 3.0);\n    \n    data.bodyPos.y += -takeoff*.3 + jump*.4 - landing*.2;\n    data.bodyDeform.y += -takeoff*.1 + jump*.05- landing*.1;\n    data.stickmanPos.y += jump*1.;\n    \/\/footRPos.y -= jump*0.4;\n    data.footLPos.y -= jump*0.4;\n    \n    float r = smoothstep(p1d, p1d + p2d, t);\n    mat3 rotY;\n    rotationY(PI*-2.*r, rotY);\n    \n    mat3 rotX;\n    rotationX(PI*.1*pow((p1 + jump)*.5, 2.0), rotX);\n    \n    data.invStickmanRot = rotY*rotX*data.invStickmanRot;\n    \n    return p1 - p3;\n}\n\nfloat forwardHit(float i, float m, inout StickmanData data)\n{   \n    float p = step(i, 0.5)*pow(i*2.0, 2.0) + step(0.5, i)*smoothstep(1.0, 0.5, i);\/\/pingPong(i);\n    data.saberTarget = step(i, 0.001)*data.saberTarget + step(0.001, i)*vec3(0.3, 0., -2.0);\n    \n    float mp = min(m, p);\n    \/\/stance\n    data.footRPos = mix(data.footRPos, ll*vec3(0.4, 0.1, data.footLPos.z - 1.5), mp);\n    data.footRPos.y += pingPong(p)*ll*0.1;\n    return mp;\n}\n\nfloat upDownHit(float i, float m, inout StickmanData data)\n{\n    float p1d = 0.2;\n    float p2d = 0.6;\n    float p3d = 0.2;\n    \n    float t = i;\n    \/\/arming part\n    float p1 = smoothstep(0.0, p1d, t);\n    float p2 = 1.0 - pow(1.0 - linearstep(p1d, p1d + p2d, t), 1.0);\n    p2 = min(m, p2);\n    float p3 = linearstep(p2d, p1d + p2d + p3d, t);\n    \n    \/\/move the target on trajectory\n    vec3 start = vec3(0.8, .35, 0.3);\n    vec3 end = vec3(-1., -0.45, -0.45);\n    vec3 target = mix(start, end, p2);\/\/mix(mix(start, end, p2), neutralTarget, pow(p3, 0.4));\n    data.saberTarget = mix(data.saberTarget, target, p1);\n    \n    \/\/stance\n    data.footRPos = mix(data.footRPos, ll*vec3(0.4, 0.1, data.footLPos.z - 1.2), (p1 - p3));\n    data.footRPos.y += pingPong(p1 - p3)*ll*0.1;\n    return p1 - p3;\n}\n\nfloat parryUpRight(float i, float m, inout StickmanData data)\n{   \n    float p = 1.0 - pow(1.0 - pingPong(i), 4.0);\n\n    mat3 alignRot;\n    vec3 restTarget = vec3(0.0, 1.0, 0.0)*data.invSaberRot;    \n    vec3 armTarget = vec3(-1.0, 0.15, -0.1);\n    rotationAlign(armTarget, restTarget, p, alignRot);\n    data.invSaberRot = data.invSaberRot*alignRot;\n        \n    data.saberPos = mix(data.saberPos, vec3(0.6, 0.42, -1.7), p);\n                \n    \/\/squint eyes while you parry, just because ....\n    data.eyeLDeform.y *= 1.0 - p*0.4;\n    data.eyeRDeform.y *= 1.0 - p*0.6;\n    \n    \/\/stance\n    data.footRPos = mix(data.footRPos, ll*vec3(0.8, 0.1, data.footRPos.z + 0.5), p);\n    data.footRPos.y += pingPong(p)*ll*0.1;\n    return 0.0;\n}\n\nfloat parryDownLeft(float i, float m, inout StickmanData data)\n{   \n    float p = 1.0 - pow(1.0 - pingPong(i), 4.0);\n    \n    mat3 alignRot;\n    vec3 restTarget = vec3(0.0, 1.0, 0.0)*data.invSaberRot;    \n    vec3 saberTarget = vec3(-0.2, 1.0, -0.5);\n    rotationAlign(saberTarget, restTarget, p, alignRot);\n    data.invSaberRot = data.invSaberRot*alignRot;\n\n    data.saberPos = mix(data.saberPos, vec3(-0.9, -0.5, -1.4), p);\n                \n\t\/\/squint eyes while you parry, just because ....\n    data.eyeLDeform.y *= 1.0 - p*0.4;\n    data.eyeRDeform.y *= 1.0 - p*0.6;\n    \n    \/\/stance\n    data.footRPos = mix(data.footRPos, ll*vec3(0.7, 0.1, data.footRPos.z + 0.5), p);\n    data.footRPos.y += pingPong(p)*ll*0.1;\n    return 0.0;\n}\n\nvoid iddle(float t, float i, inout StickmanData data)\n{\n    \/\/mouth\n    float dur = 3.0;\n    float p;\n    \/\/p = pingPong(mod(t, dur)\/dur)*i;\n    \/\/mouthDeform *= 0.9 + 0.2*p;\n    \/\/body\n    p = pingPong(mod(t - 0.1, dur)\/dur)*i;\n    data.bodyDeform *= 0.975 + 0.025*p;\n    \/\/hands\n    float r = p*PI*-0.07;\n    data.handRRot = data.handRRot*mat3(vec3(cos(r), sin(r), 0.0),\n                    vec3(-sin(r), cos(r), 0.0),\n                    vec3(0.0, 0.0, 1.0));\n    r = -r;\n    data.handLRot = data.handLRot*mat3(vec3(cos(r), sin(r), 0.0),\n                    vec3(-sin(r), cos(r), 0.0),\n                    vec3(0.0, 0.0, 1.0));        \n    \/\/eyes\n    dur = 5.0;\n    p = pingPong(smoothstep(dur - 0.3, dur, mod(t, dur)))*i;\n    data.eyeRDeform.y *= 1.0 - p;\n    data.eyeLDeform.y *= 1.0 - p;    \n}\n\nfloat poseSaberSide(float i, inout StickmanData data)\n{   \n    data.saberPos = mix(data.saberPos, vec3(1.0, -0.2, -0.8), i);\n    mat3 xRot;\n    rotationX(PI*0.07*i, xRot);\n    data.invSaberRot = data.invSaberRot*xRot;\n    \n    \/\/foot placement\n    data.footLPos = mix(data.footLPos, vec3(-0.8, 0.1, -.6*ll), i);\n    data.footLPos.y += ll*0.1*pingPong(i);\n    \n    return 1.0;\n}\n\nfloat poseSaberFront(float i, inout StickmanData data)\n{   \n    data.saberPos = mix(data.saberPos, vec3(0.2, -0.4, -1.4), i);\n    mat3 xRot;\n    rotationX(PI*0.25*i, xRot);\n    data.invSaberRot = data.invSaberRot*xRot;\n    \n    \/\/foot placement\n    data.footRPos = mix(data.footRPos, vec3(0.6, 0.1, -0.8*ll), i);\n    data.footRPos.y += ll*0.1*pingPong(i);\n    return 0.0;\n}\n\nfloat poseSaberBack(float i, inout StickmanData data)\n{    \n    mat3 xRot;\n    rotationX(0.55*PI*i, xRot);\n    mat3 yRot;\n    rotationY(-0.07*PI*i, yRot);\n    \n    data.invSaberRot = data.invSaberRot*xRot*yRot;\n   \n    mat3 zRot;\n    rotationZ(PI*0.4*i, zRot);\n    data.handLRot = data.handLRot*zRot;\n    data.handLPos = mix(data.handLPos, vec3(-1.3, 0.3, -0.9), i);\n    data.saberPos = mix(data.saberPos, vec3(1.3, 0.2, 0.5), i);\n    \n    \/\/foot placement\n    data.footLPos = mix(data.footLPos, vec3(-0.6, 0.1, -1.*ll), i);\n    data.footLPos.y += ll*0.1*pingPong(i);\n    return 0.0;\n}\n\nfloat poseSaberBackDown(float i, inout StickmanData data)\n{    \n    mat3 xRot;\n    rotationX(0.65*PI*i, xRot);\n    mat3 yRot;\n    rotationY(0.3*PI*i, yRot);\n    \n    data.invSaberRot = data.invSaberRot*xRot*yRot;\n    \n    mat3 zRot;\n    rotationZ(PI*0.4*i, zRot);\n    data.handLRot = data.handLRot*zRot;\n    data.handLPos = mix(data.handLPos, vec3(-1.2, -0.3, -0.8), i);\n    \n    data.saberPos = mix(data.saberPos, vec3(1.3, -0.3, 0.5), i);\n    \n    \/\/foot placement\n    data.footLPos = mix(data.footLPos, vec3(-0.7, 0.1, -0.7*ll), i);\n    data.footLPos.y += ll*0.1*pingPong(i);\n    return 0.0;\n}\n\nfloat animateEntranceJedi(float p, inout StickmanData data)\n{        \n    data.saberLen *= smoothstep(0.05, 0.3, p);\n    float pose1 = 1.0 - smoothstep(.52, .7, p);\n    poseSaberFront(pose1, data);\n    \n    frontLoop(smoothstep(.3, .4, p) - smoothstep(0.65, 0.7, p), linearstep(.3, .65, p)*2., data);\n    \n    float pose2 = smoothstep(.5, .7, p);\n    poseSaberSide(pose2, data);\n    \n    return pose2;\n}\n\nfloat animateEntranceSith(float p, inout StickmanData data)\n{    \n    data.saberLen *= smoothstep(0.05, 0.15, p);\n    float pose1 = 1.0 - smoothstep(.52, .6, p);\n    poseSaberBackDown(pose1, data);\n    \n    backLoop(max(smoothstep(.2, .25, p) - smoothstep(0.55, 0.6, p), 0.00001), linearstep(.2, .55, p)*3., data);\n    \n    float pose2 = smoothstep(.5, .6, p);\n    poseSaberBack(pose2, data); \n    return 0.0;\n}\n\n#define ANIMATE 1\n\n\/\/assumes t is time\n\/\/i is a float \n\/\/data is the stickman\n\/\/hit receives the hit progress\n\/\/twoHanded receives the two hand amount\n#define HIT_SEQ(s, e, m, hitAnim) if(t > s && t <= e) {i = (t-s)\/(e-s); hit = hitAnim(i, m, data);}\n#define HOLD_POSE(s, e, poseAnim) if(t > s && t <= e) {twoHanded = poseAnim(1.0, data);}\n#define TRANS_POSE(s, e, prevPoseAnim, poseAnim) if(t > s && t <= e) {i = (t-s)\/(e-s); prevTwoHanded = prevPoseAnim(1.0-i, data); twoHanded = poseAnim(i, data); twoHanded = mix(prevTwoHanded, twoHanded, i);}\n\nfloat loopTime = 9.5;\n\nvoid animateJedi(float t, inout StickmanData data)\n{    \n    float entranceDur = 4.5;\n    float prevTwoHanded = 0.0;\n    float twoHanded = 0.0;\n    float i = 0.0;\n    float hit = 0.0;\n    float s, e;\n    \n#if ANIMATE    \n    s = -entranceDur;\n    e = 0.0;\n    TRANS_POSE(s, e, nullPose, animateEntranceJedi)\n    \n    t = mod(t, loopTime) * step(0.0, t);\n    \n\ts = e;\n    e = s + 0.5;    \n    HOLD_POSE(s, e, poseSaberSide)\n        \n    s = e;\n    e = s + 0.7;    \n    HOLD_POSE(s, e, poseSaberSide)\n    HIT_SEQ(s, e, 1.0, parryDownLeft) \n        \n    s = e;\n    e = s + 0.2;    \n    HOLD_POSE(s, e, poseSaberSide)\n        \n    s = e;\n    e = s + 1.65;    \n    HOLD_POSE(s, e, poseSaberSide)\n    HIT_SEQ(s, e, 0.60, whirlingHit)  \n        \n    s = e;\n    e = s + 1.0;    \n    HOLD_POSE(s, e, poseSaberSide)\n                \n    s = e;\n    e = s + 0.9;    \n    HOLD_POSE(s, e, poseSaberSide)\n    HIT_SEQ(s, e, 1.0, parryDownLeft)  \n\n    s = e;\n    e = s + 0.45;    \n    TRANS_POSE(s, e, poseSaberSide, poseSaberFront) \n        \n    s = e;\n    e = s + 0.9;    \n    HOLD_POSE(s, e, poseSaberFront)\n    HIT_SEQ(s, e, 1.0, parryDownLeft)                  \n        \n    s = e;\n    e = s + 2.0;    \n    HOLD_POSE(s, e, poseSaberFront)\n    HIT_SEQ(s, e, 0.4375, upDownHit)   \n        \n\ts = e;\n    e = s + 0.4;    \n    HOLD_POSE(s, e, poseSaberFront)\n        \n    s = e;\n    e = s + 0.6;    \n    TRANS_POSE(s, e, poseSaberFront, poseSaberSide) \n    \n    s = e;\n    e = loopTime;    \n    HOLD_POSE(s, e, poseSaberSide)\n#endif        \n            \n    invKinematics(twoHanded, hit, data);\n}\n\nvoid animateSith(float t, inout StickmanData data)\n{        \n    float entranceDur = 4.5;\n    float twoHanded = 0.0;\n    float i = 0.0;\n    float hit = 0.0;\n    float prevTwoHanded = 0.0;\n    \n    float s, e;\n#if ANIMATE\n    \/\/do pose    \n    s = -entranceDur;\n    e = 0.0;\n    TRANS_POSE(s, e, nullPose, animateEntranceSith)\n    \n    t = mod(t, loopTime) * step(0.0, t);\n    \n    s = e;\n    e = s + 1.7;    \n    HOLD_POSE(s, e, poseSaberBack)\n    HIT_SEQ(s, e, 0.434, upDownHit)\n       \n    s = e;\n    e = s + 0.6;    \n    HOLD_POSE(s, e, poseSaberBack)\n        \n    s = e;\n    e = s + 0.6;    \n    HOLD_POSE(s, e, poseSaberBack)\n    HIT_SEQ(s, e, 1.0, parryUpRight)\n        \n    s = e;\n    e = s + 0.5;    \n    TRANS_POSE(s, e, poseSaberBack, poseSaberBackDown)\n        \n    s = e;\n    e = s + 1.5;    \n    HOLD_POSE(s, e, poseSaberBackDown)\n    HIT_SEQ(s, e, 0.558, whirlingHit)\n        \n    s = e;\n    e = s + 0.4;    \n    TRANS_POSE(s, e, poseSaberBackDown, poseSaberBack)\n        \n    s = e;\n    e = s + 1.0;    \n    HOLD_POSE(s, e, poseSaberBack)            \n    HIT_SEQ(s, e, 0.6, forwardHit)\n    \n    s = e;\n    e = s + 0.1;    \n    HOLD_POSE(s, e, poseSaberBack)  \n        \n    s = e;\n    e = s + 0.42;    \n    TRANS_POSE(s, e, poseSaberBack, poseSaberBackDown)\n        \n    s = e;\n    e = s + 1.2;    \n    HOLD_POSE(s, e, poseSaberBackDown)\n    HIT_SEQ(s, e, 1.0, parryDownLeft)   \n        \n\ts = e;\n    e = s + 0.8;    \n    HOLD_POSE(s, e, poseSaberBackDown)\n        \n    s = e;\n    e = s + 0.5;    \n    TRANS_POSE(s, e, poseSaberBackDown, poseSaberBack)\n    \n    s = e;\n    e = loopTime;    \n    HOLD_POSE(s, e, poseSaberBack)\n#endif        \n    \n    invKinematics(twoHanded, hit, data);\n}\n\nvoid initStickman(inout StickmanData data, bool isJedi)\n{\n    data.stickmanPos = vec3(0.0, -1.0, 0.0);\n    \/\/relative to stickManPos\n    data.bodyPos = vec3(0.0, 1.5, 0.0);\n    data.bodyDeform = vec3(1.0, 1.15, 1.0);\n    data.headPos = vec3(0.0, .05, -0.92);\n    data.handRPos = vec3(1.1, -0.45, -0.5);\n    data.handLPos = vec3(-1.1, -0.45, -0.5);\n    data.handRDeform = vec3(1.2, 1.5, 1.6);\n    data.handLDeform = vec3(1.2, 1.5, 1.6);\n    data.handRRot = IMAT3;\n    data.handLRot = IMAT3;\n    data.footRPos = vec3(0.6, 0.1, -0.1);\n    data.footLPos = vec3(-0.6, 0.1, -0.1);\n    data.footRRot = IMAT3;\n    data.footLRot = IMAT3;\n    data.footRDeform = vec3(1.5, 0.9, 1.8);\n    data.footLDeform = vec3(1.5, 0.9, 1.8);\n\n\n    data.invBodyRot = IMAT3;\n    data.invStickmanRot = IMAT3;\n    data.invMouthRot = IMAT3;\n\n    \/\/relative to headPos\n    data.eyeRDeform = vec3(2.0, 1.8, 1.0);\n    data.eyeLDeform = vec3(2.0, 2.5, 1.0);\n\n    data.mouthDeform = vec3(2., 1.0, 3.5); \n\n    data.saberPos = vec3(1.1, -0.45, -0.5);\n    data.saberRadius = 0.06;\n    data.saberLen = 0.85;\n    data.saberNoise = isJedi ? JEDI_SABER_NOISE : SITH_SABER_NOISE;\n    data.invSaberRot = IMAT3;\n    \n    data.laserColor = LASER_CORE + (isJedi ? JEDI : SITH);\n    data.laserLight = (data.laserColor - LASER_CORE)*LASER_LIGHT_STR;\n    \n    rotationX(mouthXRot, data.invMouthRot);\n}\n\nvec4 characterField(vec3 p, inout float minDist )\n{\n\tvec4 jediField = vec4(maxDist);\n    vec4 sithField = vec4(maxDist);\n    float jediMinDist = MAX_DIST;\n    float sithMinDist = MAX_DIST;\n    jediField = fStickman(jediData.invStickmanRot*(p - jediData.stickmanPos), jediData, jediFieldData, jediMinDist);\n#ifdef TWO_EGGS    \n    sithField = fStickman(sithData.invStickmanRot*(p - sithData.stickmanPos), sithData, sithFieldData, sithMinDist);\n#endif    \n    minDist = min(jediMinDist, sithMinDist);\n    return jediField*step(jediMinDist, minDist) + sithField*step(sithMinDist, minDist);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/get distance to nearest surface and atmosphere\/surface color\nvec4 colorDistanceField(vec3 point, inout float minDist)\n{       \n    float charDist \t\t= MAX_DIST;\n    vec4 charfield\t\t= characterField(point, charDist);\n       \n    vec3 mPoint = point - vec3(7.5, 0.0, 2.0);\n    pMod2(mPoint.xz, vec2(15.0, 15.0));\n\n    float hexaHeight \t= 3.0;\n    float hexaDist\t\t= fHexagonCircumcircle(mPoint, vec2(1.5, hexaHeight));\n    float distPlane     = fPlane(plane, point);\n    minDist             = min(minDist, distPlane);\n    minDist\t\t\t\t= min(minDist, charDist);\n    minDist\t\t\t\t= min(minDist, hexaDist);\n        \n    \/\/blend colors\n    vec4 color = vec4(0.0);\n    color += groundColor * step(distPlane, minDist);\n    color += groundColor * step(hexaDist, minDist);\n    color += charfield * step(charDist, minDist);\n\n    return color;\n}\n\n\/\/get distance and color to nearest surface\nfloat distanceField(vec3 point)\n{\n    float minDist = MAX_DIST;\n    colorDistanceField(point, minDist);\n    return minDist;\n}\n\nvec3 computeNormal(vec3 p, float roughness, out float ao)\n{    \n    vec3 normalWS = vec3(0.0);\n    for(int i = min(0, iFrame); i < 4; i++)\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        uint unusedMatId;\n        normalWS += e*distanceField(p + e * 0.001);\n    }\n    normalWS = normalize(normalWS);    \n    vec3 deform = noise3(p*0.0002);\n    \n    ao = length(deform);\n    deform = deform*2.0 - vec3(1.0);\n    return normalize(normalWS + deform * roughness*0.0001);\n}\n\nvec3 computeSaberLightDir(vec3 point, StickmanData data, FieldData fieldData)\n{\n#if LIGHT_QUALITY\n    float grad = 0.75;\n    \n    vec3 normalWS = vec3(0.0);\n    for(int i = min(0, iFrame); i < 4; i++)\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        uint unusedMatId;\n        vec3 p = point + e * grad;\n        normalWS += e*fSaber(data.invStickmanRot*(p - data.stickmanPos), data, fieldData);\n    }\n    normalWS = -normalize(normalWS); \n    return normalWS;\n#else\n    vec3 s = (vec3(0., data.saberLen*2.0, 0.)*data.invSaberRot);\n    vec3 a = data.stickmanPos + (data.bodyPos + data.saberPos*data.bodyDeform)*data.invStickmanRot;\n    vec3 c = data.stickmanPos + (data.bodyPos + (s + data.saberPos)*data.bodyDeform)*data.invStickmanRot;\n    return normalize(mix(a, c, 0.5) - point);\n#endif\n}\n\nfloat distBetweenSabers(StickmanData first, StickmanData secnd, FieldData secndField)\n{\n    vec3 s = (vec3(0., first.saberLen*2.0, 0.)*first.invSaberRot);\n    vec3 a = first.stickmanPos + (first.bodyPos + first.saberPos*first.bodyDeform)*first.invStickmanRot;\n    vec3 c = first.stickmanPos + (first.bodyPos + (s + first.saberPos)*first.bodyDeform)*first.invStickmanRot;\n        \n    float sithDistLaser = 1000.0;\n    for(float i = 0.; i <= 1.0; i += 1.0\/32.0)\n    {\n        vec3 b = mix(a, c, i);\n        vec3 stickmanDiff = secnd.invStickmanRot*(b - secnd.stickmanPos);        \n    \tsithDistLaser = min(sithDistLaser, fSaber(stickmanDiff, secnd, secndField)); \n    }\n    \n    return sithDistLaser;\n}\n\nvec3 doLighting(vec3 surfColor, vec3 surfPoint, vec3 surfNormal, vec3 lightColor, vec3 lightDir, float roughness)\n{\n    if(dot(surfColor, surfColor) <= 2.5)\n    {             \n        float lightingWrap = 0.5;\n        float diff \t\t= dot(surfNormal, lightDir);\n        diff\t\t\t= clamp((diff + lightingWrap)\/((1.0 + lightingWrap)*(1.0 + lightingWrap)), 0.0, 1.0);\n        vec3 eyeDir \t= normalize(projectionCenter - surfPoint);\n        vec3 halfVec \t= normalize(eyeDir + lightDir);\n        float spec \t\t= clamp(dot(halfVec, surfNormal), 0.0, 1.0);\n        spec \t\t\t= pow(spec, mix(128.0, 8.0, pow(roughness, 0.5))) * pow(diff, 1.0);\n        surfColor \t\t= surfColor * diff * lightColor + lightColor * spec;\n    }    \n    return surfColor;\n}\n\n\/\/raymarch and sample atmosphere color along the ray\nvec4 rmAtmosphere(vec3 rayStart, vec3 rayDir, float minDist)\n{\n    float cloud = 0.0;\n\tfloat transmittance = 1.0;\n    vec3 scatteredLight = vec3(0.0, 0.0, 0.0);\n    \n    float totalDist = minDist;\n    float dist = 0.0;\n    float dStep = 0.0;\n    vec3 color = zero;\n    float stepBias, jediDistLaser, sithDistLaser, strLaser;\n    vec3 atmColor, surfColor, litColor;\n    vec3 endPoint, sithStickmanDiff, jediStickmanDiff, normal;\n    vec3 jediSaberLightDir, sithSaberLightDir;\n    vec4 dfRes;   \n    float roughness = .0;\n    vec3 S, Sint;\n    float saberOverlap;\n    \n    float distSab = distBetweenSabers(jediData, sithData, sithFieldData);\n    \/\/distSab = min(distSab, distBetweenSabers(sithData, jediData, jediFieldData));\n    float contactLightPower = 1.0 + smoothstep(0.3, 0.15, distSab)*3.0;\n        \n    vec4 rmRes;\n    \n    for(int i = 0; i < MAX_STEPS; ++i)\n    {   \n        stepBias = max(MIN_STEP_BIAS, totalDist*2.0\/MAX_DIST);\/\/to avoid artefacts\n                      \n        endPoint = rayStart + rayDir * totalDist; \n        jediStickmanDiff = jediData.invStickmanRot*(endPoint - jediData.stickmanPos);\n        jediFieldData.fSaber = fSaber(jediStickmanDiff, jediData, jediFieldData);\n        strLaser = 1.0 + smoothstep(jediData.saberLen*2., 0.0, fHandle(jediStickmanDiff, jediData, jediFieldData))*2.;\n        jediDistLaser = (LASER_STR + strLaser)\/pow(jediFieldData.fSaber, 2.0);  \n        \n#ifdef TWO_EGGS\n        sithStickmanDiff = sithData.invStickmanRot*(endPoint - sithData.stickmanPos);\n        sithFieldData.fSaber = fSaber(sithStickmanDiff, sithData, sithFieldData);\n        strLaser = 1.0 + smoothstep(sithData.saberLen*2., 0.0, fHandle(sithStickmanDiff, sithData, sithFieldData))*2.;\n        sithDistLaser = (LASER_STR + strLaser)\/pow(sithFieldData.fSaber, 2.0);         \n        \n        saberOverlap = 1.0\/pow(jediFieldData.fSaber*sithFieldData.fSaber, 1.5);\n        jediDistLaser += saberOverlap;\n        sithDistLaser += saberOverlap;\n#endif\n        \n        jediSaberLightDir = computeSaberLightDir(endPoint, jediData, jediFieldData);\n        sithSaberLightDir = computeSaberLightDir(endPoint, sithData, sithFieldData);\n\n#if VOL_FOG\n        vec3 atmSamplePos = endPoint + rayDir*dist*(s_pixelRand-0.5);\n        cloud = atmThickness(atmSamplePos);\n        \n        S = jediDistLaser*jediData.laserLight*contactLightPower*\n#if VOL_SHADOW            \n            volumetricShadow(atmSamplePos, jediSaberLightDir)*\n#endif            \n            cloud * PHASE_FUNC; \/\/ incoming light\n#ifdef TWO_EGGS\n        S += sithDistLaser*sithData.laserLight*contactLightPower*\n#if VOL_SHADOW            \n            volumetricShadow(atmSamplePos, sithSaberLightDir)*\n#endif            \n            cloud * PHASE_FUNC; \/\/ incoming light        \n#endif        \n        \n        Sint = (S - S * exp(-cloud * dStep)) \/ cloud; \/\/ integrate along the current step segment\n        scatteredLight += transmittance * Sint; \/\/ accumulate and also take into account the transmittance from previous steps\n\t\t\/\/ Evaluate transmittance to view independentely\n        transmittance *= exp(-cloud * dStep); \n        if(transmittance < 0.005) \n        {\n            break;\n        }\n#endif              \n        dist = MAX_DIST;\n        dfRes = colorDistanceField(endPoint, dist);        \n        dStep = dist * stepBias;        \n        totalDist += dStep;  \n        \n        if(dist <= MIN_DIST)\n        {                  \n            float ao = 1.0;\n            normal = computeNormal(endPoint, roughness, ao);\n            \/\/store final hit color\n            surfColor = dfRes.xyz;\n            roughness = dfRes.w;\n\t\t\t\n            \/\/do lighting            \n            litColor = AMBIANT_LIGHT * surfColor;            \n            \/\/Don't do sunlight, night time looks better\n            \/\/litColor += doLighting(surfColor, endPoint, normal, sunLightColor, normalize(sunLightPos - endPoint), roughness);                                  \n            \n            litColor += doLighting(surfColor, endPoint, normal, \n                                   (jediData.laserLight*contactLightPower)*jediDistLaser*0.5,\n                                   jediSaberLightDir, roughness);                        \n#ifdef TWO_EGGS\n      \t\t\n            litColor += doLighting(surfColor, endPoint, normal, \n                                   (sithData.laserLight*contactLightPower)*sithDistLaser*0.5, \n                                   sithSaberLightDir, roughness);                        \n#endif                                                \n            \n            color = surfColor*ao*0.01 + litColor;\n\n            rmRes = vec4(color, totalDist);   \n            break;\n        }                \n\n        \/\/no surface hit, return sky + atmColor\n        if(totalDist >= MAX_DIST || i >= MAX_STEPS - 1)\n        {\n            rmRes = vec4(color + skyColor, MAX_DIST + 0.01);\n            break;\n        }\n    }    \n    \n    rmRes.xyz = mix(fogColor*0.8, rmRes.xyz, transmittance) + scatteredLight;\n    return rmRes;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{      \n    s_pixelRand = textureLod(iChannel0, fragCoord\/vec2(1024.0), 0.0).r;\n    s_pixelRand = fract(s_pixelRand + float(iFrame % 256)*1.618);\n    s_time = iTime;\/\/ - iTimeDelta * s_pixelRand;\n    \n    vec2 mousePos = iMouse.xy \/ iResolution.xy * 2.0 - vec2(1.0);\n    float day = 0.0;\n    day = sign(day) * pow(abs(day), 2.0);\n    dayProgress = abs(day);\n\n    float sunsetFromNight = smoothstep(0.4, 0.5, dayProgress);\n    float sunsetToDay = smoothstep(0.8, 0.5, dayProgress);\n    vec3 sunsetColor = mix(mix(vec3(0.5, 0.0 ,0.0), vec3(1.0, 0.8, 0.3), sunsetFromNight),\n                           mix(vec3(0.2, 0.2, 1.0), vec3(1.0, 0.8, 0.3), sunsetToDay), (sunsetFromNight + sunsetToDay)\/2.0);\n    float sunsetStr = sunsetFromNight*sunsetToDay;    \n    \n    sunLightPos = vec3(0.0, -1000.0, 0.0);\n    mat3 sRotZ;\n    rotationZ(day*PI, sRotZ);\n    sunLightPos = sRotZ*sunLightPos;\n    \n    sunLightColor = mix(vec3(0.004, 0.004, 0.0065), vec3(0.8, 0.8, 0.7), dayProgress);    \n    sunLightColor = mix(sunLightColor, sunsetColor, sunsetStr);\n    \n    vec2 uv = fragCoord.xy \/ iResolution.xy;    \n    vec3 ro = vec3(0.0);\n    \n    float t = s_time * 1.1; \n    t += (cos(t*0.5))*0.2;\n    \n    float camT = t*0.5;\n    float camRotY = (mousePos.x + camT*0.1)*PI*-2.0;\n    float camY = (1.0 - cos(camT*0.5))*0.3;\n    float camDist = 12.0 - sin(camT*0.5)*4.0;\n    \n    \/\/animate before marching\n    initStickman(jediData, true);\n#ifdef TWO_EGGS    \n    jediData.stickmanPos.x += 2.7;\n    mat3 yRot;\n    rotationY(-0.5*PI, yRot);    \n    jediData.invStickmanRot = yRot*jediData.invStickmanRot;\n    \n    initStickman(sithData, false);    \n    sithData.stickmanPos.x -= 2.7;\n    rotationY(0.5*PI, yRot);\n    sithData.invStickmanRot = yRot*sithData.invStickmanRot;\n    animateSith(t, sithData);      \n    computeFieldData(sithData, sithFieldData);\n#endif    \n    animateJedi(t, jediData);\n    computeFieldData(jediData, jediFieldData);\n    \n    \n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \n    \/\/Do camera setup from mouse coord\n    vec3 pCenter        = vec3(0.0, 0.2, 0.0);\n    vec3 pOffset\t\t= vec3(0.0, 0.0, 1.0);\n    \n    mat3 pRotY;\n    rotationY(camRotY, pRotY);\n    pOffset.y = camY;\n    pOffset = pRotY*pOffset;    \n    projectionCenter    = pCenter + pOffset*camDist;\n    \n    vec3 tmpCenter      = (projectionCenter + vec3(0.0, 0.0, .50));\n\n    projectionCenter    = (projectionCenter);\n    \n    projectionForward   = normalize(-pOffset);\n    projectionUp \t\t= vec3(0.0, 1.0, 0.0);\n    projectionRight \t= cross(projectionUp, projectionForward);\n    projectionUp \t\t= cross(projectionForward, projectionRight);      \n    mousePos       = pixelToNormalizedspace(iMouse.xy);\n           \n    \n    cameraOffset        = -projectionForward * FOCAL_LENGTH;\n    \n    vec2 rd = uv*2.0 - vec2(1.0);\n    rd.y \/= iResolution.x\/iResolution.y;\n    \/\/setup ray\n    vec3 rayPos                 = projectionCenter + cameraOffset;\n    vec3 pointOnProjectionPlane = projectionCenter + projectionRight * rd.x + projectionUp * rd.y;\n    vec3 rayDirection           = normalize(pointOnProjectionPlane - rayPos);\n    \n    float sun = pow(max(0.0, dot(rayDirection, normalize(sunLightPos))), 2.0);\n    \n    \/\/sky and stars\n    vec2 xzDir \t\t= normalize(rayDirection.xz);\n    vec2 starsUv \t= vec2(atan(xzDir.x, xzDir.y), rayDirection.y);\n    vec3 stars      = textureLod(iChannel0, starsUv * 0.1, 0.).xyz;\n    stars           *= pow(dot(stars, stars)*0.5, 16.0) * 0.3;\/\/ smoothstep(2.1, 2.5, dot(stars, stars));\n    stars = smoothstep(vec3(0.0), vec3(1.0), stars);\n    float skyHeight = pow(max(0.0, rayDirection.y) * 2.0, 0.75);\n    float starVis   = skyHeight * pow(1.0 - dayProgress, 2.0);\n    stars = mix(zero, stars, pow(starVis, 6.0));\n       \n    vec3 lowColor = mix(vec3(0.01, 0.01, 0.05), vec3(0.85, 0.85, 1.0), dayProgress);\n    lowColor = mix(lowColor, sunsetColor, sunsetStr + pow(sun, 5.0)*sunsetStr*2.0);\n    vec3 upColor = mix(vec3(0.0005, 0.0005, 0.001), vec3(0.15, 0.15, 1.0), dayProgress);\n    upColor = mix(upColor, sunsetColor, sunsetStr*0.5 + pow(sun, 5.0)*sunsetStr*2.0);\n    \n    skyColor = mix(lowColor, upColor, skyHeight);    \n    \n    float fogBlur = 0.5;\n    fogColor = mix(mix(lowColor, upColor, max(0.0, skyHeight - fogBlur)),\n                   mix(lowColor, upColor, min(1.0, skyHeight + fogBlur)),\n                   0.5);\n    \n    \/\/march ray\n    vec4 rayMarchResult     = rmAtmosphere(rayPos, rayDirection, 0.0);    \n    float dist              = rayMarchResult.w;\n    vec4 surfaceColor       = vec4(rayMarchResult.xyz , 1.0);\n    \n    if(dist >= MAX_DIST)\n    {\n        surfaceColor.xyz += stars;\n        surfaceColor.xyz = surfaceColor.xyz + sunLightColor*pow(sun, 80.0)*10.0;\n    }    \n    \n    \/\/convert to gamma space\n    surfaceColor = pow( surfaceColor, vec4(1.0\/2.2));\n    fragColor = surfaceColor;\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"ls2SDD","date":"1412368341","viewed":19789,"name":"Unreal Intro","username":"fizzer","description":"A remake of the castle fly-by sequence from the classic 90's videogame Unreal. The geometry is converted directly from the level data and I made everything else myself. \"Alter your reality...forever\".\nhttp:\/\/www.youtube.com\/watch?v=26I-Pw-yPJ4","likes":161,"published":1,"flags":0,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"\/media\/a\/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"\/media\/ap\/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Created by Edd Biddulph\n\/\/ License for this shader: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/\n\/\/ This is a recreation of the castle fly-by sequence from the original Unreal, released in 1998 and\n\/\/ developed by Epic MegaGames. http:\/\/epicgames.com\/\n\/\/\n\/\/ This was mostly inspired by P_Malin's amazing Doom shader - https:\/\/www.shadertoy.com\/view\/lsSXzD\n\/\/\n\/\/ I made a custom tool to convert the geometry from the original files from the game, but the textures\n\/\/ were made 'by hand'. Unreal's levels are composed of convex shapes called 'brushes'. The brushes\n\/\/ are combined using CSG operations to produce the level geometry. My tool detects cuboid-shaped brushes\n\/\/ from which a distance field is simple to create. Most of the non-cuboid-shaped brushes can be created\n\/\/ by cutting a cuboid with less than 4 oriented planes so my tool first generates a cuboid and adds\n\/\/ those planes into the distance field code.\n\n\n#define time (iTime-6.0)\nfloat flagTime=0.0;\n\nfloat hash(float n)\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat smoothNoise2(vec2 p)\n{\n    p=fract(p\/256.0);\n    return textureLod(iChannel0, p, 0.0).r;\n}\n\n\/\/ Distorted texture coordinates for the rippling flag.\nvec2 flagTC(vec2 p)\n{\n    float tm=-flagTime*1.4;\n    return vec2(p.x+p.x*(cos(p.x*7.0+tm*6.0))*0.02+cos(p.y*6.0+tm*7.5)*0.01*p.x,p.y+p.x*cos(p.x*4.0+tm*5.0)*0.01);\n}\n\nvec3 flagTexture2(vec2 p)\n{\n    p.x+=0.05;\n    p.y+=0.05;\n    float d=1e2;\n    d=min(d,length(p-vec2(-0.85,-0.13+p.x*-0.4))-0.5);\n    d=min(d,length(p-vec2(-0.8,-1.2))-0.9);\n    d=min(d,length(max(vec2(0.0),abs(p-vec2(0.4,-0.63))-vec2(0.5,0.3))));\n    d=min(d,length(max(vec2(0.0),abs(p-vec2(0.9,0.0))-vec2(0.3,0.8))));\n    d=min(d,length(max(vec2(0.0),abs(p-vec2(-0.9,0.0))-vec2(0.3,0.8))));\n    vec2 p2=p+vec2(0.0,-0.07);\n    d=min(d,length((p2-vec2(0.1,0.2))*vec2(1.0,0.9))+0.1-p2.y*1.3);\n    d=max(d,-length(p-vec2(0.1,0.5))+0.15);\n    vec2 p3=p+vec2(0.0,0.1);\n    d=min(d,max(p.x, max(-(length((p3-vec2(0.1,0.2))*vec2(1.0,0.9))+0.1-p3.y*1.1), dot(p-vec2(0.0,0.12),normalize(vec2(-0.75,-1.0))))));\n    return mix(vec3(0.2,0.1,0.1),vec3(1.0,0.2,0.1)*0.9,(0.3+(1.0-smoothstep(0.0,0.02,d))))*\n        mix(0.7,1.0,smoothNoise2(p*40.0)*0.25+smoothNoise2(p*20.0)*0.25);\n}\n\nvec4 flagTexture(vec2 p2)\n{\n    vec2 p=p2.xy*0.7+vec2(0.5);\n    vec2 c=flagTC(p);\n    vec2 e=vec2(1e-2,0.0);\n    float g=max(length((flagTC(p+e.xy)-c)\/e.x),length((flagTC(p+e.yx)-c)\/e.x));\n\n    float b=step(abs(c.y-0.5),0.3)*step(c.x,0.8);\n    float nb=-1.0+abs(c.y-0.5)*3.3;\n    return vec4(flagTexture2((c*2.0-vec2(1.0))*vec2(-1.0,1.0))*(1.0-smoothstep(0.0,2.0,g)),\n                step(abs(c.y-0.5)*2.0,0.7)*step(abs(c.x-0.5)*2.0,1.0)*smoothstep(nb+0.199,nb+0.2,smoothNoise2(c*vec2(32.0,0.5))));\n}\n\n\n\/\/ Brick pattern for tex_wmbrrw.\nfloat brickt3(vec2 p2)\n{\n    vec2 fp2=fract(p2);\n    float brick=length(max(vec2(0.0),abs(fp2-vec2(0.5))-vec2(0.4,0.36)));\n    return 1.0-smoothstep(0.01,0.2,brick)-smoothNoise2(p2*vec2(7.0,4.0)*3.0)*0.2;\n}\n\n\/\/ Brick pattern for tex_nfloor6.\nfloat brickt2(vec2 p2)\n{\n    vec2 fp2=fract(p2);\n    float brick=length(max(vec2(0.0),abs(fp2-vec2(0.5))-vec2(0.465,0.465)));\n    return 1.0-smoothstep(0.0,0.04,brick)+smoothNoise2(p2*vec2(4.0,4.0)*3.0)*0.0;\n}\n\n\/\/ Brick pattern for tex_wmcs.\nfloat brickt(vec2 p2)\n{\n    vec2 fp2=fract(p2);\n    float brick=length(max(vec2(0.0),abs(fp2-vec2(0.5))-vec2(0.44,0.32))*vec2(11.0\/4.0,1.0));\n    return 1.0-smoothstep(0.0,0.18,brick)+smoothNoise2(p2*vec2(8.0,4.0)*3.0)*0.4;\n}\n\n\/\/ Roof texture.\nvec3 tex_Roof(vec2 p)\n{\n    vec2 tc0=floor(p*vec2(6.0,3.0));\n    p.y+=0.5\/3.0;\n    vec2 tc=floor(p*vec2(6.0,3.0));\n    vec2 tt=fract(p*vec2(6.0,3.0));\n\n    tt.x+=smoothNoise2(p*10.0)*0.05+smoothNoise2(p*30.0)*0.02;\n\n    float spike=smoothstep(0.8,1.0,smoothNoise2(vec2(p.x*100.0,tc.y*7.0+tc.x*1.0)))*0.4;\n    float j=smoothNoise2(vec2(p.x*8.0,tc.y*3.0+tc.x*8.0))*0.1;\n    float sh=1.0-(smoothstep(-spike,0.05,tt.y-0.5+j)-sqrt(smoothstep(0.05,0.7,tt.y-0.5+j)));\n    sh*=smoothstep(0.0,0.1,tt.x)-smoothstep(0.9,1.0,tt.x+cos(tc0.x*9.0+tc0.y*2.0)*0.1);   \n\n    vec3 col=mix(vec3(1.4,0.9,0.5)*0.5,vec3(1.0,0.7,0.5),smoothNoise2(p*vec2(128.0,8.0)))*mix(0.1,1.0,sh)*0.5;\n    col*=vec3(1.0)+3.0*vec3(0.5,0.5,0.7)*pow(smoothNoise2(p+tc0),4.0);\n    col*=sqrt(smoothNoise2(p*8.0-tc0*4.0)*0.5+smoothNoise2(p*64.0-tc0*1.0)*0.2);\n\n    return col;\n}\n\nvec3 tex_wrck(vec2 p)\n{\n    p+=smoothNoise2(p)*0.2;\n    vec3 col=mix(vec3(0.1,0.22,0.1)*0.3,vec3(0.3,0.4,0.25),smoothNoise2(p*2.0)*0.5+smoothNoise2(p*8.0)*0.25+smoothNoise2(p*32.0)*0.125);\n    col=mix(vec3(0.4,0.3,0.1)*0.4,col*0.8,sqrt(smoothNoise2(p*64.0)*0.5+smoothNoise2(p*13.0)*0.125));\n    vec2 p2=p+smoothNoise2(p*4.0)*0.3;\n    col+=3.0*vec3(0.2,0.3,0.3)*pow(smoothNoise2(p2*4.0)*0.5,4.0);\n\n    float ly=fract(p.y*12.0)-0.5+smoothNoise2(vec2(p.x*14.0,floor(p.y)))*0.2+smoothNoise2(vec2(p.x*5.0,floor(p.y*12.0)))*0.68;\n    float lines=1.0-(smoothstep(0.0,0.1,ly)-smoothstep(0.1,0.8,ly))*0.3;\n\n    col=mix(col,col*lines*(1.0+(smoothstep(-0.05,0.0,ly)-smoothstep(0.0,0.05,ly))*0.5),smoothstep(0.0,0.5,smoothNoise2(p*4.0)));\n    col*=mix(0.7,1.0,smoothNoise2(p*16.0));\n    col=mix(col,vec3(dot(col,vec3(1.0\/3.0))),0.75);\n\n    return col*0.8;\n}\n\nvec3 tex_wmbrrw(vec2 p)\n{\n    float s=mix(0.5,1.2,sqrt(smoothNoise2(p*3.0))+smoothNoise2(p*80.0));\n    vec3 col=mix(mix(vec3(0.1),vec3(0.7,0.25,0.05),0.4)*0.4,\n                 mix(vec3(0.1),vec3(0.3,0.2,0.09),0.4)*0.7*s,\n                 sqrt(max(0.0,smoothNoise2(p*8.0)+0.15*smoothNoise2(p*32.0))))*0.7;\n    vec2 p2=p*vec2(5.0,12.0)+vec2(smoothNoise2(p*24.0),smoothNoise2(p*24.0+vec2(2.0)))*0.05;\n    p2.x+=floor(p2.y)*0.5;\n\n    float bh=pow(0.5+0.5*cos(floor(p2.y)*14.0)*cos(floor(p2.x)*1.0),2.0)*0.5;\n\n    float brick=brickt3(p2);\n    vec3 bn=normalize(vec3(brickt3(p2+vec2(1e-3,0.0))-brick,brickt3(p2+vec2(0.0,1e-3))-brick,0.04));\n\n    col*=mix(vec3(2.0),vec3(0.3+bh*1.0),brick);\n\n    col.rgb*=vec3(0.5)+vec3(0.5)*dot(bn,normalize(vec3(1.0,-1.0,1.0)));\n\n    vec2 shadp=fract(p*2.0-vec2(0.12,0.04));\n    float shadow=mix(0.2,1.0,1.0-smoothstep(0.05,0.3,length(max(vec2(0.0),abs(shadp-vec2(0.5))-vec2(0.2,0.21)))));\n    col*=shadow;\n    vec2 beamp=fract(p*2.0);\n    float hbeammask=1.0-smoothstep(0.07,0.08,abs(beamp.y-0.1));\n    float vbeammask=1.0-smoothstep(0.07,0.08,abs(beamp.x-0.1));\n\n    col*=1.0-2.0*vec3(0.4,0.4,0.5)*smoothstep(0.5,1.0,pow(max(0.0,smoothNoise2((p.yx*20.0)*vec2(1.0,1.0))),2.0));\n\n    col=mix(col,0.3*mix(vec3(1.0,0.6,0.4)*0.5,vec3(1.0,0.7,0.4)*0.3,\n                        smoothNoise2(beamp*vec2(5.0,128.0))+smoothNoise2(beamp*vec2(4.0,256.0)*2.0)*0.75\n                       ),hbeammask);\n\n    col*=smoothstep(0.05,0.16,abs(beamp.x-0.1))*smoothstep(0.05,0.16,abs(beamp.x-1.1));\n\n    col=mix(col,0.3*mix(vec3(1.0,0.6,0.4)*0.5,vec3(1.0,0.7,0.4)*0.3,\n                        smoothNoise2(beamp*vec2(128.0,5.0))+smoothNoise2(beamp*vec2(256.0,4.0)*2.0)*0.75\n                       ),vbeammask);\n\n    vec2 nn=vec2(smoothNoise2(p*1.0),smoothNoise2(p*10.0+vec2(23.0)))*2.0;\n    col*=1.0+vec3(0.4,0.4,0.5)*smoothstep(0.5,1.0,smoothNoise2((p.yx*20.0+nn)*vec2(1.0,2.0))+\n                                          smoothNoise2(p*8.0)*0.2)+smoothNoise2(p.yx*128.0)*0.3;\n\n\n    col*=1.0+vec3(0.4)*smoothstep(0.5,1.0,smoothNoise2(p.yx*2.0+nn)+smoothNoise2(p*7.0)*0.2)+smoothNoise2(p.yx*128.0)*0.3;\n\n    return col*1.75;\n}\n\nvec3 tex_nfloor6(vec2 p)\n{\n    p.x+=floor(hash(floor(p.y*2.0))*10.0);\n    p.y+=floor(hash(floor(p.x*2.0))*10.0);\n    float s=mix(0.5,1.2,sqrt(smoothNoise2(p*3.0))+smoothNoise2(p*80.0));\n    vec3 col=mix(mix(vec3(0.1),vec3(0.18,0.25,0.05),0.4)*0.4,\n                 mix(vec3(0.1),vec3(0.2,0.175,0.09),0.4)*0.7*s,\n                 sqrt(max(0.0,smoothNoise2(p*8.0)+0.15*smoothNoise2(p*32.0))))*0.7;\n    vec2 p2=p*vec2(2.0,2.0)+vec2(smoothNoise2(p*24.0),smoothNoise2(p*24.0+vec2(2.0)))*0.02;\n\n    float bh=pow(0.5+0.5*cos(floor(p2.y)*14.0)*cos(floor(p2.x)*1.0),2.0)*0.5;\n\n    float brick=brickt2(p2);\n    vec3 bn=normalize(vec3(brickt2(p2+vec2(1e-3,0.0))-brick,brickt2(p2+vec2(0.0,1e-3))-brick,0.04));\n\n    col*=mix(1.1,1.1+bh*1.0,brick);\n    vec2 nn=vec2(smoothNoise2(p*4.0),smoothNoise2(p*10.0+vec2(23.0)))*4.0;\n    col*=1.0+2.0*vec3(0.25,0.33,0.5)*smoothstep(0.5,1.0,smoothNoise2(p.yx*20.0+nn)+smoothNoise2(p*7.0)*0.2)+smoothNoise2(p.yx*128.0)*0.3;\n\n    col*=1.0+1.0*vec3(0.4)*smoothstep(0.5,1.0,smoothNoise2(p.yx*2.0+nn)+smoothNoise2(p*7.0)*0.2)+smoothNoise2(p.yx*128.0)*0.3;\n\n    col+=vec3(0.1)*smoothstep(0.4,0.9,smoothNoise2(p.yx*40.0))*smoothstep(0.8,0.9,smoothNoise2(p*50.0));\n    col*=1.2;\n\n    col.rgb*=vec3(0.6)+vec3(0.3)*dot(bn,normalize(vec3(1.0,-1.0,1.0)));\n\n    col.rgb*=vec3(1.0)+0.5*vec3(2.0,0.75,0.5)*max(0.0,1.0-abs(brick-0.6)*2.0)*1.0;\n\n    return col;\n}\n\nvec3 tex_wmcs(vec2 p)\n{\n    float s=mix(0.2,1.2,sqrt(smoothNoise2(p*3.0)));\n    vec3 col=mix(vec3(0.15,0.2,0.2)*0.4,vec3(0.2,0.15,0.11)*0.7*s,sqrt(max(0.0,smoothNoise2(p*8.0)+0.15*smoothNoise2(p*32.0))))*0.7;\n    vec2 p2=p*vec2(4.0,10.0)+vec2(smoothNoise2(p*24.0),smoothNoise2(p*24.0+vec2(2.0)))*0.02;\n    p2.x+=floor(p2.y)*0.5;\n\n    float bh=pow(0.5+0.5*cos(floor(p2.y)*14.0)*cos(floor(p2.x)*1.0),2.0);\n\n    float brick=brickt(p2);\n    vec3 bn=normalize(vec3(brickt(p2+vec2(1e-3,0.0))-brick,brickt(p2+vec2(0.0,1e-3))-brick,0.04));\n\n    col*=mix(0.9,1.4+bh*1.0,brick);\n    col*=1.0+0.4*smoothstep(0.8,0.9,smoothNoise2(p.yx*20.0)+smoothNoise2(p*70.0)*0.2)+smoothNoise2(p.yx*128.0)*0.4;\n    col*=1.0+0.5*smoothstep(0.8,0.9,smoothNoise2(p.yx*60.0)+smoothNoise2(p*7.0)*0.15)+smoothNoise2(p.yx*64.0)*0.2;\n    col*=1.1;\n    col+=vec3(0.2)*smoothstep(0.4,0.9,smoothNoise2(p.yx*20.0))*smoothstep(0.8,0.9,smoothNoise2(p*40.0));\n\n    col.rgb*=0.5+0.5*dot(bn,normalize(vec3(1.0,-1.0,1.0)));\n\n    col.rgb*=1.0+max(0.0,1.0-abs(brick-0.7)*2.0);\n\n    return col;\n}\n\nvec2 rotate(float angle, vec2 v)\n{\n    return vec2(cos(angle) * v.x + sin(angle) * v.y, cos(angle) * v.y - sin(angle) * v.x);\n}\n\n\/\/ Distance to a (non-rounded) cuboid.\nfloat cuboid(vec3 p,vec3 a,vec3 b)\n{\n    vec3 d=abs(p-(a+b))-(b-a);\n    return max(d.x,max(d.y,d.z));\n}\n\nfloat smallerTower0(vec3 p)\n{\n    float d=1e5;\n    p.xz=abs(p.xz);\n\n    {\n        float d2=dot(p.xz,normalize(vec2(1.0)))-(-1285.0 - -1680.0);\n        d=min(d,max(d2,p.y-(4257.0-2880.0)));\n    }\n\n    {\n        float d2=dot(p-(vec3(normalize(vec2(1.0))*(-1285.0- -1680.0),4257.0 - 2880.0).xzy),\n                     normalize(vec3(normalize(vec2(1.0))*(4371.0-4257.0),-(-1088.0 - -1285.0)).xzy));\n        d=min(d,max(d2,p.y-(4371.0-2880.0)));\n    }\n\n    {\n        float d2=dot(p-(vec3(normalize(vec2(1.0))*0.0,5404.0 - 2880.0).xzy),\n                     normalize(vec3(normalize(vec2(1.0))*-(4371.0 - 5404.0),(-1088.0 - -1680.0)).xzy));\n        d=min(d,max(d2,abs(p.y-((4371.0+5404.0)*0.5-2880.0))-(5404.0-4371.0)*0.5));\n    }\n\n    return d;\n}\n\nfloat smallerTower(vec3 p)\n{\n    p-=vec3(-1680, 2880, -448);\n    vec3 p2=vec3(dot(normalize(vec2(1.0)),p.xz),p.y,dot(normalize(vec2(1.0,-1.0)),p.xz));\n\n    return max(smallerTower0(p),smallerTower0(p2));\n}\n\nfloat tower0(vec3 p)\n{\n    float d=1e5;\n    p.xz=abs(p.xz);\n\n    {\n        float d2=dot(p.xz,normalize(vec2(1.0)))-(2166.0-1536.0);\n        d=min(d,max(d2,p.y-(7639.0-5440.0)));\n    }\n\n    {\n        float d2=dot(p-(vec3(normalize(vec2(1.0))*(2166.0-1536.0),7639.0-5440.0).xzy),\n                     normalize(vec3(normalize(vec2(1.0))*(7822.0-7639.0),-(2482.0-2166.0)).xzy));\n        d=min(d,max(d2,p.y-(7639.0-5440.0)));\n    }\n\n    {\n        float d2=dot(p-(vec3(normalize(vec2(1.0))*(2482.0-1536.0),7822.0-5440.0).xzy),\n                     normalize(vec3(normalize(vec2(1.0))*(9472.0-7822.0),(2482.0-1536.0)).xzy));\n        d=min(d,max(d2,abs(p.y-((7822.0+9472.0)*0.5-5440.0))-(9472.0-7822.0)*0.5));\n    }\n\n    return d;\n}\n\nfloat tower(vec3 p)\n{\n    p-=vec3(1536, 5440, -192);\n    vec3 p2=vec3(dot(normalize(vec2(1.0)),p.xz),p.y,dot(normalize(vec2(1.0,-1.0)),p.xz));\n\n    return max(tower0(p),tower0(p2));\n}\n\nfloat mountains(vec3 p)\n{\n    p=(p-vec3(640.0,28.0,65.0)).xzy;\n\n    p.y+=smoothNoise2(p.xz*20e-4)*500.0;\n\n    return dot(vec2(length(p.xz),p.y+5000.0), normalize(vec2(-1.8,1.0)))*0.75;\n}\n\n\nfloat sceneMaterial(vec3 p)\n{\n    p=p.xzy;\n\n    float material2=step(mountains(p),2.0)*2.0;\n\n    \/\/ Name=Brush1247\n    float material_d=min(cuboid(p,vec3(-16.00,-992.00,688.00),vec3(224.00,-864.00,2208.00)),\n                         cuboid(p,vec3(384.00,-992.00,688.00),vec3(624.00,-864.00,2208.00)));\n\n    \/\/ Name=Brush72\n    material_d=min(material_d,smallerTower(p.xzy));\n\n    return max(material2,max(step(material_d,1.0+step(-1600.0,p.y)),step(7640.0,p.z)));\n}\n\n\/\/ The distance to the level geometry covering the whole scene. Most of the code in this\n\/\/ function was generated by my tool.\nfloat scene(vec3 p)\n{\n    float d=-1e5;\n    p=p.xzy;\n\n    d=max(d,2.0-cuboid(p,vec3(-3020.00,-2984.00,64.00),vec3(2996.00,3032.00,5504.00))); \/\/ Name=Brush1244\n    d=min(d,mountains(p));\n\n    \/\/ Name=Brush1247\n    d=min(d,cuboid(p,vec3(-432.00,-864.00,800.00),vec3(1232.00,416.00,1880.00))); \/\/ Name=Brush852\n    d=max(d,2.0-cuboid(p,vec3(-416.00,-848.00,1856.00),vec3(1216.00,400.00,1880.00))); \/\/ Name=Brush856\n    d=min(d,cuboid(p,vec3(-304.00,-736.00,1856.00),vec3(1104.00,288.00,2208.00))); \/\/ Name=Brush858\n    d=min(d,cuboid(p,vec3(-16.00,-992.00,688.00),vec3(224.00,-864.00,2208.00))); \/\/ Name=Brush854\n    d=min(d,cuboid(p,vec3(384.00,-992.00,688.00),vec3(624.00,-864.00,2208.00))); \/\/ Name=Brush860\n    { float pls=max(dot(p,vec3(0.941742,0.000000,0.336336)) - 2406.554199,dot(p,vec3(-0.941742,0.000000,0.336336)) - 477.866821);\n     d=max(d,2.0-max(pls,cuboid(p,vec3(472.00,-992.00,1696.00),vec3(552.00,-864.00,2144.00)))); \/\/ Name=Brush82\n    }\n    { float pls=max(dot(p,vec3(0.941742,0.000000,0.336336)) - 1653.160645,dot(p,vec3(-0.941742,0.000000,0.336336)) - 1231.260254);\n     d=max(d,2.0-max(pls,cuboid(p,vec3(72.00,-992.00,1696.00),vec3(152.00,-864.00,2144.00)))); \/\/ Name=Brush84\n    }\n    d=min(d,cuboid(p,vec3(-1128.00,-608.00,1248.00),vec3(-360.00,160.00,1472.00))); \/\/ Name=Brush86\n    d=min(d,cuboid(p,vec3(-1896.00,-608.00,672.00),vec3(-1128.00,16.00,1152.00))); \/\/ Name=Brush88\n    d=max(d,2.0-cuboid(p,vec3(-1880.00,-592.00,1120.00),vec3(-1368.00, 0.00,1152.00))); \/\/ Name=Brush90\n    d=max(d,2.0-cuboid(p,vec3(-1112.00,-592.00,1440.00),vec3(-440.00,144.00,1472.00))); \/\/ Name=Brush92\n    d=min(d,cuboid(p,vec3(-1752.00,-480.00,1120.00),vec3(-1368.00,-96.00,1376.00))); \/\/ Name=Brush94\n    d=min(d,cuboid(p,vec3(-1160.00,-640.00,672.00),vec3(-1000.00,-480.00,1568.00))); \/\/ Name=Brush113\n    d=min(d,cuboid(p,vec3(-1160.00,32.00,672.00),vec3(-1000.00,192.00,1568.00))); \/\/ Name=Brush105\n    d=min(d,cuboid(p,vec3(-424.00,288.00,672.00),vec3(1256.00,736.00,2208.00))); \/\/ Name=Brush106\n    d=max(d,2.0-cuboid(p,vec3(-408.00,288.00,1856.00),vec3(-296.00,400.00,2016.00))); \/\/ Name=Brush107\n    d=max(d,2.0-cuboid(p,vec3(1112.00,288.00,1856.00),vec3(1224.00,400.00,2016.00))); \/\/ Name=Brush108\n    d=max(d,2.0-cuboid(p,vec3(-232.00,-672.00,1856.00),vec3(1048.00,288.00,2208.00))); \/\/ Name=Brush118\n    d=min(d,cuboid(p,vec3(-808.00,-416.00,1440.00),vec3(-424.00,-32.00,1880.00))); \/\/ Name=Brush109\n    { float pls=max(dot(p,vec3(-0.847999,0.000000,-0.529998)) - -2313.337891,max(dot(p,vec3(-0.000001,-0.768222,-0.640184)) - -1302.897705,max(dot(p,vec3(0.847998,-0.000000,-0.529999)) - -1960.569824,dot(p,vec3(-0.000000,0.768221,-0.640184)) - -3859.543457)));\n     d=min(d,max(pls,cuboid(p,vec3(-76.00,-1072.00,2208.00),vec3(284.00,-592.00,2400.00)))); \/\/ Name=Brush120\n    }\n    { float pls=max(dot(p,vec3(-0.847999,0.000000,-0.529998)) - -2991.736328,max(dot(p,vec3(-0.000001,-0.768222,-0.640184)) - -1302.898071,max(dot(p,vec3(0.847999,-0.000000,-0.529998)) - -1282.169800,dot(p,vec3(-0.000000,0.768221,-0.640184)) - -3859.543701)));\n     d=min(d,max(pls,cuboid(p,vec3(324.00,-1072.00,2208.00),vec3(684.00,-592.00,2400.00)))); \/\/ Name=Brush121\n    }\n    d=min(d,cuboid(p,vec3(224.00,-936.00,1920.00),vec3(384.00,-912.00,1952.00))); \/\/ Name=Brush122\n    d=min(d,cuboid(p,vec3(408.00,-480.00,1856.00),vec3(1112.00,736.00,2720.00))); \/\/ Name=Brush123\n    d=max(d,2.0-cuboid(p,vec3(-64.00,-1056.00,2360.00),vec3(272.00,-608.00,2400.00))); \/\/ Name=Brush124\n    d=max(d,2.0-cuboid(p,vec3(336.00,-1056.00,2360.00),vec3(672.00,-608.00,2400.00))); \/\/ Name=Brush125\n    d=min(d,cuboid(p,vec3(472.00,-592.00,2304.00),vec3(600.00,-480.00,2400.00))); \/\/ Name=Brush126\n    d=max(d,2.0-cuboid(p,vec3(488.00,-608.00,2360.00),vec3(584.00,-480.00,2400.00))); \/\/ Name=Brush127\n    d=min(d,cuboid(p,vec3(284.00,-864.00,2304.00),vec3(324.00,-736.00,2400.00))); \/\/ Name=Brush128\n    d=max(d,2.0-cuboid(p,vec3(272.00,-848.00,2360.00),vec3(336.00,-752.00,2400.00))); \/\/ Name=Brush129\n    d=max(d,2.0-cuboid(p,vec3(72.00,-1072.00,2360.00),vec3(136.00,-1056.00,2400.00))); \/\/ Name=Brush130\n    d=max(d,2.0-cuboid(p,vec3(472.00,-1072.00,2360.00),vec3(536.00,-1056.00,2400.00))); \/\/ Name=Brush131\n    { float pls=max(dot(p,vec3(0.664365,0.000000,0.747409)) - 3130.480957,dot(p,vec3(-0.664365,0.000000,0.747409)) - 2322.613525);\n     d=max(d,2.0-max(pls,cuboid(p,vec3(232.00,-944.00,1568.00),vec3(376.00,-720.00,1824.00)))); \/\/ Name=Brush132\n    }\n    d=max(d,2.0-cuboid(p,vec3(24.00,-720.00,1568.00),vec3(600.00,-544.00,1824.00))); \/\/ Name=Brush39\n    d=max(d,2.0-cuboid(p,vec3(488.00,-480.00,2360.00),vec3(584.00,-464.00,2504.00))); \/\/ Name=Brush40\n    d=max(d,2.0-cuboid(p,vec3(424.00,-464.00,2360.00),vec3(984.00,-192.00,2688.00))); \/\/ Name=Brush41\n    d=max(d,2.0-cuboid(p,vec3(424.00,288.00,2208.00),vec3(760.00,720.00,2688.00))); \/\/ Name=Brush46\n    d=max(d,2.0-cuboid(p,vec3(408.00,552.00,2208.00),vec3(424.00,680.00,2336.00))); \/\/ Name=Brush93\n    d=max(d,2.0-cuboid(p,vec3(-408.00,304.00,2192.00),vec3(408.00,720.00,2208.00))); \/\/ Name=Brush49\n    d=max(d,2.0-cuboid(p,vec3(280.00,288.00,2192.00),vec3(408.00,304.00,2208.00))); \/\/ Name=Brush50\n    { float pls=dot(p,vec3(0.000000,0.316228,0.948683)) - 4690.290527;\n     d=min(d,max(pls,cuboid(p,vec3(616.00,288.00,2272.00),vec3(632.00,600.00,2376.00)))); \/\/ Name=Brush53\n    }\n    { float pls=dot(p,vec3(-0.406138,0.000000,0.913812)) - 3651.997070;\n     d=min(d,max(pls,cuboid(p,vec3(472.00,600.00,2208.00),vec3(616.00,720.00,2272.00)))); \/\/ Name=Brush54\n    }\n    d=min(d,cuboid(p,vec3(616.00,480.00,2208.00),vec3(760.00,720.00,2272.00))); \/\/ Name=Brush55\n    d=min(d,cuboid(p,vec3(616.00,352.00,2208.00),vec3(760.00,416.00,2272.00))); \/\/ Name=Brush56\n\n    \/\/ Name=Brush58\n    d=min(d,tower(p.xzy));\n\n    { float pls=dot(p,vec3(0.000000,0.307820,0.951445)) - 4668.122559;\n     d=min(d,max(pls,cuboid(p,vec3(616.00,288.00,2272.00),vec3(760.00,560.00,2360.00)))); \/\/ Name=Brush65\n    }\n    d=min(d,cuboid(p,vec3(-496.00,-2136.00,672.00),vec3(592.00,-1688.00,1584.00))); \/\/ Name=Brush66\n    d=max(d,2.0-cuboid(p,vec3(80.00,-1704.00,1448.00),vec3(144.00,-1688.00,1512.00))); \/\/ Name=Brush69\n    d=max(d,2.0-cuboid(p,vec3(-176.00,-1704.00,1448.00),vec3(-112.00,-1688.00,1512.00))); \/\/ Name=Brush70\n    d=max(d,2.0-cuboid(p,vec3(-432.00,-1704.00,1448.00),vec3(-368.00,-1688.00,1512.00))); \/\/ Name=Brush71\n\n    \/\/ Name=Brush72\n    d=min(d,smallerTower(p.xzy));\n\n    { float pls=max(dot(p,vec3(-0.707107,0.000000,-0.707106)) - 531.747742,max(dot(p,vec3(-0.000001,-0.707107,-0.707106)) - -1267.131348,max(dot(p,vec3(0.707107,-0.000000,-0.707106)) - -3880.601807,dot(p,vec3(-0.000000,0.707107,-0.707107)) - -2081.721680)));\n     d=min(d,max(pls,cuboid(p,vec3(-1848.00,-576.00,1376.00),vec3(-1272.00, 0.00,1568.00)))); \/\/ Name=Brush73\n    }\n    d=max(d,2.0-cuboid(p,vec3(-1831.53,-559.53,1536.00),vec3(-1288.47,-16.47,1568.00))); \/\/ Name=Brush866\n    d=min(d,cuboid(p,vec3(-1368.00,-352.00,1120.00),vec3(-1112.00,-96.00,1568.00))); \/\/ Name=Brush864\n    { float pls=dot(p,vec3(-0.316228,0.000000,-0.948683)) - -2028.916870;\n     d=max(d,2.0-max(pls,cuboid(p,vec3(-1368.00,-328.00,1440.00),vec3(-1112.00,-120.00,1568.00)))); \/\/ Name=Brush76\n    }\n    d=min(d,cuboid(p,vec3(152.00,-560.00,1568.00),vec3(176.00,-544.00,1824.00))); \/\/ Name=Brush95\n    d=min(d,cuboid(p,vec3(448.00,-560.00,1568.00),vec3(472.00,-544.00,1824.00))); \/\/ Name=Brush97\n    d=min(d,cuboid(p,vec3(176.00,-544.00,1568.00),vec3(448.00,-536.00,1824.00))); \/\/ Name=Brush99\n    d=min(d,cuboid(p,vec3(232.00,-804.00,1706.00),vec3(376.00,-796.00,1718.00))); \/\/ Name=Brush155\n    { float pls=max(dot(p,vec3(0.000000,-0.470588,0.882353)) - 3512.470703,dot(p,vec3(0.000000,0.454709,-0.890640)) - -3531.819092);\n     d=min(d,max(pls,cuboid(p,vec3(-232.00,48.00,2016.00),vec3(264.00,288.00,2144.00)))); \/\/ Name=Brush159\n    }\n    d=max(d,2.0-cuboid(p,vec3(-616.00,-400.00,1856.00),vec3(-408.00,-48.00,1880.00))); \/\/ Name=Brush167\n    d=min(d,cuboid(p,vec3(-664.00,-288.00,1856.00),vec3(-520.00,-160.00,2048.00))); \/\/ Name=Brush168\n    d=max(d,2.0-cuboid(p,vec3(-664.00,-256.00,1856.00),vec3(-520.00,-192.00,2016.00))); \/\/ Name=Brush169\n    { float pls=max(dot(p,vec3(0.229039,0.000000,-0.973417)) - -3312.824951,dot(p,vec3(-0.229039,0.000000,0.973417)) - 3530.870605);\n     d=max(d,2.0-max(pls,cuboid(p,vec3(-1384.00,-328.00,1376.00),vec3(-1112.00,-240.00,1552.00)))); \/\/ Name=Brush265\n    }\n    d=max(d,2.0-cuboid(p,vec3(-408.00,304.00,1856.00),vec3(1240.00,416.00,2016.00))); \/\/ Name=Brush323\n    d=min(d,cuboid(p,vec3(-1384.00,-352.00,1505.50),vec3(-1309.00,-240.00,1568.00))); \/\/ Name=Brush353\n    { float pls=dot(p,vec3(-0.311770,0.000000,-0.950157)) - -2045.926514;\n     d=max(d,2.0-max(pls,cuboid(p,vec3(-1400.00,-240.00,1525.50),vec3(-1368.00,-120.00,1536.00)))); \/\/ Name=Brush355\n    }\n    d=max(d,2.0-cuboid(p,vec3(88.00,-608.00,2360.00),vec3(152.00,-592.00,2400.00))); \/\/ Name=Brush360\n    d=max(d,2.0-cuboid(p,vec3(384.00,-896.00,1568.00),vec3(392.00,-864.00,1584.00))); \/\/ Name=Brush523\n    d=max(d,2.0-cuboid(p,vec3(232.00,-896.00,1568.00),vec3(240.00,-864.00,1584.00))); \/\/ Name=Brush524\n    \/\/ Name=Brush784\n    \/\/ Name=Brush785\n    d=min(d,cuboid(p,vec3(224.00,-1824.00,688.00),vec3(384.00,-864.00,1584.00))); \/\/ Name=Brush851\n    { float pls=max(dot(p,vec3(0.000000,0.576682,0.816969)) - 741.234497,dot(p,vec3(0.000000,-0.576682,0.816969)) - 3859.928955);\n     d=max(d,2.0-max(pls,cuboid(p,vec3(224.00,-1488.00,736.00),vec3(384.00,-1216.00,1408.00)))); \/\/ Name=Brush853\n    }\n    d=min(d,cuboid(p,vec3(216.00,-1488.00,688.00),vec3(392.00,-1442.00,1312.00))); \/\/ Name=Brush855\n    { float pls=max(dot(p,vec3(0.000000,0.536233,-0.844070)) - -3762.050537,dot(p,vec3(0.000000,-0.576683,0.816968)) - 3859.932861);\n     d=min(d,max(pls,cuboid(p,vec3(216.00,-1488.00,1312.00),vec3(392.00,-1352.00,1408.00)))); \/\/ Name=Brush857\n    }\n    { float pls=max(dot(p,vec3(0.000000,-0.536233,-0.844070)) - -862.103333,dot(p,vec3(0.000000,0.576683,0.816968)) - 741.230042);\n     d=min(d,max(pls,cuboid(p,vec3(216.00,-1352.00,1312.00),vec3(392.00,-1216.00,1408.00)))); \/\/ Name=Brush859\n    }\n    d=min(d,cuboid(p,vec3(216.00,-1262.00,688.00),vec3(392.00,-1216.00,1312.00))); \/\/ Name=Brush861\n    d=max(d,2.0-cuboid(p,vec3(232.00,-1824.00,1568.00),vec3(376.00,-864.00,1584.00))); \/\/ Name=Brush865\n    d=max(d,2.0-cuboid(p,vec3(-480.00,-2112.00,1568.00),vec3(576.00,-1704.00,1584.00))); \/\/ Name=Brush867\n    d=min(d,cuboid(p,vec3(376.00,-1728.00,1376.00),vec3(456.00,-1648.00,1632.00))); \/\/ Name=Brush67\n    d=min(d,cuboid(p,vec3(152.00,-1728.00,1376.00),vec3(232.00,-1648.00,1632.00))); \/\/ Name=Brush68\n    d=min(d,cuboid(p,vec3(224.00,-1448.00,872.00),vec3(384.00,-1256.00,928.00))); \/\/ Name=Brush1140\n    { float pls=max(dot(p,vec3(-0.832049,0.000000,0.554702)) - 2658.138916,dot(p,vec3(0.832049,0.000000,0.554702)) - 5187.567871);\n     d=max(d,2.0-max(pls,cuboid(p,vec3(728.00,-416.00,3392.00),vec3(792.00,-384.00,3536.00)))); \/\/ Name=Brush1229\n    }\n    { float pls=dot(p,vec3(-0.707107,0.000000,-0.707107)) - -1448.154785;\n     d=min(d,max(pls,cuboid(p,vec3(-544.00,-592.00,1440.00),vec3(-416.00,-400.00,1696.00)))); \/\/ Name=Brush57\n    }\n    d=max(d,2.0-cuboid(p,vec3(-544.00,-544.00,1440.00),vec3(-400.00,-416.00,1552.00))); \/\/ Name=Brush60\n    { float pls=dot(p,vec3(0.000000,-0.780869,-0.624695)) - -1214.406372;\n     d=min(d,max(pls,cuboid(p,vec3(-432.00,-464.00,1492.00),vec3(-352.00,-416.00,1552.00)))); \/\/ Name=Brush63\n    }\n    { float pls=dot(p,vec3(0.000000,0.780869,-0.624695)) - -2713.674805;\n     d=min(d,max(pls,cuboid(p,vec3(-432.00,-544.00,1492.00),vec3(-352.00,-496.00,1552.00)))); \/\/ Name=Brush74\n    }\n    { float pls=max(dot(p,vec3(-0.975610,-0.000000,0.219512)) - 282.536896,max(dot(p,vec3(0.871576,0.000000,0.490261)) - 2339.308105,max(dot(p,vec3(-0.800001,-0.000000,0.599999)) - 1638.397461,dot(p,vec3(-0.284087,0.000000,0.958798)) - 3174.972900)));\n     d=max(d,2.0-max(pls,cuboid(p,vec3(208.00,-2848.00,1568.00),vec3(400.00,-2112.00,1760.00)))); \/\/ Name=Brush465\n    }\n    \/\/ Name=Brush869\n    \/\/ Name=Brush862\n    d=min(d,cuboid(p,vec3(-844.00,-228.00,2664.00),vec3(-836.00,-220.00,2920.00))); \/\/ Name=Brush100\n    d=min(d,cuboid(p,vec3(1220.00,-860.00,1856.00),vec3(1228.00,-852.00,2112.00))); \/\/ Name=Brush10\n    \/\/ Name=Brush1175\n    \/\/ Name=Brush111\n    \/\/ Name=Brush114\n    \/\/ Name=Brush115\n    \/\/ Name=Brush116\n    \/\/ Name=Brush117\n    \/\/ Name=Brush119\n    d=min(d,cuboid(p,vec3(408.00,-480.00,2720.00),vec3(424.00,736.00,2752.00))); \/\/ Name=Brush110\n    d=min(d,cuboid(p,vec3(1096.00,-480.00,2720.00),vec3(1112.00,736.00,2752.00))); \/\/ Name=Brush112\n    d=min(d,cuboid(p,vec3(424.00,720.00,2720.00),vec3(1096.00,736.00,2752.00))); \/\/ Name=Brush42\n    d=min(d,cuboid(p,vec3(424.00,-480.00,2720.00),vec3(1096.00,-464.00,2752.00))); \/\/ Name=Brush43\n    \/\/ Name=Brush101\n    { float pls=dot(p,vec3(0.000000,-0.430730,0.902481)) - 3708.376465;\n     d=min(d,max(pls,cuboid(p,vec3(280.00,-416.00,1856.00),vec3(408.00,288.00,2192.00)))); \/\/ Name=Brush51\n    }\n    { float pls=dot(p,vec3(0.000000,-0.431455,0.902134)) - 3735.306152;\n     d=min(d,max(pls,cuboid(p,vec3(264.00,-448.00,1856.00),vec3(280.00,288.00,2208.00)))); \/\/ Name=Brush52\n    }\n    \/\/ Name=Brush1\n    d=min(d,cuboid(p,vec3(188.00,-1692.00,1408.00),vec3(196.00,-1684.00,1664.00))); \/\/ Name=Brush9\n    d=min(d,cuboid(p,vec3(412.00,-1692.00,1408.00),vec3(420.00,-1684.00,1664.00))); \/\/ Name=Brush44\n    d=max(d,2.0-cuboid(p,vec3(1096.00,520.00,2736.00),vec3(1112.00,648.00,2752.00))); \/\/ Name=Brush91\n    { float pls=max(dot(p,vec3(-0.195090,0.980785,0.000000)) - 668.334656,max(dot(p,vec3(0.195090,-0.980785,0.000000)) - -604.334656,max(dot(p,vec3(0.980785,0.195091,-0.000000)) - 2393.832764,dot(p,vec3(-0.980785,-0.195091,0.000000)) - -2361.832764)));\n     d=min(d,max(pls,cuboid(p,vec3(1093.03,526.75,2736.00),vec3(1114.97,561.25,2752.00)))); \/\/ Name=Brush61\n    }\n    d=min(d,cuboid(p,vec3(1069.26,618.11,2719.03),vec3(1106.74,645.89,2752.97))); \/\/ Name=Brush64\n    { float pls=max(dot(p,vec3(-0.471398,0.881921,0.000000)) - 73.059395,max(dot(p,vec3(0.471398,-0.881921,0.000000)) - -9.059571,max(dot(p,vec3(0.881922,0.471395,-0.000000)) - 2450.862061,dot(p,vec3(-0.881922,-0.471395,0.000000)) - -2418.862305)));\n     d=min(d,max(pls,cuboid(p,vec3(1049.40,574.12,2720.00),vec3(1078.60,609.88,2736.00)))); \/\/ Name=Brush75\n    }\n    \/\/ Name=Brush78\n    \/\/ Name=Brush80\n    d=max(d,2.0-cuboid(p,vec3(800.00,720.00,2736.00),vec3(928.00,736.00,2752.00))); \/\/ Name=Brush83\n    { float pls=max(dot(p,vec3(-0.773011,0.634392,0.000000)) - -355.351471,max(dot(p,vec3(0.773011,-0.634392,0.000000)) - 419.351379,max(dot(p,vec3(0.634392,0.773011,-0.000000)) - 2217.433838,dot(p,vec3(-0.634392,-0.773011,0.000000)) - -2185.433838)));\n     d=min(d,max(pls,cuboid(p,vec3(830.56,711.67,2736.00),vec3(865.44,744.33,2752.00)))); \/\/ Name=Brush85\n    }\n    { float pls=max(dot(p,vec3(-0.923879,-0.382685,0.000000)) - -2156.288574,max(dot(p,vec3(0.923879,0.382685,-0.000000)) - 2220.288574,max(dot(p,vec3(-0.382683,0.923880,0.000000)) - 616.273071,dot(p,vec3(0.382683,-0.923880,0.000000)) - -584.272949)));\n     d=min(d,max(pls,cuboid(p,vec3(878.16,682.49,2720.00),vec3(913.84,709.51,2736.00)))); \/\/ Name=Brush87\n    }\n    { float pls=max(dot(p,vec3(-0.509803,0.000000,0.860291)) - 2943.598877,max(dot(p,vec3(0.947492,0.000000,0.319779)) - -100.432518,max(dot(p,vec3(-0.975610,0.000000,-0.219512)) - 888.975403,dot(p,vec3(-0.970143,0.000000,0.242536)) - 1967.017944)));\n     d=max(d,2.0-max(pls,cuboid(p,vec3(-720.00,1632.00,1104.00),vec3(-464.00,1888.00,1360.00)))); \/\/ Name=Brush259\n    }\n    d=min(d,cuboid(p,vec3(-720.00,1696.00,1104.00),vec3(-568.00,1888.00,1164.00))); \/\/ Name=Brush402\n    d=min(d,cuboid(p,vec3(-720.00,1696.00,1164.00),vec3(-568.00,1712.00,1180.00))); \/\/ Name=Brush467\n    d=min(d,cuboid(p,vec3(-584.00,1816.00,1164.00),vec3(-568.00,1888.00,1180.00))); \/\/ Name=Brush469\n    d=min(d,cuboid(p,vec3(-720.00,1712.00,1164.00),vec3(-704.00,1888.00,1180.00))); \/\/ Name=Brush470\n    { float pls=dot(p,vec3(-0.355995,0.000000,0.934488)) - 3215.349365;\n     d=min(d,max(pls,cuboid(p,vec3(-736.00, 4.00,1440.00),vec3(-568.00,108.00,1504.00)))); \/\/ Name=Brush48\n    }\n    d=max(d,2.0-cuboid(p,vec3(-702.67,1888.00,1164.00),vec3(-576.00,2176.00,1284.00))); \/\/ Name=Brush2\n    \/\/ Name=Brush133\n\n    d=min(d,p.z-1400.0);\n\n    return d;\n}\n\n\/\/ The camera position and Euler angles for a given point in time. The original spline\n\/\/ control points are accessible in the original level data, but it was too costly to store\n\/\/ them in the shader so I manually created an approximate path with some custom additions.\nvoid cameraPoint(float t, inout vec3 pos, inout vec3 rot)\n{\n    t=mod(t,29.0);\n\n    pos.y=3300.0;\n    pos.y+=(1.0-smoothstep(0.0,1.0,(abs(t-8.0)-2.0)*0.25)) * 2500.0;\n    pos.y-=(1.0-smoothstep(0.0,1.0,(abs(t-15.0)-0.8)*0.5)) * 1200.0;\n    pos.y+=(1.0-smoothstep(0.0,1.0,(abs(t-3.5)-0.0))) * 1000.0;\n    pos.y+=(1.0-smoothstep(0.0,1.0,(abs(t-18.0))*0.25)) * 600.0;\n\n    pos.x=600.0;\n    pos.x-=(1.0-smoothstep(0.0,1.0,(abs(t-7.0)-0.7)*0.35)) * 3000.0;\n    pos.x+=(1.0-smoothstep(0.0,1.0,(abs(t-12.0)-2.0)*0.4)) * 3500.0;\n    pos.x-=(1.0-smoothstep(0.0,1.0,(abs(t-19.0)-0.0)*0.1)) * 2500.0;\n\n    pos.z=-4200.0;\n    pos.z+=(1.0-smoothstep(0.0,1.0,(abs(t-8.1))*0.122)) * 6000.0;\n    pos.z+=(1.0-smoothstep(0.0,1.0,(abs(t-15.0)-1.0)*0.5)) * 1000.0;\n    pos.z+=(1.0-smoothstep(0.0,1.0,(abs(t-19.0)-0.5)*0.2)) * 600.0;\n\n    rot.x=0.0;\n    rot.x+=(1.0-smoothstep(0.0,1.0,abs(t-5.0)*0.5-0.0))*0.5;\n    rot.x-=(1.0-smoothstep(0.0,1.0,abs(t-10.0)*0.25-0.0))*0.15;\n    rot.x-=(1.0-smoothstep(0.0,1.0,abs(t-3.5)*0.75-0.0))*0.4;\n    rot.x-=(1.0-smoothstep(0.0,1.0,abs(t-2.0)*0.3-0.0))*0.1;\n    rot.x-=(1.0-smoothstep(0.0,1.0,(abs(t-20.0)-1.0)*0.25))*0.1;\n    rot.x+=(1.0-smoothstep(0.0,1.0,(abs(t-9.0)-1.0)))*0.1;\n    rot.x+=(1.0-smoothstep(0.0,1.0,(abs(t-12.0)-1.0)))*0.3;\n    rot.x-=(1.0-smoothstep(0.0,1.0,(abs(t-8.0))))*0.15;\n\n    rot.y=1.0;\n    rot.y+=(1.0-smoothstep(0.0,1.0,abs(t-5.0)*0.5-0.0))*0.5;\n    rot.y+=(1.0-smoothstep(0.0,1.0,abs(t-8.0)*0.5-1.0))*1.3;\n    rot.y+=(1.0-smoothstep(0.0,1.0,abs(t-13.0)*0.5-1.0))*0.4;\n    rot.y-=(1.0-smoothstep(0.0,1.0,abs(t-21.0)*0.5-1.5))*0.15;\n    rot.y-=(1.0-smoothstep(0.0,1.0,abs(t-10.0)*0.75))*0.9;\n    rot.y+=(1.0-smoothstep(0.0,1.0,(abs(t-14.0)*0.8)))*0.3;\n\n    rot.z-=(1.0-smoothstep(0.0,1.0,abs(t-20.0)*0.25-0.2))*0.1;\n    rot.z+=(1.0-smoothstep(0.0,1.0,abs(t-12.0)*0.3-0.0))*0.1;\n\n    rot.xz*=smoothstep(0.0,2.0,t)*(1.0-smoothstep(24.0,26.0,t));\n}\n\n\nfloat flareMask(vec2 p,vec2 o,vec2 d,float l,float r,float g)\n{\n    p-=o;\n    float u=dot(p,d);\n    float v=length(p-u*d);\n\n    return (1.0-(max(0.0,u)\/l))*max(0.0,(smoothstep(-r,0.0,u)-smoothstep(l-r,l,u)-smoothstep(0.0,max(r,r+u*g),v)));\n}\n\nfloat fireFbm(vec2 p)\n{\n    float f=0.0;\n    for(int i=0;i<3;i+=1)\n        f+=smoothNoise2(p*pow(2.0,float(i)))\/pow(2.0,float(i+1));\n    return f;\n}\n\nvec3 fire(vec2 p, float tm)\n{\n    float a=0.0;\n\n    vec2 p2=p+vec2(cos(p.y*8.0-tm*3.0)*0.05*clamp(p.y,0.0,1.0),0.0);\n    float fn=fireFbm(p2*5.0+vec2(0.0,-tm*4.2));\n    float fm=flareMask(p2,vec2(0.0),vec2(0.0,1.0),1.1,0.3,0.0);\n    fm*=smoothstep(0.0,0.1,p.y)*(1.0-smoothstep(0.0,max(0.0,0.5-p.y*0.4),abs(p.x)));\n    a+=pow(mix(fm*pow(max(0.0,fn),4.0),fm,fm*fm*0.9),0.4)*1.25;\n\n    a*=0.9;\n\n    return mix(vec3(1.4,0.25,0.2)*0.9,vec3(1.5,1.5,0.6),a)*a;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy \/ iResolution.xy * 2.0 - vec2(1.0);\n    uv.x*=iResolution.x\/iResolution.y;\n\n    \/\/ Set up the primary ray.\n    vec3 rd=normalize(vec3(uv.xy,-1.52));\n    vec3 ro=vec3(0.0),angs=vec3(0.0);\n    cameraPoint(time*0.5,ro,angs);\n\n    rd.yz=rotate(angs.x*3.1415926,rd.yz);\n    rd.xy=rotate(angs.z*3.1415926,rd.xy);\n    rd.zx=rotate(angs.y*3.1415926,rd.zx);\n\n    \/\/ Raymarch through the scene.\n    float t=70.0,d=0.0;\n    vec3 rp=ro;\n    float material=0.0;\n    for(int i=0;i<130;i+=1)\n    {\n        rp=ro+rd*t;\n        d=scene(rp);\n        if(d<0.1)\n            break;\n        t+=d;\n    }\n\n    \/\/ Obtain distance field gradient for material selection.\n    float d3=scene(rp+vec3(0.0,0.1,0.0))-d;\n\n    \/\/ Obtain a material index for the shading point.\n    material = sceneMaterial(rp);\n\n    vec3 rp2=rp;\n    rp2.xz=rotate(3.1415926*0.125,rp2.xz);\n\n    vec2 mtc0 = rp.xz*0.004;\n    vec2 mtc1 = rp.xz*2e-3;\n    vec2 mtc2 = (rp2.xy+vec2(rp2.z,0.0))*1e-3*vec2(2.0,1.0);\n\n    vec3 col=vec3(1.0);\n    if(material > 1.5)\n    {\n        col=tex_wrck(vec2(abs(atan(rp.z,rp.x)\/3.1415926-0.0)*8.0,rp.y*4e-4));\n    }\n    else if(d3>1e-2)\n    {\n        col=mix(tex_nfloor6(mtc0), tex_Roof(mtc0)*0.7,  material);\n    }\n    else\n    {\n        vec2 ttc=mix(mtc2, mtc1, step(d3, -1e-2));\n        col=mix(tex_wmcs(ttc), tex_wmbrrw(ttc * 2.0), material);\n    }\n\n    \/\/ Apply some good old ambient occlusion.\n    float ao = 1.0;\n    {\n        float ao_strength = 0.25, ao_eps = 80.0;\n        float w = ao_strength \/ ao_eps;\n        float dist = 2.0 * ao_eps;\n        for(int i = 0; i < 2; i++)\n        {\n            float d = scene(rp + normalize(vec3(-2.0,2.0,-4.0)) * dist);\n            ao -= (dist - d) * w;\n            w *= 0.5;\n            dist = dist * 2.0 - ao_eps;\n        }\n    }\n    ao=clamp(ao, 0.0, 1.0);\n\n\n    vec3 sun=vec3(0.5,0.5,0.4)*pow(0.5+0.5*dot(rd,normalize(vec3(-2.0,2.0,-4.0))),2.0);\n    vec3 absrp=abs(rp-vec3(-40.0,4028.0,65.0));\n    if(max(absrp.x,max(absrp.y,absrp.z))>6000.0)\n    {\n        vec2 cloudtc=rd.xz\/rd.y;\n        fragColor.rgb=mix(vec3(0.0),vec3(0.3,0.3,0.4),0.5+0.5*rd.y)*0.75;\n        fragColor.rgb+=sun;\n        fragColor.rgb=mix(fragColor.rgb,vec3(1.0),(smoothNoise2(cloudtc*4.0)*0.25+\n                                                         smoothNoise2(cloudtc*2.0)*0.5+smoothNoise2(cloudtc))*max(0.0,rd.y));\n    }\n    else\n    {\n    \t\/\/ Obtain distance field gradient for lighting.\n        float d2=scene(rp+normalize(vec3(-1.0,10.0,-1.0)))-d;\n        \n        \/\/ Apply lighting and hardcoded shadows.\n        vec3 dl=vec3(0.2,0.2,0.4)*(0.3+max(0.0,0.7+d3*7.0))*4.0*mix(0.4,1.0,ao)*smoothstep(2000.0,9000.0,rp.y+1000.0);\n        dl+=vec3(0.5,0.5,0.4)*(0.5+max(0.0,0.3+d2*7.0))*0.9*ao*smoothstep(1000.0,8000.0,rp.y+1000.0);\n        dl+=vec3(0.1,0.15,0.1)*max(0.8,(0.5+max(0.1,10.0-d2*8.0)))*0.2*(1.0-smoothstep(1000.0,3500.0,rp.y+1000.0));\n        dl*=smoothstep(0.0,1200.0,distance(rp,vec3(604.0,3228.0,-546.0)));\n        dl*=max(step(-1345.855957,rp.z),smoothstep(400.0,800.0,distance(rp,vec3(804.0,3928.0,-946.0))));\n        dl*=smoothstep(200.0,900.0,distance(rp,vec3(1204.0,4028.0,1146.0)));\n        dl*=smoothstep(20.0,900.0,distance(rp,vec3(1905.0,3728.0,1046.0)));\n        {\n            vec3 lp=rp-vec3(604.0,3228.0,-3366.0);\n            lp.x=abs(lp.x);\n            float sh=max(smoothstep(-120.0,100.0,lp.y),smoothstep(1.0,10.0,length(max(vec2(0.0),abs(lp.xz-vec2(225.0,0.0))-vec2(100.0)))));\n            dl+=(0.9+0.1*cos(time*15.0))*sh*2.0*max(0.0,0.2+d3*17.0)*vec3(1.0,0.65,0.3)*(1.0-smoothstep(0.0,280.0,distance(lp,vec3(225.0,0.0,0.0))));\n        }\n        dl*=1.0-smoothstep(1000.0,15000.0,distance(rp.xz,vec2(604.080750,1366.0)));\n        fragColor.rgb=col*dl*1.7;\n    }\n\n    \/\/ Render the first flag.\n    {\n        flagTime=time;\n        float ft=(ro.z+454.0)\/-rd.z;\n        vec3 frp=ro+rd*ft;\n        frp.x-=-1505.0;\n        frp.y-=5712.0;\n        frp.xy=frp.xy*4e-3;\n        if(abs(frp.x)<1.0 && abs(frp.y)<0.6)\n        {\n            vec4 fl=flagTexture(frp.xy);\n            fragColor.rgb=mix(fragColor.rgb,fl.rgb,fl.a*step(ft,t)*step(0.0,ft));\n        }\n    }\n\n\t\/\/ Render the second flag.\n    {\n        flagTime=time+10.0;\n        float ft=(ro.z+1720.0)\/-rd.z;\n        vec3 frp=ro+rd*ft;\n        frp.x-=2614.0;\n        frp.y-=4095.0;\n        frp.xy=frp.xy*4e-3;\n        if(abs(frp.x)<1.0 && abs(frp.y)<0.6)\n        {\n            vec4 fl=flagTexture(frp.xy);\n            fragColor.rgb=mix(fragColor.rgb,fl.rgb,fl.a*step(ft,t)*step(0.0,ft));\n        }\n    }\n\n    \/\/ Apply some fog.\n    fragColor.rgb=mix(vec3(0.15,0.15,0.18)*4.2,fragColor.rgb,exp(-t*5e-6));\n\n\n    \/\/ Render the torch flames and their reflections.\n    {\n        float ft=(ro.z+3380.0)\/-rd.z;\n        vec3 frp=ro+rd*ft;\n        frp.x=abs(frp.x-600.0);\n        frp.y-=3200.0;\n        float refl=step(frp.y,0.0);\n        frp.y=abs(frp.y);\n        frp.xy=(frp.xy-vec2(225.0,120.0))*4e-3;\n        if(abs(frp.x)<0.8 && abs(frp.y)<1.0)\n        {\n            vec3 ff=fire(frp.xy,time)*step(0.0,ft);\n            ff*=vec3((1.0-refl)*step(ft,t))+col*refl*step(0.0,rd.z)*1.5;\n            fragColor.rgb=mix(fragColor.rgb,vec3(0.0),clamp(dot(ff,vec3(1.0\/3.0))*2.0,0.0,1.0));\n            fragColor.rgb+=ff;\n        }\n    }\n\n\n    fragColor.rgb+=vec3(1.0,0.6,0.3)*(1.0-smoothstep(0.0,0.5,abs(mod(time*0.5,29.0)-1.5)))*0.12;\n\n    fragColor.rgb+=sun*0.28;\n    fragColor.rgb*=1.25;\n}\n\n\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"ts3yD7","date":"1601025359","viewed":19763,"name":"Timeless depths - cineshader","username":"kesson","description":"A timeless depths, constantly mutating over time.\n\nA raymarch experiment based on the tutorial by The Art Of Code: https:\/\/www.youtube.com\/watch?v=-adHIyjIYgk","likes":16,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Copyright 2020 - Giovanni Muzio\n\/\/ https:\/\/kesson.io\n\/\/\n\/\/ Full Shadertoy version https:\/\/www.shadertoy.com\/view\/ttlyWB\n\/\/\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/\n\n#define MAX_STEPS 100\n#define MAX_DIST 8.\n#define SURF_DIST .001\n#define GYROID_DETAILS 12\n#define WIDEANGLE 0 \/\/ set this to 1 for a wide angle pseudo-distortion\n\nmat2 rotate(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdGyroid(vec3 p, float s, float t, float b) {\n    vec3 st = p * s;\n    \n    float lx = 1.0 + ((sin(iTime * 0.0576) * 0.5) + 0.5) * 0.25;    \n    float ly = 1.0 + ((cos(iTime * 0.0565) * 0.5) + 0.5) * 0.25;\n    \n    float ls = max(lx, ly);\n    \n    return abs(dot(sin(st * lx), cos(st.zxy * ly)) - b) \/ (s * ls) - t;\n}\n\nvec3 transform(vec3 p) {\n    p.xy *= rotate(p.z * 0.1);\n    p.z += iTime * 0.1;\n    p.y -= 0.3;\n    return p;\n}\n\nfloat GetDist(vec3 p) {\n    p = transform(p);\n        \n    float s = 10.798;\n    float t = 0.03;\n    float b = 0.3;\n    float m = 0.5;\n    \n    float s1 = 1.345 + ((sin(iTime* 0.01) * 0.5) + 0.5);\n    float g1 = sdGyroid(p, s1, 0.03, 1.5);\n    \n    for (int i = 0; i < GYROID_DETAILS; i++) {\n        if (i <= 1) g1 -= sdGyroid(p, s, t, b) * m;\n        else g1 += sdGyroid(p, s, t, b) * m;\n        s *= 1.75;\n        m *= 0.75;\n    }\n    \n    float d = g1 * 0.7;\n   \t\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 bg(vec3 rd) {\n\tvec3 col = vec3(0.0);\n    float t = iTime * 0.2;\n    \n    float y = clamp(smoothstep(0.3, 1.0, rd.y * 0.5 + 0.5), 0.1, 1.0);\n    col += y * vec3(0.05, 0.18, 0.38) * 6.0;\n    \n    float a = atan(rd.x, rd.z);\n    float flares = 0.7 * sin(a*20.+t)*sin(a*2.-t)*sin(a*6.);\n    flares *= smoothstep(.0, 1.0, y);\n    col += flares;\n    col = max(col, 0.);    \n    return col;\n}\n\nvec3 getDiff(vec3 p, vec3 rd) {\n    vec3 n = GetNormal(p);\n    return reflect(rd, n);\n}\n\n\/\/ Camera matrix and movement from https:\/\/www.shadertoy.com\/view\/ldl3Dl\nvoid camera(float cd, vec2 uv, float an, out vec3 ro, out vec3 rd) {\n    ro = vec3( cd*cos(an), cd * sin(an), cd*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    rd = normalize( uv.x*uu + uv.y*vv + 2.0*ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)\/iResolution.y;\n    \n    if (WIDEANGLE == 1) {\n    \tuv += sin(uv*2.0); \/\/ wideangle distortion\n    }\n            \n    vec3 col = vec3(0.0);\n    \n    float t = iTime * 0.01;\n    \n    uv += sin(uv*20.+t)*.01;\n    \n    float an = -iTime * 0.05;\n    \n    vec3 ro, rd;\n    float cd = 0.01; \/\/ camera distance\n    camera(cd, uv, an, ro, rd); \/\/ get the camera\n    \n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        vec3 dr = getDiff(p, rd);\n    \tcol =vec3(0.0);\n        \n        p = transform(p);\n        \n    \tfloat dif = dot(n, normalize(vec3(0.0,0.0,1.0)))*.5+.5;\n        col *= dif;\n    \tcol += dif;\n        \n        float b = sdGyroid(p, 10.798, 0.03, 0.3);\n        col *= smoothstep(-0.05, 0.1, b);\n        \n        float cw = -0.02 + smoothstep(0.0, -0.5, n.y) * 0.02;\n        float c = smoothstep(cw, -0.03, b);\n        float cc = 1.0 - (sdGyroid(p+t, 6.789, 0.03, 0.3) * 4.0);\n        float cc2 = 1.0 - (sdGyroid(p-t*0.5, 3.789, 0.03, 0.3) * 2.0);\n        col += c * vec3(0.1, 0.4, 1.0) * cc * cc2 * 3.0;\n    }\n    \n    col = mix(col, bg(rd), smoothstep(0.0, MAX_DIST, d));\n    \n    fragColor = vec4(col,d \/ 3.0);\n}","name":"Image","description":"","type":"image"}]}];    var gUseScreenshots = piIsMobile();
    var gThemeName = "classic";



    </script>
</head>

<!-- <body onload="resultsInit(12,null,null)"> -->
<body onload="resultsInitStatic(12,null,null)">

<!-- header =================================================================================== -->


<div id="header">

    <div id="headerBlock1">
        <a href="/" id="headerTitle">Shadertoy</a>
        <form name="formSearch" action="/results" method="get" style="display:inline-block;">
        <div  id="headerSearch">
            <input type="search" id="mySearch" name="query" placeholder="Search..." value=""/>
        </div>
        </form>
    </div>

    <div id="headerBlock2">
            <a class="headerLinks" href="/browse">Browse</a>
        <a class="headerLinks" href="/new">New</a>
        <a class="headerLinks" href="/signin">Sign In</a>
        </div>
</div>
<!-- content ================================================================================== -->

<div id="content">

  <div id="controls">
    <div>
      <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
      Sort:      </div>
      <div class="controlOptions"><div class="pageButtonsCurrent" href="/results?query=&sort=popular&filter=">Popular</div><a class="pageButtons" href="/results?query=&sort=newest&filter=">Newest</a><a class="pageButtons" href="/results?query=&sort=love&filter=">Love</a><a class="pageButtons" href="/results?query=&sort=hot&filter=">Hot</a></div>
    </div>

    <div id="controlFilter">
      <div style="display:flex;margin-right:8px;align-items:center;">Filter:</div>
      <div class="controlOptions"> <a class="pageButtons" href="/results?query=&sort=popular&filter=multipass">Multipass</a><a class="pageButtons" href="/results?query=&sort=popular&filter=soundoutput">GPU Sound</a><a class="pageButtons" href="/results?query=&sort=popular&filter=vr">VR</a><a class="pageButtons" href="/results?query=&sort=popular&filter=soundinput">Microphone</a><a class="pageButtons" href="/results?query=&sort=popular&filter=musicstream">Soundcloud</a><a class="pageButtons" href="/results?query=&sort=popular&filter=webcam">Webcam</a></div>
    </div>

    <div>
        <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
        View:</div>
        <div><a class="pageButtons" href="/slideshow?query=&sort=popular">Slideshow</a></div>
    </div>

    <div class="navigation" id="navTop" ><span style="padding-right:8px;">Results (74098):</span><div class="controlOptions"><a id="pageButtonFirst" class="pageButtons" href="results?query=&sort=popular&from=0&num=12">1</a><span>...</span><a id="pageButton"0 class="pageButtons" href="results?query=&sort=popular&from=264&num=12">23</a><a id="pageButton"1 class="pageButtons" href="results?query=&sort=popular&from=276&num=12">24</a><div id="pageButton"2 class="pageButtonsCurrent" href="results?query=&sort=popular&from=288&num=12">25</div><a id="pageButton"3 class="pageButtons" href="results?query=&sort=popular&from=300&num=12">26</a><a id="pageButton"4 class="pageButtons" href="results?query=&sort=popular&from=312&num=12">27</a><span>...</span><a id="pageButtonLast" class="pageButtons" href="results?query=&sort=popular&from=74088&num=12">6175</a></div>
</div>
  </div>


  <div id="shaderGrid">
    <div class='searchResult'><div class='searchResultContainer' id='Preview_0_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_0_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_0_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_0_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_0_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_0_Thumnail'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_0_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_0_Info'>  <span class='previewText'  id='Preview_0_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_0_TextUser'></span>  <span class='previewStats' id='Preview_0_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_1_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_1_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_1_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_1_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_1_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_1_Thumnail'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_1_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_1_Info'>  <span class='previewText'  id='Preview_1_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_1_TextUser'></span>  <span class='previewStats' id='Preview_1_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_2_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_2_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_2_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_2_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_2_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_2_Thumnail'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_2_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_2_Info'>  <span class='previewText'  id='Preview_2_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_2_TextUser'></span>  <span class='previewStats' id='Preview_2_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_3_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_3_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_3_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_3_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_3_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_3_Thumnail'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_3_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_3_Info'>  <span class='previewText'  id='Preview_3_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_3_TextUser'></span>  <span class='previewStats' id='Preview_3_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_4_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_4_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_4_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_4_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_4_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_4_Thumnail'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_4_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_4_Info'>  <span class='previewText'  id='Preview_4_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_4_TextUser'></span>  <span class='previewStats' id='Preview_4_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_5_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_5_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_5_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_5_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_5_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_5_Thumnail'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_5_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_5_Info'>  <span class='previewText'  id='Preview_5_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_5_TextUser'></span>  <span class='previewStats' id='Preview_5_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_6_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_6_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_6_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_6_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_6_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_6_Thumnail'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_6_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_6_Info'>  <span class='previewText'  id='Preview_6_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_6_TextUser'></span>  <span class='previewStats' id='Preview_6_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_7_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_7_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_7_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_7_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_7_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_7_Thumnail'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_7_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_7_Info'>  <span class='previewText'  id='Preview_7_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_7_TextUser'></span>  <span class='previewStats' id='Preview_7_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_8_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_8_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_8_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_8_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_8_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_8_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_8_Thumnail'>        <img class='previewThumbnailImage' id='Preview_8_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_8_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_8_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_8_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_8_Info'>  <span class='previewText'  id='Preview_8_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_8_TextUser'></span>  <span class='previewStats' id='Preview_8_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_9_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_9_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_9_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_9_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_9_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_9_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_9_Thumnail'>        <img class='previewThumbnailImage' id='Preview_9_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_9_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_9_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_9_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_9_Info'>  <span class='previewText'  id='Preview_9_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_9_TextUser'></span>  <span class='previewStats' id='Preview_9_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_10_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_10_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_10_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_10_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_10_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_10_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_10_Thumnail'>        <img class='previewThumbnailImage' id='Preview_10_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_10_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_10_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_10_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_10_Info'>  <span class='previewText'  id='Preview_10_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_10_TextUser'></span>  <span class='previewStats' id='Preview_10_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_11_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_11_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_11_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_11_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_11_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_11_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_11_Thumnail'>        <img class='previewThumbnailImage' id='Preview_11_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_11_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_11_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_11_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_11_Info'>  <span class='previewText'  id='Preview_11_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_11_TextUser'></span>  <span class='previewStats' id='Preview_11_Stats'></span></div></div>  </div>
  <br>
  <div class="navigation" id="navBottom" ><span style="padding-right:8px;">Results (74098):</span><div class="controlOptions"><a id="pageButtonFirst" class="pageButtons" href="results?query=&sort=popular&from=0&num=12">1</a><span>...</span><a id="pageButton"0 class="pageButtons" href="results?query=&sort=popular&from=264&num=12">23</a><a id="pageButton"1 class="pageButtons" href="results?query=&sort=popular&from=276&num=12">24</a><div id="pageButton"2 class="pageButtonsCurrent" href="results?query=&sort=popular&from=288&num=12">25</div><a id="pageButton"3 class="pageButtons" href="results?query=&sort=popular&from=300&num=12">26</a><a id="pageButton"4 class="pageButtons" href="results?query=&sort=popular&from=312&num=12">27</a><span>...</span><a id="pageButtonLast" class="pageButtons" href="results?query=&sort=popular&from=74088&num=12">6175</a></div>
</div>  <br>      
</div>

<!-- footer ================================================================================== -->

<div id="footer">
    
    <div><span style="color:#ffffff;">Community Forums</span>
      <ul>
      <li><a class="regular" href="/events">Official Events</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/147749602472741">In Facebook (english)</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/1339783682699494">In Facebook (korean)</a></li>
      <li><a class="regular" href="https://discord.gg/XtmMN6E">In Discord</a> (<a class="regular" href="https://discordapp.com/channels/578696555612209173/579531723348639754">direct link</a>)</li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Feedback and Support</span>
      <ul>
      <li><a class="regular" href="https://www.facebook.com/Shadertoy">Facebook</a></li>
      <li><a class="regular" href="https://twitter.com/shadertoy">Twitter</a></li>
      <li><a class="regular" href="https://www.patreon.com/shadertoy">Patreon</a></li>
      <li><a class="regular" href="https://trello.com/b/5hM0CjId">Roadmap</a></li>

      
      </ul>
    </div>

    <div><span style="color:#ffffff;">Shadertoy</span>
      <ul>
      <li><a class="regular" href="/store">Store</a></li>
      <li><a class="regular" href="/howto">Documentation</a></li>
      <li><a class="regular" href="/terms">Terms & Privacy</a></li>
      <li><a class="regular" href="/about">About</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Apps and Plugins</span>
      <ul>
      <li><a class="regular" href="https://itunes.apple.com/us/app/shadertoy/id717961814">Official iPhone App</a> by <a class="user" href="/user/reinder">Reinder</a></li>
      <li><a class="regular" href="https://steamcommunity.com/sharedfiles/filedetails/?id=1726697188">Screensaver</a> by <a class="user" href="/user/kosro">Kosro</a></li>
      <li><a class="regular" href="https://chrome.google.com/webstore/detail/shadertoy-unofficial-plug/ohicbclhdmkhoabobgppffepcopomhgl">Shadertoy plugin</a> by <a class="user" href="/user/patu">Patu</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Tutorials</span>
      <ul>
      <li><a class="regular" href="https://www.youtube.com/watch?v=0ifChJ0nJfM">Shader coding intro</a> by <a class="user" href="/user/iq">iq</a></li>
      <li><a class="regular" href="https://shadertoyunofficial.wordpress.com/">Shadertoy Unofficial</a> by <a class="user" href="/user/FabriceNeyret2">FabriceNeyret2</a></li>
      </ul>
    </div>

</div>

<div id="compliance" style="padding-bottom:6px;visibility:hidden;left:0;top:0px;width:100%;background-color:rgb(200,120,20,0.93);position:absolute;color:#FFFFFF">
    <div style="text-align: center; margin-top:8px">
        We use cookies to give you the best experience on our website. If you continue using Shadertoy, we'll assume that you are happy to receive all cookies on this website. 
        For more information, please review our <a class="regular" href="/terms">Terms & Privacy</a>.
    </div> 
    <div style="text-align: center;margin-top:6px">
        <button type="button" style="width:100px;font-size:inherit" onclick="acceptCompliance()">Accept</button>
    </div>
</div>

<script>
(function runCompliance() 
{
    let showCompliance = 1;
    let allcookies = document.cookie;
    let cookiearray = allcookies.split(';');
    for (var i=0; i<cookiearray.length; i++)
    {
        let name  = cookiearray[i].split('=')[0];
        let value = cookiearray[i].split('=')[1];
        if (name.trim() == "scmp") 
        {
            showCompliance = value;
            break;
        }
    }

    if (showCompliance === 1) 
    {
        var ve = document.getElementById("compliance");
        ve.style.visibility="visible";
    }
})();

function acceptCompliance()
{
    let now = new Date();
    now.setTime( now.getTime() + (5*365*24*60*60*1000) );
    document.cookie="scmp=0;expires=" + now.toUTCString() + ";";

    var ve = document.getElementById("compliance");
    ve.style.visibility="hidden";
}
</script>

</body>
</html>
