<!DOCTYPE HTML>
<html lang="en">
<head>

    
<script async src="https://www.googletagmanager.com/gtag/js?id=G-7SYLWGZYJ2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-7SYLWGZYJ2');
</script>

<title>Browse (51) - Shadertoy BETA</title>
<meta charset="utf-8" />
<meta name="Keywords" content="shadertoy, shader toy, quilez, inigo, jeremias, pol, fractals, demoscene, computer graphics, mathematics, rendering, demo, 3D, realtime, shader, raytracing, raymarching, webgl, glsl" />
<meta name="Description" content="Build shaders, share them, and learn from the best community." />
<meta name="Author" content="Beautypi" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<link rel="image_src" href="https://www.shadertoy.com/img/logo.png" />
<link rel="apple-touch-icon" href="/img/launch_icon_57.png"/>
<link rel="apple-touch-icon" sizes="72x72" href="/img/launch_icon_72.png"/>
<link rel="apple-touch-icon" sizes="114x114" href="/img/launch_icon_114.png"/>
<link rel="shortcut icon" href="/img/favicon.ico"/>

<style>::-webkit-scrollbar {
    height: 8px;
    width: 8px;
    background: #404040;
}

::-webkit-scrollbar-thumb
{
    background: #909090;
    border-radius: 0ex;
}

::-webkit-scrollbar-corner
{
    background: #000;
}

::-webkit-input-placeholder
{
	font-style:italic;
}
input:-moz-placeholder, textarea:-moz-placeholder
{
	font-style:italic;
}
input.placeholder-text, textarea.placeholder-text
{
	font-style:italic;
}

pre 
{
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
    white-space: -pre-wrap;
    white-space: -o-pre-wrap;
    word-wrap: break-word;
}

@font-face
{
    font-family: Lobster;
    src: url("/img/lobster.otf") format("opentype");
}

div#centerScreen
{
    left: 50%;
    top: 50%;
    position: absolute;
}

a.headerLinks:hover
{
    background-color:#505050;
    color : #ff8020;
}

body
{
    color: #000000;
    font-size:12px;
    font-style:normal;
    font-family:Tahoma,Arial;
    background-repeat: no-repeat;
    //background-attachment: fixed;
    padding:0px;
    margin:0px;
    text-align: left;
    background-color: #d0d0d0;
    background-repeat: repeat;
    user-select: text;
}

a,
a:hover,
a:visited
{
  color : inherit;
}

div#content {
    width: 95%;
    overflow: hidden;
    margin: auto;
    padding: 0px;
    min-height: calc(100vh - 80px);
    //box-sizing: border-box;
}


.notificationCount
{
 background-color:#ff0000;
 padding-left:3px;
 padding-right:1px;
 padding-top:1px;
 padding-bottom:1px;
}

div#header
{
    background-color: #404040;
    top: 0px;
    left: 0px;
    width: 100%;
    padding: 0;
    margin: 0;
    color: #ffffff;
    display: flex;
    flex-direction:row;
}

#headerBlock1
{
    width: 50%;
    display:flex;
    align-items:center;
}

a#headerTitle
{
    font-size: 2.25em;
    font-family: Lobster,Tahoma,Arial;
    text-decoration: none;
    padding-left:32px;
    padding-right:32px;
}

#headerSearch
{
    display: inline-block;
    color: #000000;
    width: 300px;
}

input[type=search]#mySearch
{
    width: 100%;
    border-radius: 6px;
    border: 1px solid black;
    padding:12px;
}

#headerBlock2
{
    width: 50%;
    margin-left: auto;
    display: flex;
    justify-content: flex-end;
}


a#headerTitle:hover
{
    color : #ff8020;
}

a.headerLinks
{
    font-weight: bold;
    padding-top: 14px;
    padding-bottom: 14px;
    padding-left: 14px;
    padding-right: 14px;
    margin:0px;
    text-decoration: none;
    transition: background-color 0.15s linear, color 0.15s linear;
}

#footer
{
    background-color: rgba(64,64,64,0.25);
    color: #000000;
    padding: 0px;
    margin: 0px;
    width: 100%;
    display: flex;
    justify-content: space-between;
    flex-wrap: wrap;
}

#footer div
{
    padding-top:10px;
    padding-bottom:0px;
    padding-left:16px;
    padding-right:16px;
}

#footer div ul
{
    margin-left:0px;
    padding-left:16px;
}

#footer div ul li
{
    padding-top:6px;
}

a.regular
{
    font-weight:bold;
    text-decoration:none
}

a.regular:hover
{
  color : #ff8020;
}

a.user
{
    font-weight:bold;
    text-decoration:none;
}

a.user:hover
{
  color : #ff8020;
  text-decoration: underline;
}

.uiButton
{
    border: none;
    outline: none;
    margin: 0px;
    padding: 0px;
    width: 22px;
    height: 22px;
    position: absolute;
    cursor: pointer;
    border-radius: 4px;
}

.uiButton:hover
{
    box-shadow: inset 0px 0px 1px 1px #808080, 0px 0px 1px 1px #808080;
}

.uiDivBUtton
{
    cursor:pointer;
}

.uiDivBUtton:hover
{
    color: #ffffff;
}


.dialog
{
    display: block;
    background-color: #e0e0e0;
    color: #000000;
    border:1px solid #000;
    padding:0px;
    margin:0px;
    text-align:left;
    border-radius: 4px;
    box-shadow:4px 4px 6px 0px rgba(0,0,0,0.5);
    overflow: hidden;
    z-index:1000;
    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;
}

.dialogHeader
{
    left:0px;
    top: 0px;
    width:100%;
    height:32px;
    position: absolute;
    background-color: #808080;
    cursor:move;
}

.dialogTitle
{
    left: 12px;
    top: 4px;
    position: absolute;
    padding: 0px;
    margin: 0px;
    color:#000000;
    font-size:1.5em;
    text-align: left;
    user-select: none;
    -moz-user-select: -moz-none;
    -webkit-user-select: none;
}

.dialogOverlay
{
    z-index:1000;

    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;

    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    width:100%;
    height:100%;
    position:absolute;

    background-color:rgba(0,0,0,.4);
}

.viewsIcon, .likesIcon
{
    border: none;
    outline: none;
    display:inline-block;
    background-repeat:no-repeat;
    top:0px;
    left:0px;
    padding:0px;
    padding-right: 2px;
    margin:0px;
    position:relative;
}

.userPictureSmall
{
    background-color:#808080;
    border: 1px solid #000000;
    width:32px;
    height:32px;
}

.dialogCloseButton
{
    right:8px;
    top: 4px;
    width:22px;
    height:22px;
    position: absolute;
    background-image: url("/img/close.png");
    cursor: pointer;
    border-radius: 4px;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContentButtons
{
     padding:0;
     border:0;
     text-align: justify;
     left: 24px;
     bottom:40px;
     position:absolute;
}

.dialogButton
{
    text-align: center;
    vertical-align: middle;
    display: inline-block;
    border-radius: 4px;
    font-weight: bold;
    cursor: pointer;
    padding-bottom:5px;
    padding-top:4px;
    padding-left: 8px;
    padding-right: 8px;
    margin-left:4px;
    margin-right:4px;
    text-decoration: none;
    color:#000000;
    width: 80px;
    -moz-transition:    background-color 0.15s linear, color 0.15s linear;
    -webkit-transition: background-color 0.15s linear, color 0.15s linear;
    transition:         background-color 0.15s linear, color 0.15s linear;
}

.dialogButton:hover
{
  background-color:#808080;
  color : #ff8020;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContent
{
    color: inherit;
    overflow: auto;
    width:100%;
    height:100%;
    left: 0px;
    top: 32px;
    position:absolute
}

.dialogContentBody
{
    color: inherit;
    width:100%;
    height:auto;
    padding-top:24px;
    padding-bottom:24px;
    padding-left:24px;
    padding-right:24px;
    text-align: left;
}

.formButton
{
    font-weight:bold;
	color:#ffffff;
	border:none;
    text-align:center;
	background-color:#808080;
    border-radius: 4px;
	padding-left:8px;
	padding-right:8px;
	padding-top:4px;
	padding-bottom:4px;
    cursor:pointer;
    min-width:80px;
    box-sizing: border-box;
}
.formInput {
    border-radius: 6px;
    border: 1px solid black;
    padding: 4px;
    border: none;
}
.formButton:hover {
    background-color: #e0e0e0;
}
.formButton:disabled
{
	color:#b0b0b0;
	background-color:#808080;
}

.formButtonSmall
{
    color:#ffffff;
    border:none;
    text-align:center;
    background-color:#808080;
    border-radius: 4px;
    padding-left:2px;
    padding-right:2px;
    padding-top:2px;
    padding-bottom:2px;
    cursor:pointer;
    min-width:40px;
}

.formButtonSmall:hover
{
    background-color: #e0e0e0;
}

.formButtonSmall:disabled
{
    color:#b0b0b0;
    background-color:#808080;
}

.formButtonSmall.disabled2,
.formButton.disabled2 { color:#b0b0b0; background-color:#808080; pointer-events: none; }

.inputForm
{
    padding-left:2%;
    padding-right:2%;
    resize: none;
    text-align: left;
    background-color:#e0e0e0;
    outline: none;
    border-radius: 4px;
    border: 1px solid #808080;
    color:inherit;
    box-sizing: border-box;
}

.inputForm:focus
{
    border: 1px solid #AFCDD8;
    background-color: #EBF2F4;
}

.transparentPannel
{
    background-color:rgba(64,64,64,0.1);
    padding:16px;
}

.comment, .commentSelf, .commentNew
{
    border-radius: 4px;
    width: 100%;
    margin-left: 0px;
    margin-right: 0px;
    margin-top: 0px;
    margin-bottom: 6px;

    padding: 14px;
    box-sizing: border-box;
    display: grid;
    grid-template-columns: 32px auto 8px;
    grid-template-rows: 1fr;
    grid-gap:8px;
}

.comment:nth-child(even)
{
    background-color: rgba(64,64,64,0.1);
}

.comment:nth-child(odd)
{
    background-color: rgba(128,128,128,0.1);
}

.commentSelf
{
    background-color: rgba(240,160,64,0.1);
}

.commentNew
{
    padding-right: 0px;
    grid-template-columns: 40px auto;
}

.commentContent
{
    vertical-align: top;
    text-align: left;
    word-break: break-all;
    word-break: break-word;
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
}


/* ----------------------- media resolutions ------------------------ */

@media screen and (max-width:799px)
{
    div#header {flex-direction:column; }
    #headerBlock1 { width:100%; }
    #headerBlock2 { width:100%; justify-content: space-around;}
    div#headerSearch {width:200px;}
    input#mySearch { width:200px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:10px; }
}

@media screen and (min-width:800px) and (max-width:1279px)
{
    body { font-size: 9px; }
    div#headerSearch {width: 250px;}
    input#mySearch { width:250px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:11px; }
}

@media screen and (min-width:1280px) and (max-width:1439px)
{
    body { font-size: 10px; }
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1440px) and (max-width:1919px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1920px) and (max-width:2559px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}

@media screen and (min-width:2560px) 
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}
body
{
    background-image: url("/img/themes/classic/background.jpg");
}
</style>

    <script>"use strict"

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piCamera
//
//==============================================================================

function piCamera()
{
    var mMatrix = setIdentity();
    var mMatrixInv = setIdentity();

    var mPosition = [0.0,0.0,0.0];
    var mXRotation = 0.0;
    var mYRotation = 0.0;

    var mPositionTarget = [0.0,0.0,0.0];
    var mXRotationTarget = 0.0;
    var mYRotationTarget = 0.0;

    var me = {};
/*
    me.Set = function( pos, dir, roll) 
             {
                 mMatrix    = setLookat( pos, add(pos,dir), [Math.sin(roll),Math.cos(roll),Math.sin(roll)] );
                 mMatrixInv = invertFast( mMatrix );
             };
*/
    me.SetPos = function(pos)
                {
                    mPosition = pos;
                    //mMatrix[ 3] = -(mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                    //mMatrix[ 7] = -(mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                    //mMatrix[11] = -(mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                };
/*
    me.GlobalMove = function(pos)
                    {
                        mMatrix[ 3] -= (mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                        mMatrix[ 7] -= (mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                        mMatrix[11] -= (mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                        mMatrixInv = invertFast(mMatrix);
                    };
*/
    me.LocalMove = function( dis )
                    {
                        dis = matMulvec( setRotationY(-mYRotation), dis);
                        mPositionTarget = sub(mPositionTarget,dis)
                    };

    me.RotateXY = function( x, y)
                  {
                    mXRotationTarget -= x;
                    mYRotationTarget -= y;
                    mXRotationTarget = Math.min( Math.max( mXRotationTarget, -Math.PI/2), Math.PI/2 );
                  };


    me.CameraExectue = function( dt )
    {
        // smooth position
        mXRotation += (mXRotationTarget-mXRotation) * 12.0*dt;
        mYRotation += (mYRotationTarget-mYRotation) * 12.0*dt;
        mPosition = add(mPosition, mul( sub(mPositionTarget, mPosition), 12.0*dt));

        // Make Camera matrix
        mMatrix = matMul( matMul(setRotationX(mXRotation), 
                                 setRotationY(mYRotation)),  
                                 setTranslation(mPosition));
        mMatrixInv = invertFast(mMatrix);

    }

    me.GetMatrix = function() { return mMatrix; };
    me.GetMatrixInverse = function() { return mMatrixInv; };
    me.SetMatrix = function( mat ) 
                    {
                        mMatrix = mat;
                        mMatrixInv = invertFast(mMatrix);

                        mPosition = getXYZ(matMulpoint(mat, [0.0,0.0,0.0]));
                        mPositionTarget = mPosition;
                    };

    me.GetPos = function() { return getXYZ(matMulpoint(mMatrixInv, [0.0,0.0,0.0])); }
    me.GetDir = function() { return getXYZ(normalize(matMulvec(mMatrixInv, [0.0,0.0,-1.0]))); }

    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piFile
//
//==============================================================================

function piFile( binaryDataArrayBuffer )
{
    // private
    //var mDataView = new DataView( binaryDataArrayBuffer, 0 );
    var mDataView = binaryDataArrayBuffer;
    var mOffset = 0;

    // public members
    var me = {};
    me.mDummy = 0;
/*
    // public functions
    me.Seek = function( off ) { mOffset = off - 3; };
    me.ReadUInt16 = function()  { var res = mDataView.getUint16( mOffset ); mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = mDataView.getUint32( mOffset ); mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = mDataView.getFloat32( mOffset ); mOffset+=4; return res; };
*/

    me.Seek = function( off ) { mOffset = off; };
    me.ReadUInt8  = function()  { var res = (new Uint8Array(mDataView,mOffset))[0]; mOffset+=1; return res; };
    me.ReadUInt16 = function()  { var res = (new Uint16Array(mDataView,mOffset))[0]; mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = (new Uint32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = (new Float32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadFloat32Array = function(n) 
                          { 
                              var src = new Float32Array(mDataView, mOffset);
                              var res = [];  for( var i=0; i<n; i++ ) { res[i] = src[i]; }
                              mOffset += 4*n;
                              return res;
                          };
    me.ReadFloat32ArrayNative = function(n) { var src = new Float32Array(mDataView, mOffset); mOffset += 4*n; return src; };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piMesh
//
//==============================================================================

function piMesh()
{
    this.mChunks = [];
    this.mPrimitiveType = 0;
    this.mVertexFormat = null;
}

/*
piMesh.prototype.normalize = function( ppos, npos )
{
    var numv = this.mVertexData.length;
    var numt = this.mIndices.length;

    for( var i=0; i<numv; i++ )
    {
        //float *v = (float*)piMesh_GetVertexData( me, i, npos );
        //v[0] = 0.0f;
        //v[1] = 0.0f;
        //v[2] = 0.0f;
        this.mVerts[8 * i + 3] = 0.0;
        this.mVerts[8 * i + 4] = 0.0;
        this.mVerts[8 * i + 5] = 0.0;
    }

    for( var i=0; i<numt; i++ )
    {
        piMeshFace *face = me->mFaceData.mIndexArray[0].mBuffer + i;

        const int ft = face->mNum;
        
        vec3 nor = vec3( 0.0f, 0.0f, 0.0f );
        for( int j=0; j<ft; j++ )
        {
            const vec3 va = *((vec3*)piMesh_GetVertexData( me, face->mIndex[ j      ], ppos ));
            const vec3 vb = *((vec3*)piMesh_GetVertexData( me, face->mIndex[(j+1)%ft], ppos ));

            nor += cross( va, vb );
        }

        for( int j=0; j<ft; j++ )
        {
            vec3 *n = (vec3*)piMesh_GetVertexData( me, face->mIndex[j], npos );
            n->x += nor.x;
            n->y += nor.y;
            n->z += nor.z;
        }
    }

    for( var i=0; i<numv; i++ )
    {
        vec3 *v = (vec3*)piMesh_GetVertexData( me, i, npos );
        *v = normalize( *v );
    }
}
*/

piMesh.prototype.createCube = function(renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([ -1.0, -1.0, -1.0,
                                       1.0, -1.0, -1.0,
                                      -1.0,  1.0, -1.0,
                                       1.0,  1.0, -1.0,
                                      -1.0, -1.0,  1.0,
                                       1.0, -1.0,  1.0,
                                      -1.0,  1.0,  1.0,
                                       1.0,  1.0,  1.0 ]),

                        mIndices : new Uint16Array([ 0, 2, 1,   1, 2, 3,   5, 1, 3,   5, 3, 7,   4, 5, 7,   4, 7, 6,   4, 6, 2,   4, 2, 0,   6, 7, 3,   6, 3, 2,   4, 0, 1,   4, 1, 5 ]),
                        mNumVertices : 8,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };

    this.mVertexFormat = { mStride:12, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}

piMesh.prototype.createCubeSharp = function (renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 1.0,
                                    -1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 0.0,

                                     1.0, 1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 0.0,

                                     1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 1.0,
                                    -1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   1.0, 1.0,
                                     1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   1.0, 0.0,

                                    -1.0, 1.0, 1.0,  -1.0, 0.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0,-1.0,  -1.0, 0.0, 0.0,   0.0, 1.0,
                                    -1.0,-1.0,-1.0,  -1.0, 0.0, 0.0,   1.0, 1.0,
                                    -1.0,-1.0, 1.0,  -1.0, 0.0, 0.0,   1.0, 0.0 ]),

                        mIndices : new Uint16Array([0,1,2, 0,2,3,   4,5,6, 4,6,7,    8,9,10,8,10,11,   12,13,14,12,14,15,   16,17,18,16,18,19,   20,21,22,20,22,23]),
                        mNumVertices : 24,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };


    this.mVertexFormat = { mStride:32, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}


piMesh.prototype.createUnitQuad = function (renderer)
{
    this.mPrimitiveType = 0;
    this.mVertexFormat = { mStride:8, mChannels: [ {mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false} ] };

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0,  1.0, 1.0,  1.0]),
                        mIndices : new Uint16Array([0, 2, 1, 1, 2, 3]),
                        mNumVertices : 4,
                        mNumFaces : 2, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };
 
    return true;
}




piMesh.prototype.destroy = function()
{
    //delete this.mVerts;   this.mVerts = null;
    //delete this.mIndices; this.mIndices = null;
}

piMesh.prototype.scale = function (x, y, z)
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] *= x;
            this.mChunks[j].mVerts[stride * i + 1] *= y;
            this.mChunks[j].mVerts[stride * i + 2] *= z;
        }
    }
}

piMesh.prototype.translate = function (x, y, z) 
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] += x;
            this.mChunks[j].mVerts[stride * i + 1] += y;
            this.mChunks[j].mVerts[stride * i + 2] += z;
        }
    }
}

piMesh.prototype.GPULoad = function (renderer)
{
    for( var i=0; i<this.mChunks.length; i++ )
    {
        var vbo = renderer.CreateVertexArray(this.mChunks[i].mVerts, renderer.BUFTYPE.STATIC );
        if (vbo == null)
            return false;

        var ibo = renderer.CreateIndexArray(this.mChunks[i].mIndices, renderer.BUFTYPE.STATIC);
        if (ibo == null)
            return false;

        this.mChunks[i].mVBO = vbo;
        this.mChunks[i].mIBO = ibo;
    }
    return true;
}

piMesh.prototype.GPURender = function (renderer, positions )//, matPrj, matCam )
{
    //renderer.SetShaderConstantMat4F("unMPrj", matPrj, false );

    var num = this.mChunks.length;
    for( var i=0; i<num; i++ )
    {
        //var mat =  matMul( matCam, this.mChunks[i].mTransform );
        //renderer.SetShaderConstantMat4F("unMMod", mat, false);

        renderer.AttachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat, positions );
        renderer.AttachIndexArray(this.mChunks[i].mIBO );
        renderer.DrawPrimitive(renderer.PRIMTYPE.TRIANGLES, this.mChunks[i].mNumFaces * 3, true, 1);
        renderer.DetachIndexArray(this.mChunks[i].mIBO);
        renderer.DetachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat );
    }
}
//==============================================================================
//
// piLibs 2014-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piRenderer
//
//==============================================================================

function piRenderer()
{
    // private members

    var mGL = null;
    var mBindedShader = null;
    var mIs20 = false;
    var mFloat32Textures;
    var mFloat32Filter;
    var mFloat16Textures;
    var mDrawBuffers;
    var mDepthTextures;
    var mDerivatives;
    var mFloat16Filter;
    var mShaderTextureLOD;
    var mAnisotropic;
    var mRenderToFloat32F;
    var mDebugShader;
    var mAsynchCompile;

    var mVBO_Quad = null;
    var mVBO_Tri = null;
    var mVBO_CubePosNor = null;
    var mVBO_CubePos = null;
    var mShaderHeader = ["",""];
    var mShaderHeaderLines = [0,0];

    // public members
    var me = {};

    me.CLEAR      = { Color: 1, Zbuffer : 2, Stencil : 4 };
    me.TEXFMT     = { C4I8 : 0, C1I8 : 1, C1F16 : 2, C4F16 : 3, C1F32 : 4, C4F32 : 5, Z16 : 6, Z24 : 7, Z32 : 8, C3F32:9 };
    me.TEXWRP     = { CLAMP : 0, REPEAT : 1 };
    me.BUFTYPE    = { STATIC : 0, DYNAMIC : 1 };
    me.PRIMTYPE   = { POINTS : 0, LINES : 1, LINE_LOOP : 2, LINE_STRIP : 3, TRIANGLES : 4, TRIANGLE_STRIP : 5 };
    me.RENDSTGATE = { WIREFRAME : 0, FRONT_FACE : 1, CULL_FACE : 2, DEPTH_TEST : 3, ALPHA_TO_COVERAGE : 4 };
    me.TEXTYPE    = { T2D : 0, T3D : 1, CUBEMAP : 2 };
    me.FILTER     = { NONE : 0, LINEAR : 1, MIPMAP : 2, NONE_MIPMAP : 3 };
    me.TYPE       = { UINT8 : 0, UINT16 : 1, UINT32 : 2, FLOAT16: 3, FLOAT32 : 4, FLOAT64: 5 };

    // private functions

    var iFormatPI2GL = function( format )
    {
        if( mIs20 )
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA8,           mGLExternal: mGL.RGBA,             mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.R8,              mGLExternal: mGL.RED,              mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.R16F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA16F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.R32F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA32F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C3F32) return { mGLFormat: mGL.RGB32F,          mGLExternal: mGL.RGB,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT16, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z24)   return { mGLFormat: mGL.DEPTH_COMPONENT24, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z32)   return { mGLFormat: mGL.DEPTH_COMPONENT32F, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        }
        else
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.RED,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT, mGLExternal: mGL.DEPTH_COMPONENT, mGLType: mGL.UNSIGNED_SHORT }
        }

        return null;
     }

    // public functions

    me.Initialize = function( gl )
                    {
                        mGL = gl;

                        mIs20 = !(gl instanceof WebGLRenderingContext);

                        if( mIs20 )
                        {
                            mFloat32Textures  = true;
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = true;
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = true;
                            mDrawBuffers      = true;
                            mDepthTextures    = true;
                            mShaderTextureLOD = true;
                            mAnisotropic = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mGL.getExtension( 'EXT_color_buffer_float');
                            mDebugShader = mGL.getExtension('WEBGL_debug_shaders');
                            mAsynchCompile = mGL.getExtension('KHR_parallel_shader_compile');

							mGL.hint( mGL.FRAGMENT_SHADER_DERIVATIVE_HINT, mGL.NICEST);
                        }
                        else
                        {
                            mFloat32Textures  = mGL.getExtension( 'OES_texture_float' );
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = mGL.getExtension( 'OES_texture_half_float' );
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = mGL.getExtension( 'OES_standard_derivatives' );
                            mDrawBuffers      = mGL.getExtension( 'WEBGL_draw_buffers' );
                            mDepthTextures    = mGL.getExtension( 'WEBGL_depth_texture' );
                            mShaderTextureLOD = mGL.getExtension( 'EXT_shader_texture_lod' );
                            mAnisotropic      = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mFloat32Textures;
                            mDebugShader      = null;
                            mAsynchCompile    = null;
							
							if( mDerivatives !== null) mGL.hint( mDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, mGL.NICEST);
                        }
                        
                        
                        var maxTexSize = mGL.getParameter( mGL.MAX_TEXTURE_SIZE );
                        var maxCubeSize = mGL.getParameter( mGL.MAX_CUBE_MAP_TEXTURE_SIZE );
                        var maxRenderbufferSize = mGL.getParameter( mGL.MAX_RENDERBUFFER_SIZE );
                        var extensions = mGL.getSupportedExtensions();
                        var textureUnits = mGL.getParameter( mGL.MAX_TEXTURE_IMAGE_UNITS );
                        console.log("WebGL (2.0=" + mIs20 + "):" +
                                    " Asynch Compile: "  + ((mAsynchCompile !==null) ? "yes" : "no") +
                                    ", Textures: F32 ["   + ((mFloat32Textures !==null) ? "yes" : "no") +
                                    "], F16 ["   + ((mFloat16Textures !==null) ? "yes" : "no") +
                                    "], Depth [" + ((mDepthTextures   !==null) ? "yes" : "no") +
                                    "], LOD ["    + ((mShaderTextureLOD!==null) ? "yes" : "no") +
                                    "], Aniso ["   + ((mAnisotropic     !==null) ? "yes" : "no") +
                                    "], Units [" + textureUnits +
                                    "], Max Size [" + maxTexSize +
                                    "], Cube Max Size [" + maxCubeSize +
                                    "], Targets: MRT ["            + ((mDrawBuffers     !==null) ? "yes" : "no") +
                                    "], F32 ["     + ((mRenderToFloat32F!==null) ? "yes" : "no") +
                                    "], Max Size [" + maxRenderbufferSize + "]");

                        // create a 2D quad Vertex Buffer
                        var vertices = new Float32Array( [ -1.0, -1.0,   1.0, -1.0,    -1.0,  1.0,     1.0, -1.0,    1.0,  1.0,    -1.0,  1.0] );
                        mVBO_Quad = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                        mGL.bufferData( mGL.ARRAY_BUFFER, vertices, mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 2D triangle Vertex Buffer
                        mVBO_Tri = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0,   3.0, -1.0,    -1.0,  3.0] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePosNor = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0, -1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                               1.0,  1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                               1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                               1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                               1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0,  1.0, -1.0,   0.0,  0.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePos = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0,  1.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        //-------------------------------------------------------------------

                        mShaderHeader[0] = "";
                        mShaderHeaderLines[0] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[0] += "#version 300 es\n" +
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[0] += 6;
                        }
                        else
                        {
                            mShaderHeader[0] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "#endif\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+                                                
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[0] += 26;
                        }

                        //-------------------------------------------------------

                        mShaderHeader[1] = "";
                        mShaderHeaderLines[1] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[1] += "#version 300 es\n"+
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[1] += 6;
                        }
                        else
                        {
                            if( mDerivatives ) { mShaderHeader[1] += "#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n"; mShaderHeaderLines[1]+=3; }
                            if( mShaderTextureLOD  ) { mShaderHeader[1] += "#extension GL_EXT_shader_texture_lod : enable\n"; mShaderHeaderLines[1]++; }
                            mShaderHeader[1] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "#endif\n"+ 
                                                "vec4 texture(     sampler2D   s, vec2 c)                   { return texture2D(s,c); }\n"+
                                                "vec4 texture(     sampler2D   s, vec2 c, float b)          { return texture2D(s,c,b); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c )                  { return textureCube(s,c); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c, float b)          { return textureCube(s,c,b); }\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[1] += 30;
                            if( mShaderTextureLOD )
                            {
                            mShaderHeader[1] += "vec4 textureLod(  sampler2D   s, vec2 c, float b)          { return texture2DLodEXT(s,c,b); }\n";
                            mShaderHeader[1] += "vec4 textureGrad( sampler2D   s, vec2 c, vec2 dx, vec2 dy) { return texture2DGradEXT(s,c,dx,dy); }\n";
                            mShaderHeaderLines[1] += 2;

                            //mShaderHeader[1] += "vec4 texelFetch( sampler2D s, ivec2 c, int l) { return texture2DLodEXT(s,(vec2(c)+0.5)/vec2(800,450),float(l)); }\n";
                            //mShaderHeaderLines[1] += 1;
                            }
                        }

                        return true;
                    };

        me.GetCaps =    function ()
                        {   
                            return { mIsGL20 : mIs20,
                                     mFloat32Textures: mFloat32Textures != null,
                                     mFloat16Textures: mFloat16Textures != null,
                                     mDrawBuffers: mDrawBuffers != null,
                                     mDepthTextures: mDepthTextures != null,
                                     mDerivatives: mDerivatives != null,
                                     mShaderTextureLOD: mShaderTextureLOD != null };
                        };

        me.GetShaderHeaderLines = function (shaderType)
                        {   
                            return mShaderHeaderLines[shaderType];
                        };

        me.CheckErrors = function()
                         {
                                var error = mGL.getError();
                                if( error != mGL.NO_ERROR ) 
                                { 
                                    for( var prop in mGL ) 
                                    {
                                        if( typeof mGL[prop] == 'number' ) 
                                        {
                                            if( mGL[prop] == error )
                                            {
                                                console.log( "GL Error " + error + ": " + prop );
                                                break;
                                            }
                                        }
                                    }
                                }
                         };

        me.Clear =  function( flags, ccolor, cdepth, cstencil )
                    {
                        var mode = 0;
                        if( flags & 1 ) { mode |= mGL.COLOR_BUFFER_BIT;   mGL.clearColor( ccolor[0], ccolor[1], ccolor[2], ccolor[3] ); }
                        if( flags & 2 ) { mode |= mGL.DEPTH_BUFFER_BIT;   mGL.clearDepth( cdepth ); }
                        if( flags & 4 ) { mode |= mGL.STENCIL_BUFFER_BIT; mGL.clearStencil( cstencil ); }
                        mGL.clear( mode );
                    };


        me.CreateTexture = function ( type, xres, yres, format, filter, wrap, buffer)
                           {
                                if( mGL===null ) return null;

                                var id = mGL.createTexture();

                                var glFoTy = iFormatPI2GL( format );
                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                if( type===me.TEXTYPE.T2D )
                                {
                                    mGL.bindTexture( mGL.TEXTURE_2D, id );
//if( buffer==null )
    //mGL.texStorage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres);
//else
                                    mGL.texImage2D( mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap );

                                    if (filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                }
                                else if( type===me.TEXTYPE.T3D )
                                {
                                    if( mIs20 )
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_3D, id );
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_BASE_LEVEL, 0);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAX_LEVEL, Math.log2(xres));
                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_3D);
                                        }
                                        mGL.texImage3D( mGL.TEXTURE_3D, 0, glFoTy.mGLFormat, xres, yres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap );

                                        if (filter === me.FILTER.MIPMAP)
                                            mGL.generateMipmap( mGL.TEXTURE_3D );
                                        mGL.bindTexture( mGL.TEXTURE_3D, null );
                                    }
                                    else 
                                    {
                                        return null;
                                    }
                                }
                                else 
                                {
                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );

                                    // this works great if we know the number of required mipmaps in advance (1, or other)
                                   //mGL.texStorage2D( mGL.TEXTURE_CUBE_MAP, 1, glFoTy.mGLFormat, xres, yres );

                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                    if( filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                    }

                                    if (filter === me.FILTER.MIPMAP)
                                        mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );

                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                }
                        return { mObjectID: id, mXres: xres, mYres: yres, mFormat: format, mType: type, mFilter: filter, mWrap: wrap, mVFlip:false };
                        };

        me.CreateTextureFromImage = function ( type, image, format, filter, wrap, flipY) 
                                {
                                    if( mGL===null ) return null;

                                    var id = mGL.createTexture();

                                    var glFoTy = iFormatPI2GL( format );

                                    var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                    if( type===me.TEXTYPE.T2D )
                                    {
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);

                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.pixelStorei(mGL.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                                        if( mIs20 ) mGL.pixelStorei(mGL.UNPACK_COLORSPACE_CONVERSION_WEBGL, mGL.NONE );

                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);

                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);

                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if( filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                    }
                                    else if( type===me.TEXTYPE.T3D )
                                    {
                                        return null;
                                    }
                                    else 
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );

                                        if( filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                    }
                                    return { mObjectID: id, mXres: image.width, mYres: image.height, mFormat: format, mType: type, mFilter: filter, mWrap:wrap, mVFlip:flipY };
                                };

        me.SetSamplerFilter = function (te, filter, doGenerateMipsIfNeeded) 
                            {
                                if (te.mFilter === filter) return;

                                if (te.mType === me.TEXTYPE.T2D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_3D, null);

                                }
                                else
                                {
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }


                                te.mFilter = filter;
                            };

        me.SetSamplerWrap = function (te, wrap)
                            {
                                if (te.mWrap === wrap) return;

                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, id);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, id);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_3D, null);
                                }

                                te.mWrap = wrap;
                            };

        me.SetSamplerVFlip = function (te, vflip, image)
                            {
                                if (te.mVFlip === vflip) return;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    if( image != null)
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                }
                                else if (te.mType === me.TEXTYPE.CUBEMAP)
                                {
                                    if( image != null)
                                    {
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei( mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
        
                                }

                                te.mVFlip = vflip;
                            };

        me.CreateMipmaps =  function (te)
                            {
                                if( te.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);
                                    mGL.generateMipmap(mGL.TEXTURE_2D);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);
                                }
                                else if( te.mType===me.TEXTYPE.CUBEMAP )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);
                                    mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }
                            };

        me.UpdateTexture =  function( tex, x0, y0, xres, yres, buffer )
                            {
                                var glFoTy = iFormatPI2GL( tex.mFormat );
                                if( tex.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture( mGL.TEXTURE0);
                                    mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                    mGL.texSubImage2D( mGL.TEXTURE_2D, 0, x0, y0, xres, yres, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                }
                            };

        me.UpdateTextureFromImage = function( tex, image )
                                {
                                    var glFoTy = iFormatPI2GL( tex.mFormat );
                                    if( tex.mType===me.TEXTYPE.T2D )
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                        mGL.texImage2D(  mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image );
                                        mGL.bindTexture( mGL.TEXTURE_2D, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                };

        me.DestroyTexture = function( te )
                            {
                                 mGL.deleteTexture( te.mObjectID );
                            };

        me.AttachTextures = function (num, t0, t1, t2, t3) 
                            {
                                if (num > 0 && t0 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                         if (t0.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t0.mObjectID);
                                }

                                if (num > 1 && t1 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE1);
                                         if (t1.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t1.mObjectID);
                                }

                                if (num > 2 && t2 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE2);
                                         if (t2.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t2.mObjectID);
                                }

                                if (num > 3 && t3 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE3);
                                         if (t3.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t3.mObjectID);
                                }
                            };

        me.DettachTextures = function()
                             {
                                mGL.activeTexture(mGL.TEXTURE0);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE1);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE2);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE3);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                             };

        me.CreateRenderTarget = function ( color0, color1, color2, color3, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);

                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_2D, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.DestroyRenderTarget = function ( tex )
                                 {
                                     mGL.deleteFramebuffer(tex.mObjectID);
                                 };

        me.SetRenderTarget = function (tex)
                             {
                                if( tex===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, tex.mObjectID);

                                //mGL.drawBuffers([mGL.COLOR_ATTACHMENT0, mGL.COLOR_ATTACHMENT1]);
                             };

        me.CreateRenderTargetNew = function ( wantColor0, wantZbuffer, xres, yres, samples )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if( wantZbuffer===true )
                                    {
                                        var zb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);

                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.DEPTH_COMPONENT16, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                    }

                                    if( wantColor0 )
                                    {
                                        var cb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, cb);
                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.RGBA8, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.RGBA8, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.RENDERBUFFER, cb);
                                    }

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                    {
                                        return null;
                                    }
                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mXres: xres, mYres:yres, mTex0: color0 };
                                };

        me.CreateRenderTargetCubeMap = function ( color0, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);
                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.SetRenderTargetCubeMap = function (fbo, face)
                             {
                                if( fbo===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                {
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, fbo.mObjectID);
                                    mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X+face, fbo.mTex0.mObjectID, 0);
                                }
                             };


        me.BlitRenderTarget = function( dst, src )
                                {
                                    mGL.bindFramebuffer(mGL.READ_FRAMEBUFFER, src.mObjectID);
                                    mGL.bindFramebuffer(mGL.DRAW_FRAMEBUFFER, dst.mObjectID);
                                    mGL.clearBufferfv(mGL.COLOR, 0, [0.0, 0.0, 0.0, 1.0]);
                                    mGL.blitFramebuffer( 0, 0, src.mXres, src.mYres,
                                                         0, 0, src.mXres, src.mYres,
                                                         mGL.COLOR_BUFFER_BIT, mGL.LINEAR
                                    );
                                };

        me.SetViewport = function( vp )
                         {
                              mGL.viewport( vp[0], vp[1], vp[2], vp[3] );
                         };

        me.SetWriteMask = function( c0, c1, c2, c3, z )
                          {
                              mGL.depthMask(z);
                              mGL.colorMask(c0,c0,c0,c0);
                          };

        me.SetState = function( stateName, stateValue )
                      {
                            if (stateName === me.RENDSTGATE.WIREFRAME)
                            {
                                if( stateValue ) mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.LINE );
                                else             mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.FILL );
                            }
                            else if (stateName === me.RENDSTGATE.FRONT_FACE)
                            {
                                if( stateValue ) mGL.cullFace( mGL.BACK );
                                else             mGL.cullFace( mGL.FRONT );
                            }
                            else if (stateName === me.RENDSTGATE.CULL_FACE)
                            {
                                if( stateValue ) mGL.enable( mGL.CULL_FACE );
                                else             mGL.disable( mGL.CULL_FACE );
                            }
                            else if (stateName === me.RENDSTGATE.DEPTH_TEST)
                            {
                                if( stateValue ) mGL.enable( mGL.DEPTH_TEST );
                                else             mGL.disable( mGL.DEPTH_TEST );
                            }
                            else if (stateName === me.RENDSTGATE.ALPHA_TO_COVERAGE)
                            {
                                if( stateValue ) { mGL.enable(  mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                                else             { mGL.disable( mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                            }
                      };

        me.SetMultisample = function( v)
                    {
                        if( v===true )
                        {
                            mGL.enable(mGL.SAMPLE_COVERAGE);
                            mGL.sampleCoverage(1.0, false);
                        }
                        else
                        {
                            mGL.disable(mGL.SAMPLE_COVERAGE);
                        }
                    };

        me.GetTranslatedShaderSource = function (shader) 
                          {
                            if( mGL===null ) return null;
                            if( mDebugShader===null ) return null;
                            let vfs = mGL.getAttachedShaders(shader.mProgram);
                            let str = mDebugShader.getTranslatedShaderSource(vfs[1]);
                            let parts = str.split("GLSL END"); str = (parts.length<2) ? str : parts[1];
                            return str;
                          };

        me.CreateShader = function (vsSource, fsSource, preventCache, forceSynch, onResolve) 
                          {
                            if( mGL===null ) return;

                            var vs = mGL.createShader( mGL.VERTEX_SHADER   );
                            var fs = mGL.createShader( mGL.FRAGMENT_SHADER );

                            vsSource = mShaderHeader[0] + vsSource;
                            fsSource = mShaderHeader[1] + fsSource;

                            if( preventCache )
                            {
                                let vran = Math.random().toString(36).substring(7);
                                let fran = Math.random().toString(36).substring(7);
                                vsSource += "\n#define K" + vran + "\n";
                                fsSource += "\n#define K" + fran + "\n";
                            }

                            var timeStart = getRealTime();

                            mGL.shaderSource(vs, vsSource);
                            mGL.shaderSource(fs, fsSource);
                            mGL.compileShader(vs);
                            mGL.compileShader(fs);

                            var pr = mGL.createProgram();
                            mGL.attachShader(pr, vs);
                            mGL.attachShader(pr, fs);
                            mGL.linkProgram(pr);

                            //-------------
                            let checkErrors = function()
                            {
                                if (!mGL.getProgramParameter(pr, mGL.LINK_STATUS))
                                {
                                    // vs error
                                    if (!mGL.getShaderParameter(vs, mGL.COMPILE_STATUS))
                                    {
                                        let vsLog = mGL.getShaderInfoLog(vs);
                                        onResolve(false, { mErrorType: 0, mErrorStr: vsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // fs error
                                    else if (!mGL.getShaderParameter(fs, mGL.COMPILE_STATUS))
                                    {
                                        let fsLog = mGL.getShaderInfoLog(fs);
                                        onResolve(false, { mErrorType: 1, mErrorStr: fsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // link error
                                    else
                                    {
                                        let infoLog = mGL.getProgramInfoLog(pr);
                                        onResolve(false, { mErrorType: 2, mErrorStr: infoLog });
                                        mGL.deleteProgram(pr);
                                    }
                                }
                                // no errors
                                else
                                {
                                    let compilationTime = getRealTime() - timeStart;
                                    onResolve(true, { mProgram: pr, mTime: compilationTime });
                                }
                            };

                            // check compilation
                            if (mAsynchCompile === null || forceSynch===true )
                            {
                                checkErrors();
                            }
                            else
                            {
                                let loopCheckCompletion = function ()
                                {
                                    if( mGL.getProgramParameter(pr, mAsynchCompile.COMPLETION_STATUS_KHR) === true )
                                        checkErrors();
                                    else
                                        setTimeout(loopCheckCompletion, 10);
                                };
                                setTimeout(loopCheckCompletion, 10);
                            }
                        };

        me.AttachShader = function( shader )
                          {
                                if( shader===null )
                                {
                                    mBindedShader = null;
                                    mGL.useProgram( null );
                                }
                                else
                                {
                                    mBindedShader = shader;
                                    mGL.useProgram(shader.mProgram);
                                }
                          };

        me.DetachShader = function ()
                        {
                            mGL.useProgram(null);
                        };

        me.DestroyShader = function( tex )
                        {
                            mGL.deleteProgram(tex.mProgram);
                        };

        me.GetAttribLocation = function (shader, name)
                        {
                            return mGL.getAttribLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantLocation = function (shader, name)
                        {
                            return mGL.getUniformLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantMat4F = function( uname, params, istranspose )
                        {
                            var program = mBindedShader;

                            let pos = mGL.getUniformLocation( program.mProgram, uname );
                            if( pos===null )
                                return false;

                            if( istranspose===false )
                            {
                                var tmp = new Float32Array( [ params[0], params[4], params[ 8], params[12],
                                                              params[1], params[5], params[ 9], params[13],
                                                              params[2], params[6], params[10], params[14],
                                                              params[3], params[7], params[11], params[15] ] );
	                            mGL.uniformMatrix4fv(pos,false,tmp);
                            }
                            else
                                mGL.uniformMatrix4fv(pos,false,new Float32Array(params) );
                            return true;
                        };

        me.SetShaderConstant1F_Pos = function(pos, x)
                        {
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1FV_Pos = function(pos, x)
                        {
                            mGL.uniform1fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant1F = function( uname, x )
                        {
                            var pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1I = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1i(pos, x);
                            return true;
                        };
        me.SetShaderConstant1I_Pos = function(pos, x)
                        {
                            mGL.uniform1i(pos, x);
                            return true;
                        };


        me.SetShaderConstant2F = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform2fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant3F = function(uname, x, y, z)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform3f(pos, x, y, z);
                            return true;
                        };

        me.SetShaderConstant1FV = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1fv(pos, new Float32Array(x));
                            return true;
                        };

        me.SetShaderConstant3FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform3fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderConstant4FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform4fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderTextureUnit = function( uname, unit )
                        {
                            var program = mBindedShader;
                            let pos = mGL.getUniformLocation(program.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform1i(pos, unit);
                            return true;
                        };

        me.CreateVertexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, id);
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.CreateIndexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, id );
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.DestroyArray = function( tex )
                        {
                            mGL.destroyBuffer(tex.mObject);
                        };

        me.AttachVertexArray = function( tex, attribs, pos )
                        {
                            let shader = mBindedShader;

                            mGL.bindBuffer( mGL.ARRAY_BUFFER, tex.mObject);

                            var num = attribs.mChannels.length;
                            var stride = attribs.mStride;

                            var offset = 0;
                            for (var i = 0; i < num; i++)
                            {
                                var id = pos[i];
                                mGL.enableVertexAttribArray(id);
                                var dtype = mGL.FLOAT;
                                var dsize = 4;
                                     if( attribs.mChannels[i].mType === me.TYPE.UINT8   ) { dtype = mGL.UNSIGNED_BYTE;  dsize = 1; }
                                else if( attribs.mChannels[i].mType === me.TYPE.UINT16  ) { dtype = mGL.UNSIGNED_SHORT; dsize = 2; }
                                else if( attribs.mChannels[i].mType === me.TYPE.FLOAT32 ) { dtype = mGL.FLOAT;          dsize = 4; }
                                mGL.vertexAttribPointer(id, attribs.mChannels[i].mNumComponents, dtype, attribs.mChannels[i].mNormalize, stride, offset);
                                offset += attribs.mChannels[i].mNumComponents * dsize;
                            }
                        };

        me.AttachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, tex.mObject);
                        };

        me.DetachVertexArray = function (tex, attribs)
                        {
                            let num = attribs.mChannels.length;
                            for (let i = 0; i < num; i++)
                                mGL.disableVertexAttribArray(i);
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, null);
                        };

        me.DetachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, null);
                        };

        me.DrawPrimitive = function( typeOfPrimitive, num, useIndexArray, numInstances )
                        {
                            let glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.POINTS ) glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.LINES ) glType = mGL.LINES;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_LOOP ) glType = mGL.LINE_LOOP;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_STRIP ) glType = mGL.LINE_STRIP;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLES ) glType = mGL.TRIANGLES;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLE_STRIP ) glType = mGL.TRIANGLE_STRIP;

                            if( numInstances<=1 )
                            {
  	                            if( useIndexArray ) mGL.drawElements( glType, num, mGL.UNSIGNED_SHORT, 0 );
	                            else                mGL.drawArrays( glType, 0, num );
                            }
                            else
                            {
                                mGL.drawArraysInstanced(glType, 0, num, numInstances);
                                mGL.drawElementsInstanced( glType, num, mGL.UNSIGNED_SHORT, 0, numInstances);
                            }
                        };


        me.DrawFullScreenTriangle_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 3 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };


        me.DrawUnitQuad_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 6 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };

        me.DrawUnitCube_XYZ_NOR = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                            mGL.vertexAttribPointer( vpos[0], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.vertexAttribPointer( vpos[1], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos[0] );
                            mGL.enableVertexAttribArray( vpos[1] );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos[0] );
                            mGL.disableVertexAttribArray( vpos[1] );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.DrawUnitCube_XYZ = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                            mGL.vertexAttribPointer( vpos, 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.SetBlend = function( enabled )
                    {
                        if( enabled )
                        {
                            mGL.enable( mGL.BLEND );
                            mGL.blendEquationSeparate( mGL.FUNC_ADD, mGL.FUNC_ADD );
                            mGL.blendFuncSeparate( mGL.SRC_ALPHA, mGL.ONE_MINUS_SRC_ALPHA, mGL.ONE, mGL.ONE_MINUS_SRC_ALPHA );
                        }
                        else
                        {
                            mGL.disable( mGL.BLEND );
                        }
                    };

        me.GetPixelData = function( data, offset, xres, yres )
                        {
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.UNSIGNED_BYTE, data, offset);
                        };

        me.GetPixelDataRenderTarget = function( obj, data, xres, yres )
                        {
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, obj.mObjectID);
                            mGL.readBuffer(mGL.COLOR_ATTACHMENT0);
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.FLOAT, data, 0);
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                        };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piShading
//
//==============================================================================

function smoothstep(a, b, x)
{
    x = (x - a) / (b - a);
    if (x < 0) x = 0; else if (x > 1) x = 1;
    return x * x * (3.0 - 2.0 * x);
}

function clamp01(x)
{
    if( x < 0.0 ) x = 0.0;
    if( x > 1.0 ) x = 1.0;
    return x;
}

function clamp(x, a, b)
{
    if( x < a ) x = a;
    if( x > b ) x = b;
    return x;
}

function screen(a, b)
{
    return 1.0 - (1.0 - a) * (1.0 - b);
}

function parabola(x)
{
    return 4.0 * x * (1.0 - x);
}

function min(a, b)
{
    return (a < b) ? a : b;
}

function max(a, b)
{
    return (a > b) ? a : b;
}

function noise( x )
{
    function grad(i, j, x, y)
    {
        var h = 7 * i + 131 * j;
        h = (h << 13) ^ h;
        h = (h * (h * h * 15731 + 789221) + 1376312589);

        var rx = (h & 0x20000000) ? x : -x;
        var ry = (h & 0x10000000) ? y : -y;

        return rx + ry;
    }

    var i = [ Math.floor(x[0]), Math.floor(x[1]) ];
    var f = [ x[0] - i[0], x[1] - i[1] ];
    var w = [ f[0]*f[0]*(3.0-2.0*f[0]), f[1]*f[1]*(3.0-2.0*f[1]) ];

    var a = grad( i[0]+0, i[1]+0, f[0]+0.0, f[1]+0.0 );
    var b = grad( i[0]+1, i[1]+0, f[0]-1.0, f[1]+0.0 );
    var c = grad( i[0]+0, i[1]+1, f[0]+0.0, f[1]-1.0 );
    var d = grad( i[0]+1, i[1]+1, f[0]-1.0, f[1]-1.0 );

    return a + (b-a)*w[0] + (c-a)*w[1] + (a-b-c+d)*w[0]*w[1];
}//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piVecTypes
//
//==============================================================================


function vec3( a, b, c )
{
    return [ a, b, c ];
}

function add( a, b )
{
    return [ a[0]+b[0], a[1]+b[1], a[2]+b[2] ];
}

function sub( a, b )
{
    return [ a[0]-b[0], a[1]-b[1], a[2]-b[2] ];
}

function mul( a, s ) 
{
    return [ a[0]*s, a[1]*s, a[2]*s ];
}

function cross( a, b )
{
    return [ a[1]*b[2] - a[2]*b[1],
             a[2]*b[0] - a[0]*b[2],
             a[0]*b[1] - a[1]*b[0] ];
}

function dot( a, b ) 
{
    return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
}

function normalize( v ) 
{
    var is = 1.0 / Math.sqrt( v[0]*v[0] + v[1]*v[1] + v[2]*v[2] );
    return [ v[0]*is, v[1]*is, v[2]*is ];
}

function createCirclePoint( cen, uuu, vvv, rad, s, t )
{
    return [ cen[0] + rad*(uuu[0]*s + vvv[0]*t),
             cen[1] + rad*(uuu[1]*s + vvv[1]*t),
             cen[2] + rad*(uuu[2]*s + vvv[2]*t) ];
}

function createTangent( a, b, c )
{
    var cb = normalize( [ c[0]-b[0], c[1]-b[1], c[2]-b[2] ] );
    var ba = normalize( [ b[0]-a[0], b[1]-a[1], b[2]-a[2] ] );
    return normalize( [ ba[0]+cb[0], ba[1]+cb[1], ba[2]+cb[2] ] );

}

//===================================

function vec4( a, b, c, d )
{
    return [ a, b, c, d ];
}

function getXYZ( v )
{
    return [ v[0], v[1], v[2] ];
}

//===================================

function setIdentity()
{
    return [ 1.0, 0.0, 0.0, 0.0,
             0.0, 1.0, 0.0, 0.0,
             0.0, 0.0, 1.0, 0.0,
             0.0, 0.0, 0.0, 1.0 ];
}

function setRotationX( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ 1.0,   0.0,   0.0, 0.0,
             0.0,  cost, -sint, 0.0, 
             0.0,  sint,  cost, 0.0,
             0.0,   0.0,   0.0, 1.0 ];
}

function setRotationY( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ cost, 0.0, -sint, 0.0,
              0.0, 1.0,   0.0, 0.0, 
             sint, 0.0,  cost, 0.0,
              0.0, 0.0,   0.0, 1.0 ];
}

function extractRotationEuler( m)
{
    var res = [];
    if (m[0] == 1.0)
    {
        res[0] = Math.atan2(m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;

    }
    else if (m[0] == -1.0)
    {
        res[0] = Math.atan2( m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;
    }
    else
    {
        res[0] = Math.atan2( -m[9], m[10]);
        res[1] = Math.atan2( m[8], Math.sqrt(m[9]*m[9] + m[10]*m[10]));
        res[2] = Math.atan2( m[4], m[0]);
    }
    return res;
}

function setFromQuaternion( q )
{
    var ww = q[3]*q[3];
    var xx = q[0]*q[0];
    var yy = q[1]*q[1];
    var zz = q[2]*q[2];

    return [ ww+xx-yy-zz,                   2.0*(q[0]*q[1] - q[3]*q[2]), 2.0*(q[0]*q[2] + q[3]*q[1]), 0.0,
               2.0*(q[0]*q[1] + q[3]*q[2]),   ww-xx+yy-zz,                 2.0*(q[1]*q[2] - q[3]*q[0]), 0.0,
               2.0*(q[0]*q[2] - q[3]*q[1]),   2.0*(q[1]*q[2] + q[3]*q[0]), ww-xx-yy+zz,                 0.0,
               0.0,                           0.0,                         0.0,                         1.0 ];
}

function setPerspective( fovy, aspect, znear, zfar )
{
    var tan = Math.tan(fovy * Math.PI/180.0);
    var x = 1.0 / (tan*aspect);
    var y = 1.0 / (tan);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0 * zfar * znear) / (zfar - znear);

    return [ x,    0.0,  0.0,  0.0,
             0.0,  y,    0.0,  0.0,
             0.0,  0.0,  c,     d,
             0.0,  0.0, -1.0,  0.0 ];
}

function setLookAt( eye, tar, up )
{
    var dir = [ -tar[0]+eye[0], -tar[1]+eye[1], -tar[2]+eye[2] ];

	var m00 = dir[2]*up[1] - dir[1]*up[2]; 
    var m01 = dir[0]*up[2] - dir[2]*up[0];
    var m02 = dir[1]*up[0] - dir[0]*up[1];
    var im = 1.0/Math.sqrt( m00*m00 + m01*m01 + m02*m02 );
    m00 *= im;
    m01 *= im;
    m02 *= im;

	var m04 = m02*dir[1] - m01*dir[2]; 
    var m05 = m00*dir[2] - m02*dir[0];
    var m06 = m01*dir[0] - m00*dir[1];
    im = 1.0/Math.sqrt( m04*m04 + m05*m05 + m06*m06 );
    m04 *= im;
    m05 *= im;
    m06 *= im;

	var m08 = dir[0];
	var m09 = dir[1];
	var m10 = dir[2];
    im = 1.0/Math.sqrt( m08*m08 + m09*m09 + m10*m10 );
    m08 *= im;
    m09 *= im;
    m10 *= im;

	var m03 = -(m00*eye[0] + m01*eye[1] + m02*eye[2] );
	var m07 = -(m04*eye[0] + m05*eye[1] + m06*eye[2] );
	var m11 = -(m08*eye[0] + m09*eye[1] + m10*eye[2] );

    return [ m00, m01, m02, m03,
             m04, m05, m06, m07,
             m08, m09, m10, m11,
             0.0, 0.0, 0.0, 1.0 ];
}


function setOrtho( left, right, bottom, top, znear, zfar )
{
   var x = 2.0 / (right - left);
   var y = 2.0 / (top - bottom);
   var a = (right + left) / (right - left);
   var b = (top + bottom) / (top - bottom);
   var c = -2.0 / (zfar - znear);
   var d = -(zfar + znear) / ( zfar - znear);

   return [  x, 0.0, 0.0,   a,
           0.0,   y, 0.0,   b,
           0.0, 0.0,   c,   d,
           0.0, 0.0, 0.0, 1.0 ];
}

function setTranslation( p )
{
    return [ 1.0, 0.0, 0.0, p[0],
             0.0, 1.0, 0.0, p[1],
             0.0, 0.0, 1.0, p[2],
             0.0, 0.0, 0.0, 1.0 ];
}

function setScale( s )
{
    return [ s[0], 0.0,  0.0,  0.0,
             0.0,  s[1], 0.0,  0.0,
             0.0,  0.0,  s[2], 0.0,
             0.0,  0.0,  0.0,  1.0];
}

function setProjection( fov, znear, zfar )
{
    var x = 2.0 / (fov[3]+fov[2]);
    var y = 2.0 / (fov[0]+fov[1]);
    var a = (fov[3]-fov[2]) / (fov[3]+fov[2]);
    var b = (fov[0]-fov[1]) / (fov[0]+fov[1]);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0*zfar*znear) / (zfar - znear);
    return [   x, 0.0,    a, 0.0,
             0.0,   y,    b, 0.0,
             0.0, 0.0,    c,   d,
             0.0, 0.0, -1.0, 0.0 ];
   // inverse is:
   //return mat4x4( 1.0/x, 0.0f,  0.0f,   a/x,
   //               0.0f,  1.0/y, 0.0f,   b/x,
   //               0.0f,  0.0f,  0.0f,   -1.0,
   //               0.0f,  0.0f,  1.0f/d, c/d );
}


function invertFast( m )
{
    var inv = [
   
             m[5]  * m[10] * m[15] - 
             m[5]  * m[11] * m[14] - 
             m[9]  * m[6]  * m[15] + 
             m[9]  * m[7]  * m[14] +
             m[13] * m[6]  * m[11] - 
             m[13] * m[7]  * m[10],

             -m[1]  * m[10] * m[15] + 
              m[1]  * m[11] * m[14] + 
              m[9]  * m[2] * m[15] - 
              m[9]  * m[3] * m[14] - 
              m[13] * m[2] * m[11] + 
              m[13] * m[3] * m[10],

             m[1]  * m[6] * m[15] - 
             m[1]  * m[7] * m[14] - 
             m[5]  * m[2] * m[15] + 
             m[5]  * m[3] * m[14] + 
             m[13] * m[2] * m[7] - 
             m[13] * m[3] * m[6],

             -m[1] * m[6] * m[11] + 
              m[1] * m[7] * m[10] + 
              m[5] * m[2] * m[11] - 
              m[5] * m[3] * m[10] - 
              m[9] * m[2] * m[7] + 
              m[9] * m[3] * m[6],

             -m[4]  * m[10] * m[15] + 
              m[4]  * m[11] * m[14] + 
              m[8]  * m[6]  * m[15] - 
              m[8]  * m[7]  * m[14] - 
              m[12] * m[6]  * m[11] + 
              m[12] * m[7]  * m[10],

             m[0]  * m[10] * m[15] - 
             m[0]  * m[11] * m[14] - 
             m[8]  * m[2] * m[15] + 
             m[8]  * m[3] * m[14] + 
             m[12] * m[2] * m[11] - 
             m[12] * m[3] * m[10],

             -m[0]  * m[6] * m[15] + 
              m[0]  * m[7] * m[14] + 
              m[4]  * m[2] * m[15] - 
              m[4]  * m[3] * m[14] - 
              m[12] * m[2] * m[7] + 
              m[12] * m[3] * m[6],


             m[0] * m[6] * m[11] - 
             m[0] * m[7] * m[10] - 
             m[4] * m[2] * m[11] + 
             m[4] * m[3] * m[10] + 
             m[8] * m[2] * m[7] - 
             m[8] * m[3] * m[6],


             m[4]  * m[9] * m[15] - 
             m[4]  * m[11] * m[13] - 
             m[8]  * m[5] * m[15] + 
             m[8]  * m[7] * m[13] + 
             m[12] * m[5] * m[11] - 
             m[12] * m[7] * m[9],



             -m[0]  * m[9] * m[15] + 
              m[0]  * m[11] * m[13] + 
              m[8]  * m[1] * m[15] - 
              m[8]  * m[3] * m[13] - 
              m[12] * m[1] * m[11] + 
              m[12] * m[3] * m[9],

              m[0]  * m[5] * m[15] - 
              m[0]  * m[7] * m[13] - 
              m[4]  * m[1] * m[15] + 
              m[4]  * m[3] * m[13] + 
              m[12] * m[1] * m[7] - 
              m[12] * m[3] * m[5],

              -m[0] * m[5] * m[11] + 
               m[0] * m[7] * m[9] + 
               m[4] * m[1] * m[11] - 
               m[4] * m[3] * m[9] - 
               m[8] * m[1] * m[7] + 
               m[8] * m[3] * m[5],

              -m[4]  * m[9] * m[14] + 
               m[4]  * m[10] * m[13] +
               m[8]  * m[5] * m[14] - 
               m[8]  * m[6] * m[13] - 
               m[12] * m[5] * m[10] + 
               m[12] * m[6] * m[9],

              m[0]  * m[9] * m[14] - 
              m[0]  * m[10] * m[13] - 
              m[8]  * m[1] * m[14] + 
              m[8]  * m[2] * m[13] + 
              m[12] * m[1] * m[10] - 
              m[12] * m[2] * m[9],

              -m[0]  * m[5] * m[14] + 
               m[0]  * m[6] * m[13] + 
               m[4]  * m[1] * m[14] - 
               m[4]  * m[2] * m[13] - 
               m[12] * m[1] * m[6] + 
               m[12] * m[2] * m[5],

              m[0] * m[5] * m[10] - 
              m[0] * m[6] * m[9] - 
              m[4] * m[1] * m[10] + 
              m[4] * m[2] * m[9] + 
              m[8] * m[1] * m[6] - 
              m[8] * m[2] * m[5] ];

    var det = m[0] * inv[0] + m[1] * inv[4] + m[2] * inv[8] + m[3] * inv[12];

    det = 1.0/det;

    for( var i = 0; i<16; i++ ) inv[i] = inv[i] * det;

    return inv;
}

function matMul( a, b )
{
    var res = [];
    for( var i=0; i<4; i++ )
    {
        var x = a[4*i+0];
        var y = a[4*i+1];
        var z = a[4*i+2];
        var w = a[4*i+3];

        res[4*i+0] = x * b[ 0] + y * b[ 4] + z * b[ 8] + w * b[12];
        res[4*i+1] = x * b[ 1] + y * b[ 5] + z * b[ 9] + w * b[13];
        res[4*i+2] = x * b[ 2] + y * b[ 6] + z * b[10] + w * b[14];
        res[4*i+3] = x * b[ 3] + y * b[ 7] + z * b[11] + w * b[15];
    }

    return res;
}

function matMulpoint( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2] + m[ 3],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2] + m[ 7],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] + m[11] ];
}

function matMulvec( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] ];
}


function bound3( infi )
{
    return [ infi, -infi, infi, -infi, infi, -infi ];
}

function bound3_include( a, p )
{
    return [
        (p[0]<a[0]) ? p[0] : a[0],
        (p[0]>a[1]) ? p[0] : a[1],
        (p[1]<a[2]) ? p[1] : a[2],
        (p[1]>a[3]) ? p[1] : a[3],
        (p[2]<a[4]) ? p[2] : a[4],
        (p[2]>a[5]) ? p[2] : a[5] ];
}

function bound3_center( b )
{
    return [ 0.5*(b[0]+b[1]),
             0.5*(b[2]+b[3]),
             0.5*(b[4]+b[5]) ];
}

function bound3_radius( b )
{
    return [ 0.5*(b[1]-b[0]),
             0.5*(b[3]-b[2]),
             0.5*(b[5]-b[4]) ];
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebVR
//
//==============================================================================

function WebVR( isVREnabledCallback, canvasElement )
{
    isVREnabledCallback(false);
    /*


    this.mSupportVR = false;
    this.mHMD = null;

    var me = this;
    var listVRDisplays = function (vrdevs) {
        for (var i = 0; i < vrdevs.length; i++)
        {
            if (vrdevs[i] instanceof VRDisplay)
            {
                me.mHMD = vrdevs[i];
                console.log("WebVR is available.");
                console.log(me.mHMD);
                break;
            }
        }

        isVREnabledCallback(true);
        me.mSupportVR = true;
    }

    if (navigator.getVRDisplays)
    {
        navigator.getVRDisplays().then(listVRDisplays);
    }

    isVREnabledCallback(false);
    this.mCanvas = canvasElement;
    */
}

WebVR.prototype.IsSupported = function()
{
    return false;
    //return this.mSupportVR;
}

WebVR.prototype.GetData = function( id )
{
    return {};
    /*
    var frameData = new VRFrameData();
    var s = this.mHMD.getFrameData(frameData);
    var ss = frameData.pose;
    
    var fovL = this.mHMD.getEyeParameters("left");
    var fovR = this.mHMD.getEyeParameters( "right" );

    // camera info
    var cPos = vec3(0.0, 0.0, 0.0);
    if (ss.position)
        cPos = vec3(-ss.position[0], -ss.position[1], -ss.position[2]);
    var rot = vec4(0.0, 0.0, 0.0, 0.0);
    if (ss.orientation)
        rot = vec4(ss.orientation[0], ss.orientation[1], ss.orientation[2], ss.orientation[3]);
    var cRot = setFromQuaternion(rot);
    var cTra = setTranslation(cPos);
    var cMat = matMul(invertFast(cRot), cTra);
    
    // per eye info
    var lTra = setTranslation( vec3(-fovL.offset[0], -fovL.offset[1], -fovL.offset[2]) );
    var lMat = matMul(lTra, cMat);
    var lPrj = [ Math.tan( fovL.fieldOfView.upDegrees * Math.PI/180.0),
                 Math.tan(fovL.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.rightDegrees * Math.PI / 180.0)];

    var rTra = setTranslation(vec3(-fovR.offset[0], -fovR.offset[1], -fovR.offset[2]));
    var rMat = matMul(rTra, cMat);
    var rPrj = [Math.tan(fovR.fieldOfView.upDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.rightDegrees * Math.PI / 180.0)];

    return {
        mCamera   : { mCamera: cMat },
        mLeftEye  : { mVP:[0,0,fovL.renderWidth,fovL.renderHeight], mProjection:lPrj, mCamera:lMat },
        mRightEye : { mVP:[fovR.renderWidth/2,0,fovR.renderWidth,fovR.renderHeight], mProjection:rPrj, mCamera:rMat }
           };
    */
}

WebVR.prototype.Enable = function( id )
{
    /*
    this.mHMD.requestPresent([{ source: this.mCanvas }]).then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : requestPresent failed.");
        }
    );
    */
}

WebVR.prototype.Disable = function( id )
{
    /*
    if (!this.mHMD.isPresenting)
    {
        return;
    }

    this.mHMD.exitPresent().then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : exitPresent failed.");
        }
    );
    */
}

WebVR.prototype.RequestAnimationFrame = function (id)
{
    //this.mHMD.requestAnimationFrame(id);
}

WebVR.prototype.IsPresenting = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        return true;
    }
    */
    return false;
}

WebVR.prototype.Finish = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        this.mHMD.submitFrame();
    }
    */
}

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebUtils
//
//==============================================================================


// RequestAnimationFrame
window.requestAnimFrame = ( function () { return window.requestAnimationFrame    || window.webkitRequestAnimationFrame ||
                                                 window.mozRequestAnimationFrame || window.oRequestAnimationFrame ||
                                                 window.msRequestAnimationFrame  || function( cb ) { window.setTimeout(cb,1000/60); };
                                        } )();

// performance.now
window.getRealTime = ( function() { if ("performance" in window ) return function() { return window.performance.now(); }
                                                                  return function() { return (new Date()).getTime(); }
                                  } )();

window.URL = window.URL || window.webkitURL;

navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;

function htmlEntities(str) 
{
    return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g,'&apos;');
}

function piDisableTouch()
{
    document.body.addEventListener('touchstart', function(e){ e.preventDefault(); });
}

var piGetTime = function ( timestamp )
{
    if (timestamp == 0)
        return "";
    return new Date(timestamp * 1000).toISOString().substr(0, 10);
}

function piGetCoords( obj )
{
    var x = 0;
    var y = 0; 
    do
    {
         x += obj.offsetLeft;
         y += obj.offsetTop;
    }while( obj = obj.offsetParent );

    return { mX:x, mY:y };
}

function piGetMouseCoords( ev, canvasElement )
{
    var pos = piGetCoords(canvasElement );
    var mcx =                        (ev.pageX - pos.mX) * canvasElement.width / canvasElement.offsetWidth;
    var mcy = canvasElement.height - (ev.pageY - pos.mY) * canvasElement.height / canvasElement.offsetHeight;

    return { mX: mcx, mY: mcy };

}

function piGetSourceElement( e )
{
    var ele = null;
    if( e.target )     ele = e.target;
    if( e.srcElement ) ele = e.srcElement;
    return ele;
}

function piRequestFullScreen( ele )
{
    if( ele==null ) ele =   document.documentElement;
         if( ele.requestFullscreen       ) ele.requestFullscreen();
    else if( ele.msRequestFullscreen     ) ele.msRequestFullscreen();
    else if( ele.mozRequestFullScreen    ) ele.mozRequestFullScreen();
    else if( ele.webkitRequestFullscreen ) ele.webkitRequestFullscreen( Element.ALLOW_KEYBOARD_INPUT );
}

function piIsFullScreen()
{
    return document.fullscreen || document.mozFullScreen || document.webkitIsFullScreen || document.msFullscreenElement || false;
}

function piExitFullScreen()
{
       if( document.exitFullscreen       ) document.exitFullscreen();
  else if( document.msExitFullscreen     ) document.msExitFullscreen();
  else if( document.mozCancelFullScreen  ) document.mozCancelFullScreen();
  else if( document.webkitExitFullscreen ) document.webkitExitFullscreen();
}

function piIsMobile()
{
    return (navigator.userAgent.match(/Android/i) ||
            navigator.userAgent.match(/webOS/i) ||
            navigator.userAgent.match(/iPhone/i) ||
            navigator.userAgent.match(/iPad/i) ||
            navigator.userAgent.match(/iPod/i) ||
            navigator.userAgent.match(/BlackBerry/i) ||
            navigator.userAgent.match(/Windows Phone/i)) ? true : false;
}

function piCreateGlContext( cv, useAlpha, useDepth, usePreserveBuffer, useSupersampling )
{
    var opts = { alpha: useAlpha, 
                 depth: useDepth, 
                 stencil: false, 
                 premultipliedAlpha: false, 
                 antialias: useSupersampling, 
                 preserveDrawingBuffer: usePreserveBuffer, 
                 powerPreference: "high-performance" }; // "low_power", "high_performance", "default"

    var gl = null;
    if( gl === null) gl = cv.getContext( "webgl2", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl2", opts );
    if( gl === null) gl = cv.getContext( "webgl", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl", opts );

    return gl;
}

function piCreateAudioContext()
{
    var res = null;
    try
    {
        if( window.AudioContext ) res = new AudioContext();
        if( res==null && window.webkitAudioContext ) res = new webkitAudioContext();
    }
    catch( e )
    {
        res = null;
    }
    return res;
}

function piHexColorToRGB(str) // "#ff3041"
{
    var rgb = parseInt(str.slice(1), 16);
    var r = (rgb >> 16) & 255;
    var g = (rgb >> 8) & 255;
    var b = (rgb >> 0) & 255;
    return [r, g, b];
}

function piCreateFPSCounter()
{
    var mFrame;
    var mTo;
    var mFPS;

    var iReset = function( time )
    {
        mFrame = 0;
        mTo = time;
        mFPS = 60.0;
    }

    var iCount = function( time )
    {
        mFrame++;

        if( (time-mTo)>500.0 )
        {
            mFPS = 1000.0*mFrame/(time-mTo);
            mFrame = 0;
            mTo = time;
            return true;
        }
        return false;
    }

    var iGetFPS = function()
    {
        return mFPS;
    }
    
    return { Reset : iReset, Count : iCount, GetFPS : iGetFPS };
}

function piCanMediaRecorded(canvas)
{
    if (typeof window.MediaRecorder !== 'function' || typeof canvas.captureStream !== 'function') {
        return false;
    }
    return true;
}

function piCreateMediaRecorder(isRecordingCallback, canvas) 
{
    if (piCanMediaRecorded(canvas) == false)
    {
        return null;
    }
    
    var options = { audioBitsPerSecond : 0, videoBitsPerSecond : 8000000 }; 
	     if (MediaRecorder.isTypeSupported('video/webm;codecs=h264')) options.mimeType = 'video/webm;codecs=h264';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9' )) options.mimeType = 'video/webm;codecs=vp9';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8' )) options.mimeType = 'video/webm;codecs=vp8';
    else                                                              options.mimeType = 'video/webm;';

    var mediaRecorder = new MediaRecorder(canvas.captureStream(), options);
    var chunks = [];
    
    mediaRecorder.ondataavailable = function(e) 
    {
        if (e.data.size > 0) 
        {
            chunks.push(e.data);
        }
    };
 
    mediaRecorder.onstart = function(){ 
        isRecordingCallback( true );
    };
    
    mediaRecorder.onstop = function()
    {
         isRecordingCallback( false );
         let blob     = new Blob(chunks, {type: "video/webm"});
         chunks       = [];
         let videoURL = window.URL.createObjectURL(blob);
         let url      = window.URL.createObjectURL(blob);
         let a        = document.createElement("a");
         document.body.appendChild(a);
         a.style      = "display: none";
         a.href       = url;
         a.download   = "capture.webm";
         a.click();
         window.URL.revokeObjectURL(url);
     };
    
    return mediaRecorder;
}

function piExportToEXR(width, height, numComponents, type, bytes)
{
    var bytesPerComponent = 0;
    if      (type=="Uint")   bytesPerComponent = 4; 
    else if (type=="Half")   bytesPerComponent = 2;
    else if (type=="Float")  bytesPerComponent = 4;

    var tHeader = 258 + (18 * numComponents + 1);
    var tTable = 8 * height;
    var tScanlines = height * (4 + 4 + (numComponents * bytesPerComponent * width));
    var tTotal = tHeader + tTable + tScanlines;

    //console.log("    header size = " + tHeader);
    //console.log("    table size = " + tTable);
    //console.log("    scanlines size = " + tScanlines);
    //console.log("    total = " + tTotal);

    var buffer = new ArrayBuffer(tTotal); 
    var data = new DataView(buffer);

    // Header
    {
        // Header : 4 bytes -> 0x76, 0x2f, 0x31, 0x01
        var c = 0;
        data.setUint8 (c++, 0x76);
        data.setUint8 (c++, 0x2f);
        data.setUint8 (c++, 0x31);
        data.setUint8 (c++, 0x01);

        // Version : 4 bytes -> 2, 0, 0, 0
        data.setUint8 (c++, 0x02);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        
        // Write channel info
        // Write attribute name : "channels"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x73);
            data.setUint8 (c++, 0x0);

            // Write attribute type : "chlist"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : 18 x 3 + 1 = 55
            var attribSize = 18 * numComponents + 1;
            data.setUint8 (c++, attribSize); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            var i;
            for (i = 0; i < numComponents; i++)
            {
                // Attribute : "B" (42) "G" (47) "R" (52)
                if (i==0)       data.setUint8 (c++, 0x42);
                else if (i==1)  data.setUint8 (c++, 0x47);
                else if (i==2)  data.setUint8 (c++, 0x52);
                data.setUint8 (c++, 0x00);
                
                // Value : Float (2), Half (1), Uint (0)
                if      (type=="Uint")   data.setUint8 (c++, 0x00); 
                else if (type=="Half")   data.setUint8 (c++, 0x01);
                else if (type=="Float")  data.setUint8 (c++, 0x02);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);

                // Plinear
                data.setUint8 (c++, 0x01);

                // Reserved
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 

                // X sampling
                data.setUint8 (c++, 0x01); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                
                // Y sampling
                data.setUint8 (c++, 0x01);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
            }
            // End attribute
            data.setUint8 (c++, 0x00);
    
        // Write attribute name : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute type : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : "1"
            data.setUint8 (c++, 0x01); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // Write attribute value : "0" (None)
            data.setUint8 (c++, 0x00);

        // datawindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00); 

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00);

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 

            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // displayWindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x79); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00);

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00); 

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // size
            data.setUint8 (c++, 0x01);
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);
            
            // value 
            data.setUint8 (c++, 0x00);

        // PixelAspectRatio
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x41); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x52); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x00); 

            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);
        
            // size 4
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 1.0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);
        
        // screenWindowCenter
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63);
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x43); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e);
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00);

            // v2f
            data.setUint8 (c++, 0x76); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x00);

            // size 8
            data.setUint8 (c++, 0x08); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

        // screenWindowWidth
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x00); 
            
            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00); 

            // size
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);

            // value
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);

        // End of header
        data.setUint8 (c++, 0x00);
    }
    //console.log("header size = " + c);

    // Scanline table
    var initc = c + height * 8;
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        var jump = initc + scanline * (8 + width * bytesPerComponent * numComponents); 
        data.setUint32 (c, jump, true);
        c += 4; 

        data.setUint32 (c, 0x00, true);
        c += 4;
    }
    //console.log("header + scanlines table size = " + c);

    // Scanlines
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        // Scanline
        data.setUint32(c, scanline, true);
        c += 4;

        // size 24
        var size = width * numComponents * bytesPerComponent; 
        data.setUint32(c, size, true);
        c += 4;

        var numComponentsSource = 4; // number of components in the SOURCE image
        for (var component = 0; component < numComponents ; component ++) 
        {
            for (var pixel = 0 ; pixel < width ; pixel ++) 
            {
                // flip vertical, so we read OpenGL buffers without JS image flipping
                var v = bytes[(height-1-scanline) * width *numComponentsSource + pixel * numComponentsSource + (2-component)];
                if      (type=="Float") data.setFloat32(c, v, true);
                else if (type=="Half")  data.setUint16(c, v, true);

                c += bytesPerComponent;
            }
        }
    }
    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}


function piExportToWAV(numSamples, rate, bits, numChannels, words)
{
    let numBytes = numSamples * numChannels * bits/8;

    let buffer = new ArrayBuffer(44 + numBytes); 
    let data = new DataView(buffer);

    {
        data.setUint32( 0, 0x46464952, true );  // RIFF
        data.setUint32( 4, numBytes + 36, true);
        {
            data.setUint32( 8, 0x45564157, true );  // WAV_WAVE
            data.setUint32( 12, 0x20746D66, true );  // WAV_FMT
            {
                data.setUint32( 16, 16, true);
                data.setUint16( 20, 1, true ); // WAV_FORMAT_PCM
                data.setUint16( 22, numChannels, true);
                data.setUint32( 24, rate, true);
                data.setUint32( 28, rate*numChannels*bits / 8, true);
                data.setUint16( 32, numChannels*bits / 8, true);
                data.setUint16( 34, bits, true);
            }

            data.setUint32( 36, 0x61746164, true);  // WAV_DATA
            {
                data.setUint32( 40, numBytes, true);
                let numWords = numSamples * numChannels;
                for(let i=0; i<numWords; i++ )
                {
                    data.setInt16( 44 + i*2, words[i], true );
                }
            }
        }
    }


    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}

function piTriggerDownload(name, blob)
{
    let url = URL.createObjectURL(blob);
    let aElement = document.createElement("a");
    aElement.href     = url;
    aElement.target   = "_self";
    aElement.download = name;
    document.body.appendChild(aElement);
    aElement.click();
    document.body.removeChild(aElement);
}</script>
    <script>"use strict"

function bufferID_to_assetID( id )
{
    if( id===0 ) return '4dXGR8';
    if( id===1 ) return 'XsXGR8';
    if( id===2 ) return '4sXGR8';
    if( id===3 ) return 'XdfGR8';
    return 'none';
}
function assetID_to_bufferID( id )
{
    if( id==='4dXGR8' ) return 0;
    if( id==='XsXGR8' ) return 1;
    if( id==='4sXGR8' ) return 2;
    if( id==='XdfGR8' ) return 3;
    return -1;
}

function assetID_to_cubemapBuferID( id )
{
    if( id==='4dX3Rr' ) return 0;
    return -1;
}
function cubamepBufferID_to_assetID( id )
{
    if( id===0 ) return '4dX3Rr';
    return 'none';
}

function EffectPass( renderer, is20, isLowEnd, hasShaderTextureLOD, callback, obj, forceMuted, forcePaused, outputGainNode, copyProgram, id, effect  )
{
    this.mID = id;
    this.mInputs  = [null, null, null, null ];
    this.mOutputs = [null, null, null, null ];
    this.mSource = null;

    this.mGainNode = outputGainNode;
    this.mSoundShaderCompiled = false;

    this.mEffect = effect;
    this.mRenderer = renderer;
    this.mProgramCopy = copyProgram; 
    this.mCompilationTime = 0;

    this.mType = "none";
    this.mName = "none";
    this.mFrame = 0;

    this.mShaderTextureLOD = hasShaderTextureLOD;
    this.mIs20 = is20;
    this.mIsLowEnd = isLowEnd;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mForceMuted = forceMuted;
    this.mForcePaused = forcePaused;
}

EffectPass.prototype.MakeHeader_Image = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        // old API
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                   header += "uniform sampler2D iChannel" + i + ";\n";

        // new API (see shadertoy.com/view/wtdGW8)
        header += "uniform struct {\n";
             if( inp===null )                  header += "  sampler2D";
        else if( inp.mInfo.mType==="cubemap" ) header += "  samplerCube";
        else if( inp.mInfo.mType==="volume"  ) header += "  sampler3D";
        else                                  header += "  sampler2D";
        header +=        " sampler;\n";
        header += "  vec3  size;\n";
        header += "  float time;\n";
        header += "  int   loaded;\n";
        header += "}iCh" + i + ";\n";
    }
	header += "void mainImage( out vec4 c, in vec2 f );\n";
    header += "void st_assert( bool cond );\n";
    header += "void st_assert( bool cond, int v );\n";

    if( this.mIs20 ) 
    {
        header += "\nout vec4 shadertoy_out_color;\n" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)shadertoy_out_color.x=-1.0;else if(v==1)shadertoy_out_color.y=-1.0;else if(v==2)shadertoy_out_color.z=-1.0;else shadertoy_out_color.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)shadertoy_out_color.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "shadertoy_out_color = vec4(1.0,1.0,1.0,1.0);" + 
            "vec4 color = vec4(1e20);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "if(shadertoy_out_color.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(shadertoy_out_color.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(shadertoy_out_color.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(shadertoy_out_color.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "shadertoy_out_color = vec4(color.xyz,1.0);" +
        "}";
    }
    else
    {
        header += "" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)gl_FragColor.x=-1.0;else if(v==1)gl_FragColor.y=-1.0;else if(v==2)gl_FragColor.z=-1.0;else gl_FragColor.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)gl_FragColor.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "gl_FragColor = vec4(0.0,0.0,0.0,1.0);" + 
            "vec4 color = vec4(1e20);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "color.w = 1.0;" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(gl_FragColor.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "gl_FragColor = vec4(color.xyz,1.0);"+
        "}";
    }
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 ) 
        this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "void main( void )" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );" +
        "color.w = 1.0;"
    if( this.mIs20 ) 
        this.mImagePassFooterVR +=  "outColor = color;}";
    else
        this.mImagePassFooterVR +=  "gl_FragColor = color;}";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Buffer = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                  header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainImage( out vec4 c,  in vec2 f );\n"

    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +
        "mainImage( color, gl_FragCoord.xy );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
    this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        this.mImagePassFooterVR +="outColor = color; }";
    else
        this.mImagePassFooterVR +="gl_FragColor = color; }";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Cubemap = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                   header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainCubemap( out vec4 c, in vec2 f, in vec3 ro, in vec3 rd );\n"

    header += "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainCubemap( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Sound = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform float     iChannelTime[4];\n" +
              "uniform float     iTimeOffset;\n" +
              "uniform int       iSampleOffset;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n";

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp!==null && inp.mInfo.mType==="cubemap" )
            header += "uniform samplerCube iChannel" + i + ";\n";
        else
            header += "uniform sampler2D iChannel" + i + ";\n";
    }
    header += "\n";
    header += "vec2 mainSound( in int samp, float time );\n";

    if( this.mIs20 )
    {
        header += "out vec4 outColor; void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "int   s = iSampleOffset + int(gl_FragCoord.y-0.2)*512 + int(gl_FragCoord.x-0.2);" +
            "vec2 y = mainSound( s, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "outColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    else
    {
        header += "void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "vec2 y = mainSound( 0, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "gl_FragColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    header += "\n";
    this.mHeader = header;
    this.mHeaderLength = 0;
}


EffectPass.prototype.MakeHeader_Common = function ()
{
    let header = "";
    let headerlength = 0;

    header += "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n";
    headerlength += 2;

    if (this.mIs20)
    {
        header += "out vec4 outColor;\n";
        headerlength += 1;
    }
    header += "void main( void )\n";
    headerlength += 1;

    if (this.mIs20)
        header += "{ outColor = vec4(0.0); }";
    else
        header += "{ gl_FragColor = vec4(0.0); }";
    headerlength += 1;
    header += "\n";
    headerlength += 1;

    this.mHeader = header;
    this.mHeaderLength = headerlength;
}

EffectPass.prototype.MakeHeader = function()
{
         if( this.mType==="image" ) this.MakeHeader_Image();
    else if( this.mType==="sound" ) this.MakeHeader_Sound();
    else if( this.mType==="buffer") this.MakeHeader_Buffer();
    else if( this.mType==="common") this.MakeHeader_Common();
    else if( this.mType==="cubemap") this.MakeHeader_Cubemap();
    else console.log("ERROR 4");
}

EffectPass.prototype.Create_Image = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}
EffectPass.prototype.Destroy_Image = function( wa )
{
}

EffectPass.prototype.Create_Buffer = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}

EffectPass.prototype.Destroy_Buffer = function( wa )
{
}

EffectPass.prototype.Create_Cubemap = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
}

EffectPass.prototype.Destroy_Cubemap = function( wa )
{
}

EffectPass.prototype.Create_Common = function( wa )
{
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.MakeHeader();
}
EffectPass.prototype.Destroy_Common = function( wa )
{
}

EffectPass.prototype.Create_Sound = function (wa)
{
    this.MakeHeader();

    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    this.mSampleRate = 44100;
    this.mPlayTime = 60*3;
    this.mPlaySamples = this.mPlayTime*this.mSampleRate;
    this.mBuffer = wa.createBuffer( 2, this.mPlaySamples, this.mSampleRate );

    //-------------------
    this.mTextureDimensions = 512;
    this.mRenderTexture = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D, 
                                                       this.mTextureDimensions, this.mTextureDimensions,
                                                       this.mRenderer.TEXFMT.C4I8,
                                                       this.mRenderer.FILTER.NONE,
                                                       this.mRenderer.TEXWRP.CLAMP, null);
    this.mRenderFBO = this.mRenderer.CreateRenderTarget(this.mRenderTexture, null, null, null, null, false);

    //-----------------------------

    // ArrayBufferView pixels;
    this.mTmpBufferSamples = this.mTextureDimensions*this.mTextureDimensions;
    this.mData = new Uint8Array( this.mTmpBufferSamples*4 );

    this.mPlaying = false;
}

EffectPass.prototype.Destroy_Sound = function( wa )
{
    if( this.mPlayNode!==null ) this.mPlayNode.stop();
    this.mPlayNode = null;
    this.mBuffer = null;
    this.mData = null;

    this.mRenderer.DestroyRenderTarget(this.mRenderFBO);
    this.mRenderer.DestroyTexture(this.mRenderTexture);
}

EffectPass.prototype.Create = function( passType, wa )
{
    this.mType = passType;
    this.mSource = null;

         if( passType==="image" ) this.Create_Image( wa );
    else if( passType==="sound" ) this.Create_Sound( wa );
    else if( passType==="buffer") this.Create_Buffer( wa );
    else if( passType==="common") this.Create_Common( wa );
    else if( passType==="cubemap") this.Create_Cubemap( wa );
    else alert("ERROR 1");
}

EffectPass.prototype.SetName = function (passName)
{
    this.mName = passName;
}

EffectPass.prototype.SetCode = function (src)
{
    this.mSource = src;
}

EffectPass.prototype.Destroy = function( wa )
{
    this.mSource = null;
         if( this.mType==="image" ) this.Destroy_Image( wa );
    else if( this.mType==="sound" ) this.Destroy_Sound( wa );
    else if( this.mType==="buffer") this.Destroy_Buffer( wa );
    else if( this.mType==="common") this.Destroy_Common( wa );
    else if( this.mType==="cubemap") this.Destroy_Cubemap( wa );
    else alert("ERROR 2");
}

EffectPass.prototype.NewShader_Sound = function( shaderCode, commonShaderCodes)
{
    let vsSource = null;

    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for( let i=0; i<commonShaderCodes.length; i++ )
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    this.mSoundShaderCompiled = false;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader_Image = function ( shaderCode, commonShaderCodes )
{
    this.mSupportsVR = false;

    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    return [vsSource, fsSource];


    /*
    let n1 = shaderCode.indexOf("mainVR(");
    let n2 = shaderCode.indexOf("mainVR (");
    let n3 = shaderCode.indexOf("mainVR  (");
    if( n1>0 || n2>0 || n3>0 )
    {
        let vsSourceVR;
        if( this.mIs20 )
            vsSourceVR = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        else
            vsSourceVR = "attribute in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

        let fsSourceVR = this.mHeader;
        for (let i = 0; i < commonShaderCodes.length; i++) {
            fsSourceVR += commonShaderCodes[i];
        }
        fsSourceVR += shaderCode;
        fsSourceVR += this.mImagePassFooterVR;

        let res = this.mRenderer.CreateShader(vsSource, fsSourceVR, preventCache);
        if( res.mResult == false )
        {
            return res.mInfo;
        }
        if( this.mProgramVR != null )
            this.mRenderer.DestroyShader( this.mProgramVR );

        this.mSupportsVR = true;
        this.mProgramVR = res;
    }
    */
}

EffectPass.prototype.NewShader_Cubemap = function( shaderCode, commonShaderCodes )
{
    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }

    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;

    fsSource += shaderCode;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader_Common = function (shaderCode )
{
    let vsSource = null;
    if (this.mIs20)
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader + shaderCode;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader = function ( commonSourceCodes, preventCache, onResolve)
{
    if( this.mRenderer===null ) return;

    let vs_fs = null;

         if( this.mType==="sound"  ) vs_fs = this.NewShader_Sound(   this.mSource, commonSourceCodes );
    else if( this.mType==="image"  ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="buffer" ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="common" ) vs_fs = this.NewShader_Common(  this.mSource,                   );
    else if( this.mType==="cubemap") vs_fs = this.NewShader_Cubemap( this.mSource, commonSourceCodes );
    else { console.log("ERROR 3: \"" + this.mType + "\""); return; }

    let me = this;
    this.mRenderer.CreateShader(vs_fs[0], vs_fs[1], preventCache, false,
        function (worked, info)
        {
            if (worked === true)
            {
                if (me.mType === "sound")
                {
                    me.mSoundShaderCompiled = true;
                }

                me.mCompilationTime = info.mTime;
                me.mError = false;
                me.mErrorStr = "No Errors";
                if (me.mProgram !== null)
                    me.mRenderer.DestroyShader(me.mProgram);
                me.mTranslatedSource = me.mRenderer.GetTranslatedShaderSource(info);
                me.mProgram = info;
            }
            else
            {
                me.mError = true;
                me.mErrorStr = info.mErrorStr;
            }
            onResolve();
        });
}

EffectPass.prototype.DestroyInput = function( id )
{
    if( this.mInputs[id]===null ) return;

    if( this.mInputs[id].mInfo.mType==="texture" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    if( this.mInputs[id].mInfo.mType==="volume" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="webcam" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video.src = "";

        if( this.mInputs[id].video.srcObject!==null )
        {
        let tracks = this.mInputs[id].video.srcObject.getVideoTracks();
        if( tracks ) tracks[0].stop();
        }
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="video" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="music" || this.mInputs[id].mInfo.mType==="musicstream")
    {
        this.mInputs[id].audio.pause();
        this.mInputs[id].audio.mSound.mFreqData = null;
        this.mInputs[id].audio.mSound.mWaveData = null;
        this.mInputs[id].audio = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="cubemap" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="keyboard" )
    {
        //if( this.mInputs[id].globject != null )
          //  this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="mic" )
    {
        this.mInputs[id].mic = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }

    this.mInputs[id] = null;
}

EffectPass.prototype.TooglePauseInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        else
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.audio.mPaused )
        {
            if( inp.loaded )
            {
                inp.audio.play();
            }
            inp.audio.mPaused = false;
        }
        else
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }

    return null;
}

EffectPass.prototype.StopInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused === false )
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused === false )
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.ResumeInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused )
        {
            inp.audio.play();
            inp.audio.mPaused = false;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.RewindInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp==null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.loaded )
        {
            inp.video.currentTime = 0;
        }
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.loaded )
        {
            inp.audio.currentTime = 0;
        }
    }
}

EffectPass.prototype.MuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = true;
        inp.video.mMuted = true;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 0.0;
        inp.audio.mMuted = true;
    }
}

EffectPass.prototype.UnMuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = false;
        inp.video.mMuted = false;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 1.0;
        inp.audio.mMuted = false;
    }
}

EffectPass.prototype.ToggleMuteInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];
    if( inp===null ) return null;

    if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.video.mMuted;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if( inp.audio.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.audio.mMuted;
    }

    return null;
}

EffectPass.prototype.UpdateInputs = function( wa, forceUpdate, keyboard )
{
   for (let i=0; i<this.mInputs.length; i++ )
   {
        let inp = this.mInputs[i];

        if( inp===null )
        {
            if( forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, null, false, 0, 0, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.image, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mPreview, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if( inp.loaded && forceUpdate )
            {
                if( this.mTextureCallbackFun!==null )
                {
                    let img = (assetID_to_cubemapBuferID(inp.mInfo.mID)===-1) ? inp.image[0] : inp.mImage;
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, img, true, 2, 1, -1.0, this.mID );
                }
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:keyboard.mIcon,mData:keyboard.mData}, false, 6, 0, -1.0, this.mID );
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, -1, this.mID );
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
              if( inp.loaded && inp.audio.mPaused === false && inp.audio.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                      inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                  }

                  if (this.mTextureCallbackFun!==null)
                  {
                           if (inp.mInfo.mType === "music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData}, false, 4, 1, inp.audio.currentTime, this.mID);
                      else if (inp.mInfo.mType === "musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData, info: inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                  }
              }
              else if( inp.loaded===false )
              {
                  if (this.mTextureCallbackFun!==null)
                      this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:null}, false, 4, 0, -1.0, this.mID);
              }
        }
        else if( inp.mInfo.mType==="mic" )
        {
              if( inp.loaded && inp.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                      inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
                  }
                  if( this.mTextureCallbackFun!==null )
                      this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave: ((wa==null)?null:inp.mFreqData) }, false, 5, 1, 0, this.mID );
              }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:null}, true, 9, 1, -1.0, this.mID );
            }
        }
    }
}

EffectPass.prototype.Sampler2Renderer = function (sampler)
{
    let filter = this.mRenderer.FILTER.NONE;
    if (sampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
    if (sampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
    let wrap = this.mRenderer.TEXWRP.REPEAT;
    if (sampler.wrap === "clamp") wrap = this.mRenderer.TEXWRP.CLAMP;
    let vflip = false;
    if (sampler.vflip === "true") vflip = true;

    return { mFilter: filter, mWrap: wrap, mVFlip: vflip };
}

EffectPass.prototype.GetSamplerVFlip = function (id)
{
    let inp = this.mInputs[id];
    return inp.mInfo.mSampler.vflip;
}

EffectPass.prototype.GetTranslatedShaderSource = function ()
{
    return this.mTranslatedSource;
}

EffectPass.prototype.SetSamplerVFlip = function (id, str) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = false;
    if (str === "true") filter = true;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, null);
            inp.mInfo.mSampler.vflip = str;
        }
    }
}

EffectPass.prototype.GetAcceptsVFlip = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return false;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return false;
    return true;
}

EffectPass.prototype.GetSamplerFilter = function (id)
{
    let inp = this.mInputs[id];
    if( inp===null) return;
    return inp.mInfo.mSampler.filter;
}

EffectPass.prototype.SetSamplerFilter = function (id, str, buffers, cubeBuffers) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = renderer.FILTER.NONE;
    if (str === "linear") filter = renderer.FILTER.LINEAR;
    if (str === "mipmap") filter = renderer.FILTER.MIPMAP;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0)
            {
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[0], filter, true);
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[1], filter, true);
                inp.mInfo.mSampler.filter = str;
            }
            else
            {
                renderer.SetSamplerFilter(inp.globject, filter, true);
                inp.mInfo.mSampler.filter = str;
            }
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[0], filter, true);
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[1], filter, true);
        inp.mInfo.mSampler.filter = str;
    }
    else if (inp.mInfo.mType === "keyboard")
    {
        inp.mInfo.mSampler.filter = str;
    }
}

EffectPass.prototype.GetAcceptsMipmapping = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetAcceptsLinear = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return true;
    if (inp.mInfo.mType === "musicstream") return true;
    if (inp.mInfo.mType === "mic")  return true;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return true;
    return false;
}

EffectPass.prototype.GetAcceptsWrapRepeat = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return false;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetSamplerWrap = function (id)
{
    return this.mInputs[id].mInfo.mSampler.wrap;
}

EffectPass.prototype.SetSamplerWrap = function (id, str, buffers)
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let restr = renderer.TEXWRP.REPEAT;
    if (str === "clamp") restr = renderer.TEXWRP.CLAMP;

    if (inp === null) 
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "video") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap") 
    {
        if (inp.loaded)
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "webcam") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[0], restr);
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[1], restr);
        inp.mInfo.mSampler.wrap = str;
    }
}


EffectPass.prototype.GetTexture = function( slot )
{
    let inp = this.mInputs[slot];
    if( inp===null ) return null;
    return inp.mInfo;
}

EffectPass.prototype.SetOutputs = function( slot, id )
{
    this.mOutputs[slot] = id;
}

EffectPass.prototype.SetOutputsByBufferID = function( slot, id )
{
    if( this.mType==="buffer" )
    {
        this.mOutputs[slot] = bufferID_to_assetID( id );

        this.mEffect.ResizeBuffer( id, this.mEffect.mXres, this.mEffect.mYres, false );
    }
    else if( this.mType==="cubemap" )
    {
        this.mOutputs[slot] = cubamepBufferID_to_assetID( id );
        this.mEffect.ResizeCubemapBuffer(id, 1024, 1024 );
    }
}

EffectPass.prototype.NewTexture = function( wa, slot, url, buffers, cubeBuffers, keyboard )
{
    var me = this;
    var renderer = this.mRenderer;

    if( renderer===null ) return;

    let texture = null;

    if( url===null || url.mType===null )
    {
        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( this.mTextureCallbackObj, slot, null, true, 0, 0, -1.0, me.mID );
        me.DestroyInput( slot );
        me.mInputs[slot] = null;
        me.MakeHeader();
        return { mFailed:false, mNeedsShaderCompile:false };
    }
    else if( url.mType==="texture" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.image = new Image();
        texture.image.crossOrigin = '';
        texture.image.onload = function()
        {
            let rti = me.Sampler2Renderer(url.mSampler);

            // O.M.G. FIX THIS
            let channels = renderer.TEXFMT.C4I8;
            if (url.mID === "Xdf3zn" || url.mID === "4sf3Rn" || url.mID === "4dXGzn" || url.mID === "4sf3Rr")
                channels = renderer.TEXFMT.C1I8;
            
            texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.image, channels, rti.mFilter, rti.mWrap, rti.mVFlip);

            texture.loaded = true;
            if( me.mTextureCallbackFun!==null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.image, true, 1, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="volume" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mImage = { mData:null, mXres:1, mYres:0, mZres:0 };
        texture.mPreview = new Image();
        texture.mPreview.crossOrigin = '';

	    var xmlHttp = new XMLHttpRequest();
        if( xmlHttp===null ) return { mFailed:true };

        xmlHttp.open('GET', url.mSrc, true);
        xmlHttp.responseType = "arraybuffer";
        xmlHttp.onerror = function()
        {
            console.log( "Error 1 loading Volume" );
        }
        xmlHttp.onload = function()
        {
            let data = xmlHttp.response;
            if (!data ) { console.log( "Error 2 loading Volume" ); return; }

            let file = piFile(data);

            let signature = file.ReadUInt32();
            texture.mImage.mXres = file.ReadUInt32();
            texture.mImage.mYres = file.ReadUInt32();
            texture.mImage.mZres = file.ReadUInt32();
            let binNumChannels = file.ReadUInt8();
            let binLayout = file.ReadUInt8();
            let binFormat = file.ReadUInt16();
            let format = renderer.TEXFMT.C1I8;
                 if( binNumChannels===1 && binFormat===0 )  format = renderer.TEXFMT.C1I8;
            else if( binNumChannels===2 && binFormat===0 )  format = renderer.TEXFMT.C2I8;
            else if( binNumChannels===3 && binFormat===0 )  format = renderer.TEXFMT.C3I8;
            else if( binNumChannels===4 && binFormat===0 )  format = renderer.TEXFMT.C4I8;
            else if( binNumChannels===1 && binFormat===10 ) format = renderer.TEXFMT.C1F32;
            else if( binNumChannels===2 && binFormat===10 ) format = renderer.TEXFMT.C2F32;
            else if( binNumChannels===3 && binFormat===10 ) format = renderer.TEXFMT.C3F32;
            else if( binNumChannels===4 && binFormat===10 ) format = renderer.TEXFMT.C4F32;
            else return;

            let buffer = new Uint8Array(data, 20); // skip 16 bytes (header of .bin)

            let rti = me.Sampler2Renderer(url.mSampler);

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T3D, texture.mImage.mXres, texture.mImage.mYres, format, rti.mFilter, rti.mWrap, buffer);

            if( texture.globject===null )
            {
                console.log( "Error 4: loading Volume" ); 
                return { mFailed:true };
            }

            if (me.mTextureCallbackFun !== null)
            {
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }

            texture.loaded = true;

            // load icon for it
            texture.mPreview.onload = function()
            {
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }
            texture.mPreview.src = url.mPreviewSrc;
        }
        xmlHttp.send("");


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="volume")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="cubemap" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        let rti = me.Sampler2Renderer(url.mSampler);

        if( assetID_to_cubemapBuferID(url.mID)!==-1 )
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 2, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/cubemap00.png";

            this.mEffect.ResizeCubemapBuffer(0, 1024, 1024 );

        }
        else
        {
            texture.image = [ new Image(), new Image(), new Image(), new Image(), new Image(), new Image() ];

            let numLoaded = 0;
            for (var i=0; i<6; i++ )
            {
                texture.image[i].mId = i;
                texture.image[i].crossOrigin = '';
                texture.image[i].onload = function()
                {
                    var id = this.mId;
                    numLoaded++;
                    if( numLoaded===6 )
                    {
                        texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.CUBEMAP, texture.image, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                        texture.loaded = true;
                        if (me.mTextureCallbackFun !== null)
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, texture.image[0], true, 2, 1, -1.0, me.mID);
                    }
                }

                if( i === 0) 
                {
                    texture.image[i].src = url.mSrc;
                } 
                else 
                {
                    let n = url.mSrc.lastIndexOf(".");
                    texture.image[i].src = url.mSrc.substring(0, n) + "_" + i + url.mSrc.substring(n, url.mSrc.length);
                }
            }
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="cubemap")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="webcam" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        texture.video = document.createElement('video');
    	texture.video.width = 320;
    	texture.video.height = 240;
    	texture.video.autoplay = true;
    	texture.video.loop = true;
        texture.mForceMuted = this.mForceMuted;
        texture.mImage = null;

        let rti = me.Sampler2Renderer(url.mSampler);

        var loadImageInsteadOfWebCam = function()
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.mImage, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 7, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/webcam.png";
        }
        
        loadImageInsteadOfWebCam();

        if( typeof navigator.getUserMedia !== "undefined"  && texture.mForceMuted===false )
        {
            texture.video.addEventListener("canplay", function (e)
            {
				try
				{
                    texture.mImage = null;
                    if( texture.globject != null )
                        renderer.DestroyTexture( texture.globject );
					texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
					texture.loaded = true;
                }
                catch(e)
                {
                    loadImageInsteadOfWebCam();
	                alert( 'Your browser can not transfer webcam data to the GPU.');
                }
            } );

            navigator.mediaDevices.getUserMedia( 
                                { "video": { width: 1280, height: 720 }, "audio": false } )
                                .then( function(stream)
                                       {
                                            texture.video.srcObject = stream;
    	                               } )
                                .catch( function(error)
                                        {
                                            loadImageInsteadOfWebCam();
    		                                alert( 'Unable to capture WebCam. Please reload the page.' );
    	                                } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="mic" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mForceMuted = this.mForceMuted;
        texture.mAnalyser = null;
        let num = 512;
        texture.mFreqData = new Uint8Array( num );
        texture.mWaveData = new Uint8Array( num );

        if( wa === null || typeof navigator.getUserMedia === "undefined" )
        {
            if( !texture.mForceMuted ) alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.mForceMuted = true; 
        }

        if( texture.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, num, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)
            texture.loaded = true;
        }
        else
        {
        navigator.getUserMedia( { "audio": true },
                                function(stream)
                                {
                                  texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, null)
                                  texture.mic = wa.createMediaStreamSource(stream);
                                  texture.mAnalyser = wa.createAnalyser();
                                  texture.mic.connect( texture.mAnalyser );
                                  texture.loaded = true;
    	                        },
                                function(error)
                                {
    		                        alert( 'Unable open Mic. Please reload the page.' );
    	                        } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="video" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.video = document.createElement('video');
    	texture.video.loop = true;
        texture.video.preload = "auto";
        texture.video.mPaused = this.mForcePaused;
        texture.video.mMuted = true;//this.mForceMuted;
    	texture.video.muted  = true;//this.mForceMuted;
        if( this.mForceMuted===true )
            texture.video.volume = 0;
    	texture.video.autoplay = false;
        texture.video.hasFalled = false;
        
        let rti = me.Sampler2Renderer(url.mSampler);

        texture.video.addEventListener("canplay", function (e)
        {
            texture.video.play().then( function()
                                       {
                                           texture.video.mPaused = false;

                                           texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                                           texture.loaded = true;
            
                                           if( me.mTextureCallbackFun!=null )
                                               me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.video, true, 3, 1, -1.0, me.mID );
                                        } )
                               .catch( function(error)
                                       {
                                           console.log( error );
                                       }
                                );
        } );

        texture.video.addEventListener( "error", function(e)
        {
               if( texture.video.hasFalled===true ) { alert("Error: cannot load video" ); return; }
               let str = texture.video.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".mp4";
               texture.video.src = str;
               texture.video.hasFalled = true;
        } );

        texture.video.src = url.mSrc;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="music" || url.mType==="musicstream" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.audio = document.createElement('audio');
    	texture.audio.loop = true;
        texture.audio.mMuted = this.mForceMuted;
        texture.audio.mForceMuted = this.mForceMuted;
        texture.audio.muted = this.mForceMuted;
        if( this.mForceMuted===true )
            texture.audio.volume = 0;
        texture.audio.autoplay = false;
        texture.audio.hasFalled = false;
        texture.audio.mPaused = false;
        texture.audio.mSound = {};

        if( this.mForceMuted===false )
        {
            if(url.mType==="musicstream" && SC === null)
            {
                alert( "Shadertoy: Soundcloud could not be reached" );
                texture.audio.mForceMuted = true;
            }
            }

        if( wa === null && this.mForceMuted===false )
        {
            alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.audio.mForceMuted = true;
        }

        if( texture.audio.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null);
            let num = 512;
            texture.audio.mSound.mFreqData = new Uint8Array( num );
            texture.audio.mSound.mWaveData = new Uint8Array( num );
            texture.loaded = true;
        }

        texture.audio.addEventListener( "canplay", function()
        {
            if( texture===null || texture.audio===null ) return;
            if( this.mForceMuted  ) return;
            if( texture.loaded === true ) return;

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)

            texture.audio.mSound.mSource   = wa.createMediaElementSource( texture.audio );
            texture.audio.mSound.mAnalyser = wa.createAnalyser();
            texture.audio.mSound.mGain     = wa.createGain();

            texture.audio.mSound.mSource.connect(   texture.audio.mSound.mAnalyser );
            texture.audio.mSound.mAnalyser.connect( texture.audio.mSound.mGain );
            texture.audio.mSound.mGain.connect(me.mGainNode);

            texture.audio.mSound.mFreqData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );
            texture.audio.mSound.mWaveData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );

            if( texture.audio.mPaused )
            {
                texture.audio.pause();
            }
            else
            {
                texture.audio.play().then( function() {} ).catch( function(e){console.log("error " + e);} );
            }
            texture.loaded = true;
        } );

        texture.audio.addEventListener( "error", function(e)
        {
               if( this.mForceMuted  ) return;

               if( texture.audio.hasFalled===true ) { return; }
               let str = texture.audio.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".ogg";
               texture.audio.src = str;
               texture.audio.hasFalled = true;
        } );

        if( !texture.audio.mForceMuted )
        {
            if(url.mType==="musicstream")
            {
                SC.resolve(url.mSrc, 
                    function(song) 
                    {
                        if( song.streamable===true )
                        {
                            texture.audio.crossOrigin = 'anonymous';
                            texture.audio.src = song.stream_url;
                            texture.audio.soundcloudInfo = song;
                        }
                        else
                        {
                            alert('Shadertoy: Soundcloud 3 - This track cannot be streamed' );
                        }
                    },
                    function(error)
                    {
                        if (me.mTextureCallbackFun!==null)
                        {
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
                        }
                    } );
            } 
            else
            {
                texture.audio.src = url.mSrc;
            }
        }

        if (me.mTextureCallbackFun!==null)
        {
            if (url.mType === "music")            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
            else if (url.mType === "musicstream") me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null, info: texture.audio.soundcloudInfo}, false, 8, 0, -1.0, me.mID);
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="keyboard" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = true;

        texture.keyboard = {};

        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {mImage: keyboard.mIcon, mData: keyboard.mData}, false, 6, 1, -1.0, me.mID );

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="buffer" )
    {
        texture = {};
        texture.mInfo = url;

        texture.image = new Image();
        texture.image.onload = function()
        {
            if( me.mTextureCallbackFun!==null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {texture: texture.image, data:null}, true, 9, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;
        texture.id = assetID_to_bufferID( url.mID );
        texture.loaded = true;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;

        this.mEffect.ResizeBuffer(texture.id, this.mEffect.mXres, this.mEffect.mYres, false );

        this.SetSamplerFilter(slot, url.mSampler.filter, buffers, cubeBuffers, true);
        this.SetSamplerVFlip(slot, url.mSampler.vflip);
        this.SetSamplerWrap(slot, url.mSampler.wrap, buffers);

        this.MakeHeader();
        return returnValue;
    }
    else
    {
        alert( "input type error" );
        return { mFailed: true };
    }

    return { mFailed: true };
}

EffectPass.prototype.Paint_Image = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];

    //------------------------
    
    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];
    let texIsLoaded = [0, 0, 0, 0 ];
    let texID = [ null, null, null, null];

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
            texIsLoaded[i] = 1;
            resos[3*i+0] = 256;
            resos[3*i+1] = 3;
            resos[3*i+2] = 1;
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;

                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                }
            }
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {

                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                texIsLoaded[i] = 0;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    times[i] = 10.0 + time;
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            let id = inp.id;
            if( inp.loaded===true  )
            {
                texID[i] = buffers[id].mTexture[ buffers[id].mLastRenderDone ];
                texIsLoaded[i] = 1;
                resos[3*i+0] = xres;
                resos[3*i+1] = yres;
                resos[3*i+2] = 1;
                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID[i], filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    let prog = this.mProgram;

    //if( vrData!=null && this.mSupportsVR ) prog = this.mProgramVR;

    this.mRenderer.AttachShader(prog);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F("iFrameRate", fps);

    this.mRenderer.SetShaderConstant1F(  "iCh0.time", times[0] );
    this.mRenderer.SetShaderConstant1F(  "iCh1.time", times[1] );
    this.mRenderer.SetShaderConstant1F(  "iCh2.time", times[2] );
    this.mRenderer.SetShaderConstant1F(  "iCh3.time", times[3] );
    this.mRenderer.SetShaderConstant3F(  "iCh0.size", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iCh1.size", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iCh2.size", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iCh3.size", resos[9], resos[10], resos[11] );
    this.mRenderer.SetShaderConstant1I(  "iCh0.loaded", texIsLoaded[0] );
    this.mRenderer.SetShaderConstant1I(  "iCh1.loaded", texIsLoaded[1] );
    this.mRenderer.SetShaderConstant1I(  "iCh2.loaded", texIsLoaded[2] );
    this.mRenderer.SetShaderConstant1I(  "iCh3.loaded", texIsLoaded[3] );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    if( (vrData !== null) && this.mSupportsVR )
    {
        for (let i=0; i<2; i++ )
        {
            let ei = (i===0) ? vrData.mLeftEye : vrData.mRightEye;

            let vp = [i * xres / 2, 0, xres / 2, yres];

            this.mRenderer.SetViewport(vp);

            let fov = ei.mProjection;
            let corA = [ -fov[2], -fov[1], -1.0 ];
            let corB = [  fov[3], -fov[1], -1.0 ];
            let corC = [  fov[3],  fov[0], -1.0 ];
            let corD = [ -fov[2],  fov[0], -1.0 ];
            let apex = [ 0.0, 0.0, 0.0 ];

            let ma = invertFast( ei.mCamera );
            corA = matMulpoint( ma, corA ); 
            corB = matMulpoint( ma, corB ); 
            corC = matMulpoint( ma, corC ); 
            corD = matMulpoint( ma, corD ); 
            apex = matMulpoint( ma, apex ); 

            let corners = [ corA[0], corA[1], corA[2], 
                            corB[0], corB[1], corB[2], 
                            corC[0], corC[1], corC[2], 
                            corD[0], corD[1], corD[2],
                            apex[0], apex[1], apex[2]];

            this.mRenderer.SetShaderConstant3FV("unCorners", corners);
            this.mRenderer.SetShaderConstant4FV("unViewport", vp);

            this.mRenderer.DrawUnitQuad_XY(l1);
        }
    }
    else 
    {
        this.mRenderer.SetViewport([0, 0, xres, yres]);
        this.mRenderer.DrawFullScreenTriangle_XY( l1 );
    }

    this.mRenderer.DettachTextures();
}

EffectPass.prototype.iRenderSound = function(d, callback )
{
    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds() ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    this.mRenderer.SetRenderTarget(this.mRenderFBO);

    this.mRenderer.SetViewport([0, 0, this.mTextureDimensions, this.mTextureDimensions]);
    this.mRenderer.AttachShader(this.mProgram);
    this.mRenderer.SetBlend( false );

    let texID = [null, null, null, null];
    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
    }

    this.mRenderer.AttachTextures(4, texID[0], texID[1], texID[2], texID[3]);

    let l2 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iTimeOffset");
    let l3 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iSampleOffset");
    this.mRenderer.SetShaderConstant4FV("iDate", dates);
    this.mRenderer.SetShaderConstant3FV("iChannelResolution", resos);
    this.mRenderer.SetShaderConstant1F("iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit("iChannel0", 0);
    this.mRenderer.SetShaderTextureUnit("iChannel1", 1);
    this.mRenderer.SetShaderTextureUnit("iChannel2", 2);
    this.mRenderer.SetShaderTextureUnit("iChannel3", 3);

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    //--------------------------------
    let numSamples = this.mTmpBufferSamples;
    let numBlocks = this.mPlaySamples / numSamples;
    for (let j=0; j<numBlocks; j++ )
    {
        let off = j*numSamples;
        
        this.mRenderer.SetShaderConstant1F_Pos(l2, off / this.mSampleRate);
        this.mRenderer.SetShaderConstant1I_Pos(l3, off );
        this.mRenderer.DrawUnitQuad_XY(l1);

        this.mRenderer.GetPixelData(this.mData, 0, this.mTextureDimensions, this.mTextureDimensions);

        callback( off, this.mData, numSamples );
    }

    this.mRenderer.DetachShader();
    this.mRenderer.DettachTextures();
    this.mRenderer.SetRenderTarget(null);
}

EffectPass.prototype.Paint_Sound = function( wa, d )
{
    let bufL = this.mBuffer.getChannelData(0); // Float32Array
    let bufR = this.mBuffer.getChannelData(1); // Float32Array

    this.iRenderSound( d, function(off, data, numSamples)
                         {
                            for( let i=0; i<numSamples; i++ )
                            {
                                bufL[off+i] = -1.0 + 2.0*(data[4*i+0]+256.0*data[4*i+1])/65535.0;
                                bufR[off+i] = -1.0 + 2.0*(data[4*i+2]+256.0*data[4*i+3])/65535.0;
                            }
                         }
                     );
}

EffectPass.prototype.SetUniforms = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    //------------------------
    
    let texID = [ null, null, null, null];

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
        }
        else if( inp.mInfo.mType=="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
    
                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                }
            }

        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
           if( inp.loaded===true )
           { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                times[i] = 10.0 + time;
            }

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = buffers[inp.id].mTexture[ buffers[inp.id].mLastRenderDone ];
                resos[3*i+0] = buffers[inp.id].mResolution[0];
                resos[3*i+1] = buffers[inp.id].mResolution[1];
                resos[3*i+2] = 1;
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    this.mRenderer.AttachShader(this.mProgram);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F(  "iFrameRate", fps );

    this.mRenderer.SetShaderConstant1F(  "iChannel[0].time",       times[0] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[1].time",       times[1] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[2].time",       times[2] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[3].time",       times[3] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[0].resolution", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[1].resolution", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[2].resolution", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[3].resolution", resos[9], resos[10], resos[11] );
}

EffectPass.prototype.ProcessInputs = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
        }
        else if( inp.mInfo.mType==="volume" )
        {
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );
                }
                else if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                if( inp.audio.mForceMuted === true )
                {
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                let id = inp.id;
                let texID = buffers[id].mTexture[ buffers[id].mLastRenderDone ];

                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID, filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
				let id = inp.id;
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }
}

EffectPass.prototype.Paint_Cubemap = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face )
{
    this.ProcessInputs(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
    this.SetUniforms(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    let vp = [0, 0, xres, yres];

    this.mRenderer.SetViewport(vp);

    let corA = [-1.0, -1.0, -1.0];
    let corB = [ 1.0, -1.0, -1.0];
    let corC = [ 1.0,  1.0, -1.0];
    let corD = [-1.0,  1.0, -1.0];
    let apex = [ 0.0,  0.0,  0.0];

         if( face===0 ) { corA=[ 1.0,  1.0,  1.0]; corB=[ 1.0,  1.0, -1.0]; corC=[ 1.0, -1.0, -1.0]; corD=[ 1.0, -1.0,  1.0]; }
    else if( face===1 ) { corA=[-1.0,  1.0, -1.0]; corB=[-1.0,  1.0,  1.0]; corC=[-1.0, -1.0,  1.0]; corD=[-1.0, -1.0, -1.0]; }
    else if( face===2 ) { corA=[-1.0,  1.0, -1.0]; corB=[ 1.0,  1.0, -1.0]; corC=[ 1.0,  1.0,  1.0]; corD=[-1.0,  1.0,  1.0]; }
    else if( face===3 ) { corA=[-1.0, -1.0,  1.0]; corB=[ 1.0, -1.0,  1.0]; corC=[ 1.0, -1.0, -1.0]; corD=[-1.0, -1.0, -1.0]; }
    else if( face===4 ) { corA=[-1.0,  1.0,  1.0]; corB=[ 1.0,  1.0,  1.0]; corC=[ 1.0, -1.0,  1.0]; corD=[-1.0, -1.0,  1.0]; }
    else if( face===5 ) { corA=[ 1.0,  1.0, -1.0]; corB=[-1.0,  1.0, -1.0]; corC=[-1.0, -1.0, -1.0]; corD=[ 1.0, -1.0, -1.0]; }

    let corners = [ corA[0], corA[1], corA[2], 
                    corB[0], corB[1], corB[2], 
                    corC[0], corC[1], corC[2], 
                    corD[0], corD[1], corD[2],
                    apex[0], apex[1], apex[2]];

    this.mRenderer.SetShaderConstant3FV("unCorners", corners);
    this.mRenderer.SetShaderConstant4FV("unViewport", vp);

    this.mRenderer.DrawUnitQuad_XY(l1);

    this.mRenderer.DettachTextures();
}

EffectPass.prototype.Paint = function( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, bufferNeedsMimaps, buffers, cubeBuffers, keyboard, effect )
{
    if( this.mType==="sound" )
    {
        if (this.mSoundShaderCompiled === true)
        {
            // make sure all textures are loaded
            for (let i=0; i<this.mInputs.length; i++ )
            {
                let inp = this.mInputs[i];
                if (inp === null) continue;

                if (inp.mInfo.mType === "texture" && !inp.loaded) return;
                if (inp.mInfo.mType === "cubemap" && !inp.loaded) return;
            }

            this.Paint_Sound(wa, da);
            this.mSoundShaderCompiled = false;
        }
        if (this.mFrame === 0)
        {
            if (this.mPlaying===true)
            {
                this.mPlayNode.disconnect();
                this.mPlayNode.stop();
                this.mPlayNode = null;
            }
            this.mPlaying = true;

            this.mPlayNode = wa.createBufferSource();
            this.mPlayNode.buffer = this.mBuffer;
            this.mPlayNode.connect(this.mGainNode);
            this.mPlayNode.start(0);
        }
        this.mFrame++;
    }
    else if( this.mType==="image" )
    {
        this.mRenderer.SetRenderTarget( null );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );
        this.mFrame++;
    }
    else if( this.mType==="common" )
    {
    }
    else if( this.mType==="buffer" )
    {
        this.mEffect.ResizeBuffer(bufferID, this.mEffect.mXres, this.mEffect.mYres, false );

        let buffer = buffers[bufferID];

        let dstID = 1 - buffer.mLastRenderDone;

        this.mRenderer.SetRenderTarget( buffer.mTarget[dstID] );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }

        // make thumbnail
        //if( this.mTextureCallbackFun != null )
        /*
        {
            this.mRenderer.SetRenderTarget( buffer.mThumbnailRenderTarget );
            let v = [0, 0, buffer.mThumbnailRes[0], buffer.mThumbnailRes[1]];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            this.mRenderer.SetShaderConstant4FV("v", v);
            this.mRenderer.AttachTextures(1, buffer.mTexture[dstID], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);
            this.mRenderer.DettachTextures();
            this.mRenderer.DetachShader();
            this.mRenderer.GetPixelData( new Uint8Array(buffer.mThumbnailBuffer.data.buffer), buffer.mThumbnailRes[0], buffer.mThumbnailRes[1] );
            this.mRenderer.SetRenderTarget(null);
        }
        */
        buffers[bufferID].mLastRenderDone = 1 - buffers[bufferID].mLastRenderDone;
        this.mFrame++;
    }
    else if( this.mType==="cubemap" )
    {
        this.mEffect.ResizeCubemapBuffer(bufferID, 1024, 1024, false );

        let buffer = cubeBuffers[bufferID];

        xres = buffer.mResolution[0];
        yres = buffer.mResolution[1];
        let dstID = 1 - buffer.mLastRenderDone;
        for( let face=0; face<6; face++ )
        {
            this.mRenderer.SetRenderTargetCubeMap( buffer.mTarget[dstID], face );
            this.Paint_Cubemap( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
        }
        this.mRenderer.SetRenderTargetCubeMap( null, 0 );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }
        cubeBuffers[bufferID].mLastRenderDone = 1 - cubeBuffers[bufferID].mLastRenderDone;

        this.mFrame++;
    }
}

EffectPass.prototype.StopOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;
    this.mPlayNode.disconnect();
}

EffectPass.prototype.ResumeOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;

    wa.resume()
    this.mPlayNode.connect( this.mGainNode );
}

EffectPass.prototype.StopOutput_Image = function( wa )
{
}

EffectPass.prototype.ResumeOutput_Image = function( wa )
{
}

EffectPass.prototype.StopOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.StopInput(j);

    if( this.mType==="sound" )
         this.StopOutput_Sound( wa );
    else
         this.StopOutput_Image( wa );
}

EffectPass.prototype.ResumeOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.ResumeInput(j);

    if( this.mType==="sound" )
         this.ResumeOutput_Sound( wa );
    else
         this.ResumeOutput_Image( wa );
}

EffectPass.prototype.GetCompilationTime = function()
{
    return this.mCompilationTime;
}

//============================================================================================================
function Screenshots()
{
    // private
    let mTexture = null;
    let mTarget = null;
    let mXres = 0;
    let mYres = 0;
    let mCubemapToEquirectProgram;
    let mRenderer = null;

    // public
    var me = {};

    me.Initialize = function(renderer)
    {
        mRenderer = renderer;
        let caps = mRenderer.GetCaps();
        let is20 = caps.mIsGL20;

        let vsSourceC, fsSourceC;
        if( is20 )
        {
            vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; out vec4 outColor; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); outColor = texture(t, rd); }";
        }
        else
        {
            vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); gl_FragColor = texture(t, rd); }";
        }

        let compileShader = function (worked, info)
        {
            if (worked === false)
            {
                console.log("Failed to compile cubemap resample shader (" + errorType + "): " + log);
            }
            else
            {
                mCubemapToEquirectProgram = info;
            }
        }
        mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, compileShader);

        return true;
    };

    me.Allocate = function( xres, yres )
    {
        if( xres>mXres || yres>mYres )
        {
            let texture = mRenderer.CreateTexture(mRenderer.TEXTYPE.T2D, xres, yres, mRenderer.TEXFMT.C4F32, mRenderer.FILTER.NONE, mRenderer.TEXWRP.CLAMP, null);
            let target = mRenderer.CreateRenderTarget( texture, null, null, null, null, false);

            if( mXres!==0 )
            {
                mRenderer.DestroyTexture(mTexture);
                mRenderer.DestroyRenderTarget(mTarget);
            }

            mTexture = texture;
            mTarget = target;
            mXres = xres;
            mYres = yres;
        }
    };

    me.GetProgram = function()
    {
        return mCubemapToEquirectProgram;
    };
    me.GetTarget = function()
    {
        return mTarget;
    };

    return me;
};

//============================================================================================================

function Effect(vr, ac, canvas, callback, obj, forceMuted, forcePaused, resizeCallback, crashCallback )
{
    let xres = canvas.width;
    let yres = canvas.height;

    let me = this;
    this.mCanvas = canvas;
    this.mCreated = false;
    this.mRenderer = null;
    this.mAudioContext = ac;
    this.mGLContext = null;
    this.mWebVR = vr;
    this.mRenderingStereo = false;
    this.mXres = xres;
    this.mYres = yres;
    this.mForceMuted = forceMuted;
    if( ac===null ) this.mForceMuted = true;
    this.mForcePaused = forcePaused;
    this.mGainNode = null;
    this.mPasses = [];
    this.mFrame = 0;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mMaxBuffers = 4;
    this.mMaxCubeBuffers = 1;
    this.mMaxPasses = this.mMaxBuffers + 1 + 1 + 1 + 1; // some day decouple passes from buffers (4 buffers + common + Imagen + sound + cubemap)
    this.mBuffers = [];
    this.mCubeBuffers = [];
    this.mScreenshotSytem = null;
    this.mCompilationTime = 0;
    this.mIsLowEnd = piIsMobile();

    this.mGLContext = piCreateGlContext(canvas, false, false, true, false); // need preserve-buffe to true in order to capture screenshots
    if (this.mGLContext === null)
    {
        return;
    }

    canvas.addEventListener("webglcontextlost", function (event)
        {
            event.preventDefault();
            crashCallback();
        }, false);

    this.mRenderer = piRenderer();
    if (!this.mRenderer.Initialize(this.mGLContext))
        return;

    this.mScreenshotSytem = Screenshots();
    if (!this.mScreenshotSytem.Initialize(this.mRenderer))
        return;

    var caps = this.mRenderer.GetCaps();
    this.mIs20 = caps.mIsGL20;
    this.mShaderTextureLOD = caps.mShaderTextureLOD;
    //-------------
    if( ac!==null )
    {   
        this.mGainNode = ac.createGain();
        if( !forceMuted )
        {
            this.mGainNode.connect( ac.destination);
        }
        if (this.mForceMuted )
            this.mGainNode.gain.value = 0.0;
        else
            this.mGainNode.gain.value = 1.0;
    }

    //-------------
    let vsSourceC, fsSourceC;
    if( this.mIs20 )
    {
        vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { outColor = textureLod(t, gl_FragCoord.xy / v.zw, 0.0); }";
    }
    else
    {
        vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; void main() { gl_FragColor = texture2D(t, gl_FragCoord.xy / v.zw, -100.0); }";
    }

    this.mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, function(worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to copy buffers : " + info.mErrorStr);
            else me.mProgramCopy = info;
        });

    let vsSourceD, fsSourceD;
    if( this.mIs20 )
    {
        vsSourceD = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { vec2 uv = gl_FragCoord.xy / v.zw; outColor = texture(t, vec2(uv.x,1.0-uv.y)); }";
    }
    else
    {
        vsSourceD = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; void main() { vec2 uv = gl_FragCoord.xy / v.zw; gl_FragColor = texture2D(t, vec2(uv.x,1.0-uv.y)); }";
    }

    this.mRenderer.CreateShader(vsSourceD, fsSourceD, false, true, function (worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to downscale buffers : " + info.mErrorStr);
            else me.mProgramDownscale = info;
        });


    // set all buffers and cubemaps to null
    for( let i=0; i<this.mMaxBuffers; i++ )
    {
        this.mBuffers[i] = { mTexture: [null, null], 
                             mTarget:  [null, null], 
                             mResolution: [0, 0],
                             mLastRenderDone: 0,
                             mThumbnailRenderTarget: null,
                             mThumbnailTexture: null,
                             mThumbnailBuffer:  null,
                             mThumbnailRes: [0, 0] };
    }

    for( let i=0; i<this.mMaxCubeBuffers; i++ )
    {
        this.mCubeBuffers[i] = { mTexture: [null, null], 
                                mTarget:  [null, null], 
                                mResolution: [0, 0],
                                mLastRenderDone: 0,
                                mThumbnailRenderTarget: null,
                                mThumbnailTexture: null,
                                mThumbnailBuffer:  null,
                                mThumbnailRes: [0, 0] };
    }

    //-------

    let keyboardData = new Uint8Array( 256*3 );
    for (let j=0; j<(256*3); j++ ) { keyboardData[j] = 0; }
    let kayboardTexture = this.mRenderer.CreateTexture( this.mRenderer.TEXTYPE.T2D, 256, 3, this.mRenderer.TEXFMT.C1I8, this.mRenderer.FILTER.NONE, this.mRenderer.TEXWRP.CLAMP, null);
    let keyboardImage = new Image();
    if( callback!==null )
        keyboardImage.src = "/img/keyboard.png"; // don't load PNG if no UI 
    this.mKeyboard = { mData: keyboardData, mTexture: kayboardTexture, mIcon: keyboardImage };

    let iResize = function( xres, yres )
    {
        me.mCanvas.width = xres;
        me.mCanvas.height = yres;
        me.mXres = xres;
        me.mYres = yres;
        me.ResizeBuffers(xres, yres);
        resizeCallback(xres, yres);
    };

    let bestAttemptFallback = function()
    {
        let devicePixelRatio = window.devicePixelRatio || 1;
        let xres = Math.round(me.mCanvas.offsetWidth  * devicePixelRatio) | 0;
        let yres = Math.round(me.mCanvas.offsetHeight * devicePixelRatio) | 0;
        iResize(xres, yres);
    };

    if(!window.ResizeObserver)
    {
        console.log("WARNING: This browser doesn't support ResizeObserver.");
        bestAttemptFallback();
        window.addEventListener("resize", bestAttemptFallback);
    }
    else
    {
        this.mRO = new ResizeObserver( function(entries, observer)
        {
            var entry = entries[0];
            if (!entry['devicePixelContentBoxSize'])
            {
                observer.unobserve(me.mCanvas);
                console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (2)");
                bestAttemptFallback();
                window.addEventListener("resize", bestAttemptFallback);
            }
            else
            {
                let box = entry.devicePixelContentBoxSize[0];
                let xres = box.inlineSize;
                let yres = box.blockSize;
                iResize(xres, yres);
            }
        });
        try
        {
            this.mRO.observe(this.mCanvas, { box: ["device-pixel-content-box"] });
            //this.mRO.observe(this.mCanvas);
        }
        catch (e)
        {
            console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (1)");
            bestAttemptFallback();
            window.addEventListener("resize", bestAttemptFallback);
        }
    }

    this.mCreated = true;
}

Effect.prototype.ResizeCubemapBuffer = function(i, xres, yres )
{
    let oldXres = this.mCubeBuffers[i].mResolution[0];
    let oldYres = this.mCubeBuffers[i].mResolution[1];

    if( this.mCubeBuffers[i].mTexture[0]===null || oldXres !== xres || oldYres !== yres )
    {
        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);
        let target1 = this.mRenderer.CreateRenderTargetCubeMap( texture1, null, false);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target2 = this.mRenderer.CreateRenderTargetCubeMap( texture2, null, false);

        // Store new buffers
        this.mCubeBuffers[i].mTexture = [texture1,texture2], 
        this.mCubeBuffers[i].mTarget =  [target1, target2 ], 
        this.mCubeBuffers[i].mLastRenderDone = 0;
        this.mCubeBuffers[i].mResolution[0] = xres;
        this.mCubeBuffers[i].mResolution[1] = yres;
    }
}

Effect.prototype.ResizeBuffer = function( i, xres, yres, skipIfNotExists )
{
    if( skipIfNotExists && this.mBuffers[i].mTexture[0]===null ) return;

    let oldXres = this.mBuffers[i].mResolution[0];
    let oldYres = this.mBuffers[i].mResolution[1];

    if( oldXres !== xres || oldYres !== yres )
    {
        let needCopy = (this.mBuffers[i].mTexture[0]!==null);

        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[0].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[0].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[1].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[1].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target1 = this.mRenderer.CreateRenderTarget( texture1, null, null, null, null, false);
        let target2 = this.mRenderer.CreateRenderTarget( texture2, null, null, null, null, false);

        if( needCopy )
        {
            let v = [0, 0, Math.min(xres, oldXres), Math.min(yres, oldYres)];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            let vOld = [0, 0, oldXres, oldYres];
            this.mRenderer.SetShaderConstant4FV("v", vOld);

            // Copy old buffers 1 to new buffer
            this.mRenderer.SetRenderTarget(target1);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[0], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Copy old buffers 2 to new buffer
            this.mRenderer.SetRenderTarget(target2);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[1], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Deallocate old memory
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[0]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[0]);
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[1]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[1]);
            //this.mRenderer.DestroyTexture(this.mBuffers[i].thumbnailTexture);
        }

        // Store new buffers
        this.mBuffers[i].mTexture = [texture1,texture2], 
        this.mBuffers[i].mTarget =  [target1, target2 ], 
        this.mBuffers[i].mLastRenderDone = 0;
        this.mBuffers[i].mResolution[0] = xres;
        this.mBuffers[i].mResolution[1] = yres;
    }
}

Effect.prototype.saveScreenshot = function(passid)
{
    let pass = this.mPasses[passid];

    if( pass.mType === "buffer" )
    {
        let bufferID = assetID_to_bufferID( this.mPasses[passid].mOutputs[0] );

        let texture = this.mBuffers[bufferID].mTarget[ this.mBuffers[bufferID].mLastRenderDone ];

        let numComponents = 3;
        let width = texture.mTex0.mXres;
        let height = texture.mTex0.mYres;
        let type = "Float"; // Other options Float, Half, Uint
        let bytes = new Float32Array(width * height * 4 );//numComponents);
        this.mRenderer.GetPixelDataRenderTarget( texture, bytes, width, height );
        let blob = piExportToEXR(width, height, numComponents, type, bytes);

        // Offer download automatically to the user
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "cubemap" )
    {
        let xres = 4096;
        let yres = 2048;
        this.mScreenshotSytem.Allocate( xres, yres );

        let cubeBuffer = this.mCubeBuffers[0];

        let target = this.mScreenshotSytem.GetTarget();
        this.mRenderer.SetRenderTarget( target );

        let program = this.mScreenshotSytem.GetProgram();

        this.mRenderer.AttachShader(program);
        let l1 = this.mRenderer.GetAttribLocation(program, "pos");
        this.mRenderer.SetViewport( [0, 0, xres, yres] );
        this.mRenderer.AttachTextures(1, cubeBuffer.mTexture[ cubeBuffer.mLastRenderDone ], null, null, null);
        this.mRenderer.DrawUnitQuad_XY(l1);
        this.mRenderer.DettachTextures();
        this.mRenderer.SetRenderTarget( null );

        let data = new Float32Array(xres*yres*4);
        this.mRenderer.GetPixelDataRenderTarget( target, data, xres, yres );

        let blob = piExportToEXR(xres, yres, 3, "Float", data );
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "sound" )
    {
        let offset = 0;
        const bits = 16;
        const numChannels = 2;
        let words = new Int16Array(60*pass.mSampleRate*numChannels );

        pass.iRenderSound( new Date(), function(off, data, numSamples)
                                         {
                                            for( let i=0; i<numSamples; i++ )
                                            {
                                                words[offset++] = (data[4*i+0]+256.0*data[4*i+1]) - 32767;
                                                words[offset++] = (data[4*i+2]+256.0*data[4*i+3]) - 32767;
                                            }
                                         }
                                     );

        let blob = piExportToWAV( 60*pass.mSampleRate, pass.mSampleRate, bits, numChannels, words);

        piTriggerDownload("sound.wav", blob);
    }    
}

Effect.prototype.ResizeBuffers = function(xres, yres)
{
    for (let i=0; i<this.mMaxBuffers; i++ )
    {
        this.ResizeBuffer(i, xres, yres, true);
    }
}

Effect.prototype.IsEnabledVR = function ()
{
    if (this.mRenderingStereo) return true;
    return false;
}

Effect.prototype.EnableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( this.mRenderingStereo ) return;

    this.mRenderingStereo = true;
    this.mWebVR.Enable();
}

Effect.prototype.DisableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( !this.mRenderingStereo ) return;

    this.mRenderingStereo = false;
    this.mWebVR.Disable();
}

Effect.prototype.GetTexture = function( passid, slot ) { return this.mPasses[passid].GetTexture( slot ); }
Effect.prototype.NewTexture = function (passid, slot, url) { return this.mPasses[passid].NewTexture( this.mAudioContext, slot, url, this.mBuffers, this.mCubeBuffers, this.mKeyboard ); }
Effect.prototype.SetOutputs = function( passid, slot, url ) { this.mPasses[passid].SetOutputs( slot, url ); }
Effect.prototype.SetOutputsByBufferID = function( passid, slot, id ) { this.mPasses[passid].SetOutputsByBufferID( slot, id ); }
Effect.prototype.GetAcceptsLinear = function (passid, slot) { return this.mPasses[passid].GetAcceptsLinear(slot); }
Effect.prototype.GetAcceptsMipmapping = function (passid, slot) { return this.mPasses[passid].GetAcceptsMipmapping(slot); }
Effect.prototype.GetAcceptsWrapRepeat = function (passid, slot) { return this.mPasses[passid].GetAcceptsWrapRepeat(slot); }
Effect.prototype.GetAcceptsVFlip = function (passid, slot) { return this.mPasses[passid].GetAcceptsVFlip(slot); }
Effect.prototype.SetSamplerFilter = function (passid, slot, str) { this.mPasses[passid].SetSamplerFilter(slot, str, this.mBuffers, this.mCubeBuffers); }
Effect.prototype.GetTranslatedShaderSource = function (passid) { return this.mPasses[passid].GetTranslatedShaderSource(); }
Effect.prototype.GetSamplerFilter = function (passid, slot) { return this.mPasses[passid].GetSamplerFilter(slot); }
Effect.prototype.SetSamplerWrap = function (passid, slot, str) { this.mPasses[passid].SetSamplerWrap(slot, str, this.mBuffers); }
Effect.prototype.GetSamplerWrap = function (passid, slot) { return this.mPasses[passid].GetSamplerWrap(slot); }
Effect.prototype.SetSamplerVFlip = function (passid, slot, str) { this.mPasses[passid].SetSamplerVFlip(slot, str); }
Effect.prototype.GetSamplerVFlip = function (passid, slot) { return this.mPasses[passid].GetSamplerVFlip(slot); }

Effect.prototype.GetHeaderSize = function (passid)
{
    return this.mPasses[passid].mHeaderLength + 
           this.mRenderer.GetShaderHeaderLines(1);
}

Effect.prototype.ToggleVolume = function()
{
    this.mForceMuted = !this.mForceMuted;

    // outp
    if (this.mForceMuted)
        this.mGainNode.gain.value = 0.0;
    else
        this.mGainNode.gain.value = 1.0;

    // inp
    let num = this.mPasses.length;
    for( let j=0; j<num; j++ )
    {
        for( let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            if( this.mForceMuted )
                this.mPasses[j].MuteInput( this.mAudioContext, i );
            else
                this.mPasses[j].UnMuteInput( this.mAudioContext, i );
        }
    }

    return this.mForceMuted;
}

Effect.prototype.SetKeyDown = function( passid, k )
{
    if( this.mKeyboard.mData[ k + 0*256 ] == 255 ) return;

    this.mKeyboard.mData[ k + 0*256 ] = 255;
    this.mKeyboard.mData[ k + 1*256 ] = 255;
    this.mKeyboard.mData[ k + 2*256 ] = 255 - this.mKeyboard.mData[ k + 2*256 ];
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }
}

Effect.prototype.SetKeyUp = function( passid, k )
{
    this.mKeyboard.mData[ k + 0*256 ] = 0;
    this.mKeyboard.mData[ k + 1*256 ] = 0;
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }
}

Effect.prototype.StopOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].StopOutput( wa );
    }
}

Effect.prototype.ResumeOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].ResumeOutput( wa );
    }
}

Effect.prototype.PauseInput = function( passid, id )
{
    return this.mPasses[passid].TooglePauseInput( this.mAudioContext, id );
}

Effect.prototype.ToggleMuteInput = function( passid, id )
{
    return this.mPasses[passid].ToggleMuteInput( this.mAudioContext, id );
}

Effect.prototype.RewindInput = function( passid, id )
{
    this.mPasses[passid].RewindInput( this.mAudioContext, id );
}

Effect.prototype.UpdateInputs = function( passid, forceUpdate )
{
   this.mPasses[passid].UpdateInputs( this.mAudioContext, forceUpdate, this.mKeyboard );
}

Effect.prototype.ResetTime = function()
{
    this.mFrame = 0;
    this.mAudioContext.resume()

    let num = this.mPasses.length;
    for( let i=0; i<num; i++ )
    {
        this.mPasses[i].mFrame = 0;
        for( let j=0; j<this.mPasses[i].mInputs.length; j++ )
            this.mPasses[i].RewindInput(this.mAudioContext, j)
    }
}

Effect.prototype.RequestAnimationFrame = function (id)
{
    if (this.mRenderingStereo && this.mWebVR.IsPresenting())
    {
        this.mWebVR.RequestAnimationFrame(id);
    }
    else
    {
        requestAnimFrame(id);
    }
}

Effect.prototype.Paint = function(time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, isPaused)
{
    let wa = this.mAudioContext;
    let da = new Date();
    let vrData = null; if (this.mRenderingStereo) vrData = this.mWebVR.GetData();
    let xres = this.mXres / 1;
    let yres = this.mYres / 1;

    if( this.mFrame===0 )
    {
        for( let i=0; i<this.mMaxBuffers; i++ )
        {
            if( this.mBuffers[i].mTexture[0]!==null )
            {
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[0] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[1] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
				
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[0] );
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[1] );
            }
        }
        for( let i=0; i<this.mMaxCubeBuffers; i++ )
        {
            if( this.mCubeBuffers[i].mTexture[0]!==null )
            {
                for( let face=0; face<6; face++ )
                {
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[0], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[1], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
					this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[0] );
				    this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[1] );
                }
            }
        }
    }

    let num = this.mPasses.length;

    // render sound first
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "sound" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "buffer" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;
        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="buffer" && inp.id === bufferID && inp.mInfo.mSampler.filter === "mipmap")
                {
                    needMipMaps = true;
                    break;
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render cubemap buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "cubemap" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = 0;//assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;

        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="cubemap" )
                {
                    if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0 && inp.mInfo.mSampler.filter === "mipmap" )
                    {
                        needMipMaps = true;
                        break;
                    }
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render image last
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "image" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }   

    // erase keypresses
    for (let k=0; k<256; k++ )
    {
       this.mKeyboard.mData[ k + 1*256 ] = 0;
    }
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    if( this.mRenderingStereo ) this.mWebVR.Finish();

    this.mFrame++;
}

Effect.prototype.NewShader = function( passid, preventCache, onResolve )
{
    let commonSourceCodes = [];
    for (let i=0; i<this.mPasses.length; i++ )
    {
        if( this.mPasses[i].mType==="common")
        {
            commonSourceCodes.push(this.mPasses[i].mSource);
        }
    }

    this.mPasses[passid].NewShader(commonSourceCodes, preventCache, onResolve );
}

Effect.prototype.GetNumPasses = function()
{
    return this.mPasses.length;
}

Effect.prototype.GetNumOfType = function(passtype)
{
    let id = 0;
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType===passtype )
        {
            id++;
        }
    }
    return id;
}

Effect.prototype.GetPassType = function( id ) { return this.mPasses[id].mType; }
Effect.prototype.GetPassName = function( id ) { return this.mPasses[id].mName; }
Effect.prototype.GetCode = function( id ) { return this.mPasses[id].mSource; }
Effect.prototype.SetCode = function( id, source ) { this.mPasses[id].SetCode(source); }
Effect.prototype.GetError = function (id) { return this.mPasses[id].mError; }
Effect.prototype.GetErrorStr = function (id) { return this.mPasses[id].mErrorStr; }
Effect.prototype.GetErrorGlobal = function()
{
    for (let i = 0; i < this.mPasses.length; i++)
    {
        if (this.mPasses[i].mError)
        {
            return true;
        }
    }
    return false;
}

Effect.prototype.Load = function (jobj )
{
    if (jobj.ver !== "0.1")
    {
        console.log("Wrong Format");
        return false;
    }

    let numPasses = jobj.renderpass.length;

    if( numPasses<1 || numPasses>this.mMaxPasses )
    {
        console.log("Corrupted Shader - " + numPasses);
        return false;
    }

    this.mPasses = [];
    for (let j = 0; j < numPasses; j++)
    {
        let rpass = jobj.renderpass[j];

        // skip sound passes if in thumbnail mode
        if( this.mForceMuted && rpass.type === "sound" ) continue;

        let wpass = new EffectPass(this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                   this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode,
                                   this.mProgramDownscale, j, this);

        wpass.Create(rpass.type, this.mAudioContext);

        let numInputs = rpass.inputs.length;

        for (let i = 0; i < 4; i++)
        {
            wpass.NewTexture(this.mAudioContext, i, null, null, null);
        }
        for (let i = 0; i < numInputs; i++)
        {
            let lid  = rpass.inputs[i].channel;
            let styp = rpass.inputs[i].type;
            let sid  = rpass.inputs[i].id;
            let ssrc = rpass.inputs[i].filepath;
            let psrc = rpass.inputs[i].previewfilepath;
            let samp = rpass.inputs[i].sampler;

            wpass.NewTexture(this.mAudioContext, lid, { mType: styp, mID: sid, mSrc: ssrc, mSampler: samp, mPreviewSrc: psrc }, this.mBuffers, this.mCubeBuffers, this.mKeyboard);
        }

        for (let i = 0; i < 4; i++)
        {
            wpass.SetOutputs(i, null);
        }

        let numOutputs = rpass.outputs.length;
        for (let i = 0; i < numOutputs; i++)
        {
            let outputID = rpass.outputs[i].id;
            let outputCH = rpass.outputs[i].channel;
            wpass.SetOutputs(outputCH, outputID);
        }

        // create some hardcoded names. This should come from the DB
        let rpassName = "";
        if (rpass.type === "common" ) rpassName = "Common";
        if (rpass.type === "sound"  ) rpassName = "Sound";
        if (rpass.type === "image"  ) rpassName = "Image";
        if (rpass.type === "buffer") rpassName = "Buffer " + String.fromCharCode(65 + assetID_to_bufferID(wpass.mOutputs[0]));
        if (rpass.type === "cubemap") rpassName = "Cube A";// " + String.fromCharCode(65 + assetID_to_bufferID(this.mPasses[j].mOutputs[0]));
        wpass.SetName(rpassName);
        wpass.SetCode(rpass.code);

        this.mPasses.push(wpass);
    }
    return true;
}

Effect.prototype.CompileSome = function ( passes, preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    for (let j = 0; j < passes.length; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(passes[j], preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < me.mPasses.length; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.Compile = function (preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(j, preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < numPasses; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.GetCompilationTime = function( id )
{
    return this.mPasses[id].GetCompilationTime()/1000.0;
}
Effect.prototype.GetTotalCompilationTime = function()
{
    return this.mCompilationTime/1000.0;
}

Effect.prototype.DestroyPass = function( id )
{
   this.mPasses[id].Destroy( this.mAudioContext );
   this.mPasses.splice(id, 1);
}

Effect.prototype.AddPass = function( passType, passName, onResolve )
{
    let shaderStr = null;

    if( passType==="sound"   ) shaderStr = "vec2 mainSound( int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n}";
    if( passType==="buffer"  ) shaderStr = "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}";
    if( passType==="common"  ) shaderStr = "vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}";
    if( passType==="cubemap" ) shaderStr = "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rayDir;\n\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}";

    let id = this.GetNumPasses();
    this.mPasses[id] = new EffectPass( this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                       this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode, 
                                       this.mProgramDownscale, id, this );

    this.mPasses[id].Create( passType, this.mAudioContext );
    this.mPasses[id].SetName( passName );
    this.mPasses[id].SetCode( shaderStr );
    this.NewShader(id, false, function ()
    {
        onResolve();
    });

    return { mId : id, mShader : shaderStr };
}

// this should be removed once we have MultiPass 2.0 and passes render to arbitrary buffers
Effect.prototype.IsBufferPassUsed = function( bufferID )
{
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType !== "buffer" ) continue;
        if( this.mPasses[j].mOutputs[0] === bufferID_to_assetID(bufferID) ) return true;
    }
    return false;
}

Effect.prototype.Save = function()
{
    var result = {};

    result.ver = "0.1";

    result.renderpass = [];

    let numPasses = this.mPasses.length;
    for (let j=0; j<numPasses; j++ )
    {
        result.renderpass[j] = {};

        result.renderpass[j].outputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            let outputID = this.mPasses[j].mOutputs[i];
            if( outputID===null ) continue;
            result.renderpass[j].outputs.push( { channel: i, id: outputID } );
        }
        result.renderpass[j].inputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            if( this.mPasses[j].mInputs[i]===null ) continue;
            result.renderpass[j].inputs.push( {channel: i,
                                               type    : this.mPasses[j].mInputs[i].mInfo.mType,
                                               id      : this.mPasses[j].mInputs[i].mInfo.mID,
                                               filepath: this.mPasses[j].mInputs[i].mInfo.mSrc,
                                               sampler : this.mPasses[j].mInputs[i].mInfo.mSampler });
        }

        result.renderpass[j].code = this.mPasses[j].mSource;
        result.renderpass[j].name = this.mPasses[j].mName
        result.renderpass[j].description = "";
        result.renderpass[j].type = this.mPasses[j].mType;
    }

    result.flags = this.calcFlags();

    return result;
}

Effect.prototype.calcFlags = function ()
{
    let flagVR = false;
    let flagWebcam = false;
    let flagSoundInput = false;
    let flagSoundOutput = false;
    let flagKeyboard = false;
    let flagMultipass = false;
    let flagMusicStream = false;

    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        let pass = this.mPasses[j];

        if (pass.mType === "sound") flagSoundOutput = true;
        if (pass.mType === "buffer") flagMultipass = true;

        for (let i = 0; i < 4; i++)
        {
            if (pass.mInputs[i] === null) continue;

            if (pass.mInputs[i].mInfo.mType === "webcam") flagWebcam = true;
            else if (pass.mInputs[i].mInfo.mType === "keyboard") flagKeyboard = true;
            else if (pass.mInputs[i].mInfo.mType === "mic") flagSoundInput = true;
            else if (pass.mInputs[i].mInfo.mType === "musicstream") flagMusicStream = true;
        }

        let n1 = pass.mSource.indexOf("mainVR(");
        let n2 = pass.mSource.indexOf("mainVR (");
        if (n1 > 0 || n2 > 0) flagVR = true;
    }

    return {
        mFlagVR: flagVR,
        mFlagWebcam: flagWebcam,
        mFlagSoundInput: flagSoundInput,
        mFlagSoundOutput: flagSoundOutput,
        mFlagKeyboard: flagKeyboard,
        mFlagMultipass: flagMultipass,
        mFlagMusicStream: flagMusicStream
    };
}</script>
    <script>"use strict"

const kMaxCompileTime = 10.0;

function iReportCrash(shaderID)
{
    let req = new XMLHttpRequest();
    req.onload = function ()
    {
        let jsn = req.response;
        if (jsn === null) return;
        if (jsn.result === 0)
        {
            // yep
        }
    };
    req.open("POST", "/shadertoy", true);
    req.responseType = "json";
    req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    req.send( "s=" + shaderID + "&r=2" );
}
</script>
    <script>"use strict"

var gActive = -1;
var mShaders = [];
var gNumCanvases = 0;

function myrefresh( id, slot, img, forceFrame, gui, guiID, renderID, time )
{
    if( mShaders[id].mReady===false ) return;
    if( forceFrame )
    {
        if (mShaders[id].mScreenshot === false)
        {
            mShaders[id].gEffect.Paint(mShaders[id].mTime / 1000.0, 1.0 / 60.0, 60.0, 0, 0, 0, 0, false);
        }
    }
}

function startRendering()
{
    if( gActive<0 ) return;
    if( mShaders[gActive].mReady===false ) return;
    if( mShaders[gActive].mScreenshot===true ) return;

    let time = getRealTime();

    mShaders[gActive].mFPS.Count( time );
    mShaders[gActive].mTime = mShaders[gActive].mTime0 + (time - mShaders[gActive].mTo);
    let dtime = 1000.0/60.0;
    mShaders[gActive].gEffect.Paint( mShaders[gActive].mTime/1000.0, dtime/1000.0, mShaders[gActive].mFPS.GetFPS(), 0,0,0,0, false);

    requestAnimFrame( startRendering );
}

function iLoadAndCompile(jsn, i )
{
    var shaderObj = jsn[i];
    if (shaderObj === null) return;

    var resizeCB = function (xres, yres) { myrefresh(i, 0, null, true, false, 0, -1.0) };
    var crashCB = function () { alert('crash');/*iReportCrash(gShaderIDs[i])*/ };
    mShaders[i].gEffect = new Effect(null, null, mShaders[i].mPreview.mCanvas, myrefresh, i, true, true, resizeCB, crashCB);

    if (!mShaders[i].gEffect.Load(shaderObj)) return;

    mShaders[i].gEffect.Compile(false, function (worked)
    {
        if (worked === true)
        {
            previewShowRender(mShaders[i].mPreview);

            mShaders[i].mScreenshot = false;
            mShaders[i].mReady = true;
            mShaders[i].mTime = 10.0 * 1000.0;
            mShaders[i].mTime0 = 0.0;
            mShaders[i].mTo = 0.0;
            mShaders[i].mFPS = piCreateFPSCounter();
            mShaders[i].mPreview.mCanvas.addEventListener("mouseout", function (ev) { gActive = -1; }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseover", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.add('isVisible'); }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseout", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.remove('isVisible'); }, true);
            mShaders[i].mPreview.mCanvas.addEventListener("mouseover", function (ev)
            {
                let ele = piGetSourceElement(ev);
                if (ele.mId === undefined) return;

                gActive = ele.mId;
                if (!mShaders[gActive].mReady) return;
                let time = getRealTime();
                mShaders[gActive].mTo = time;
                mShaders[gActive].mTime0 = mShaders[gActive].mTime;
                mShaders[gActive].mFPS.Reset(time);

                startRendering();
            }, true);


            /*
            let compilationTime = mShaders[i].gEffect.GetTotalCompilationTime();
            if (compilationTime > kMaxCompileTime)
            {
                iReportCrash(mShaders[i].mShaderID);
            }*/

            myrefresh(i, null, null, true, false, 0, -1.0);
        }
        else
        {
            mShaders[i].mReady = false;
            previewShowError(mShaders[i].mPreview);
        }
    });
};


function iProcessShader( jsn, i )
{
    var shaderObj = jsn[i];
    if( shaderObj===null ) return;

    if ((shaderObj.info.usePreview === 0 && !gUseScreenshots) || (mShaders[i].mPreviewReady !== 1))
    {
        iLoadAndCompile(jsn, i);
    }
    else
    {
        mShaders[i].mScreenshot = true;
        if( shaderObj.info.usePreview === 1 )
            previewShowScreenshot(mShaders[i].mPreview, 1); // comp
        else if (gUseScreenshots)
            previewShowScreenshot(mShaders[i].mPreview, 2); // sett
    }

    if( i<(jsn.length-1) ) setTimeout( function(){iProcessShader(jsn,i+1);}, 10 );
}

function iInitUI(numCanvases, uiCallback, windowTitle)
{
    gNumCanvases = numCanvases;
    document.getElementById("mySearch").focus();

    //-----------------------------------------------------------------
    // window
    //-----------------------------------------------------------------
    if (windowTitle !== null) {
        document.title = windowTitle;
    }

    //-----------------------------------------------------------------
    // ui
    //-----------------------------------------------------------------
    var num = Math.min(gShaders.length, gNumCanvases);

    //var base = document.getElementsByClassName( "searchResult" );

    for (let i = 0; i < gNumCanvases; i++)
    {
        let pv = createPreview(i);

        if (i >= num) {
            previewHide(pv);
            continue;
        }

        let shaderID = gShaders[i].info.id;
        
        if (pv.mUI !== null && uiCallback !== null) {
            pv.mUI.addEventListener('click', function (ev) {
                uiCallback(shaderID);
                ev.preventDefault();
            }, false);
        }
        
        previewShowLoading(pv);
        
        mShaders[i] = {};
        mShaders[i].mShaderID = shaderID;
        mShaders[i].mPreview = pv;
        mShaders[i].mScreenshot = false;
        mShaders[i].mPreview.mLink.href = "/view/" + shaderID;
        mShaders[i].mPreviewReady = 0;
        mShaders[i].mReady = false;
        mShaders[i].gEffect = null;

        previewLoadScreenshot(mShaders[i].mPreview,
            function () { mShaders[i].mPreviewReady = 1; if (mShaders[i].mReady === false) previewShowScreenshot(mShaders[i].mPreview, 0); },
            function () { mShaders[i].mPreviewReady = 2; },
            shaderID);
    }

    if (num <= 0) {
        return;
    }
}

function iInitShaders(jsn)
{
    for (let i = 0; i < jsn.length; i++)
    {
        let shaderObj = jsn[i];
        if (shaderObj === null) continue;
        let inf = shaderObj.info;
        mShaders[i].mPreview.mTextA.textContent = inf.name;
        mShaders[i].mPreview.mTextB.innerHTML = "<a class='user' href='/user/" + htmlEntities(inf.username) + "'>" + htmlEntities(inf.username) + "</a>";
        mShaders[i].mPreview.mTextC.innerHTML = "<img src='/img/themes/" + gThemeName + "/views.png' class='viewsIcon'></img>" + inf.viewed + "    &nbsp;&nbsp;  <img src='/img/themes/" + gThemeName + "/likes.png' class='likesIcon'></img>" + inf.likes;
    }

    setTimeout(function () { iProcessShader(jsn, 0); }, 10);
}

function resultsInitStatic(numCanvases, uiCallback, windowTitle)
{
    iInitUI(numCanvases, uiCallback, windowTitle);

    iInitShaders(gShaders);
}

function resultsInit(numCanvases, uiCallback, windowTitle)
{	
    iInitUI(numCanvases, uiCallback, windowTitle);

    var num = Math.min(gShaderIDs.length, gNumCanvases);

    var mHttpReq = new XMLHttpRequest();

    mHttpReq.abort();

    var str = "{ \"shaders\" : [";
    for( let i=0; i<num; i++ )
    {
         str += "\"" + gShaderIDs[i] + "\"";
         if( i!==(num-1) ) str += ", ";
    }
    str += "] }";

    str = "s=" + encodeURIComponent( str ) + "&nt=0&nl=0&np=0";

    mHttpReq.open( "POST", "/shadertoy", true );
    mHttpReq.responseType = "json";
    mHttpReq.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    mHttpReq.onload = function ()
    {
        let jsn = this.response;
        if( jsn===null )
        {
            console.log( "Could not load shaders" );
            return;
        }

        iInitShaders(jsn);
    }
    mHttpReq.send( str );
}</script>
    <style>
    .shaderPreview
    {
    display: block;
    background-color: #000000;
    background-image: url("/img/loading.gif");
    background-repeat: no-repeat;
    background-position: center;
    padding: 0px;
    margin: 0px;
    border: 0px solid #000000;
    border-radius: 8px;
    width:100%;
    height:100%;
    position: absolute;
    overflow:hidden;
    }

    .previewInfo
    {
    width: 100%;
    left: 0px;
    top: 2px;
    position: relative;
    visibility: hidden;
    }

    .previewCanvas
    {
    left: 0px;
    top: 0px;
    padding: 0px;
    margin: 0px;
    position: absolute;
    cursor: pointer;
    width:100%;
    height:100%;
    border-radius: 8px;
    border: 0px solid #000000;
    backgroundColor: transparent;
visibility: hidden;
opacity:0;
transition: opacity 1.0s ease;
    }

    .previewText
    {
        text-overflow: ellipsis;
    white-space: nowrap;
    padding-right: 1px;
    }

    .previewTextUser
    {
    text-overflow: ellipsis;
    white-space: nowrap;
    padding-left: 3px;
    }

    .previewStats
    {
    padding-right: 1px;
    right: 0px;
    top: 0px;
    position: absolute;
    }

    .previewErrorContainer
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    visibility:hidden;
    }

    .previewErrorMessage
    {
    top:50%;
    position:absolute;
    width:100%;
    text-align:center;
    padding:0;
    margin:auto;
    color:#ff0000;
    font-size:2em;
    font-style:italic;
    }

    .previewNoGLContainter
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    position:absolute;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    pointer-events:none;
    visibility:hidden;
    font-size:2em;
    }

    .previewNoGLMessage
    {
    width:86%;
    height:90%;
    padding-left:7%;
    padding-right:7%;
    padding-top:10%;
    padding-bottom:0px;
    color:#ff0000;
    position:absolute;
    visibility:hidden;
    }

    .previewThumbnailContainer
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    visibility:hidden;
    border-radius:8px;
    border:0px solid #000000;
    }

    .previewThumbnailImage
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    border-radius:8px;
    border:0px solid #000000;
opacity: 0.0;
transition: opacity 1.0s ease;
    }

    .previewThumbnailIcon
    {
    width:64px;
    height:32px;
    left:0px;
    top:0px;
    padding:0px;
    padding-top:12px;
    margin:0px;
    position:absolute;
    color:#ffffff;
    background-color:#ff8020;
    font-weight:bold;
    border-radius:0px 0px 8px 0px;
    text-align:center;
    //visibility:hidden;
    }


    .previewUIContainter
    {
    display: block;
    right:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    //cursor:pointer;
    //pointer-events:none;
    //visibility:hidden;
    }
</style>

<script>
    function previewHide(me)
    {
    me.mBase.style.visibility = "hidden";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";
    }

    function previewShowRender(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "visible";
me.mCanvas.style.opacity = 1.0;
    me.mCanvas.style.borderRadius ="8px;";
//  me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    }

    function previewShowScreenshot(me, message)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "visible";
me.mThumbnailImg.style.opacity = 1.0;
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    me.mThumbnailWar1.style.visibility = (message===1)?"visible":"hidden";
    me.mThumbnailWar2.style.visibility = (message===2)?"visible":"hidden";
    }

    function previewShowLoading(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";

    me.mLink.style.visibility = "visible";
    me.mBase.style.backgroundColor = "#ff0000;"
    me.mCont.style.visibility = "visible";
    }

    function previewShowNoWebGL(me, shaderID)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "visible";
    me.mError.style.visibility = "visible";
    me.mThumbnailImgNoWebGL.onerror = function(ev) 
                                      { 
                                            me.mThumbnailImgNoWebGL.style.visibility="hidden"; 
                                            me.mMessageNoWebGL.style.visibility="visible"; 
                                      };
    me.mThumbnailImgNoWebGL.src = "/media/shaders/" + shaderID + ".jpg";
    }

    function previewShowError(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "visible";
    me.mCont.style.visibility = "visible";
    }

    function previewLoadScreenshot( me, cbSuccess, cbError, shaderID )
    {
    var url = "/media/shaders/" + shaderID + ".jpg";
    me.mThumbnailImg.onload = cbSuccess;
    me.mThumbnailImg.onerror = function(ev) { cbError(); };
    me.mThumbnailImg.src = url;
    }
        
    function createPreview(id)
    {
        var bar = document.getElementById( "Preview_"+id+"_Canvas" );
        bar.width = bar.offsetWidth;
        bar.height = bar.offsetHeight;
        bar.mId = id;

        return { mBase: document.getElementById( "Preview_"+id+"_Container" ),
        mLink: document.getElementById( "Preview_"+id+"_Link" ),
        mCanvas: bar,
        mCont: document.getElementById( "Preview_"+id+"_Info" ),
        mTextA: document.getElementById( "Preview_"+id+"_Text" ),
        mTextB: document.getElementById( "Preview_"+id+"_TextUser" ),
        mTextC: document.getElementById( "Preview_"+id+"_Stats" ),
        mNoWebGL: document.getElementById( "Preview_"+id+"_NoWebGL" ),
        mError: document.getElementById( "Preview_"+id+"_Error" ),
        mCanvas2D: document.getElementById( "Preview_"+id+"_Thumnail" ),
        mThumbnailImg: document.getElementById( "Preview_"+id+"_ThumnailImage" ),
        mThumbnailWar1: document.getElementById( "Preview_"+id+"_ThumnailWarning1" ),
        mThumbnailWar2: document.getElementById( "Preview_"+id+"_ThumnailWarning2" ),
        mThumbnailImgNoWebGL: document.getElementById( "Preview_"+id+"_ThumnailImageNoWebGL" ),
        mMessageNoWebGL: document.getElementById( "Preview_"+id+"_MessageNoWebGL"),
        mUI: document.getElementById( "Preview_"+id+"_UI" )
        };
    }
</script>

    <style>

    div#shaderGrid
    {
        width:100%;
        padding:0px;
        margin:0px;
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        grid-template-rows: repeat(3, 1fr);
        grid-column-gap: 64px;
        grid-row-gap: 24px;
    }
    .searchResult
    {
        margin: 0px;
        padding: 0px;
        width: 100%;
    }
    .searchResultContainer
    {
        width: 100%;
        padding-bottom:56.25%;
        height: 0;
        position: relative;
    }
    .navigation
    {
        display:flex;
        align-items:center;
    }
    div#navBottom
    {
        display:none;
        justify-content:center;
    }
    a.pageButtons, .pageButtonsCurrent
    {
        border-style: solid;
        border-width: 1px;
        border-color: #808080;
        text-align: center;
        vertical-align: middle;
        margin-left: 12px;
        display: inline-block;
        border-radius: 4px;
		font-weight:bold;
        cursor: pointer;
        padding-bottom:5px;
        padding-top:4px;
        padding-left: 8px;
        padding-right: 8px;
        margin:8px;
    }
    a.pageButtons
    {
        text-decoration: none;
        -moz-transition:    background-color 0.15s linear, color 0.15s linear;
        -webkit-transition: background-color 0.15s linear, color 0.15s linear;
        transition:         background-color 0.15s linear, color 0.15s linear;
    }
    a.pageButtons:hover
    {
      background-color:#808080;
      color : #ff8020;
    }
    .pageButtonsCurrent
    {
        background-color: #808080;
        color:#000000;
    }
    div#controls
    {
        width:100%;
        padding-top:16px;
        padding-bottom:16px;
        display:flex;
        justify-content:space-between; 
        flex-wrap:wrap;
    }
    div#controls > div
    {
        display:inline-flex;
    }
    .controlOptions
    {
        display:inline-block;
    }

    /* ----------------------- media resolutions ------------------------ */

    @media screen and (max-width:799px) 
    {
        div#shaderGrid  { grid-template-columns: 1fr; grid-template-rows: repeat(12, 1fr); grid-column-gap: 0px; grid-row-gap: 16px; }
        div#controls
        {
            width:100%;
            display:flex;
            justify-content:flex-start; 
            flex-wrap:wrap;
        }
        div#controls > div
        {
            display:inline-flex;
            width:100%;
            margin-left: 0px;
            margin-right: 0px;
            padding-bottom:16px;
        }
        div#navBottom
        {
            display: flex;
        }
    }
    
    </style>
    <script>
    var gShaders=[{"ver":"0.1","info":{"id":"4s2yW1","date":"1492029808","viewed":11297,"name":"Bokeh Paralax","username":"knarkowicz","description":"Feeling artsy","likes":181,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float MATH_PI\t= float( 3.14159265359 );\n\nvoid Rotate( inout vec2 p, float a ) \n{\n\tp = cos( a ) * p + sin( a ) * vec2( p.y, -p.x );\n}\n\nfloat Circle( vec2 p, float r )\n{\n    return ( length( p \/ r ) - 1.0 ) * r;\n}\n\nfloat Rand( vec2 c )\n{\n\treturn fract( sin( dot( c.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\n}\n\nfloat saturate( float x )\n{\n\treturn clamp( x, 0.0, 1.0 );\n}\n\nvoid BokehLayer( inout vec3 color, vec2 p, vec3 c )   \n{\n    float wrap = 450.0;    \n    if ( mod( floor( p.y \/ wrap + 0.5 ), 2.0 ) == 0.0 )\n    {\n        p.x += wrap * 0.5;\n    }    \n    \n    vec2 p2 = mod( p + 0.5 * wrap, wrap ) - 0.5 * wrap;\n    vec2 cell = floor( p \/ wrap + 0.5 );\n    float cellR = Rand( cell );\n        \n    c *= fract( cellR * 3.33 + 3.33 );    \n    float radius = mix( 30.0, 70.0, fract( cellR * 7.77 + 7.77 ) );\n    p2.x *= mix( 0.9, 1.1, fract( cellR * 11.13 + 11.13 ) );\n    p2.y *= mix( 0.9, 1.1, fract( cellR * 17.17 + 17.17 ) );\n    \n    float sdf = Circle( p2, radius );\n    float circle = 1.0 - smoothstep( 0.0, 1.0, sdf * 0.04 );\n    float glow\t = exp( -sdf * 0.025 ) * 0.3 * ( 1.0 - circle );\n    color += c * ( circle + glow );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n\tvec2 p = ( 2.0 * fragCoord - iResolution.xy ) \/ iResolution.x * 1000.0;\n    \n    \/\/ background\n\tvec3 color = mix( vec3( 0.3, 0.1, 0.3 ), vec3( 0.1, 0.4, 0.5 ), dot( uv, vec2( 0.2, 0.7 ) ) );\n\n    float time = iTime - 15.0;\n    \n    Rotate( p, 0.2 + time * 0.03 );\n    BokehLayer( color, p + vec2( -50.0 * time +  0.0, 0.0  ), 3.0 * vec3( 0.4, 0.1, 0.2 ) );\n\tRotate( p, 0.3 - time * 0.05 );\n    BokehLayer( color, p + vec2( -70.0 * time + 33.0, -33.0 ), 3.5 * vec3( 0.6, 0.4, 0.2 ) );\n\tRotate( p, 0.5 + time * 0.07 );\n    BokehLayer( color, p + vec2( -60.0 * time + 55.0, 55.0 ), 3.0 * vec3( 0.4, 0.3, 0.2 ) );\n    Rotate( p, 0.9 - time * 0.03 );\n    BokehLayer( color, p + vec2( -25.0 * time + 77.0, 77.0 ), 3.0 * vec3( 0.4, 0.2, 0.1 ) );    \n    Rotate( p, 0.0 + time * 0.05 );\n    BokehLayer( color, p + vec2( -15.0 * time + 99.0, 99.0 ), 3.0 * vec3( 0.2, 0.0, 0.4 ) );     \n\n\tfragColor = vec4( color, 1.0 );\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"ldj3Wh","date":"1387452122","viewed":11291,"name":"Quadratic Bezier - distance","username":"iq","description":"Intersecting quadratic Bezier segments in 3D. Used Microsoft's paper as pointed out by tayholliday in https:\/\/www.shadertoy.com\/view\/XsX3zf. Since 3D quadratic Bezier segments are planar, the 2D version can be used to compute the distance to 3D curves.","likes":115,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"\/media\/a\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"\/media\/ap\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ The MIT License\n\/\/ Copyright \u00a9 2013 Inigo Quilez\n\/\/ Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\/\/ Intersecting quadratic Bezier segments in 3D. Used Microsoft's paper as\n\/\/ pointed out by tayholliday in https:\/\/www.shadertoy.com\/view\/XsX3zf. Since\n\/\/ 3D quadratic Bezier segments are planar, the 2D version can be used to compute\n\/\/ the distance to the 3D curve.\n\n\/\/ Related Shaders:\n\/\/     Cubic     Bezier - 2D BBox : https:\/\/www.shadertoy.com\/view\/XdVBWd \n\/\/     Cubic     Bezier - 3D BBox : https:\/\/www.shadertoy.com\/view\/MdKBWt\n\/\/     Quadratic Bezier - 2D BBox : https:\/\/www.shadertoy.com\/view\/lsyfWc\n\/\/     Quadratic Bezier - 3D BBox : https:\/\/www.shadertoy.com\/view\/tsBfRD\n\n\/\/ List of other 3D SDFs: https:\/\/www.shadertoy.com\/playlist\/43cXRl\n\/\/\n\/\/ and https:\/\/iquilezles.org\/articles\/distfunctions\n\n\t\n#define AA 1\n\n\/\/ method 0 : approximate http:\/\/research.microsoft.com\/en-us\/um\/people\/hoppe\/ravg.pdf\n\/\/ method 1 : exact       https:\/\/www.shadertoy.com\/view\/ltXSDB\n#define METHOD 1\n\n\/\/ uv=0 : do not compute V, just U\n\/\/ uv=1 : comptue U and V\n#define COMPUTE_UV 1\n\n\/\/ texture 0: checkers\n\/\/ texture 1: organic\n#define TEXTURE 0\n\n\n\n\/\/-----------------------------------------------------------------------------------\n\n\/\/ b(t) = (1-t)^2*A + 2(1-t)t*B + t^2*C\nvec3 bezier( vec3 A, vec3 B, vec3 C, float t )\n{\n    return (1.0-t)*(1.0-t)*A + 2.0*(1.0-t)*t*B + t*t*C;\n}\n\/\/ b'(t) = 2(t-1)*A + 2(1-2t)*B + 2t*C\nvec3 bezier_dx( vec3 A, vec3 B, vec3 C, float t )\n{\n    return 2.0*(t-1.0)*A + 2.0*(1.0-2.0*t)*B + 2.0*t*C;\n}\n\/\/ b\"(t) = 2*A - 4*B + 2*C\nvec3 bezier_dx_dx( vec3 A, vec3 B, vec3 C, float t )\n{\n    return 2.0*A - 4.0*B + 2.0*C;\n}\n\n#if METHOD==1\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nvec2 sdBezier(vec3 pos, vec3 A, vec3 B, vec3 C)\n{    \n    vec3 a = B - A;\n    vec3 b = A - 2.0*B + C;\n    vec3 c = a * 2.0;\n    vec3 d = A - pos;\n\n    float kk = 1.0 \/ dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) \/ 3.0;\n    float kz = kk * dot(d,a);      \n\n    vec2 res;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float q2 = q*q;\n    float h = q2 + 4.0*p3;\n\n    if(h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) \/ 2.0;\n        \n        #if 1\n        \/\/ When p\u22480 and p<0, h-q has catastrophic cancelation. So, we do\n        \/\/ h=\u221a(q\u00b2+4p\u00b3)=q\u00b7\u221a(1+4p\u00b3\/q\u00b2)=q\u00b7\u221a(1+w) instead. Now we approximate\n        \/\/ \u221a by a linear Taylor expansion into h\u2248q(1+\u00bdw) so that the q's\n        \/\/ cancel each other in h-q. Expanding and simplifying further we\n        \/\/ get x=vec2(p\u00b3\/q,-p\u00b3\/q-q). And using a second degree Taylor\n        \/\/ expansion instead: x=vec2(k,-k-q) with k=(1-p\u00b3\/q\u00b2)\u00b7p\u00b3\/q\n        if( abs(p)<0.001 )\n        {\n          \/\/float k = p3\/q;              \/\/ linear approx\n            float k = (1.0-p3\/q2)*p3\/q;  \/\/ quadratic approx \n            x = vec2(k,-k-q);  \n        }\n        #endif\n        \n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0\/3.0));\n        float t = clamp(uv.x+uv.y-kx, 0.0, 1.0);\n\n        \/\/ 1 root\n        res = vec2(dot2(d+(c+b*t)*t),t);\n        \n        \/\/res = vec2( dot2( pos-bezier(A,B,C,t)), t );\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q\/(p*z*2.0) ) \/ 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0);\n        \n        \/\/ 3 roots, but only need two\n        float dis = dot2(d+(c+b*t.x)*t.x);\n        res = vec2(dis,t.x);\n\n        dis = dot2(d+(c+b*t.y)*t.y);\n        if( dis<res.x ) res = vec2(dis,t.y );\n    }\n    \n    res.x = sqrt(res.x);\n    return res;\n}\n\n#endif\n\n#if METHOD==0\n\n    #if 1\n    \/\/ http:\/\/research.microsoft.com\/en-us\/um\/people\/hoppe\/ravg.pdf\n    \/\/ { dist, t, y (above the plane of the curve, x (away from curve in the plane of the curve))\n\tfloat det( vec2 a, vec2 b ) { return a.x*b.y - a.y*b.x; }\n    vec2 sdBezier( vec3 p, vec3 va, vec3 vb, vec3 vc )\n    {\n      vec3 w = normalize( cross( vc-vb, va-vb ) );\n      vec3 u = normalize( vc-vb );\n      vec3 v =          ( cross( w, u ) );\n\n      vec2 m = vec2( dot(va-vb,u), dot(va-vb,v) );\n      vec2 n = vec2( dot(vc-vb,u), dot(vc-vb,v) );\n      vec3 q = vec3( dot( p-vb,u), dot( p-vb,v), dot(p-vb,w) );\n            \n      float mq = det(m,q.xy);\n      float nq = det(n,q.xy);\n      float mn = det(m,n);\n      float k1 = mq + nq;\n        \n      vec2  g = (k1+mn)*n + (k1-mn)*m;\n    \/\/float f = -4.0*mq*nq - (mn-mq+nq)*(mn-mq+nq);\n      float f = -(mn*mn + 2.0*mn*(nq-mq)) - k1*k1;\n      vec2  z = 0.5*f*vec2(g.y,-g.x)\/dot(g,g);\n    \/\/float t = clamp( 0.5 + 0.5*det(z-q.xy,m+n)\/mn, 0.0 ,1.0 );\n      float t = clamp( 0.5 + 0.5*(det(z,m+n)+k1)\/mn, 0.0 ,1.0 );\n        \n      vec2 cp = m*(1.0-t)*(1.0-t) + n*t*t - q.xy;\n      return vec2(sqrt(dot(cp,cp)+q.z*q.z), t );\n    }\n    #else\n    \/\/ my adaptation to 3d of http:\/\/research.microsoft.com\/en-us\/um\/people\/hoppe\/ravg.pdf\n    \/\/ { dist, t, y (above the plane of the curve, x (away from curve in the plane of the curve))\n    vec2 sdBezier( vec3 p, vec3 b0, vec3 b1, vec3 b2 )\n    {\n        b0 -= p;\n        b1 -= p;\n        b2 -= p;\n       \n        vec3 b01 = cross(b0,b1);\n        vec3 b12 = cross(b1,b2);\n        vec3 b20 = cross(b2,b0);\n        \n        vec3 n =  b01+b12+b20;\n        \n        float a = -dot(b20,n);\n        float b = -dot(b01,n);\n        float d = -dot(b12,n);\n\n        float m = -dot(n,n);\n        \n      \/\/vec3  g = b*(b2-b1) + d*(b1-b0) + a*(b2-b0)*0.5;\n        vec3  g =  (d-b)*b1 + (b+a*0.5)*b2 + (-d-a*0.5)*b0;\n        float f = a*a*0.25-b*d;\n        vec3  k = b0-2.0*b1+b2;\n        float t = clamp((a*0.5+b-0.5*f*dot(g,k)\/dot(g,g))\/m, 0.0, 1.0 );\n        \n        return vec2(length(mix(mix(b0,b1,t), mix(b1,b2,t),t)),t);\n    }\n    #endif\n \n#endif\n\n\/\/-----------------------------------------------------------------------------------\n\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+7.3,n+13.7))*1313.54531); }\n\nvec3 noise3( in float x )\n{\n    float p = floor(x);\n    float f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return mix( hash3(p+0.0), hash3(p+1.0), f );\n}\n\n\/\/-----------------------------------------------------------------------------------\n\nvec3 map( vec3 p )\n{\n    vec3 a = vec3(0.0,-1.0,0.0);\n    vec3 b = vec3(0.0, 0.0,0.0);\n    vec3 c = vec3(0.0, 0.5,-0.5);\n\tfloat hm = 0.0;\n\tfloat id = 0.0;\n    float am = 0.0;\n    \n    float dm = length(p-a);\n    \n    vec3 pb = vec3(1.0,0.0,0.0);\n    float off = 0.0;\n    for( int i=0; i<8; i++ )\n\t{\t\n        \/\/vec3 bboxMi = min(a,min(b,c))-0.3;\n    \t\/\/vec3 bboxMa = max(a,max(b,c))+0.3;\n        \n        vec2 h = sdBezier( p, a, b, c );\n        float kh = (float(i) + h.y)\/8.0;\n\n\n        #if COMPUTE_UV==1\n            vec3 bb = normalize(cross(b-a,c-a));\n            vec3 qq = bezier(a,b,c,h.y);\n            vec3 tq = normalize(bezier_dx(a,b,c,h.y));\n            vec3 nq = normalize(cross(bb,tq));\n            vec2 uv = vec2(dot(p-qq,nq),dot(p-qq,bb));\n            float ad = acos( dot(pb,bb) );\n            if( i==3 ) ad = -ad; \/\/ hack\n            off += ad;\n            float ka = atan(uv.y,uv.x) - off;\n            pb = bb;\n        #else\n            float ka = 0.0;\n        #endif\n        \n        \/\/ thickness\n        float ra = 0.3 - 0.28*kh + 0.3*exp(-15.0*kh);\n        float d = h.x - ra; \/\/ not accurate sdf, should use a cone better\n        if( d<dm ) { dm=d; hm=kh; am = ka;}\n\t\t\n        \/\/ grow next segment\n        vec3 na = c;\n\t\tvec3 nb = c + (c-b);\n\t\tvec3 dir = normalize(-1.0+2.0*hash3( id+13.0 ));\n\t\tvec3 nc = nb + 1.0*dir*sign(-dot(c-b,dir));\n\t\tid += 3.71;\n\t\ta = na;\n\t\tb = nb;\n\t\tc = nc;\n\t}\n\n\treturn vec3( dm*0.5, hm, am );\n}\n\nfloat map2( in vec3 pos )\n{\n    return min( pos.y+1.0, map(pos).x );\n}\n\nvec4 intersect( in vec3 ro, in vec3 rd )\n{\n    vec4 res = vec4( -1.0 );\n\n    float maxd = 12.0;\n    \n    \/\/ plane\n    float tp = (-1.0-ro.y)\/rd.y;\n    if( tp>0.0 )\n    {\n        vec3 pos = ro + rd*tp;\n        res = vec4( tp, 0.025*length(pos.xz), 0.0, 0.0 );\n        maxd = tp;\n    }\n\n    \/\/ tentacle\n\tconst float precis = 0.001;\n    float t = 2.0;\n\tfloat l = 0.0;\n    float m = 0.0;\n    for( int i=0; i<128; i++ )\n    {\n\t    vec3 h = map( ro+rd*t );\n        if( h.x<precis || t>maxd ) break;\n        t += h.x;\n\t\tl = h.y;\n        m = h.z;\n    }\n    if( t<maxd ) res = vec4( t, l, 1.0, m );\n\n    return res;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.002,0.0,0.0);\n\n    float f = map(pos).x;\n\treturn normalize( vec3(\n           map(pos+eps.xyy).x - f,\n           map(pos+eps.yxy).x - f,\n           map(pos+eps.yyx).x - f ) );\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/rmshadows\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n\tfloat h = 1.0;\n    for( int i=0; i<32; i++ )\n    {\n        h = map(ro + rd*t).x;\n        res = min( res, k*h\/t );\n\t\tt += clamp( h, 0.02, 2.0 );\n        if( res<0.0001 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<8; i++ )\n    {\n        float h = 0.02 + 0.5*float(i)\/7.0;\n        float d = map2( pos + h*nor );\n        occ += max(h-d,0.0)*sca;\n        sca *= 0.9;\n    }\n    return clamp( 1.5 - occ, 0.0, 1.0 );\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/filterableprocedurals\nfloat gridTexture( in vec2 p, vec2 w )\n{\n    \n    vec2 i = (abs(fract((p-0.5*w)*0.5)-0.5)-\n                  abs(fract((p+0.5*w)*0.5)-0.5))\/w;\n    return 0.5 - 2.0*i.x*i.y;  \n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/filterableprocedurals\nfloat gridTexture( in float p, in float dpdx, in float dpdy )\n{\n    float w =  0.01 + max(abs(dpdx),abs(dpdy));\n    float i = (abs(fract((p-0.5*w)*0.5)-0.5)-\n               abs(fract((p+0.5*w)*0.5)-0.5))\/w;\n    return 0.5 - 2.0*i;  \n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/filteringrm\nvoid calcPxy( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy, in float t, in vec3 nor, out vec3 dpdx, out vec3 dpdy )\n{\n    dpdx = ro + t*rdx*dot(rd,nor)\/dot(rdx,nor);\n    dpdy = ro + t*rdy*dot(rd,nor)\/dot(rdy,nor);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        \/\/ pixel coordinates\n        vec2 o = vec2(float(m),float(n)) \/ float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)\/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)\/iResolution.y;\n#endif\n\n        \/\/-----------------------------------------------------\n        \/\/ camera\n        \/\/-----------------------------------------------------\n\n        float an = 1.0 - 0.15*iTime;\n\n        vec3 ro = vec3(1.0+6.0*sin(an),1.0,5.0*cos(an));\n        vec3 ta = vec3(1.0,0.0,0.0);\n\n        \/\/ camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n\n        \/\/ create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 3.0*ww );\n\n        \/\/ ray differentials\n        vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)\/iResolution.y;\n        vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)\/iResolution.y;\n        vec3 rdx = normalize( px.x*uu + px.y*vv + 3.0*ww );\n        vec3 rdy = normalize( py.x*uu + py.y*vv + 3.0*ww );\n        vec3 drddx = rdx;\n        vec3 drddy = rdy;\n\n        \/\/-----------------------------------------------------\n        \/\/ render\n        \/\/-----------------------------------------------------\n\n        vec3 col = clamp( vec3(0.95,0.95,1.0) - 0.75*rd.y, 0.0, 1.0 );\n        const vec3 lig = normalize(vec3(-0.2,0.6,0.9));\n        float sun = pow( clamp( dot(rd,lig), 0.0, 1.0 ), 8.0 );\n        col += 0.7*vec3(1.0,0.9,0.8)*pow(sun,4.0);\n        col *= 0.9;\n        vec3 bcol = col;\n\n        \/\/ raymarch\n        vec4 tmat = intersect(ro,rd);\n        float t = tmat.x;\n        if( tmat.z>-0.5 )\n        {\n            \/\/ geometry\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            if( tmat.z<0.5 )\n                nor = vec3(0.0,1.0,0.0);\n            vec3 ref = reflect( rd, nor );\n\n\n            \/\/ derivatives\n            vec3 dposdx;\n            vec3 dposdy;\n            calcPxy( ro, rd, rdx, rdy, t, nor, dposdx, dposdy );\n\n\n            \/\/ materials\n            vec3 mate = vec3(1.0);\n            vec2 uv = tmat.yw;\n            #if COMPUTE_UV==1\n                if( tmat.z>0.5 )\n                {\n                    uv.y = mod(uv.y,6.283185);\n                    uv = uv*vec2(10.0,1.0\/6.283185) - vec2(0.4*iTime,0.0);\n                    #if TEXTURE==0\n                    \/\/mate *= 0.5*gridTexture(uv*6.0);\n                    mate *= smoothstep(-0.02,0.02,sin(uv.x*6.283185*4.0)*sin(uv.y*6.283185*4.0));\n                    #else\n                    vec3 te = texture(iChannel0,uv).xyz;\n                    mate *= sqrt(te*te*te);\n                    #endif\n                }\n                else\n                {\n                    #if TEXTURE==0\n                          uv.x = 0.025*length(pos.xz);\n                    float dudx = 0.025*length(dposdx.xz) - uv.x;\n                    float dudy = 0.025*length(dposdy.xz) - uv.x;\n                    mate *= 0.5*gridTexture(uv.x*65.0, dudx*65.0, dudy*65.0);\n                    #else\n                    uv = pos.xz*0.2;\n                    vec3 te = texture(iChannel0,uv).xyz;\n                    mate *= sqrt(te*te*te);\n                    #endif\n                }\n            #else\n                mate *= 0.5*gridTexture(uv.x*80.0);\n            #endif\n            \n            \n            \n\n            float occ = calcAO( pos, nor );\n\n            \/\/ lighting\n            float sky = clamp(0.5+0.5*nor.y,0.0,1.0);\n            float dif = max(dot(nor,lig),0.0);\n            float bac = max(0.5 + 0.5*dot(nor,-lig),0.0);\n            float sha = 0.0; if( dif>0.001 ) sha=softshadow( pos+0.01*nor, lig, 0.0005, 32.0 );\n            float fre = clamp( 1.0 + dot(nor,rd), 0.0, 1.0 );\n            float spe = max( 0.0, pow( clamp( dot(lig,reflect(rd,nor)), 0.0, 1.0), 8.0 ) );\n\n            \/\/ lights\n            vec3 brdf = vec3(0.0);\n            brdf += 2.5*dif*vec3(1.00,0.90,0.80)*sha;\n            brdf += 1.0*sky*vec3(0.15,0.20,0.30)*occ;\n            brdf += 1.5*bac*vec3(0.10,0.10,0.10)*occ;\n            brdf += 1.0*fre*fre*vec3(1.00,1.00,1.00)*(0.1+0.9*occ*dif);\n\n            \/\/ surface-light interacion\n            col = mate.xyz* brdf;\n            col += spe*vec3(1.0,0.95,0.9)*sha*(0.1+0.9*fre*fre*fre)*occ;\n\n            \/\/ fog\n            col = mix( col, bcol, smoothstep(10.0,20.0,t) );\n        }\n\t\tcol += 0.4*vec3(1.0,0.8,0.7)*sun;\n        tot += col;\n#if AA>1\n    }\n    tot \/= float(AA*AA);\n#endif\n    \t\n    \/\/ gamma\n\ttot = pow( clamp(tot,0.0,1.0), vec3(0.45) );\n\n\tfragColor = vec4( tot, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"3ddGzn","date":"1567633730","viewed":11262,"name":"Then and Before - PC4k by Altair","username":"KK","description":"4k PC intro released at Xenium 2019\n\nDownload\/pouet: https:\/\/www.pouet.net\/prod.php?which=82778","likes":269,"published":3,"flags":96,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/\n\/\/ __ __|  |   |  ____|   \\  |         \\      \\  |  __ \\       __ )   ____|  ____|  _ \\    _ \\   ____| \n\/\/    |    |   |  __|      \\ |        _ \\      \\ |  |   |      __ \\   __|    |     |   |  |   |  __|   \n\/\/    |    ___ |  |      |\\  |       ___ \\   |\\  |  |   |      |   |  |      __|   |   |  __ <   |     \n\/\/   _|   _|  _| _____| _| \\_|     _\/    _\\ _| \\_| ____\/      ____\/  _____| _|    \\___\/  _| \\_\\ _____| \n\/\/\n\/\/\n\/\/                                                                         4k PC intro - Altair MMXIX\n\/\/\n\/\/\n\/\/    Code & design:    KK\n\/\/    Music & design:   Lesnik\n\/\/    Add. code:        Virgill\n\/\/\n\/\/\n\/\/\n\/\/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy\/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4tXGWB","filepath":"https:\/\/soundcloud.com\/lesnik-altair\/there-and-before","previewfilepath":"https:\/\/soundcloud.com\/lesnik-altair\/there-and-before","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ ================================================ Intro ================================================\n\n\nconst int QN = 100;\nconst int QD = 50;\n\nconst float QNs = 45.\/float(QN);\nconst float QNq = 1.35\/float(QN);\nconst float QDs = 30.\/float(QD);\nconst float QDq = .9\/float(QD);\n\n\nint seq_code;\nivec3 iA;\nfloat cb(int n) {\n\treturn float((seq_code>>n)&1);\n}\n\nvec3 lpos3;\nfloat camz, destr, sprog;\t\/\/ scene progress\n\n\n\n\n\n\n\n\nvec3 map(vec3 p)\n{\n\tfloat\n\t\ta=.5*iTime*cb(11),\n\t\tn0 = noise(73.*p+a),\n\t\tn1 = noise(10.*p+a+a),\n\t\tn2 = noise(2.*p+a)-.5,\n\t\tn3 = noise(.4*p+a)-.5,\n\t\th;\n\tfloat\n\t\twn1 = .2*n0+n1,\n\t\twn2 = sat(10.*n2),\n\t\twn3 = sat(10.*n3)*sat(.2*p.x*p.x-.1+.3*n2);\n\tfloat wallnoise = wn1*(.02+wn2),\n        \teclipse=sat(5.*sprog-3.)*cb(7);\n\tvec3 d = vec3(1, 0, 0), q, t;\n\n\tdmin(d, 6.-p.y-.1*n1+.3*n2-.4*n3,\n\t\t(2.-.4*cb(12)-1.*eclipse+1.5*sat(1000.*\n\t\t(1.3-length((p-7.*lpos3).xz))*cb(4)\t\/\/ enl\n\t\t))*(.12+.3*n0+.5*n1+.5*n2+.5*n3),\t\t\/\/ ebase,\n\t\t0.); \t\t\/\/ common sky\n\n\n\th = mix(.05*n0+.07*n1+.3*n2+n3,\t\t\t\t\t\/\/ terrain\n\t\t.002*n0+.04*n1+.2*n2+.4*n3, cb(11));\t\/\/ water\n\tif( cb(3)==0. )\n\t\tdmin(d, .8+p.y-.1*wallnoise, .01+.9*wn2, 0.);\t\/\/ forrest floor\n\telse if( cb(2)==0. )\n\t\tdmin(d, 1.2-.6*cb(11)+p.y-h, mix(.8+h*(1.-eclipse), .01, cb(11)), 0.);\t\/\/ terrain\n\telse\n\t\tdmin(d, .6+p.y-(wn1\/3.+n2+.5+3.*sat(4.*n3-1.))*(.02+wn3), .01+.9*wn3, 0.);\t\/\/ rocks\n\n\n\n\th = sat(mix(.85*sprog, 1., cb(5))*2.*cb(6)-.5+.2*p.y);\n\th*=2.*(n0-.2)*h;\n\tif( cb(3)==0. )\n\t\tif( cb(2)==0. )\n\t\t{\n\t\t\t\/\/ trees\n\t\t\tq=rep(abs(p)-1.6, 3.2);\n\t\t\tq.y = abs(p.y)-3.;\n\t\t\tdmin(d,\n\t\t\t\tmax(p.y-3.5+wn2, vines(\n\t\t\t\t\tq,\n\t\t\t\t\t.1*wn1+.5+10.\/pow(1.+.95*q.y*q.y, 1.5)\n\t\t\t\t) -\n\t\t\t\t\tmix(.02+.08*wn1, -.1, (.55+p.y\/3.)*sat(-15.-p.z))\n\t\t\t\t), .9, .0);\n\t\t}\n\t\telse {\n\t\t\t\/\/ city\n\t\t\tq=p;\n\t\t\tq.xz=rep(q-3., 6.).xz;\n\n\t\t\tdmin(d,\n\t\t\t\t(max(\n\t\t\t\t\tmin(lattice(rep(q, .17))-.01, lattice(rep(q, .3))-.03),\n\t\t\t\t\tlength(max(abs(q) - vec3(1, 3, 1), 0.))+sat(wallnoise+q.y\/10.-.25)\n\t\t\t\t)-h), .7, 0.);\n\t\t}\n\n\n\t\tq=p;\n\t\tq.y-=1.5*n0*sprog*cb(15);\n\t\tif( camz<30. )\n\t\t\tif( cb(2)==0. )\n\t\t\t\t\/\/ circle\n\t\t\t\tif( cb(4)==0. )\n\t\t\t\t\tdmin(d,\n\t\t\t\t\t\tlength(vec2(q.z, length(q.xy)-.5))-.025,\n\t\t\t\t\t\t2.5, -.3);\n\t\t\t\telse\n\t\t\t\t\tdmin(d,\n\t\t\t\t\t\tlength(q)-.6,\n\t\t\t\t\t\t1.8+eclipse*(p.z+.4*(p.y+p.x)<0. ? -.8 : .5),\n\t\t\t\t\t\t.0);\n\t\t\telse\n\t\t\t\t\/\/ glowing triangle\/square\n\t\t\t\tif( cb(4)==0. )\n\t\t\t\t\tfor( float i=0.; i<.99; i+=1.\/(3.+cb(3)) ) {\n\t\t\t\t\t\tt=q;\n\t\t\t\t\t\tpR(t.xy, i);\n\t\t\t\t\t\tt.y -= .3+.22*cb(3);\n\t\t\t\t\t\tdmin(d,\n\t\t\t\t\t\t\tmax(length(t.yz)-.025, abs(t.x)-.532),\n\t\t\t\t\t\t\t2.5, -.3);\n\t\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpR(q.xz, .05);\n\t\t\t\t\tq.y -= .5;\n\t\t\t\t\tdmin(d,\n\t\t\t\t\t\tmax(q.y, dot(abs(q), normalize(vec3(1, .6, 1)))-.4),\n\t\t\t\t\t\t1.4, .0);\n\t\t\t\t}\n\n\n\t\t\/\/ destruction\n\t\tvec2 r=p.xz+p.xy, s = vec2(.5, -.5), vd=50.*vcore(vcore(vcore(vcore(vec2(1), r, s.xx), r, s.xy), r, s.yx), r, s.yy);\n\t\th = vd.y-vd.x+sat(p.y)+1.-1.5*sat((destr-length(p.xz)));\n\t\td.yz = mix(d.yz, vec2(3., -.3), sat(1.-h));\n\n\t\treturn d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n\tfragColor = vec4(0);\n    \n    \/\/ sequencing\n\t{\n\t\tint spos = 0;\n\t\tfloat stim = iTime*1000.*441.\/10.\/(9586.*2.);\n\t\tint istim = int(stim);\n        while( SCENES[spos].x<255 && stim>=float(SCENES[spos].x) )\n            stim -= float(SCENES[spos++].x);\n        iA.y = seq_code = SCENES[spos].y;\n        sprog = sat(stim \/ float(SCENES[spos].x));\n\t}\n\n\tcamz = mix((15.+10.*cb(0)+20.*cb(1)+5.*cb(10))*(1.-.1*sprog)-10., .6, pow(sprog,6.)*cb(7));\n\tdestr = sprog*cb(9)*(3.+5.*cb(5));\n\n\n\n\tfragColor = vec4(0);\n\tif( uv.y>.11 && uv.y<.89 )\n\t{\n\t\tfloat t1 = 0., t2 = 0., seed = uv.x*uv.y+uv.y+uv.x+fract(iTime);\n\t\tvec3 ro1 = vec3(0, 0, -.1),\n\t\t\trd1 = normalize(vec3((2.*fragCoord.xy-iResolution.xy)\/iResolution.y\/1.8, 1)),\n\t\t\tscol=vec3(0), m1, m2, nor1, pos1, pos2;\n\n\t\t\/\/ camera angle\n\t\tvec2 ca=vec2(.1, .07)*cb(8), e = vec2(0, .0001);\n\t\tpR(ro1.zy, ca.y); pR(rd1.zy, ca.y);\n\t\tpR(ro1.zx, ca.x); pR(rd1.zx, ca.x);\n\t\tro1.z-=camz;\n\n\t\tlpos3 = normalize(mix(vec3(.5, 1, 0), vec3(0, -1, 0), sat(destr)));\n\n\t\tt1 = .2*fract(seed);\n\n\t\tfor( int i = 0; i < QN; i++ )\n\t\t{\n\t\t\tpos1 = ro1+rd1*t1;\n\t\t\tm1 = map(pos1);\n\t\t\tt1+=QNs*m1.x;\n\n\t\t\tif( m1.x<.005 )\n\t\t\t{\n\t\t\t\tif( m1.z<0. )\n\t\t\t\t\tscol+= vec3(1.+m1.z, 1., 1.-m1.z)*step(1., m1.y)*float(QN-i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpos2=pos1+mix(lpos3, hashHs(lpos3, seed), .04)*t2;\n\t\t\tm2 = map(pos2);\n\t\t\tt2+=m2.x;\n\n\t\t\tscol +=\n\t\t\t\tmax(0., m1.z) +\n\t\t\t\tvec3(1.+m1.z, 1., 1.-m1.z)*max(0., m1.y-1.) +\n\t\t\t\t(.5+5.*m1.x*noise(7.*pos1+vec3(iTime)))*max(0., m2.y-1.)*(1.-cb(12));\n\t\t}\n\t\tscol *= QNq;\n\n\t\tnor1 = normalize(m1.x-vec3(map(pos1 - e.yxx).x, map(pos1 - e.xyx).x, map(pos1 - e.xxy).x));\n\n\t\tt2=1.;\n\t\tfor( int i = 0; i < QD; i++ )\n\t\t{\n\t\t\tpos2 = pos1 + mix(reflect(rd1, nor1), hashHs(nor1, seed), sat(m1.y))*t2;\n\t\t\tm2 = map(pos2);\n\t\t\tt2+=QDs*m2.x;\n\n\t\t\tscol += vec3(1.+m2.z, 1., 1.-m2.z)*max(0., m2.y-1.)*QDq;\n\n\t\t}\n\t\tscol=clamp(scol, 0., 1.)\n\t\t\t*sat(cb(14)+15.*sprog)\n\t\t\t*sat(cb(13)+5.-5.*sprog)\n\t\t\t-float(iA.y==128)\n\t\t\t;\n\n\t\tfragColor = mix(scol.xyzz, texture(iChannel0, uv), pow(.0001, iTimeDelta));\n\t}\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n\n\/\/ Scene control:\n\/\/\n\/\/ $0003\tBA\t1..0\t- camera distance 0..3\n\/\/ $000C\tDC\t3..2\t- scenery \t00:forest\t\t01:city\n\/\/\t\t\t\t\t\t\t\t\t10:terrain\t\t11:landscape\n\/\/\t \t\t\t\t\t\t\t\t-0:circle\t\t-1:triangle\n\/\/\n\/\/ $0010\t E\t 4\t\t- 0:glowing\t\t1:solid\n\/\/ $0020\t F\t 5\t\t- large voronoi range \/ end phase of city destruction\n\/\/ $0040\t G\t 6\t\t- city destruction\n\/\/ $0080\t H\t 7\t\t- black sphere (only flag H = black screen)\n\/\/ $0100\t I\t 8\t\t- camera angle\n\/\/ $0200\t J\t 9\t\t- voronoi destruction\n\/\/ $0400\t K\t10\t\t- camera distance + 0.5\n\/\/ $0800\t L  11\t\t- water (with C=0 D=1)\n\/\/ $1000\t M  12\t\t- darkness\n\/\/ $2000\t N\t13\t\t- sharp OUT transition\n\/\/ $4000\t O\t14\t\t- sharp IN transition\n\/\/ $8000\t P\t15\t\t- shape particles\n\/\/\n\/\/\n\n\nconst ivec3 SCENES[] = ivec3[](\n#define SCENE(n,d,b)\tivec3((d),(b),(n))\n\n\t\/\/intro\n\tSCENE(2, 16, 0x050A | 0x0000),\n\tSCENE(3, 16, 0x040B | 0x0000),\n\n\t\/\/PART 1 - forest+rocks\n\tSCENE(4, 12, 0x0013 | 0x4000),\n\tSCENE(5, 11, 0x0051 | 0x2000),\n\tSCENE(6, 1, 0x0410 | 0x6000),\n\tSCENE(7, 8, 0x0010 | 0x6000),\n\tSCENE(8, 12, 0x0110 | 0x4000),\n\tSCENE(9, 12, 0x001F | 0x0000),\n\tSCENE(10, 12, 0x001C | 0x6000),\n\n\t\/\/the ball!\n\tSCENE(11, 8, 0x0080 | 0x0000), \/\/d\n\tSCENE(13, 20, 0x0418 | 0x2000),\n\n\t\/\/PART 2 - city\n\tSCENE(14, 16, 0x0407 | 0x4000),\n\tSCENE(15, 16, 0x0014 | 0x0000),\n\tSCENE(16, 20, 0x0124 | 0x6000),\n\tSCENE(17, 11, 0x0044 | 0x6000),\n\n\t\/\/the ball!\n\tSCENE(18, 13, 0x0080 | 0x0000), \/\/d        \n\tSCENE(20, 20, 0x0818 | 0x4000),\n\n\t\/\/PART 3 - destruction\n\tSCENE(80, 16, 0x0041 | 0x2000),\n\tSCENE(21, 16, 0x0200 | 0x6000),\n\tSCENE(33, 16, 0x0074 | 0x0000),\n\tSCENE(22, 16, 0x040c | 0x7000),\n\tSCENE(24, 19, 0x063c | 0x3000),\n\n\tSCENE(26, 7, 0x0080 | 0x0000), \/\/d\n\n\t\t\t\t\t\t\t\t   \/\/outtro - water\n\tSCENE(28, 12, 0x1908 | 0x0000),\n\tSCENE(27, 16, 0x0808 | 0x1000),\n\tSCENE(97, 10, 0x0C08 | 0xB000),\n\n\tSCENE(96, 8, 0x0080 | 0x0000), \/\/d\n\n\t\t\t\t\t\t\t\t   \/\/the ball! \n\/\/\tSCENE(30, 12, 0x0018 | 0x4000),\n\/\/\tSCENE(31, 16, 0x0098 | 0x0000),\n\tSCENE(32, 24, 0x0098 | 0x6000),\n\tSCENE(0, 255, 0x0080 | 0x0000) \/\/d\t\n#undef SCENE\n\t);\n\n\n\n\/\/ ================================ Helper functions ================================\n\n\nfloat sat(float x)\n{\n\treturn clamp(x, 0., 1.);\n}\n\n\n\/\/ ================================ Noises ================================\n\n\/\/ 3D noise - method by iq\/shane\nfloat noise(vec3 p)\n{\n\tvec3 ip=floor(p);\n\tp-=ip;\n\tvec3 s=vec3(7, 157, 113);\n\tvec4 h=vec4(0, s.yz, s.y+s.z)+dot(ip, s);\n\tp=p*p*(3.-2.*p);\n\th=mix(fract(43758.5*sin(h)), fract(43758.5*sin(h+s.x)), p.x);\n\th.xy=mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\n\n\/\/ ================================ Voronoi ================================\n\nvec2 vcore(vec2 m, vec2 p, vec2 s)\n{\n\tvec2 c = floor(2.5*p+s);\t\t\/\/ 1.\/.4   r\n\tc += fract(43758.5*sin(c+17.*c.yx));\n\n\tfloat v = length(.4*c-p);\t\/\/ r\n\treturn v<m.x ? vec2(v, m.x) : v<m.y ? vec2(m.x, v) : m;\n}\n\n\n\n\/\/ ================================ Patterns ================================\n\n\nfloat lattice(vec3 p)\n{\n\tp=abs(p);\n\tp=max(p, p.yzx);\n\tp=min(p, p.yzx);\n\tp=min(p, p.yzx);\n\treturn p.x;\n}\n\n\n\n\/\/ ================================ SDF merge functions ================================\n\n\nvoid dmin(inout vec3 d, float x, float y, float z)\n{\n\tif( x < d.x ) d = vec3(x, y, z);\n}\n\n\n\n\/\/ ================================ Domain operations ================================\n\n\n\/\/ rotation\nvoid pR(inout vec2 p, float a)\n{\n\ta *= 6.283;\n\tp = cos(a)*p+sin(a)*vec2(p.y, -p.x);\n}\n\n\n\/\/ 3D repetition\nvec3 rep(vec3 p, float r)\n{\n\treturn (fract(p\/r-.5)-.5)*r;\n}\n\n\/\/ diffuse reflection hash - method by fizzer\nvec3 hashHs(vec3 n, inout float seed)\n{\n\tvec2 uv = (seed=32.+seed*fract(seed))+vec2(78.233, 10.873);\n\tuv = fract(.1031*uv);\n\tuv *= 19.19+uv;\n\tuv = fract(2.*uv*uv);\n\n\tfloat u = 2.*uv.x-1.;\n\n\tvec3 v = vec3(sqrt(1.-u*u), 0., u);\n\tpR(v.xy, uv.y);\n\treturn normalize(n+v);\n}\n\n\n\/\/ ================================ Complex SDFs ================================\n\nfloat vines(vec3 p, float s)\n{\n\tp.y=abs(p.y);\n\tpR(p.xz, .1*p.y); p=abs(p); p.xz -= .06*s;\n\tpR(p.xz, -.16*p.y); p=abs(p); p.xz -= .05*s;\n\tpR(p.xz, .4*p.y);\n\treturn length(abs(p.xz) - .04*(s*.5+.5));\n}\n","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"XtfXDN","date":"1437227300","viewed":11227,"name":" [SIG15] Oblivion","username":"Dave_Hoskins","description":"The Oblivion drone. I love all the scenes that include these things.\nPLEASE REWIND ON FIRST LOAD [|<], to make sure audio is in sync.\n\"Tech 4-9, Jack Harper!!!\"","likes":157,"published":3,"flags":8,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"\/media\/a\/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"\/media\/ap\/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"\/media\/a\/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"\/media\/ap\/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"\/media\/a\/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"\/media\/ap\/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ [SIG15] Oblivion\n\/\/ by David Hoskins.\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ The Oblivion drone. I love all the scenes that include these things.\n\/\/ It takes bits from all over:-\n\/\/ https:\/\/www.youtube.com\/watch?v=rEby9OkePpg&feature=youtu.be\n\/\/ These drones were the true stars of the film!\n\n\/\/ You might need to rewind to sync the audio properly.\n\n\/\/ Some info, if you want to know:-\n\/\/ The camera is delayed when following the drone to make it feel hand held.\n\/\/ The rendering layers consist of:-\n\/\/ 1. Background, including sky, ground and shadow. Plus a check for a possible heat haze\n\/\/    to bend the ray, before beginning trace.\n\/\/ 2. Anti-aliased drone ray-marching, which is traced from just in front to just behind it for speed.\n\/\/ 3. Clouds, and fogging.\n\/\/ 4. Foreground, for ID scanner\n\n#define PI 3.14156\n#define TAU 6.2831853071\n#define MOD2 vec2(443.8975,397.2973)\n#define MOD3 vec3(443.8975,397.2973, 491.1871)\n\nconst vec2 add = vec2(1.0, 0.0);\nvec3 sunDir = normalize(vec3(-2.3, 3.4, -5.89));\nconst vec3 sunCol = vec3(1.0, 1.0, .9);\nvec2 gunMovement;\nvec3 drone;\nvec3 droneRots;\nfloat scannerOn;\nvec4 dStack;\nvec4 eStack;\nint emitionType = 0;\n#define ZERO min(iFrame, 0)\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ Action cue sheet, for easy manipulation...\n#define cueINCLOUDS 0.0\n#define cueFLYIN 14.0\n#define cueFRONTOF cueFLYIN + 10.0\n#define cueTHREAT cueFRONTOF + 5.\n#define cueFLYOFF cueTHREAT + 19.0\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ A hash that's the same on all platforms...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3.zxy, p3.yxz+19.19);\n    return fract(vec3(p3.x * p3.y, p3.x*p3.z, p3.y*p3.z));\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * MOD3);\n   p3 += dot(p3.xyz, p3.yzx + 19.19);\n   return fract(vec3(p3.x * p3.y, p3.x*p3.z, p3.y*p3.z));\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 noise3(float n)\n{\n    float f = fract(n);\n    n = floor(n);\n    f = f*f*(3.0-2.0*f);\n    return mix(hash31(n), hash31(n+1.0), f);\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(1.5-f)*2.0;\n    \n    vec3 res = mix(mix( hash32(p), hash32(p + add.xy),f.x),\n               mix( hash32(p + add.yx), hash32(p + add.xx),f.x),f.y);\n    return res;\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ CubeMap OpenGL clamping fix. Why do I have to do this?\nvec3 cubeMap(in samplerCube sam, in vec3 v, float size)\n{\n   float M = max(max(abs(v.x), abs(v.y)), abs(v.z));\n   float scale = (float(size) - 1.) \/ float(size);\n   if (abs(v.x) != M) v.x *= scale;\n   if (abs(v.y) != M) v.y *= scale;\n   if (abs(v.z) != M) v.z *= scale;\n   return texture(sam, v).xyz;\n}\n\n\/\/ Thanks to iq for the distance functions...\n\/\/----------------------------------------------------------------------------------------\nfloat circle(vec2 p, float s )\n{\n    return length(p)-s;\n}\n\/\/----------------------------------------------------------------------------------------\nfloat  sphere(vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat prism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.x-h.y,max(q.z*0.6+p.y*.5,-p.y)-h.x*0.5);\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat prismFlip( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.x-h.y,max(q.z*.8-p.y*.5,p.y)-h.x*0.5);\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat roundedSquare( vec2 p, vec2 b)\n{\n  vec2 d = abs(p) - b;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    \n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat roundedBox( vec3 p, vec3 b, float r )\n{\n\treturn length(max(abs(p)-b,0.0))-r;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat sMin( float a, float b, float k )\n{\n    \n\tfloat h = clamp(0.5 + 0.5*(b-a)\/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.-h);\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec2 rot2D(inout vec2 p, float a)\n{\n    return cos(a)*p - sin(a) * vec2(p.y, -p.x);\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 rot3DXY(in vec3 p, in vec2 a)\n{\n\tvec2 si = sin(a);\n\tvec2 co = cos(a);\n    p.xz *= mat2(co.y, -si.y, si.y, co.y);\n    p.zy *= mat2(co.x, -si.x, si.x, co.x);\n    return p;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat boxMap( sampler2D sam, in vec3 p, in vec3 n)\n{\n    p = p*vec3(.1, .03, .1);\n    n = abs(n);\n\tfloat x = texture( sam, p.yz ).y;\n\tfloat y = texture( sam, p.zx ).y;\n\tfloat z = texture( sam, p.xy ).y;\n\treturn (x*n.x + y*n.y + z*n.z)\/(n.x+n.y+n.z);\n}\n\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\n\nfloat triNoise3d(in vec3 p, in float spd, float ti)\n{\n    float z=1.1;\n\tfloat rz = 0.;\n    vec3 bp = p*1.5;\n\tfor (float i=0.; i<=3.; i++ )\n\t{\n        vec3 dg = tri3(bp);\n        p += (dg+spd);\n        bp *= 1.9;\n\t\tz *= 1.5;\n\t\tp *= 1.3;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))\/z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}\n\nfloat fogmap(in vec3 p, in float d, float ti)\n{\n    p.xz *= .4;\n    p.z += ti*1.5;\n    return max(triNoise3d(p*.3\/(d+20.),0.2, ti)*1.8-.7, 0.)*(smoothstep(0.,25.,p.y));\n}\n\/\/ Thanks to nimitz for the quick fog\/clouds idea...\n\/\/ https:\/\/www.shadertoy.com\/view\/4ts3z2\nvec3 clouds(in vec3 col, in vec3 ro, in vec3 rd, in float mt, float ti)\n{\n    float d = 3.5;\n    for(int i=0; i<7; i++)\n    {\n        if (d>mt)break;\n        vec3  pos = ro + rd*d;\n        float rz = fogmap(pos, d, ti);\n        vec3 col2 = (vec3(.4,0.4,.4));\n        col = mix(col,col2,clamp(rz*smoothstep(d,d*1.86,mt),0.,1.) );\n        d *= 1.86;\n        \n    }\n    return col;\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec4 numbers(vec4 mat, vec2 p)\n{\n    p.y *= 1.70;\n    p.y+=.32;\n\tfloat d;\n\td =(roundedSquare(p+vec2(1.4, -.25), vec2(.02, .76)));\n  \td =min(d, (roundedSquare(p+vec2(1.48, -1.04), vec2(.1, .06))));\n\n    vec2 v = p;\n    v.x -= v.y*.6;\n    v.x = abs(v.x+.149)-.75;\n\td = min(d, roundedSquare(v+vec2(0.0, -.7), vec2(.07, .4)));\n    v = p;\n    v.x -= v.y*.6;\n    v.x = abs(v.x-.225)-.75;\n    p.x = abs(p.x-.391)-.75;\n  \td = min(d, circle(p, .5));\n   \td = max(d, -circle(p, .452));\n    d = max(d, -roundedSquare(v+vec2(0., -.87), vec2(.33, .9)));\n    \n    mat = mix(mat, vec4(.8), smoothstep(0.2, .13, d));\n    return mat;\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ Find the drone...\nfloat mapDE(vec3 p)\n{\n    p -= drone.xyz;\n    p = rot3DXY(p, droneRots.xy);\n\n    float d = sphere(p, 10.0);\n\tvec3 v = p;\n    v.xy = abs(v.xy);\n    v.xy = rot2D(v.xy, -PI\/6.2);\n    \/\/ Cross pieces...\n    d = sMin(d, roundedBox(v-vec3(0,0,-8), vec3(4.9, .3, .5), 1.), 1.2); \n    d = max(d, -roundedBox(v-vec3(0,0,-8.5), vec3(4.8, .3, 1.), 1.));\n    \n    \/\/ Centre cutout...\n    \/\/d = sMin(d, roundedBox(p-vec3(0,0,-8.5), vec3(1.3, 1.4, 1.5), .7), .4); \n    d = max(d,-roundedBox(p-vec3(0,0,-9.1), vec3(2., 1.5, 4.0), .7)); \n    \/\/ Inside...\n    d = min(d, sphere(p, 8.8));\n    d = max(d, roundedBox(p, vec3(6.5, 12, 12.0), .8)); \n    \/\/ Make back...\n    d = sMin(d, prismFlip(p+ vec3(.0, -4.1, -8.1), vec2(7., 4.7) ), 1.);\n    d = max(d, -prism(p + vec3(.0, 6.4, -11.4), vec2(8.0, 10.0) ));\n    d = min(d, sphere(p+ vec3(.0, 5.6, -6.2), 3.0));\n    \n    \/\/ Eye locations..\/\n    d = min(d, sphere(v+ vec3(-3.5, .0, 7.4), 1.1));\n    \n    v = p;\n    v.x = abs(v.x);\n    d = sMin(d, roundedBox(v+vec3(-4.2,-6.,-10.0), vec3(1.1, .1, 4.5), 1.), 2.4); \n    \n    v =abs(p)-vec3(gunMovement.x, .0, 0.) ;\n    v.x -= p.z*.1*gunMovement.y;\n\tfloat d2 = sphere(v, 10.0);\n    d2 = max(d2, -roundedBox(v, vec3(6.55, 12, 12.0), .8)); \n    d = min(d2 ,d);\n    d = min(d,roundedBox(v-vec3(5.5, 3.5, 3.5), vec3(2.3, .1, .1), .4));\n    d = min(d,roundedBox(v-vec3(5.5, .0, 5.), vec3(2.4, .1, .1), .4));\n\n    v =vec3(abs(p.xy)-vec2(gunMovement.x, .0), p.z);\n    v.x -= p.z*.1*gunMovement.y;\n\n    d = min(d, roundedBox(v-vec3(8., 2.8, -6.5), vec3(.3, 1., 3.), .2));\n    d = min(d, roundedBox(v-vec3(8., 2.3, -10.), vec3(.2, .4, 1.2), .2));\n    d = min(d, roundedBox(v-vec3(8., 3.4, -10.), vec3(.01, .01, 1.2), .4));\n    d = max(d, -roundedBox(v-vec3(8., 3.4, -10.4), vec3(.01, .01, 1.2), .3));\n    d = max(d, -roundedBox(v-vec3(8., 2.3, -10.4), vec3(.01, .01, 1.2), .3));\n    \n    d = min(d,  roundedBox(v-vec3(8.55, 0, -4.5), vec3(.4, .2, 1.), .4));\n    d = max(d, -roundedBox(v-vec3(8.65, 0, -4.5), vec3(.0, .0, 2.), .34));\n       \n    return d;\n}\n\n\/\/---------------------------------------------------------------------------\nfloat bumpstep(float edge0, float edge1, float x)\n{\n    return 1.0-abs(clamp((x - edge0) \/ (edge1 - edge0), 0.0, 1.0)-.5)*2.0;\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ Find the drone's material...yes, it's IFtastic! :D\nvec4 mapCE(vec3 p, vec3 nor)\n{\n    vec4 mat;\n    p -= drone.xyz;\n\tp = rot3DXY(p, droneRots.xy);\n\n    const vec4 gunMetal = vec4(.05, .05, .05,.3);\n    vec4 body     = vec4(.8, .8, .8,.4);\n   \n    float dirt1 = smoothstep(-.1, .5,boxMap(iChannel1,p, nor))*.25+.75;\n    mat = body*dirt1;\n  \n    float d = sphere(p+vec3(0,0,.5), 8.9);\n    float d2;\n    d = max(d, roundedBox(p, vec3(6., 12, 11.0), .72)); \n    if (d < .0 || p.z > 14.5)\n    {\n        d = sphere(p-vec3(-3.3 , 1.8, -8.1), .9);\n        d2 = sphere(p-vec3(3.1 , 1.7, -8.1), .5);\n        \/\/ EyeCam...\n\t    if (d < 0.0)\n        {\n            mat = vec4(1., 0.03, 0.0, .7);\n            emitionType = 1;\n        }else\n\t\t\/\/ Scanner...\n       \tif (d2 < 0.0)\n       \t{\n            d2 = d2 < -.015 ? max(-circle(mod(p.xy-vec2(3.185 , 1.78), .16)-.08, .085)*35.0, 0.0): 1.0;\n\t\t\tmat = vec4(.2+scannerOn*.6, 0.2+scannerOn*.75, 0.2+scannerOn, .7*d2)*d2;\n            \n\t\t\temitionType = 2;\n      \t}\n        else\n\t        mat = numbers(gunMetal, p.xy);\n        \/\/ Do hex border line around numbers...\n        p = abs(p);\n        mat = p.x > p.y*.76 ? mix(mat, vec4(0.0), bumpstep(2.3, 2.4, p.x+p.y*.5)):mix(mat, vec4(0.0), bumpstep(1.82, 1.92, p.y));\n        return mat;\n    }\n\n     \/\/ Gun placements and carriers...\n    vec3 v = p;\n    \n   \t\/\/v.yz = rot2D(p.yz, gunMovement.x);\n\tv =abs(v)-vec3(gunMovement.x, .0, 0.) ;\n    v.x -= p.z*.1*gunMovement.y;\n\td2 = sphere(v, 10.0);\n    d2 = max(d2, -roundedBox(v, vec3(6.55, 12, 4.0), 1.1)); \n    \n    d = min(d2, d);\n    d2 = min(d,\troundedBox(v-vec3(5.5, 3.5, 3.5), vec3(2.3, .1, .1), .4));\n    \/\/d2 = min(d2,roundedBox(v-vec3(5.5, .0, 3.7), vec3(2.3, .1, .1), .4));\n    d2 = min(d2, sphere(v-vec3(5., .0, 3.7), 3.8));\n    if(d2 < d) mat = vec4(.0, .0, .0, 6.);\n    \/\/return mat;\n    \n    v = vec3(abs(p.x)-gunMovement.x, p.yz);\n    v.x -= p.z*.1*gunMovement.y;\n    float dirt = (smoothstep(-.1, .5,boxMap(iChannel1,v, nor))*.2+.8);\n    body = body * dirt;\n \n    v = vec3(abs(p.xy)-vec2(gunMovement.x, .0), p.z);\n    v.x -= p.z*.1*gunMovement.y;\n    \n    if ( v.x > 7.4)  mat =mix(body, gunMetal, smoothstep(2.5, 2.3, v.y))*dirt;\n    d2 =  roundedBox(v-vec3(8., 2.3, -10.5), vec3(.4, 1.6, 1.5), .2);\n    \/\/if ( d2 < 0.1)  mat = gunMetal*dirt;\n    mat= mix(mat, gunMetal*dirt, clamp(-d2*10.0, 0.0, 1.0));\n    \n    d =  sphere(p+ vec3(.0, 5.6, -6.2), 3.2);\n    if ( d < 0.0)\n    {\n        mat = vec4(0);\n        emitionType = 3;\n    }\n\n    return mat;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat shadow( in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    float t = .2;\n    for (int i = ZERO; i < 12; i++)\n\t{\n\t\tfloat h = mapDE( ro + rd*t );\n        if (h< -2.) break;\n\t\tres = min(10.*h \/ t, res);\n\t\tt += h+.2;\n\t}\n    return max(res, .3);\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat SphereRadius(in float t)\n{\n    t = t*.003+.01;\n\treturn min(t,256.0\/iResolution.x);\n}\n\n\/\/----------------------------------------------------------------------------------------\nvoid rayMarch(vec3 pos, vec3 dir)\n{\n    \/\/ Efficiently start the ray just in front of the drone...\n    float l = max(length(drone-pos)-14.2, .0);\n    float d =  l;\n    l+=23.;\/\/ ...and end it just after\n    int hits = 0;\n\t\/\/ Collect 4 of the closest scrapes on the tracing sphere...\n    for (int i = ZERO; i < 55; i++)\n    {\n        \/\/ Leave if it's gone past the drone or when it's found 7 stacks points...\n        if(d > l || hits == 6) break;\n        vec3 p = pos + dir * (d);\n\t\tfloat r= SphereRadius(d);\n\t\tfloat de = mapDE(p);\n        \/\/ Only store the closest ones (roughly), which means we don't\n        \/\/ have to render the 8 stack points, just the most relavent ones.\n        \/\/ This also prevents the banding seen when using small stacks.\n        if(de < r &&  de < eStack.x)\n        {\n            \/\/ Rotate the stack and insert new value!...\n\t\t\tdStack = dStack.wxyz; dStack.x = d; \n            eStack = eStack.wxyz; eStack.x = de;\n\t\t\thits++;    \n        }\n\t\td +=de*.9;\n    }\n    return;\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 normal( in vec3 pos, in float r )\n{\n\tvec2 eps = vec2( r*1., 0.0);\n\tvec3 nor = vec3(\n\t    mapDE(pos+eps.xyy) - mapDE(pos-eps.xyy),\n\t    mapDE(pos+eps.yxy) - mapDE(pos-eps.yxy),\n\t    mapDE(pos+eps.yyx) - mapDE(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat terrain( in vec2 q )\n{\n    q *= .5;\n    q += 4.;\n\tfloat h = smoothstep( 0., 0.7, textureLod( iChannel1, 0.023*q,  0.0).x )*6.0;\n    h +=  smoothstep( 0., 0.7, textureLod( iChannel2, 0.03*q, 0.0 ).y )*3.0;\n    \/\/h +=  smoothstep( 0., 1., texture( iChannel1, .01*q, 00.0 ).y )*1.0;\n    return h;\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 skyUpper(in vec3 rd)\n{\n    vec3  sky;\n    float f = pow(max(rd.y, 0.0), .5);\n    sky = mix(vec3(.45, .5, .6), vec3(.7, .7, .7), f);\n    float sunAmount = pow(max( dot( rd, sunDir), 0.0 ), 8.0);\n    sky = sky + sunCol * sunAmount*.5;\n    rd.xz = rd.zx;rd.y-=.05;\n    sky -= (vec3(.65, .67, .75)-cubeMap(iChannel3, rd, 64.0).xyz)*.5;\n\n\treturn clamp(sky, 0.0, 1.0);\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 fogIt(in vec3 col, in vec3 sky, in float d)\n{\n    return mix (col, sky, clamp(1.0-exp(-d*0.001), 0.0, 1.0));\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 ground(vec3 sky, in vec3 rd, in vec3 pos)\n{\n  \n    if (rd.y > .0) return sky;\n \n\tfloat d = (-20.0-pos.y)\/rd.y;\n\tvec2 p = pos.xz+rd.xz * d;\n    \n\tvec3 tex1 = texture(iChannel1, p*.1).xyz;\n\tvec3 tex2 = texture(iChannel2, p*.0004).yyx*vec3(1.0, .8, .8);\n\n\tvec3 gro  = vec3(1.);\n    \n    d-=20.0;\n\tfloat a = .0004*d*d;\n        \n\tvec3 nor  \t= vec3(0.0,\t\t    terrain(p), 0.0);\n\tvec3 v2\t\t= nor - vec3(a,\t\tterrain(p+vec2(a, 0.0)), 0.0);\n\tvec3 v3\t\t= nor - vec3(0.0,\t\tterrain(p+vec2(0.0, a)), -a);\n\tnor = cross(v2, v3);\n\tnor = normalize(nor);\n\tgro = mix(tex1, tex2, nor.y*.8);\n\tfloat sha = shadow(vec3(p.x, 0.0, p.y),  sunDir);\n\tfloat z =max(dot(nor, sunDir), 0.1);\n    if (dStack[0] < 0.0) dStack[0]= d;\n    vec3 col = gro*z*sha;\n\n\treturn col = fogIt(col, sky, d);\n}\n\n\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ This is also used for the camera's delayed follow routine.\n\/\/ Which make the scene more dramitic because it's a human camera operator!\nvec3 dronePath(float ti)\n{\n    vec3 p = vec3(-2030, 500, 2400.0);\n    p = mix(p, vec3(-2030, 500, 2000.0),\t \tsmoothstep(cueINCLOUDS, cueFLYIN, ti));\n    p = mix(p, vec3(-30.0, 18.0, 300.0),\t\tsmoothstep(cueFLYIN, cueFLYIN+4.0, ti));\n    p = mix(p, vec3(-35.0, 25.0, 10.0), \t\tsmoothstep(cueFLYIN+2.0,cueFLYIN+8.0, ti));\n    p = mix(p, vec3(30.0, 0.0, 15.0), \t\t\tsmoothstep(cueFRONTOF+.5,cueFRONTOF+2.5, ti)); \/\/..\/ Move to front of cam.\n    \n    p = mix(p, vec3(0.0, 8.0, .0), \t\t\t\tsmoothstep(cueTHREAT, cueTHREAT+.5, ti)); \t\/\/ ...Threaten\n    p = mix(p, vec3(0.0, 8.0, -4.0), \t\t\tsmoothstep(cueTHREAT+2.0, cueTHREAT+2.3, ti)); \t\/\/ ...Threaten\n    p = mix(p, vec3(0.0, 8., -12.0), \t\t\tsmoothstep(cueTHREAT+3.0, cueTHREAT+3.3, ti)); \t\/\/ ...Threaten\n    \n    p = mix(p, vec3(0.0, 110.0, 0.0), \t\t\tsmoothstep(cueFLYOFF,cueFLYOFF+1.5, ti)); \/\/ ...Fly off\n    p = mix(p, vec3(4000.0, 110.0, -4000.0), \tsmoothstep(cueFLYOFF+2.6,cueFLYOFF+10.0, ti)); \n    return p; \n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 droneRotations(float ti)\n{\n    vec3 a = vec3(0);\n    \n    \n   \ta.x = mix(a.x, .2, smoothstep(cueFLYIN-3.0,cueFLYIN-1.5, ti));\n    a.x = mix(a.x, .0, smoothstep(cueFLYIN-1.5,cueFLYIN, ti));\n\n    a.y = mix(a.y, -.8,smoothstep(cueFLYIN-1.5,cueFLYIN, ti));\n\n    a.x = mix(a.x, .2,smoothstep(cueFLYIN+2.0,cueFLYIN+4.0, ti));\n    a.x = mix(a.x, 0.,smoothstep(cueFLYIN+4.0,cueFLYIN+6., ti));\n\n\ta.y = mix(a.y, 0.0, smoothstep(cueFLYIN+3.0,cueFLYIN+4.4, ti));\n    a.x = mix(a.x, .1,smoothstep(cueFLYIN+7.0,cueFLYIN+7.8, ti));\n    a.x = mix(a.x, 0.,smoothstep(cueFLYIN+7.8,cueFLYIN+8.3, ti));\n    \n\ta.y = mix(a.y, -1.5,smoothstep(cueFRONTOF,cueFRONTOF+.5, ti));\/\/ ..Turn to go right, infront\n\ta.y = mix(a.y, .6, \tsmoothstep(cueFRONTOF+3.,cueFRONTOF+4.5, ti));\n\n    a.y = mix(a.y, .0,  smoothstep(cueTHREAT,cueTHREAT+.5, ti));\n\n    a.x = mix(a.x, -.28,smoothstep(cueTHREAT, cueTHREAT+.3, ti)); \/\/ ...Threaten\n    \n    a.x = mix(a.x, 0.0, smoothstep(cueFLYOFF-2.0, cueFLYOFF, ti)); \/\/ Normalise position, relax!\n    a.x = mix(a.x, -0.5,smoothstep(cueFLYOFF, cueFLYOFF+.2, ti)); \t\/\/ ...Fly off\n    a.x = mix(a.x, 0.0, smoothstep(cueFLYOFF+.2, cueFLYOFF+.7, ti));\n    \n    a.y = mix(a.y, -.78,smoothstep(cueFLYOFF+2., cueFLYOFF+2.3, ti)); \n    \n    scannerOn = smoothstep(cueTHREAT+4.0,cueTHREAT+4.2, ti)* smoothstep(cueTHREAT+11.5,cueTHREAT+11.2, ti);\n    a.z = sin(ti*2.) * scannerOn;\n\n    return a;\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec2 droneGunAni(float ti)\n{\n    vec2 a;\n   \tfloat mov = smoothstep(cueTHREAT+.5, cueTHREAT+1.5, ti);\n    mov = mov * smoothstep(cueFLYOFF-1., cueFLYOFF-3.0, ti);\n    mov = mov*3.1-1.4;\n    a.x = (sin(mov)+1.0)*1.5;\n    a.y = smoothstep(.3,.7,sin(mov))*3.0;\n    return a;\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 cameraAni(float ti)\n{\n    vec3 p;\n    p = mix(drone-vec3(0.0,0.0, 10.0), drone-vec3(0.0,0.0, 20.0), smoothstep(cueINCLOUDS,cueINCLOUDS+2.0, ti));\n    p = mix(p, drone-vec3(17.0,-14.0, 35.0), smoothstep(cueINCLOUDS+2.0,cueFLYIN-3.0, ti));\n\n    p = mix(p, vec3(0.0, 0.0, -28.0), step(cueFLYIN, ti));\n\tp = vec3(p.xy, mix(p.z, -40.0, smoothstep(cueTHREAT,cueTHREAT+4.0, ti)));\n    return p;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat overlay(vec3 p, vec3 dir)\n{\n    float r = 0.0;\n    vec3 pos = drone.xyz+vec3(3.25, -.48, -8.0);\n    vec3 v = p-pos;\n    vec3 n = vec3(0.0, 1., 0.0);\n    n.zy = rot2D(n.zy, droneRots.z);\n    n = normalize(n);\n    float d = -dot(n, v)\/ dot(n, dir);\n    p = p + dir*d-pos;\n\n    if (p.z < .0 && p.z > -20.)\n    {\n        float d = abs(p.z) - abs(p.x)+.4;\n        r = step(.3, d)*.3;\n        r += smoothstep(-.3, -.2,p.x) * smoothstep(0., -.2, p.x)*r;\n        r += smoothstep(.3, .2,p.x) * smoothstep(0.0, .2, p.x)*r;\n        r += smoothstep(0.1, .2, d) * smoothstep(0.4, .2, d);\n    }\n    r += smoothstep(0.3, 0.0,abs(droneRots.z-.4))*1.5;\n\n    return r;\n}\n\n\/\/----------------------------------------------------------------------------------------\nvoid heatHaze(vec3 p, inout vec3 dir, float t)\n{\n    if (t < cueFLYIN) return;\n    float r = 0.0;\n    vec3 pos = vec3(0.0, -4.8, 7.);\n    if (drone.y < 20.0)\n    \tpos.y += smoothstep(-.90, .5,droneRots.y)*smoothstep(.9, 0.5,droneRots.y)*-8.0;\n    pos.zx = rot2D(pos.zx, droneRots.y);\n    pos += drone.xyz;\n    vec3 v = p-pos;\n    vec3 n = vec3(0.0, 0., 1.0);\n\n    n = normalize(n);\n    float d = -dot(n, v)\/ dot(n, dir);\n    p = p + dir*d-pos;\n\n    if (p.y < .0 && p.y > -30.)\n    {\n        float l = abs(p.y) - abs(p.x*(1.1))+8.0;\n        r = smoothstep(.0, 14., l);\n        \/\/p.xy *= vec2(.5,.9);\n        t*= 23.0;\n        dir += r*(noise(p.xy*.8+vec2(0.0,t))-.5)*.001\/(.07+(smoothstep(10.0, 2500.0, d)*20.0));\n    }\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 cameraLookAt(in vec2 uv, in vec3 pos, in vec3 target, in float roll)\n{    \n\tvec3 cw = normalize(target-pos);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n\treturn normalize(-uv.x*cu + uv.y*cv +2.*cw );\n}\n\n\/\/----------------------------------------------------------------------------------------\nvoid mainImage( out vec4 outColour, in vec2 coords )\n{\n\tvec2 xy = coords.xy \/ iResolution.xy;\n    vec2 uv = (xy-.5)*vec2( iResolution.x \/ iResolution.y, 1)*2.0;\n     \/\/ Multiply this time to speed up playback, but remember to do the sound as well!\n  \tfloat ti = mod(iTime, 57.);\n    \/\/float ti = mod(iTime, 5.)+cueFRONTOF;\t\/\/ ...Test cues..\n    \/\/float ti = mod(iTime, 15.0)+cueTHREAT+1.0;\n    \/\/float ti = mod(iTime, 5.)+cueFLYIN;\n    \/\/float ti = mod(iTime, 5.)+cueFLYOFF;\n\t\n    \/\/---------------------------------------------------------\n    \/\/ Animations...\n\tdrone = dronePath(ti);\n    droneRots = droneRotations(ti);\n    vec3 camPos = cameraAni(ti);\n    gunMovement = droneGunAni(ti);\n    float t = smoothstep(cueTHREAT, cueTHREAT+.5, ti) *smoothstep(cueTHREAT+15.5, cueTHREAT+14.7, ti);\n    \n    float e = -droneRots.y+t*texture(iChannel0, vec2(.3, ti*.02)).x*.25-.22;\n    e += texture(iChannel0, vec2(.4, ti*.005)).x*.5-.35;\n    vec3 eyeCam = normalize(vec3(0.3, -.4*t,  -1.0));\n    eyeCam.xz = rot2D(eyeCam.xz, e);\n    \n\t\/\/---------------------------------------------------------\n\tvec3 tar = dronePath(ti-.25);\n    \/\/ Cameraman gets shaky when the drone is close...oh no...\n    float l = 30.0 \/ length(tar-camPos);\n    tar += (noise3(ti*4.0)-.5)*l;\n    vec3 dir = cameraLookAt(uv, camPos, tar, 0.0);\n\t\n    \n    heatHaze(camPos, dir, ti);\n    \/\/--------------------------------------------------------\n    \/\/ Reset and fill the render stack through ray marching...\n    dStack = vec4(-1);\n    eStack = vec4(1000.0);\n    rayMarch(camPos, dir);\n\n    \/\/---------------------------------------------------------\n\t\/\/ Use the last stacked value to do the shadow, seems to be OK, phew!...\n    float lg = dStack[0];\n\tvec3 p = camPos + dir * lg;\n    float sha = shadow(p, sunDir);\n    vec3 sky = skyUpper(dir);\n\t\/\/---------------------------------------------------------\n\t\/\/ Render the stack...\n    float alphaAcc = .0;\n    vec3 col = vec3(0);\n    float spe;\n    for (int i = 0; i < 4; i++)\n    {\n        float d = dStack[i];\n\t\tif (d > 0.0)\n        {\n            float de = eStack[i];\n            float s = SphereRadius(d);\n            float alpha = max((1.0 - alphaAcc) * min(((s-de) \/ s), 1.0),0.0);\n\n            vec3 p = camPos + dir * d;\n            vec3  nor = normal(p, s);\n            vec4  mat = mapCE(p, nor);\n            float amb = abs(nor.y)*.6; amb = amb*amb;\n            vec3 c= mat.xyz * vec3(max(dot(sunDir, nor), 0.0))+ amb * mat.xyz;\n            spe = pow(max(dot(sunDir, reflect(dir, nor)), 0.0), 18.0);\n\n            if (emitionType != 0)\n            {\n                if (emitionType == 1)\n                {\n                    s = cos(pow(max(dot(eyeCam, nor), 0.0), 4.4)*9.0)*.14;\n                    s += pow(abs(dot(eyeCam, nor)), 80.)*18.0;\n                    c*= max(s, 0.0);\n                }\n                if (emitionType == 3)\n                {\n                    vec3 dp = p - drone;\n                    s = smoothstep(.0,-.1, nor.y) * smoothstep(-1.0,-.3, nor.y);\n                    c = vec3((smoothstep(-5.8,-5., dp.y) * smoothstep(-4.8,-5., dp.y))*.1);\n                    float g = abs(sin((atan(nor.x, -nor.z))*TAU+ti*33.0))+.2;\n                    c += s*(texture(iChannel2, p.xy*vec2(.04, .01)+vec2(0.0, ti)).xyy)*vec3(1.5, 2.3,3.5)*g;\n\n                    alpha *= smoothstep(-9.,-4.5, dp.y) - g * smoothstep(-4.5,-10., dp.y)*.2;\n\n                }          \n\n                sha = 1.0;\n            }\n\n            c += sunCol * spe * mat.w;\n\n\n            col += c = fogIt(c *sha, sky, d)* alpha;\n            alphaAcc+= alpha;\n        }\n     }\n    \n\t\/\/---------------------------------------------------------\n    \/\/ Back drop...\n    \n    vec3 gro = ground(sky, dir, camPos);\n\t\n    col = mix(col, gro, clamp(1.0-alphaAcc, 0.0, 1.0));\n    \n    \n    if (dStack[0] < 0.0) dStack[0] = 4000.0;\n    col = clouds(col,camPos, dir, dStack[0], ti);\n    \n        \/\/ Overlay...\n    float scan = overlay(camPos, dir)*scannerOn;\n\tcol = min(col+vec3(scan*.6, scan*.75, scan), 1.0);\n\n    \n    \n\t\/\/---------------------------------------------------------\n\t\/\/ Post effects...\n    col = col*0.5 + 0.5*col*col*(3.0-2.0*col);\t\t\t\t\t\/\/ Slight contrast adjust\n    col = sqrt(col);\t\t\t\t\t\t\t\t\t\t\t\/\/ Adjust Gamma \n    \/\/ I can't decide if I like the added noise or not...\n    \/\/col = clamp(col+hash32(xy+ti)*.11, 0.0, 1.0); \t\t\t\t\t\/\/ Random film noise\n\n    \n    col *= .6+0.4*pow(50.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.2 );\t\/\/ Vignette\n    col *= smoothstep(0.0, .5, ti)*smoothstep(58.0, 53., ti);\n\toutColour = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3Rn","filepath":"\/media\/a\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"\/media\/ap\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsfGRr","channel":0}],"code":"\/\/ [SIG15] Oblivion [sound code]\n\/\/ by David Hoskins.\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ The sound includes a vocoded 'aaah' and \"Tech 4-9, Jack Harper\" with formants collected straight from the film.\n\/\/ Speech coefficients created using Wavesurfer:\n\/\/ http:\/\/sourceforge.net\/projects\/wavesurfer\/\n\n\n#define TWO_PI \t\t\t6.2831\n#define MOD2 vec2(.16632,.17369)\n#define MOD3 vec3(.16532,.17369,.15787)\n#define PLAY_PHRASES\n\n#define cueINCLOUDS 0.0\n#define cueFLYIN 14.0\n#define cueFRONTOF cueFLYIN + 10.0\n#define cueTHREAT cueFRONTOF + 5.\n#define cueFLYOFF cueTHREAT + 19.0\n\nfloat n1 = 0.0;\nfloat n2 = 0.0;\nfloat fb_lp = 0.0;\nfloat lfb_lp = 0.0;\nfloat hp = 0.0;\nfloat p4=1.0e-24;\nvec3 drone;\nfloat gTime;\nfloat speed, height;\n\n#define TAU  6.28318530718\n#define NT(a, b, c) if(t > a){x = a; n = b; ty = c;}\n#define P(a, b, c, d, e, f) if(t >= sec){x = sec; pit = ivec2(a, b), form = ivec4(c, d, e, f);} if(t+step >= sec){pit2 = ivec2(a, b),  form2 = ivec4(c, d, e, f);} sec+=step;\n\n\n#define N(a, b) if(t > a){x = a; n = b;}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  1 out, 1 in ...\nfloat hash11(float p)\n{\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);\n}\n\n\/\/----------------------------------------------------------------------------------\nfloat tract(float x, float f, float bandwidth)\n{\n    float ret = sin(TAU * f * x) * exp(-bandwidth * 3.14159265359 * x);\n    return ret;\n}\n\n\/\/----------------------------------------------------------------------------------\nfloat noise11(float x)\n{\n    float p = floor(x);\n    float f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return mix( hash11(p), hash11(p + 1.0), f)-.5;\n}\n\n\/\/----------------------------------------------------------------------------------\nfloat Fricative(float x, float f)\n{\n    float ret = hash11(floor(f * x)*20.0)-.5;\n\treturn ret*3.0;\n}\n\n\n\/\/----------------------------------------------------------------------------------\nfloat noteMIDI(float n)\n{\n\treturn 440.0 * pow(2.0, (n - 69.0) \/ 12.0);\n}\n\n\/\/----------------------------------------------------------------------------------\nfloat saw( float x, float a)\n{\n    float f = fract( x );\n\treturn (clamp(f\/a,0.0,1.0)-clamp((f-a)\/(1.0-a),0.0,1.0))*2.0-.5;\n}\n\n\/\/----------------------------------------------------------------------------------\nfloat sqr(float t)\n{\n\treturn step(fract(t), 0.5)-0.5;\n}\n\n\/\/----------------------------------------------------------------------------------\nfloat tri(float t)\n{\n\treturn (abs(fract(t)-0.5)*2.-0.5)*2.;\n}\n\n\/\/----------------------------------------------------------------------------------\nfloat sine(float t)\n{\n\treturn sin(t* 3.141*2.0);\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat softBeep(float t)\n{\n\tfloat n = 0.0;\n    float x = 0.0;\n    float ty = 0.0;\n \n    \/\/NT(cueFRONTOF-4.0, 61., .2);\n    NT(cueFRONTOF-4.0,56., .5);\n    \n    NT(cueFRONTOF+.7, 56., .4);\n    NT(cueFRONTOF+1., 61., .5);\n    \n    float asr = cueFLYOFF-.9;\n    NT(asr+.7, 69.0, .5);\n\n    n = noteMIDI(n);\n    \n    x = t-x;\n    \n\tfloat aud = 0.0;\n      \n    float vol = smoothstep(.0, .05, x) * smoothstep(1.0, .8, x\/ty);\n    aud += sine(x*n*2.0+t)*sine(x*n*.9+t)*smoothstep(0.0, .04, t)*vol*.3;\n    aud = clamp(aud*.9,-1., 1.);\n\n    return aud;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat beeDoop(float t)\n{\n\tfloat n = 0.0;\n    float x = 0.0;\n    float ty = 0.0;\n    \n    NT(cueTHREAT-1.0, 63.0, .14);\n    NT(cueTHREAT-1.0+.14, 51.0, .55);\n\n    NT(cueTHREAT+3.2, 63.0, .14);\n    NT(cueTHREAT+3.2+.14, 51.0, .55);\n\n    n = noteMIDI(n);\n    \n    x = t-x;\n    \n\tfloat aud = 0.0;\n    float vol = smoothstep(.0, .01, x) * smoothstep(1.0, .7, x\/ty);\n    aud = tri(x*n*4.0) * tri(x*n*.5) * sine(x*n*2.)*vol;\n    aud += sine(x*n*2.0+t)*smoothstep(0.0, .04, t)*vol*.3;\n    aud = clamp(aud*.7,-1., 1.);\n\n    return aud;\n}\n\n \/\/----------------------------------------------------------------------------------------\n\/\/ Speech Processing Based on a Sinusoidal Model\n\/\/ For the vocal part I analylised a sample from the film and extracted\n\/\/ the vocal formants, which of course turned out to be an 'aaaah!' :)\n\/\/ https:\/\/www.ll.mit.edu\/publications\/journal\/pdf\/vol01_no2\/1.2.3.speechprocessing.pdf\nfloat aaaah(float t)\n{\n\tfloat n = 0.0;\n    float x = 0.0;\n    float ty = 0.0;\n    \/\/t=  mod(t, 2.0)+cueTHREAT;\n    NT(cueTHREAT, 52., 1.1);\n    NT(cueFLYOFF+2.0, 52., 3.1);\n    \n    n = noteMIDI(n);\n    x = t-x;\n    float vol= smoothstep(.0, .03, x) * smoothstep(1.0, .9, x\/ty)*.5;\n    float pit = smoothstep(.0, .8, x) * smoothstep(1.0, .9, x\/ty);\n    float formSlide = (smoothstep(.3, .0, x) + smoothstep(.8, 1., x\/ty)) * 100.0;\n    pit = pow(pit,.1);\n    pit = (1.0-pit*.001)\/n;\n    \n    t += noise11(x*7.+45.0)*.0008; \/\/ ...Add a bit of random flutter to humanise it.\n\n    \/\/ Build the vocal tract with sine waves...\n    x = mod(t, pit);\n\tfloat aud =\ttract(x, 710.0-formSlide, 70.0) *.5 +\n       \t\t\ttract(x, 1000.0+formSlide, 90.0)  * .6 +\n\t       \t\ttract(x, 2450.0+formSlide, 140.0) * .4;\n   \t    \n    aud = clamp(aud * vol, -1.0, 1.0);\n    return aud;\n}\nfloat tech49(float t)\n{\n    \/\/t = mod(t, 7.0)+ cueTHREAT+4.5; \/\/ ...test\n    float step = .013;\n    float vol = .45;\n    float adjust = 1.0;\n    float sec = cueTHREAT+4.5;\n    if (t > cueTHREAT+6.5 && t < cueTHREAT+13.5)\n    {\n        t-=3.0;\n        vol = .7;\n        step = 0.023;\n        adjust = 1.18;\n    }\n    \n    ivec4 form = ivec4(271,2104,3152,4600), form2 = form;\n    ivec2 pit = ivec2(0\t,0), pit2 = pit;\n    float x = .0;\n\n\t\/\/ Pitch, intensity and formants for...\n    \/\/ \"Tech 4-9, Jack Harper\"\n    \/\/ Uses the output from free software called WaveSurfer:-\n    \/\/ http:\/\/sourceforge.net\/projects\/wavesurfer\/\n    \n    \/\/ It's still a little rough between the frames, but it's getting there.\n    \n    \/\/ I had to hand edit some of these bastards!...\n   \n    \/\/ Pitch or fricative(0) , gain, f1, f2, f3, f4\n    P(0\t,42,\t271,\t2104,\t3152,\t4600);\n    P(0\t,30,\t515,\t1568,\t2589,\t3820);\n    P(0\t,20,\t650,\t1955,\t2644,\t3900);\n    P(154\t,40\t,650    ,1663,\t 2644\t,3900);\n    P(164\t,46\t,557\t,1663\t,2540\t,3532);\n    P(178\t,44\t,576\t,1641\t,2465\t,3399);\n    P(179\t,53\t,604\t,1677\t,2439\t,3368);\n    P(180\t,58\t,610\t,1751\t,2352\t,3272);\n    P(181\t,57\t,594\t,1805\t,2327\t,3211);\n    P(183\t,58\t,573\t,1847\t,2267\t,3195);\n    P(186\t,59\t,554\t,1594\t,1999\t,3120);\n    P(186\t,57\t,534\t,1611\t,1981\t,3097);\n    P(185\t,58\t,512\t,1762\t,1902\t,3205);\n    P(184\t,56\t,429\t,1848\t,2489\t,4087);\n    P(0\t,12\t,350,1600,1900,3900\t );\n    P(0\t,40\t,350,1600,1900,3900\t );\n    P(0\t,30\t,300,1950,2800,4400\t );\n    P(0\t,23\t,300,1950,2800,4400\t\t );\n    P(0\t,17\t,300,1950,2800,4400\t\t );\n    P(0\t,0\t,755\t,1825\t,2511\t,4083\t );\n    P(0\t,0\t,440\t,1811\t,2529\t,4099\t );\n    P(0\t,17\t,287\t,1223\t,2455\t,3977\t );\n    P(0\t,28\t,280\t,1259\t,2338\t,3707\t );\n    P(0\t,32\t,281\t,1288\t,2345\t,3719\t );\n    P(0\t,34\t,281, 1294, 2361,4166\t );\n    P(0\t,35\t,281, 1294, 2361,4166\t );\n    P(0\t,45\t,281, 1294, 2361,4166\t );\n    P(207\t,42\t,487\t,934\t,1791\t,3100);\n    P(214\t,48\t,489\t,993\t,1858\t,3159);\n    P(220\t,55\t,489\t,1005\t,1925\t,3233);\n    P(221\t,58\t,487\t,1014\t,1942\t,3252);\n    P(220\t,57\t,483\t,1038\t,1950\t,3234);\n    P(224\t,56\t,486\t,1057\t,1985\t,3227);\n    P(223\t,56\t,491\t,1058\t,1996\t,3205);\n    P(222\t,56\t,494\t,1078\t,2007\t,3101);\n    P(222\t,56\t,495\t,1320\t,2480\t,3186);\n    P(220\t,56\t,481\t,1523\t,2554\t,3497);\n    P(221\t,55\t,464\t,1539\t,2580\t,3525);\n    P(221\t,55\t,460\t,1547\t,2629\t,3550);\n    P(220\t,50\t,463\t,1562\t,2551\t,3523);\n    P(219\t,37\t,474\t,1573\t,2494\t,3562);\n    P(219\t,35\t,501\t,1604\t,2513\t,3596);\n    P(219\t,40\t,555\t,1650\t,2501\t,3624);\n    P(226\t,45\t,625\t,1598\t,2486\t,3676);\n    P(226\t,57\t,655\t,1562\t,2462\t,3752);\n    P(227\t,57\t,667\t,1552\t,2410\t,3852);\n    P(227\t,58\t,674\t,1552\t,2390\t,3900);\n    P(225\t,57\t,679\t,1549\t,2402\t,3900);\n    P(225\t,58\t,681\t,1537\t,2425\t,3877);\n    P(227\t,57\t,677\t,1513\t,2448\t,3850);\n    P(227\t,56\t,667\t,1504\t,2410\t,3823);\n    P(229\t,58\t,659\t,1536\t,2346\t,3766);\n    P(229\t,58\t,640\t,1604\t,2318\t,3611);\n    P(231\t,57\t,589\t,1791\t,2333\t,3433);\n    P(229\t,55\t,518\t,1852\t,2396\t,4156);\n    P(229\t,57\t,468\t,1907\t,2497\t,4151);\n    P(227\t,56\t,440\t,1973\t,2564\t,4113);\n    P(221\t,54\t,423\t,1970\t,2576\t,4053);\n    P(178\t,54\t,400\t,1857\t,2517\t,4033);\n    P(205\t,44\t,425\t,1690\t,2231\t,3986);\n    P(175\t,32\t,418\t,1566\t,2124\t,3959);\n    P(172\t,38\t,384\t,1569\t,2307\t,3983);\n    P(165\t,47\t,455\t,1783\t,2630\t,3942);\n    P(0,    0, 0, 0, 0, 0);\n    P(0,    0, 0, 0, 0, 0);\n    P(0,    0, 0, 0, 0, 0);\n    P(0,    0, 0, 0, 0, 0);\n\n    P(0,    0, 0, 0, 0, 0);\n    P(0,    20,480\t,1840\t,2697\t,3859);\n    P(177,  40,\t174,1914,3509,3900);\n    P(0\t,   34,\t174,1914,3509,3900);\n    P(0\t,\t25,\t174,\t1914,\t2609,3900);\n    P(0\t,\t 10\t,405\t,1843\t,2603\t,3851);\n    P(177\t,46\t,445\t,1807\t,2487\t,2996);\n    P(200\t,47\t,472\t,1780\t,2465\t,3037);\n    P(219\t,48\t,509\t,1755\t,2454\t,3096);\n    P(227\t,54\t,614\t,1746\t,2435\t,3143);\n    P(227\t,56\t,658\t,1747\t,2421\t,3163);\n    P(220\t,53\t,661\t,1747\t,2409\t,3153);\n    P(222\t,53\t,662\t,1732\t,2365\t,3132);\n    P(220\t,57\t,662\t,1730\t,2426\t,3162);\n    P(219\t,59\t,659\t,1739\t,2506\t,3271);\n    P(217\t,59\t,652\t,1732\t,2440\t,3288);\n    P(216\t,58\t,635\t,1728\t,2347\t,3236);\n    P(215\t,57\t,609\t,1748\t,2277\t,3221);\n    P(209\t,57\t,585\t,1798\t,2202\t,3301);\n    P(205\t,57\t,547\t,1860\t,2126\t,3292);\n    P(200\t,56\t,367\t,1952\t,3296\t,4100);\n    P(178\t,44\t,282\t,1943\t,3417\t,4117);\n    P(0\t,03\t,322\t,1959\t,2548\t,4132\t );\n    P(0\t,27\t,409\t,1826\t,2560\t,4125\t );\n    P(0\t,0\t,331,1761,2488,3921\t );\n    P(0\t,0\t,331,1761,2488,3921\t );\n    P(0\t,30\t,331,1761,2488,3921\t );\n    P(0\t,38\t,331,1761,2488,3921\t );\n    P(0\t,40\t,331,1761,2488,3921\t );\n    P(189\t,35\t,600\t,1300\t,2020\t,3912);\n    P(193\t,44\t,621\t,1290\t,2070\t,3972);\n    P(201\t,50\t,636\t,1203\t,2070\t,4011);\n    P(208\t,53\t,643\t,1097\t,2004\t,4119);\n    P(217\t,54\t,644\t,1084\t,1987\t,4227);\n    P(220\t,55\t,642\t,1095\t,2109\t,4224);\n    P(217\t,57\t,642\t,1115\t,2067\t,4193);\n    P(215\t,54\t,643\t,1120\t,1923\t,4078);\n    P(214\t,54\t,647\t,1138\t,1842\t,3808);\n    P(216\t,56\t,650\t,1169\t,1801\t,3762);\n    P(218\t,56\t,652\t,1237\t,1790\t,3768);\n    P(220\t,55\t,648\t,1275\t,1784\t,3763);\n    P(223\t,53\t,621\t,1256\t,1763\t,3629);\n    P(225\t,50\t,533\t,1123\t,1636\t,3516);\n    P(222\t,52\t,386\t,1006\t,1563\t,3361);\n    P(192\t,48\t,255\t,1203\t,2528\t,3211);\n    P(183\t,35\t,304\t,1151\t,2209\t,3086);\n    P(156\t,29\t,303\t,841\t,1900\t,2698);\n    P(154\t,7\t,260\t,895\t,1884\t,2635);\n    P(168\t,8\t,217\t,957\t,2642\t,3825);\n    P(0  \t,38\t,254\t,980\t,1873\t,2688);\n    P(148\t,28\t,338\t,1142\t,1659\t,3780);\n    P(143\t,26\t,436\t,1171\t,1594\t,3789);\n    P(179\t,25\t,464\t,1191\t,1585\t,3822);\n    P(162\t,31\t,465\t,1211\t,1574\t,3756);\n    P(231\t,44\t,462\t,1235\t,1567\t,3678);\n    P(229\t,53\t,461\t,1252\t,1557\t,3670);\n    P(229\t,53\t,461\t,1252\t,1557\t,3670);\n    P(226\t,52\t,459\t,1273\t,1548\t,3658);\n    P(224\t,57\t,468\t,1300\t,1597\t,3665);\n    P(222\t,56\t,492\t,1317\t,1605\t,3715);\n    P(217\t,52\t,492\t,1342\t,1587\t,3734);\n    P(209\t,49\t,444\t,1424\t,1612\t,3770);\n    P(198\t,46\t,399\t,1463\t,1755\t,2960);\n    P(179\t,38\t,303\t,1423\t,1831\t,2912);\n    P(0,    0, 0, 0, 0, 0);\n    P(0,    0, 0, 0, 0, 0);\n\n    x = t - x;\n    float sm = clamp(x\/step, 0.0,1.0);\n\n  \n    float aud = 0.0;\n    float fric = 0.0;\n    float intensity = pow(8.0, float(pit.y)\/19.0) * .001;\n    float intensity2 = pow(8.0, float(pit2.y)\/19.0) * .001;\n    \n    intensity = mix(intensity, intensity2, sm);\n    vec4 formants  = mix(vec4(form), vec4(form2), sm);\n    \n    if (pit.x > 0)\n    {\n\n  \t\tfloat p = 1.0\/(float(pit.x)*adjust);\n        if (pit2.x > 0)\n        {\n\t       \tfloat p2 = 1.0\/(float(pit2.x)*adjust);\n            p = max(mix(p, p2, sm), 0.);\n        }\n\n        float a = mod(x, p); \n\t\taud =\ttract(a, formants.x, 70.0) +\n      \t\t\ttract(a, formants.y, 90.0)  * .7 +\n\t       \t\ttract(a, formants.z, 140.0) * .6 + \n        \t\ttract(a, formants.w, 210.0) * .4;\n        aud *= intensity;\n    }\n    else\n    {\n         vec4 formants  = vec4(form);\n         fric += Fricative(t, formants.x) +\n      \t\t\tFricative(t, formants.y) +\n       \t\t\tFricative(t, formants.z)*1.8;\n        aud = fric*intensity*.25;\n    }\n  \n\n\taud = clamp(aud*vol, -1.0, 1.0);\n    \n    return aud;\n\n}\n\n\n\/\/----------------------------------------------------------------------------------------\nfloat beepPong(float t)\n{\n\tfloat n = 0.0, x = 0.0, ty = 0.0;\n    float asr = cueFLYOFF-4.;\n    \/\/t = mod(t, 3.0) + cueFLYOFF-3.5;\n    NT(asr, 93.0, .2);\n    NT(asr+0.1, 69.0, .3);\n    NT(asr+.3, 81.0, .55);\n    n = noteMIDI(n);\n    x = t-x;\n\tfloat aud = 0.0;\n    asr = min((t-asr)*18.0, 1.0);\n    float vol = smoothstep(.0, .002, x) * smoothstep(1.0, .1, x\/ty)*asr;\n    aud = sine(x*n)*vol;\n   \taud += sine(x*n*.99+t)*smoothstep(0.0, .04, t)*vol*.3;\n    aud = clamp(aud*.3,-1., 1.);\n\n    return aud;\/\/(1.5 * aud - 0.5 * aud * aud * aud);\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat boom(float t)\n{\n\tfloat n = 0.0, x = 0.0, ty = 0.0;\n    \/\/t = mod(t, 2.)+cueFLYOFF-.9;\n    float asr = cueFLYOFF-.9;\n\n    NT(asr+0.3, 33.0, .1);\n    NT(asr+.6, 29.0, .1);\n    NT(asr+.9, 26.0, .2);\n    \n    n = noteMIDI(n);\n    x = t-x;\n    \n\tfloat aud = 0.0;\n    float vol = smoothstep(.0, .002, x) * smoothstep(1.0, .9, x\/ty);\n    n-=x*50.0;\n    aud = tri(x*n);\n    aud += tri(x*n*2.0);\n    aud = clamp(aud*vol,-1., 1.);\n\n    return (1.5 * aud - 0.5 * aud * aud * aud)*.7;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat scanner(float t)\n{\n    float n = noteMIDI(21.0);\n     float   scannerOn = smoothstep(cueTHREAT+4.0,cueTHREAT+4.2, t)* smoothstep(cueTHREAT+11.5,cueTHREAT+11.2, t);\n    float r = sin(t*2.) * scannerOn;\n    float vol= (smoothstep(0.4, 0.0,abs(r-.4))+.2) * scannerOn;\n\tfloat b = abs(sin(t*8.0))*.3;\n    \n    float aud = (saw(t*n*2.0, 1.)+saw(t*n*2.1, 1.))*.2;\n    aud += saw(t*n*4.0, .6+b)+saw(t*n*4.01, .6+b);\n    aud = clamp(aud*vol,-1., 1.);\n    return aud;\/\/(1.5 * aud - 0.5 * aud * aud * aud);\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec2 deepFuzz(float t)\n{\n\tfloat n = 0.0;\n    float x = 0.0;\n    float ty = 0.0;\n    \n    NT(cueFRONTOF-2.2, 28., .5);\n    NT(cueFRONTOF-1.2, 28., .5);\n\n    NT(cueTHREAT+1.2, 28., .5);\n    NT(cueTHREAT+2.2, 28., .5);\n    \n    NT(cueTHREAT+10.+1.2, 28., .5);\n    NT(cueTHREAT+10.+2.2, 28., 1.5);\n   \n    n = noteMIDI(n);\n    x = t-x;\n    \n    float vol= smoothstep(.0, .0, x) * smoothstep(1.0, .98, x\/ty);\n    \n    vol *= smoothstep(cueFRONTOF, cueFRONTOF+.2, t)*.9+.1;\n    float pit = 1.0+sqr(t*250.0)*.02;\n    vec2 aud = vec2(0.0);\n    aud.x += saw(t*n*pit, 1.)+saw(t*n*1.01*pit, 1.)+saw(t*n*4.0*pit, 1.);\n    aud.y += saw(t*n*pit, 1.)+saw(t*n*.99*pit, 1.)+saw(t*n*4.0*pit, 1.);\n    aud = clamp(aud * vol*.5, -1.0, 1.0);\n    return aud;\/\/(1.5 * aud - 0.5 * aud * aud * aud);\n}\n    \n\/\/----------------------------------------------------------------------------------------\nvec3 dronePath(float ti)\n{\n    vec3 p = vec3(-2030, 340, 2200.0);\n    p = mix(p, vec3(-2030, 340, 2000.0),\t\tsmoothstep(cueINCLOUDS, cueFLYIN-.5, ti));\n    p = mix(p, vec3(-30.0, 18.0, 300.0),\t\tsmoothstep(cueFLYIN, cueFLYIN+4.0, ti));\n    p = mix(p, vec3(-35.0, 25.0, 10.0), \t\tsmoothstep(cueFLYIN+4.0,cueFLYIN+8.0, ti));\n    p = mix(p, vec3(30.0, 0.0, 15.0), \t\t\tsmoothstep(cueFRONTOF+.5,cueFRONTOF+2.5, ti)); \/\/..\/ Move to front of cam.\n    p = mix(p, vec3(0.0, 8.0, .0), \t\t\t\tsmoothstep(cueTHREAT, cueTHREAT+.5, ti)); \t\/\/ ...Threaten\n    p = mix(p, vec3(0.0, 8.0, -4.0), \t\t\tsmoothstep(cueTHREAT+2.0, cueTHREAT+2.3, ti)); \t\/\/ ...Threaten\n    p = mix(p, vec3(0.0, 8., -12.0), \t\t\tsmoothstep(cueTHREAT+3.0, cueTHREAT+3.3, ti)); \t\/\/ ...Threaten\n    p = mix(p, vec3(0.0, 110.0, 0.0), \t\t\tsmoothstep(cueFLYOFF,cueFLYOFF+1.5, ti)); \/\/ ...Fly off\n    p = mix(p, vec3(4000.0, 110.0, -4000.0), \tsmoothstep(cueFLYOFF+2.6,cueFLYOFF+10.0, ti)); \n    return p; \n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 cameraAni(float ti)\n{\n    vec3 p;\n    p = mix(drone-vec3(0.0,0.0, 10.0), drone-vec3(0.0,0.0, 20.0), smoothstep(cueINCLOUDS,cueINCLOUDS+2.0, ti));\n    p = mix(p, drone-vec3(17.0,-14.0, 35.0), smoothstep(cueINCLOUDS+2.0,cueFLYIN-3.0, ti));\n    p = mix(p, vec3(0.0, 0.0, -28.0), step(cueFLYIN, ti));\n\tp = vec3(p.xy, mix(p.z, -40.0, smoothstep(cueTHREAT,cueTHREAT+4.0, ti)));\n    return p;\n}\n\n\n\/\/----------------------------------------------------------------------------------------\nfloat engines(float ti)\n{\n\tfloat  t = ti+ sin(height*.7)*.3+1.0;\n\tfloat t1 = texture(iChannel1, vec2(t*(2.44),t*11.33), -4.0).x *  .5-.25;\n\tt1 += texture(iChannel1, vec2(t*(2.44),t*1.33), -99.0).x -.5;\n    float t2 = texture(iChannel0, vec2(ti*13.81,ti*4.73), -4.0).x * .5-.25;\n    t2 += texture(iChannel0, vec2(ti*13.81,ti*14.54), -99.0).x * .08-.04;\n\tfloat f = mix(t1, t2, speed);\n\tf+= clamp((texture(iChannel1, vec2(ti*5.44,t*12.33), -99.0).x*2.0-1.) *(smoothstep(cueFLYOFF+.0, cueFLYOFF+2.8, ti))*4.0, -1.,1.);\n    f += (texture(iChannel0, vec2(ti*2.4413,ti*4.1375), -3.).x*2.0-1.);\n\treturn clamp(f*(speed+.5), -1.0, 1.0);\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec2 droneGunAni(float ti)\n{\n    vec2 a;\n   \tfloat mov;\n    mov = smoothstep(cueFLYOFF-1., cueFLYOFF-3.0, ti);\n    mov = mov*3.1-1.4;\n    a.x = (sin(mov)+1.0)*1.5;\n    a.y = smoothstep(.3,.7,sin(mov))*3.0;\n    return a;\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec2 guns(float ti)\n{\n\tvec2 a;\n    vec2 ga = droneGunAni(ti);\n    a = texture(iChannel0, vec2(ga.x*14.4,ga.x*21.33), -99.0).xy-.5;\n    a -= texture(iChannel0, vec2(ga.x*14.4,ga.x*21.33), -3.0).xy-.5;\n    a *= .3;\n    a += texture(iChannel1, vec2(ga.y*1.44,ga.y*1.03), -99.0).xy*2.0-1.;\n    return a*.5;\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec2 allsounds(float t)\n{\n    vec2 audio = vec2(0);\n\taudio = vec2(beeDoop(t));\n    audio += vec2(aaaah(t));\n    audio += vec2(deepFuzz(t));\n    audio += vec2(beepPong(t));\n    audio += engines(t);\n    audio += vec2(scanner(t));\n    audio = clamp(audio, -1.0, 1.0);\n    audio *= smoothstep(cueFLYOFF-.3, cueFLYOFF-.8, t)+smoothstep(cueFLYOFF, cueFLYOFF+.3, t);\n    audio += vec2(boom(t));\n    audio += vec2(softBeep(t));\n    audio += guns(t);\n    audio *= smoothstep(cueFLYIN, cueFLYIN-.2, t)  + smoothstep(cueFLYIN, cueFLYIN+.2, t);\n    audio += vec2(tech49(t));\n    return audio*.8;\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec2 mainSound( in int samp,float time)\n{\n\t float ti = mod(time, 57.);\n     \/\/ Tests cues...\n\/\/   float ti = mod(time, 45.0);\n   \/\/float ti = mod(time, 6.5)+cueFRONTOF;\n   \/\/float ti = mod(time, 15.)+cueTHREAT+1.0;\n   \/\/float ti = mod(time, 8.5)+cueFLYOFF-2.5;\n    \n    drone = dronePath(ti);\n    vec3 camPos = cameraAni(ti);\n    float l = max(length(drone-camPos)-20.0, 1.);\n    speed = clamp(length(drone -dronePath(ti-.08)),0.0, 1.1);\n    height = drone.y;\n    float disAtten = clamp(7330.0\/(l*l), 0.0, 1.0);\n\n   \tvec2 audio = allsounds(ti)*disAtten;\n    \/\/ Echo, echo echo...\n\taudio += allsounds(ti-.3)*.12 * vec2(1.0, .3)*disAtten;\n    audio += allsounds(ti-.6)*.06 * vec2(.3, 1.)*disAtten;\n    audio += allsounds(ti-.9)*.03 * vec2(1., .3)*disAtten;\n    \/\/audio += allsounds(ti-.12)*.025 * vec2(.3, 1.)*disAtten;.\/\/ ...too much!\n    \n    return audio * smoothstep(0.0, 2., ti) * smoothstep(57.0, 55., time);\n}\n\n","name":"Sound","description":"","type":"sound"}]},{"ver":"0.1","info":{"id":"flGyDd","date":"1662408326","viewed":11215,"name":"Refraction + post proc","username":"mrange","description":"CC0: Refraction + post proc\nAdded a bit of post processing to the earlier refraction experiment\n","likes":151,"published":3,"flags":32,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ CC0: Refraction + post proc\n\/\/ Added a bit of post processing to the earlier refraction experiment\n\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n\n\n\/\/ License: Unknown, author: nmz (twitter: @stormoid), found: https:\/\/www.shadertoy.com\/view\/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1.\/2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n\/\/ License: Unknown, author: Matt Taylor (https:\/\/github.com\/64), found: https:\/\/64.github.io\/tonemapping\/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))\/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord\/RESOLUTION.xy;\n  vec3 col = vec3(0.0);\n  col = texture(iChannel0, q).xyz;\n  col = aces_approx(col);\n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define PHI             (sqrt(5.0)*0.5 + 0.5)\n\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n\n#define TOLERANCE       0.0001\n#define MAX_RAY_LENGTH  20.0\n#define MAX_RAY_MARCHES 60\n#define NORM_OFF        0.001\n#define MAX_BOUNCES     6\n\nmat3 g_rot  = mat3(1.0); \nvec3 g_mat  = vec3(0.0);\nvec3 g_beer = vec3(0.0);\n\n\/\/ License: WTFPL, author: sam hocevar, found: https:\/\/stackoverflow.com\/a\/17897228\/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 \/ 3.0, 1.0 \/ 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n\/\/ License: WTFPL, author: sam hocevar, found: https:\/\/stackoverflow.com\/a\/17897228\/418488\n\/\/  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst float hoff = 0.0;\n\nconst vec3 skyCol     = HSV2RGB(vec3(hoff+0.6, 0.86, 1.0));\nconst vec3 glowCol    = HSV2RGB(vec3(hoff+0.065, 0.8, 6.0));\nconst vec3 diffuseCol = HSV2RGB(vec3(hoff+0.6, 0.85, 1.0));\nconst vec3 lightPos   = vec3(0.0, 10.0, 0.0);\n\nconst float initt       = 0.1; \n\n\/\/ License: MIT, author: Inigo Quilez, found: https:\/\/iquilezles.org\/www\/articles\/distfunctions2d\/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n\/\/ License: MIT, author: Inigo Quilez, found: https:\/\/iquilezles.org\/www\/articles\/intersectors\/intersectors.htm\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)\/dot(rd,p.xyz);\n}\n\nmat3 rot_z(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n      c,s,0\n    ,-s,c,0\n    , 0,0,1\n    );\n}\n\nmat3 rot_y(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n      c,0,s\n    , 0,1,0\n    ,-s,0,c\n    );\n}\n\nmat3 rot_x(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n      1, 0,0\n    , 0, c,s\n    , 0,-s,c\n    );\n}\n\nfloat sphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\n\/\/ License: MIT, author: Inigo Quilez, found: https:\/\/iquilezles.org\/articles\/distfunctions2d\/\nfloat flatTorus(vec3 p, vec2 dim) {\n  float d = length(p.xy)-dim.x;\n  d = abs(d) - dim.y;\n  vec2 w = vec2(d, abs(p.z) - dim.y);\n  return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  vec3 col = clamp(vec3(0.0025\/abs(rd.y))*skyCol, 0.0, 1.0);\n\n  float tp0  = rayPlane(ro, rd, vec4(vec3(0.0, 1.0, 0.0), 4.0));\n  float tp1  = rayPlane(ro, rd, vec4(vec3(0.0, -1.0, 0.0), 6.0));\n  float tp = tp1;\n  tp = max(tp0,tp1);\n\n\n  if (tp1 > 0.0) {\n    vec3 pos  = ro + tp1*rd;\n    vec2 pp = pos.xz;\n    float db = box(pp, vec2(6.0, 9.0))-1.0;\n    \n    col += vec3(4.0)*skyCol*rd.y*rd.y*smoothstep(0.25, 0.0, db);\n    col += vec3(0.8)*skyCol*exp(-0.5*max(db, 0.0));\n  }\n\n  if (tp0 > 0.0) {\n    vec3 pos  = ro + tp0*rd;\n    vec2 pp = pos.xz;\n    float ds = length(pp) - 0.5;\n    \n    col += vec3(0.25)*skyCol*exp(-.5*max(ds, 0.0));\n  }\n\n  return clamp(col, 0.0, 10.0);\n}\n\nfloat df(vec3 p) {\n  p *= g_rot;\n  const mat2 rot0 = ROT(0.5);\n  const mat2 rot1 = ROT(1.0);\n  vec3 p0 = p;\n  vec3 p1 = p;\n  vec3 p2 = p;\n\n  p1.zx *= rot0;\n  p2.zy *= rot1;\n  const float w = 0.2;\n  const float rnd = 0.025;\n  float d0 = flatTorus(p0, vec2(2.0, w))-rnd;\n  float d1 = flatTorus(p1, vec2(1.4, w))-rnd;\n  float d2 = flatTorus(p2, vec2(0.8, w))-rnd;\n  float d3 = sphere(p, 0.4);\n  \n  vec3 mat = vec3(0.9, 0.5, 0.8);\n  const vec3 gcol = -2.5*(HSV2RGB(vec3(0.025, 0.925, 1.0)));\n\/\/  const vec3 gcol = 3.5*(1.0-HSV2RGB(vec3(0.025, 0.9, 1.0)));\n  vec3 beer = gcol;\n  \n  float d = d0;\n  d = min(d, d1);\n  d = min(d, d2);\n  if (d3 < d) {\n    const vec3 gcol = -10.*(HSV2RGB(vec3(0.06, 0.65, 1.0)));\n    beer = gcol;\n    d = d3;\n  }\n\n  g_mat = mat;\n  g_beer = beer;\n  return d;\n}\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, float dfactor, out int ii) {\n  float t = 0.0;\n  float tol = dfactor*TOLERANCE;\n  ii = MAX_RAY_MARCHES;\n  for (int i = 0; i < MAX_RAY_MARCHES; ++i) {\n    if (t > MAX_RAY_LENGTH) {\n      t = MAX_RAY_LENGTH;    \n      break;\n    }\n    float d = dfactor*df(ro + rd*t);\n    if (d < TOLERANCE) {\n      ii = i;\n      break;\n    }\n    t += d;\n  }\n  return t;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 agg = vec3(0.0, 0.0, 0.0);\n  vec3 ragg = vec3(1.0);\n\n  bool isInside = df(ro) < 0.0;\n\n  for (int bounce = 0; bounce < MAX_BOUNCES; ++bounce) {\n    float dfactor = isInside ? -1.0 : 1.0;\n    float mragg = min(min(ragg.x, ragg.y), ragg.z);\n    if (mragg < 0.025) break;\n    int iter;\n    float st = rayMarch(ro, rd, dfactor, iter);\n    const float mrm = 1.0\/float(MAX_RAY_MARCHES);\n    float ii = float(iter)*mrm;\n    vec3 mat = g_mat;\n    if (st >= MAX_RAY_LENGTH) {\n      agg += ragg*skyColor(ro, rd);\n      break; \n    }\n\n    vec3 sp = ro+rd*st;\n\n    vec3 sn = dfactor*normal(sp);\n    float fre = 1.0+dot(rd, sn);\n\/\/    fre = clamp(abs(fre), 0.0, 1.0);\n    fre *= fre;\n    fre = mix(0.1, 1.0, fre);\n\n    vec3 ld     = normalize(lightPos - sp);\n\n    float dif   = max(dot(ld, sn), 0.0); \n    vec3 ref    = reflect(rd, sn);\n    float re    = mat.z;\n    float ire   = 1.0\/re;\n    vec3 refr   = refract(rd, sn, !isInside ? re : ire);\n    vec3 rsky   = skyColor(sp, ref);\n    vec3 col = vec3(0.0);    \n    col += diffuseCol*dif*dif*(1.0-mat.x);\n    float edge = smoothstep(1.0, 0.9, fre);\n    col += rsky*mat.y*fre*vec3(1.0)*edge;\n    if (isInside) {\n      ragg *= exp(-st*g_beer);\n    }\n    agg += ragg*col;\n\n    if (refr == vec3(0.0)) {\n      rd = ref;\n    } else {\n      ragg *= mat.x;\n      isInside = !isInside;\n      rd = refr;\n    }\n\n    \/\/ TODO: if beer is active should also computer it based on initt    \n    ro = sp+initt*rd;\n  }\n\n  return agg;\n}\n\nvec3 effect(vec2 p) {\n  g_rot = rot_x(-0.3*TIME)*rot_z(0.5*TIME);\n  vec3 ro = 0.9*vec3(0.0, 2.0, 5.0);\n  const vec3 la = vec3(0.0, 0.0, 0.0);\n  const vec3 up = vec3(0.0, 1.0, 0.0);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  const float fov = tan(TAU\/6.);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n\n  vec3 col = render(ro, rd);\n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord\/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x\/RESOLUTION.y;\n  vec3 col = vec3(0.0);\n  col = effect(p);\n  fragColor = vec4(col, 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\nconst mat2 brot = ROT(2.399);\n\/\/ License: Unknown, author: Dave Hoskins, found: Forgot where\nvec3 dblur(vec2 q,float rad) {\n  vec3 acc=vec3(0);\n  const float m = 0.0025;\n  vec2 pixel=vec2(m*RESOLUTION.y\/RESOLUTION.x,m);\n  vec2 angle=vec2(0,rad);\n  rad=1.;\n  const int iter = 30;\n  for (int j=0; j<iter; ++j) {  \n    rad += 1.\/rad;\n    angle*=brot;\n    vec4 col=texture(iChannel1,q+pixel*(rad-1.)*angle);\n    acc+=clamp(col.xyz, 0.0, 10.0);\n  }\n  return acc*(1.0\/float(iter));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord\/RESOLUTION.xy;\n  vec2 p = -1.0+2.0*q;\n  vec2 p2 = 0.9*p;\n  vec2 q2 = 0.5+0.5*p2;\n  const vec2 off = 0.0125*vec2(0.0, -1.0);\n  p.x *= RESOLUTION.x\/RESOLUTION.y;\n\n  float pp = smoothstep(0.0, 1.0, sin(0.25*TAU*TIME));\n  float bf = mix(0.66, 0.75, pp)*smoothstep(mix(0.65, 0.85, pp), 0.0, dot(p, p));\n  vec3 bcol = bf > 0.05 ? dblur(q2, mix(0.5, 1.0, pp)) : vec3(0.0);\n\n  vec3 col = vec3(0.0);\n  col = texture(iChannel0, q).xyz;\n  col += bcol*bf;\n  fragColor = vec4(col, 1.0);\n}\n","name":"Buffer B","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"lsKSWR","date":"1463853411","viewed":11196,"name":"Simple vignette effect","username":"Ippokratis","description":"A simple vignette shader","likes":41,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n   \n    uv *=  1.0 - uv.yx;   \/\/vec2(1.0)- uv.yx; -> 1.-u.yx; Thanks FabriceNeyret !\n    \n    float vig = uv.x*uv.y * 15.0; \/\/ multiply with sth for intensity\n    \n    vig = pow(vig, 0.25); \/\/ change pow for modifying the extend of the  vignette\n\n    \n    fragColor = vec4(vig); \n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"MldXWX","date":"1482007643","viewed":11173,"name":"curtain and ball","username":"archee","description":"This is my xmas present to the Shadertoy community.\nCloth simulation of 128x64 vertex. Wind, collision. 60fps on gtx970\nRendered as 1024x512 voxels with spatial tree. I have never seen this rendering method in Shadertoy.\n","likes":289,"published":3,"flags":32,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"\/media\/a\/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"\/media\/ap\/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/*\n  128x64 vertex cloth simulation with collision, wind\n\n  try to guess, how it works before reading :D\n\n*\/\n\n#define SIZX 128.0\n#define SIZY 64.0\n\n#define SIZYPHYS (SIZY+2.0)\n\nfloat mytime = 0.0; \/\/ timing stored in texture to deal with frame skip\n\nconst float maxextentionratio = 1.15;\n\n\nconst float ballradius = 0.99 * 64.0*0.3;\nvec3 ballpos()\n{\n    return vec3(128.0*0.4,64.0*0.7,64.0*(cos(mytime\/3.0)*0.8));;\n}\n\nvec3 lighting(vec3 normal)\n{\n\treturn vec3(dot(normal,normalize(vec3(0.5,1.0,0.0)))*0.5+0.5);    \n}\n\nvec4 background(vec3 campos,vec3 camdir)\n{\n\treturn vec4(vec3(atan(camdir.y*8.0)*-0.5+0.5),9999.0)    ;\n}\n\nvec3 getpos(vec2 uv)\n{\n    return textureLod(iChannel1,vec2((uv+0.5)\/iResolution.xy),0.0).xyz;\n}\n\n\nvec3 rotatex(vec3 v,float anglex)\n{\n\tfloat t;\n\tt =   v.y*cos(anglex) - v.z*sin(anglex);\n\tv.z = v.z*cos(anglex) + v.y*sin(anglex);\n\tv.y = t;\n\treturn v;\n}\n\nfloat anglex = 0.1;\nfloat angley = 0.0;\n\nvec3 rotcam(vec3 v)\n{\n\tfloat t;\n\tv = rotatex(v,anglex);\n\t\n\tt = v.x * cos(angley) - v.z*sin(angley);\n\tv.z = v.z*cos(angley) + v.x*sin(angley);\n\tv.x = t;\n\treturn v;\n}\n\n\nvec3 findnormal(vec2 uv)\n{\n    return normalize(cross(getpos(uv+vec2(1.0,0.0))-getpos(uv-vec2(1.0,0.0)),getpos(uv+vec2(0.0,1.0))-getpos(uv-vec2(0.0,1.0))));\n}\n\nvec4 raytrace_curtain_background_rail(vec3 campos,vec3 camdir)\n{\n    \/\/ raycast 1024*512 voxels with spatial tree\n    \/\/ note that the cloth has only 128x64 vertices, \n    \/\/ but linear filtered reading of the positions texture oversamples it\n    \n    const float minst = 1.0\/8.0; \/\/ oversampling voxelgeometry by 8x8 \n    const float voxelsize = minst*0.77*maxextentionratio;\n    float mindept=999.0;\n    vec2 c = vec2(0.0,0.0);\n    vec2 minc=vec2(-1.0,-1.0);\n    float st = SIZY;\n    float levelup=0.0;\n    \n    \n    float cnt=0.0;\n    for(float i=0.0;i<5000.0;i+=1.0) \/\/ less than 200 iterations for most pixels\n    {\n        cnt+=1.0;\n            \n        vec3 wp = getpos(c);\n        \n        if (st==minst)\n        {\n        \tfloat d=length( cross(wp-campos,camdir) );\n        \tif (d<=voxelsize)\n        \t{\n                float dept = dot(camdir,wp);\n                if (dept<mindept)\n                {\n                    mindept = dept;\n                    minc = c;\n                }\n\t        }\n            \n        \tif (st==minst)            \n\t            levelup=1.0;\n        }\n        \n        vec3 boundingcenter= getpos(c.xy + vec2(st*0.5));\n\n        if (  length( cross(boundingcenter-campos,camdir) )>st*0.79*maxextentionratio )\n        {\n            levelup=1.0;\n        }\n        \n        \n        \n        if (levelup>0.0)\n        {\n            levelup=0.0;\n            \n            if ( fract(c.x\/st\/2.0)<0.25 )\n            {\n                c.x += st;\n            }\n            else\n            {\n                c.x -= st;            \n\n                if ( fract(c.y\/st\/2.0)<0.25 )\n                {\n                    c.y += st;\n                }\n                else\n                {\n                    c.y -= st;\n                    st *= 2.0;\n                    levelup=1.0;\n                }\n            }\n        }\n        else\n        {\n            \n            if (st>minst) st\/=2.0;\n            \n        }\n        \n\/\/        if (c.x>=SIZX) break;    \n        if (c.y>=SIZY) break;    \n    }\n    \n    if (minc.x>=0.0)\n    {\n        vec3 diffuse;\n        diffuse = clamp( (texture(iChannel0,vec2(minc.x\/SIZX,minc.y\/SIZX)).xyz-0.3)*-30.0,0.7,1.0)*1.5;\n        \n        vec3 normal = findnormal(minc);\n        \n        if ( dot(camdir,normal) < -0.1) \/\/ back side detection with antibug cheat\n        {\n            normal*=-1.0;  \/\/ backside color of curtian\n            diffuse*=vec3(0.5,0.7,1.0);\n        }\n        else\n        {\n\t\t\tdiffuse*=vec3(1.0,0.8,0.6); \/\/ front color \n        }\n        \n        mindept-=dot(campos,camdir);\n        vec3 hitpos = campos + camdir*mindept;\n        \n        \/\/ ball analitic ambient occlusion on curtian\n        float aaom = clamp( (hitpos.y-ballpos().y)\/ballradius,-1.0,1.0)*0.5+0.5;\n        \n        float balld = length(hitpos-ballpos());\n        float aao = 1.0 - aaom * max(dot(normal,(hitpos-ballpos())),0.0)\/balld\/balld\/balld*ballradius*ballradius*1.3;\n        \n\/\/        aao = 1.0;\n        \n        return  vec4(diffuse*lighting(normal)*aao,mindept);\n        \n    }\n    else\n    {\n        vec3 dir = camdir; \/\/ quick anti aliased 3d line\n        dir.x = 0.0;\n        vec3 p2 = campos;\n        p2.x = 0.0;\n        float rod = min(length(cross(normalize(dir),p2))\/0.8,1.0);\n        if (dot(dir,p2)>0.0) rod = 1.0;\n        float mul = rod;\n        return background(campos,camdir)*vec4(mul,mul,mul,1.0);\n    }\n    \n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\/\/    mytime = float(iFrame) \/ 60.0;\n    mytime = getpos(vec2(0.0,SIZYPHYS)).x;\n    \n    float zoom = 1.4;\n    float zoomamt = clamp(sin((mytime)\/2.0+0.5)*-3.0+1.2,0.0,1.0);\n    \n    angley = cos((mytime+2.0)*0.1)*1.3;\n    anglex = max(-0.05,-ballpos().z\/SIZY*0.5);\n    \n    \n    fragColor = vec4(1.0);\n    \n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n\tvec3 campos = vec3(SIZX\/2.0,SIZY*0.6,SIZY*0.0);\n\tvec3 camdir = vec3((uv-0.5)*1.1,1);\n\tcamdir.y *= -iResolution.y \/ iResolution.x; \/\/ wide screen\n\tcamdir = normalize(rotcam(camdir));\n    zoom = 1.1 - zoomamt*0.3;\n\tcampos -= rotcam(vec3(0,0,SIZX*zoom)); \/\/ back up from subject    \n    \n    \n    vec4 res  = raytrace_curtain_background_rail(campos,camdir);\n    \n    \/\/ raytrace ball    \n    vec3 bp = ballpos();\n    \n    \n    float m = length(cross(bp-campos,camdir))\/ballradius;\n    if (m<1.0)\n    {\n        float dept = dot(bp-campos,camdir) - sqrt(1.0-m*m)*ballradius;\n        vec3 hitpos = campos + camdir*dept;\n        vec3 normal = -(hitpos-bp)\/ballradius;\n        if (dept < res.a)\n        {\n            res.a = dept;\n            \n            vec3 reflectedraydir = reflect(camdir,normal);\n            \n            \/\/ ball shading:\n            \/\/ raytracing the reflected curtain in the ball is very slow due to random texture access\n            \n\/\/            vec3 reflectedcolor = raytrace_curtain_background_rail(hitpos,reflectedraydir).xyz;\n            vec3 reflectedcolor = background(hitpos,reflectedraydir).xyz;\n            \n            float f=1.0-max(dot(normal,camdir),0.0);\n            float fresnel = 0.05+0.95*f*f*f*f*f;\n            res.xyz = mix(vec3(0.5,0.05,0.1)*lighting(normal),reflectedcolor, fresnel);\n        }\n    }\n    \n    fragColor = res;\n    \n    \/\/ progress bar was aimed to hide the bugs in the beginning, such as the stretching.\n    \/\/ but it ruins the preview\n\/*    const float loadtime = 2.0;\n    if (mytime<loadtime)\n    { \n        fragColor = vec4(0.0);\n        if ( uv.y>0.45 && uv.y<0.55)\n        {\n            fragColor = vec4(mytime\/loadtime > uv.x ? 1.0 : 0.5);\n        }\n    }*\/\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGR8","filepath":"\/media\/previz\/buffer03.png","previewfilepath":"\/media\/previz\/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ Copy the same code to all buffers and chain them.\n\n#define SIZX 130.0\n#define SIZY 66.0\nconst vec3 windvel = vec3(0.01,0.0,-0.005);\nconst float gravity = 0.0022;\nfloat mytime=0.0;\n\nvec3 getpos(vec2 uv)\n{\n    return texture(iChannel1,(uv+0.01)\/iResolution.xy).xyz;\n}\nvec3 getvel(vec2 uv)\n{\n    return texture(iChannel1,(uv+0.01+vec2(SIZX,0.0))\/iResolution.xy).xyz;\n}\n\nvec3 pos,vel,ovel;\nvec2 c;\n\nvoid edge(vec2 dif)\n{\n    if ( \n        (dif+c).x>=0.0 && (dif+c).x<SIZX &&\n        (dif+c).y>=0.0 && (dif+c).y<SIZY    )\n    {\n        float edgelen = length(dif);\n        vec3 posdif = getpos(dif+c)-pos;\n        vec3 veldif = getvel(dif+c)-ovel;\n\n        vel += normalize(posdif)*(clamp(length(posdif)-edgelen,-1.0,1.0)*0.15); \/\/ spring\n\n        \/\/            vel += dot(posdif,veldif)*posdif\/dot(posdif,posdif)*0.33; \/\/ damper\n        vel +=normalize(posdif)*( dot(normalize(posdif),veldif)*0.10); \/\/ damper\n        \/\/            vel += normalize(posdif)*(-0.005); \/\/ spring\n    }\n}\n\nvec3 findnormal(vec2 c)\n{\n    return normalize(cross(  getpos(c-vec2(1.0,0.0))-getpos(c+vec2(1.0,0.0)) ,  getpos(c-vec2(0.0,1.0))-getpos(c+vec2(0.0,1.0)) ));\n}\n\nvec3 ballpos()\n{\n    return vec3(128.0*0.4,64.0*0.7,64.0*(cos(mytime\/3.0)*0.8));;\n}\n\nvoid ballcollis()\n{\n    float ballradius = 64.0*0.3;\n    vec3 ballpos2 = ballpos();\n    if ( length(pos-ballpos2)<ballradius)\n    {\n        vel -= normalize(pos-ballpos2)*dot(normalize(pos-ballpos2),vel);\n        vel += (normalize(pos-ballpos2)*ballradius+ballpos2-pos);\n    }\n                        \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\/\/    mytime = float(iFrame) \/ 60.0;\n    mytime = getpos(vec2(0.0,SIZY)).x;\n    \n    fragColor=vec4(0.0);\n    vec2 fc = fragCoord+0.1;\n    fc-=fract(fc);\n\n    if (fc.y>=SIZY+2.0 || fc.x>=SIZX*2.0) discard;\n    \n    c = fc;\n    c.x = fract(c.x\/SIZX)*SIZX;\n\n    pos = getpos(c);\n     vel = getvel(c);\n\n    \n    \n    \n\/*    vec2 edges[6];\n    edges[2]=vec2(1.0,0.0);\n    edges[3]=vec2(-1.0,0.0);\n    edges[0]=vec2(0.0,1.0);\n    edges[1]=vec2(0.0,-1.0);\n    edges[4]=vec2(1.0,1.0);\n    edges[5]=vec2(-1.0,-1.0);*\/\n    \n    ovel = vel;\n    \n    edge(vec2(0.0,1.0));\n    edge(vec2(0.0,-1.0));\n    edge(vec2(1.0,0.0));\n    edge(vec2(-1.0,0.0));\n    edge(vec2(1.0,1.0));\n    edge(vec2(-1.0,-1.0));\n\n    edge(vec2(0.0,2.0));\n    edge(vec2(0.0,-2.0));\n    edge(vec2(2.0,0.0));\n    edge(vec2(-2.0,0.0));\n    edge(vec2(2.0,-2.0));\n    edge(vec2(-2.0,2.0));\n    \n    \n\/\/    vel.x = 0.0;\n    ballcollis();\n    \n    pos += vel;\n    vel.y += gravity; \/\/ gravity\n    \n    \/\/ apply air friction\n    \n    vec3 norm = findnormal(c);\n    vel -= norm * (dot(norm,vel-windvel)*0.05 );\n    \n    \n    if (iFrame==0 || c.y==0.0) \/\/ init\n    {\n        pos = vec3(fc.x*0.85,fc.y,fc.y*0.01);\n        vel = vec3(0.0,0.0,0.0);\n    }\n    \n    \n    fragColor = vec4(fc.x>=SIZX ? vel : pos,0.0);\n    \n    if (fc.y>=SIZY)\n    {\n        mytime += 1.0\/4.0\/60.0;\n        fragColor = vec4(mytime);\n    }\n    \n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/\/ Copy the same code to all buffers and chain them.\n\n#define SIZX 130.0\n#define SIZY 66.0\nconst vec3 windvel = vec3(0.01,0.0,-0.005);\nconst float gravity = 0.0022;\nfloat mytime=0.0;\n\nvec3 getpos(vec2 uv)\n{\n    return texture(iChannel1,(uv+0.01)\/iResolution.xy).xyz;\n}\nvec3 getvel(vec2 uv)\n{\n    return texture(iChannel1,(uv+0.01+vec2(SIZX,0.0))\/iResolution.xy).xyz;\n}\n\nvec3 pos,vel,ovel;\nvec2 c;\n\nvoid edge(vec2 dif)\n{\n    if ( \n        (dif+c).x>=0.0 && (dif+c).x<SIZX &&\n        (dif+c).y>=0.0 && (dif+c).y<SIZY    )\n    {\n        float edgelen = length(dif);\n        vec3 posdif = getpos(dif+c)-pos;\n        vec3 veldif = getvel(dif+c)-ovel;\n\n        vel += normalize(posdif)*(clamp(length(posdif)-edgelen,-1.0,1.0)*0.15); \/\/ spring\n\n        \/\/            vel += dot(posdif,veldif)*posdif\/dot(posdif,posdif)*0.33; \/\/ damper\n        vel +=normalize(posdif)*( dot(normalize(posdif),veldif)*0.10); \/\/ damper\n        \/\/            vel += normalize(posdif)*(-0.005); \/\/ spring\n    }\n}\n\nvec3 findnormal(vec2 c)\n{\n    return normalize(cross(  getpos(c-vec2(1.0,0.0))-getpos(c+vec2(1.0,0.0)) ,  getpos(c-vec2(0.0,1.0))-getpos(c+vec2(0.0,1.0)) ));\n}\n\nvec3 ballpos()\n{\n    return vec3(128.0*0.4,64.0*0.7,64.0*(cos(mytime\/3.0)*0.8));;\n}\n\nvoid ballcollis()\n{\n    float ballradius = 64.0*0.3;\n    vec3 ballpos2 = ballpos();\n    if ( length(pos-ballpos2)<ballradius)\n    {\n        vel -= normalize(pos-ballpos2)*dot(normalize(pos-ballpos2),vel);\n        vel += (normalize(pos-ballpos2)*ballradius+ballpos2-pos);\n    }\n                        \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\/\/    mytime = float(iFrame) \/ 60.0;\n    mytime = getpos(vec2(0.0,SIZY)).x;\n    \n    fragColor=vec4(0.0);\n    vec2 fc = fragCoord+0.1;\n    fc-=fract(fc);\n\n    if (fc.y>=SIZY+2.0 || fc.x>=SIZX*2.0) discard;\n    \n    c = fc;\n    c.x = fract(c.x\/SIZX)*SIZX;\n\n    pos = getpos(c);\n     vel = getvel(c);\n\n    \n    \n    \n\/*    vec2 edges[6];\n    edges[2]=vec2(1.0,0.0);\n    edges[3]=vec2(-1.0,0.0);\n    edges[0]=vec2(0.0,1.0);\n    edges[1]=vec2(0.0,-1.0);\n    edges[4]=vec2(1.0,1.0);\n    edges[5]=vec2(-1.0,-1.0);*\/\n    \n    ovel = vel;\n    \n    edge(vec2(0.0,1.0));\n    edge(vec2(0.0,-1.0));\n    edge(vec2(1.0,0.0));\n    edge(vec2(-1.0,0.0));\n    edge(vec2(1.0,1.0));\n    edge(vec2(-1.0,-1.0));\n\n    edge(vec2(0.0,2.0));\n    edge(vec2(0.0,-2.0));\n    edge(vec2(2.0,0.0));\n    edge(vec2(-2.0,0.0));\n    edge(vec2(2.0,-2.0));\n    edge(vec2(-2.0,2.0));\n    \n    \n\/\/    vel.x = 0.0;\n    ballcollis();\n    \n    pos += vel;\n    vel.y += gravity; \/\/ gravity\n    \n    \/\/ apply air friction\n    \n    vec3 norm = findnormal(c);\n    vel -= norm * (dot(norm,vel-windvel)*0.05 );\n    \n    \n    if (iFrame==0 || c.y==0.0) \/\/ init\n    {\n        pos = vec3(fc.x*0.85,fc.y,fc.y*0.01);\n        vel = vec3(0.0,0.0,0.0);\n    }\n    \n    \n    fragColor = vec4(fc.x>=SIZX ? vel : pos,0.0);\n    \n    if (fc.y>=SIZY)\n    {\n        mytime += 1.0\/4.0\/60.0;\n        fragColor = vec4(mytime);\n    }\n    \n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\/\/ Copy the same code to all buffers and chain them.\n\n#define SIZX 130.0\n#define SIZY 66.0\nconst vec3 windvel = vec3(0.01,0.0,-0.005);\nconst float gravity = 0.0022;\nfloat mytime=0.0;\n\nvec3 getpos(vec2 uv)\n{\n    return texture(iChannel1,(uv+0.01)\/iResolution.xy).xyz;\n}\nvec3 getvel(vec2 uv)\n{\n    return texture(iChannel1,(uv+0.01+vec2(SIZX,0.0))\/iResolution.xy).xyz;\n}\n\nvec3 pos,vel,ovel;\nvec2 c;\n\nvoid edge(vec2 dif)\n{\n    if ( \n        (dif+c).x>=0.0 && (dif+c).x<SIZX &&\n        (dif+c).y>=0.0 && (dif+c).y<SIZY    )\n    {\n        float edgelen = length(dif);\n        vec3 posdif = getpos(dif+c)-pos;\n        vec3 veldif = getvel(dif+c)-ovel;\n\n        vel += normalize(posdif)*(clamp(length(posdif)-edgelen,-1.0,1.0)*0.15); \/\/ spring\n\n        \/\/            vel += dot(posdif,veldif)*posdif\/dot(posdif,posdif)*0.33; \/\/ damper\n        vel +=normalize(posdif)*( dot(normalize(posdif),veldif)*0.10); \/\/ damper\n        \/\/            vel += normalize(posdif)*(-0.005); \/\/ spring\n    }\n}\n\nvec3 findnormal(vec2 c)\n{\n    return normalize(cross(  getpos(c-vec2(1.0,0.0))-getpos(c+vec2(1.0,0.0)) ,  getpos(c-vec2(0.0,1.0))-getpos(c+vec2(0.0,1.0)) ));\n}\n\nvec3 ballpos()\n{\n    return vec3(128.0*0.4,64.0*0.7,64.0*(cos(mytime\/3.0)*0.8));;\n}\n\nvoid ballcollis()\n{\n    float ballradius = 64.0*0.3;\n    vec3 ballpos2 = ballpos();\n    if ( length(pos-ballpos2)<ballradius)\n    {\n        vel -= normalize(pos-ballpos2)*dot(normalize(pos-ballpos2),vel);\n        vel += (normalize(pos-ballpos2)*ballradius+ballpos2-pos);\n    }\n                        \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\/\/    mytime = float(iFrame) \/ 60.0;\n    mytime = getpos(vec2(0.0,SIZY)).x;\n    \n    fragColor=vec4(0.0);\n    vec2 fc = fragCoord+0.1;\n    fc-=fract(fc);\n\n    if (fc.y>=SIZY+2.0 || fc.x>=SIZX*2.0) discard;\n    \n    c = fc;\n    c.x = fract(c.x\/SIZX)*SIZX;\n\n    pos = getpos(c);\n     vel = getvel(c);\n\n    \n    \n    \n\/*    vec2 edges[6];\n    edges[2]=vec2(1.0,0.0);\n    edges[3]=vec2(-1.0,0.0);\n    edges[0]=vec2(0.0,1.0);\n    edges[1]=vec2(0.0,-1.0);\n    edges[4]=vec2(1.0,1.0);\n    edges[5]=vec2(-1.0,-1.0);*\/\n    \n    ovel = vel;\n    \n    edge(vec2(0.0,1.0));\n    edge(vec2(0.0,-1.0));\n    edge(vec2(1.0,0.0));\n    edge(vec2(-1.0,0.0));\n    edge(vec2(1.0,1.0));\n    edge(vec2(-1.0,-1.0));\n\n    edge(vec2(0.0,2.0));\n    edge(vec2(0.0,-2.0));\n    edge(vec2(2.0,0.0));\n    edge(vec2(-2.0,0.0));\n    edge(vec2(2.0,-2.0));\n    edge(vec2(-2.0,2.0));\n    \n    \n\/\/    vel.x = 0.0;\n    ballcollis();\n    \n    pos += vel;\n    vel.y += gravity; \/\/ gravity\n    \n    \/\/ apply air friction\n    \n    vec3 norm = findnormal(c);\n    vel -= norm * (dot(norm,vel-windvel)*0.05 );\n    \n    \n    if (iFrame==0 || c.y==0.0) \/\/ init\n    {\n        pos = vec3(fc.x*0.85,fc.y,fc.y*0.01);\n        vel = vec3(0.0,0.0,0.0);\n    }\n    \n    \n    fragColor = vec4(fc.x>=SIZX ? vel : pos,0.0);\n    \n    if (fc.y>=SIZY)\n    {\n        mytime += 1.0\/4.0\/60.0;\n        fragColor = vec4(mytime);\n    }\n    \n}","name":"Buf C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\/\/ Copy the same code to all buffers and chain them.\n\n#define SIZX 130.0\n#define SIZY 66.0\nconst vec3 windvel = vec3(0.01,0.0,-0.005);\nconst float gravity = 0.0022;\nfloat mytime=0.0;\n\nvec3 getpos(vec2 uv)\n{\n    return texture(iChannel1,(uv+0.01)\/iResolution.xy).xyz;\n}\nvec3 getvel(vec2 uv)\n{\n    return texture(iChannel1,(uv+0.01+vec2(SIZX,0.0))\/iResolution.xy).xyz;\n}\n\nvec3 pos,vel,ovel;\nvec2 c;\n\nvoid edge(vec2 dif)\n{\n    if ( \n        (dif+c).x>=0.0 && (dif+c).x<SIZX &&\n        (dif+c).y>=0.0 && (dif+c).y<SIZY    )\n    {\n        float edgelen = length(dif);\n        vec3 posdif = getpos(dif+c)-pos;\n        vec3 veldif = getvel(dif+c)-ovel;\n\n        vel += normalize(posdif)*(clamp(length(posdif)-edgelen,-1.0,1.0)*0.15); \/\/ spring\n\n        \/\/            vel += dot(posdif,veldif)*posdif\/dot(posdif,posdif)*0.33; \/\/ damper\n        vel +=normalize(posdif)*( dot(normalize(posdif),veldif)*0.10); \/\/ damper\n        \/\/            vel += normalize(posdif)*(-0.005); \/\/ spring\n    }\n}\n\nvec3 findnormal(vec2 c)\n{\n    return normalize(cross(  getpos(c-vec2(1.0,0.0))-getpos(c+vec2(1.0,0.0)) ,  getpos(c-vec2(0.0,1.0))-getpos(c+vec2(0.0,1.0)) ));\n}\n\nvec3 ballpos()\n{\n    return vec3(128.0*0.4,64.0*0.7,64.0*(cos(mytime\/3.0)*0.8));;\n}\n\nvoid ballcollis()\n{\n    float ballradius = 64.0*0.3;\n    vec3 ballpos2 = ballpos();\n    if ( length(pos-ballpos2)<ballradius)\n    {\n        vel -= normalize(pos-ballpos2)*dot(normalize(pos-ballpos2),vel);\n        vel += (normalize(pos-ballpos2)*ballradius+ballpos2-pos);\n    }\n                        \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\/\/    mytime = float(iFrame) \/ 60.0;\n    mytime = getpos(vec2(0.0,SIZY)).x;\n    \n    fragColor=vec4(0.0);\n    vec2 fc = fragCoord+0.1;\n    fc-=fract(fc);\n\n    if (fc.y>=SIZY+2.0 || fc.x>=SIZX*2.0) discard;\n    \n    c = fc;\n    c.x = fract(c.x\/SIZX)*SIZX;\n\n    pos = getpos(c);\n     vel = getvel(c);\n\n    \n    \n    \n\/*    vec2 edges[6];\n    edges[2]=vec2(1.0,0.0);\n    edges[3]=vec2(-1.0,0.0);\n    edges[0]=vec2(0.0,1.0);\n    edges[1]=vec2(0.0,-1.0);\n    edges[4]=vec2(1.0,1.0);\n    edges[5]=vec2(-1.0,-1.0);*\/\n    \n    ovel = vel;\n    \n    edge(vec2(0.0,1.0));\n    edge(vec2(0.0,-1.0));\n    edge(vec2(1.0,0.0));\n    edge(vec2(-1.0,0.0));\n    edge(vec2(1.0,1.0));\n    edge(vec2(-1.0,-1.0));\n\n    edge(vec2(0.0,2.0));\n    edge(vec2(0.0,-2.0));\n    edge(vec2(2.0,0.0));\n    edge(vec2(-2.0,0.0));\n    edge(vec2(2.0,-2.0));\n    edge(vec2(-2.0,2.0));\n    \n    \n\/\/    vel.x = 0.0;\n    ballcollis();\n    \n    pos += vel;\n    vel.y += gravity; \/\/ gravity\n    \n    \/\/ apply air friction\n    \n    vec3 norm = findnormal(c);\n    vel -= norm * (dot(norm,vel-windvel)*0.05 );\n    \n    \n    if (iFrame==0 || c.y==0.0) \/\/ init\n    {\n        pos = vec3(fc.x*0.85,fc.y,fc.y*0.01);\n        vel = vec3(0.0,0.0,0.0);\n    }\n    \n    \n    fragColor = vec4(fc.x>=SIZX ? vel : pos,0.0);\n    \n    if (fc.y>=SIZY)\n    {\n        mytime += 1.0\/4.0\/60.0;\n        fragColor = vec4(mytime);\n    }\n    \n}","name":"Buf D","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"ldtGD4","date":"1449767000","viewed":11170,"name":"barebones ray marching","username":"nicoptere","description":"this is a miniaml example of ray marching used as an illustration for this article: http:\/\/barradeau.com\/blog\/?p=575","likes":10,"published":1,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[],"code":"\/\/the signed distance field function\n\/\/used in the ray march loop\nfloat sdf(vec3 p) {\n\n    \/\/a sphere of radius 1.\n    return length( p ) - 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n\/\/1 : retrieve the fragment's coordinates\n\tvec2 uv = ( fragCoord.xy \/ iResolution.xy ) * 2.0 - 1.0;\n\t\/\/preserve aspect ratio\n\tuv.x *= iResolution.x \/ iResolution.y;\n\n\n\/\/2 : camera position and ray direction\n\tvec3 pos = vec3( 0.,0.,-3.);\n\tvec3 dir = normalize( vec3( uv, 1. ) );\n\n\n\/\/3 : ray march loop\n    \/\/ip will store where the ray hits the surface\n\tvec3 ip;\n\n\t\/\/variable step size\n\tfloat t = 0.0;\n\tfor( int i = 0; i < 32; i++) {\n\n        \/\/update position along path\n        ip = pos + dir * t;\n\n        \/\/gets the shortest distance to the scene\n\t\tfloat temp = sdf( ip );\n\n        \/\/break the loop if the distance was too small\n        \/\/this means that we are close enough to the surface\n\t\tif( temp < 0.01 ) break;\n\n\t\t\/\/increment the step along the ray path\n\t\tt += temp;\n\n\t}\n\n\/\/4 : apply color to this fragment\n    \/\/we use the result position as the color\n\tfragColor = vec4( ip, 1.0);\n\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4sf3Dj","date":"1379099558","viewed":11151,"name":"Gamecube","username":"fb39ca4","description":"Phew. That took a while to get looking right. I apologize for the lack of optimization. Anyone good at doing text? All that's missing is the words \"Nintendo Gamecube.\"\n\nIf it doesn't work and you are using Windows, please disable ANGLE in your browser. ","likes":81,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[],"code":"const int MAX_RAY_STEPS = 20;\n\nconst float pi = 3.14159265359;\n\nfloat maxcomp(vec2 v) { return max(v.x, v.y); }\nfloat maxcomp(vec3 v) { return max(v.x, max(v.y, v.z)); }\n\nfloat mincomp(vec3 v) { return min(v.x, min(v.y, v.z)); }\n\nfloat sum(vec3 v) { return v.x + v.y + v.z; }\n\nvec2 rotate2d(vec2 v, float a) { return vec2(v.x * cos(a) - v.y * sin(a), v.y * cos(a) + v.x * sin(a)); }\n\nfloat smootherstep(float edge0, float edge1, float x)\n{\n    x = clamp((x - edge0)\/(edge1 - edge0), 0.0, 1.0);\n    return x*x*x*(x*(x*6.0 - 15.0) + 10.0);\n}\n\nfloat pulse1(float x) {\n\tx = x \/ (1.0 + 2.5 * step(0.0, x));\n\tx = clamp(abs(x), 0.0, 1.0);\n\treturn 1.0 - x*x*x*(x*(x*6.0 - 15.0) + 10.0);\t\n}\n\nfloat pulse2(float x) {\n\tx = x \/ (1.0 + 1.5 * step(0.0, x));\n\treturn 1.0 - smoothstep(0.0, 1.0, abs(x));\t\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdBox2p(vec3 p, vec3 b1, vec3 b2) {\n\tvec3 pos = (b1 + b2) \/ 2.0;\n\tvec3 b = (b2 - b1) \/ 2.0;\n\treturn sdBox(p - pos, b);\n}\n\nfloat tileCubeShell(vec3 p, float t) {\n\treturn max(p.y, -min(p.x, p.z));\n}\n\nfloat marchingCube(vec3 p, float t) {\n\tp.z -= floor(t);\n\tp.y += 0.5;\n\tp.z -= 0.5;\n\tp.yz = rotate2d(p.yz, -mod(t, 1.0) * pi \/ 2.0);\n\tp.y -= 0.5;\n\tp.z += 0.5;\n\treturn sdBox(p, vec3(0.40)) - 0.05;\n}\n\nfloat tumblingCube(vec3 p, float t) {\n\tt = clamp(t * 0.333, 0.0, 1.0);\n\tvec3 pos;\n\tpos.x = mix(0.5, 0.65, t);\n\tpos.y = -14.0 * t * t + 14.0 * t + mix(-0.5, -0.65, t);\n\tpos.z = mix(-0.5, 0.65, t);\n\tfloat size = mix(0.4, 0.65, pow(t, 4.0));\n\tfloat cornerRounding = mix(0.05, 0.1, pow(t, 4.0));\n\tfloat rot = min(mix(0.0, 2.0 * pi, 2.0 * smoothstep(0.0, 1.0, t)), 2.0 * pi);\n\treturn sdBox(vec3(p.x - pos.z, rotate2d(p.yz - pos.yz, rot)), vec3(size)) - cornerRounding;\t\n}\n\nfloat marchingCubePath(vec3 p, float t) {\n\tif (t < 0.0) \n\t\treturn sdBox(p - vec3(2.5, max(-0.5 - 3.0 * (t + 1.0), 0.5), 0.5), vec3(0.40)) - 0.05;\n\telse if (t < 2.0) \n\t\treturn marchingCube(p - vec3(2.5, 0.5, 0.5), t);\n\telse if (t < 5.0) \n\t\treturn marchingCube(p.zyx * vec3(1.0, 1.0, -1.0) - vec3(2.5, 0.5, -2.5), t - 2.0);\n\telse if (t < 8.0) \n\t\treturn marchingCube(p.zxy * vec3(1.0, -1.0, -1.0) - vec3(2.5, 0.5, -0.5), t - 5.0);\n\telse if (t < 11.0) \n\t\treturn marchingCube(p.yxz * vec3(1.0, -1.0, -1.0) - vec3(-2.5, 0.5, -2.5), t - 8.0);\n\telse if (t < 14.0)\n\t\treturn marchingCube(p.yzx * vec3(1.0, -1.0, 1.0) - vec3(-2.5, 0.5, -0.5), t - 11.0);\n\telse if (t < 16.0)\n\t\treturn marchingCube(p.xzy * vec3(1.0, -1.0, 1.0) - vec3(2.5, 0.5, -2.5), t - 14.0);\n\telse if (t < 18.0)\n\t\treturn marchingCube(p.yzx * vec3(1.0, -1.0, -1.0) - vec3(-0.5, 0.5, -2.5), t - 16.0);\n\telse\n\t\treturn tumblingCube(p, t - 18.0);\n}\n\nfloat finalLogoScene(vec3 p, float t) {\n\tfloat thickness = 0.1;\n\tp.y = -p.y;\n\tfloat shell = max(sdBox2p(p, vec3(0.0), vec3(3.0)), -sdBox2p(p, vec3(thickness), vec3(8.0)));\n\tshell = max(shell, -sdBox2p(p, vec3(-8.0), vec3(2.0)));\n\tshell = max(shell, -sdBox2p(p, vec3(1.0, -1.0, thickness), vec3(4.0, 5.0, 1.0)));\n\tshell = min(shell, sdBox2p(p, vec3(0.0), vec3(3.0, 1.0, thickness)));\n\tshell = min(shell, sdBox2p(p, vec3(0.0), vec3(1.4)));\n\treturn shell;\n}\n\nfloat scene(vec3 p, float t) {\n\tfloat bigCube = tileCubeShell(p, t);\n\tfloat littleCube = marchingCubePath(p, t - 10.0);\n\treturn min(bigCube, littleCube);\n}\n\nfloat getMaterial(vec3 p, float t) {\n\tfloat bigCube = tileCubeShell(p, t);\n\tfloat littleCube = marchingCubePath(p, t - 10.0);\n\tif (bigCube < littleCube) return 0.0;\n\telse return 1.0;\n}\n\nfloat sideY(vec3 p, float t) {\n\tvec3 p1 = vec3(2.5, p.y, min(0.5 + t, p.z));\n\tvec3 p2 = vec3(max(3.5 - (t - 1.0), p.x), p.y, 2.5);\n\treturn max(1.0 - min(length(p - p1), length(p - p2)), 0.0) * step(1.0, p.z);\n}\n\nfloat sideX(vec3 p, float t) {\n\tvec3 p1 = vec3(p.x, min(-1.5 + t, p.y), 2.5);\n\tvec3 p2 = vec3(p.x, 2.5, max(6.5 - t, p.z));\n\treturn max(1.0 - min(length(p - p1), length(p - p2)), 0.0);\n}\n\nfloat sideZ(vec3 p, float t) {\n\tvec3 p1 = vec3(min(-2.5 + t, p.x), 2.5, p.z);\n\tvec3 p2 = vec3(2.5, max(7.5 - t, p.y), p.z);\n\tvec3 p3 = vec3(max(max(9.5 - t, 1.5), p.x), 0.5, p.z);\n\treturn max(1.0 - min(min(length(p - p1), length(p - p2)), length(p - p3)), 0.0);\n}\n\nvec3 translucentColor(vec3 p, float t) {\n\tvec3 color = vec3(0.766, 0.733, 0.813) * 0.5;\n\treturn ( maxcomp(p \/ 3.0) + maxcomp((3.0 - p) \/ 3.0) ) * color * sqrt(pulse1(t - 9.6666) + pulse2(0.75 * (t - 32.5)));\t\n}\n\nvec4 tileColor(vec3 p, float t) {\n\tp.y = -p.y;\n\tif (maxcomp(p) > 3.0) return vec4(0.0);\n\tvec3 uvw = mod(p, 1.0);\n\tvec3 color = vec3(0.566, 0.533, 0.813);\n\tfloat tileBorder = 0.45;\n\tbool inTile = maxcomp(abs(uvw.xy - 0.5)) < tileBorder;\n\tinTile = inTile || maxcomp(abs(uvw.xz - 0.5)) < tileBorder;\n\tinTile = inTile || maxcomp(abs(uvw.yz - 0.5)) < tileBorder;\n\t\n\tvec3 tilePos = floor(p) + 0.5;\n\tvec3 side = vec3(lessThan(p, vec3(0.0000001)));\n\tvec3 sidePattern = vec3(sideX(tilePos, t - 4.0), sideY(tilePos, t), sideZ(tilePos, t - 9.0)) * float(inTile);\n\n\tfloat tileAlpha = sum(side * sidePattern);\n\ttileAlpha = min(tileAlpha, 1.0);\n\t\n\tvec3 tileColor = mix(translucentColor(p, t + 11.0), color, tileAlpha);\n\t\n\treturn vec4(tileColor, 1.0);\n\t\n}\n\nfloat diffuseLit(vec3 p, vec3 n) {\n\tfloat result = 0.0;\n\tn = normalize(n);\n\t\n\tvec3 light1 = vec3(0.0, 9.0, 3.0);\n\tvec3 light1Dir = light1 - p;\n\tfloat light1Dist = length(light1Dir);\n\tresult += max(dot(n, normalize(light1Dir)), 0.0);\n\t\n\tvec3 light2 = vec3(0.0, 1.5, -14.0);\n\tvec3 light2Dir = light2 - p;\n\tfloat light2Dist = length(light2Dir);\n\tresult += max(dot(n, normalize(light2Dir)), 0.0);\n\t\n\tvec3 light3 = vec3(-9.0, -1.5, 2.0);\n\tvec3 light3Dir = light3 - p;\n\tfloat light3Dist = length(light3Dir);\n\tresult += max(dot(n, normalize(light3Dir)), 0.0);\n\t\n\treturn result;\n\t\t\n}\n\nvec4 finalLogoColor(vec3 p, vec3 n) {\n\tn = pow(abs(n), vec3(9001.0));\n\tp.y = -p.y;\n\tvec3 color = vec3(0.0);\n\tcolor.y = 1.0 - pow(length(p.xz - vec2(2.7, 2.3)), 1.3) \/ 3.5;\t\n\tcolor.x = pow(length((p.yz - vec2(3.7, -1.0)) * vec2(1.0, 1.1)), 1.3) \/ 6.0;\n\tcolor.z = pow(length(p.xy - vec2(2.7, 2.3)), 1.3) \/ 4.0;\n\tfloat mixVal = clamp(sum(color * n), 0.0, 1.0);\n\tvec4 res = mix(vec4(0.98, 0.98, 0.99, 1.0), vec4(0.74, 0.71, 0.95, 1.0), mixVal);\n\tres.xyz *= sum(n * vec3(0.85, 1.0, 0.6));\n\treturn res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = mod(iTime - 1.0, 10.0) * 5.0 + 5.0;\n\tif (iTime == 10.0 && length(iResolution.xy) < 350.0) time = 40.0;\n\t\n\tvec2 screenPos = (fragCoord.xy \/ iResolution.xy) * 2.0 - 1.0;\n\tscreenPos.x *= iResolution.x \/ iResolution.y;\n\tscreenPos += vec2(0.3, -0.3);\n\tscreenPos = rotate2d(screenPos, 0.25 * pulse1(time - 9.6666));\n\tscreenPos -= vec2(0.3, -0.3);\n\tscreenPos.y -= 0.7;\n\tvec3 cameraPos = normalize(vec3(-1.0, 1.0 + 2.0 * pulse2(0.75 * (time - 32.5)), -1.0)) * 90.0;\n\tvec3 cameraDir = normalize(vec3(3.0, 0.0, 3.0) - cameraPos);\n\t\n\tvec3 cameraPlaneU = vec3(0.0);\n\tcameraPlaneU.xz = cross(vec3(0.0, 1.0, 0.0), vec3(cameraDir.x, 0.0, cameraDir.z)).xz;\n\tcameraPlaneU = normalize(cameraPlaneU);\n\tvec3 cameraPlaneV = normalize(cross(cameraDir, cameraPlaneU));\n\tcameraDir *= 30.0;\n\t\n\tvec3 rayDir = normalize(cameraDir + screenPos.x * cameraPlaneU + screenPos.y * cameraPlaneV);\n\tvec3 rayPos = cameraPos;\n\t\n\tfloat dist = scene(rayPos, time);\n\tint stepsTaken;\n\t\n\tvec3 planeDist;\n\tplaneDist.x = cameraPos.x * length(rayDir \/ rayDir.x);\n\tplaneDist.y = cameraPos.y * length(rayDir \/ rayDir.y);\n\tplaneDist.z = cameraPos.z * length(rayDir \/ rayDir.z);\n\tfloat planeIntersectDist = -mincomp(abs(planeDist));\n\t\n\tfor (int i = 0; i < MAX_RAY_STEPS; i++) {\n\t\trayPos += rayDir * dist;\n\t\tdist = scene(rayPos, time);\n\t}\n\tfloat material = getMaterial(rayPos, time);\n\tvec2 dd = vec2(0.0, 1.0) * 0.00001;\n\tvec3 normal = normalize(vec3(scene(rayPos + dd.yxx, time) - scene(rayPos - dd.yxx, time),\n\t\t\t\t\t\t\t     scene(rayPos + dd.xyx, time) - scene(rayPos - dd.xyx, time),\n\t\t\t\t\t\t\t     scene(rayPos + dd.xxy, time) - scene(rayPos - dd.xxy, time)));\n\t\n\tvec4 color;\n\tif (material == 0.0) color = tileColor(rayPos, time - 11.0);\n\telse color = vec4(0.566, 0.533, 0.863, 1.0) * diffuseLit(rayPos, normal);\n\tcolor = clamp(color, 0.0, 1.0);\n\t\n\trayPos = cameraPos;\n\t\n\tdist = finalLogoScene(rayPos, time);\n\tfor (int i = 0; i < MAX_RAY_STEPS; i++) {\n\t\tif (dist < 0.001) continue;\n\t\trayPos += rayDir * dist;\n\t\tdist = finalLogoScene(rayPos, time);\n\t}\n\tnormal = normalize(vec3(finalLogoScene(rayPos + dd.yxx, time) - finalLogoScene(rayPos - dd.yxx, time),\n\t\t\t\t\t\t\t     finalLogoScene(rayPos + dd.xyx, time) - finalLogoScene(rayPos - dd.xyx, time),\n\t\t\t\t\t\t\t     finalLogoScene(rayPos + dd.xxy, time) - finalLogoScene(rayPos - dd.xxy, time)));\n\tfloat mixAmount = smoothstep(32.0, 40.0, time);\n\tif (dist < 0.05)\n\t\tcolor = mix(color, clamp(vec4(vec3(finalLogoColor(rayPos, normal)), 1.0), 0.0, 1.0), mixAmount);\n\telse\n\t\tcolor = mix(color, vec4(0.0), mixAmount);\n\tcolor = mix(color, vec4(0.0), smoothstep(45.0, 50.0, time));\n\tcolor = pow(color, vec4(2.2));\n\n\tfragColor = color;\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"MdtGD4","date":"1449767564","viewed":11141,"name":"CSG basics","username":"nicoptere","description":"this is a basic example of how to combine 2 shapes to illustrate this article: http:\/\/barradeau.com\/blog\/?p=575","likes":2,"published":1,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[],"code":"\/\/CSG operations\n\nfloat unite( float a, float b){return min(a, b);}\nfloat subtract( float a, float b ){ return max(-a, b); }\nfloat intersect( float a, float b ){ return max(a, b); }\n\n\n\/\/describing a sphere\nfloat sphere( vec3 pos, vec3 center, float radius )\n{\n    return length( pos - center ) - radius;\n}\n\n\/\/describing a box\nfloat box( vec3 pos, vec3 center, vec3 size, float corner )\n{\n    return length( max( abs( pos-center )-size, 0.0 ) )-corner;\n}\n\n\/\/the signed distance field function\n\/\/used in the ray march loop\nfloat sdf(vec3 p) {\n \n    \/\/we build a sphere\n    float s = sphere( p, vec3( 0. ), 1.25 );\n \n    \/\/we build a box\n    float b = box( p, vec3( 0. ), vec3( 1. ), .0 );\n \n    \/\/we return the combination of both:\n    \/\/subtracting the sphere from the box\n    return subtract( s,b  );\n    \n}\n\n\/\/unchanged \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = ( fragCoord.xy \/ iResolution.xy ) * 2.0 - 1.0;\n\tuv.x *= iResolution.x \/ iResolution.y;\n\tvec3 pos = vec3( 0.,0.,-3.);\n\tvec3 dir = normalize( vec3( uv, 1. ) );\n\tvec3 ip;\n\tfloat t = 0.0;\n\tfor( int i = 0; i < 32; i++) {\n        ip = pos + dir * t;\n\t\tfloat temp = sdf( ip );\n\t\tif( temp < 0.01 ) break;\n\t\tt += temp;\n\t}\n\tfragColor = vec4( ip, 1.0);\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4sXXRN","date":"1397174619","viewed":11132,"name":"Triangle - distance 3D","username":"iq","description":"Distance field to a triangle. Of course, some thickness has to be given to the polygon (or mesh if you had one) in order to make it renderable. [url]http:\/\/iquilezles.org\/articles\/triangledistance\/triangledistance.htm[\/url]","likes":53,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ The MIT License\n\/\/ Copyright \u00a9 2014 Inigo Quilez\n\/\/ Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\/\/ It computes the distance to a triangle.\n\/\/\n\/\/ See here: https:\/\/iquilezles.org\/articles\/triangledistance\n\/\/\n\/\/ In case a mesh was rendered, only one square root would be needed for the\n\/\/ whole mesh. In this example the triangle is given a thckness of 0.01 units\n\/\/ for display purposes. Like the square root, this thickness should be added\n\/\/ only once for the whole mesh too.\n\n\n\/\/ List of other 3D SDFs: https:\/\/www.shadertoy.com\/playlist\/43cXRl\n\/\/\n\/\/ and https:\/\/iquilezles.org\/articles\/distfunctions\n\n\n\/\/ Other triangle functions:\n\/\/\n\/\/ Occlusion:    https:\/\/www.shadertoy.com\/view\/XdjSDy\n\/\/ Distance:     https:\/\/www.shadertoy.com\/view\/4sXXRN\n\/\/ Intersection: https:\/\/www.shadertoy.com\/view\/MlGcDz\n\/\/ Closest:      https:\/\/www.shadertoy.com\/view\/ttfGWl\n\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat udTriangle( in vec3 v1, in vec3 v2, in vec3 v3, in vec3 p )\n{\n    vec3 v21 = v2 - v1; vec3 p1 = p - v1;\n    vec3 v32 = v3 - v2; vec3 p2 = p - v2;\n    vec3 v13 = v1 - v3; vec3 p3 = p - v3;\n    vec3 nor = cross( v21, v13 );\n\n    return sqrt( (sign(dot(cross(v21,nor),p1)) + \n                  sign(dot(cross(v32,nor),p2)) + \n                  sign(dot(cross(v13,nor),p3))<2.0) \n                  ?\n                  min( min( \n                  dot2(v21*clamp(dot(v21,p1)\/dot2(v21),0.0,1.0)-p1), \n                  dot2(v32*clamp(dot(v32,p2)\/dot2(v32),0.0,1.0)-p2) ), \n                  dot2(v13*clamp(dot(v13,p3)\/dot2(v13),0.0,1.0)-p3) )\n                  :\n                  dot(nor,p1)*dot(nor,p1)\/dot2(nor) );\n}\n\n\/\/=====================================================\n\nfloat map( in vec3 p )\n{\n    \/\/ triangle\t\n\tvec3 v1 = 1.5*cos( iTime + vec3(0.0,1.0,1.0) + 0.0 );\n\tvec3 v2 = 1.0*cos( iTime + vec3(0.0,2.0,3.0) + 2.0 );\n\tvec3 v3 = 1.0*cos( iTime + vec3(0.0,3.0,5.0) + 4.0 );\n\tfloat d1 = udTriangle( v1, v2, v3, p ) - 0.01;\n\n    \/\/ ground plane\n\tfloat d2 = p.y + 1.0;\n\n    return min( d1, d2 );\t\n}\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 10.0;\n\tfloat h = 1.0;\n    float t = 0.0;\n    for( int i=0; i<50; i++ )\n    {\n        if( h<0.001 || t>maxd ) break;\n\t    h = map( ro+rd*t );\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n\t\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.002,0.0,0.0);\n\n\treturn normalize( vec3(\n           map(pos+eps.xyy) - map(pos-eps.xyy),\n           map(pos+eps.yxy) - map(pos-eps.yxy),\n           map(pos+eps.yyx) - map(pos-eps.yyx) ) );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n    float t = 0.0;\n\tfloat h = 1.0;\n    for( int i=0; i<20; i++ )\n    {\n        h = map(ro + rd*t);\n        res = min( res, k*h\/t );\n\t\tt += clamp( h, 0.01, 1.0 );\n\t\tif( h<0.0001 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.02 + 0.025*float(i*i);\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return 1.0 - clamp( occ, 0.0, 1.0 );\n}\n\nconst vec3 lig = normalize(vec3(1.0,0.9,0.7));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)\/iResolution.y;\n\n\tvec3 ro = vec3(0.0, 0.25, 2.0 );\n\tvec3 rd = normalize( vec3(p,-1.0) );\n\t\n\tvec3 col = vec3(0.0);\n\n    float t = intersect(ro,rd);\n    if( t>0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\t\tfloat sha = calcSoftshadow( pos + nor*0.01, lig, 32.0 );\n\t\tfloat occ = calcOcclusion( pos, nor );\n\t\tcol =  vec3(0.9,0.6,0.3)*clamp( dot( nor, lig ), 0.0, 1.0 ) * sha;\n\t\tcol += vec3(0.5,0.6,0.7)*clamp( nor.y, 0.0, 1.0 )*occ;\n        col += 0.03;\n\t\tcol *= exp( -0.2*t );\n        col *= 1.0 - smoothstep( 5.0, 10.0, t );\n\t}\n\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\n\t   \n    fragColor = vec4( col, 1.0 );\n}\n\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4ldGDB","date":"1471375113","viewed":11100,"name":"Displacement with Dispersion","username":"cornusammonis","description":"Displacement mapping with chromatic dispersion. The displacement vectors are supplied by an underlying dynamical system. Click to paint.","likes":250,"published":3,"flags":48,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"\/media\/a\/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"\/media\/ap\/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ displacement amount\n#define DISP_SCALE 2.0\n\n\/\/ chromatic dispersion samples\n#define SAMPLES 64\n\n\/\/ contrast\n#define SIGMOID_CONTRAST 12.0\n\n\/\/ channels to use for displacement, either xy or zw\n#define CH xy\n\n\nvec3 contrast(vec3 x) {\n\treturn 1.0 \/ (1.0 + exp(-SIGMOID_CONTRAST * (x - 0.5)));    \n}\n\nvec2 normz(vec2 x) {\n\treturn x == vec2(0) ? vec2(0) : normalize(x);\n}\n\n\/*\n\tThis function supplies a weight vector for each color channel.\n\tIt's analogous to (but not a physically accurate model of)\n\tthe response curves for each of the 3 cone types in the human eye.\n\tThe three functions for red, green, and blue have the same integral\n    over [0, 1], which is 1\/3.\n    Here are some other potential terms for the green weight that \n\tintegrate to 1\/3:\n        2.0*(1-x)*x\n        10.0*((1-x)*x)^2\n        46.667*((1-i)*i)^3\n        210.0*((1-x)*x)^4\n        924.0*((1-x)*x)^5\n    By the way, this series of coefficients is OEIS A004731 divided by 3,\n    which is a pretty interesting series: https:\/\/oeis.org\/A002457\n*\/\nvec3 sampleWeights(float i) {\n\treturn vec3(i * i, 46.6666*pow((1.0-i)*i,3.0), (1.0 - i) * (1.0 - i));\n}\n\nvec3 sampleDisp(vec2 uv, vec2 dispNorm, float disp) {\n    vec3 col = vec3(0);\n    const float SD = 1.0 \/ float(SAMPLES);\n    float wl = 0.0;\n    vec3 denom = vec3(0);\n    for(int i = 0; i < SAMPLES; i++) {\n        vec3 sw = sampleWeights(wl);\n        denom += sw;\n        col += sw * texture(iChannel1, uv + dispNorm * disp * wl).xyz;\n        wl  += SD;\n    }\n    \n    \/\/ For a large enough number of samples,\n    \/\/ the return below is equivalent to 3.0 * col * SD;\n    return col \/ denom;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 texel = 1. \/ iResolution.xy;\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n\n    vec2 n  = vec2(0.0, texel.y);\n    vec2 e  = vec2(texel.x, 0.0);\n    vec2 s  = vec2(0.0, -texel.y);\n    vec2 w  = vec2(-texel.x, 0.0);\n\n    vec2 d   = texture(iChannel0, uv).CH;\n    vec2 d_n = texture(iChannel0, fract(uv+n)).CH;\n    vec2 d_e = texture(iChannel0, fract(uv+e)).CH;\n    vec2 d_s = texture(iChannel0, fract(uv+s)).CH;\n    vec2 d_w = texture(iChannel0, fract(uv+w)).CH; \n\n    \/\/ antialias our vector field by blurring\n    vec2 db = 0.4 * d + 0.15 * (d_n+d_e+d_s+d_w);\n\n    float ld = length(db);\n    vec2 ln = normz(db);\n\n\tvec3 col = sampleDisp(uv, ln, DISP_SCALE * ld);\n    \n    fragColor = vec4(contrast(col), 1.0);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdXGzn","filepath":"\/media\/a\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"\/media\/ap\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"\/presets\/tex00.jpg","previewfilepath":"\/presets\/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/*\n    A fracturing dynamical system\n\tsee: https:\/\/www.shadertoy.com\/view\/MsyXRW\n*\/\n\n#define _G0 0.25\n#define _G1 0.125\n#define _G2 0.0625\n#define W0 -3.0\n#define W1 0.5\n#define TIMESTEP 0.1\n#define ADVECT_DIST 2.0\n#define DV 0.70710678\n\n\/\/ nonlinearity\nfloat nl(float x) {\n    return 1.0 \/ (1.0 + exp(W0 * (W1 * x - 0.5))); \n}\n\nvec4 gaussian(vec4 x, vec4 x_nw, vec4 x_n, vec4 x_ne, vec4 x_w, vec4 x_e, vec4 x_sw, vec4 x_s, vec4 x_se) {\n    return _G0*x + _G1*(x_n + x_e + x_w + x_s) + _G2*(x_nw + x_sw + x_ne + x_se);\n}\n\nbool reset() {\n    return texture(iChannel3, vec2(32.5\/256.0, 0.5) ).x > 0.5;\n}\n\nvec2 normz(vec2 x) {\n\treturn x == vec2(0.0, 0.0) ? vec2(0.0, 0.0) : normalize(x);\n}\n\nvec4 advect(vec2 ab, vec2 vUv, vec2 step) {\n    \n    vec2 aUv = vUv - ab * ADVECT_DIST * step;\n    \n    vec2 n  = vec2(0.0, step.y);\n    vec2 ne = vec2(step.x, step.y);\n    vec2 e  = vec2(step.x, 0.0);\n    vec2 se = vec2(step.x, -step.y);\n    vec2 s  = vec2(0.0, -step.y);\n    vec2 sw = vec2(-step.x, -step.y);\n    vec2 w  = vec2(-step.x, 0.0);\n    vec2 nw = vec2(-step.x, step.y);\n\n    vec4 u =    texture(iChannel0, fract(aUv));\n    vec4 u_n =  texture(iChannel0, fract(aUv+n));\n    vec4 u_e =  texture(iChannel0, fract(aUv+e));\n    vec4 u_s =  texture(iChannel0, fract(aUv+s));\n    vec4 u_w =  texture(iChannel0, fract(aUv+w));\n    vec4 u_nw = texture(iChannel0, fract(aUv+nw));\n    vec4 u_sw = texture(iChannel0, fract(aUv+sw));\n    vec4 u_ne = texture(iChannel0, fract(aUv+ne));\n    vec4 u_se = texture(iChannel0, fract(aUv+se));\n    \n    return gaussian(u, u_nw, u_n, u_ne, u_w, u_e, u_sw, u_s, u_se);\n}\n\n#define SQRT_3_OVER_2 0.86602540378\n#define SQRT_3_OVER_2_INV 0.13397459621\n\nvec2 diagH(vec2 x, vec2 x_v, vec2 x_h, vec2 x_d) {\n    return 0.5 * ((x + x_v) * SQRT_3_OVER_2_INV + (x_h + x_d) * SQRT_3_OVER_2);\n}\n\nvec2 diagV(vec2 x, vec2 x_v, vec2 x_h, vec2 x_d) {\n    return 0.5 * ((x + x_h) * SQRT_3_OVER_2_INV + (x_v + x_d) * SQRT_3_OVER_2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 vUv = fragCoord.xy \/ iResolution.xy;\n    vec2 texel = 1. \/ iResolution.xy;\n    \n    vec2 n  = vec2(0.0, 1.0);\n    vec2 ne = vec2(1.0, 1.0);\n    vec2 e  = vec2(1.0, 0.0);\n    vec2 se = vec2(1.0, -1.0);\n    vec2 s  = vec2(0.0, -1.0);\n    vec2 sw = vec2(-1.0, -1.0);\n    vec2 w  = vec2(-1.0, 0.0);\n    vec2 nw = vec2(-1.0, 1.0);\n\n    vec4 u =    texture(iChannel0, fract(vUv));\n    vec4 u_n =  texture(iChannel0, fract(vUv+texel*n));\n    vec4 u_e =  texture(iChannel0, fract(vUv+texel*e));\n    vec4 u_s =  texture(iChannel0, fract(vUv+texel*s));\n    vec4 u_w =  texture(iChannel0, fract(vUv+texel*w));\n    vec4 u_nw = texture(iChannel0, fract(vUv+texel*nw));\n    vec4 u_sw = texture(iChannel0, fract(vUv+texel*sw));\n    vec4 u_ne = texture(iChannel0, fract(vUv+texel*ne));\n    vec4 u_se = texture(iChannel0, fract(vUv+texel*se));\n    \n    const float vx = 0.5;\n    const float vy = SQRT_3_OVER_2;\n    const float hx = SQRT_3_OVER_2;\n    const float hy = 0.5;\n\n    float di_n  = nl(distance(u_n.xy + n, u.xy));\n    float di_w  = nl(distance(u_w.xy + w, u.xy));\n    float di_e  = nl(distance(u_e.xy + e, u.xy));\n    float di_s  = nl(distance(u_s.xy + s, u.xy));\n    \n    float di_nne = nl(distance((diagV(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ vx, + vy)), u.xy));\n    float di_ene = nl(distance((diagH(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ hx, + hy)), u.xy));\n    float di_ese = nl(distance((diagH(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ hx, - hy)), u.xy));\n    float di_sse = nl(distance((diagV(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ vx, - vy)), u.xy));    \n    float di_ssw = nl(distance((diagV(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- vx, - vy)), u.xy));\n    float di_wsw = nl(distance((diagH(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- hx, - hy)), u.xy));\n    float di_wnw = nl(distance((diagH(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- hx, + hy)), u.xy));\n    float di_nnw = nl(distance((diagV(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- vx, + vy)), u.xy));\n\n    vec2 xy_n  = u_n.xy + n - u.xy;\n    vec2 xy_w  = u_w.xy + w - u.xy;\n    vec2 xy_e  = u_e.xy + e - u.xy;\n    vec2 xy_s  = u_s.xy + s - u.xy;\n    \n    vec2 xy_nne = (diagV(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ vx, + vy)) - u.xy;\n    vec2 xy_ene = (diagH(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ hx, + hy)) - u.xy;\n    vec2 xy_ese = (diagH(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ hx, - hy)) - u.xy;\n    vec2 xy_sse = (diagV(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ vx, - vy)) - u.xy;\n    vec2 xy_ssw = (diagV(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- vx, - vy)) - u.xy;\n    vec2 xy_wsw = (diagH(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- hx, - hy)) - u.xy;\n    vec2 xy_wnw = (diagH(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- hx, + hy)) - u.xy;\n    vec2 xy_nnw = (diagV(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- vx, + vy)) - u.xy;\n\n    vec2 ma = di_nne * xy_nne + di_ene * xy_ene + di_ese * xy_ese + di_sse * xy_sse + di_ssw * xy_ssw + di_wsw * xy_wsw + di_wnw * xy_wnw + di_nnw * xy_nnw + di_n * xy_n + di_w * xy_w + di_e * xy_e + di_s * xy_s;\n\n    vec4 u_blur = gaussian(u, u_nw, u_n, u_ne, u_w, u_e, u_sw, u_s, u_se);\n    \n    vec4 au = advect(u.xy, vUv, texel);\n    vec4 av = advect(u.zw, vUv, texel);\n    \n    vec2 dv = av.zw + TIMESTEP * ma;\n    vec2 du = au.xy + TIMESTEP * dv;\n\n    if (iMouse.z > 0.0) {\n    \tvec2 d = fragCoord.xy - iMouse.xy;\n        float m = exp(-length(d) \/ 50.0);\n        du += 0.2 * m * normz(d);\n    }\n    \n    vec2 init = texture(iChannel1, vUv, 4.0).xy;\n    \/\/ initialize with noise\n    if((length(u) < 0.001 && length(init) > 0.001) || reset()) {\n        fragColor = 8.0 * (vec4(-0.5) + vec4(init.xy, init.xy));\n    } else {\n        du = length(du) > 1.0 ? normz(du) : du;\n        fragColor = vec4(du, dv);\n    }\n    \n\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/*\n    A fluid-like dynamical system\n\tsee: https:\/\/www.shadertoy.com\/view\/XddSRX\n*\/\n\nvec2 normz(vec2 x) {\n\treturn x == vec2(0.0, 0.0) ? vec2(0.0, 0.0) : normalize(x);\n}\n\n\/\/ reverse advection\nvec4 advect(vec2 ab, vec2 vUv, vec2 step, float sc) {\n    \n    vec2 aUv = vUv - ab * sc * step;\n    \n    const float _G0 = 0.25; \/\/ center weight\n    const float _G1 = 0.125; \/\/ edge-neighbors\n    const float _G2 = 0.0625; \/\/ vertex-neighbors\n    \n    \/\/ 3x3 neighborhood coordinates\n    float step_x = step.x;\n    float step_y = step.y;\n    vec2 n  = vec2(0.0, step_y);\n    vec2 ne = vec2(step_x, step_y);\n    vec2 e  = vec2(step_x, 0.0);\n    vec2 se = vec2(step_x, -step_y);\n    vec2 s  = vec2(0.0, -step_y);\n    vec2 sw = vec2(-step_x, -step_y);\n    vec2 w  = vec2(-step_x, 0.0);\n    vec2 nw = vec2(-step_x, step_y);\n\n    vec4 uv =    texture(iChannel0, fract(aUv));\n    vec4 uv_n =  texture(iChannel0, fract(aUv+n));\n    vec4 uv_e =  texture(iChannel0, fract(aUv+e));\n    vec4 uv_s =  texture(iChannel0, fract(aUv+s));\n    vec4 uv_w =  texture(iChannel0, fract(aUv+w));\n    vec4 uv_nw = texture(iChannel0, fract(aUv+nw));\n    vec4 uv_sw = texture(iChannel0, fract(aUv+sw));\n    vec4 uv_ne = texture(iChannel0, fract(aUv+ne));\n    vec4 uv_se = texture(iChannel0, fract(aUv+se));\n    \n    return _G0*uv + _G1*(uv_n + uv_e + uv_w + uv_s) + _G2*(uv_nw + uv_sw + uv_ne + uv_se);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float _K0 = -20.0\/6.0; \/\/ center weight\n    const float _K1 = 4.0\/6.0;   \/\/ edge-neighbors\n    const float _K2 = 1.0\/6.0;   \/\/ vertex-neighbors\n    const float cs = -3.0;  \/\/ curl scale\n    const float ls = 3.0;  \/\/ laplacian scale\n    const float ps = 0.0;  \/\/ laplacian of divergence scale\n    const float ds = -12.0; \/\/ divergence scale\n    const float dp = -6.0; \/\/ divergence update scale\n    const float pl = 0.3;   \/\/ divergence smoothing\n    const float ad = 6.0;   \/\/ advection distance scale\n    const float pwr = 1.0;  \/\/ power when deriving rotation angle from curl\n    const float amp = 1.0;  \/\/ self-amplification\n    const float upd = 0.99;  \/\/ update smoothing\n    const float sq2 = 0.6;  \/\/ diagonal weight\n    \n    vec2 vUv = fragCoord.xy \/ iResolution.xy;\n    vec2 texel = 1. \/ iResolution.xy;\n    \n    \/\/ 3x3 neighborhood coordinates\n    float step_x = texel.x;\n    float step_y = texel.y;\n    vec2 n  = vec2(0.0, step_y);\n    vec2 ne = vec2(step_x, step_y);\n    vec2 e  = vec2(step_x, 0.0);\n    vec2 se = vec2(step_x, -step_y);\n    vec2 s  = vec2(0.0, -step_y);\n    vec2 sw = vec2(-step_x, -step_y);\n    vec2 w  = vec2(-step_x, 0.0);\n    vec2 nw = vec2(-step_x, step_y);\n\n    vec4 uv =    texture(iChannel0, fract(vUv));\n    vec4 uv_n =  texture(iChannel0, fract(vUv+n));\n    vec4 uv_e =  texture(iChannel0, fract(vUv+e));\n    vec4 uv_s =  texture(iChannel0, fract(vUv+s));\n    vec4 uv_w =  texture(iChannel0, fract(vUv+w));\n    vec4 uv_nw = texture(iChannel0, fract(vUv+nw));\n    vec4 uv_sw = texture(iChannel0, fract(vUv+sw));\n    vec4 uv_ne = texture(iChannel0, fract(vUv+ne));\n    vec4 uv_se = texture(iChannel0, fract(vUv+se));\n    \n    \/\/ uv.x and uv.y are the x and y components, uv.z and uv.w accumulate divergence \n\n    \/\/ laplacian of all components\n    vec4 lapl  = _K0*uv + _K1*(uv_n + uv_e + uv_w + uv_s) + _K2*(uv_nw + uv_sw + uv_ne + uv_se);\n    \n    \/\/ calculate curl\n    \/\/ vectors point clockwise about the center point\n    float curl = uv_n.x - uv_s.x - uv_e.y + uv_w.y + sq2 * (uv_nw.x + uv_nw.y + uv_ne.x - uv_ne.y + uv_sw.y - uv_sw.x - uv_se.y - uv_se.x);\n    \n    \/\/ compute angle of rotation from curl\n    float sc = cs * sign(curl) * pow(abs(curl), pwr);\n    \n    \/\/ calculate divergence\n    \/\/ vectors point inwards towards the center point\n    float div  = uv_s.y - uv_n.y - uv_e.x + uv_w.x + sq2 * (uv_nw.x - uv_nw.y - uv_ne.x - uv_ne.y + uv_sw.x + uv_sw.y + uv_se.y - uv_se.x);\n    \n    vec2 norm = normz(uv.xy);\n    \n    float sdx = uv.z + dp * uv.x * div + pl * lapl.z;\n    float sdy = uv.w + dp * uv.y * div + pl * lapl.w;\n\n    vec2 ab = advect(vec2(uv.x, uv.y), vUv, texel, ad).xy;\n    \n    \/\/ temp values for the update rule\n    float ta = amp * ab.x + ls * lapl.x + norm.x * ps * lapl.z + ds * sdx;\n    float tb = amp * ab.y + ls * lapl.y + norm.y * ps * lapl.w + ds * sdy;\n\n    \/\/ rotate\n    float a = ta * cos(sc) - tb * sin(sc);\n    float b = ta * sin(sc) + tb * cos(sc);\n    \n    vec4 abd = upd * uv + (1.0 - upd) * vec4(a,b,sdx,sdy);\n    \n    fragColor = vec4(abd);\n    \n    abd.xy = clamp(length(abd.xy) > 1.0 ? normz(abd.xy) : abd.xy, -1.0, 1.0);\n    fragColor = vec4(abd);\n    \n}","name":"Buf B","description":"","type":"buffer"}]}];    var gUseScreenshots = piIsMobile();
    var gThemeName = "classic";



    </script>
</head>

<!-- <body onload="resultsInit(12,null,null)"> -->
<body onload="resultsInitStatic(12,null,null)">

<!-- header =================================================================================== -->


<div id="header">

    <div id="headerBlock1">
        <a href="/" id="headerTitle">Shadertoy</a>
        <form name="formSearch" action="/results" method="get" style="display:inline-block;">
        <div  id="headerSearch">
            <input type="search" id="mySearch" name="query" placeholder="Search..." value=""/>
        </div>
        </form>
    </div>

    <div id="headerBlock2">
            <a class="headerLinks" href="/browse">Browse</a>
        <a class="headerLinks" href="/new">New</a>
        <a class="headerLinks" href="/signin">Sign In</a>
        </div>
</div>
<!-- content ================================================================================== -->

<div id="content">

  <div id="controls">
    <div>
      <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
      Sort:      </div>
      <div class="controlOptions"><div class="pageButtonsCurrent" href="/results?query=&sort=popular&filter=">Popular</div><a class="pageButtons" href="/results?query=&sort=newest&filter=">Newest</a><a class="pageButtons" href="/results?query=&sort=love&filter=">Love</a><a class="pageButtons" href="/results?query=&sort=hot&filter=">Hot</a></div>
    </div>

    <div id="controlFilter">
      <div style="display:flex;margin-right:8px;align-items:center;">Filter:</div>
      <div class="controlOptions"> <a class="pageButtons" href="/results?query=&sort=popular&filter=multipass">Multipass</a><a class="pageButtons" href="/results?query=&sort=popular&filter=soundoutput">GPU Sound</a><a class="pageButtons" href="/results?query=&sort=popular&filter=vr">VR</a><a class="pageButtons" href="/results?query=&sort=popular&filter=soundinput">Microphone</a><a class="pageButtons" href="/results?query=&sort=popular&filter=musicstream">Soundcloud</a><a class="pageButtons" href="/results?query=&sort=popular&filter=webcam">Webcam</a></div>
    </div>

    <div>
        <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
        View:</div>
        <div><a class="pageButtons" href="/slideshow?query=&sort=popular">Slideshow</a></div>
    </div>

    <div class="navigation" id="navTop" ><span style="padding-right:8px;">Results (74098):</span><div class="controlOptions"><a id="pageButtonFirst" class="pageButtons" href="results?query=&sort=popular&from=0&num=12">1</a><span>...</span><a id="pageButton"0 class="pageButtons" href="results?query=&sort=popular&from=576&num=12">49</a><a id="pageButton"1 class="pageButtons" href="results?query=&sort=popular&from=588&num=12">50</a><div id="pageButton"2 class="pageButtonsCurrent" href="results?query=&sort=popular&from=600&num=12">51</div><a id="pageButton"3 class="pageButtons" href="results?query=&sort=popular&from=612&num=12">52</a><a id="pageButton"4 class="pageButtons" href="results?query=&sort=popular&from=624&num=12">53</a><span>...</span><a id="pageButtonLast" class="pageButtons" href="results?query=&sort=popular&from=74088&num=12">6175</a></div>
</div>
  </div>


  <div id="shaderGrid">
    <div class='searchResult'><div class='searchResultContainer' id='Preview_0_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_0_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_0_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_0_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_0_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_0_Thumnail'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_0_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_0_Info'>  <span class='previewText'  id='Preview_0_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_0_TextUser'></span>  <span class='previewStats' id='Preview_0_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_1_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_1_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_1_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_1_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_1_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_1_Thumnail'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_1_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_1_Info'>  <span class='previewText'  id='Preview_1_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_1_TextUser'></span>  <span class='previewStats' id='Preview_1_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_2_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_2_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_2_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_2_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_2_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_2_Thumnail'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_2_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_2_Info'>  <span class='previewText'  id='Preview_2_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_2_TextUser'></span>  <span class='previewStats' id='Preview_2_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_3_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_3_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_3_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_3_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_3_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_3_Thumnail'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_3_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_3_Info'>  <span class='previewText'  id='Preview_3_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_3_TextUser'></span>  <span class='previewStats' id='Preview_3_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_4_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_4_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_4_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_4_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_4_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_4_Thumnail'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_4_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_4_Info'>  <span class='previewText'  id='Preview_4_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_4_TextUser'></span>  <span class='previewStats' id='Preview_4_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_5_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_5_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_5_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_5_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_5_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_5_Thumnail'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_5_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_5_Info'>  <span class='previewText'  id='Preview_5_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_5_TextUser'></span>  <span class='previewStats' id='Preview_5_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_6_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_6_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_6_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_6_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_6_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_6_Thumnail'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_6_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_6_Info'>  <span class='previewText'  id='Preview_6_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_6_TextUser'></span>  <span class='previewStats' id='Preview_6_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_7_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_7_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_7_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_7_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_7_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_7_Thumnail'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_7_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_7_Info'>  <span class='previewText'  id='Preview_7_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_7_TextUser'></span>  <span class='previewStats' id='Preview_7_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_8_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_8_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_8_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_8_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_8_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_8_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_8_Thumnail'>        <img class='previewThumbnailImage' id='Preview_8_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_8_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_8_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_8_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_8_Info'>  <span class='previewText'  id='Preview_8_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_8_TextUser'></span>  <span class='previewStats' id='Preview_8_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_9_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_9_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_9_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_9_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_9_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_9_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_9_Thumnail'>        <img class='previewThumbnailImage' id='Preview_9_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_9_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_9_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_9_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_9_Info'>  <span class='previewText'  id='Preview_9_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_9_TextUser'></span>  <span class='previewStats' id='Preview_9_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_10_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_10_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_10_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_10_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_10_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_10_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_10_Thumnail'>        <img class='previewThumbnailImage' id='Preview_10_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_10_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_10_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_10_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_10_Info'>  <span class='previewText'  id='Preview_10_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_10_TextUser'></span>  <span class='previewStats' id='Preview_10_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_11_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_11_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_11_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_11_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_11_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_11_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_11_Thumnail'>        <img class='previewThumbnailImage' id='Preview_11_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_11_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_11_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_11_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_11_Info'>  <span class='previewText'  id='Preview_11_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_11_TextUser'></span>  <span class='previewStats' id='Preview_11_Stats'></span></div></div>  </div>
  <br>
  <div class="navigation" id="navBottom" ><span style="padding-right:8px;">Results (74098):</span><div class="controlOptions"><a id="pageButtonFirst" class="pageButtons" href="results?query=&sort=popular&from=0&num=12">1</a><span>...</span><a id="pageButton"0 class="pageButtons" href="results?query=&sort=popular&from=576&num=12">49</a><a id="pageButton"1 class="pageButtons" href="results?query=&sort=popular&from=588&num=12">50</a><div id="pageButton"2 class="pageButtonsCurrent" href="results?query=&sort=popular&from=600&num=12">51</div><a id="pageButton"3 class="pageButtons" href="results?query=&sort=popular&from=612&num=12">52</a><a id="pageButton"4 class="pageButtons" href="results?query=&sort=popular&from=624&num=12">53</a><span>...</span><a id="pageButtonLast" class="pageButtons" href="results?query=&sort=popular&from=74088&num=12">6175</a></div>
</div>  <br>      
</div>

<!-- footer ================================================================================== -->

<div id="footer">
    
    <div><span style="color:#ffffff;">Community Forums</span>
      <ul>
      <li><a class="regular" href="/events">Official Events</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/147749602472741">In Facebook (english)</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/1339783682699494">In Facebook (korean)</a></li>
      <li><a class="regular" href="https://discord.gg/XtmMN6E">In Discord</a> (<a class="regular" href="https://discordapp.com/channels/578696555612209173/579531723348639754">direct link</a>)</li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Feedback and Support</span>
      <ul>
      <li><a class="regular" href="https://www.facebook.com/Shadertoy">Facebook</a></li>
      <li><a class="regular" href="https://twitter.com/shadertoy">Twitter</a></li>
      <li><a class="regular" href="https://www.patreon.com/shadertoy">Patreon</a></li>
      <li><a class="regular" href="https://trello.com/b/5hM0CjId">Roadmap</a></li>

      
      </ul>
    </div>

    <div><span style="color:#ffffff;">Shadertoy</span>
      <ul>
      <li><a class="regular" href="/store">Store</a></li>
      <li><a class="regular" href="/howto">Documentation</a></li>
      <li><a class="regular" href="/terms">Terms & Privacy</a></li>
      <li><a class="regular" href="/about">About</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Apps and Plugins</span>
      <ul>
      <li><a class="regular" href="https://itunes.apple.com/us/app/shadertoy/id717961814">Official iPhone App</a> by <a class="user" href="/user/reinder">Reinder</a></li>
      <li><a class="regular" href="https://steamcommunity.com/sharedfiles/filedetails/?id=1726697188">Screensaver</a> by <a class="user" href="/user/kosro">Kosro</a></li>
      <li><a class="regular" href="https://chrome.google.com/webstore/detail/shadertoy-unofficial-plug/ohicbclhdmkhoabobgppffepcopomhgl">Shadertoy plugin</a> by <a class="user" href="/user/patu">Patu</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Tutorials</span>
      <ul>
      <li><a class="regular" href="https://www.youtube.com/watch?v=0ifChJ0nJfM">Shader coding intro</a> by <a class="user" href="/user/iq">iq</a></li>
      <li><a class="regular" href="https://shadertoyunofficial.wordpress.com/">Shadertoy Unofficial</a> by <a class="user" href="/user/FabriceNeyret2">FabriceNeyret2</a></li>
      </ul>
    </div>

</div>

<div id="compliance" style="padding-bottom:6px;visibility:hidden;left:0;top:0px;width:100%;background-color:rgb(200,120,20,0.93);position:absolute;color:#FFFFFF">
    <div style="text-align: center; margin-top:8px">
        We use cookies to give you the best experience on our website. If you continue using Shadertoy, we'll assume that you are happy to receive all cookies on this website. 
        For more information, please review our <a class="regular" href="/terms">Terms & Privacy</a>.
    </div> 
    <div style="text-align: center;margin-top:6px">
        <button type="button" style="width:100px;font-size:inherit" onclick="acceptCompliance()">Accept</button>
    </div>
</div>

<script>
(function runCompliance() 
{
    let showCompliance = 1;
    let allcookies = document.cookie;
    let cookiearray = allcookies.split(';');
    for (var i=0; i<cookiearray.length; i++)
    {
        let name  = cookiearray[i].split('=')[0];
        let value = cookiearray[i].split('=')[1];
        if (name.trim() == "scmp") 
        {
            showCompliance = value;
            break;
        }
    }

    if (showCompliance === 1) 
    {
        var ve = document.getElementById("compliance");
        ve.style.visibility="visible";
    }
})();

function acceptCompliance()
{
    let now = new Date();
    now.setTime( now.getTime() + (5*365*24*60*60*1000) );
    document.cookie="scmp=0;expires=" + now.toUTCString() + ";";

    var ve = document.getElementById("compliance");
    ve.style.visibility="hidden";
}
</script>

</body>
</html>
