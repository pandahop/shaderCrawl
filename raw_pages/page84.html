<!DOCTYPE HTML>
<html lang="en">
<head>

    
<script async src="https://www.googletagmanager.com/gtag/js?id=G-7SYLWGZYJ2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-7SYLWGZYJ2');
</script>

<title>Browse (85) - Shadertoy BETA</title>
<meta charset="utf-8" />
<meta name="Keywords" content="shadertoy, shader toy, quilez, inigo, jeremias, pol, fractals, demoscene, computer graphics, mathematics, rendering, demo, 3D, realtime, shader, raytracing, raymarching, webgl, glsl" />
<meta name="Description" content="Build shaders, share them, and learn from the best community." />
<meta name="Author" content="Beautypi" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<link rel="image_src" href="https://www.shadertoy.com/img/logo.png" />
<link rel="apple-touch-icon" href="/img/launch_icon_57.png"/>
<link rel="apple-touch-icon" sizes="72x72" href="/img/launch_icon_72.png"/>
<link rel="apple-touch-icon" sizes="114x114" href="/img/launch_icon_114.png"/>
<link rel="shortcut icon" href="/img/favicon.ico"/>

<style>::-webkit-scrollbar {
    height: 8px;
    width: 8px;
    background: #404040;
}

::-webkit-scrollbar-thumb
{
    background: #909090;
    border-radius: 0ex;
}

::-webkit-scrollbar-corner
{
    background: #000;
}

::-webkit-input-placeholder
{
	font-style:italic;
}
input:-moz-placeholder, textarea:-moz-placeholder
{
	font-style:italic;
}
input.placeholder-text, textarea.placeholder-text
{
	font-style:italic;
}

pre 
{
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
    white-space: -pre-wrap;
    white-space: -o-pre-wrap;
    word-wrap: break-word;
}

@font-face
{
    font-family: Lobster;
    src: url("/img/lobster.otf") format("opentype");
}

div#centerScreen
{
    left: 50%;
    top: 50%;
    position: absolute;
}

a.headerLinks:hover
{
    background-color:#505050;
    color : #ff8020;
}

body
{
    color: #000000;
    font-size:12px;
    font-style:normal;
    font-family:Tahoma,Arial;
    background-repeat: no-repeat;
    //background-attachment: fixed;
    padding:0px;
    margin:0px;
    text-align: left;
    background-color: #d0d0d0;
    background-repeat: repeat;
    user-select: text;
}

a,
a:hover,
a:visited
{
  color : inherit;
}

div#content {
    width: 95%;
    overflow: hidden;
    margin: auto;
    padding: 0px;
    min-height: calc(100vh - 80px);
    //box-sizing: border-box;
}


.notificationCount
{
 background-color:#ff0000;
 padding-left:3px;
 padding-right:1px;
 padding-top:1px;
 padding-bottom:1px;
}

div#header
{
    background-color: #404040;
    top: 0px;
    left: 0px;
    width: 100%;
    padding: 0;
    margin: 0;
    color: #ffffff;
    display: flex;
    flex-direction:row;
}

#headerBlock1
{
    width: 50%;
    display:flex;
    align-items:center;
}

a#headerTitle
{
    font-size: 2.25em;
    font-family: Lobster,Tahoma,Arial;
    text-decoration: none;
    padding-left:32px;
    padding-right:32px;
}

#headerSearch
{
    display: inline-block;
    color: #000000;
    width: 300px;
}

input[type=search]#mySearch
{
    width: 100%;
    border-radius: 6px;
    border: 1px solid black;
    padding:12px;
}

#headerBlock2
{
    width: 50%;
    margin-left: auto;
    display: flex;
    justify-content: flex-end;
}


a#headerTitle:hover
{
    color : #ff8020;
}

a.headerLinks
{
    font-weight: bold;
    padding-top: 14px;
    padding-bottom: 14px;
    padding-left: 14px;
    padding-right: 14px;
    margin:0px;
    text-decoration: none;
    transition: background-color 0.15s linear, color 0.15s linear;
}

#footer
{
    background-color: rgba(64,64,64,0.25);
    color: #000000;
    padding: 0px;
    margin: 0px;
    width: 100%;
    display: flex;
    justify-content: space-between;
    flex-wrap: wrap;
}

#footer div
{
    padding-top:10px;
    padding-bottom:0px;
    padding-left:16px;
    padding-right:16px;
}

#footer div ul
{
    margin-left:0px;
    padding-left:16px;
}

#footer div ul li
{
    padding-top:6px;
}

a.regular
{
    font-weight:bold;
    text-decoration:none
}

a.regular:hover
{
  color : #ff8020;
}

a.user
{
    font-weight:bold;
    text-decoration:none;
}

a.user:hover
{
  color : #ff8020;
  text-decoration: underline;
}

.uiButton
{
    border: none;
    outline: none;
    margin: 0px;
    padding: 0px;
    width: 22px;
    height: 22px;
    position: absolute;
    cursor: pointer;
    border-radius: 4px;
}

.uiButton:hover
{
    box-shadow: inset 0px 0px 1px 1px #808080, 0px 0px 1px 1px #808080;
}

.uiDivBUtton
{
    cursor:pointer;
}

.uiDivBUtton:hover
{
    color: #ffffff;
}


.dialog
{
    display: block;
    background-color: #e0e0e0;
    color: #000000;
    border:1px solid #000;
    padding:0px;
    margin:0px;
    text-align:left;
    border-radius: 4px;
    box-shadow:4px 4px 6px 0px rgba(0,0,0,0.5);
    overflow: hidden;
    z-index:1000;
    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;
}

.dialogHeader
{
    left:0px;
    top: 0px;
    width:100%;
    height:32px;
    position: absolute;
    background-color: #808080;
    cursor:move;
}

.dialogTitle
{
    left: 12px;
    top: 4px;
    position: absolute;
    padding: 0px;
    margin: 0px;
    color:#000000;
    font-size:1.5em;
    text-align: left;
    user-select: none;
    -moz-user-select: -moz-none;
    -webkit-user-select: none;
}

.dialogOverlay
{
    z-index:1000;

    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;

    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    width:100%;
    height:100%;
    position:absolute;

    background-color:rgba(0,0,0,.4);
}

.viewsIcon, .likesIcon
{
    border: none;
    outline: none;
    display:inline-block;
    background-repeat:no-repeat;
    top:0px;
    left:0px;
    padding:0px;
    padding-right: 2px;
    margin:0px;
    position:relative;
}

.userPictureSmall
{
    background-color:#808080;
    border: 1px solid #000000;
    width:32px;
    height:32px;
}

.dialogCloseButton
{
    right:8px;
    top: 4px;
    width:22px;
    height:22px;
    position: absolute;
    background-image: url("/img/close.png");
    cursor: pointer;
    border-radius: 4px;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContentButtons
{
     padding:0;
     border:0;
     text-align: justify;
     left: 24px;
     bottom:40px;
     position:absolute;
}

.dialogButton
{
    text-align: center;
    vertical-align: middle;
    display: inline-block;
    border-radius: 4px;
    font-weight: bold;
    cursor: pointer;
    padding-bottom:5px;
    padding-top:4px;
    padding-left: 8px;
    padding-right: 8px;
    margin-left:4px;
    margin-right:4px;
    text-decoration: none;
    color:#000000;
    width: 80px;
    -moz-transition:    background-color 0.15s linear, color 0.15s linear;
    -webkit-transition: background-color 0.15s linear, color 0.15s linear;
    transition:         background-color 0.15s linear, color 0.15s linear;
}

.dialogButton:hover
{
  background-color:#808080;
  color : #ff8020;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContent
{
    color: inherit;
    overflow: auto;
    width:100%;
    height:100%;
    left: 0px;
    top: 32px;
    position:absolute
}

.dialogContentBody
{
    color: inherit;
    width:100%;
    height:auto;
    padding-top:24px;
    padding-bottom:24px;
    padding-left:24px;
    padding-right:24px;
    text-align: left;
}

.formButton
{
    font-weight:bold;
	color:#ffffff;
	border:none;
    text-align:center;
	background-color:#808080;
    border-radius: 4px;
	padding-left:8px;
	padding-right:8px;
	padding-top:4px;
	padding-bottom:4px;
    cursor:pointer;
    min-width:80px;
    box-sizing: border-box;
}
.formInput {
    border-radius: 6px;
    border: 1px solid black;
    padding: 4px;
    border: none;
}
.formButton:hover {
    background-color: #e0e0e0;
}
.formButton:disabled
{
	color:#b0b0b0;
	background-color:#808080;
}

.formButtonSmall
{
    color:#ffffff;
    border:none;
    text-align:center;
    background-color:#808080;
    border-radius: 4px;
    padding-left:2px;
    padding-right:2px;
    padding-top:2px;
    padding-bottom:2px;
    cursor:pointer;
    min-width:40px;
}

.formButtonSmall:hover
{
    background-color: #e0e0e0;
}

.formButtonSmall:disabled
{
    color:#b0b0b0;
    background-color:#808080;
}

.formButtonSmall.disabled2,
.formButton.disabled2 { color:#b0b0b0; background-color:#808080; pointer-events: none; }

.inputForm
{
    padding-left:2%;
    padding-right:2%;
    resize: none;
    text-align: left;
    background-color:#e0e0e0;
    outline: none;
    border-radius: 4px;
    border: 1px solid #808080;
    color:inherit;
    box-sizing: border-box;
}

.inputForm:focus
{
    border: 1px solid #AFCDD8;
    background-color: #EBF2F4;
}

.transparentPannel
{
    background-color:rgba(64,64,64,0.1);
    padding:16px;
}

.comment, .commentSelf, .commentNew
{
    border-radius: 4px;
    width: 100%;
    margin-left: 0px;
    margin-right: 0px;
    margin-top: 0px;
    margin-bottom: 6px;

    padding: 14px;
    box-sizing: border-box;
    display: grid;
    grid-template-columns: 32px auto 8px;
    grid-template-rows: 1fr;
    grid-gap:8px;
}

.comment:nth-child(even)
{
    background-color: rgba(64,64,64,0.1);
}

.comment:nth-child(odd)
{
    background-color: rgba(128,128,128,0.1);
}

.commentSelf
{
    background-color: rgba(240,160,64,0.1);
}

.commentNew
{
    padding-right: 0px;
    grid-template-columns: 40px auto;
}

.commentContent
{
    vertical-align: top;
    text-align: left;
    word-break: break-all;
    word-break: break-word;
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
}


/* ----------------------- media resolutions ------------------------ */

@media screen and (max-width:799px)
{
    div#header {flex-direction:column; }
    #headerBlock1 { width:100%; }
    #headerBlock2 { width:100%; justify-content: space-around;}
    div#headerSearch {width:200px;}
    input#mySearch { width:200px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:10px; }
}

@media screen and (min-width:800px) and (max-width:1279px)
{
    body { font-size: 9px; }
    div#headerSearch {width: 250px;}
    input#mySearch { width:250px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:11px; }
}

@media screen and (min-width:1280px) and (max-width:1439px)
{
    body { font-size: 10px; }
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1440px) and (max-width:1919px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1920px) and (max-width:2559px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}

@media screen and (min-width:2560px) 
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}
body
{
    background-image: url("/img/themes/classic/background.jpg");
}
</style>

    <script>"use strict"

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piCamera
//
//==============================================================================

function piCamera()
{
    var mMatrix = setIdentity();
    var mMatrixInv = setIdentity();

    var mPosition = [0.0,0.0,0.0];
    var mXRotation = 0.0;
    var mYRotation = 0.0;

    var mPositionTarget = [0.0,0.0,0.0];
    var mXRotationTarget = 0.0;
    var mYRotationTarget = 0.0;

    var me = {};
/*
    me.Set = function( pos, dir, roll) 
             {
                 mMatrix    = setLookat( pos, add(pos,dir), [Math.sin(roll),Math.cos(roll),Math.sin(roll)] );
                 mMatrixInv = invertFast( mMatrix );
             };
*/
    me.SetPos = function(pos)
                {
                    mPosition = pos;
                    //mMatrix[ 3] = -(mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                    //mMatrix[ 7] = -(mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                    //mMatrix[11] = -(mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                };
/*
    me.GlobalMove = function(pos)
                    {
                        mMatrix[ 3] -= (mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                        mMatrix[ 7] -= (mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                        mMatrix[11] -= (mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                        mMatrixInv = invertFast(mMatrix);
                    };
*/
    me.LocalMove = function( dis )
                    {
                        dis = matMulvec( setRotationY(-mYRotation), dis);
                        mPositionTarget = sub(mPositionTarget,dis)
                    };

    me.RotateXY = function( x, y)
                  {
                    mXRotationTarget -= x;
                    mYRotationTarget -= y;
                    mXRotationTarget = Math.min( Math.max( mXRotationTarget, -Math.PI/2), Math.PI/2 );
                  };


    me.CameraExectue = function( dt )
    {
        // smooth position
        mXRotation += (mXRotationTarget-mXRotation) * 12.0*dt;
        mYRotation += (mYRotationTarget-mYRotation) * 12.0*dt;
        mPosition = add(mPosition, mul( sub(mPositionTarget, mPosition), 12.0*dt));

        // Make Camera matrix
        mMatrix = matMul( matMul(setRotationX(mXRotation), 
                                 setRotationY(mYRotation)),  
                                 setTranslation(mPosition));
        mMatrixInv = invertFast(mMatrix);

    }

    me.GetMatrix = function() { return mMatrix; };
    me.GetMatrixInverse = function() { return mMatrixInv; };
    me.SetMatrix = function( mat ) 
                    {
                        mMatrix = mat;
                        mMatrixInv = invertFast(mMatrix);

                        mPosition = getXYZ(matMulpoint(mat, [0.0,0.0,0.0]));
                        mPositionTarget = mPosition;
                    };

    me.GetPos = function() { return getXYZ(matMulpoint(mMatrixInv, [0.0,0.0,0.0])); }
    me.GetDir = function() { return getXYZ(normalize(matMulvec(mMatrixInv, [0.0,0.0,-1.0]))); }

    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piFile
//
//==============================================================================

function piFile( binaryDataArrayBuffer )
{
    // private
    //var mDataView = new DataView( binaryDataArrayBuffer, 0 );
    var mDataView = binaryDataArrayBuffer;
    var mOffset = 0;

    // public members
    var me = {};
    me.mDummy = 0;
/*
    // public functions
    me.Seek = function( off ) { mOffset = off - 3; };
    me.ReadUInt16 = function()  { var res = mDataView.getUint16( mOffset ); mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = mDataView.getUint32( mOffset ); mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = mDataView.getFloat32( mOffset ); mOffset+=4; return res; };
*/

    me.Seek = function( off ) { mOffset = off; };
    me.ReadUInt8  = function()  { var res = (new Uint8Array(mDataView,mOffset))[0]; mOffset+=1; return res; };
    me.ReadUInt16 = function()  { var res = (new Uint16Array(mDataView,mOffset))[0]; mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = (new Uint32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = (new Float32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadFloat32Array = function(n) 
                          { 
                              var src = new Float32Array(mDataView, mOffset);
                              var res = [];  for( var i=0; i<n; i++ ) { res[i] = src[i]; }
                              mOffset += 4*n;
                              return res;
                          };
    me.ReadFloat32ArrayNative = function(n) { var src = new Float32Array(mDataView, mOffset); mOffset += 4*n; return src; };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piMesh
//
//==============================================================================

function piMesh()
{
    this.mChunks = [];
    this.mPrimitiveType = 0;
    this.mVertexFormat = null;
}

/*
piMesh.prototype.normalize = function( ppos, npos )
{
    var numv = this.mVertexData.length;
    var numt = this.mIndices.length;

    for( var i=0; i<numv; i++ )
    {
        //float *v = (float*)piMesh_GetVertexData( me, i, npos );
        //v[0] = 0.0f;
        //v[1] = 0.0f;
        //v[2] = 0.0f;
        this.mVerts[8 * i + 3] = 0.0;
        this.mVerts[8 * i + 4] = 0.0;
        this.mVerts[8 * i + 5] = 0.0;
    }

    for( var i=0; i<numt; i++ )
    {
        piMeshFace *face = me->mFaceData.mIndexArray[0].mBuffer + i;

        const int ft = face->mNum;
        
        vec3 nor = vec3( 0.0f, 0.0f, 0.0f );
        for( int j=0; j<ft; j++ )
        {
            const vec3 va = *((vec3*)piMesh_GetVertexData( me, face->mIndex[ j      ], ppos ));
            const vec3 vb = *((vec3*)piMesh_GetVertexData( me, face->mIndex[(j+1)%ft], ppos ));

            nor += cross( va, vb );
        }

        for( int j=0; j<ft; j++ )
        {
            vec3 *n = (vec3*)piMesh_GetVertexData( me, face->mIndex[j], npos );
            n->x += nor.x;
            n->y += nor.y;
            n->z += nor.z;
        }
    }

    for( var i=0; i<numv; i++ )
    {
        vec3 *v = (vec3*)piMesh_GetVertexData( me, i, npos );
        *v = normalize( *v );
    }
}
*/

piMesh.prototype.createCube = function(renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([ -1.0, -1.0, -1.0,
                                       1.0, -1.0, -1.0,
                                      -1.0,  1.0, -1.0,
                                       1.0,  1.0, -1.0,
                                      -1.0, -1.0,  1.0,
                                       1.0, -1.0,  1.0,
                                      -1.0,  1.0,  1.0,
                                       1.0,  1.0,  1.0 ]),

                        mIndices : new Uint16Array([ 0, 2, 1,   1, 2, 3,   5, 1, 3,   5, 3, 7,   4, 5, 7,   4, 7, 6,   4, 6, 2,   4, 2, 0,   6, 7, 3,   6, 3, 2,   4, 0, 1,   4, 1, 5 ]),
                        mNumVertices : 8,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };

    this.mVertexFormat = { mStride:12, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}

piMesh.prototype.createCubeSharp = function (renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 1.0,
                                    -1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 0.0,

                                     1.0, 1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 0.0,

                                     1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 1.0,
                                    -1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   1.0, 1.0,
                                     1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   1.0, 0.0,

                                    -1.0, 1.0, 1.0,  -1.0, 0.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0,-1.0,  -1.0, 0.0, 0.0,   0.0, 1.0,
                                    -1.0,-1.0,-1.0,  -1.0, 0.0, 0.0,   1.0, 1.0,
                                    -1.0,-1.0, 1.0,  -1.0, 0.0, 0.0,   1.0, 0.0 ]),

                        mIndices : new Uint16Array([0,1,2, 0,2,3,   4,5,6, 4,6,7,    8,9,10,8,10,11,   12,13,14,12,14,15,   16,17,18,16,18,19,   20,21,22,20,22,23]),
                        mNumVertices : 24,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };


    this.mVertexFormat = { mStride:32, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}


piMesh.prototype.createUnitQuad = function (renderer)
{
    this.mPrimitiveType = 0;
    this.mVertexFormat = { mStride:8, mChannels: [ {mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false} ] };

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0,  1.0, 1.0,  1.0]),
                        mIndices : new Uint16Array([0, 2, 1, 1, 2, 3]),
                        mNumVertices : 4,
                        mNumFaces : 2, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };
 
    return true;
}




piMesh.prototype.destroy = function()
{
    //delete this.mVerts;   this.mVerts = null;
    //delete this.mIndices; this.mIndices = null;
}

piMesh.prototype.scale = function (x, y, z)
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] *= x;
            this.mChunks[j].mVerts[stride * i + 1] *= y;
            this.mChunks[j].mVerts[stride * i + 2] *= z;
        }
    }
}

piMesh.prototype.translate = function (x, y, z) 
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] += x;
            this.mChunks[j].mVerts[stride * i + 1] += y;
            this.mChunks[j].mVerts[stride * i + 2] += z;
        }
    }
}

piMesh.prototype.GPULoad = function (renderer)
{
    for( var i=0; i<this.mChunks.length; i++ )
    {
        var vbo = renderer.CreateVertexArray(this.mChunks[i].mVerts, renderer.BUFTYPE.STATIC );
        if (vbo == null)
            return false;

        var ibo = renderer.CreateIndexArray(this.mChunks[i].mIndices, renderer.BUFTYPE.STATIC);
        if (ibo == null)
            return false;

        this.mChunks[i].mVBO = vbo;
        this.mChunks[i].mIBO = ibo;
    }
    return true;
}

piMesh.prototype.GPURender = function (renderer, positions )//, matPrj, matCam )
{
    //renderer.SetShaderConstantMat4F("unMPrj", matPrj, false );

    var num = this.mChunks.length;
    for( var i=0; i<num; i++ )
    {
        //var mat =  matMul( matCam, this.mChunks[i].mTransform );
        //renderer.SetShaderConstantMat4F("unMMod", mat, false);

        renderer.AttachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat, positions );
        renderer.AttachIndexArray(this.mChunks[i].mIBO );
        renderer.DrawPrimitive(renderer.PRIMTYPE.TRIANGLES, this.mChunks[i].mNumFaces * 3, true, 1);
        renderer.DetachIndexArray(this.mChunks[i].mIBO);
        renderer.DetachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat );
    }
}
//==============================================================================
//
// piLibs 2014-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piRenderer
//
//==============================================================================

function piRenderer()
{
    // private members

    var mGL = null;
    var mBindedShader = null;
    var mIs20 = false;
    var mFloat32Textures;
    var mFloat32Filter;
    var mFloat16Textures;
    var mDrawBuffers;
    var mDepthTextures;
    var mDerivatives;
    var mFloat16Filter;
    var mShaderTextureLOD;
    var mAnisotropic;
    var mRenderToFloat32F;
    var mDebugShader;
    var mAsynchCompile;

    var mVBO_Quad = null;
    var mVBO_Tri = null;
    var mVBO_CubePosNor = null;
    var mVBO_CubePos = null;
    var mShaderHeader = ["",""];
    var mShaderHeaderLines = [0,0];

    // public members
    var me = {};

    me.CLEAR      = { Color: 1, Zbuffer : 2, Stencil : 4 };
    me.TEXFMT     = { C4I8 : 0, C1I8 : 1, C1F16 : 2, C4F16 : 3, C1F32 : 4, C4F32 : 5, Z16 : 6, Z24 : 7, Z32 : 8, C3F32:9 };
    me.TEXWRP     = { CLAMP : 0, REPEAT : 1 };
    me.BUFTYPE    = { STATIC : 0, DYNAMIC : 1 };
    me.PRIMTYPE   = { POINTS : 0, LINES : 1, LINE_LOOP : 2, LINE_STRIP : 3, TRIANGLES : 4, TRIANGLE_STRIP : 5 };
    me.RENDSTGATE = { WIREFRAME : 0, FRONT_FACE : 1, CULL_FACE : 2, DEPTH_TEST : 3, ALPHA_TO_COVERAGE : 4 };
    me.TEXTYPE    = { T2D : 0, T3D : 1, CUBEMAP : 2 };
    me.FILTER     = { NONE : 0, LINEAR : 1, MIPMAP : 2, NONE_MIPMAP : 3 };
    me.TYPE       = { UINT8 : 0, UINT16 : 1, UINT32 : 2, FLOAT16: 3, FLOAT32 : 4, FLOAT64: 5 };

    // private functions

    var iFormatPI2GL = function( format )
    {
        if( mIs20 )
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA8,           mGLExternal: mGL.RGBA,             mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.R8,              mGLExternal: mGL.RED,              mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.R16F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA16F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.R32F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA32F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C3F32) return { mGLFormat: mGL.RGB32F,          mGLExternal: mGL.RGB,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT16, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z24)   return { mGLFormat: mGL.DEPTH_COMPONENT24, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z32)   return { mGLFormat: mGL.DEPTH_COMPONENT32F, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        }
        else
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.RED,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT, mGLExternal: mGL.DEPTH_COMPONENT, mGLType: mGL.UNSIGNED_SHORT }
        }

        return null;
     }

    // public functions

    me.Initialize = function( gl )
                    {
                        mGL = gl;

                        mIs20 = !(gl instanceof WebGLRenderingContext);

                        if( mIs20 )
                        {
                            mFloat32Textures  = true;
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = true;
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = true;
                            mDrawBuffers      = true;
                            mDepthTextures    = true;
                            mShaderTextureLOD = true;
                            mAnisotropic = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mGL.getExtension( 'EXT_color_buffer_float');
                            mDebugShader = mGL.getExtension('WEBGL_debug_shaders');
                            mAsynchCompile = mGL.getExtension('KHR_parallel_shader_compile');

							mGL.hint( mGL.FRAGMENT_SHADER_DERIVATIVE_HINT, mGL.NICEST);
                        }
                        else
                        {
                            mFloat32Textures  = mGL.getExtension( 'OES_texture_float' );
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = mGL.getExtension( 'OES_texture_half_float' );
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = mGL.getExtension( 'OES_standard_derivatives' );
                            mDrawBuffers      = mGL.getExtension( 'WEBGL_draw_buffers' );
                            mDepthTextures    = mGL.getExtension( 'WEBGL_depth_texture' );
                            mShaderTextureLOD = mGL.getExtension( 'EXT_shader_texture_lod' );
                            mAnisotropic      = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mFloat32Textures;
                            mDebugShader      = null;
                            mAsynchCompile    = null;
							
							if( mDerivatives !== null) mGL.hint( mDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, mGL.NICEST);
                        }
                        
                        
                        var maxTexSize = mGL.getParameter( mGL.MAX_TEXTURE_SIZE );
                        var maxCubeSize = mGL.getParameter( mGL.MAX_CUBE_MAP_TEXTURE_SIZE );
                        var maxRenderbufferSize = mGL.getParameter( mGL.MAX_RENDERBUFFER_SIZE );
                        var extensions = mGL.getSupportedExtensions();
                        var textureUnits = mGL.getParameter( mGL.MAX_TEXTURE_IMAGE_UNITS );
                        console.log("WebGL (2.0=" + mIs20 + "):" +
                                    " Asynch Compile: "  + ((mAsynchCompile !==null) ? "yes" : "no") +
                                    ", Textures: F32 ["   + ((mFloat32Textures !==null) ? "yes" : "no") +
                                    "], F16 ["   + ((mFloat16Textures !==null) ? "yes" : "no") +
                                    "], Depth [" + ((mDepthTextures   !==null) ? "yes" : "no") +
                                    "], LOD ["    + ((mShaderTextureLOD!==null) ? "yes" : "no") +
                                    "], Aniso ["   + ((mAnisotropic     !==null) ? "yes" : "no") +
                                    "], Units [" + textureUnits +
                                    "], Max Size [" + maxTexSize +
                                    "], Cube Max Size [" + maxCubeSize +
                                    "], Targets: MRT ["            + ((mDrawBuffers     !==null) ? "yes" : "no") +
                                    "], F32 ["     + ((mRenderToFloat32F!==null) ? "yes" : "no") +
                                    "], Max Size [" + maxRenderbufferSize + "]");

                        // create a 2D quad Vertex Buffer
                        var vertices = new Float32Array( [ -1.0, -1.0,   1.0, -1.0,    -1.0,  1.0,     1.0, -1.0,    1.0,  1.0,    -1.0,  1.0] );
                        mVBO_Quad = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                        mGL.bufferData( mGL.ARRAY_BUFFER, vertices, mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 2D triangle Vertex Buffer
                        mVBO_Tri = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0,   3.0, -1.0,    -1.0,  3.0] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePosNor = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0, -1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                               1.0,  1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                               1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                               1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                               1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0,  1.0, -1.0,   0.0,  0.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePos = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0,  1.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        //-------------------------------------------------------------------

                        mShaderHeader[0] = "";
                        mShaderHeaderLines[0] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[0] += "#version 300 es\n" +
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[0] += 6;
                        }
                        else
                        {
                            mShaderHeader[0] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "#endif\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+                                                
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[0] += 26;
                        }

                        //-------------------------------------------------------

                        mShaderHeader[1] = "";
                        mShaderHeaderLines[1] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[1] += "#version 300 es\n"+
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[1] += 6;
                        }
                        else
                        {
                            if( mDerivatives ) { mShaderHeader[1] += "#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n"; mShaderHeaderLines[1]+=3; }
                            if( mShaderTextureLOD  ) { mShaderHeader[1] += "#extension GL_EXT_shader_texture_lod : enable\n"; mShaderHeaderLines[1]++; }
                            mShaderHeader[1] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "#endif\n"+ 
                                                "vec4 texture(     sampler2D   s, vec2 c)                   { return texture2D(s,c); }\n"+
                                                "vec4 texture(     sampler2D   s, vec2 c, float b)          { return texture2D(s,c,b); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c )                  { return textureCube(s,c); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c, float b)          { return textureCube(s,c,b); }\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[1] += 30;
                            if( mShaderTextureLOD )
                            {
                            mShaderHeader[1] += "vec4 textureLod(  sampler2D   s, vec2 c, float b)          { return texture2DLodEXT(s,c,b); }\n";
                            mShaderHeader[1] += "vec4 textureGrad( sampler2D   s, vec2 c, vec2 dx, vec2 dy) { return texture2DGradEXT(s,c,dx,dy); }\n";
                            mShaderHeaderLines[1] += 2;

                            //mShaderHeader[1] += "vec4 texelFetch( sampler2D s, ivec2 c, int l) { return texture2DLodEXT(s,(vec2(c)+0.5)/vec2(800,450),float(l)); }\n";
                            //mShaderHeaderLines[1] += 1;
                            }
                        }

                        return true;
                    };

        me.GetCaps =    function ()
                        {   
                            return { mIsGL20 : mIs20,
                                     mFloat32Textures: mFloat32Textures != null,
                                     mFloat16Textures: mFloat16Textures != null,
                                     mDrawBuffers: mDrawBuffers != null,
                                     mDepthTextures: mDepthTextures != null,
                                     mDerivatives: mDerivatives != null,
                                     mShaderTextureLOD: mShaderTextureLOD != null };
                        };

        me.GetShaderHeaderLines = function (shaderType)
                        {   
                            return mShaderHeaderLines[shaderType];
                        };

        me.CheckErrors = function()
                         {
                                var error = mGL.getError();
                                if( error != mGL.NO_ERROR ) 
                                { 
                                    for( var prop in mGL ) 
                                    {
                                        if( typeof mGL[prop] == 'number' ) 
                                        {
                                            if( mGL[prop] == error )
                                            {
                                                console.log( "GL Error " + error + ": " + prop );
                                                break;
                                            }
                                        }
                                    }
                                }
                         };

        me.Clear =  function( flags, ccolor, cdepth, cstencil )
                    {
                        var mode = 0;
                        if( flags & 1 ) { mode |= mGL.COLOR_BUFFER_BIT;   mGL.clearColor( ccolor[0], ccolor[1], ccolor[2], ccolor[3] ); }
                        if( flags & 2 ) { mode |= mGL.DEPTH_BUFFER_BIT;   mGL.clearDepth( cdepth ); }
                        if( flags & 4 ) { mode |= mGL.STENCIL_BUFFER_BIT; mGL.clearStencil( cstencil ); }
                        mGL.clear( mode );
                    };


        me.CreateTexture = function ( type, xres, yres, format, filter, wrap, buffer)
                           {
                                if( mGL===null ) return null;

                                var id = mGL.createTexture();

                                var glFoTy = iFormatPI2GL( format );
                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                if( type===me.TEXTYPE.T2D )
                                {
                                    mGL.bindTexture( mGL.TEXTURE_2D, id );
//if( buffer==null )
    //mGL.texStorage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres);
//else
                                    mGL.texImage2D( mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap );

                                    if (filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                }
                                else if( type===me.TEXTYPE.T3D )
                                {
                                    if( mIs20 )
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_3D, id );
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_BASE_LEVEL, 0);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAX_LEVEL, Math.log2(xres));
                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_3D);
                                        }
                                        mGL.texImage3D( mGL.TEXTURE_3D, 0, glFoTy.mGLFormat, xres, yres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap );

                                        if (filter === me.FILTER.MIPMAP)
                                            mGL.generateMipmap( mGL.TEXTURE_3D );
                                        mGL.bindTexture( mGL.TEXTURE_3D, null );
                                    }
                                    else 
                                    {
                                        return null;
                                    }
                                }
                                else 
                                {
                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );

                                    // this works great if we know the number of required mipmaps in advance (1, or other)
                                   //mGL.texStorage2D( mGL.TEXTURE_CUBE_MAP, 1, glFoTy.mGLFormat, xres, yres );

                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                    if( filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                    }

                                    if (filter === me.FILTER.MIPMAP)
                                        mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );

                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                }
                        return { mObjectID: id, mXres: xres, mYres: yres, mFormat: format, mType: type, mFilter: filter, mWrap: wrap, mVFlip:false };
                        };

        me.CreateTextureFromImage = function ( type, image, format, filter, wrap, flipY) 
                                {
                                    if( mGL===null ) return null;

                                    var id = mGL.createTexture();

                                    var glFoTy = iFormatPI2GL( format );

                                    var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                    if( type===me.TEXTYPE.T2D )
                                    {
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);

                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.pixelStorei(mGL.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                                        if( mIs20 ) mGL.pixelStorei(mGL.UNPACK_COLORSPACE_CONVERSION_WEBGL, mGL.NONE );

                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);

                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);

                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if( filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                    }
                                    else if( type===me.TEXTYPE.T3D )
                                    {
                                        return null;
                                    }
                                    else 
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );

                                        if( filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                    }
                                    return { mObjectID: id, mXres: image.width, mYres: image.height, mFormat: format, mType: type, mFilter: filter, mWrap:wrap, mVFlip:flipY };
                                };

        me.SetSamplerFilter = function (te, filter, doGenerateMipsIfNeeded) 
                            {
                                if (te.mFilter === filter) return;

                                if (te.mType === me.TEXTYPE.T2D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_3D, null);

                                }
                                else
                                {
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }


                                te.mFilter = filter;
                            };

        me.SetSamplerWrap = function (te, wrap)
                            {
                                if (te.mWrap === wrap) return;

                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, id);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, id);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_3D, null);
                                }

                                te.mWrap = wrap;
                            };

        me.SetSamplerVFlip = function (te, vflip, image)
                            {
                                if (te.mVFlip === vflip) return;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    if( image != null)
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                }
                                else if (te.mType === me.TEXTYPE.CUBEMAP)
                                {
                                    if( image != null)
                                    {
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei( mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
        
                                }

                                te.mVFlip = vflip;
                            };

        me.CreateMipmaps =  function (te)
                            {
                                if( te.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);
                                    mGL.generateMipmap(mGL.TEXTURE_2D);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);
                                }
                                else if( te.mType===me.TEXTYPE.CUBEMAP )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);
                                    mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }
                            };

        me.UpdateTexture =  function( tex, x0, y0, xres, yres, buffer )
                            {
                                var glFoTy = iFormatPI2GL( tex.mFormat );
                                if( tex.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture( mGL.TEXTURE0);
                                    mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                    mGL.texSubImage2D( mGL.TEXTURE_2D, 0, x0, y0, xres, yres, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                }
                            };

        me.UpdateTextureFromImage = function( tex, image )
                                {
                                    var glFoTy = iFormatPI2GL( tex.mFormat );
                                    if( tex.mType===me.TEXTYPE.T2D )
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                        mGL.texImage2D(  mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image );
                                        mGL.bindTexture( mGL.TEXTURE_2D, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                };

        me.DestroyTexture = function( te )
                            {
                                 mGL.deleteTexture( te.mObjectID );
                            };

        me.AttachTextures = function (num, t0, t1, t2, t3) 
                            {
                                if (num > 0 && t0 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                         if (t0.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t0.mObjectID);
                                }

                                if (num > 1 && t1 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE1);
                                         if (t1.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t1.mObjectID);
                                }

                                if (num > 2 && t2 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE2);
                                         if (t2.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t2.mObjectID);
                                }

                                if (num > 3 && t3 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE3);
                                         if (t3.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t3.mObjectID);
                                }
                            };

        me.DettachTextures = function()
                             {
                                mGL.activeTexture(mGL.TEXTURE0);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE1);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE2);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE3);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                             };

        me.CreateRenderTarget = function ( color0, color1, color2, color3, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);

                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_2D, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.DestroyRenderTarget = function ( tex )
                                 {
                                     mGL.deleteFramebuffer(tex.mObjectID);
                                 };

        me.SetRenderTarget = function (tex)
                             {
                                if( tex===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, tex.mObjectID);

                                //mGL.drawBuffers([mGL.COLOR_ATTACHMENT0, mGL.COLOR_ATTACHMENT1]);
                             };

        me.CreateRenderTargetNew = function ( wantColor0, wantZbuffer, xres, yres, samples )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if( wantZbuffer===true )
                                    {
                                        var zb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);

                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.DEPTH_COMPONENT16, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                    }

                                    if( wantColor0 )
                                    {
                                        var cb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, cb);
                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.RGBA8, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.RGBA8, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.RENDERBUFFER, cb);
                                    }

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                    {
                                        return null;
                                    }
                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mXres: xres, mYres:yres, mTex0: color0 };
                                };

        me.CreateRenderTargetCubeMap = function ( color0, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);
                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.SetRenderTargetCubeMap = function (fbo, face)
                             {
                                if( fbo===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                {
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, fbo.mObjectID);
                                    mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X+face, fbo.mTex0.mObjectID, 0);
                                }
                             };


        me.BlitRenderTarget = function( dst, src )
                                {
                                    mGL.bindFramebuffer(mGL.READ_FRAMEBUFFER, src.mObjectID);
                                    mGL.bindFramebuffer(mGL.DRAW_FRAMEBUFFER, dst.mObjectID);
                                    mGL.clearBufferfv(mGL.COLOR, 0, [0.0, 0.0, 0.0, 1.0]);
                                    mGL.blitFramebuffer( 0, 0, src.mXres, src.mYres,
                                                         0, 0, src.mXres, src.mYres,
                                                         mGL.COLOR_BUFFER_BIT, mGL.LINEAR
                                    );
                                };

        me.SetViewport = function( vp )
                         {
                              mGL.viewport( vp[0], vp[1], vp[2], vp[3] );
                         };

        me.SetWriteMask = function( c0, c1, c2, c3, z )
                          {
                              mGL.depthMask(z);
                              mGL.colorMask(c0,c0,c0,c0);
                          };

        me.SetState = function( stateName, stateValue )
                      {
                            if (stateName === me.RENDSTGATE.WIREFRAME)
                            {
                                if( stateValue ) mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.LINE );
                                else             mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.FILL );
                            }
                            else if (stateName === me.RENDSTGATE.FRONT_FACE)
                            {
                                if( stateValue ) mGL.cullFace( mGL.BACK );
                                else             mGL.cullFace( mGL.FRONT );
                            }
                            else if (stateName === me.RENDSTGATE.CULL_FACE)
                            {
                                if( stateValue ) mGL.enable( mGL.CULL_FACE );
                                else             mGL.disable( mGL.CULL_FACE );
                            }
                            else if (stateName === me.RENDSTGATE.DEPTH_TEST)
                            {
                                if( stateValue ) mGL.enable( mGL.DEPTH_TEST );
                                else             mGL.disable( mGL.DEPTH_TEST );
                            }
                            else if (stateName === me.RENDSTGATE.ALPHA_TO_COVERAGE)
                            {
                                if( stateValue ) { mGL.enable(  mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                                else             { mGL.disable( mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                            }
                      };

        me.SetMultisample = function( v)
                    {
                        if( v===true )
                        {
                            mGL.enable(mGL.SAMPLE_COVERAGE);
                            mGL.sampleCoverage(1.0, false);
                        }
                        else
                        {
                            mGL.disable(mGL.SAMPLE_COVERAGE);
                        }
                    };

        me.GetTranslatedShaderSource = function (shader) 
                          {
                            if( mGL===null ) return null;
                            if( mDebugShader===null ) return null;
                            let vfs = mGL.getAttachedShaders(shader.mProgram);
                            let str = mDebugShader.getTranslatedShaderSource(vfs[1]);
                            let parts = str.split("GLSL END"); str = (parts.length<2) ? str : parts[1];
                            return str;
                          };

        me.CreateShader = function (vsSource, fsSource, preventCache, forceSynch, onResolve) 
                          {
                            if( mGL===null ) return;

                            var vs = mGL.createShader( mGL.VERTEX_SHADER   );
                            var fs = mGL.createShader( mGL.FRAGMENT_SHADER );

                            vsSource = mShaderHeader[0] + vsSource;
                            fsSource = mShaderHeader[1] + fsSource;

                            if( preventCache )
                            {
                                let vran = Math.random().toString(36).substring(7);
                                let fran = Math.random().toString(36).substring(7);
                                vsSource += "\n#define K" + vran + "\n";
                                fsSource += "\n#define K" + fran + "\n";
                            }

                            var timeStart = getRealTime();

                            mGL.shaderSource(vs, vsSource);
                            mGL.shaderSource(fs, fsSource);
                            mGL.compileShader(vs);
                            mGL.compileShader(fs);

                            var pr = mGL.createProgram();
                            mGL.attachShader(pr, vs);
                            mGL.attachShader(pr, fs);
                            mGL.linkProgram(pr);

                            //-------------
                            let checkErrors = function()
                            {
                                if (!mGL.getProgramParameter(pr, mGL.LINK_STATUS))
                                {
                                    // vs error
                                    if (!mGL.getShaderParameter(vs, mGL.COMPILE_STATUS))
                                    {
                                        let vsLog = mGL.getShaderInfoLog(vs);
                                        onResolve(false, { mErrorType: 0, mErrorStr: vsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // fs error
                                    else if (!mGL.getShaderParameter(fs, mGL.COMPILE_STATUS))
                                    {
                                        let fsLog = mGL.getShaderInfoLog(fs);
                                        onResolve(false, { mErrorType: 1, mErrorStr: fsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // link error
                                    else
                                    {
                                        let infoLog = mGL.getProgramInfoLog(pr);
                                        onResolve(false, { mErrorType: 2, mErrorStr: infoLog });
                                        mGL.deleteProgram(pr);
                                    }
                                }
                                // no errors
                                else
                                {
                                    let compilationTime = getRealTime() - timeStart;
                                    onResolve(true, { mProgram: pr, mTime: compilationTime });
                                }
                            };

                            // check compilation
                            if (mAsynchCompile === null || forceSynch===true )
                            {
                                checkErrors();
                            }
                            else
                            {
                                let loopCheckCompletion = function ()
                                {
                                    if( mGL.getProgramParameter(pr, mAsynchCompile.COMPLETION_STATUS_KHR) === true )
                                        checkErrors();
                                    else
                                        setTimeout(loopCheckCompletion, 10);
                                };
                                setTimeout(loopCheckCompletion, 10);
                            }
                        };

        me.AttachShader = function( shader )
                          {
                                if( shader===null )
                                {
                                    mBindedShader = null;
                                    mGL.useProgram( null );
                                }
                                else
                                {
                                    mBindedShader = shader;
                                    mGL.useProgram(shader.mProgram);
                                }
                          };

        me.DetachShader = function ()
                        {
                            mGL.useProgram(null);
                        };

        me.DestroyShader = function( tex )
                        {
                            mGL.deleteProgram(tex.mProgram);
                        };

        me.GetAttribLocation = function (shader, name)
                        {
                            return mGL.getAttribLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantLocation = function (shader, name)
                        {
                            return mGL.getUniformLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantMat4F = function( uname, params, istranspose )
                        {
                            var program = mBindedShader;

                            let pos = mGL.getUniformLocation( program.mProgram, uname );
                            if( pos===null )
                                return false;

                            if( istranspose===false )
                            {
                                var tmp = new Float32Array( [ params[0], params[4], params[ 8], params[12],
                                                              params[1], params[5], params[ 9], params[13],
                                                              params[2], params[6], params[10], params[14],
                                                              params[3], params[7], params[11], params[15] ] );
	                            mGL.uniformMatrix4fv(pos,false,tmp);
                            }
                            else
                                mGL.uniformMatrix4fv(pos,false,new Float32Array(params) );
                            return true;
                        };

        me.SetShaderConstant1F_Pos = function(pos, x)
                        {
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1FV_Pos = function(pos, x)
                        {
                            mGL.uniform1fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant1F = function( uname, x )
                        {
                            var pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1I = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1i(pos, x);
                            return true;
                        };
        me.SetShaderConstant1I_Pos = function(pos, x)
                        {
                            mGL.uniform1i(pos, x);
                            return true;
                        };


        me.SetShaderConstant2F = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform2fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant3F = function(uname, x, y, z)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform3f(pos, x, y, z);
                            return true;
                        };

        me.SetShaderConstant1FV = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1fv(pos, new Float32Array(x));
                            return true;
                        };

        me.SetShaderConstant3FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform3fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderConstant4FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform4fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderTextureUnit = function( uname, unit )
                        {
                            var program = mBindedShader;
                            let pos = mGL.getUniformLocation(program.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform1i(pos, unit);
                            return true;
                        };

        me.CreateVertexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, id);
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.CreateIndexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, id );
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.DestroyArray = function( tex )
                        {
                            mGL.destroyBuffer(tex.mObject);
                        };

        me.AttachVertexArray = function( tex, attribs, pos )
                        {
                            let shader = mBindedShader;

                            mGL.bindBuffer( mGL.ARRAY_BUFFER, tex.mObject);

                            var num = attribs.mChannels.length;
                            var stride = attribs.mStride;

                            var offset = 0;
                            for (var i = 0; i < num; i++)
                            {
                                var id = pos[i];
                                mGL.enableVertexAttribArray(id);
                                var dtype = mGL.FLOAT;
                                var dsize = 4;
                                     if( attribs.mChannels[i].mType === me.TYPE.UINT8   ) { dtype = mGL.UNSIGNED_BYTE;  dsize = 1; }
                                else if( attribs.mChannels[i].mType === me.TYPE.UINT16  ) { dtype = mGL.UNSIGNED_SHORT; dsize = 2; }
                                else if( attribs.mChannels[i].mType === me.TYPE.FLOAT32 ) { dtype = mGL.FLOAT;          dsize = 4; }
                                mGL.vertexAttribPointer(id, attribs.mChannels[i].mNumComponents, dtype, attribs.mChannels[i].mNormalize, stride, offset);
                                offset += attribs.mChannels[i].mNumComponents * dsize;
                            }
                        };

        me.AttachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, tex.mObject);
                        };

        me.DetachVertexArray = function (tex, attribs)
                        {
                            let num = attribs.mChannels.length;
                            for (let i = 0; i < num; i++)
                                mGL.disableVertexAttribArray(i);
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, null);
                        };

        me.DetachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, null);
                        };

        me.DrawPrimitive = function( typeOfPrimitive, num, useIndexArray, numInstances )
                        {
                            let glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.POINTS ) glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.LINES ) glType = mGL.LINES;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_LOOP ) glType = mGL.LINE_LOOP;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_STRIP ) glType = mGL.LINE_STRIP;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLES ) glType = mGL.TRIANGLES;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLE_STRIP ) glType = mGL.TRIANGLE_STRIP;

                            if( numInstances<=1 )
                            {
  	                            if( useIndexArray ) mGL.drawElements( glType, num, mGL.UNSIGNED_SHORT, 0 );
	                            else                mGL.drawArrays( glType, 0, num );
                            }
                            else
                            {
                                mGL.drawArraysInstanced(glType, 0, num, numInstances);
                                mGL.drawElementsInstanced( glType, num, mGL.UNSIGNED_SHORT, 0, numInstances);
                            }
                        };


        me.DrawFullScreenTriangle_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 3 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };


        me.DrawUnitQuad_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 6 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };

        me.DrawUnitCube_XYZ_NOR = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                            mGL.vertexAttribPointer( vpos[0], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.vertexAttribPointer( vpos[1], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos[0] );
                            mGL.enableVertexAttribArray( vpos[1] );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos[0] );
                            mGL.disableVertexAttribArray( vpos[1] );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.DrawUnitCube_XYZ = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                            mGL.vertexAttribPointer( vpos, 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.SetBlend = function( enabled )
                    {
                        if( enabled )
                        {
                            mGL.enable( mGL.BLEND );
                            mGL.blendEquationSeparate( mGL.FUNC_ADD, mGL.FUNC_ADD );
                            mGL.blendFuncSeparate( mGL.SRC_ALPHA, mGL.ONE_MINUS_SRC_ALPHA, mGL.ONE, mGL.ONE_MINUS_SRC_ALPHA );
                        }
                        else
                        {
                            mGL.disable( mGL.BLEND );
                        }
                    };

        me.GetPixelData = function( data, offset, xres, yres )
                        {
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.UNSIGNED_BYTE, data, offset);
                        };

        me.GetPixelDataRenderTarget = function( obj, data, xres, yres )
                        {
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, obj.mObjectID);
                            mGL.readBuffer(mGL.COLOR_ATTACHMENT0);
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.FLOAT, data, 0);
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                        };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piShading
//
//==============================================================================

function smoothstep(a, b, x)
{
    x = (x - a) / (b - a);
    if (x < 0) x = 0; else if (x > 1) x = 1;
    return x * x * (3.0 - 2.0 * x);
}

function clamp01(x)
{
    if( x < 0.0 ) x = 0.0;
    if( x > 1.0 ) x = 1.0;
    return x;
}

function clamp(x, a, b)
{
    if( x < a ) x = a;
    if( x > b ) x = b;
    return x;
}

function screen(a, b)
{
    return 1.0 - (1.0 - a) * (1.0 - b);
}

function parabola(x)
{
    return 4.0 * x * (1.0 - x);
}

function min(a, b)
{
    return (a < b) ? a : b;
}

function max(a, b)
{
    return (a > b) ? a : b;
}

function noise( x )
{
    function grad(i, j, x, y)
    {
        var h = 7 * i + 131 * j;
        h = (h << 13) ^ h;
        h = (h * (h * h * 15731 + 789221) + 1376312589);

        var rx = (h & 0x20000000) ? x : -x;
        var ry = (h & 0x10000000) ? y : -y;

        return rx + ry;
    }

    var i = [ Math.floor(x[0]), Math.floor(x[1]) ];
    var f = [ x[0] - i[0], x[1] - i[1] ];
    var w = [ f[0]*f[0]*(3.0-2.0*f[0]), f[1]*f[1]*(3.0-2.0*f[1]) ];

    var a = grad( i[0]+0, i[1]+0, f[0]+0.0, f[1]+0.0 );
    var b = grad( i[0]+1, i[1]+0, f[0]-1.0, f[1]+0.0 );
    var c = grad( i[0]+0, i[1]+1, f[0]+0.0, f[1]-1.0 );
    var d = grad( i[0]+1, i[1]+1, f[0]-1.0, f[1]-1.0 );

    return a + (b-a)*w[0] + (c-a)*w[1] + (a-b-c+d)*w[0]*w[1];
}//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piVecTypes
//
//==============================================================================


function vec3( a, b, c )
{
    return [ a, b, c ];
}

function add( a, b )
{
    return [ a[0]+b[0], a[1]+b[1], a[2]+b[2] ];
}

function sub( a, b )
{
    return [ a[0]-b[0], a[1]-b[1], a[2]-b[2] ];
}

function mul( a, s ) 
{
    return [ a[0]*s, a[1]*s, a[2]*s ];
}

function cross( a, b )
{
    return [ a[1]*b[2] - a[2]*b[1],
             a[2]*b[0] - a[0]*b[2],
             a[0]*b[1] - a[1]*b[0] ];
}

function dot( a, b ) 
{
    return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
}

function normalize( v ) 
{
    var is = 1.0 / Math.sqrt( v[0]*v[0] + v[1]*v[1] + v[2]*v[2] );
    return [ v[0]*is, v[1]*is, v[2]*is ];
}

function createCirclePoint( cen, uuu, vvv, rad, s, t )
{
    return [ cen[0] + rad*(uuu[0]*s + vvv[0]*t),
             cen[1] + rad*(uuu[1]*s + vvv[1]*t),
             cen[2] + rad*(uuu[2]*s + vvv[2]*t) ];
}

function createTangent( a, b, c )
{
    var cb = normalize( [ c[0]-b[0], c[1]-b[1], c[2]-b[2] ] );
    var ba = normalize( [ b[0]-a[0], b[1]-a[1], b[2]-a[2] ] );
    return normalize( [ ba[0]+cb[0], ba[1]+cb[1], ba[2]+cb[2] ] );

}

//===================================

function vec4( a, b, c, d )
{
    return [ a, b, c, d ];
}

function getXYZ( v )
{
    return [ v[0], v[1], v[2] ];
}

//===================================

function setIdentity()
{
    return [ 1.0, 0.0, 0.0, 0.0,
             0.0, 1.0, 0.0, 0.0,
             0.0, 0.0, 1.0, 0.0,
             0.0, 0.0, 0.0, 1.0 ];
}

function setRotationX( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ 1.0,   0.0,   0.0, 0.0,
             0.0,  cost, -sint, 0.0, 
             0.0,  sint,  cost, 0.0,
             0.0,   0.0,   0.0, 1.0 ];
}

function setRotationY( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ cost, 0.0, -sint, 0.0,
              0.0, 1.0,   0.0, 0.0, 
             sint, 0.0,  cost, 0.0,
              0.0, 0.0,   0.0, 1.0 ];
}

function extractRotationEuler( m)
{
    var res = [];
    if (m[0] == 1.0)
    {
        res[0] = Math.atan2(m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;

    }
    else if (m[0] == -1.0)
    {
        res[0] = Math.atan2( m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;
    }
    else
    {
        res[0] = Math.atan2( -m[9], m[10]);
        res[1] = Math.atan2( m[8], Math.sqrt(m[9]*m[9] + m[10]*m[10]));
        res[2] = Math.atan2( m[4], m[0]);
    }
    return res;
}

function setFromQuaternion( q )
{
    var ww = q[3]*q[3];
    var xx = q[0]*q[0];
    var yy = q[1]*q[1];
    var zz = q[2]*q[2];

    return [ ww+xx-yy-zz,                   2.0*(q[0]*q[1] - q[3]*q[2]), 2.0*(q[0]*q[2] + q[3]*q[1]), 0.0,
               2.0*(q[0]*q[1] + q[3]*q[2]),   ww-xx+yy-zz,                 2.0*(q[1]*q[2] - q[3]*q[0]), 0.0,
               2.0*(q[0]*q[2] - q[3]*q[1]),   2.0*(q[1]*q[2] + q[3]*q[0]), ww-xx-yy+zz,                 0.0,
               0.0,                           0.0,                         0.0,                         1.0 ];
}

function setPerspective( fovy, aspect, znear, zfar )
{
    var tan = Math.tan(fovy * Math.PI/180.0);
    var x = 1.0 / (tan*aspect);
    var y = 1.0 / (tan);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0 * zfar * znear) / (zfar - znear);

    return [ x,    0.0,  0.0,  0.0,
             0.0,  y,    0.0,  0.0,
             0.0,  0.0,  c,     d,
             0.0,  0.0, -1.0,  0.0 ];
}

function setLookAt( eye, tar, up )
{
    var dir = [ -tar[0]+eye[0], -tar[1]+eye[1], -tar[2]+eye[2] ];

	var m00 = dir[2]*up[1] - dir[1]*up[2]; 
    var m01 = dir[0]*up[2] - dir[2]*up[0];
    var m02 = dir[1]*up[0] - dir[0]*up[1];
    var im = 1.0/Math.sqrt( m00*m00 + m01*m01 + m02*m02 );
    m00 *= im;
    m01 *= im;
    m02 *= im;

	var m04 = m02*dir[1] - m01*dir[2]; 
    var m05 = m00*dir[2] - m02*dir[0];
    var m06 = m01*dir[0] - m00*dir[1];
    im = 1.0/Math.sqrt( m04*m04 + m05*m05 + m06*m06 );
    m04 *= im;
    m05 *= im;
    m06 *= im;

	var m08 = dir[0];
	var m09 = dir[1];
	var m10 = dir[2];
    im = 1.0/Math.sqrt( m08*m08 + m09*m09 + m10*m10 );
    m08 *= im;
    m09 *= im;
    m10 *= im;

	var m03 = -(m00*eye[0] + m01*eye[1] + m02*eye[2] );
	var m07 = -(m04*eye[0] + m05*eye[1] + m06*eye[2] );
	var m11 = -(m08*eye[0] + m09*eye[1] + m10*eye[2] );

    return [ m00, m01, m02, m03,
             m04, m05, m06, m07,
             m08, m09, m10, m11,
             0.0, 0.0, 0.0, 1.0 ];
}


function setOrtho( left, right, bottom, top, znear, zfar )
{
   var x = 2.0 / (right - left);
   var y = 2.0 / (top - bottom);
   var a = (right + left) / (right - left);
   var b = (top + bottom) / (top - bottom);
   var c = -2.0 / (zfar - znear);
   var d = -(zfar + znear) / ( zfar - znear);

   return [  x, 0.0, 0.0,   a,
           0.0,   y, 0.0,   b,
           0.0, 0.0,   c,   d,
           0.0, 0.0, 0.0, 1.0 ];
}

function setTranslation( p )
{
    return [ 1.0, 0.0, 0.0, p[0],
             0.0, 1.0, 0.0, p[1],
             0.0, 0.0, 1.0, p[2],
             0.0, 0.0, 0.0, 1.0 ];
}

function setScale( s )
{
    return [ s[0], 0.0,  0.0,  0.0,
             0.0,  s[1], 0.0,  0.0,
             0.0,  0.0,  s[2], 0.0,
             0.0,  0.0,  0.0,  1.0];
}

function setProjection( fov, znear, zfar )
{
    var x = 2.0 / (fov[3]+fov[2]);
    var y = 2.0 / (fov[0]+fov[1]);
    var a = (fov[3]-fov[2]) / (fov[3]+fov[2]);
    var b = (fov[0]-fov[1]) / (fov[0]+fov[1]);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0*zfar*znear) / (zfar - znear);
    return [   x, 0.0,    a, 0.0,
             0.0,   y,    b, 0.0,
             0.0, 0.0,    c,   d,
             0.0, 0.0, -1.0, 0.0 ];
   // inverse is:
   //return mat4x4( 1.0/x, 0.0f,  0.0f,   a/x,
   //               0.0f,  1.0/y, 0.0f,   b/x,
   //               0.0f,  0.0f,  0.0f,   -1.0,
   //               0.0f,  0.0f,  1.0f/d, c/d );
}


function invertFast( m )
{
    var inv = [
   
             m[5]  * m[10] * m[15] - 
             m[5]  * m[11] * m[14] - 
             m[9]  * m[6]  * m[15] + 
             m[9]  * m[7]  * m[14] +
             m[13] * m[6]  * m[11] - 
             m[13] * m[7]  * m[10],

             -m[1]  * m[10] * m[15] + 
              m[1]  * m[11] * m[14] + 
              m[9]  * m[2] * m[15] - 
              m[9]  * m[3] * m[14] - 
              m[13] * m[2] * m[11] + 
              m[13] * m[3] * m[10],

             m[1]  * m[6] * m[15] - 
             m[1]  * m[7] * m[14] - 
             m[5]  * m[2] * m[15] + 
             m[5]  * m[3] * m[14] + 
             m[13] * m[2] * m[7] - 
             m[13] * m[3] * m[6],

             -m[1] * m[6] * m[11] + 
              m[1] * m[7] * m[10] + 
              m[5] * m[2] * m[11] - 
              m[5] * m[3] * m[10] - 
              m[9] * m[2] * m[7] + 
              m[9] * m[3] * m[6],

             -m[4]  * m[10] * m[15] + 
              m[4]  * m[11] * m[14] + 
              m[8]  * m[6]  * m[15] - 
              m[8]  * m[7]  * m[14] - 
              m[12] * m[6]  * m[11] + 
              m[12] * m[7]  * m[10],

             m[0]  * m[10] * m[15] - 
             m[0]  * m[11] * m[14] - 
             m[8]  * m[2] * m[15] + 
             m[8]  * m[3] * m[14] + 
             m[12] * m[2] * m[11] - 
             m[12] * m[3] * m[10],

             -m[0]  * m[6] * m[15] + 
              m[0]  * m[7] * m[14] + 
              m[4]  * m[2] * m[15] - 
              m[4]  * m[3] * m[14] - 
              m[12] * m[2] * m[7] + 
              m[12] * m[3] * m[6],


             m[0] * m[6] * m[11] - 
             m[0] * m[7] * m[10] - 
             m[4] * m[2] * m[11] + 
             m[4] * m[3] * m[10] + 
             m[8] * m[2] * m[7] - 
             m[8] * m[3] * m[6],


             m[4]  * m[9] * m[15] - 
             m[4]  * m[11] * m[13] - 
             m[8]  * m[5] * m[15] + 
             m[8]  * m[7] * m[13] + 
             m[12] * m[5] * m[11] - 
             m[12] * m[7] * m[9],



             -m[0]  * m[9] * m[15] + 
              m[0]  * m[11] * m[13] + 
              m[8]  * m[1] * m[15] - 
              m[8]  * m[3] * m[13] - 
              m[12] * m[1] * m[11] + 
              m[12] * m[3] * m[9],

              m[0]  * m[5] * m[15] - 
              m[0]  * m[7] * m[13] - 
              m[4]  * m[1] * m[15] + 
              m[4]  * m[3] * m[13] + 
              m[12] * m[1] * m[7] - 
              m[12] * m[3] * m[5],

              -m[0] * m[5] * m[11] + 
               m[0] * m[7] * m[9] + 
               m[4] * m[1] * m[11] - 
               m[4] * m[3] * m[9] - 
               m[8] * m[1] * m[7] + 
               m[8] * m[3] * m[5],

              -m[4]  * m[9] * m[14] + 
               m[4]  * m[10] * m[13] +
               m[8]  * m[5] * m[14] - 
               m[8]  * m[6] * m[13] - 
               m[12] * m[5] * m[10] + 
               m[12] * m[6] * m[9],

              m[0]  * m[9] * m[14] - 
              m[0]  * m[10] * m[13] - 
              m[8]  * m[1] * m[14] + 
              m[8]  * m[2] * m[13] + 
              m[12] * m[1] * m[10] - 
              m[12] * m[2] * m[9],

              -m[0]  * m[5] * m[14] + 
               m[0]  * m[6] * m[13] + 
               m[4]  * m[1] * m[14] - 
               m[4]  * m[2] * m[13] - 
               m[12] * m[1] * m[6] + 
               m[12] * m[2] * m[5],

              m[0] * m[5] * m[10] - 
              m[0] * m[6] * m[9] - 
              m[4] * m[1] * m[10] + 
              m[4] * m[2] * m[9] + 
              m[8] * m[1] * m[6] - 
              m[8] * m[2] * m[5] ];

    var det = m[0] * inv[0] + m[1] * inv[4] + m[2] * inv[8] + m[3] * inv[12];

    det = 1.0/det;

    for( var i = 0; i<16; i++ ) inv[i] = inv[i] * det;

    return inv;
}

function matMul( a, b )
{
    var res = [];
    for( var i=0; i<4; i++ )
    {
        var x = a[4*i+0];
        var y = a[4*i+1];
        var z = a[4*i+2];
        var w = a[4*i+3];

        res[4*i+0] = x * b[ 0] + y * b[ 4] + z * b[ 8] + w * b[12];
        res[4*i+1] = x * b[ 1] + y * b[ 5] + z * b[ 9] + w * b[13];
        res[4*i+2] = x * b[ 2] + y * b[ 6] + z * b[10] + w * b[14];
        res[4*i+3] = x * b[ 3] + y * b[ 7] + z * b[11] + w * b[15];
    }

    return res;
}

function matMulpoint( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2] + m[ 3],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2] + m[ 7],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] + m[11] ];
}

function matMulvec( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] ];
}


function bound3( infi )
{
    return [ infi, -infi, infi, -infi, infi, -infi ];
}

function bound3_include( a, p )
{
    return [
        (p[0]<a[0]) ? p[0] : a[0],
        (p[0]>a[1]) ? p[0] : a[1],
        (p[1]<a[2]) ? p[1] : a[2],
        (p[1]>a[3]) ? p[1] : a[3],
        (p[2]<a[4]) ? p[2] : a[4],
        (p[2]>a[5]) ? p[2] : a[5] ];
}

function bound3_center( b )
{
    return [ 0.5*(b[0]+b[1]),
             0.5*(b[2]+b[3]),
             0.5*(b[4]+b[5]) ];
}

function bound3_radius( b )
{
    return [ 0.5*(b[1]-b[0]),
             0.5*(b[3]-b[2]),
             0.5*(b[5]-b[4]) ];
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebVR
//
//==============================================================================

function WebVR( isVREnabledCallback, canvasElement )
{
    isVREnabledCallback(false);
    /*


    this.mSupportVR = false;
    this.mHMD = null;

    var me = this;
    var listVRDisplays = function (vrdevs) {
        for (var i = 0; i < vrdevs.length; i++)
        {
            if (vrdevs[i] instanceof VRDisplay)
            {
                me.mHMD = vrdevs[i];
                console.log("WebVR is available.");
                console.log(me.mHMD);
                break;
            }
        }

        isVREnabledCallback(true);
        me.mSupportVR = true;
    }

    if (navigator.getVRDisplays)
    {
        navigator.getVRDisplays().then(listVRDisplays);
    }

    isVREnabledCallback(false);
    this.mCanvas = canvasElement;
    */
}

WebVR.prototype.IsSupported = function()
{
    return false;
    //return this.mSupportVR;
}

WebVR.prototype.GetData = function( id )
{
    return {};
    /*
    var frameData = new VRFrameData();
    var s = this.mHMD.getFrameData(frameData);
    var ss = frameData.pose;
    
    var fovL = this.mHMD.getEyeParameters("left");
    var fovR = this.mHMD.getEyeParameters( "right" );

    // camera info
    var cPos = vec3(0.0, 0.0, 0.0);
    if (ss.position)
        cPos = vec3(-ss.position[0], -ss.position[1], -ss.position[2]);
    var rot = vec4(0.0, 0.0, 0.0, 0.0);
    if (ss.orientation)
        rot = vec4(ss.orientation[0], ss.orientation[1], ss.orientation[2], ss.orientation[3]);
    var cRot = setFromQuaternion(rot);
    var cTra = setTranslation(cPos);
    var cMat = matMul(invertFast(cRot), cTra);
    
    // per eye info
    var lTra = setTranslation( vec3(-fovL.offset[0], -fovL.offset[1], -fovL.offset[2]) );
    var lMat = matMul(lTra, cMat);
    var lPrj = [ Math.tan( fovL.fieldOfView.upDegrees * Math.PI/180.0),
                 Math.tan(fovL.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.rightDegrees * Math.PI / 180.0)];

    var rTra = setTranslation(vec3(-fovR.offset[0], -fovR.offset[1], -fovR.offset[2]));
    var rMat = matMul(rTra, cMat);
    var rPrj = [Math.tan(fovR.fieldOfView.upDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.rightDegrees * Math.PI / 180.0)];

    return {
        mCamera   : { mCamera: cMat },
        mLeftEye  : { mVP:[0,0,fovL.renderWidth,fovL.renderHeight], mProjection:lPrj, mCamera:lMat },
        mRightEye : { mVP:[fovR.renderWidth/2,0,fovR.renderWidth,fovR.renderHeight], mProjection:rPrj, mCamera:rMat }
           };
    */
}

WebVR.prototype.Enable = function( id )
{
    /*
    this.mHMD.requestPresent([{ source: this.mCanvas }]).then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : requestPresent failed.");
        }
    );
    */
}

WebVR.prototype.Disable = function( id )
{
    /*
    if (!this.mHMD.isPresenting)
    {
        return;
    }

    this.mHMD.exitPresent().then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : exitPresent failed.");
        }
    );
    */
}

WebVR.prototype.RequestAnimationFrame = function (id)
{
    //this.mHMD.requestAnimationFrame(id);
}

WebVR.prototype.IsPresenting = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        return true;
    }
    */
    return false;
}

WebVR.prototype.Finish = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        this.mHMD.submitFrame();
    }
    */
}

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebUtils
//
//==============================================================================


// RequestAnimationFrame
window.requestAnimFrame = ( function () { return window.requestAnimationFrame    || window.webkitRequestAnimationFrame ||
                                                 window.mozRequestAnimationFrame || window.oRequestAnimationFrame ||
                                                 window.msRequestAnimationFrame  || function( cb ) { window.setTimeout(cb,1000/60); };
                                        } )();

// performance.now
window.getRealTime = ( function() { if ("performance" in window ) return function() { return window.performance.now(); }
                                                                  return function() { return (new Date()).getTime(); }
                                  } )();

window.URL = window.URL || window.webkitURL;

navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;

function htmlEntities(str) 
{
    return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g,'&apos;');
}

function piDisableTouch()
{
    document.body.addEventListener('touchstart', function(e){ e.preventDefault(); });
}

var piGetTime = function ( timestamp )
{
    if (timestamp == 0)
        return "";
    return new Date(timestamp * 1000).toISOString().substr(0, 10);
}

function piGetCoords( obj )
{
    var x = 0;
    var y = 0; 
    do
    {
         x += obj.offsetLeft;
         y += obj.offsetTop;
    }while( obj = obj.offsetParent );

    return { mX:x, mY:y };
}

function piGetMouseCoords( ev, canvasElement )
{
    var pos = piGetCoords(canvasElement );
    var mcx =                        (ev.pageX - pos.mX) * canvasElement.width / canvasElement.offsetWidth;
    var mcy = canvasElement.height - (ev.pageY - pos.mY) * canvasElement.height / canvasElement.offsetHeight;

    return { mX: mcx, mY: mcy };

}

function piGetSourceElement( e )
{
    var ele = null;
    if( e.target )     ele = e.target;
    if( e.srcElement ) ele = e.srcElement;
    return ele;
}

function piRequestFullScreen( ele )
{
    if( ele==null ) ele =   document.documentElement;
         if( ele.requestFullscreen       ) ele.requestFullscreen();
    else if( ele.msRequestFullscreen     ) ele.msRequestFullscreen();
    else if( ele.mozRequestFullScreen    ) ele.mozRequestFullScreen();
    else if( ele.webkitRequestFullscreen ) ele.webkitRequestFullscreen( Element.ALLOW_KEYBOARD_INPUT );
}

function piIsFullScreen()
{
    return document.fullscreen || document.mozFullScreen || document.webkitIsFullScreen || document.msFullscreenElement || false;
}

function piExitFullScreen()
{
       if( document.exitFullscreen       ) document.exitFullscreen();
  else if( document.msExitFullscreen     ) document.msExitFullscreen();
  else if( document.mozCancelFullScreen  ) document.mozCancelFullScreen();
  else if( document.webkitExitFullscreen ) document.webkitExitFullscreen();
}

function piIsMobile()
{
    return (navigator.userAgent.match(/Android/i) ||
            navigator.userAgent.match(/webOS/i) ||
            navigator.userAgent.match(/iPhone/i) ||
            navigator.userAgent.match(/iPad/i) ||
            navigator.userAgent.match(/iPod/i) ||
            navigator.userAgent.match(/BlackBerry/i) ||
            navigator.userAgent.match(/Windows Phone/i)) ? true : false;
}

function piCreateGlContext( cv, useAlpha, useDepth, usePreserveBuffer, useSupersampling )
{
    var opts = { alpha: useAlpha, 
                 depth: useDepth, 
                 stencil: false, 
                 premultipliedAlpha: false, 
                 antialias: useSupersampling, 
                 preserveDrawingBuffer: usePreserveBuffer, 
                 powerPreference: "high-performance" }; // "low_power", "high_performance", "default"

    var gl = null;
    if( gl === null) gl = cv.getContext( "webgl2", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl2", opts );
    if( gl === null) gl = cv.getContext( "webgl", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl", opts );

    return gl;
}

function piCreateAudioContext()
{
    var res = null;
    try
    {
        if( window.AudioContext ) res = new AudioContext();
        if( res==null && window.webkitAudioContext ) res = new webkitAudioContext();
    }
    catch( e )
    {
        res = null;
    }
    return res;
}

function piHexColorToRGB(str) // "#ff3041"
{
    var rgb = parseInt(str.slice(1), 16);
    var r = (rgb >> 16) & 255;
    var g = (rgb >> 8) & 255;
    var b = (rgb >> 0) & 255;
    return [r, g, b];
}

function piCreateFPSCounter()
{
    var mFrame;
    var mTo;
    var mFPS;

    var iReset = function( time )
    {
        mFrame = 0;
        mTo = time;
        mFPS = 60.0;
    }

    var iCount = function( time )
    {
        mFrame++;

        if( (time-mTo)>500.0 )
        {
            mFPS = 1000.0*mFrame/(time-mTo);
            mFrame = 0;
            mTo = time;
            return true;
        }
        return false;
    }

    var iGetFPS = function()
    {
        return mFPS;
    }
    
    return { Reset : iReset, Count : iCount, GetFPS : iGetFPS };
}

function piCanMediaRecorded(canvas)
{
    if (typeof window.MediaRecorder !== 'function' || typeof canvas.captureStream !== 'function') {
        return false;
    }
    return true;
}

function piCreateMediaRecorder(isRecordingCallback, canvas) 
{
    if (piCanMediaRecorded(canvas) == false)
    {
        return null;
    }
    
    var options = { audioBitsPerSecond : 0, videoBitsPerSecond : 8000000 }; 
	     if (MediaRecorder.isTypeSupported('video/webm;codecs=h264')) options.mimeType = 'video/webm;codecs=h264';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9' )) options.mimeType = 'video/webm;codecs=vp9';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8' )) options.mimeType = 'video/webm;codecs=vp8';
    else                                                              options.mimeType = 'video/webm;';

    var mediaRecorder = new MediaRecorder(canvas.captureStream(), options);
    var chunks = [];
    
    mediaRecorder.ondataavailable = function(e) 
    {
        if (e.data.size > 0) 
        {
            chunks.push(e.data);
        }
    };
 
    mediaRecorder.onstart = function(){ 
        isRecordingCallback( true );
    };
    
    mediaRecorder.onstop = function()
    {
         isRecordingCallback( false );
         let blob     = new Blob(chunks, {type: "video/webm"});
         chunks       = [];
         let videoURL = window.URL.createObjectURL(blob);
         let url      = window.URL.createObjectURL(blob);
         let a        = document.createElement("a");
         document.body.appendChild(a);
         a.style      = "display: none";
         a.href       = url;
         a.download   = "capture.webm";
         a.click();
         window.URL.revokeObjectURL(url);
     };
    
    return mediaRecorder;
}

function piExportToEXR(width, height, numComponents, type, bytes)
{
    var bytesPerComponent = 0;
    if      (type=="Uint")   bytesPerComponent = 4; 
    else if (type=="Half")   bytesPerComponent = 2;
    else if (type=="Float")  bytesPerComponent = 4;

    var tHeader = 258 + (18 * numComponents + 1);
    var tTable = 8 * height;
    var tScanlines = height * (4 + 4 + (numComponents * bytesPerComponent * width));
    var tTotal = tHeader + tTable + tScanlines;

    //console.log("    header size = " + tHeader);
    //console.log("    table size = " + tTable);
    //console.log("    scanlines size = " + tScanlines);
    //console.log("    total = " + tTotal);

    var buffer = new ArrayBuffer(tTotal); 
    var data = new DataView(buffer);

    // Header
    {
        // Header : 4 bytes -> 0x76, 0x2f, 0x31, 0x01
        var c = 0;
        data.setUint8 (c++, 0x76);
        data.setUint8 (c++, 0x2f);
        data.setUint8 (c++, 0x31);
        data.setUint8 (c++, 0x01);

        // Version : 4 bytes -> 2, 0, 0, 0
        data.setUint8 (c++, 0x02);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        
        // Write channel info
        // Write attribute name : "channels"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x73);
            data.setUint8 (c++, 0x0);

            // Write attribute type : "chlist"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : 18 x 3 + 1 = 55
            var attribSize = 18 * numComponents + 1;
            data.setUint8 (c++, attribSize); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            var i;
            for (i = 0; i < numComponents; i++)
            {
                // Attribute : "B" (42) "G" (47) "R" (52)
                if (i==0)       data.setUint8 (c++, 0x42);
                else if (i==1)  data.setUint8 (c++, 0x47);
                else if (i==2)  data.setUint8 (c++, 0x52);
                data.setUint8 (c++, 0x00);
                
                // Value : Float (2), Half (1), Uint (0)
                if      (type=="Uint")   data.setUint8 (c++, 0x00); 
                else if (type=="Half")   data.setUint8 (c++, 0x01);
                else if (type=="Float")  data.setUint8 (c++, 0x02);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);

                // Plinear
                data.setUint8 (c++, 0x01);

                // Reserved
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 

                // X sampling
                data.setUint8 (c++, 0x01); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                
                // Y sampling
                data.setUint8 (c++, 0x01);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
            }
            // End attribute
            data.setUint8 (c++, 0x00);
    
        // Write attribute name : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute type : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : "1"
            data.setUint8 (c++, 0x01); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // Write attribute value : "0" (None)
            data.setUint8 (c++, 0x00);

        // datawindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00); 

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00);

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 

            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // displayWindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x79); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00);

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00); 

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // size
            data.setUint8 (c++, 0x01);
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);
            
            // value 
            data.setUint8 (c++, 0x00);

        // PixelAspectRatio
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x41); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x52); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x00); 

            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);
        
            // size 4
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 1.0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);
        
        // screenWindowCenter
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63);
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x43); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e);
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00);

            // v2f
            data.setUint8 (c++, 0x76); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x00);

            // size 8
            data.setUint8 (c++, 0x08); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

        // screenWindowWidth
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x00); 
            
            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00); 

            // size
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);

            // value
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);

        // End of header
        data.setUint8 (c++, 0x00);
    }
    //console.log("header size = " + c);

    // Scanline table
    var initc = c + height * 8;
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        var jump = initc + scanline * (8 + width * bytesPerComponent * numComponents); 
        data.setUint32 (c, jump, true);
        c += 4; 

        data.setUint32 (c, 0x00, true);
        c += 4;
    }
    //console.log("header + scanlines table size = " + c);

    // Scanlines
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        // Scanline
        data.setUint32(c, scanline, true);
        c += 4;

        // size 24
        var size = width * numComponents * bytesPerComponent; 
        data.setUint32(c, size, true);
        c += 4;

        var numComponentsSource = 4; // number of components in the SOURCE image
        for (var component = 0; component < numComponents ; component ++) 
        {
            for (var pixel = 0 ; pixel < width ; pixel ++) 
            {
                // flip vertical, so we read OpenGL buffers without JS image flipping
                var v = bytes[(height-1-scanline) * width *numComponentsSource + pixel * numComponentsSource + (2-component)];
                if      (type=="Float") data.setFloat32(c, v, true);
                else if (type=="Half")  data.setUint16(c, v, true);

                c += bytesPerComponent;
            }
        }
    }
    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}


function piExportToWAV(numSamples, rate, bits, numChannels, words)
{
    let numBytes = numSamples * numChannels * bits/8;

    let buffer = new ArrayBuffer(44 + numBytes); 
    let data = new DataView(buffer);

    {
        data.setUint32( 0, 0x46464952, true );  // RIFF
        data.setUint32( 4, numBytes + 36, true);
        {
            data.setUint32( 8, 0x45564157, true );  // WAV_WAVE
            data.setUint32( 12, 0x20746D66, true );  // WAV_FMT
            {
                data.setUint32( 16, 16, true);
                data.setUint16( 20, 1, true ); // WAV_FORMAT_PCM
                data.setUint16( 22, numChannels, true);
                data.setUint32( 24, rate, true);
                data.setUint32( 28, rate*numChannels*bits / 8, true);
                data.setUint16( 32, numChannels*bits / 8, true);
                data.setUint16( 34, bits, true);
            }

            data.setUint32( 36, 0x61746164, true);  // WAV_DATA
            {
                data.setUint32( 40, numBytes, true);
                let numWords = numSamples * numChannels;
                for(let i=0; i<numWords; i++ )
                {
                    data.setInt16( 44 + i*2, words[i], true );
                }
            }
        }
    }


    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}

function piTriggerDownload(name, blob)
{
    let url = URL.createObjectURL(blob);
    let aElement = document.createElement("a");
    aElement.href     = url;
    aElement.target   = "_self";
    aElement.download = name;
    document.body.appendChild(aElement);
    aElement.click();
    document.body.removeChild(aElement);
}</script>
    <script>"use strict"

function bufferID_to_assetID( id )
{
    if( id===0 ) return '4dXGR8';
    if( id===1 ) return 'XsXGR8';
    if( id===2 ) return '4sXGR8';
    if( id===3 ) return 'XdfGR8';
    return 'none';
}
function assetID_to_bufferID( id )
{
    if( id==='4dXGR8' ) return 0;
    if( id==='XsXGR8' ) return 1;
    if( id==='4sXGR8' ) return 2;
    if( id==='XdfGR8' ) return 3;
    return -1;
}

function assetID_to_cubemapBuferID( id )
{
    if( id==='4dX3Rr' ) return 0;
    return -1;
}
function cubamepBufferID_to_assetID( id )
{
    if( id===0 ) return '4dX3Rr';
    return 'none';
}

function EffectPass( renderer, is20, isLowEnd, hasShaderTextureLOD, callback, obj, forceMuted, forcePaused, outputGainNode, copyProgram, id, effect  )
{
    this.mID = id;
    this.mInputs  = [null, null, null, null ];
    this.mOutputs = [null, null, null, null ];
    this.mSource = null;

    this.mGainNode = outputGainNode;
    this.mSoundShaderCompiled = false;

    this.mEffect = effect;
    this.mRenderer = renderer;
    this.mProgramCopy = copyProgram; 
    this.mCompilationTime = 0;

    this.mType = "none";
    this.mName = "none";
    this.mFrame = 0;

    this.mShaderTextureLOD = hasShaderTextureLOD;
    this.mIs20 = is20;
    this.mIsLowEnd = isLowEnd;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mForceMuted = forceMuted;
    this.mForcePaused = forcePaused;
}

EffectPass.prototype.MakeHeader_Image = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        // old API
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                   header += "uniform sampler2D iChannel" + i + ";\n";

        // new API (see shadertoy.com/view/wtdGW8)
        header += "uniform struct {\n";
             if( inp===null )                  header += "  sampler2D";
        else if( inp.mInfo.mType==="cubemap" ) header += "  samplerCube";
        else if( inp.mInfo.mType==="volume"  ) header += "  sampler3D";
        else                                  header += "  sampler2D";
        header +=        " sampler;\n";
        header += "  vec3  size;\n";
        header += "  float time;\n";
        header += "  int   loaded;\n";
        header += "}iCh" + i + ";\n";
    }
	header += "void mainImage( out vec4 c, in vec2 f );\n";
    header += "void st_assert( bool cond );\n";
    header += "void st_assert( bool cond, int v );\n";

    if( this.mIs20 ) 
    {
        header += "\nout vec4 shadertoy_out_color;\n" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)shadertoy_out_color.x=-1.0;else if(v==1)shadertoy_out_color.y=-1.0;else if(v==2)shadertoy_out_color.z=-1.0;else shadertoy_out_color.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)shadertoy_out_color.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "shadertoy_out_color = vec4(1.0,1.0,1.0,1.0);" + 
            "vec4 color = vec4(1e20);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "if(shadertoy_out_color.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(shadertoy_out_color.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(shadertoy_out_color.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(shadertoy_out_color.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "shadertoy_out_color = vec4(color.xyz,1.0);" +
        "}";
    }
    else
    {
        header += "" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)gl_FragColor.x=-1.0;else if(v==1)gl_FragColor.y=-1.0;else if(v==2)gl_FragColor.z=-1.0;else gl_FragColor.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)gl_FragColor.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "gl_FragColor = vec4(0.0,0.0,0.0,1.0);" + 
            "vec4 color = vec4(1e20);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "color.w = 1.0;" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(gl_FragColor.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "gl_FragColor = vec4(color.xyz,1.0);"+
        "}";
    }
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 ) 
        this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "void main( void )" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );" +
        "color.w = 1.0;"
    if( this.mIs20 ) 
        this.mImagePassFooterVR +=  "outColor = color;}";
    else
        this.mImagePassFooterVR +=  "gl_FragColor = color;}";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Buffer = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                  header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainImage( out vec4 c,  in vec2 f );\n"

    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +
        "mainImage( color, gl_FragCoord.xy );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
    this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        this.mImagePassFooterVR +="outColor = color; }";
    else
        this.mImagePassFooterVR +="gl_FragColor = color; }";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Cubemap = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                   header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainCubemap( out vec4 c, in vec2 f, in vec3 ro, in vec3 rd );\n"

    header += "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainCubemap( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Sound = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform float     iChannelTime[4];\n" +
              "uniform float     iTimeOffset;\n" +
              "uniform int       iSampleOffset;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n";

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp!==null && inp.mInfo.mType==="cubemap" )
            header += "uniform samplerCube iChannel" + i + ";\n";
        else
            header += "uniform sampler2D iChannel" + i + ";\n";
    }
    header += "\n";
    header += "vec2 mainSound( in int samp, float time );\n";

    if( this.mIs20 )
    {
        header += "out vec4 outColor; void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "int   s = iSampleOffset + int(gl_FragCoord.y-0.2)*512 + int(gl_FragCoord.x-0.2);" +
            "vec2 y = mainSound( s, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "outColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    else
    {
        header += "void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "vec2 y = mainSound( 0, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "gl_FragColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    header += "\n";
    this.mHeader = header;
    this.mHeaderLength = 0;
}


EffectPass.prototype.MakeHeader_Common = function ()
{
    let header = "";
    let headerlength = 0;

    header += "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n";
    headerlength += 2;

    if (this.mIs20)
    {
        header += "out vec4 outColor;\n";
        headerlength += 1;
    }
    header += "void main( void )\n";
    headerlength += 1;

    if (this.mIs20)
        header += "{ outColor = vec4(0.0); }";
    else
        header += "{ gl_FragColor = vec4(0.0); }";
    headerlength += 1;
    header += "\n";
    headerlength += 1;

    this.mHeader = header;
    this.mHeaderLength = headerlength;
}

EffectPass.prototype.MakeHeader = function()
{
         if( this.mType==="image" ) this.MakeHeader_Image();
    else if( this.mType==="sound" ) this.MakeHeader_Sound();
    else if( this.mType==="buffer") this.MakeHeader_Buffer();
    else if( this.mType==="common") this.MakeHeader_Common();
    else if( this.mType==="cubemap") this.MakeHeader_Cubemap();
    else console.log("ERROR 4");
}

EffectPass.prototype.Create_Image = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}
EffectPass.prototype.Destroy_Image = function( wa )
{
}

EffectPass.prototype.Create_Buffer = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}

EffectPass.prototype.Destroy_Buffer = function( wa )
{
}

EffectPass.prototype.Create_Cubemap = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
}

EffectPass.prototype.Destroy_Cubemap = function( wa )
{
}

EffectPass.prototype.Create_Common = function( wa )
{
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.MakeHeader();
}
EffectPass.prototype.Destroy_Common = function( wa )
{
}

EffectPass.prototype.Create_Sound = function (wa)
{
    this.MakeHeader();

    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    this.mSampleRate = 44100;
    this.mPlayTime = 60*3;
    this.mPlaySamples = this.mPlayTime*this.mSampleRate;
    this.mBuffer = wa.createBuffer( 2, this.mPlaySamples, this.mSampleRate );

    //-------------------
    this.mTextureDimensions = 512;
    this.mRenderTexture = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D, 
                                                       this.mTextureDimensions, this.mTextureDimensions,
                                                       this.mRenderer.TEXFMT.C4I8,
                                                       this.mRenderer.FILTER.NONE,
                                                       this.mRenderer.TEXWRP.CLAMP, null);
    this.mRenderFBO = this.mRenderer.CreateRenderTarget(this.mRenderTexture, null, null, null, null, false);

    //-----------------------------

    // ArrayBufferView pixels;
    this.mTmpBufferSamples = this.mTextureDimensions*this.mTextureDimensions;
    this.mData = new Uint8Array( this.mTmpBufferSamples*4 );

    this.mPlaying = false;
}

EffectPass.prototype.Destroy_Sound = function( wa )
{
    if( this.mPlayNode!==null ) this.mPlayNode.stop();
    this.mPlayNode = null;
    this.mBuffer = null;
    this.mData = null;

    this.mRenderer.DestroyRenderTarget(this.mRenderFBO);
    this.mRenderer.DestroyTexture(this.mRenderTexture);
}

EffectPass.prototype.Create = function( passType, wa )
{
    this.mType = passType;
    this.mSource = null;

         if( passType==="image" ) this.Create_Image( wa );
    else if( passType==="sound" ) this.Create_Sound( wa );
    else if( passType==="buffer") this.Create_Buffer( wa );
    else if( passType==="common") this.Create_Common( wa );
    else if( passType==="cubemap") this.Create_Cubemap( wa );
    else alert("ERROR 1");
}

EffectPass.prototype.SetName = function (passName)
{
    this.mName = passName;
}

EffectPass.prototype.SetCode = function (src)
{
    this.mSource = src;
}

EffectPass.prototype.Destroy = function( wa )
{
    this.mSource = null;
         if( this.mType==="image" ) this.Destroy_Image( wa );
    else if( this.mType==="sound" ) this.Destroy_Sound( wa );
    else if( this.mType==="buffer") this.Destroy_Buffer( wa );
    else if( this.mType==="common") this.Destroy_Common( wa );
    else if( this.mType==="cubemap") this.Destroy_Cubemap( wa );
    else alert("ERROR 2");
}

EffectPass.prototype.NewShader_Sound = function( shaderCode, commonShaderCodes)
{
    let vsSource = null;

    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for( let i=0; i<commonShaderCodes.length; i++ )
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    this.mSoundShaderCompiled = false;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader_Image = function ( shaderCode, commonShaderCodes )
{
    this.mSupportsVR = false;

    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    return [vsSource, fsSource];


    /*
    let n1 = shaderCode.indexOf("mainVR(");
    let n2 = shaderCode.indexOf("mainVR (");
    let n3 = shaderCode.indexOf("mainVR  (");
    if( n1>0 || n2>0 || n3>0 )
    {
        let vsSourceVR;
        if( this.mIs20 )
            vsSourceVR = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        else
            vsSourceVR = "attribute in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

        let fsSourceVR = this.mHeader;
        for (let i = 0; i < commonShaderCodes.length; i++) {
            fsSourceVR += commonShaderCodes[i];
        }
        fsSourceVR += shaderCode;
        fsSourceVR += this.mImagePassFooterVR;

        let res = this.mRenderer.CreateShader(vsSource, fsSourceVR, preventCache);
        if( res.mResult == false )
        {
            return res.mInfo;
        }
        if( this.mProgramVR != null )
            this.mRenderer.DestroyShader( this.mProgramVR );

        this.mSupportsVR = true;
        this.mProgramVR = res;
    }
    */
}

EffectPass.prototype.NewShader_Cubemap = function( shaderCode, commonShaderCodes )
{
    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }

    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;

    fsSource += shaderCode;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader_Common = function (shaderCode )
{
    let vsSource = null;
    if (this.mIs20)
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader + shaderCode;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader = function ( commonSourceCodes, preventCache, onResolve)
{
    if( this.mRenderer===null ) return;

    let vs_fs = null;

         if( this.mType==="sound"  ) vs_fs = this.NewShader_Sound(   this.mSource, commonSourceCodes );
    else if( this.mType==="image"  ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="buffer" ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="common" ) vs_fs = this.NewShader_Common(  this.mSource,                   );
    else if( this.mType==="cubemap") vs_fs = this.NewShader_Cubemap( this.mSource, commonSourceCodes );
    else { console.log("ERROR 3: \"" + this.mType + "\""); return; }

    let me = this;
    this.mRenderer.CreateShader(vs_fs[0], vs_fs[1], preventCache, false,
        function (worked, info)
        {
            if (worked === true)
            {
                if (me.mType === "sound")
                {
                    me.mSoundShaderCompiled = true;
                }

                me.mCompilationTime = info.mTime;
                me.mError = false;
                me.mErrorStr = "No Errors";
                if (me.mProgram !== null)
                    me.mRenderer.DestroyShader(me.mProgram);
                me.mTranslatedSource = me.mRenderer.GetTranslatedShaderSource(info);
                me.mProgram = info;
            }
            else
            {
                me.mError = true;
                me.mErrorStr = info.mErrorStr;
            }
            onResolve();
        });
}

EffectPass.prototype.DestroyInput = function( id )
{
    if( this.mInputs[id]===null ) return;

    if( this.mInputs[id].mInfo.mType==="texture" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    if( this.mInputs[id].mInfo.mType==="volume" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="webcam" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video.src = "";

        if( this.mInputs[id].video.srcObject!==null )
        {
        let tracks = this.mInputs[id].video.srcObject.getVideoTracks();
        if( tracks ) tracks[0].stop();
        }
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="video" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="music" || this.mInputs[id].mInfo.mType==="musicstream")
    {
        this.mInputs[id].audio.pause();
        this.mInputs[id].audio.mSound.mFreqData = null;
        this.mInputs[id].audio.mSound.mWaveData = null;
        this.mInputs[id].audio = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="cubemap" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="keyboard" )
    {
        //if( this.mInputs[id].globject != null )
          //  this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="mic" )
    {
        this.mInputs[id].mic = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }

    this.mInputs[id] = null;
}

EffectPass.prototype.TooglePauseInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        else
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.audio.mPaused )
        {
            if( inp.loaded )
            {
                inp.audio.play();
            }
            inp.audio.mPaused = false;
        }
        else
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }

    return null;
}

EffectPass.prototype.StopInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused === false )
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused === false )
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.ResumeInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused )
        {
            inp.audio.play();
            inp.audio.mPaused = false;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.RewindInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp==null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.loaded )
        {
            inp.video.currentTime = 0;
        }
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.loaded )
        {
            inp.audio.currentTime = 0;
        }
    }
}

EffectPass.prototype.MuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = true;
        inp.video.mMuted = true;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 0.0;
        inp.audio.mMuted = true;
    }
}

EffectPass.prototype.UnMuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = false;
        inp.video.mMuted = false;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 1.0;
        inp.audio.mMuted = false;
    }
}

EffectPass.prototype.ToggleMuteInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];
    if( inp===null ) return null;

    if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.video.mMuted;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if( inp.audio.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.audio.mMuted;
    }

    return null;
}

EffectPass.prototype.UpdateInputs = function( wa, forceUpdate, keyboard )
{
   for (let i=0; i<this.mInputs.length; i++ )
   {
        let inp = this.mInputs[i];

        if( inp===null )
        {
            if( forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, null, false, 0, 0, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.image, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mPreview, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if( inp.loaded && forceUpdate )
            {
                if( this.mTextureCallbackFun!==null )
                {
                    let img = (assetID_to_cubemapBuferID(inp.mInfo.mID)===-1) ? inp.image[0] : inp.mImage;
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, img, true, 2, 1, -1.0, this.mID );
                }
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:keyboard.mIcon,mData:keyboard.mData}, false, 6, 0, -1.0, this.mID );
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, -1, this.mID );
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
              if( inp.loaded && inp.audio.mPaused === false && inp.audio.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                      inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                  }

                  if (this.mTextureCallbackFun!==null)
                  {
                           if (inp.mInfo.mType === "music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData}, false, 4, 1, inp.audio.currentTime, this.mID);
                      else if (inp.mInfo.mType === "musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData, info: inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                  }
              }
              else if( inp.loaded===false )
              {
                  if (this.mTextureCallbackFun!==null)
                      this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:null}, false, 4, 0, -1.0, this.mID);
              }
        }
        else if( inp.mInfo.mType==="mic" )
        {
              if( inp.loaded && inp.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                      inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
                  }
                  if( this.mTextureCallbackFun!==null )
                      this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave: ((wa==null)?null:inp.mFreqData) }, false, 5, 1, 0, this.mID );
              }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:null}, true, 9, 1, -1.0, this.mID );
            }
        }
    }
}

EffectPass.prototype.Sampler2Renderer = function (sampler)
{
    let filter = this.mRenderer.FILTER.NONE;
    if (sampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
    if (sampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
    let wrap = this.mRenderer.TEXWRP.REPEAT;
    if (sampler.wrap === "clamp") wrap = this.mRenderer.TEXWRP.CLAMP;
    let vflip = false;
    if (sampler.vflip === "true") vflip = true;

    return { mFilter: filter, mWrap: wrap, mVFlip: vflip };
}

EffectPass.prototype.GetSamplerVFlip = function (id)
{
    let inp = this.mInputs[id];
    return inp.mInfo.mSampler.vflip;
}

EffectPass.prototype.GetTranslatedShaderSource = function ()
{
    return this.mTranslatedSource;
}

EffectPass.prototype.SetSamplerVFlip = function (id, str) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = false;
    if (str === "true") filter = true;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, null);
            inp.mInfo.mSampler.vflip = str;
        }
    }
}

EffectPass.prototype.GetAcceptsVFlip = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return false;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return false;
    return true;
}

EffectPass.prototype.GetSamplerFilter = function (id)
{
    let inp = this.mInputs[id];
    if( inp===null) return;
    return inp.mInfo.mSampler.filter;
}

EffectPass.prototype.SetSamplerFilter = function (id, str, buffers, cubeBuffers) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = renderer.FILTER.NONE;
    if (str === "linear") filter = renderer.FILTER.LINEAR;
    if (str === "mipmap") filter = renderer.FILTER.MIPMAP;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0)
            {
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[0], filter, true);
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[1], filter, true);
                inp.mInfo.mSampler.filter = str;
            }
            else
            {
                renderer.SetSamplerFilter(inp.globject, filter, true);
                inp.mInfo.mSampler.filter = str;
            }
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[0], filter, true);
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[1], filter, true);
        inp.mInfo.mSampler.filter = str;
    }
    else if (inp.mInfo.mType === "keyboard")
    {
        inp.mInfo.mSampler.filter = str;
    }
}

EffectPass.prototype.GetAcceptsMipmapping = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetAcceptsLinear = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return true;
    if (inp.mInfo.mType === "musicstream") return true;
    if (inp.mInfo.mType === "mic")  return true;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return true;
    return false;
}

EffectPass.prototype.GetAcceptsWrapRepeat = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return false;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetSamplerWrap = function (id)
{
    return this.mInputs[id].mInfo.mSampler.wrap;
}

EffectPass.prototype.SetSamplerWrap = function (id, str, buffers)
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let restr = renderer.TEXWRP.REPEAT;
    if (str === "clamp") restr = renderer.TEXWRP.CLAMP;

    if (inp === null) 
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "video") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap") 
    {
        if (inp.loaded)
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "webcam") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[0], restr);
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[1], restr);
        inp.mInfo.mSampler.wrap = str;
    }
}


EffectPass.prototype.GetTexture = function( slot )
{
    let inp = this.mInputs[slot];
    if( inp===null ) return null;
    return inp.mInfo;
}

EffectPass.prototype.SetOutputs = function( slot, id )
{
    this.mOutputs[slot] = id;
}

EffectPass.prototype.SetOutputsByBufferID = function( slot, id )
{
    if( this.mType==="buffer" )
    {
        this.mOutputs[slot] = bufferID_to_assetID( id );

        this.mEffect.ResizeBuffer( id, this.mEffect.mXres, this.mEffect.mYres, false );
    }
    else if( this.mType==="cubemap" )
    {
        this.mOutputs[slot] = cubamepBufferID_to_assetID( id );
        this.mEffect.ResizeCubemapBuffer(id, 1024, 1024 );
    }
}

EffectPass.prototype.NewTexture = function( wa, slot, url, buffers, cubeBuffers, keyboard )
{
    var me = this;
    var renderer = this.mRenderer;

    if( renderer===null ) return;

    let texture = null;

    if( url===null || url.mType===null )
    {
        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( this.mTextureCallbackObj, slot, null, true, 0, 0, -1.0, me.mID );
        me.DestroyInput( slot );
        me.mInputs[slot] = null;
        me.MakeHeader();
        return { mFailed:false, mNeedsShaderCompile:false };
    }
    else if( url.mType==="texture" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.image = new Image();
        texture.image.crossOrigin = '';
        texture.image.onload = function()
        {
            let rti = me.Sampler2Renderer(url.mSampler);

            // O.M.G. FIX THIS
            let channels = renderer.TEXFMT.C4I8;
            if (url.mID === "Xdf3zn" || url.mID === "4sf3Rn" || url.mID === "4dXGzn" || url.mID === "4sf3Rr")
                channels = renderer.TEXFMT.C1I8;
            
            texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.image, channels, rti.mFilter, rti.mWrap, rti.mVFlip);

            texture.loaded = true;
            if( me.mTextureCallbackFun!==null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.image, true, 1, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="volume" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mImage = { mData:null, mXres:1, mYres:0, mZres:0 };
        texture.mPreview = new Image();
        texture.mPreview.crossOrigin = '';

	    var xmlHttp = new XMLHttpRequest();
        if( xmlHttp===null ) return { mFailed:true };

        xmlHttp.open('GET', url.mSrc, true);
        xmlHttp.responseType = "arraybuffer";
        xmlHttp.onerror = function()
        {
            console.log( "Error 1 loading Volume" );
        }
        xmlHttp.onload = function()
        {
            let data = xmlHttp.response;
            if (!data ) { console.log( "Error 2 loading Volume" ); return; }

            let file = piFile(data);

            let signature = file.ReadUInt32();
            texture.mImage.mXres = file.ReadUInt32();
            texture.mImage.mYres = file.ReadUInt32();
            texture.mImage.mZres = file.ReadUInt32();
            let binNumChannels = file.ReadUInt8();
            let binLayout = file.ReadUInt8();
            let binFormat = file.ReadUInt16();
            let format = renderer.TEXFMT.C1I8;
                 if( binNumChannels===1 && binFormat===0 )  format = renderer.TEXFMT.C1I8;
            else if( binNumChannels===2 && binFormat===0 )  format = renderer.TEXFMT.C2I8;
            else if( binNumChannels===3 && binFormat===0 )  format = renderer.TEXFMT.C3I8;
            else if( binNumChannels===4 && binFormat===0 )  format = renderer.TEXFMT.C4I8;
            else if( binNumChannels===1 && binFormat===10 ) format = renderer.TEXFMT.C1F32;
            else if( binNumChannels===2 && binFormat===10 ) format = renderer.TEXFMT.C2F32;
            else if( binNumChannels===3 && binFormat===10 ) format = renderer.TEXFMT.C3F32;
            else if( binNumChannels===4 && binFormat===10 ) format = renderer.TEXFMT.C4F32;
            else return;

            let buffer = new Uint8Array(data, 20); // skip 16 bytes (header of .bin)

            let rti = me.Sampler2Renderer(url.mSampler);

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T3D, texture.mImage.mXres, texture.mImage.mYres, format, rti.mFilter, rti.mWrap, buffer);

            if( texture.globject===null )
            {
                console.log( "Error 4: loading Volume" ); 
                return { mFailed:true };
            }

            if (me.mTextureCallbackFun !== null)
            {
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }

            texture.loaded = true;

            // load icon for it
            texture.mPreview.onload = function()
            {
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }
            texture.mPreview.src = url.mPreviewSrc;
        }
        xmlHttp.send("");


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="volume")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="cubemap" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        let rti = me.Sampler2Renderer(url.mSampler);

        if( assetID_to_cubemapBuferID(url.mID)!==-1 )
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 2, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/cubemap00.png";

            this.mEffect.ResizeCubemapBuffer(0, 1024, 1024 );

        }
        else
        {
            texture.image = [ new Image(), new Image(), new Image(), new Image(), new Image(), new Image() ];

            let numLoaded = 0;
            for (var i=0; i<6; i++ )
            {
                texture.image[i].mId = i;
                texture.image[i].crossOrigin = '';
                texture.image[i].onload = function()
                {
                    var id = this.mId;
                    numLoaded++;
                    if( numLoaded===6 )
                    {
                        texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.CUBEMAP, texture.image, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                        texture.loaded = true;
                        if (me.mTextureCallbackFun !== null)
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, texture.image[0], true, 2, 1, -1.0, me.mID);
                    }
                }

                if( i === 0) 
                {
                    texture.image[i].src = url.mSrc;
                } 
                else 
                {
                    let n = url.mSrc.lastIndexOf(".");
                    texture.image[i].src = url.mSrc.substring(0, n) + "_" + i + url.mSrc.substring(n, url.mSrc.length);
                }
            }
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="cubemap")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="webcam" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        texture.video = document.createElement('video');
    	texture.video.width = 320;
    	texture.video.height = 240;
    	texture.video.autoplay = true;
    	texture.video.loop = true;
        texture.mForceMuted = this.mForceMuted;
        texture.mImage = null;

        let rti = me.Sampler2Renderer(url.mSampler);

        var loadImageInsteadOfWebCam = function()
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.mImage, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 7, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/webcam.png";
        }
        
        loadImageInsteadOfWebCam();

        if( typeof navigator.getUserMedia !== "undefined"  && texture.mForceMuted===false )
        {
            texture.video.addEventListener("canplay", function (e)
            {
				try
				{
                    texture.mImage = null;
                    if( texture.globject != null )
                        renderer.DestroyTexture( texture.globject );
					texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
					texture.loaded = true;
                }
                catch(e)
                {
                    loadImageInsteadOfWebCam();
	                alert( 'Your browser can not transfer webcam data to the GPU.');
                }
            } );

            navigator.mediaDevices.getUserMedia( 
                                { "video": { width: 1280, height: 720 }, "audio": false } )
                                .then( function(stream)
                                       {
                                            texture.video.srcObject = stream;
    	                               } )
                                .catch( function(error)
                                        {
                                            loadImageInsteadOfWebCam();
    		                                alert( 'Unable to capture WebCam. Please reload the page.' );
    	                                } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="mic" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mForceMuted = this.mForceMuted;
        texture.mAnalyser = null;
        let num = 512;
        texture.mFreqData = new Uint8Array( num );
        texture.mWaveData = new Uint8Array( num );

        if( wa === null || typeof navigator.getUserMedia === "undefined" )
        {
            if( !texture.mForceMuted ) alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.mForceMuted = true; 
        }

        if( texture.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, num, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)
            texture.loaded = true;
        }
        else
        {
        navigator.getUserMedia( { "audio": true },
                                function(stream)
                                {
                                  texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, null)
                                  texture.mic = wa.createMediaStreamSource(stream);
                                  texture.mAnalyser = wa.createAnalyser();
                                  texture.mic.connect( texture.mAnalyser );
                                  texture.loaded = true;
    	                        },
                                function(error)
                                {
    		                        alert( 'Unable open Mic. Please reload the page.' );
    	                        } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="video" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.video = document.createElement('video');
    	texture.video.loop = true;
        texture.video.preload = "auto";
        texture.video.mPaused = this.mForcePaused;
        texture.video.mMuted = true;//this.mForceMuted;
    	texture.video.muted  = true;//this.mForceMuted;
        if( this.mForceMuted===true )
            texture.video.volume = 0;
    	texture.video.autoplay = false;
        texture.video.hasFalled = false;
        
        let rti = me.Sampler2Renderer(url.mSampler);

        texture.video.addEventListener("canplay", function (e)
        {
            texture.video.play().then( function()
                                       {
                                           texture.video.mPaused = false;

                                           texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                                           texture.loaded = true;
            
                                           if( me.mTextureCallbackFun!=null )
                                               me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.video, true, 3, 1, -1.0, me.mID );
                                        } )
                               .catch( function(error)
                                       {
                                           console.log( error );
                                       }
                                );
        } );

        texture.video.addEventListener( "error", function(e)
        {
               if( texture.video.hasFalled===true ) { alert("Error: cannot load video" ); return; }
               let str = texture.video.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".mp4";
               texture.video.src = str;
               texture.video.hasFalled = true;
        } );

        texture.video.src = url.mSrc;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="music" || url.mType==="musicstream" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.audio = document.createElement('audio');
    	texture.audio.loop = true;
        texture.audio.mMuted = this.mForceMuted;
        texture.audio.mForceMuted = this.mForceMuted;
        texture.audio.muted = this.mForceMuted;
        if( this.mForceMuted===true )
            texture.audio.volume = 0;
        texture.audio.autoplay = false;
        texture.audio.hasFalled = false;
        texture.audio.mPaused = false;
        texture.audio.mSound = {};

        if( this.mForceMuted===false )
        {
            if(url.mType==="musicstream" && SC === null)
            {
                alert( "Shadertoy: Soundcloud could not be reached" );
                texture.audio.mForceMuted = true;
            }
            }

        if( wa === null && this.mForceMuted===false )
        {
            alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.audio.mForceMuted = true;
        }

        if( texture.audio.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null);
            let num = 512;
            texture.audio.mSound.mFreqData = new Uint8Array( num );
            texture.audio.mSound.mWaveData = new Uint8Array( num );
            texture.loaded = true;
        }

        texture.audio.addEventListener( "canplay", function()
        {
            if( texture===null || texture.audio===null ) return;
            if( this.mForceMuted  ) return;
            if( texture.loaded === true ) return;

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)

            texture.audio.mSound.mSource   = wa.createMediaElementSource( texture.audio );
            texture.audio.mSound.mAnalyser = wa.createAnalyser();
            texture.audio.mSound.mGain     = wa.createGain();

            texture.audio.mSound.mSource.connect(   texture.audio.mSound.mAnalyser );
            texture.audio.mSound.mAnalyser.connect( texture.audio.mSound.mGain );
            texture.audio.mSound.mGain.connect(me.mGainNode);

            texture.audio.mSound.mFreqData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );
            texture.audio.mSound.mWaveData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );

            if( texture.audio.mPaused )
            {
                texture.audio.pause();
            }
            else
            {
                texture.audio.play().then( function() {} ).catch( function(e){console.log("error " + e);} );
            }
            texture.loaded = true;
        } );

        texture.audio.addEventListener( "error", function(e)
        {
               if( this.mForceMuted  ) return;

               if( texture.audio.hasFalled===true ) { return; }
               let str = texture.audio.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".ogg";
               texture.audio.src = str;
               texture.audio.hasFalled = true;
        } );

        if( !texture.audio.mForceMuted )
        {
            if(url.mType==="musicstream")
            {
                SC.resolve(url.mSrc, 
                    function(song) 
                    {
                        if( song.streamable===true )
                        {
                            texture.audio.crossOrigin = 'anonymous';
                            texture.audio.src = song.stream_url;
                            texture.audio.soundcloudInfo = song;
                        }
                        else
                        {
                            alert('Shadertoy: Soundcloud 3 - This track cannot be streamed' );
                        }
                    },
                    function(error)
                    {
                        if (me.mTextureCallbackFun!==null)
                        {
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
                        }
                    } );
            } 
            else
            {
                texture.audio.src = url.mSrc;
            }
        }

        if (me.mTextureCallbackFun!==null)
        {
            if (url.mType === "music")            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
            else if (url.mType === "musicstream") me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null, info: texture.audio.soundcloudInfo}, false, 8, 0, -1.0, me.mID);
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="keyboard" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = true;

        texture.keyboard = {};

        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {mImage: keyboard.mIcon, mData: keyboard.mData}, false, 6, 1, -1.0, me.mID );

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="buffer" )
    {
        texture = {};
        texture.mInfo = url;

        texture.image = new Image();
        texture.image.onload = function()
        {
            if( me.mTextureCallbackFun!==null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {texture: texture.image, data:null}, true, 9, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;
        texture.id = assetID_to_bufferID( url.mID );
        texture.loaded = true;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;

        this.mEffect.ResizeBuffer(texture.id, this.mEffect.mXres, this.mEffect.mYres, false );

        this.SetSamplerFilter(slot, url.mSampler.filter, buffers, cubeBuffers, true);
        this.SetSamplerVFlip(slot, url.mSampler.vflip);
        this.SetSamplerWrap(slot, url.mSampler.wrap, buffers);

        this.MakeHeader();
        return returnValue;
    }
    else
    {
        alert( "input type error" );
        return { mFailed: true };
    }

    return { mFailed: true };
}

EffectPass.prototype.Paint_Image = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];

    //------------------------
    
    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];
    let texIsLoaded = [0, 0, 0, 0 ];
    let texID = [ null, null, null, null];

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
            texIsLoaded[i] = 1;
            resos[3*i+0] = 256;
            resos[3*i+1] = 3;
            resos[3*i+2] = 1;
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;

                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                }
            }
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {

                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                texIsLoaded[i] = 0;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    times[i] = 10.0 + time;
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            let id = inp.id;
            if( inp.loaded===true  )
            {
                texID[i] = buffers[id].mTexture[ buffers[id].mLastRenderDone ];
                texIsLoaded[i] = 1;
                resos[3*i+0] = xres;
                resos[3*i+1] = yres;
                resos[3*i+2] = 1;
                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID[i], filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    let prog = this.mProgram;

    //if( vrData!=null && this.mSupportsVR ) prog = this.mProgramVR;

    this.mRenderer.AttachShader(prog);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F("iFrameRate", fps);

    this.mRenderer.SetShaderConstant1F(  "iCh0.time", times[0] );
    this.mRenderer.SetShaderConstant1F(  "iCh1.time", times[1] );
    this.mRenderer.SetShaderConstant1F(  "iCh2.time", times[2] );
    this.mRenderer.SetShaderConstant1F(  "iCh3.time", times[3] );
    this.mRenderer.SetShaderConstant3F(  "iCh0.size", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iCh1.size", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iCh2.size", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iCh3.size", resos[9], resos[10], resos[11] );
    this.mRenderer.SetShaderConstant1I(  "iCh0.loaded", texIsLoaded[0] );
    this.mRenderer.SetShaderConstant1I(  "iCh1.loaded", texIsLoaded[1] );
    this.mRenderer.SetShaderConstant1I(  "iCh2.loaded", texIsLoaded[2] );
    this.mRenderer.SetShaderConstant1I(  "iCh3.loaded", texIsLoaded[3] );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    if( (vrData !== null) && this.mSupportsVR )
    {
        for (let i=0; i<2; i++ )
        {
            let ei = (i===0) ? vrData.mLeftEye : vrData.mRightEye;

            let vp = [i * xres / 2, 0, xres / 2, yres];

            this.mRenderer.SetViewport(vp);

            let fov = ei.mProjection;
            let corA = [ -fov[2], -fov[1], -1.0 ];
            let corB = [  fov[3], -fov[1], -1.0 ];
            let corC = [  fov[3],  fov[0], -1.0 ];
            let corD = [ -fov[2],  fov[0], -1.0 ];
            let apex = [ 0.0, 0.0, 0.0 ];

            let ma = invertFast( ei.mCamera );
            corA = matMulpoint( ma, corA ); 
            corB = matMulpoint( ma, corB ); 
            corC = matMulpoint( ma, corC ); 
            corD = matMulpoint( ma, corD ); 
            apex = matMulpoint( ma, apex ); 

            let corners = [ corA[0], corA[1], corA[2], 
                            corB[0], corB[1], corB[2], 
                            corC[0], corC[1], corC[2], 
                            corD[0], corD[1], corD[2],
                            apex[0], apex[1], apex[2]];

            this.mRenderer.SetShaderConstant3FV("unCorners", corners);
            this.mRenderer.SetShaderConstant4FV("unViewport", vp);

            this.mRenderer.DrawUnitQuad_XY(l1);
        }
    }
    else 
    {
        this.mRenderer.SetViewport([0, 0, xres, yres]);
        this.mRenderer.DrawFullScreenTriangle_XY( l1 );
    }

    this.mRenderer.DettachTextures();
}

EffectPass.prototype.iRenderSound = function(d, callback )
{
    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds() ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    this.mRenderer.SetRenderTarget(this.mRenderFBO);

    this.mRenderer.SetViewport([0, 0, this.mTextureDimensions, this.mTextureDimensions]);
    this.mRenderer.AttachShader(this.mProgram);
    this.mRenderer.SetBlend( false );

    let texID = [null, null, null, null];
    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
    }

    this.mRenderer.AttachTextures(4, texID[0], texID[1], texID[2], texID[3]);

    let l2 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iTimeOffset");
    let l3 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iSampleOffset");
    this.mRenderer.SetShaderConstant4FV("iDate", dates);
    this.mRenderer.SetShaderConstant3FV("iChannelResolution", resos);
    this.mRenderer.SetShaderConstant1F("iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit("iChannel0", 0);
    this.mRenderer.SetShaderTextureUnit("iChannel1", 1);
    this.mRenderer.SetShaderTextureUnit("iChannel2", 2);
    this.mRenderer.SetShaderTextureUnit("iChannel3", 3);

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    //--------------------------------
    let numSamples = this.mTmpBufferSamples;
    let numBlocks = this.mPlaySamples / numSamples;
    for (let j=0; j<numBlocks; j++ )
    {
        let off = j*numSamples;
        
        this.mRenderer.SetShaderConstant1F_Pos(l2, off / this.mSampleRate);
        this.mRenderer.SetShaderConstant1I_Pos(l3, off );
        this.mRenderer.DrawUnitQuad_XY(l1);

        this.mRenderer.GetPixelData(this.mData, 0, this.mTextureDimensions, this.mTextureDimensions);

        callback( off, this.mData, numSamples );
    }

    this.mRenderer.DetachShader();
    this.mRenderer.DettachTextures();
    this.mRenderer.SetRenderTarget(null);
}

EffectPass.prototype.Paint_Sound = function( wa, d )
{
    let bufL = this.mBuffer.getChannelData(0); // Float32Array
    let bufR = this.mBuffer.getChannelData(1); // Float32Array

    this.iRenderSound( d, function(off, data, numSamples)
                         {
                            for( let i=0; i<numSamples; i++ )
                            {
                                bufL[off+i] = -1.0 + 2.0*(data[4*i+0]+256.0*data[4*i+1])/65535.0;
                                bufR[off+i] = -1.0 + 2.0*(data[4*i+2]+256.0*data[4*i+3])/65535.0;
                            }
                         }
                     );
}

EffectPass.prototype.SetUniforms = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    //------------------------
    
    let texID = [ null, null, null, null];

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
        }
        else if( inp.mInfo.mType=="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
    
                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                }
            }

        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
           if( inp.loaded===true )
           { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                times[i] = 10.0 + time;
            }

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = buffers[inp.id].mTexture[ buffers[inp.id].mLastRenderDone ];
                resos[3*i+0] = buffers[inp.id].mResolution[0];
                resos[3*i+1] = buffers[inp.id].mResolution[1];
                resos[3*i+2] = 1;
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    this.mRenderer.AttachShader(this.mProgram);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F(  "iFrameRate", fps );

    this.mRenderer.SetShaderConstant1F(  "iChannel[0].time",       times[0] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[1].time",       times[1] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[2].time",       times[2] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[3].time",       times[3] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[0].resolution", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[1].resolution", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[2].resolution", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[3].resolution", resos[9], resos[10], resos[11] );
}

EffectPass.prototype.ProcessInputs = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
        }
        else if( inp.mInfo.mType==="volume" )
        {
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );
                }
                else if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                if( inp.audio.mForceMuted === true )
                {
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                let id = inp.id;
                let texID = buffers[id].mTexture[ buffers[id].mLastRenderDone ];

                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID, filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
				let id = inp.id;
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }
}

EffectPass.prototype.Paint_Cubemap = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face )
{
    this.ProcessInputs(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
    this.SetUniforms(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    let vp = [0, 0, xres, yres];

    this.mRenderer.SetViewport(vp);

    let corA = [-1.0, -1.0, -1.0];
    let corB = [ 1.0, -1.0, -1.0];
    let corC = [ 1.0,  1.0, -1.0];
    let corD = [-1.0,  1.0, -1.0];
    let apex = [ 0.0,  0.0,  0.0];

         if( face===0 ) { corA=[ 1.0,  1.0,  1.0]; corB=[ 1.0,  1.0, -1.0]; corC=[ 1.0, -1.0, -1.0]; corD=[ 1.0, -1.0,  1.0]; }
    else if( face===1 ) { corA=[-1.0,  1.0, -1.0]; corB=[-1.0,  1.0,  1.0]; corC=[-1.0, -1.0,  1.0]; corD=[-1.0, -1.0, -1.0]; }
    else if( face===2 ) { corA=[-1.0,  1.0, -1.0]; corB=[ 1.0,  1.0, -1.0]; corC=[ 1.0,  1.0,  1.0]; corD=[-1.0,  1.0,  1.0]; }
    else if( face===3 ) { corA=[-1.0, -1.0,  1.0]; corB=[ 1.0, -1.0,  1.0]; corC=[ 1.0, -1.0, -1.0]; corD=[-1.0, -1.0, -1.0]; }
    else if( face===4 ) { corA=[-1.0,  1.0,  1.0]; corB=[ 1.0,  1.0,  1.0]; corC=[ 1.0, -1.0,  1.0]; corD=[-1.0, -1.0,  1.0]; }
    else if( face===5 ) { corA=[ 1.0,  1.0, -1.0]; corB=[-1.0,  1.0, -1.0]; corC=[-1.0, -1.0, -1.0]; corD=[ 1.0, -1.0, -1.0]; }

    let corners = [ corA[0], corA[1], corA[2], 
                    corB[0], corB[1], corB[2], 
                    corC[0], corC[1], corC[2], 
                    corD[0], corD[1], corD[2],
                    apex[0], apex[1], apex[2]];

    this.mRenderer.SetShaderConstant3FV("unCorners", corners);
    this.mRenderer.SetShaderConstant4FV("unViewport", vp);

    this.mRenderer.DrawUnitQuad_XY(l1);

    this.mRenderer.DettachTextures();
}

EffectPass.prototype.Paint = function( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, bufferNeedsMimaps, buffers, cubeBuffers, keyboard, effect )
{
    if( this.mType==="sound" )
    {
        if (this.mSoundShaderCompiled === true)
        {
            // make sure all textures are loaded
            for (let i=0; i<this.mInputs.length; i++ )
            {
                let inp = this.mInputs[i];
                if (inp === null) continue;

                if (inp.mInfo.mType === "texture" && !inp.loaded) return;
                if (inp.mInfo.mType === "cubemap" && !inp.loaded) return;
            }

            this.Paint_Sound(wa, da);
            this.mSoundShaderCompiled = false;
        }
        if (this.mFrame === 0)
        {
            if (this.mPlaying===true)
            {
                this.mPlayNode.disconnect();
                this.mPlayNode.stop();
                this.mPlayNode = null;
            }
            this.mPlaying = true;

            this.mPlayNode = wa.createBufferSource();
            this.mPlayNode.buffer = this.mBuffer;
            this.mPlayNode.connect(this.mGainNode);
            this.mPlayNode.start(0);
        }
        this.mFrame++;
    }
    else if( this.mType==="image" )
    {
        this.mRenderer.SetRenderTarget( null );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );
        this.mFrame++;
    }
    else if( this.mType==="common" )
    {
    }
    else if( this.mType==="buffer" )
    {
        this.mEffect.ResizeBuffer(bufferID, this.mEffect.mXres, this.mEffect.mYres, false );

        let buffer = buffers[bufferID];

        let dstID = 1 - buffer.mLastRenderDone;

        this.mRenderer.SetRenderTarget( buffer.mTarget[dstID] );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }

        // make thumbnail
        //if( this.mTextureCallbackFun != null )
        /*
        {
            this.mRenderer.SetRenderTarget( buffer.mThumbnailRenderTarget );
            let v = [0, 0, buffer.mThumbnailRes[0], buffer.mThumbnailRes[1]];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            this.mRenderer.SetShaderConstant4FV("v", v);
            this.mRenderer.AttachTextures(1, buffer.mTexture[dstID], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);
            this.mRenderer.DettachTextures();
            this.mRenderer.DetachShader();
            this.mRenderer.GetPixelData( new Uint8Array(buffer.mThumbnailBuffer.data.buffer), buffer.mThumbnailRes[0], buffer.mThumbnailRes[1] );
            this.mRenderer.SetRenderTarget(null);
        }
        */
        buffers[bufferID].mLastRenderDone = 1 - buffers[bufferID].mLastRenderDone;
        this.mFrame++;
    }
    else if( this.mType==="cubemap" )
    {
        this.mEffect.ResizeCubemapBuffer(bufferID, 1024, 1024, false );

        let buffer = cubeBuffers[bufferID];

        xres = buffer.mResolution[0];
        yres = buffer.mResolution[1];
        let dstID = 1 - buffer.mLastRenderDone;
        for( let face=0; face<6; face++ )
        {
            this.mRenderer.SetRenderTargetCubeMap( buffer.mTarget[dstID], face );
            this.Paint_Cubemap( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
        }
        this.mRenderer.SetRenderTargetCubeMap( null, 0 );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }
        cubeBuffers[bufferID].mLastRenderDone = 1 - cubeBuffers[bufferID].mLastRenderDone;

        this.mFrame++;
    }
}

EffectPass.prototype.StopOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;
    this.mPlayNode.disconnect();
}

EffectPass.prototype.ResumeOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;

    wa.resume()
    this.mPlayNode.connect( this.mGainNode );
}

EffectPass.prototype.StopOutput_Image = function( wa )
{
}

EffectPass.prototype.ResumeOutput_Image = function( wa )
{
}

EffectPass.prototype.StopOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.StopInput(j);

    if( this.mType==="sound" )
         this.StopOutput_Sound( wa );
    else
         this.StopOutput_Image( wa );
}

EffectPass.prototype.ResumeOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.ResumeInput(j);

    if( this.mType==="sound" )
         this.ResumeOutput_Sound( wa );
    else
         this.ResumeOutput_Image( wa );
}

EffectPass.prototype.GetCompilationTime = function()
{
    return this.mCompilationTime;
}

//============================================================================================================
function Screenshots()
{
    // private
    let mTexture = null;
    let mTarget = null;
    let mXres = 0;
    let mYres = 0;
    let mCubemapToEquirectProgram;
    let mRenderer = null;

    // public
    var me = {};

    me.Initialize = function(renderer)
    {
        mRenderer = renderer;
        let caps = mRenderer.GetCaps();
        let is20 = caps.mIsGL20;

        let vsSourceC, fsSourceC;
        if( is20 )
        {
            vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; out vec4 outColor; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); outColor = texture(t, rd); }";
        }
        else
        {
            vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); gl_FragColor = texture(t, rd); }";
        }

        let compileShader = function (worked, info)
        {
            if (worked === false)
            {
                console.log("Failed to compile cubemap resample shader (" + errorType + "): " + log);
            }
            else
            {
                mCubemapToEquirectProgram = info;
            }
        }
        mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, compileShader);

        return true;
    };

    me.Allocate = function( xres, yres )
    {
        if( xres>mXres || yres>mYres )
        {
            let texture = mRenderer.CreateTexture(mRenderer.TEXTYPE.T2D, xres, yres, mRenderer.TEXFMT.C4F32, mRenderer.FILTER.NONE, mRenderer.TEXWRP.CLAMP, null);
            let target = mRenderer.CreateRenderTarget( texture, null, null, null, null, false);

            if( mXres!==0 )
            {
                mRenderer.DestroyTexture(mTexture);
                mRenderer.DestroyRenderTarget(mTarget);
            }

            mTexture = texture;
            mTarget = target;
            mXres = xres;
            mYres = yres;
        }
    };

    me.GetProgram = function()
    {
        return mCubemapToEquirectProgram;
    };
    me.GetTarget = function()
    {
        return mTarget;
    };

    return me;
};

//============================================================================================================

function Effect(vr, ac, canvas, callback, obj, forceMuted, forcePaused, resizeCallback, crashCallback )
{
    let xres = canvas.width;
    let yres = canvas.height;

    let me = this;
    this.mCanvas = canvas;
    this.mCreated = false;
    this.mRenderer = null;
    this.mAudioContext = ac;
    this.mGLContext = null;
    this.mWebVR = vr;
    this.mRenderingStereo = false;
    this.mXres = xres;
    this.mYres = yres;
    this.mForceMuted = forceMuted;
    if( ac===null ) this.mForceMuted = true;
    this.mForcePaused = forcePaused;
    this.mGainNode = null;
    this.mPasses = [];
    this.mFrame = 0;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mMaxBuffers = 4;
    this.mMaxCubeBuffers = 1;
    this.mMaxPasses = this.mMaxBuffers + 1 + 1 + 1 + 1; // some day decouple passes from buffers (4 buffers + common + Imagen + sound + cubemap)
    this.mBuffers = [];
    this.mCubeBuffers = [];
    this.mScreenshotSytem = null;
    this.mCompilationTime = 0;
    this.mIsLowEnd = piIsMobile();

    this.mGLContext = piCreateGlContext(canvas, false, false, true, false); // need preserve-buffe to true in order to capture screenshots
    if (this.mGLContext === null)
    {
        return;
    }

    canvas.addEventListener("webglcontextlost", function (event)
        {
            event.preventDefault();
            crashCallback();
        }, false);

    this.mRenderer = piRenderer();
    if (!this.mRenderer.Initialize(this.mGLContext))
        return;

    this.mScreenshotSytem = Screenshots();
    if (!this.mScreenshotSytem.Initialize(this.mRenderer))
        return;

    var caps = this.mRenderer.GetCaps();
    this.mIs20 = caps.mIsGL20;
    this.mShaderTextureLOD = caps.mShaderTextureLOD;
    //-------------
    if( ac!==null )
    {   
        this.mGainNode = ac.createGain();
        if( !forceMuted )
        {
            this.mGainNode.connect( ac.destination);
        }
        if (this.mForceMuted )
            this.mGainNode.gain.value = 0.0;
        else
            this.mGainNode.gain.value = 1.0;
    }

    //-------------
    let vsSourceC, fsSourceC;
    if( this.mIs20 )
    {
        vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { outColor = textureLod(t, gl_FragCoord.xy / v.zw, 0.0); }";
    }
    else
    {
        vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; void main() { gl_FragColor = texture2D(t, gl_FragCoord.xy / v.zw, -100.0); }";
    }

    this.mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, function(worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to copy buffers : " + info.mErrorStr);
            else me.mProgramCopy = info;
        });

    let vsSourceD, fsSourceD;
    if( this.mIs20 )
    {
        vsSourceD = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { vec2 uv = gl_FragCoord.xy / v.zw; outColor = texture(t, vec2(uv.x,1.0-uv.y)); }";
    }
    else
    {
        vsSourceD = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; void main() { vec2 uv = gl_FragCoord.xy / v.zw; gl_FragColor = texture2D(t, vec2(uv.x,1.0-uv.y)); }";
    }

    this.mRenderer.CreateShader(vsSourceD, fsSourceD, false, true, function (worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to downscale buffers : " + info.mErrorStr);
            else me.mProgramDownscale = info;
        });


    // set all buffers and cubemaps to null
    for( let i=0; i<this.mMaxBuffers; i++ )
    {
        this.mBuffers[i] = { mTexture: [null, null], 
                             mTarget:  [null, null], 
                             mResolution: [0, 0],
                             mLastRenderDone: 0,
                             mThumbnailRenderTarget: null,
                             mThumbnailTexture: null,
                             mThumbnailBuffer:  null,
                             mThumbnailRes: [0, 0] };
    }

    for( let i=0; i<this.mMaxCubeBuffers; i++ )
    {
        this.mCubeBuffers[i] = { mTexture: [null, null], 
                                mTarget:  [null, null], 
                                mResolution: [0, 0],
                                mLastRenderDone: 0,
                                mThumbnailRenderTarget: null,
                                mThumbnailTexture: null,
                                mThumbnailBuffer:  null,
                                mThumbnailRes: [0, 0] };
    }

    //-------

    let keyboardData = new Uint8Array( 256*3 );
    for (let j=0; j<(256*3); j++ ) { keyboardData[j] = 0; }
    let kayboardTexture = this.mRenderer.CreateTexture( this.mRenderer.TEXTYPE.T2D, 256, 3, this.mRenderer.TEXFMT.C1I8, this.mRenderer.FILTER.NONE, this.mRenderer.TEXWRP.CLAMP, null);
    let keyboardImage = new Image();
    if( callback!==null )
        keyboardImage.src = "/img/keyboard.png"; // don't load PNG if no UI 
    this.mKeyboard = { mData: keyboardData, mTexture: kayboardTexture, mIcon: keyboardImage };

    let iResize = function( xres, yres )
    {
        me.mCanvas.width = xres;
        me.mCanvas.height = yres;
        me.mXres = xres;
        me.mYres = yres;
        me.ResizeBuffers(xres, yres);
        resizeCallback(xres, yres);
    };

    let bestAttemptFallback = function()
    {
        let devicePixelRatio = window.devicePixelRatio || 1;
        let xres = Math.round(me.mCanvas.offsetWidth  * devicePixelRatio) | 0;
        let yres = Math.round(me.mCanvas.offsetHeight * devicePixelRatio) | 0;
        iResize(xres, yres);
    };

    if(!window.ResizeObserver)
    {
        console.log("WARNING: This browser doesn't support ResizeObserver.");
        bestAttemptFallback();
        window.addEventListener("resize", bestAttemptFallback);
    }
    else
    {
        this.mRO = new ResizeObserver( function(entries, observer)
        {
            var entry = entries[0];
            if (!entry['devicePixelContentBoxSize'])
            {
                observer.unobserve(me.mCanvas);
                console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (2)");
                bestAttemptFallback();
                window.addEventListener("resize", bestAttemptFallback);
            }
            else
            {
                let box = entry.devicePixelContentBoxSize[0];
                let xres = box.inlineSize;
                let yres = box.blockSize;
                iResize(xres, yres);
            }
        });
        try
        {
            this.mRO.observe(this.mCanvas, { box: ["device-pixel-content-box"] });
            //this.mRO.observe(this.mCanvas);
        }
        catch (e)
        {
            console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (1)");
            bestAttemptFallback();
            window.addEventListener("resize", bestAttemptFallback);
        }
    }

    this.mCreated = true;
}

Effect.prototype.ResizeCubemapBuffer = function(i, xres, yres )
{
    let oldXres = this.mCubeBuffers[i].mResolution[0];
    let oldYres = this.mCubeBuffers[i].mResolution[1];

    if( this.mCubeBuffers[i].mTexture[0]===null || oldXres !== xres || oldYres !== yres )
    {
        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);
        let target1 = this.mRenderer.CreateRenderTargetCubeMap( texture1, null, false);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target2 = this.mRenderer.CreateRenderTargetCubeMap( texture2, null, false);

        // Store new buffers
        this.mCubeBuffers[i].mTexture = [texture1,texture2], 
        this.mCubeBuffers[i].mTarget =  [target1, target2 ], 
        this.mCubeBuffers[i].mLastRenderDone = 0;
        this.mCubeBuffers[i].mResolution[0] = xres;
        this.mCubeBuffers[i].mResolution[1] = yres;
    }
}

Effect.prototype.ResizeBuffer = function( i, xres, yres, skipIfNotExists )
{
    if( skipIfNotExists && this.mBuffers[i].mTexture[0]===null ) return;

    let oldXres = this.mBuffers[i].mResolution[0];
    let oldYres = this.mBuffers[i].mResolution[1];

    if( oldXres !== xres || oldYres !== yres )
    {
        let needCopy = (this.mBuffers[i].mTexture[0]!==null);

        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[0].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[0].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[1].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[1].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target1 = this.mRenderer.CreateRenderTarget( texture1, null, null, null, null, false);
        let target2 = this.mRenderer.CreateRenderTarget( texture2, null, null, null, null, false);

        if( needCopy )
        {
            let v = [0, 0, Math.min(xres, oldXres), Math.min(yres, oldYres)];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            let vOld = [0, 0, oldXres, oldYres];
            this.mRenderer.SetShaderConstant4FV("v", vOld);

            // Copy old buffers 1 to new buffer
            this.mRenderer.SetRenderTarget(target1);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[0], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Copy old buffers 2 to new buffer
            this.mRenderer.SetRenderTarget(target2);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[1], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Deallocate old memory
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[0]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[0]);
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[1]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[1]);
            //this.mRenderer.DestroyTexture(this.mBuffers[i].thumbnailTexture);
        }

        // Store new buffers
        this.mBuffers[i].mTexture = [texture1,texture2], 
        this.mBuffers[i].mTarget =  [target1, target2 ], 
        this.mBuffers[i].mLastRenderDone = 0;
        this.mBuffers[i].mResolution[0] = xres;
        this.mBuffers[i].mResolution[1] = yres;
    }
}

Effect.prototype.saveScreenshot = function(passid)
{
    let pass = this.mPasses[passid];

    if( pass.mType === "buffer" )
    {
        let bufferID = assetID_to_bufferID( this.mPasses[passid].mOutputs[0] );

        let texture = this.mBuffers[bufferID].mTarget[ this.mBuffers[bufferID].mLastRenderDone ];

        let numComponents = 3;
        let width = texture.mTex0.mXres;
        let height = texture.mTex0.mYres;
        let type = "Float"; // Other options Float, Half, Uint
        let bytes = new Float32Array(width * height * 4 );//numComponents);
        this.mRenderer.GetPixelDataRenderTarget( texture, bytes, width, height );
        let blob = piExportToEXR(width, height, numComponents, type, bytes);

        // Offer download automatically to the user
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "cubemap" )
    {
        let xres = 4096;
        let yres = 2048;
        this.mScreenshotSytem.Allocate( xres, yres );

        let cubeBuffer = this.mCubeBuffers[0];

        let target = this.mScreenshotSytem.GetTarget();
        this.mRenderer.SetRenderTarget( target );

        let program = this.mScreenshotSytem.GetProgram();

        this.mRenderer.AttachShader(program);
        let l1 = this.mRenderer.GetAttribLocation(program, "pos");
        this.mRenderer.SetViewport( [0, 0, xres, yres] );
        this.mRenderer.AttachTextures(1, cubeBuffer.mTexture[ cubeBuffer.mLastRenderDone ], null, null, null);
        this.mRenderer.DrawUnitQuad_XY(l1);
        this.mRenderer.DettachTextures();
        this.mRenderer.SetRenderTarget( null );

        let data = new Float32Array(xres*yres*4);
        this.mRenderer.GetPixelDataRenderTarget( target, data, xres, yres );

        let blob = piExportToEXR(xres, yres, 3, "Float", data );
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "sound" )
    {
        let offset = 0;
        const bits = 16;
        const numChannels = 2;
        let words = new Int16Array(60*pass.mSampleRate*numChannels );

        pass.iRenderSound( new Date(), function(off, data, numSamples)
                                         {
                                            for( let i=0; i<numSamples; i++ )
                                            {
                                                words[offset++] = (data[4*i+0]+256.0*data[4*i+1]) - 32767;
                                                words[offset++] = (data[4*i+2]+256.0*data[4*i+3]) - 32767;
                                            }
                                         }
                                     );

        let blob = piExportToWAV( 60*pass.mSampleRate, pass.mSampleRate, bits, numChannels, words);

        piTriggerDownload("sound.wav", blob);
    }    
}

Effect.prototype.ResizeBuffers = function(xres, yres)
{
    for (let i=0; i<this.mMaxBuffers; i++ )
    {
        this.ResizeBuffer(i, xres, yres, true);
    }
}

Effect.prototype.IsEnabledVR = function ()
{
    if (this.mRenderingStereo) return true;
    return false;
}

Effect.prototype.EnableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( this.mRenderingStereo ) return;

    this.mRenderingStereo = true;
    this.mWebVR.Enable();
}

Effect.prototype.DisableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( !this.mRenderingStereo ) return;

    this.mRenderingStereo = false;
    this.mWebVR.Disable();
}

Effect.prototype.GetTexture = function( passid, slot ) { return this.mPasses[passid].GetTexture( slot ); }
Effect.prototype.NewTexture = function (passid, slot, url) { return this.mPasses[passid].NewTexture( this.mAudioContext, slot, url, this.mBuffers, this.mCubeBuffers, this.mKeyboard ); }
Effect.prototype.SetOutputs = function( passid, slot, url ) { this.mPasses[passid].SetOutputs( slot, url ); }
Effect.prototype.SetOutputsByBufferID = function( passid, slot, id ) { this.mPasses[passid].SetOutputsByBufferID( slot, id ); }
Effect.prototype.GetAcceptsLinear = function (passid, slot) { return this.mPasses[passid].GetAcceptsLinear(slot); }
Effect.prototype.GetAcceptsMipmapping = function (passid, slot) { return this.mPasses[passid].GetAcceptsMipmapping(slot); }
Effect.prototype.GetAcceptsWrapRepeat = function (passid, slot) { return this.mPasses[passid].GetAcceptsWrapRepeat(slot); }
Effect.prototype.GetAcceptsVFlip = function (passid, slot) { return this.mPasses[passid].GetAcceptsVFlip(slot); }
Effect.prototype.SetSamplerFilter = function (passid, slot, str) { this.mPasses[passid].SetSamplerFilter(slot, str, this.mBuffers, this.mCubeBuffers); }
Effect.prototype.GetTranslatedShaderSource = function (passid) { return this.mPasses[passid].GetTranslatedShaderSource(); }
Effect.prototype.GetSamplerFilter = function (passid, slot) { return this.mPasses[passid].GetSamplerFilter(slot); }
Effect.prototype.SetSamplerWrap = function (passid, slot, str) { this.mPasses[passid].SetSamplerWrap(slot, str, this.mBuffers); }
Effect.prototype.GetSamplerWrap = function (passid, slot) { return this.mPasses[passid].GetSamplerWrap(slot); }
Effect.prototype.SetSamplerVFlip = function (passid, slot, str) { this.mPasses[passid].SetSamplerVFlip(slot, str); }
Effect.prototype.GetSamplerVFlip = function (passid, slot) { return this.mPasses[passid].GetSamplerVFlip(slot); }

Effect.prototype.GetHeaderSize = function (passid)
{
    return this.mPasses[passid].mHeaderLength + 
           this.mRenderer.GetShaderHeaderLines(1);
}

Effect.prototype.ToggleVolume = function()
{
    this.mForceMuted = !this.mForceMuted;

    // outp
    if (this.mForceMuted)
        this.mGainNode.gain.value = 0.0;
    else
        this.mGainNode.gain.value = 1.0;

    // inp
    let num = this.mPasses.length;
    for( let j=0; j<num; j++ )
    {
        for( let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            if( this.mForceMuted )
                this.mPasses[j].MuteInput( this.mAudioContext, i );
            else
                this.mPasses[j].UnMuteInput( this.mAudioContext, i );
        }
    }

    return this.mForceMuted;
}

Effect.prototype.SetKeyDown = function( passid, k )
{
    if( this.mKeyboard.mData[ k + 0*256 ] == 255 ) return;

    this.mKeyboard.mData[ k + 0*256 ] = 255;
    this.mKeyboard.mData[ k + 1*256 ] = 255;
    this.mKeyboard.mData[ k + 2*256 ] = 255 - this.mKeyboard.mData[ k + 2*256 ];
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }
}

Effect.prototype.SetKeyUp = function( passid, k )
{
    this.mKeyboard.mData[ k + 0*256 ] = 0;
    this.mKeyboard.mData[ k + 1*256 ] = 0;
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }
}

Effect.prototype.StopOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].StopOutput( wa );
    }
}

Effect.prototype.ResumeOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].ResumeOutput( wa );
    }
}

Effect.prototype.PauseInput = function( passid, id )
{
    return this.mPasses[passid].TooglePauseInput( this.mAudioContext, id );
}

Effect.prototype.ToggleMuteInput = function( passid, id )
{
    return this.mPasses[passid].ToggleMuteInput( this.mAudioContext, id );
}

Effect.prototype.RewindInput = function( passid, id )
{
    this.mPasses[passid].RewindInput( this.mAudioContext, id );
}

Effect.prototype.UpdateInputs = function( passid, forceUpdate )
{
   this.mPasses[passid].UpdateInputs( this.mAudioContext, forceUpdate, this.mKeyboard );
}

Effect.prototype.ResetTime = function()
{
    this.mFrame = 0;
    this.mAudioContext.resume()

    let num = this.mPasses.length;
    for( let i=0; i<num; i++ )
    {
        this.mPasses[i].mFrame = 0;
        for( let j=0; j<this.mPasses[i].mInputs.length; j++ )
            this.mPasses[i].RewindInput(this.mAudioContext, j)
    }
}

Effect.prototype.RequestAnimationFrame = function (id)
{
    if (this.mRenderingStereo && this.mWebVR.IsPresenting())
    {
        this.mWebVR.RequestAnimationFrame(id);
    }
    else
    {
        requestAnimFrame(id);
    }
}

Effect.prototype.Paint = function(time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, isPaused)
{
    let wa = this.mAudioContext;
    let da = new Date();
    let vrData = null; if (this.mRenderingStereo) vrData = this.mWebVR.GetData();
    let xres = this.mXres / 1;
    let yres = this.mYres / 1;

    if( this.mFrame===0 )
    {
        for( let i=0; i<this.mMaxBuffers; i++ )
        {
            if( this.mBuffers[i].mTexture[0]!==null )
            {
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[0] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[1] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
				
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[0] );
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[1] );
            }
        }
        for( let i=0; i<this.mMaxCubeBuffers; i++ )
        {
            if( this.mCubeBuffers[i].mTexture[0]!==null )
            {
                for( let face=0; face<6; face++ )
                {
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[0], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[1], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
					this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[0] );
				    this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[1] );
                }
            }
        }
    }

    let num = this.mPasses.length;

    // render sound first
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "sound" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "buffer" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;
        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="buffer" && inp.id === bufferID && inp.mInfo.mSampler.filter === "mipmap")
                {
                    needMipMaps = true;
                    break;
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render cubemap buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "cubemap" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = 0;//assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;

        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="cubemap" )
                {
                    if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0 && inp.mInfo.mSampler.filter === "mipmap" )
                    {
                        needMipMaps = true;
                        break;
                    }
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render image last
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "image" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }   

    // erase keypresses
    for (let k=0; k<256; k++ )
    {
       this.mKeyboard.mData[ k + 1*256 ] = 0;
    }
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    if( this.mRenderingStereo ) this.mWebVR.Finish();

    this.mFrame++;
}

Effect.prototype.NewShader = function( passid, preventCache, onResolve )
{
    let commonSourceCodes = [];
    for (let i=0; i<this.mPasses.length; i++ )
    {
        if( this.mPasses[i].mType==="common")
        {
            commonSourceCodes.push(this.mPasses[i].mSource);
        }
    }

    this.mPasses[passid].NewShader(commonSourceCodes, preventCache, onResolve );
}

Effect.prototype.GetNumPasses = function()
{
    return this.mPasses.length;
}

Effect.prototype.GetNumOfType = function(passtype)
{
    let id = 0;
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType===passtype )
        {
            id++;
        }
    }
    return id;
}

Effect.prototype.GetPassType = function( id ) { return this.mPasses[id].mType; }
Effect.prototype.GetPassName = function( id ) { return this.mPasses[id].mName; }
Effect.prototype.GetCode = function( id ) { return this.mPasses[id].mSource; }
Effect.prototype.SetCode = function( id, source ) { this.mPasses[id].SetCode(source); }
Effect.prototype.GetError = function (id) { return this.mPasses[id].mError; }
Effect.prototype.GetErrorStr = function (id) { return this.mPasses[id].mErrorStr; }
Effect.prototype.GetErrorGlobal = function()
{
    for (let i = 0; i < this.mPasses.length; i++)
    {
        if (this.mPasses[i].mError)
        {
            return true;
        }
    }
    return false;
}

Effect.prototype.Load = function (jobj )
{
    if (jobj.ver !== "0.1")
    {
        console.log("Wrong Format");
        return false;
    }

    let numPasses = jobj.renderpass.length;

    if( numPasses<1 || numPasses>this.mMaxPasses )
    {
        console.log("Corrupted Shader - " + numPasses);
        return false;
    }

    this.mPasses = [];
    for (let j = 0; j < numPasses; j++)
    {
        let rpass = jobj.renderpass[j];

        // skip sound passes if in thumbnail mode
        if( this.mForceMuted && rpass.type === "sound" ) continue;

        let wpass = new EffectPass(this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                   this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode,
                                   this.mProgramDownscale, j, this);

        wpass.Create(rpass.type, this.mAudioContext);

        let numInputs = rpass.inputs.length;

        for (let i = 0; i < 4; i++)
        {
            wpass.NewTexture(this.mAudioContext, i, null, null, null);
        }
        for (let i = 0; i < numInputs; i++)
        {
            let lid  = rpass.inputs[i].channel;
            let styp = rpass.inputs[i].type;
            let sid  = rpass.inputs[i].id;
            let ssrc = rpass.inputs[i].filepath;
            let psrc = rpass.inputs[i].previewfilepath;
            let samp = rpass.inputs[i].sampler;

            wpass.NewTexture(this.mAudioContext, lid, { mType: styp, mID: sid, mSrc: ssrc, mSampler: samp, mPreviewSrc: psrc }, this.mBuffers, this.mCubeBuffers, this.mKeyboard);
        }

        for (let i = 0; i < 4; i++)
        {
            wpass.SetOutputs(i, null);
        }

        let numOutputs = rpass.outputs.length;
        for (let i = 0; i < numOutputs; i++)
        {
            let outputID = rpass.outputs[i].id;
            let outputCH = rpass.outputs[i].channel;
            wpass.SetOutputs(outputCH, outputID);
        }

        // create some hardcoded names. This should come from the DB
        let rpassName = "";
        if (rpass.type === "common" ) rpassName = "Common";
        if (rpass.type === "sound"  ) rpassName = "Sound";
        if (rpass.type === "image"  ) rpassName = "Image";
        if (rpass.type === "buffer") rpassName = "Buffer " + String.fromCharCode(65 + assetID_to_bufferID(wpass.mOutputs[0]));
        if (rpass.type === "cubemap") rpassName = "Cube A";// " + String.fromCharCode(65 + assetID_to_bufferID(this.mPasses[j].mOutputs[0]));
        wpass.SetName(rpassName);
        wpass.SetCode(rpass.code);

        this.mPasses.push(wpass);
    }
    return true;
}

Effect.prototype.CompileSome = function ( passes, preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    for (let j = 0; j < passes.length; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(passes[j], preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < me.mPasses.length; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.Compile = function (preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(j, preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < numPasses; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.GetCompilationTime = function( id )
{
    return this.mPasses[id].GetCompilationTime()/1000.0;
}
Effect.prototype.GetTotalCompilationTime = function()
{
    return this.mCompilationTime/1000.0;
}

Effect.prototype.DestroyPass = function( id )
{
   this.mPasses[id].Destroy( this.mAudioContext );
   this.mPasses.splice(id, 1);
}

Effect.prototype.AddPass = function( passType, passName, onResolve )
{
    let shaderStr = null;

    if( passType==="sound"   ) shaderStr = "vec2 mainSound( int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n}";
    if( passType==="buffer"  ) shaderStr = "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}";
    if( passType==="common"  ) shaderStr = "vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}";
    if( passType==="cubemap" ) shaderStr = "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rayDir;\n\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}";

    let id = this.GetNumPasses();
    this.mPasses[id] = new EffectPass( this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                       this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode, 
                                       this.mProgramDownscale, id, this );

    this.mPasses[id].Create( passType, this.mAudioContext );
    this.mPasses[id].SetName( passName );
    this.mPasses[id].SetCode( shaderStr );
    this.NewShader(id, false, function ()
    {
        onResolve();
    });

    return { mId : id, mShader : shaderStr };
}

// this should be removed once we have MultiPass 2.0 and passes render to arbitrary buffers
Effect.prototype.IsBufferPassUsed = function( bufferID )
{
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType !== "buffer" ) continue;
        if( this.mPasses[j].mOutputs[0] === bufferID_to_assetID(bufferID) ) return true;
    }
    return false;
}

Effect.prototype.Save = function()
{
    var result = {};

    result.ver = "0.1";

    result.renderpass = [];

    let numPasses = this.mPasses.length;
    for (let j=0; j<numPasses; j++ )
    {
        result.renderpass[j] = {};

        result.renderpass[j].outputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            let outputID = this.mPasses[j].mOutputs[i];
            if( outputID===null ) continue;
            result.renderpass[j].outputs.push( { channel: i, id: outputID } );
        }
        result.renderpass[j].inputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            if( this.mPasses[j].mInputs[i]===null ) continue;
            result.renderpass[j].inputs.push( {channel: i,
                                               type    : this.mPasses[j].mInputs[i].mInfo.mType,
                                               id      : this.mPasses[j].mInputs[i].mInfo.mID,
                                               filepath: this.mPasses[j].mInputs[i].mInfo.mSrc,
                                               sampler : this.mPasses[j].mInputs[i].mInfo.mSampler });
        }

        result.renderpass[j].code = this.mPasses[j].mSource;
        result.renderpass[j].name = this.mPasses[j].mName
        result.renderpass[j].description = "";
        result.renderpass[j].type = this.mPasses[j].mType;
    }

    result.flags = this.calcFlags();

    return result;
}

Effect.prototype.calcFlags = function ()
{
    let flagVR = false;
    let flagWebcam = false;
    let flagSoundInput = false;
    let flagSoundOutput = false;
    let flagKeyboard = false;
    let flagMultipass = false;
    let flagMusicStream = false;

    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        let pass = this.mPasses[j];

        if (pass.mType === "sound") flagSoundOutput = true;
        if (pass.mType === "buffer") flagMultipass = true;

        for (let i = 0; i < 4; i++)
        {
            if (pass.mInputs[i] === null) continue;

            if (pass.mInputs[i].mInfo.mType === "webcam") flagWebcam = true;
            else if (pass.mInputs[i].mInfo.mType === "keyboard") flagKeyboard = true;
            else if (pass.mInputs[i].mInfo.mType === "mic") flagSoundInput = true;
            else if (pass.mInputs[i].mInfo.mType === "musicstream") flagMusicStream = true;
        }

        let n1 = pass.mSource.indexOf("mainVR(");
        let n2 = pass.mSource.indexOf("mainVR (");
        if (n1 > 0 || n2 > 0) flagVR = true;
    }

    return {
        mFlagVR: flagVR,
        mFlagWebcam: flagWebcam,
        mFlagSoundInput: flagSoundInput,
        mFlagSoundOutput: flagSoundOutput,
        mFlagKeyboard: flagKeyboard,
        mFlagMultipass: flagMultipass,
        mFlagMusicStream: flagMusicStream
    };
}</script>
    <script>"use strict"

const kMaxCompileTime = 10.0;

function iReportCrash(shaderID)
{
    let req = new XMLHttpRequest();
    req.onload = function ()
    {
        let jsn = req.response;
        if (jsn === null) return;
        if (jsn.result === 0)
        {
            // yep
        }
    };
    req.open("POST", "/shadertoy", true);
    req.responseType = "json";
    req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    req.send( "s=" + shaderID + "&r=2" );
}
</script>
    <script>"use strict"

var gActive = -1;
var mShaders = [];
var gNumCanvases = 0;

function myrefresh( id, slot, img, forceFrame, gui, guiID, renderID, time )
{
    if( mShaders[id].mReady===false ) return;
    if( forceFrame )
    {
        if (mShaders[id].mScreenshot === false)
        {
            mShaders[id].gEffect.Paint(mShaders[id].mTime / 1000.0, 1.0 / 60.0, 60.0, 0, 0, 0, 0, false);
        }
    }
}

function startRendering()
{
    if( gActive<0 ) return;
    if( mShaders[gActive].mReady===false ) return;
    if( mShaders[gActive].mScreenshot===true ) return;

    let time = getRealTime();

    mShaders[gActive].mFPS.Count( time );
    mShaders[gActive].mTime = mShaders[gActive].mTime0 + (time - mShaders[gActive].mTo);
    let dtime = 1000.0/60.0;
    mShaders[gActive].gEffect.Paint( mShaders[gActive].mTime/1000.0, dtime/1000.0, mShaders[gActive].mFPS.GetFPS(), 0,0,0,0, false);

    requestAnimFrame( startRendering );
}

function iLoadAndCompile(jsn, i )
{
    var shaderObj = jsn[i];
    if (shaderObj === null) return;

    var resizeCB = function (xres, yres) { myrefresh(i, 0, null, true, false, 0, -1.0) };
    var crashCB = function () { alert('crash');/*iReportCrash(gShaderIDs[i])*/ };
    mShaders[i].gEffect = new Effect(null, null, mShaders[i].mPreview.mCanvas, myrefresh, i, true, true, resizeCB, crashCB);

    if (!mShaders[i].gEffect.Load(shaderObj)) return;

    mShaders[i].gEffect.Compile(false, function (worked)
    {
        if (worked === true)
        {
            previewShowRender(mShaders[i].mPreview);

            mShaders[i].mScreenshot = false;
            mShaders[i].mReady = true;
            mShaders[i].mTime = 10.0 * 1000.0;
            mShaders[i].mTime0 = 0.0;
            mShaders[i].mTo = 0.0;
            mShaders[i].mFPS = piCreateFPSCounter();
            mShaders[i].mPreview.mCanvas.addEventListener("mouseout", function (ev) { gActive = -1; }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseover", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.add('isVisible'); }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseout", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.remove('isVisible'); }, true);
            mShaders[i].mPreview.mCanvas.addEventListener("mouseover", function (ev)
            {
                let ele = piGetSourceElement(ev);
                if (ele.mId === undefined) return;

                gActive = ele.mId;
                if (!mShaders[gActive].mReady) return;
                let time = getRealTime();
                mShaders[gActive].mTo = time;
                mShaders[gActive].mTime0 = mShaders[gActive].mTime;
                mShaders[gActive].mFPS.Reset(time);

                startRendering();
            }, true);


            /*
            let compilationTime = mShaders[i].gEffect.GetTotalCompilationTime();
            if (compilationTime > kMaxCompileTime)
            {
                iReportCrash(mShaders[i].mShaderID);
            }*/

            myrefresh(i, null, null, true, false, 0, -1.0);
        }
        else
        {
            mShaders[i].mReady = false;
            previewShowError(mShaders[i].mPreview);
        }
    });
};


function iProcessShader( jsn, i )
{
    var shaderObj = jsn[i];
    if( shaderObj===null ) return;

    if ((shaderObj.info.usePreview === 0 && !gUseScreenshots) || (mShaders[i].mPreviewReady !== 1))
    {
        iLoadAndCompile(jsn, i);
    }
    else
    {
        mShaders[i].mScreenshot = true;
        if( shaderObj.info.usePreview === 1 )
            previewShowScreenshot(mShaders[i].mPreview, 1); // comp
        else if (gUseScreenshots)
            previewShowScreenshot(mShaders[i].mPreview, 2); // sett
    }

    if( i<(jsn.length-1) ) setTimeout( function(){iProcessShader(jsn,i+1);}, 10 );
}

function iInitUI(numCanvases, uiCallback, windowTitle)
{
    gNumCanvases = numCanvases;
    document.getElementById("mySearch").focus();

    //-----------------------------------------------------------------
    // window
    //-----------------------------------------------------------------
    if (windowTitle !== null) {
        document.title = windowTitle;
    }

    //-----------------------------------------------------------------
    // ui
    //-----------------------------------------------------------------
    var num = Math.min(gShaders.length, gNumCanvases);

    //var base = document.getElementsByClassName( "searchResult" );

    for (let i = 0; i < gNumCanvases; i++)
    {
        let pv = createPreview(i);

        if (i >= num) {
            previewHide(pv);
            continue;
        }

        let shaderID = gShaders[i].info.id;
        
        if (pv.mUI !== null && uiCallback !== null) {
            pv.mUI.addEventListener('click', function (ev) {
                uiCallback(shaderID);
                ev.preventDefault();
            }, false);
        }
        
        previewShowLoading(pv);
        
        mShaders[i] = {};
        mShaders[i].mShaderID = shaderID;
        mShaders[i].mPreview = pv;
        mShaders[i].mScreenshot = false;
        mShaders[i].mPreview.mLink.href = "/view/" + shaderID;
        mShaders[i].mPreviewReady = 0;
        mShaders[i].mReady = false;
        mShaders[i].gEffect = null;

        previewLoadScreenshot(mShaders[i].mPreview,
            function () { mShaders[i].mPreviewReady = 1; if (mShaders[i].mReady === false) previewShowScreenshot(mShaders[i].mPreview, 0); },
            function () { mShaders[i].mPreviewReady = 2; },
            shaderID);
    }

    if (num <= 0) {
        return;
    }
}

function iInitShaders(jsn)
{
    for (let i = 0; i < jsn.length; i++)
    {
        let shaderObj = jsn[i];
        if (shaderObj === null) continue;
        let inf = shaderObj.info;
        mShaders[i].mPreview.mTextA.textContent = inf.name;
        mShaders[i].mPreview.mTextB.innerHTML = "<a class='user' href='/user/" + htmlEntities(inf.username) + "'>" + htmlEntities(inf.username) + "</a>";
        mShaders[i].mPreview.mTextC.innerHTML = "<img src='/img/themes/" + gThemeName + "/views.png' class='viewsIcon'></img>" + inf.viewed + "    &nbsp;&nbsp;  <img src='/img/themes/" + gThemeName + "/likes.png' class='likesIcon'></img>" + inf.likes;
    }

    setTimeout(function () { iProcessShader(jsn, 0); }, 10);
}

function resultsInitStatic(numCanvases, uiCallback, windowTitle)
{
    iInitUI(numCanvases, uiCallback, windowTitle);

    iInitShaders(gShaders);
}

function resultsInit(numCanvases, uiCallback, windowTitle)
{	
    iInitUI(numCanvases, uiCallback, windowTitle);

    var num = Math.min(gShaderIDs.length, gNumCanvases);

    var mHttpReq = new XMLHttpRequest();

    mHttpReq.abort();

    var str = "{ \"shaders\" : [";
    for( let i=0; i<num; i++ )
    {
         str += "\"" + gShaderIDs[i] + "\"";
         if( i!==(num-1) ) str += ", ";
    }
    str += "] }";

    str = "s=" + encodeURIComponent( str ) + "&nt=0&nl=0&np=0";

    mHttpReq.open( "POST", "/shadertoy", true );
    mHttpReq.responseType = "json";
    mHttpReq.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    mHttpReq.onload = function ()
    {
        let jsn = this.response;
        if( jsn===null )
        {
            console.log( "Could not load shaders" );
            return;
        }

        iInitShaders(jsn);
    }
    mHttpReq.send( str );
}</script>
    <style>
    .shaderPreview
    {
    display: block;
    background-color: #000000;
    background-image: url("/img/loading.gif");
    background-repeat: no-repeat;
    background-position: center;
    padding: 0px;
    margin: 0px;
    border: 0px solid #000000;
    border-radius: 8px;
    width:100%;
    height:100%;
    position: absolute;
    overflow:hidden;
    }

    .previewInfo
    {
    width: 100%;
    left: 0px;
    top: 2px;
    position: relative;
    visibility: hidden;
    }

    .previewCanvas
    {
    left: 0px;
    top: 0px;
    padding: 0px;
    margin: 0px;
    position: absolute;
    cursor: pointer;
    width:100%;
    height:100%;
    border-radius: 8px;
    border: 0px solid #000000;
    backgroundColor: transparent;
visibility: hidden;
opacity:0;
transition: opacity 1.0s ease;
    }

    .previewText
    {
        text-overflow: ellipsis;
    white-space: nowrap;
    padding-right: 1px;
    }

    .previewTextUser
    {
    text-overflow: ellipsis;
    white-space: nowrap;
    padding-left: 3px;
    }

    .previewStats
    {
    padding-right: 1px;
    right: 0px;
    top: 0px;
    position: absolute;
    }

    .previewErrorContainer
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    visibility:hidden;
    }

    .previewErrorMessage
    {
    top:50%;
    position:absolute;
    width:100%;
    text-align:center;
    padding:0;
    margin:auto;
    color:#ff0000;
    font-size:2em;
    font-style:italic;
    }

    .previewNoGLContainter
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    position:absolute;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    pointer-events:none;
    visibility:hidden;
    font-size:2em;
    }

    .previewNoGLMessage
    {
    width:86%;
    height:90%;
    padding-left:7%;
    padding-right:7%;
    padding-top:10%;
    padding-bottom:0px;
    color:#ff0000;
    position:absolute;
    visibility:hidden;
    }

    .previewThumbnailContainer
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    visibility:hidden;
    border-radius:8px;
    border:0px solid #000000;
    }

    .previewThumbnailImage
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    border-radius:8px;
    border:0px solid #000000;
opacity: 0.0;
transition: opacity 1.0s ease;
    }

    .previewThumbnailIcon
    {
    width:64px;
    height:32px;
    left:0px;
    top:0px;
    padding:0px;
    padding-top:12px;
    margin:0px;
    position:absolute;
    color:#ffffff;
    background-color:#ff8020;
    font-weight:bold;
    border-radius:0px 0px 8px 0px;
    text-align:center;
    //visibility:hidden;
    }


    .previewUIContainter
    {
    display: block;
    right:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    //cursor:pointer;
    //pointer-events:none;
    //visibility:hidden;
    }
</style>

<script>
    function previewHide(me)
    {
    me.mBase.style.visibility = "hidden";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";
    }

    function previewShowRender(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "visible";
me.mCanvas.style.opacity = 1.0;
    me.mCanvas.style.borderRadius ="8px;";
//  me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    }

    function previewShowScreenshot(me, message)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "visible";
me.mThumbnailImg.style.opacity = 1.0;
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    me.mThumbnailWar1.style.visibility = (message===1)?"visible":"hidden";
    me.mThumbnailWar2.style.visibility = (message===2)?"visible":"hidden";
    }

    function previewShowLoading(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";

    me.mLink.style.visibility = "visible";
    me.mBase.style.backgroundColor = "#ff0000;"
    me.mCont.style.visibility = "visible";
    }

    function previewShowNoWebGL(me, shaderID)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "visible";
    me.mError.style.visibility = "visible";
    me.mThumbnailImgNoWebGL.onerror = function(ev) 
                                      { 
                                            me.mThumbnailImgNoWebGL.style.visibility="hidden"; 
                                            me.mMessageNoWebGL.style.visibility="visible"; 
                                      };
    me.mThumbnailImgNoWebGL.src = "/media/shaders/" + shaderID + ".jpg";
    }

    function previewShowError(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "visible";
    me.mCont.style.visibility = "visible";
    }

    function previewLoadScreenshot( me, cbSuccess, cbError, shaderID )
    {
    var url = "/media/shaders/" + shaderID + ".jpg";
    me.mThumbnailImg.onload = cbSuccess;
    me.mThumbnailImg.onerror = function(ev) { cbError(); };
    me.mThumbnailImg.src = url;
    }
        
    function createPreview(id)
    {
        var bar = document.getElementById( "Preview_"+id+"_Canvas" );
        bar.width = bar.offsetWidth;
        bar.height = bar.offsetHeight;
        bar.mId = id;

        return { mBase: document.getElementById( "Preview_"+id+"_Container" ),
        mLink: document.getElementById( "Preview_"+id+"_Link" ),
        mCanvas: bar,
        mCont: document.getElementById( "Preview_"+id+"_Info" ),
        mTextA: document.getElementById( "Preview_"+id+"_Text" ),
        mTextB: document.getElementById( "Preview_"+id+"_TextUser" ),
        mTextC: document.getElementById( "Preview_"+id+"_Stats" ),
        mNoWebGL: document.getElementById( "Preview_"+id+"_NoWebGL" ),
        mError: document.getElementById( "Preview_"+id+"_Error" ),
        mCanvas2D: document.getElementById( "Preview_"+id+"_Thumnail" ),
        mThumbnailImg: document.getElementById( "Preview_"+id+"_ThumnailImage" ),
        mThumbnailWar1: document.getElementById( "Preview_"+id+"_ThumnailWarning1" ),
        mThumbnailWar2: document.getElementById( "Preview_"+id+"_ThumnailWarning2" ),
        mThumbnailImgNoWebGL: document.getElementById( "Preview_"+id+"_ThumnailImageNoWebGL" ),
        mMessageNoWebGL: document.getElementById( "Preview_"+id+"_MessageNoWebGL"),
        mUI: document.getElementById( "Preview_"+id+"_UI" )
        };
    }
</script>

    <style>

    div#shaderGrid
    {
        width:100%;
        padding:0px;
        margin:0px;
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        grid-template-rows: repeat(3, 1fr);
        grid-column-gap: 64px;
        grid-row-gap: 24px;
    }
    .searchResult
    {
        margin: 0px;
        padding: 0px;
        width: 100%;
    }
    .searchResultContainer
    {
        width: 100%;
        padding-bottom:56.25%;
        height: 0;
        position: relative;
    }
    .navigation
    {
        display:flex;
        align-items:center;
    }
    div#navBottom
    {
        display:none;
        justify-content:center;
    }
    a.pageButtons, .pageButtonsCurrent
    {
        border-style: solid;
        border-width: 1px;
        border-color: #808080;
        text-align: center;
        vertical-align: middle;
        margin-left: 12px;
        display: inline-block;
        border-radius: 4px;
		font-weight:bold;
        cursor: pointer;
        padding-bottom:5px;
        padding-top:4px;
        padding-left: 8px;
        padding-right: 8px;
        margin:8px;
    }
    a.pageButtons
    {
        text-decoration: none;
        -moz-transition:    background-color 0.15s linear, color 0.15s linear;
        -webkit-transition: background-color 0.15s linear, color 0.15s linear;
        transition:         background-color 0.15s linear, color 0.15s linear;
    }
    a.pageButtons:hover
    {
      background-color:#808080;
      color : #ff8020;
    }
    .pageButtonsCurrent
    {
        background-color: #808080;
        color:#000000;
    }
    div#controls
    {
        width:100%;
        padding-top:16px;
        padding-bottom:16px;
        display:flex;
        justify-content:space-between; 
        flex-wrap:wrap;
    }
    div#controls > div
    {
        display:inline-flex;
    }
    .controlOptions
    {
        display:inline-block;
    }

    /* ----------------------- media resolutions ------------------------ */

    @media screen and (max-width:799px) 
    {
        div#shaderGrid  { grid-template-columns: 1fr; grid-template-rows: repeat(12, 1fr); grid-column-gap: 0px; grid-row-gap: 16px; }
        div#controls
        {
            width:100%;
            display:flex;
            justify-content:flex-start; 
            flex-wrap:wrap;
        }
        div#controls > div
        {
            display:inline-flex;
            width:100%;
            margin-left: 0px;
            margin-right: 0px;
            padding-bottom:16px;
        }
        div#navBottom
        {
            display: flex;
        }
    }
    
    </style>
    <script>
    var gShaders=[{"ver":"0.1","info":{"id":"MtfGR4","date":"1419015939","viewed":7194,"name":"Bidirectional path tracing","username":"reinder","description":"Yesterday, I found out about bidirectional path tracing. I didn't read the articles, but looked at the images and I tried to implement something myself. Therefore, I think most of the math will be incorrect - but it looks nice. Only diffuse lighting.","likes":42,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Bidirectional path tracing. Created by Reinder Nijhoff 2014\n\/\/ Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n\/\/ @reindernijhoff\n\/\/\n\/\/ https:\/\/www.shadertoy.com\/view\/MtfGR4\n\/\/\n\n#define eps 0.0001\n#define LIGHTPATHLENGTH 2\n#define EYEPATHLENGTH 3\n#define MAXPATHLENGTH 4\n#define SAMPLES 12\n\n#define FULLBOX\n\n#define DOF\n#define ANIMATENOISE\n#define MOTIONBLUR\n\n#define MOTIONBLURFPS 12.\n\n#define LIGHTCOLOR vec3(16.86, 10.76, 8.2)*1.3\n#define WHITECOLOR vec3(.7295, .7355, .729)*0.7\n#define GREENCOLOR vec3(.117, .4125, .115)*0.7\n#define REDCOLOR vec3(.611, .0555, .062)*0.7\n\nstruct LightPathNode {\n    vec3 color;\n    vec3 position;\n    vec3 normal;\n};\n    \n\nfloat hash1(inout float seed) {\n    return fract(sin(seed += 0.1)*43758.5453123);\n}\n\nvec2 hash2(inout float seed) {\n    return fract(sin(vec2(seed+=0.1,seed+=0.1))*vec2(43758.5453123,22578.1459123));\n}\n\nvec3 hash3(inout float seed) {\n    return fract(sin(vec3(seed+=0.1,seed+=0.1,seed+=0.1))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\n\/\/-----------------------------------------------------\n\/\/ Intersection functions (by iq)\n\/\/-----------------------------------------------------\n\nvec3 nSphere( in vec3 pos, in vec4 sph ) {\n    return (pos-sph.xyz)\/sph.w;\n}\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph ) {\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\nvec3 nPlane( in vec3 ro, in vec4 obj ) {\n    return obj.xyz;\n}\n\nfloat iPlane( in vec3 ro, in vec3 rd, in vec4 pla ) {\n    return (-pla.w - dot(pla.xyz,ro)) \/ dot( pla.xyz, rd );\n}\n\n\/\/-----------------------------------------------------\n\/\/ scene\n\/\/-----------------------------------------------------\n\nvec3 cosWeightedRandomHemisphereDirection( const vec3 n, inout float seed ) {\n  \tvec2 rv2 = hash2(seed);\n    \n\tvec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );\n\tvec3  vv = normalize( cross( uu, n ) );\n\t\n\tfloat ra = sqrt(rv2.y);\n\tfloat rx = ra*cos(6.2831*rv2.x); \n\tfloat ry = ra*sin(6.2831*rv2.x);\n\tfloat rz = sqrt( 1.0-rv2.y );\n\tvec3  rr = vec3( rx*uu + ry*vv + rz*n );\n    \n    return normalize( rr );\n}\n\nvec3 randomSphereDirection(inout float seed) {\n    vec2 h = hash2(seed) * vec2(2.,6.28318530718)-vec2(1,0);\n    float phi = h.y;\n\treturn vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\n}\n\nvec3 randomHemisphereDirection( const vec3 n, inout float seed ) {\n\tvec3 dr = randomSphereDirection(seed);\n\treturn dot(dr,n) * dr;\n}\n\n\/\/-----------------------------------------------------\n\/\/ renderer\n\/\/-----------------------------------------------------\n\nvec4 lightSphere;\nLightPathNode lpNodes[LIGHTPATHLENGTH];\n\nvoid initLightSphere( float time ) {\n\tlightSphere = vec4( 3.0+2.*sin(time),2.8+2.*sin(time*0.9),3.0+4.*cos(time*0.7),0.5);\n}\n\nvec2 intersect( in vec3 ro, in vec3 rd, inout vec3 normal ) {\n\tvec2 res = vec2( 1e20, -1.0 );\n    float t;\n\t\n\tt = iPlane( ro, rd, vec4( 0.0, 1.0, 0.0,0.0 ) ); if( t>eps && t<res.x ) { res = vec2( t, 0. ); normal = vec3( 0., 1., 0.); }\n\tt = iPlane( ro, rd, vec4( 0.0, 0.0,-1.0,8.0 ) ); if( t>eps && t<res.x ) { res = vec2( t, 0. ); normal = vec3( 0., 0.,-1.); }\n    t = iPlane( ro, rd, vec4( 1.0, 0.0, 0.0,0.0 ) ); if( t>eps && t<res.x ) { res = vec2( t, 2. ); normal = vec3( 1., 0., 0.); }\n#ifdef FULLBOX\n    t = iPlane( ro, rd, vec4( 0.0,-1.0, 0.0,5.49) ); if( t>eps && t<res.x ) { res = vec2( t, 0. ); normal = vec3( 0., -1., 0.); }\n    t = iPlane( ro, rd, vec4(-1.0, 0.0, 0.0,5.59) ); if( t>eps && t<res.x ) { res = vec2( t, 1. ); normal = vec3(-1., 0., 0.); }\n#endif\n\n\tt = iSphere( ro, rd, vec4( 1.5,1.0, 2.7, 1.0) ); if( t>eps && t<res.x ) { res = vec2( t, 0. ); normal = nSphere( ro+t*rd, vec4( 1.5,1.0, 2.7,1.0) ); }\n    t = iSphere( ro, rd, vec4( 4.0,1.0, 4.0, 1.0) ); if( t>eps && t<res.x ) { res = vec2( t, 2. ); normal = nSphere( ro+t*rd, vec4( 4.0,1.0, 4.0,1.0) ); }\n    t = iSphere( ro, rd, lightSphere ); if( t>eps && t<res.x ) { res = vec2( t, 4.0 );  normal = nSphere( ro+t*rd, lightSphere ); }\n\t\t\t\t\t  \n    return res;\t\t\t\t\t  \n}\n\nbool intersectShadow( in vec3 ro, in vec3 rd, in float dist ) {\n    float t;\n\t\n\tt = iSphere( ro, rd, vec4( 1.5,1.0, 2.7,1.0) );  if( t>eps && t<dist ) { return true; }\n    t = iSphere( ro, rd, vec4( 4.0,1.0, 4.0,1.0) );  if( t>eps && t<dist ) { return true; }\n\n    return false; \/\/ optimisation: planes don't cast shadows in this scene\n}\n\nvec3 calcColor( in float mat ) {\n\tvec3 nor = vec3(0.0);\n\t\n\tif( mat<4.5 ) nor = LIGHTCOLOR;\n\tif( mat<3.5 ) nor = WHITECOLOR;\n    if( mat<2.5 ) nor = GREENCOLOR;\n\tif( mat<1.5 ) nor = REDCOLOR;\n\tif( mat<0.5 ) nor = WHITECOLOR;\n\t\t\t\t\t  \n    return nor;\t\t\t\t\t  \n}\n\n\/\/-----------------------------------------------------\n\/\/ lightpath\n\/\/-----------------------------------------------------\n\nvoid constructLightPath(inout float seed) {\n    vec3 ro = normalize( hash3(seed)-vec3(0.5) );\n    vec3 rd = randomHemisphereDirection( ro, seed );\n    ro = lightSphere.xyz + ro*0.5;\n    vec3 color = LIGHTCOLOR;\n    \n    lpNodes[0].position = ro;\n    lpNodes[0].color = color;\n    lpNodes[0].normal = rd;\n    \n    for( int i=1; i<LIGHTPATHLENGTH; ++i ) {\n        lpNodes[i].position = lpNodes[i].color = lpNodes[i].normal = vec3(0.);\n    }\n    \n    for( int i=1; i<LIGHTPATHLENGTH; i++ ) {\n\t\tvec3 normal;\n        vec2 res = intersect( ro, rd, normal );\n        if( res.y > -0.5 && res.y < 4. ) {\n            ro = ro + rd*res.x;\n            color *= calcColor( res.y );\n            lpNodes[i].position = ro;\n            lpNodes[i].color = color;\n            lpNodes[i].normal = normal;\n\n            rd = cosWeightedRandomHemisphereDirection( normal, seed );\n        } else break;\n    }\n}\n\n\/\/-----------------------------------------------------\n\/\/ eyepath\n\/\/-----------------------------------------------------\n\nvec3 traceEyePath( in vec3 ro, in vec3 rd, inout float seed ) {\n    vec3 col = vec3(0.);\n    vec3 basecol = vec3(1.);\n    \n    for( int j=0; j<EYEPATHLENGTH; ++j ) {\n        vec3 normal;\n        \n        vec2 res = intersect( ro, rd, normal );\n        if( res.y < -0.5 ) return col;\n        if( res.y > 3.5 ) {\n            return col + basecol*LIGHTCOLOR \/ float( j+1 ); \n        }\n        \n        ro = ro + res.x * rd;\n        rd = cosWeightedRandomHemisphereDirection( normal, seed );\n        \n        basecol *= calcColor( res.y );\n        \n\t    for( int i=0; i<LIGHTPATHLENGTH; ++i ) {\n            if( i+j >= MAXPATHLENGTH ) continue;\n            \n            vec3 lp = lpNodes[i].position - ro;\n            vec3 lpn = normalize( lp );\n            vec3 lc = lpNodes[i].color;\n            \n            if( !intersectShadow(ro, lpn, length(lp)-eps) ) {\n                col += clamp( dot( lpn, normal ), 0., 1.) * lc * basecol\n                    * clamp(  dot( lpNodes[i].normal, -lpn ), 0., 1.)\n                    * clamp( 1.\/dot(lp,lp), 0., 1. )\n                    \/ float( i+j+1 );\n            }\n        }\n    }    \n    return col;\n}\n\n\/\/-----------------------------------------------------\n\/\/ main\n\/\/-----------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 q = fragCoord.xy \/ iResolution.xy;\n    \n    \/\/-----------------------------------------------------\n    \/\/ camera\n    \/\/-----------------------------------------------------\n\n    vec2 p = -1.0 + 2.0 * (fragCoord.xy) \/ iResolution.xy;\n    p.x *= iResolution.x\/iResolution.y;\n\n#ifdef ANIMATENOISE\n    float seed = p.x + fract(p.y * 18753.43121412313) + fract(12.12345314312*iTime);\n#else\n    float seed = p.x + fract(p.y * 18753.43121412313);\n#endif\n    \n    vec3 ro = vec3(2.78, 2.73, -8.00);\n    vec3 ta = vec3(2.78, 2.73,  0.00);\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \/\/-----------------------------------------------------\n    \/\/ render\n    \/\/-----------------------------------------------------\n\n    vec3 col = vec3(0.0);\n    vec3 tot = vec3(0.0);\n    vec3 uvw = vec3(0.0);\n\n    for( int a=0; a<SAMPLES; a++ ) {\n        \n        vec2 rpof = 4.*(hash2(seed)-vec2(0.5)) \/ iResolution.xy;\n\t    vec3 rd = normalize( (p.x+rpof.x)*uu + (p.y+rpof.y)*vv + 3.0*ww );\n        \n#ifdef DOF\n\t    vec3 fp = ro + rd * 12.0;\n   \t\tvec3 rof = ro + (uu*(hash1(seed)-0.5) + vv*(hash1(seed)-0.5))*0.125;\n    \trd = normalize( fp - rof );\n#else\n        vec3 rof = ro;\n#endif        \n        \n#ifdef MOTIONBLUR\n        initLightSphere( iTime + hash1(seed) \/ MOTIONBLURFPS );\n#else\n        initLightSphere( iTime );        \n#endif\n        \n        constructLightPath(seed);\n        col = traceEyePath( rof, rd, seed );\n\n        tot += col;\n        \n        seed = mod( seed*1.1234567893490423, 13. );\n    }\n    \n    tot \/= float(SAMPLES);\n\n\ttot = pow( clamp(tot,0.0,1.0), vec3(0.45) );\n\n    fragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"wljSz1","date":"1565107172","viewed":7194,"name":"Subsurface lattice","username":"noby","description":"Simple distance field with some pseudo-organic shading via half lambert and fake subsurface scattering. Super sampled (4x) so it's a bit slow.\n\n(If the result looks just blue try F5-ing the page a few times, it's a shadertoy bug with the volume textures).","likes":169,"published":1,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XdX3Rr","filepath":"\/media\/a\/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"\/media\/ap\/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"\/media\/a\/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"\/media\/ap\/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"\/media\/a\/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"\/media\/ap\/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BUMPY\n\/\/#define LIGHT_SOURCE\n\/\/#define SPLOTCHES\n\/\/#define HIGH_CONTRAST\n\n#ifdef HIGH_CONTRAST\n#define LIGHT_SOURCE\n#endif\n\nfloat T;\nfloat hash(float x){\n    return fract(sin(x*54265.135165416));\n}\n\n\/\/ by TinyTexel, mentioned at https:\/\/iquilezles.org\/articles\/smin\nfloat smin(float a, float b, float k){\n    float h = max(k-abs(a-b), 0.0)\/k;\n    return min(a, b) - h*h*h*k*(1.0\/6.0);\n}\n\n\/\/ store the matrix globally so the 2D \"normal map\" sticks better\nmat2 R;\nfloat map(vec3 p){\n    \/\/ rotate\n    float r = 3.14159*sin(p.z*0.15)+T*0.25;\n    R = mat2(cos(r), sin(r), -sin(r), cos(r));\n    p.xy *= R;\n    vec3 op = p;\n    \n    \/\/ per-cell random values\n    float h = hash(floor(p.x+p.y+p.z));\n    float h2 = 3.141*hash(floor(-p.x-p.y-p.z));\n    \n    \/\/ bumpy\n    #ifdef BUMPY\n    float f = pow(texture(iChannel2, p*0.1).b,4.0);\n   \tvec3 dd = vec3(sin(p.z*71.), cos(p.x*73.), -cos(p.y*77.))\n               -0.6*vec3(cos(p.y*141.), sin(p.z*143.), -sin(p.x*147.));\n    p = mix(p, p-dd*0.005, f);\n    #endif\n    \n    \/\/ repeat lattice\n    const float a = 1.0;\n    p = mod(p, a)-a*0.5;\n    \n    \/\/ primitives\n    \/\/ center sphere\n    float v = length(p)-(0.02+(0.18*h*(0.6+0.4*sin(3.0*T+h2)) ));\n    \/\/ four connecting cylinders\n    v = smin(v, length(p.xy+0.01*sin(-3.2*T+13.0*op.z))-0.03, 0.2);\n    v = smin(v, length(p.xz+0.01*cos(-4.1*T+11.0*(op.y-op.z)))-0.03, 0.2);\n    v = smin(v, length(p.yz+0.01*sin(-5.0*T-8.0*(op.x-op.z)))-0.03, 0.2);\n    \n    return v;\n}\n\nvec3 normal(vec3 p){\n    mat3 e = mat3(0.001);\n    return normalize(vec3(map(p+e[0]), map(p+e[1]), map(p+e[2])) - map(p));\n}\n\nvec3 march(vec3 o, vec3 dir){\n    vec3 p = o;\n    float e = 0.0;\n    for(int i = 0; i < 100; ++i){\n        float d = 0.5*map(p);\n        e += d;\n        if(d < 0.005 || e > 12.0)\n            break;\n        p += d*dir;\n    }\n    \n    return p;\n}\n\nvec4 subsurface(vec3 o, vec3 dir){\n    vec3 p = o;\n    float e = 0.0;\n    for(int i = 0; i < 7; ++i){\n        float d = map(p);\n        e += -d;\n        if(d > -0.001)\n            break;\n        p -= d*dir;\n    }\n    \n    return vec4(p, e);\n}\n\nfloat G(float dotNV, float k){\n\treturn 1.0\/(dotNV*(1.0f-k)+k);\n}\n\n\/\/ from http:\/\/filmicworlds.com\/blog\/optimizing-ggx-shaders-with-dotlh\/\nfloat ggx(vec3 N, vec3 V, vec3 L, float roughness, float F0){\n\tfloat alpha = roughness*roughness;\n\n\tvec3 H = normalize(V+L);\n\n\tfloat dotNL = clamp(dot(N,L),0.,1.);\n\tfloat dotNV = clamp(dot(N,V),0.,1.);\n\tfloat dotNH = clamp(dot(N,H),0.,1.);\n\tfloat dotLH = clamp(dot(L,H),0.,1.);\n\n\tfloat F, D, vis;\n\n\tfloat alphaSqr = alpha*alpha;\n\tfloat pi = 3.14159;\n\tfloat denom = dotNH * dotNH *(alphaSqr - 1.0) + 1.0;\n\tD = alphaSqr\/(pi * denom * denom);\n\n\tfloat dotLH5 = pow(1.0 - dotLH, 5.0);\n\tF = F0 + (1.0 - F0)*(dotLH5);\n\n\tfloat k = alpha * 0.5;\n\n\treturn dotNL * D * F * G(dotNL,k)*G(dotNV,k);\n}\n\n#ifdef LIGHT_SOURCE\nfloat sphere(vec3 ro, vec3 rd, vec3 pos, float r){\n    vec3 ce = ro-pos;\n    float b = dot(rd, ce);\n    return -b-sqrt(b*b-dot(ce, ce)+r*r);\n}\n#endif\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    vec2 uv = fragCoord\/iResolution.xy;\n    \n    const float tm = 2.0;\n    T = iTime*tm;\n    float ot = T;\n    \n    \/\/ quadratic, increase this if your gpu is gpu enough\n    const int samples = 2;\n    \n    vec3 c = vec3(0);\n    for(int y = 0; y < samples; ++y)\n    for(int x = 0; x < samples; ++x){\n        \/\/ anti-aliasing\n        vec2 p = -1.0 + 2.0 * (uv + (-0.5+(vec2(x, y)\/float(samples)))\/iResolution.xy);\n        p.x *= iResolution.x\/iResolution.y;\n        \n        \/\/ motion blur\n        float r = texelFetch(iChannel0, ivec2(mod(fragCoord*float(samples)+vec2(x,y),1024.)),0).r;\n        T = ot+(tm*r)\/36.0;\n        \n        \/\/ camera setup\n        vec3 cam = vec3(0.1*sin(T*0.51),0.1*cos(T*0.59),T);\n        vec3 l = vec3(0.6*cos(T*0.83),0.6*sin(T*0.79),cam.z+3.0+0.5*sin(0.7*T));\n        \/\/vec3 l = vec3(0.6*cos(T*0.83),0.6*sin(T*0.79),cam.z+3.0);\n    \tvec3 dir = normalize(vec3(p, 2.0)+0.1*vec3(sin(T*0.63),cos(T*0.71),0));\n        \n        \/\/ solve intersection and normal\n    \tvec3 pos = march(cam, dir);\n        vec3 mp = pos;\n        mp.xy *= R;\n        vec3 np = pos+vec3(0,0,-0.08*texture(iChannel1, mp.xy*4.0).r);\n        vec3 n = normalize(mix(normal(np), pow(texture(iChannel2, pos*2.0).xyz, vec3(2)), 0.08));\n        \n        \/\/ shade\n        vec3 ld = normalize(l-pos);\n        vec3 alb = mix((vec3(0.3,0.5,0.9)),\n                       (vec3(0.75,0.9,0.4)),\n                       texture(iChannel2, 0.04*mp).r)*1.25;\n        #ifdef SPLOTCHES\n        float mat = smoothstep(0.1,0.8,pow(texture(iChannel2, 0.14*mp).b, 3.0));\n        alb = mix(alb, vec3(0.9,0.78,0.42), mat);\n        #endif\n        float dif = 0.5+0.5*dot(n, ld);\n        \n        #ifdef SPLOTCHES\n        float spe = ggx(n, -dir, ld, mix(0.3,0.5,mat), mix(0.7,1.0,mat));\n        #else\n        float spe = ggx(n, -dir, ld, 0.3, 0.7);\n        #endif\n        float att = 1.0+pow(distance(l, pos), 2.0);\n        dif \/= att;\n        spe \/= att;\n        \n        \/\/ subsurface scattering\n        vec3 h = normalize(mix(-normal(pos), dir, 0.5));\n        \/\/ sv.zyz contains outgoing position, w contains accumulate distance (path \"tightness\")\n        vec4 sv = subsurface(pos+h*0.02, dir);\n        \/\/ subsurface magic term\n        float sss = max(0.0, 1.0-3.0*sv.w);\n        \/\/ light visibility across the volume\n        float ssha = max(0.0, dot(normal(sv.xyz), normalize(l-sv.xyz)));\n        sss \/= att;\n        ssha \/= att;\n        \n        \/\/ mix reflecting and refracting contributions\n        dif = mix(dif, mix(sss, ssha, 0.2), 0.5);\n        \n        c += alb*dif+0.025*spe;\n        \n        \/\/ draw light source\n        #ifdef LIGHT_SOURCE\n        float vs = max(0.0, sphere(cam, dir, l, 0.03));\n        float occluded = step(distance(cam, l), distance(cam,pos));\n        c += 0.4*vs * occluded;\n        vec3 e = pos - cam;\n        vec3 cp = cam + e * dot(e, l-cam) \/ dot(e, e);\n        c += 1.6*max(0.0, 1.0-pow(distance(cp, l), 0.1)) * (0.5+0.5*occluded);\n        #endif\n    }\n    \n\tfragColor.rgb = c\/float(samples*samples);\n    \n    \/\/ \"color grade\" and gamma\n    fragColor.rgb = mix(vec3(dot(fragColor.rgb, vec3(.2125,.7154,.0721))), fragColor.rgb, 1.4);\n    #ifdef HIGH_CONTRAST\n    fragColor.rgb = smoothstep(0.12, 1.6, fragColor.rgb);\n    #else\n    \/\/ default color grading\n    fragColor.rgb = smoothstep(0.0, 1.25, fragColor.rgb);\n    #endif\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0\/2.2));\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"Msd3DN","date":"1450109165","viewed":7187,"name":"Christmas delivery","username":"iapafoto","description":"Christmas delivery\ninspired by Rocket Science by mu6k (https:\/\/www.shadertoy.com\/view\/ltjGD1)","likes":84,"published":3,"flags":64,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"\/media\/a\/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"\/media\/ap\/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xs2Xz1","filepath":"https:\/\/soundcloud.com\/sounding-divine\/this-is-christmas","previewfilepath":"https:\/\/soundcloud.com\/sounding-divine\/this-is-christmas","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Created by sebastien durand - 2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/-----------------------------------------------------\n\n\/\/ Lightening, essentially based on one of incredible TekF shaders:\n\/\/ https:\/\/www.shadertoy.com\/view\/lslXRj\n\n\/\/ Pupils effect came from lexicobol shader: [famous iq tutorial]\n\/\/ https:\/\/www.shadertoy.com\/view\/XsjXz1\n\n\/\/ Smooth max from cabbibo shader:\n\/\/ https:\/\/www.shadertoy.com\/view\/Ml2XDw\n\n\n\n\/\/-----------------------------------------------------\n\n\/\/ Display distance field in a plane perpendicular to camera crossing pt(0,0,0)\n\n\n\/\/ Change this to improve quality (3 is good)\n\t#define ANTIALIASING 1\n\n#define CLOUD_FAST\n\nfloat g_time;\n\n\/\/ consts\nconst float tau = 6.2831853;\nconst float phi = 1.61803398875;\n\n\/\/ Isosurface Renderer\nconst int g_traceLimit=64;\nconst float g_traceSize=.005;\n\n\/\/ globals\nconst vec3 g_nozePos = vec3(0,-.28+.04,.47+.08);\nconst vec3 g_eyePos = vec3(.14,-.14,.29);\nconst float g_eyeSize = .09;\n\nvec3 g_envBrightness = vec3(.5,.6,.9); \/\/ Global ambiant color\nvec3 g_lightPos, g_deltaPast;\nmat2 ma, mb, mc, g_eyeRot, g_headRotH, rotTime;\n    \nbool g_bHead = true, g_bBody = true;\n\n\n\n\/\/ -----------------------------------------------------------------\n\n\nfloat hash( float n ) { return fract(sin(n)*43758.5453123); }\n\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.-2.*f);\n\tvec2 uv = (p.xy+vec2(37.,17.)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ .5)\/256., -100.).yx;\n\treturn -1.+2.*mix( rg.x, rg.y, f.z );\n}\n\nmat2 matRot(in float a) {\n    float ca = cos(a), sa = sin(a);\n    return mat2(ca,sa,-sa,ca);\n}\n\n\n\/\/ Smooth HSV to RGB conversion \n\/\/ [iq: https:\/\/www.shadertoy.com\/view\/MsS3Wc]\nvec3 hsv2rgb_smooth(float x, float y, float z) {\n    vec3 rgb = clamp( abs(mod(x*6.+vec3(0.,4.,2.),6.)-3.)-1., 0., 1.);\n\trgb = rgb*rgb*(3.-2.*rgb); \/\/ cubic smoothing\t\n\treturn z * mix( vec3(1), rgb, y);\n}\n\n\/\/ Distance from ray to point\nfloat dist(vec3 ro, vec3 rd, vec3 p) {\n\treturn length(cross(p-ro,rd));\n}\n\n\/\/ Intersection ray \/ sphere\nbool intersectSphere(in vec3 ro, in vec3 rd, in vec3 c, in float r, out float t0, out float t1) {\n    ro -= c;\n\tfloat b = dot(rd,ro), d = b*b - dot(ro,ro) + r*r;\n    if (d<0.) return false;\n\tfloat sd = sqrt(d);\n\tt0 = max(0., -b - sd);\n\tt1 = -b + sd;\n\treturn (t1 > 0.);\n}\n\n\n\/\/#ifdef NOISE_SKIN\n\/\/ By Shane -----\n\n\/\/ Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n    n = max((abs(n) - .2)*7., .001); \/\/ n = max(abs(n), 0.001), etc.\n    n \/= (n.x + n.y + n.z );  \n    p*=6.;\n\treturn (textureLod(tex, p.yz, 5.)*n.x + textureLod(tex, p.zx, 5.)*n.y + textureLod(tex, p.xy, 5.)*n.z).xyz;\n}\n\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor){\n    const float eps = 0.001;\n    float ref = (tex3D(tex,  p , nor)).x;                 \n    vec3 grad = vec3( (tex3D(tex, vec3(p.x-eps, p.y, p.z), nor).x)-ref,\n                      (tex3D(tex, vec3(p.x, p.y-eps, p.z), nor).x)-ref,\n                      (tex3D(tex, vec3(p.x, p.y, p.z-eps), nor).x)-ref )\/eps;\n             \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n}\n\n\/\/#endif\n\n\n\/\/ -- Modeling Primitives ---------------------------------------------------\n\nfloat udRoundBox(in vec3 p,in vec3 b, in float r) {\n  return length(max(abs(p)-b,0.0))-r ;\n}\nfloat mBox(vec3 p, vec3 b){\n\treturn max(max(abs(p.x)-b.x,abs(p.y)-b.y),abs(p.z)-b.z);\n}\n\n\nfloat sdCapsule(in vec3 p, in vec3 a, in vec3 b, in float r0, in float r1 ) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)\/dot(ba,ba), 0., 1.);\n    return length( pa - ba*h ) - mix(r0,r1,h);\n}\n\n\/\/ capsule with bump in the middle -> use for neck\nvec2 sdCapsule2(in vec3 p,in vec3 a,in vec3 b, in float r0,in float r1,in float bump) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa,ba)\/dot(ba,ba), 0., 1. );\n    float dd = bump*sin(3.14*h);  \/\/ Little adaptation\n    return vec2(length(pa - ba*h) - mix(r0,r1,h)*(1.+dd), 1.); \n}\n\nfloat smin(in float a, in float b, in float k ) {\n    float h = clamp( .5+.5*(b-a)\/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.-h);\n}\n\n\/\/ Smooth max from cabbibo shader:\n\/\/ https:\/\/www.shadertoy.com\/view\/Ml2XDw\nfloat smax(in float a, in float b, in float k) {\n    return log(exp(a\/k)+exp(b\/k))*k;\n}\n\nfloat smax2( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)\/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r) {\n    return (length(p\/r ) - 1.) * min(min(r.x,r.y),r.z);\n}\n\n\n\n\/\/ -- Modeling Head ---------------------------------------------------------\n\nfloat dSkinPart(in vec3 pgeneral, in vec3 p) {\n\n    float d = 1000.;\n   \n\/\/ Skull modeling -------------------------\n    d = sdEllipsoid(p-vec3(0,.05,.0), vec3(.39,.48,.46));\t\n    if (d > .2) return d;\n    \n \/\/   d = smin(d, sdEllipsoid(p-vec3(0.,.1,-.15), vec3(.42,.4,.4)),.1);     \n    d = smin(d, udRoundBox(p-vec3(0,-.28,.2), vec3(.07,.05,.05),.05),.4); \/\/ Basic jaw \n\/\/ Symetrie -------------------------------\n    p.x = abs(p.x);\n\/\/ Eye hole \n    d = smax(d, -sdEllipsoid(p-vec3(.12,-.16,.48), vec3(.09,.06,.09)), .07);\n\n\/\/ Noze ------------------------------------\n    d = smin(d, max(-(length(p-vec3(.032,-.325,.45))-.028),   \/\/ Noze hole\n                    smin(length(p-vec3(.043,-.29,.434))-.01,  \/\/ Nostrils\n                    sdCapsule(p, vec3(0,-.13,.39), vec3(0,-.28,.47), .01,.04), .05)) \/\/ Bridge of the nose\n            ,.065); \n   \n\/\/ Mouth -----------------------------------    \n    d = smin(d, length(p- vec3(.22,-.34,.08)), .17); \/\/ Jaw\n    d = smin(d, sdCapsule(p, vec3(.16,-.35,.2), vec3(-.16,-.35,.2), .06,.06), .15); \/\/ Cheeks\n   \n    d = smin(d, max(-length(p.xz-vec2(0,.427))+.015,  \t\/\/ Line under the noze\n        \t\tmax(-p.y-.41,   \t\t\t\t\t\t\/\/ Upper lip\n                    sdEllipsoid(p- vec3(0,-.34,.37), vec3(.08,.15,.05)))), \/\/ Mouth bump\n             .032);\n\n\/\/ Eyelid ---------------------------------\n\tvec3 p_eye1 = p - g_eyePos;\n    p_eye1.xz *= mb;\n    \n    vec3 p_eye2 = p_eye1;\n    float d_eye = length(p_eye1) - g_eyeSize;\n          \n\tp_eye1.yz *= g_eyeRot;\n\tp_eye2.zy *= mc;\n    \n    float d1 = min(max(-p_eye1.y,d_eye - .01),\n                   max(p_eye2.y,d_eye - .005));\n    d = smin(d,d1,.01);\n\n\treturn d; \n}\n\nfloat dEye(vec3 p_eye) {\n    p_eye.xz *= ma;     \n    return length(p_eye) - g_eyeSize;\n}\n\nvec2 min2(in vec2 dc1, in vec2 dc2) {\n\treturn dc1.x <= dc2.x ? dc1 : dc2; \n}\n\nfloat sdTorus(in vec3 p, in vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat dfTrailPart0(vec3 p, float t, float lineId)\n{\n    vec3 pm = p;\n    t*=20.;\n    t += hash(lineId);\n    pm.x = mod(p.x+t+1.6,3.2)-1.6;\n    \n    float index = (p.x+t)-pm.x;\n    float id = lineId*10. + floor(((index+1.6)\/3.2)+1.6);\n    vec3 size = (.2+.5*hash3(vec2(id, id+1.)));\/\/*smoothstep(3.,7.,-p.x);\n    \n    pm.z += .25*cos(id);\n    \/\/pm.xy *= rotTime;\n    pm.xz *= matRot(3.14*hash(id));\n    pm.yz *= rotTime;\n     \n    return  max(p.x+4., udRoundBox(pm,size,.025));\n}\n\n\nfloat spaceship0(vec3 p, float lineId) {\n    p += vec3(0.,1.7,.5);\n\tvec2 p2 = vec2(sqrt(dot(p,p)-p.z*p.z), p.z);\n\t\n    float d = length(p2-vec2(-6.,0))-7.5;\n    \n    d = min(d, max(p2.y, p2.x-.3+.2*(p2.y+3.)));\n    d = max(-p2.y-4., d);\n            \n    vec3 p3 = p;\n    p3.xy = abs(p3.xy);\n    p3-=vec3(1.,1.,-3.);\n    p3.xy *= mc;\n    \n    float d2 = mBox(p3, vec3(.05,.5,.8));\n    d2 = max(d2, length(p-vec3(0.,0.,-3.5))-1.8);\n    d = min(d, length(p - vec3(0,.95,1.1))-.83);\n    d = smax2(d, -length(p - vec3(0,.8,.8))+1., .15); \n    d = min(d,d2);\n    return min(d, dfTrailPart0(p.zxy, 5.*g_time, lineId)); \n}\n\nfloat dToga0(vec3 p) {\n\n    float move = -1.+2.*g_deltaPast.x;\n    \n    p.z -= .04;\n    p.y += .05;\n    float bonnet = length(p- vec3(0,.25,-.03)) - .42;\n    \n    bonnet = smin(bonnet, length(p-vec3(.15*move,.5,-.35)) - .18, .25);\n\n    vec3 sp = p-vec3(0.,-1.2,.15);\n    sp.yz *= ma;\n    bonnet = min(bonnet, udRoundBox(sp, vec3(.4,.5,0.), .4));\n        \n    sp = sin(111.*p);\n    float echarpe = length(p- vec3(.3*move,.45,-.57)) - .15 - .007*sp.x*sp.y*sp.z;\n    \n    \n    p -= vec3(0.,-.05,-.05);\n  \n    p.y = -abs(p.y);\n \n    p.zy *= mb;  \n    float dy = -.8+1.2*cos(p.x);\n    \n    echarpe =  min(echarpe, sdTorus(p+vec3(0,+dy,0), vec2(.42,.07)));\n    echarpe = smin(echarpe, sdTorus(p+vec3(0,-.2+dy,0), vec2(.46,.09)),.15);\n\tfloat result =  min(echarpe,bonnet);\n    result -= .001*sp.x*sp.y*sp.z;\n    return result *.8;\n}\n\nvec2 dfTrailPart(vec3 p, float t, float lineId)\n{\n    vec3 pm = p;\n    t*=20.;\n    t += hash(lineId);\n    pm.x = mod(p.x+t+1.6,3.2)-1.6;\n    \n    float index = (p.x+t)-pm.x;\n    float id = lineId*10. + floor(((index+1.6)\/3.2)+1.6);\n    vec3 size = (.2+.5*hash3(vec2(id, id+1.)));\/\/*smoothstep(4.,7.,-p.x);\n    \n    pm.z += .25*cos(id);  \n    \n    \/\/pm.xy *= rotTime;\n    pm.xz *= matRot(3.14*hash(id));\n    pm.yz *= rotTime;\n    \n    vec3 k3 = smoothstep(.08*size.x, .12*size.x, abs(pm));\n    float k = k3.x*k3.y*k3.z*.95;\n     \n    float d = max(p.x+4., udRoundBox(pm,size,.025));\n    return vec2(d, 40. + id + k);    \n}\n\n\nvec2 spaceship(vec3 p, float lineId) {\n    p += vec3(0.,1.7,.5);\n\t\n    vec2 p2 = vec2(sqrt(dot(p,p)-p.z*p.z), p.z);\n\tfloat d = length(p2-vec2(-6.,0))-7.5;\n    \n    d = min(d, max(p2.y, p2.x-.3+.2*(p2.y+3.)));\n    d = max(-p2.y-4., d);\n            \n    vec3 p3 = p;\n    p3.xy = abs(p3.xy);\n    p3-=vec3(1.,1.,-3.);\n    p3.xy *= mc;\n   \n    float d2 = mBox(p3, vec3(.05,.5,.8));\n    d2 = max(d2, length(p-vec3(0.,0.,-3.5))-1.8);\n\n    d = min(d, length(p - vec3(0,.95,1.1))-.83);\n\/\/\td = max(d, -length(p - vec3(0,.8,.8))+1.1);\n    d = smax2(d, -length(p - vec3(0,.8,.8))+1., .15); \n    \n    d = min(d,d2);\n    p = p.zxy;\n    \n    return min2(vec2(d,20.+ mod(lineId,3.) + .95*smoothstep(.8,.9,cos(5.*p.z*p.y))), dfTrailPart(p, 5.*g_time, lineId)); \n}\n\nvec2 dToga(vec3 p) {\n\n    float move = -1.+2.*g_deltaPast.x;\n    \n    p.z -= .04;\n    p.y += .05;\n    float bonnet = length(p- vec3(0,.25,-.03)) - .42;\n    bonnet = smin(bonnet, length(p-vec3(.15*move,.5,-.35)) - .18, .25);\n\n    vec3 sp = p-vec3(0.,-1.2,.15);\n    sp.yz *= ma;\n    bonnet = min(bonnet, udRoundBox(sp, vec3(.4,.5,0.), .4));\n        \n    sp = sin(111.*p);\n    float echarpe = length(p- vec3(.3*move,.45,-.57)) - .15 - .007*sp.x*sp.y*sp.z;\n    \n    \n    p -= vec3(0.,-.05,-.05);\n  \n    p.y = -abs(p.y);\n \n    p.zy *= mb;  \n    float dy = -.8+1.2*cos(p.x);\n    \n    echarpe =  min(echarpe, sdTorus(p+vec3(0,+dy,0), vec2(.42,.07)));\n    echarpe = smin(echarpe, sdTorus(p+vec3(0,-.2+dy,0), vec2(.46,.09)),.15);\n\tvec2 result =  min2(vec2(echarpe,0.), vec2(bonnet, 1.));\n    result.x -= .001*sp.x*sp.y*sp.z;\n    result.x *=.8;\n    return result;\n}\n\n\nvec3 headRotCenter = vec3(0,-.2,-.07);\nfloat map( vec3 p) {\n    \n    float px = mod(p.x+8.,16.)-8.;\n    \n    float lineId = floor((px-p.x+8.)\/16.);\n    p.x = px;\n    float rnd = hash(lineId+10.);\n    p.z += cos(g_time*rnd+2.*rnd)*rnd;\n    p.y += cos(g_time+5.*rnd)*rnd;\n    \n    float d = dToga0(p);\n    d = min(d, spaceship0(p, lineId));\n        \n    vec3 p0 = p;\n    p -= headRotCenter;\n    p.yz *= g_headRotH;\n    p += headRotCenter;\n    \n\td = min(d, dSkinPart(p0,p));\n    p.x = abs(p.x);\n    d = min(d, dEye(p- g_eyePos));\n\n    return d;\n}\n\n\n\/\/ render for color extraction\nfloat colorField(vec3 p) {\n\n    float px = mod(p.x+8.,16.)-8.;\n    \n    float lineId = floor((px-p.x+8.)\/16.);\n    p.x = px;\n    float rnd = hash(lineId+10.);\n    p.z += cos(g_time*rnd+2.*rnd)*rnd;\n    p.y += cos(g_time+5.*rnd)*rnd;\n    \n    vec2 dc = dToga(p);\n    dc = min2(dc, spaceship(p,lineId));\n    \n    vec3 p0 = p;\n    p -= headRotCenter;\n    p.yz *= g_headRotH;\n    p += headRotCenter;\n\n    dc = min2(vec2(dSkinPart(p0,p), 2.), dc);\n         \n    p.x = abs(p.x);\n\treturn min2(dc, vec2(dEye(p - g_eyePos), 3.)).y;\n}\n\n\n\/\/ ---------------------------------------------------------------------------\n\nfloat SmoothMax( float a, float b, float smoothing ) {\n\treturn a-sqrt(smoothing*smoothing + pow(max(.0,a-b),2.0));\n}\n\nvec3 Sky( vec3 ray) {\n\treturn g_envBrightness*mix( vec3(.8), vec3(0), exp2(-(1.0\/max(ray.y,.01))*vec3(.4,.6,1.0)) );\n}\n\n\n\n\/\/--------------------------------------------------------------------\n\nconst float cloudScale = .15;\n\nfloat map5( in vec3 p )\n{\n\tvec3 q = p*cloudScale;\n\tfloat f;\n    f  = .50000*noise( q ); q = q*2.02;\n    f += .25000*noise( q ); q = q*2.03;\n    f += .12500*noise( q ); q = q*2.01;\n    f += .06250*noise( q ); q = q*2.02;\n    f += .03125*noise( q );\n\treturn clamp( 1.5 - p.y - 2. + 1.75*f, 0., 1. );\n}\n\nfloat map4( in vec3 p )\n{\n\tvec3 q = p*cloudScale;\n\tfloat f;\n    f  = .50000*noise( q ); q = q*2.02;\n    f += .25000*noise( q ); q = q*2.03;\n    f += .12500*noise( q ); q = q*2.01;\n    f += .06250*noise( q );\n\treturn clamp( 1.5 - p.y - 2. + 1.75*f, 0., 1. );\n}\nfloat map3( in vec3 p )\n{\n\tvec3 q = p*cloudScale;\n\tfloat f;\n    f  = .50000*noise( q ); q = q*2.02;\n    f += .25000*noise( q ); q = q*2.03;\n    f += .12500*noise( q );\n\treturn clamp( 1.5 - p.y - 2. + 1.75*f, 0., 1. );\n}\nfloat map2( in vec3 p )\n{\n\tvec3 q = p*cloudScale;\n\tfloat f;\n    f  = .50000*noise( q ); q = q*2.02;\n    f += .25000*noise( q );\n\treturn clamp( 1.5 - p.y - 2. + 1.75*f, 0., 1. );\n}\n\nvec3 sundir = normalize(vec3(.5,1.5,1.5)); \n\n\nvec4 integrate( in vec4 sum, in float dif, in float den, in vec3 bgcol, in float t )\n{\n  \/\/  bgcol *= 1.2;\n    \/\/ lighting\n    vec3 lin = vec3(.65,.7,.75)*1.4 + vec3(1.0, .6, .3)*dif;        \n    vec4 col = vec4( mix( vec3(1.,.95,.8), vec3(.25,.3,.35), den ), den );\n    col.xyz *= lin;\n    \/\/col.xyz = mix( col.xyz, bgcol, 1.0-exp(-0.00008*t*t) );\n    \/\/ front to back blending         \n\tcol.xyz = mix(bgcol, col.xyz, exp2(-t*vec3(.4,.6,1.)\/39.) );\n    col.a *= 0.5;\n    col.rgb *= col.a;\n    return sum + col*(1.0-sum.a);\n}\n\n#ifdef CLOUD_FAST\n\n#define MARCH(STEPS,MAPLOD,TEND) for(int i=0; i<STEPS; i++) { vec3  pos = ro + t*rd; if( t>TEND || sum.a > 0.95 ) break; float den = MAPLOD( pos ); if( den>0.01 ) { float dif =  clamp((den - MAPLOD(pos+0.3*sundir))\/0.6, 0.0, 1.0 ); sum = integrate( sum, dif, den, bgcol, t ); } t += max(.3,0.2*t); }\n\nvec4 raymarch( in vec3 ro, in vec3 rd, in vec3 bgcol, in float tend )\n{\n    ro.y *= .3;\n    rd.y *= .3;\n    \n\tvec4 sum = vec4(0);\n\n\tfloat t = 0.0;\n\/\/    MARCH(30,map5, tend);\n    MARCH(30,map4, tend);\n\/\/    MARCH(30,map3, tend);\n    MARCH(30,map2, tend);\n\n    return clamp( sum, 0., 1. );\n}\n\n#else\n\n#define MARCH(STEPS,MAPLOD,TEND) for(int i=0; i<STEPS; i++) { vec3  pos = ro + t*rd; if( t>TEND || sum.a > 0.95 ) break; float den = MAPLOD( pos ); if( den>0.01 ) { float dif =  clamp((den - MAPLOD(pos+0.3*sundir))\/0.6, 0.0, 1.0 ); sum = integrate( sum, dif, den, bgcol, t ); } t += max(.3,0.06*t); }\n\nvec4 raymarch( in vec3 ro, in vec3 rd, in vec3 bgcol, in float tend )\n{\n    ro.y *= .3;\n    rd.y *= .3;\n    \n\tvec4 sum = vec4(0);\n\n\tfloat t = 0.0;\n    MARCH(30,map5, tend);\n    MARCH(30,map4, tend);\n    MARCH(30,map3, tend);\n    MARCH(30,map2, tend);\n\n    return clamp( sum, 0., 1. );\n}\n\n#endif \/\/ CLOUD_FAST\n\n\n\n\n\n\n\n\n\/\/ -------------------------------------------------------------------\n\/\/ pupils effect came from lexicobol shader:\n\/\/ https:\/\/www.shadertoy.com\/view\/XsjXz1\n\/\/ -------------------------------------------------------------------\n\n\nfloat iqnoise( in vec2 x, float u, float v )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tfloat k = 1.+63.*pow(1.-v,4.);\n\tfloat va = 0.;\n\tfloat wt = 0.;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ ) {\n        vec2 g = vec2(i,j);\n\t\tvec3 o = hash3( p + g )*vec3(u,u,1.);\n\t\tvec2 r = g - f + o.xy;\n\t\tfloat d = dot(r,r);\n\t\tfloat ww = pow( 1.-smoothstep(0.,1.414,sqrt(d)), k );\n\t\tva += o.z*ww;\n\t\twt += ww;\n    }\n\t\n    return va\/wt;\n}\n\nfloat noise ( vec2 x)\n{\n\treturn iqnoise(x, 0., 1.);\n}\n\nmat2 m = mat2( .8, .6, -.6, .8);\n\nfloat fbm( vec2 p)\n{\n\tfloat f = .0;\n    f += .5000 * noise(p); p *= m* 2.02;\n    f += .2500 * noise(p); p *= m* 2.03;\n    f += .1250 * noise(p); p *= m* 2.01;\n    f += .0625 * noise(p); p *= m* 2.04;\n    f \/= .9375;\n    return f;\n}\n\n\nvec3 iris(vec2 p, float open)\n{\n    float background = 1.;\/\/ smoothstep(-0.25, 0.25, p.x);\n    \n    float r = sqrt( dot (p,p));\n    float r_pupil = .15 + .15*smoothstep(.5,2.,open);\n\n    float a = atan(p.y, p.x); \/\/ + 0.01*g_time;\n    vec3 col = vec3(1);\n    \n    float ss = .5;\/\/ + 0.5 * sin(g_time * 2.0);\n    float anim = 1.0 + .05*ss* clamp(1.0-r, 0., 1.);\n    r *= anim;\n        \n    if( r< .8) {\n\t\tcol = vec3(.12, .60, .57);\n        float f = fbm(5. * p);\n        col = mix(col, vec3(.12,.52, .60), f); \/\/ iris bluish green mix\n        \n        f = 1.0 - smoothstep( r_pupil, r_pupil+.2, r);\n        col = mix(col, vec3(.60,.44,.12), f); \/\/yellow\n        \n        a += .05 * fbm(20.*p);\n        \n        f = smoothstep(0.3, 1.0, fbm(vec2(5.0 * r, 20.0 * a))); \/\/ white highlight\n        col = mix(col, vec3(1.0), f);\n        \n        f = smoothstep(0.3, 1.0, fbm(vec2(5.0 * r, 5.0 * a))); \/\/ yellow highlight\n        col = mix(col, vec3(0.60,0.44,0.12), f);\n        \n        f = smoothstep(0.5, 1.0, fbm(vec2(5.0 * r, 15.0 * a))); \/\/ dark highlight\n        col *= 1.0 - f;\n        \n        f = smoothstep(0.55, 0.8, r); \/\/dark at edge\n        col *= 1.0 - 0.6*f;\n        \n        f = smoothstep( r_pupil, r_pupil + .05, r); \/\/pupil\n        col *= f; \n        \n        f = smoothstep(0.75, 0.8, r);\n        col = .5*mix(col, vec3(1.0), f);\n    }\n    \n\treturn col * background;\n}\n\n\/\/ -------------------------------------------------------------------\n\nfloat lineSegDist( vec2 uv, vec2 ba, vec2 a, float r ) {\n    vec2 pa = uv - a - ba*r; ba = -ba*r;\n    return length( pa - ba*clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 ) );\n}\n\nfloat snowFlake(vec2 p) {\n    p*= 8.;\n    if (length(p)>2.2) return 0.;\n    p.y = -abs(p.y);\n\n    float d2 = lineSegDist(p, vec2(-1., 0.), vec2(-1.2,-.5), 1.2); \n    d2 = min(d2, lineSegDist(p, vec2(-1., 0.), vec2(-1.6,-.15), .8)); \n\n    p.x = abs(p.x);\n    \n\n    float a = .6;\n    float d = lineSegDist(p, vec2(1., 0.), vec2(.0,0.), 1.);\n    d = min(d, lineSegDist(p, vec2(.5, -.866), vec2(0.,0.), 1.));\n    d = min(d, lineSegDist(p, vec2(.5, -.866), vec2(a,0.), .25));\n    d = min(d, lineSegDist(p, vec2(-.5, -.866), vec2(a*.5,-.866*a), .25));\n    d = min(d, lineSegDist(p, vec2(1., 0.), vec2(a*.5,-.866*a), .25));\n\t\n    return (1.-smoothstep(.05,.08,abs(d-.15))) + \n        (1.-smoothstep(.0,.03,d2-.05));\n}\n\n\n\/\/ -------------------------------------------------------------------\n\n\n\nvec3 Shade( vec3 pos, vec3 ray, vec3 normal, vec3 lightDir1, vec3 lightDir2, vec3 lightCol1, vec3 lightCol2, float shadowMask1, float shadowMask2, float distance )\n{\n    \n    float colorId = colorField(pos);\n    \n\tvec3 ambient = g_envBrightness*mix( vec3(.2,.27,.4), vec3(.4), (-normal.y*.5+.5) ); \/\/ ambient\n    \n    \/\/ ambient occlusion, based on my DF Lighting: https:\/\/www.shadertoy.com\/view\/XdBGW3\n\tfloat aoRange = distance\/20.0;\n\t\n\tfloat occlusion = max( 0.0, 1.0 - map( pos + normal*aoRange )\/aoRange ); \/\/ can be > 1.0\n\tocclusion = exp2( -2.0*pow(occlusion,2.0) ); \/\/ tweak the curve\n    \n\tambient *= occlusion*.8+.2; \/\/ reduce occlusion to imply indirect sub surface scattering\n\n\tfloat ndotl1 = max(.0,dot(normal,lightDir1));\n\tfloat ndotl2 = max(.0,dot(normal,lightDir2));\n    \n\tfloat lightCut1 = smoothstep(.0,.1,ndotl1);\n\tfloat lightCut2 = smoothstep(.0,.1,ndotl2);\n\n\tvec3 light = vec3(0);\n    \n\n\tlight += lightCol1*shadowMask1*ndotl1;\n\tlight += lightCol2*shadowMask2*ndotl2;\n\n    \n\t\/\/ And sub surface scattering too! Because, why not?\n    float tr = distance\/10.0; \/\/ this really should be constant... right?\n    float transmission1 = map( pos + lightDir1*tr )\/tr;\n    float transmission2 = map( pos + lightDir2*tr )\/tr;\n    \n    vec3 sslight = lightCol1 * smoothstep(0.0,1.0,transmission1) + lightCol2 * smoothstep(0.0,1.0,transmission2);\n    vec3 subsurface = vec3(1,.8,.5) * sslight;\n\n    float specularity = .2; \n\tvec3 h1 = normalize(lightDir1-ray);\n\tvec3 h2 = normalize(lightDir2-ray);\n    \n\tfloat specPower;\n    specPower = exp2(3.0+5.0*specularity);\n\n    vec3 p = pos;\n    p -= headRotCenter;\n    p.yz *= g_headRotH;\n    p += headRotCenter;\n         \n    float px = mod(p.x+8.,16.)-8.;\n    float lineId = floor((px-p.x+8.)\/16.);\n    p.x = px;\n    float rnd = hash(lineId+10.);\n    p.z += cos(g_time*rnd+2.*rnd)*rnd;\n    p.y += cos(g_time+5.*rnd)*rnd;\n        \n     \n    vec3 albedo;\n\n    if (colorId < 1.5) {  \n        \/\/ closes\n        albedo = mix(vec3(.8),vec3(.7,0.,0.),colorId);\n        specPower = sqrt(specPower);\n    } else if (colorId < 2.5) {\n         \/\/ Skin color\n        albedo = vec3(.6,.43,.3); \n  \n    } else if (colorId < 3.5) {\n\n        \/\/ Eye\n        if (p.z>0.) {\n            vec3 g_eyePosloc = g_eyePos;\n            g_eyePosloc.x *= sign(p.x);\n            \n            vec3 pe = p - g_eyePosloc;\n            \/\/ Light point in face coordinates\n        \tvec3 g_lightPos2 = g_lightPos - headRotCenter;\n    \t\tg_lightPos2.yz *= g_headRotH;\n    \t\t\/\/g_lightPos2.xz *= g_headRot;\n    \t\tg_lightPos2 += headRotCenter;\n\n            vec3 dir = normalize(g_lightPos2-g_eyePosloc);\n            \n            float a = clamp(atan(-dir.x, dir.z), -.2,.2), \n                  ca = cos(a), sa = sin(a);\n            pe.xz *= mat2(ca, sa, -sa, ca);\n\n            float b = clamp(atan(-dir.y, dir.z), -.1,.1), \n                  cb = cos(b), sb = sin(b);\n            pe.yz *= mat2(cb, sb, -sb, cb);\n            \n            \n            albedo = (pe.z>0.) ? iris(17.*(pe.xy), length(g_lightPos2-g_eyePosloc)) : vec3(1);\n        }\n        specPower *= specPower;\n    } else if (colorId < 39.5) {  \n        \/\/ spaceship\n        vec3 shipColor = hsv2rgb_smooth(.75+(colorId-20.)*.25,1.,.5);\n        albedo = mix(vec3(.8), shipColor,fract(colorId));\n        if (lineId == 0.)\n        \talbedo = mix(albedo, vec3(1), snowFlake((p.zy-vec2(-.06,-.8))));\n\n        normal = doBumpMap(iChannel2, p*1.2, normal,.02);\n        normal = normalize(normal - max(.0,dot (normal,ray ))*ray); \n        specPower*=1.5;\n        \n    } else {\n    \talbedo = mix(vec3(.7,.2,.2),hsv2rgb_smooth(hash(colorId),.6,1.), fract(colorId));  \n        specPower*2.;\/\/specPower;\n    }\n    \n\tvec3 specular1 = lightCol1*shadowMask1*pow(max(.0,dot(normal,h1))*lightCut1, specPower)*specPower\/32.0;\n\tvec3 specular2 = lightCol2*shadowMask2*pow(max(.0,dot(normal,h2))*lightCut2, specPower)*specPower\/32.0;\n    \n\tvec3 rray = reflect(ray,normal);\n\tvec3 reflection = Sky( rray );\n\t\n\t\/\/ specular occlusion, adjust the divisor for the gradient we expect\n\tfloat specOcclusion = max( 0., 1. - map( pos + rray*aoRange )\/(aoRange*max(.01,dot(rray,normal))) ); \/\/ can be > 1.0\n\tspecOcclusion = exp2( -2.*pow(specOcclusion,2.) ); \/\/ tweak the curve\n\t\n\t\/\/ prevent sparkles in heavily occluded areas\n\tspecOcclusion *= occlusion;\n\n\treflection *= specOcclusion; \/\/ could fire an additional ray for more accurate results\n    \n\tfloat fresnel = pow( 1.+dot(normal,ray), 5. );\n\tfresnel = mix( mix( .0, .01, specularity ), mix( .4, 1., specularity ), fresnel );\n\n    light += ambient;\n\tlight += subsurface;\n\n    vec3 result = light*albedo;\n\tresult = mix( result, reflection, fresnel );\n\tresult += specular1;\n    result += specular2;\n\n\treturn result;\n}\n\n\nfloat Trace( vec3 pos, vec3 ray, float traceStart, float traceEnd )\n{\n    float t0=0.,t1=1e3,\n          t2=0.,t3=1e3;\n  \n    float t = max(traceStart, min(t2,t0));\n    traceEnd = min(traceEnd, max(t3,t1));\n    float h;\n    for( int i=0; i < g_traceLimit; i++) {\n        h = map( pos+t*ray );\n        if (h < g_traceSize || t > traceEnd)\n            return t>traceEnd?1e3:t;\n        t = t+h;\n    }\n    \n\treturn 1e3;\n}\n\n\n\nvec3 Normal( vec3 pos, vec3 ray, float t) {\n\n\tfloat pitch = .2 * t \/ iResolution.x;\n    \n\/\/#ifdef FAST\n\/\/\t\/\/ don't sample smaller than the interpolation errors in Noise()\n\tpitch = max( pitch, .005 );\n\/\/#endif\n\t\n\tvec2 d = vec2(-1,1) * pitch;\n\n\tvec3 p0 = pos+d.xxx, \/\/ tetrahedral offsets\n         p1 = pos+d.xyy,\n         p2 = pos+d.yxy,\n         p3 = pos+d.yyx;\n\t\n\tfloat f0 = map(p0),\n\t      f1 = map(p1),\n\t      f2 = map(p2),\n\t      f3 = map(p3);\n\t\n\tvec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - pos*(f0+f1+f2+f3);\n\t\/\/ prevent normals pointing away from camera (caused by precision errors)\n\treturn normalize(grad - max(.0,dot (grad,ray ))*ray);\n}\n\n\n\/\/ Camera\nvec3 Ray( float zoom, in vec2 fragCoord) {\n    mat2 rot = matRot(.2*cos(.2*g_time)*cos(.71*g_time)); \n\treturn vec3( (fragCoord.xy-iResolution.xy*.5)*rot, iResolution.x*zoom );\n}\n\nvec3 Rotate( inout vec3 v, vec2 a ) {\n\tvec4 cs = vec4( cos(a.x), sin(a.x), cos(a.y), sin(a.y) );\n\t\n\tv.yz = v.yz*cs.x+v.zy*cs.y*vec2(-1,1);\n\tv.xz = v.xz*cs.z+v.zx*cs.w*vec2(1,-1);\n\t\n\tvec3 p;\n\tp.xz = vec2( -cs.w, -cs.z )*cs.x;\n\tp.y = cs.y;\n\t\n\treturn p;\n}\n\n\n\/\/ Camera Effects\n\nvoid BarrelDistortion( inout vec3 ray, float degree ){\n\t\/\/ would love to get some disperson on this, but that means more rays\n\tray.z \/= degree;\n\tray.z = ( ray.z*ray.z - dot(ray.xy,ray.xy) ); \/\/ fisheye\n\tray.z = degree*sqrt(ray.z);\n}\n\n\n\n\n\/\/ -------------------------------------------\n\nconst float\n    a_eyeClose = .55, \n    a_eyeOpen = -.3;\n\n\nmat3 lookat(in vec3 ro, in vec3 up){\n    vec3 fw=normalize(ro),\n    \t rt=normalize(cross(fw,up));\n    return mat3(rt, cross(rt,fw),fw);\n}\n\nvec3 RD(in vec3 ro, in vec3 cp, in vec2 fCoord) {\n    return lookat(cp-ro, vec3(0.,1.,0.))*normalize(vec3(((2.*fCoord-iResolution.xy)\/iResolution.y)*ma, 12.0));\n} \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float yy = fragCoord.y\/iResolution.y;\n\tif(yy<.11 || yy >.89) discard;\n\n\tg_time = 1.2*iTime;\/\/ - .25*smoothstep(2.,4.,iTime);\n    \n    float st = 1.2; \/\/ speed coeff\n    float time = g_time-19.;\n    \n\/\/ constantes\n    ma = matRot(-.5);\n    mb = matRot(-.15);\n    mc = matRot(-.6);\n\n    rotTime = matRot(5.*g_time); \n    \n\/\/ Eye blink\n    float a_Paupieres = mix(a_eyeOpen,a_eyeClose, hash(floor((time-2.)*10.))>.94?2.*abs(fract(20.*(time-2.))-.5):0.);    \n\n    g_eyeRot = matRot(a_Paupieres);\n\n\/\/ rotation de la tete \n    float a_headRot = 0.1, a_headRotH = -.1;\n\n    g_headRotH = matRot(a_headRotH); \n\n    mat2 g_headRotH2 = matRot(-a_headRotH); \n\n\n\n    g_lightPos = vec3(0,0,40);\n\n\/\/ intensitee et couleur du point\n    float lightAppear = 0.; \n\tvec3 lightCol2 = vec3(1,0,0);\n    \n\t\/\/ Ambiant color\n\tg_envBrightness = vec3(.6,.65,.9);\n\t\n\n\tvec3 lightDir1 = normalize(vec3(.5,1.5,1.5)),\n\t     lightCol1 = vec3(1.1,1.,.9)*.7*g_envBrightness;\n\n\tfloat lightRange2 = .4,\n\t\t  traceStart = 0.,\n\t\t  traceEnd = 200.;\n\n    vec3 col, colorSum = vec3(0.);\n        g_deltaPast = hash3(vec2(g_time));\n\n#if (ANTIALIASING == 1)\t\n\tint ii=0;\n#else\n\tfor (int ii=0;ii<ANTIALIASING;ii++) {\n#endif\n\t\tcol = vec3(0);\n\n        \/\/ Camera    \n\n#if (ANTIALIASING == 1)\t        \n        float randPix = 0.;\n#else \n        float randPix = hash(g_time); \/\/ Use frame rate to improve antialiasing ... not sure of result\n#endif        \n\t\tvec2 subPix = .4*vec2(cos(randPix+6.28*float(ii)\/float(ANTIALIASING)),\n                              sin(randPix+6.28*float(ii)\/float(ANTIALIASING)));\n\t\t\n\n        \n        vec3 ray = Ray(1.8,fragCoord.xy+subPix);\t\t\n\t\tBarrelDistortion(ray, 2.15 );\n\t\tray = normalize(ray);\n\t\tvec3 localRay = ray;\n        \n        \n\t\tvec2 mouse = vec2(-.1-.1*cos(.4*g_time),0.);\n\n\t\tif ( iMouse.z > 0. )\n\t\t\tmouse = .5-iMouse.yx\/iResolution.yx;\n\t\tvec3 pos; \/\/ = vec3(0,-.2,-2.) + 37.*Rotate(ray, vec2(-.1,1.+time*.1)+vec2(-1.0,-3.3)*mouse );        \n\n        vec2 q = ((2.*(fragCoord.xy+subPix)-iResolution.xy)\/iResolution.y);\n\n        float time2 = \/*mod(*\/g_time;\/\/,52.);\n        if (time2 < 5.5) {\n        \tpos = vec3(10., 1., 450.-200.*(time2));\n            q *= matRot(mix(-.5, .5, smoothstep(1.8, 2.2, time2))); \n            ray = lookat(-pos, vec3(0,1,0))*normalize(vec3(q, 12));\n        } else if (time2 < 24.) {\n        \/\/\tpos = mix(vec3(6., 0., 5.), vec3(6., 0., 5.-200.*(time2-17.)), smoothstep(16.,16.2,time2));\n        \tpos = vec3(6., -.15, 3.5);\n            float a = mix(0., 2.2, \/*8.5,*\/ smoothstep(14., 19., time2));\n            float k = mix(1., 5., smoothstep(17., 20., time2));\n            k = mix(k, 55., smoothstep(23.5, 24., time2));\n            pos *= k;\n            pos.xz *= matRot(a);\n            ray = lookat(vec3(0,.05,.7)-pos, vec3(0,1,0))*normalize(vec3(q, 6));\n            pos -= .1*g_deltaPast;\n\n        } else {\n\t\t\tg_time = 1.2*iTime+9.;\n            \n            ray = Ray(1.8, fragCoord.xy+subPix);\t\t\n            BarrelDistortion(ray, 2.15 );\n            ray = normalize(ray);\n            localRay = ray;\n\n\t\t\tmouse = vec2(-.1-.1*cos(.4*g_time),0.);\n\t\t\tpos = vec3(0,-.2,-2.) + 37.*Rotate(ray, vec2(-.1,1.+time*.1)+vec2(-1,-3.3)*mouse );        \n            pos -= .2*g_deltaPast;\n        }\n        \n\t\tvec3 skyColor = Sky( ray );\n        \n\n\t\tfloat t = Trace(pos, ray, traceStart, traceEnd );\n        if ( t < 900. )\n\t\t{           \n\t\t\tvec3 p = pos + ray*t;\n\t\t\t\n\t\t\t\/\/ Shadows\n\t\t\tvec3 lightDir2 = g_lightPos-p;\n\t\t\tfloat lightIntensity2 = length(lightDir2);\n\t\t\tlightDir2 \/= lightIntensity2;\n\t\t\tlightIntensity2 = lightAppear*lightRange2\/(.1+lightIntensity2*lightIntensity2);\n\t\t\t\n\t\t\tfloat s1 = Trace(p, lightDir1, .05, 4. );\n\t\t\tfloat s2 = Trace(p, lightDir2, .05, 4. );\n\t\t\t\n\t\t\tvec3 n = Normal(p, ray, t);\n\t\t\tcol = Shade(p, ray, n, lightDir1, lightDir2,\n\t\t\t\t\t\tlightCol1, lightCol2*lightIntensity2,\n\t\t\t\t\t\t(s1<20.)?0.:1., (s2<20.)?0.:1., t );\n\t\t\t\n\t\t\t\/\/ fog\n\t\t\tfloat f = 25.;\n\t\t\tcol = mix(skyColor, col, exp2(-t*vec3(.4,.6,1.)\/f) );\n\t\t}\n\t\telse\n\t\t{\n            t = 200.;\n            col = skyColor; \n\t\t}\n        \n        \n         vec4 cloud = raymarch(pos+vec3(0.,3.,g_time*200.), ray, skyColor, t);\n         col = col*(1.-cloud.a) + cloud.xyz; \/\/col*(1.-cloud.a) + cloud.rgb*cloud.a;\n        \n        \t\t\n\n\t\/\/ Post traitments -----------------------------------------------------    \n\t\t\/\/ Vignetting:\n\t\tcol *= smoothstep(.15, .0, dot(localRay.xy,localRay.xy) );\n\n\t\t\t\n\t\tcolorSum += col;\n        \n#if (ANTIALIASING > 1)\t\n\t}\n    \n    col = colorSum\/float(ANTIALIASING);\n#else\n\tcol = colorSum;\n#endif\n    \n\n    \/\/ Compress bright colours, (because bloom vanishes in vignette)\n    vec3 c = (col-1.);\n    c = sqrt(c*c+.05); \/\/ soft abs\n    col = mix(col,1.-c,.48); \/\/ .5 = never saturate, .0 = linear\n\t\n\t\/\/ compress bright colours\n\tfloat l = max(col.x,max(col.y,col.z));\/\/dot(col,normalize(vec3(2,4,1)));\n\tl = max(l,.01); \/\/ prevent div by zero, darker colours will have no curve\n\tfloat l2 = SmoothMax(l,1.0,.01);\n\tcol *= l2\/l;\n    \n    \t\t\/\/ grain\n\t\tvec2 grainuv = fragCoord.xy + floor(g_time*60.)*vec2(37,41);\n\t\tvec2 filmNoise = 1.5*textureLod( iChannel0, .5*grainuv\/iChannelResolution[0].xy, 0. ).rb;\n\t\tcol *= mix( vec3(1), mix(vec3(1,.5,0),vec3(0,.5,1),filmNoise.x), .1*filmNoise.y );\n    \/*\n   float gray = dot(col, vec3(0.299, 0.587, 0.114));\n\t\n    const vec3 SEPIA = vec3(1.25, 1.0, 0.85); \n    col = gray*gray*gray*SEPIA;\n    *\/\n \/\/   col = mix(col, vec3(1), snowFlake(3.*(fragCoord\/iResolution.y)+vec2(-5.1,-.52)));\n\tfragColor =  vec4(pow(col,vec3(1.\/1.6)),1);\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4lGSDw","date":"1484594019","viewed":7163,"name":"Fourier - interpolation","username":"iq","description":"Interpolating a set of 38 points with the Discrete Fourier Transform. More info here: [url]https:\/\/iquilezles.org\/articles\/fourier[\/url]","likes":120,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ The MIT License\n\/\/ Copyright \u00a9 2017 Inigo Quilez\n\/\/ Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\/\/ A set of 38 points gets interpolated by computing the DFT (Discrete Fourier Transform)\n\/\/ and then its inverse, and evaluating the it at more than 38 points. This results in\n\/\/ an interpolation sort of made of cosine\/sine waves. Would be nice to do a regular\n\/\/ Hermite spline interpolation as well to compare.\n\/\/\n\/\/ More info: https:\/\/iquilezles.org\/articles\/fourier\n\/\/\n\/\/ Original drawing (kind of), here:\n\/\/ https:\/\/mir-s3-cdn-cf.behance.net\/project_modules\/disp\/831a237863325.560b2e6f92480.png\n\nfloat sdSegmentSq( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n    vec2  d = pa - ba*h;\n\treturn dot(d,d);\n}\n\nfloat sdPointSq( in vec2 p, in vec2 a )\n{\n    vec2 d = p - a;\n\treturn dot(d,d);\n}\n\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\n\n#define ZERO min(iFrame,0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float e = 1.0\/iResolution.x;\n\tvec2 p = fragCoord \/ iResolution.x;\n    \n    vec3 col = vec3(1.0);\n\n    #define NUM 38\n    \n    vec2 path[NUM];\n    \n    \/\/------------------------------------------------------\n    \/\/ path\n    \/\/------------------------------------------------------\n    {\n        path[ 0] = vec2( 0.098, 0.062 );\n        path[ 1] = vec2( 0.352, 0.073 );\n        path[ 2] = vec2( 0.422, 0.136 );\n        path[ 3] = vec2( 0.371, 0.085 );\n        path[ 4] = vec2( 0.449, 0.140 );\n        path[ 5] = vec2( 0.352, 0.187 );\n        path[ 6] = vec2( 0.379, 0.202 );\n        path[ 7] = vec2( 0.398, 0.202 );\n        path[ 8] = vec2( 0.266, 0.198 );\n        path[ 9] = vec2( 0.318, 0.345 );\n        path[10] = vec2( 0.402, 0.359 );\n        path[11] = vec2( 0.361, 0.425 );\n        path[12] = vec2( 0.371, 0.521 );\n        path[13] = vec2( 0.410, 0.491 );\n        path[14] = vec2( 0.410, 0.357 );\n        path[15] = vec2( 0.502, 0.482 );\n        path[16] = vec2( 0.529, 0.435 );\n        path[17] = vec2( 0.426, 0.343 );\n        path[18] = vec2( 0.449, 0.343 );\n        path[19] = vec2( 0.504, 0.335 );\n        path[20] = vec2( 0.664, 0.355 );\n        path[21] = vec2( 0.748, 0.208 );\n        path[22] = vec2( 0.738, 0.277 );\n        path[23] = vec2( 0.787, 0.308 );\n        path[24] = vec2( 0.748, 0.183 );\n        path[25] = vec2( 0.623, 0.081 );\n        path[26] = vec2( 0.557, 0.099 );\n        path[27] = vec2( 0.648, 0.116 );\n        path[28] = vec2( 0.598, 0.116 );\n        path[29] = vec2( 0.566, 0.195 );\n        path[30] = vec2( 0.584, 0.228 );\n        path[31] = vec2( 0.508, 0.083 );\n        path[32] = vec2( 0.457, 0.140 );\n        path[33] = vec2( 0.508, 0.130 );\n        path[34] = vec2( 0.625, 0.071 );\n        path[35] = vec2( 0.818, 0.093 );\n        path[36] = vec2( 0.951, 0.066 );\n        path[37] = vec2( 0.547, 0.081 );\n    }\n\n    \/\/------------------------------------------------------\n    \/\/ draw path\n    \/\/------------------------------------------------------\n    {\n        vec2 d = vec2(1000.0);\n        for( int i=0; i<(NUM-1); i++ )\n        {\n            vec2 a = path[i+0];\n            vec2 b = path[i+1];\n            d = min( d, vec2(sdSegmentSq( p,a,b ), sdPointSq(p,a) ) );\n        }\n        d.x = sqrt( d.x );\n        d.y = sqrt( min( d.y, sdPointSq(p,path[NUM-1]) ) );\n        \/\/col = mix( col, vec3(0.8,0.8,0.8), 1.0-smoothstep(0.0,e,d.x) );\n        col = mix( col, vec3(0.9,0.2,0.0), 1.0-smoothstep(5.0*e,6.0*e,d.y) );\n    }\n\n    \/\/------------------------------------------------------\n    \/\/ compute fourier transform of the path\n    \/\/------------------------------------------------------\n    vec2 fcsX[20];\n    vec2 fcsY[20];\n    for( int k=ZERO; k<20; k++ )\n    {\n        vec2 fcx = vec2(0.0);\n        vec2 fcy = vec2(0.0);\n        for( int i=0; i<NUM; i++ )\n        {\n            float an = -6.283185*float(k)*float(i)\/float(NUM);\n            vec2  ex = vec2( cos(an), sin(an) );\n            fcx += path[i].x*ex;\n            fcy += path[i].y*ex;\n        }\n        fcsX[k] = fcx;\n        fcsY[k] = fcy;\n    }\n\n    \/\/------------------------------------------------------\n    \/\/ inverse transform with 6x evaluation points\n    \/\/------------------------------------------------------\n    {\n    float ani = min( mod((12.0+iTime)\/10.1,1.3), 1.0 );\n    float d = 1000.0;\n    vec2 oq, fq;\n    for( int i=ZERO; i<256; i++ )\n    {\n        float h = ani*float(i)\/256.0;\n        vec2 q = vec2(0.0);\n        for( int k=0; k<20; k++ )\n        {\n            float w = (k==0||k==19)?1.0:2.0;\n            float an = -6.283185*float(k)*h;\n            vec2  ex = vec2( cos(an), sin(an) );\n            q.x += w*dot(fcsX[k],ex)\/float(NUM);\n            q.y += w*dot(fcsY[k],ex)\/float(NUM);\n        }\n        if( i==0 ) fq=q; else d = min( d, sdSegmentSq( p, q, oq ) );\n        oq = q;\n    }\n    d = sqrt(d);\n    col = mix( col, vec3(0.1,0.1,0.2), 1.0-smoothstep(0.0*e,2.0*e,d) );\n    col *= 0.75 + 0.25*smoothstep( 0.0, 0.13, sqrt(d) );\n    }\n\n    \/\/------------------------------------------------------\n\n    col *= 1.0 - 0.3*length(fragCoord\/iResolution.xy-0.5);\n \n    \n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"MsSBRh","date":"1499361200","viewed":7149,"name":"Inverse Smoothstep","username":"iq","description":"The inverse function of the smoothstep y(x) = x\u00b2(3-2x) has analytic inverse. Cubic as it is, it involves some trigonometric computations. In yellow, the inverse_smoothstep. In gray, the smoothstep of the inverse_smoothstep, which gives the identity.","likes":45,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ The MIT License\n\/\/ Copyright \u00a9 2017 Inigo Quilez\n\/\/ Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\/\/ The inverse function of smoothstep, y(x) = x\u00b2\u00b7(3-2x), has analytic inverse. \n\/\/ Cubic as it is, it involves some trigonometric computations. Surely enought\n\/\/ that can be approximated but that's not the point of this shader. Computing\n\/\/ the exact inverse is.\n\/\/ \n\/\/ In yellow, the inverse_smoothstep. In gray, the smoothstep of the\n\/\/ inverse_smoothstep, which gives the identity. In blue, the smoothstep for \n\/\/ reference and symmetry of the image.\n\/\/\n\/\/ More info on its derivation here:\n\/\/\n\/\/ https:\/\/iquilezles.org\/articles\/ismoothstep\n\/\/\n\n\n\/\/ inverse of y = x\u00b2(3-2x)\nfloat inverse_smoothstep( float x )\n{\n    return 0.5-sin(asin(1.0-2.0*x)\/3.0);\n}\n\n\/\/ y = x\u00b2(3-2x)\nfloat my_smoothstep( float x )\n{\n    return x*x*(3.0-2.0*x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    float dx = 1.0\/iResolution.y;\n    vec2  p = ( vec2((iResolution.y-iResolution.x)\/2.0,0.0)+fragCoord)\/iResolution.y;\n    \n    vec3 col = vec3(0.0);\n    \n    if( p.x>0.0 && p.x<1.0 )\n    {\n        \/\/ background\n        col = vec3( 0.2 + 0.02*mod(floor(p.x*10.0)+floor(p.y*10.0),2.0) );\n\n        \/\/ gray: smoothstep of inverse_smoothstep = identity\n        {\n        float y = my_smoothstep( inverse_smoothstep( p.x ) );\n        float di = abs(p.y-y)\/0.002;\n        col = mix( col, vec3(0.5,0.5,0.5), 1.0-smoothstep(0.0, 1.5, di ) );\n        }\n\n        \/\/ blue: smoothstep\n        {\n        float y = my_smoothstep( p.x );\n        float di = abs(p.y-y)\/0.002;\n        col = mix( col, vec3(0.0,0.4,0.8), 1.0-smoothstep( 0.0, 2.0, di ) );\n        }\n        \n        \/\/ yellow: inverse_smoothstep\n        {\n        float y = inverse_smoothstep( p.x );\n        float di = abs(p.y-y)\/0.002;\n        col = mix( col, vec3(1.0,0.7,0.0), 1.0-smoothstep( 0.0, 2.0, di ) );\n        }\n    }\n    \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"WdXfzl","date":"1588821050","viewed":7148,"name":"Montecarlo PDE (2)","username":"iq","description":"Playing with [url]http:\/\/www.cs.cmu.edu\/~kmcrane\/Projects\/MonteCarloGeometryProcessing\/paper.pdf[\/url]. Used contour lines from [url]https:\/\/www.shadertoy.com\/view\/XdKGDW[\/url]","likes":61,"published":3,"flags":32,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Playing with Keenan Crane's latest paper in collab with\n\/\/ Rohan Sawhney: http:\/\/www.cs.cmu.edu\/~kmcrane\/Projects\/MonteCarloGeometryProcessing\/paper.pdf[\/url]\n\/\/\n\/\/ Used contour lines from https:\/\/www.shadertoy.com\/view\/XdKGDW\n\/\/\n\/\/ See https:\/\/www.shadertoy.com\/view\/WsXBzl for a simpler example\n\/\/\n\/\/ Change the define in line 397 of \"Buffer A\" in order to see the\n\/\/ actual color contour curves.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 data = texelFetch(iChannel0,ivec2(fragCoord),0);\n    fragColor = vec4(data.xyz\/data.w, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nvoid sdLine(inout vec4 dis_col, in vec2 p, vec2 a, vec2 b, vec3 cu,vec3 cv)\n{\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float h = clamp( dot(pa,ba)\/dot(ba,ba),0.0,1.0);\n    float d = length(pa-h*ba);\n    if( d<dis_col.x )\n    {\n        float s = pa.x*ba.y-pa.y*ba.x;\n        dis_col = vec4(d,(s<0.0)?cu:cv);\n    }\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nvoid sdLine(inout vec4 dis_col,in vec2 p, vec2 a, vec2 b,vec3 cu0,vec3 cv0,vec3 cu1,vec3 cv1)\n{\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float h = clamp( dot(pa,ba)\/dot(ba,ba),0.0,1.0);\n    float d = length(pa-h*ba);\n    if( d<dis_col.x )\n    {\n        float s = pa.x*ba.y-pa.y*ba.x;\n        h = 1.0-h;\n        dis_col = vec4(d,(s<0.0)?mix(cu0,cu1,h):mix(cv0,cv1,h));\n    }\n}\n\n\/\/ image contour SDF\nvec4 map( in vec2 pos )\n{    \n  vec4 dis_col = vec4(1e20,0.0,0.0,0.0);\n\n  \/\/ data copied and transformed from https:\/\/www.shadertoy.com\/view\/XdKGDW\n  sdLine(dis_col,pos,vec2( 0.032566, 0.636419),vec2(-0.140558, 0.554919),vec3(0.802,0.563,0.443),vec3(0.865,0.792,0.690));\n  sdLine(dis_col,pos,vec2( 0.157917, 0.667506),vec2( 0.032586, 0.636408),vec3(0.824,0.575,0.453),vec3(0.869,0.804,0.702));\n  sdLine(dis_col,pos,vec2( 0.292774, 0.683634),vec2( 0.157637, 0.667307),vec3(0.849,0.600,0.467),vec3(0.871,0.804,0.702));\n  sdLine(dis_col,pos,vec2( 0.462459, 0.681116),vec2( 0.293026, 0.683576),vec3(0.890,0.647,0.488),vec3(0.871,0.804,0.700));\n  sdLine(dis_col,pos,vec2( 0.532097, 0.663221),vec2( 0.462281, 0.681257),vec3(0.931,0.692,0.510),vec3(0.871,0.804,0.698));\n  sdLine(dis_col,pos,vec2( 0.679623, 0.589789),vec2( 0.532148, 0.663353),vec3(0.951,0.712,0.518),vec3(0.871,0.804,0.698));\n  sdLine(dis_col,pos,vec2( 0.737901, 0.539194),vec2( 0.680024, 0.589419),vec3(0.951,0.712,0.512),vec3(0.871,0.804,0.698));\n  sdLine(dis_col,pos,vec2( 0.816252, 0.438381),vec2( 0.737331, 0.539616),vec3(0.933,0.700,0.502),vec3(0.871,0.804,0.696));\n  sdLine(dis_col,pos,vec2( 0.855568, 0.362220),vec2( 0.816666, 0.437574),vec3(0.920,0.684,0.486),vec3(0.871,0.802,0.694));\n  sdLine(dis_col,pos,vec2( 0.914063, 0.195570),vec2( 0.855412, 0.362903),vec3(0.904,0.667,0.467),vec3(0.871,0.800,0.694));\n  sdLine(dis_col,pos,vec2( 0.906394,-0.050806),vec2( 0.914184, 0.195399),vec3(0.876,0.637,0.437),vec3(0.871,0.800,0.692));\n  sdLine(dis_col,pos,vec2( 0.847684,-0.254043),vec2( 0.906304,-0.051022),vec3(0.841,0.600,0.402),vec3(0.871,0.800,0.688));\n  sdLine(dis_col,pos,vec2( 0.753134,-0.419097),vec2( 0.847548,-0.253827),vec3(0.808,0.571,0.373),vec3(0.871,0.798,0.686));\n  sdLine(dis_col,pos,vec2( 0.655326,-0.537575),vec2( 0.752991,-0.419390),vec3(0.796,0.557,0.357),vec3(0.871,0.796,0.686),vec3(0.698,0.439,0.271),vec3(0.871,0.796,0.686));\n  sdLine(dis_col,pos,vec2( 0.589686,-0.601779),vec2( 0.655427,-0.537635),vec3(0.698,0.439,0.271),vec3(0.871,0.796,0.686),vec3(0.592,0.298,0.149),vec3(0.871,0.796,0.686));\n  sdLine(dis_col,pos,vec2( 0.485769,-0.673529),vec2( 0.589993,-0.601259),vec3(0.553,0.269,0.131),vec3(0.871,0.796,0.684));\n  sdLine(dis_col,pos,vec2( 0.420683,-0.695361),vec2( 0.485736,-0.673833),vec3(0.506,0.247,0.124),vec3(0.876,0.806,0.692));\n  sdLine(dis_col,pos,vec2( 0.289074,-0.705976),vec2( 0.420341,-0.695230),vec3(0.482,0.275,0.155),vec3(0.876,0.806,0.692));\n  sdLine(dis_col,pos,vec2( 0.261794,-0.694878),vec2( 0.289218,-0.706199),vec3(0.459,0.284,0.173),vec3(0.871,0.796,0.680));\n  sdLine(dis_col,pos,vec2( 0.234336,-0.652438),vec2( 0.261805,-0.694874),vec3(0.443,0.249,0.153),vec3(0.871,0.796,0.678));\n  sdLine(dis_col,pos,vec2( 0.229172,-0.613117),vec2( 0.234298,-0.652477),vec3(0.420,0.184,0.116),vec3(0.871,0.796,0.678));\n  sdLine(dis_col,pos,vec2( 0.211059,-0.573956),vec2( 0.229373,-0.612721),vec3(0.404,0.145,0.094),vec3(0.871,0.796,0.678),vec3(0.384,0.090,0.059),vec3(0.631,0.506,0.447));\n  sdLine(dis_col,pos,vec2( 0.794264, 0.332819),vec2( 0.820637, 0.237829),vec3(0.961,0.525,0.318),vec3(0.941,0.394,0.175));\n  sdLine(dis_col,pos,vec2( 0.791799, 0.406427),vec2( 0.794099, 0.333239),vec3(0.967,0.565,0.365),vec3(0.941,0.388,0.163));\n  sdLine(dis_col,pos,vec2( 0.773116, 0.456365),vec2( 0.791677, 0.406208),vec3(0.973,0.596,0.406),vec3(0.941,0.382,0.153));\n  sdLine(dis_col,pos,vec2( 0.691214, 0.542967),vec2( 0.772875, 0.456604),vec3(0.980,0.631,0.455),vec3(0.941,0.375,0.139));\n  sdLine(dis_col,pos,vec2( 0.584748, 0.612130),vec2( 0.691856, 0.543066),vec3(0.988,0.675,0.510),vec3(0.941,0.367,0.124));\n  sdLine(dis_col,pos,vec2( 0.523270, 0.633009),vec2( 0.583850, 0.612122),vec3(0.994,0.702,0.543),vec3(0.941,0.361,0.114));\n  sdLine(dis_col,pos,vec2( 0.416081, 0.649827),vec2( 0.523622, 0.632948),vec3(0.996,0.710,0.553),vec3(0.941,0.357,0.110),vec3(0.965,0.596,0.420),vec3(0.941,0.353,0.094));\n  sdLine(dis_col,pos,vec2( 0.328754, 0.652317),vec2( 0.416523, 0.649811),vec3(0.955,0.573,0.390),vec3(0.941,0.349,0.090));\n  sdLine(dis_col,pos,vec2( 0.152437, 0.628754),vec2( 0.328509, 0.652168),vec3(0.945,0.549,0.361),vec3(0.941,0.345,0.086),vec3(0.918,0.671,0.486),vec3(0.929,0.404,0.192));\n  sdLine(dis_col,pos,vec2(-0.058755, 0.562422),vec2( 0.152170, 0.628817),vec3(0.918,0.671,0.486),vec3(0.929,0.404,0.192),vec3(0.847,0.643,0.471),vec3(0.910,0.478,0.325));\n  sdLine(dis_col,pos,vec2(-0.152258, 0.413501),vec2(-0.073990, 0.418056),vec3(0.322,0.165,0.318),vec3(0.839,0.357,0.294),vec3(0.325,0.161,0.341),vec3(0.875,0.427,0.400));\n  sdLine(dis_col,pos,vec2(-0.166656, 0.426903),vec2(-0.152256, 0.413325),vec3(0.325,0.161,0.341),vec3(0.875,0.427,0.400),vec3(0.329,0.157,0.361),vec3(0.929,0.510,0.518));\n  sdLine(dis_col,pos,vec2(-0.150301, 0.459101),vec2(-0.167019, 0.427044),vec3(0.327,0.155,0.355),vec3(0.902,0.504,0.522));\n  sdLine(dis_col,pos,vec2(-0.118651, 0.485569),vec2(-0.150151, 0.459146),vec3(0.322,0.151,0.329),vec3(0.892,0.510,0.522));\n  sdLine(dis_col,pos,vec2(-0.002352, 0.524810),vec2(-0.118560, 0.485419),vec3(0.302,0.141,0.253),vec3(0.918,0.525,0.484));\n  sdLine(dis_col,pos,vec2( 0.031055, 0.523623),vec2(-0.002648, 0.525035),vec3(0.329,0.161,0.216),vec3(0.927,0.531,0.443));\n  sdLine(dis_col,pos,vec2( 0.698487, 0.039536),vec2( 0.691611,-0.011391),vec3(0.241,0.084,0.069),vec3(0.894,0.271,0.043));\n  sdLine(dis_col,pos,vec2( 0.719461, 0.087611),vec2( 0.698093, 0.039144),vec3(0.208,0.076,0.112),vec3(0.892,0.271,0.041));\n  sdLine(dis_col,pos,vec2( 0.756735, 0.118077),vec2( 0.719793, 0.087918),vec3(0.180,0.078,0.149),vec3(0.890,0.271,0.037));\n  sdLine(dis_col,pos,vec2( 0.781480, 0.121070),vec2( 0.756822, 0.117813),vec3(0.208,0.100,0.151),vec3(0.890,0.271,0.035));\n  sdLine(dis_col,pos,vec2( 0.801014, 0.097611),vec2( 0.781005, 0.120993),vec3(0.220,0.114,0.149),vec3(0.888,0.269,0.033));\n  sdLine(dis_col,pos,vec2( 0.823724, 0.024839),vec2( 0.801409, 0.097493),vec3(0.210,0.129,0.149),vec3(0.886,0.267,0.029));\n  sdLine(dis_col,pos,vec2( 0.823815,-0.104922),vec2( 0.823541, 0.024940),vec3(0.247,0.180,0.135),vec3(0.882,0.265,0.024));\n  sdLine(dis_col,pos,vec2( 0.812986,-0.134971),vec2( 0.823897,-0.104904),vec3(0.275,0.206,0.120),vec3(0.878,0.263,0.018));\n  sdLine(dis_col,pos,vec2( 0.781477,-0.159956),vec2( 0.813047,-0.134843),vec3(0.275,0.182,0.102),vec3(0.876,0.263,0.014));\n  sdLine(dis_col,pos,vec2( 0.742899,-0.136473),vec2( 0.781414,-0.160083),vec3(0.273,0.161,0.084),vec3(0.873,0.261,0.010));\n  sdLine(dis_col,pos,vec2( 0.707845,-0.099381),vec2( 0.742671,-0.136282),vec3(0.278,0.145,0.071),vec3(0.871,0.259,0.006));\n  sdLine(dis_col,pos,vec2( 0.692791,-0.057184),vec2( 0.707941,-0.099276),vec3(0.278,0.127,0.057),vec3(0.869,0.259,0.002));\n  sdLine(dis_col,pos,vec2( 0.691497,-0.011596),vec2( 0.692977,-0.057240),vec3(0.269,0.114,0.049),vec3(0.859,0.257,0.000));\n  sdLine(dis_col,pos,vec2( 0.649558,-0.424193),vec2( 0.570243,-0.515577),vec3(0.394,0.220,0.129),vec3(0.763,0.245,0.125));\n  sdLine(dis_col,pos,vec2( 0.691564,-0.410217),vec2( 0.649794,-0.424293),vec3(0.408,0.216,0.118),vec3(0.800,0.247,0.122),vec3(0.635,0.341,0.208),vec3(0.773,0.318,0.176));\n  sdLine(dis_col,pos,vec2( 0.696625,-0.423080),vec2( 0.691171,-0.410166),vec3(0.635,0.341,0.208),vec3(0.773,0.318,0.176),vec3(0.569,0.345,0.220),vec3(0.749,0.416,0.251));\n  sdLine(dis_col,pos,vec2( 0.689415,-0.442915),vec2( 0.697144,-0.422830),vec3(0.529,0.343,0.227),vec3(0.729,0.441,0.273));\n  sdLine(dis_col,pos,vec2( 0.593770,-0.551001),vec2( 0.689147,-0.443398),vec3(0.441,0.322,0.225),vec3(0.688,0.429,0.271));\n  sdLine(dis_col,pos,vec2( 0.555892,-0.565232),vec2( 0.593883,-0.550881),vec3(0.431,0.282,0.198),vec3(0.665,0.351,0.220));\n  sdLine(dis_col,pos,vec2( 0.551358,-0.559085),vec2( 0.555731,-0.565064),vec3(0.471,0.263,0.180),vec3(0.663,0.310,0.192),vec3(0.345,0.263,0.192),vec3(0.659,0.271,0.169));\n  sdLine(dis_col,pos,vec2( 0.570349,-0.515707),vec2( 0.551420,-0.559235),vec3(0.343,0.257,0.188),vec3(0.661,0.257,0.157));\n  sdLine(dis_col,pos,vec2( 0.139656, 0.051930),vec2( 0.125174,-0.011939),vec3(0.212,0.176,0.188),vec3(0.773,0.251,0.153),vec3(0.322,0.298,0.314),vec3(0.831,0.376,0.290));\n  sdLine(dis_col,pos,vec2( 0.156524, 0.072534),vec2( 0.139337, 0.052148),vec3(0.322,0.298,0.314),vec3(0.831,0.376,0.290),vec3(0.455,0.388,0.420),vec3(0.863,0.510,0.447));\n  sdLine(dis_col,pos,vec2( 0.207624, 0.092959),vec2( 0.156443, 0.072549),vec3(0.455,0.388,0.420),vec3(0.863,0.510,0.447),vec3(0.608,0.612,0.635),vec3(0.902,0.635,0.588));\n  sdLine(dis_col,pos,vec2( 0.277523, 0.089856),vec2( 0.208031, 0.092954),vec3(0.608,0.612,0.635),vec3(0.902,0.635,0.588),vec3(0.792,0.820,0.851),vec3(0.945,0.776,0.753));\n  sdLine(dis_col,pos,vec2( 0.342574, 0.060277),vec2( 0.277521, 0.089925),vec3(0.792,0.820,0.851),vec3(0.945,0.776,0.753),vec3(0.851,0.867,0.894),vec3(0.988,0.914,0.910));\n  sdLine(dis_col,pos,vec2( 0.395896, 0.011487),vec2( 0.342325, 0.060273),vec3(0.851,0.867,0.894),vec3(0.988,0.914,0.910),vec3(0.816,0.769,0.788),vec3(0.973,0.792,0.769));\n  sdLine(dis_col,pos,vec2( 0.426593,-0.056929),vec2( 0.395983, 0.010998),vec3(0.816,0.769,0.788),vec3(0.973,0.792,0.769),vec3(0.784,0.690,0.702),vec3(0.953,0.675,0.624));\n  sdLine(dis_col,pos,vec2( 0.429756,-0.097479),vec2( 0.426646,-0.056343),vec3(0.784,0.690,0.702),vec3(0.955,0.676,0.627));\n  sdLine(dis_col,pos,vec2( 0.211977, 0.039860),vec2( 0.152329, 0.066394),vec3(0.251,0.255,0.322),vec3(0.573,0.522,0.557),vec3(0.239,0.251,0.325),vec3(0.612,0.620,0.655));\n  sdLine(dis_col,pos,vec2( 0.253875,-0.009396),vec2( 0.212258, 0.039555),vec3(0.224,0.235,0.298),vec3(0.627,0.651,0.694));\n  sdLine(dis_col,pos,vec2( 0.304442,-0.112422),vec2( 0.254010,-0.009088),vec3(0.190,0.196,0.251),vec3(0.629,0.653,0.704));\n  sdLine(dis_col,pos,vec2( 0.333171,-0.133931),vec2( 0.303949,-0.112429),vec3(0.178,0.169,0.220),vec3(0.612,0.620,0.671));\n  sdLine(dis_col,pos,vec2( 0.374078,-0.127448),vec2( 0.333105,-0.133826),vec3(0.222,0.190,0.220),vec3(0.629,0.629,0.675));\n  sdLine(dis_col,pos,vec2( 0.429594,-0.097757),vec2( 0.374129,-0.127644),vec3(0.278,0.229,0.237),vec3(0.678,0.659,0.694));\n  sdLine(dis_col,pos,vec2( 0.128499,-0.076818),vec2( 0.113227,-0.128679),vec3(0.131,0.071,0.118),vec3(0.986,0.927,0.737));\n  sdLine(dis_col,pos,vec2( 0.214776,-0.207363),vec2( 0.168035,-0.203218),vec3(0.982,0.796,0.496),vec3(0.124,0.039,0.092));\n  sdLine(dis_col,pos,vec2( 0.238606,-0.218984),vec2( 0.215027,-0.207500),vec3(0.990,0.782,0.447),vec3(0.153,0.033,0.057));\n  sdLine(dis_col,pos,vec2( 0.252587,-0.370868),vec2( 0.218651,-0.371118),vec3(0.441,0.100,0.059),vec3(0.845,0.380,0.137));\n  sdLine(dis_col,pos,vec2( 0.276234,-0.360153),vec2( 0.252950,-0.370523),vec3(0.496,0.124,0.057),vec3(0.847,0.412,0.163));\n  sdLine(dis_col,pos,vec2( 0.296842,-0.316514),vec2( 0.275936,-0.360588),vec3(0.533,0.141,0.055),vec3(0.847,0.431,0.180),vec3(0.643,0.192,0.051),vec3(0.910,0.561,0.271));\n  sdLine(dis_col,pos,vec2( 0.296875,-0.238281),vec2( 0.296875,-0.316406),vec3(0.643,0.192,0.051),vec3(0.910,0.561,0.271),vec3(0.741,0.239,0.047),vec3(0.953,0.678,0.357));\n  sdLine(dis_col,pos,vec2(-0.018745,-0.009492),vec2(-0.023346,-0.023500),vec3(0.984,0.665,0.482),vec3(0.824,0.235,0.180));\n  sdLine(dis_col,pos,vec2( 0.004475, 0.004419),vec2(-0.019006,-0.009652),vec3(0.976,0.686,0.506),vec3(0.798,0.210,0.153));\n  sdLine(dis_col,pos,vec2( 0.078024,-0.000098),vec2( 0.004545, 0.004548),vec3(0.935,0.696,0.480),vec3(0.792,0.229,0.122));\n  sdLine(dis_col,pos,vec2( 0.129006,-0.035229),vec2( 0.078225,-0.000073),vec3(0.902,0.686,0.447),vec3(0.788,0.243,0.102),vec3(0.937,0.769,0.545),vec3(0.769,0.255,0.059));\n  sdLine(dis_col,pos,vec2( 0.214680,-0.370938),vec2( 0.167824,-0.202999),vec3(0.263,0.220,0.243),vec3(0.941,0.643,0.373));\n  sdLine(dis_col,pos,vec2( 0.117434,-0.128738),vec2(-0.023211,-0.023293),vec3(0.718,0.698,0.690),vec3(0.984,0.867,0.718));\n  sdLine(dis_col,pos,vec2(-0.027606,-0.023401),vec2(-0.250232, 0.058604),vec3(0.369,0.376,0.439),vec3(0.824,0.357,0.349));\n  sdLine(dis_col,pos,vec2( 0.224314,-0.490840),vec2( 0.214794,-0.371444),vec3(0.110,0.076,0.102),vec3(0.553,0.102,0.061));\n  sdLine(dis_col,pos,vec2( 0.210828,-0.578506),vec2( 0.224257,-0.490867),vec3(0.118,0.094,0.114),vec3(0.467,0.108,0.084));\n  sdLine(dis_col,pos,vec2(-0.738216, 0.577331),vec2(-0.835883, 0.550764),vec3(0.647,0.639,0.914),vec3(0.859,0.780,0.682));\n  sdLine(dis_col,pos,vec2(-0.428590, 0.601696),vec2(-0.738185, 0.577395),vec3(0.698,0.680,0.884),vec3(0.865,0.778,0.667));\n  sdLine(dis_col,pos,vec2(-0.257866, 0.593737),vec2(-0.428754, 0.601618),vec3(0.763,0.733,0.845),vec3(0.876,0.775,0.645));\n  sdLine(dis_col,pos,vec2(-0.136723, 0.554703),vec2(-0.257809, 0.593759),vec3(0.808,0.769,0.820),vec3(0.878,0.775,0.657));\n  sdLine(dis_col,pos,vec2(-0.910838, 0.948616),vec2(-0.980469, 0.968751),vec3(0.782,0.753,0.910),vec3(0.486,0.422,0.769));\n  sdLine(dis_col,pos,vec2(-0.849120, 0.905236),vec2(-0.910830, 0.948608),vec3(0.771,0.741,0.908),vec3(0.494,0.431,0.773));\n  sdLine(dis_col,pos,vec2(-0.805151, 0.844085),vec2(-0.849092, 0.905222),vec3(0.751,0.724,0.904),vec3(0.494,0.431,0.773));\n  sdLine(dis_col,pos,vec2(-0.792960, 0.808567),vec2(-0.805191, 0.844089),vec3(0.741,0.714,0.902),vec3(0.494,0.431,0.773));\n  sdLine(dis_col,pos,vec2(-0.660730, 0.350115),vec2(-0.687380, 0.324080),vec3(0.569,0.539,0.929),vec3(0.625,0.612,0.963));\n  sdLine(dis_col,pos,vec2(-0.581342, 0.390737),vec2(-0.660931, 0.350300),vec3(0.610,0.565,0.941),vec3(0.671,0.641,0.963));\n  sdLine(dis_col,pos,vec2(-0.519169, 0.405706),vec2(-0.581260, 0.390541),vec3(0.653,0.590,0.953),vec3(0.722,0.671,0.963));\n  sdLine(dis_col,pos,vec2(-0.325640, 0.410142),vec2(-0.519014, 0.405733),vec3(0.708,0.624,0.969),vec3(0.784,0.706,0.965));\n  sdLine(dis_col,pos,vec2(-0.265662, 0.386779),vec2(-0.325886, 0.410329),vec3(0.767,0.661,0.982),vec3(0.847,0.741,0.965));\n  sdLine(dis_col,pos,vec2(-0.890704, 0.394153),vec2(-0.996080, 0.374882),vec3(0.576,0.569,0.918),vec3(0.635,0.637,0.951));\n  sdLine(dis_col,pos,vec2(-0.808329, 0.393799),vec2(-0.890754, 0.394278),vec3(0.575,0.569,0.922),vec3(0.635,0.635,0.955));\n  sdLine(dis_col,pos,vec2(-0.746093, 0.374902),vec2(-0.808295, 0.393687),vec3(0.573,0.569,0.924),vec3(0.635,0.629,0.961));\n  sdLine(dis_col,pos,vec2(-0.691314, 0.328133),vec2(-0.746006, 0.375002),vec3(0.571,0.569,0.927),vec3(0.635,0.624,0.969));\n  sdLine(dis_col,pos,vec2(-0.713022, 0.223982),vec2(-0.699215, 0.078105),vec3(0.443,0.404,0.831),vec3(0.490,0.471,0.855),vec3(0.486,0.455,0.871),vec3(0.576,0.573,0.929));\n  sdLine(dis_col,pos,vec2(-0.687633, 0.328193),vec2(-0.713148, 0.224068),vec3(0.502,0.473,0.884),vec3(0.590,0.586,0.943));\n  sdLine(dis_col,pos,vec2(-0.962077,-0.021061),vec2(-0.984470,-0.062241),vec3(0.567,0.553,0.914),vec3(0.506,0.502,0.843));\n  sdLine(dis_col,pos,vec2(-0.929730, 0.012170),vec2(-0.962095,-0.021151),vec3(0.563,0.543,0.914),vec3(0.508,0.514,0.829));\n  sdLine(dis_col,pos,vec2(-0.842855, 0.056023),vec2(-0.929597, 0.011852),vec3(0.555,0.527,0.914),vec3(0.506,0.522,0.804));\n  sdLine(dis_col,pos,vec2(-0.740058, 0.072302),vec2(-0.842912, 0.056291),vec3(0.549,0.518,0.914),vec3(0.502,0.522,0.788),vec3(0.537,0.498,0.914),vec3(0.431,0.412,0.788));\n  sdLine(dis_col,pos,vec2(-0.648617, 0.066357),vec2(-0.739962, 0.072359),vec3(0.531,0.486,0.912),vec3(0.406,0.369,0.786));\n  sdLine(dis_col,pos,vec2(-0.599562, 0.052212),vec2(-0.648693, 0.066421),vec3(0.522,0.465,0.912),vec3(0.390,0.339,0.776));\n  sdLine(dis_col,pos,vec2(-0.523674,-0.011767),vec2(-0.599782, 0.051913),vec3(0.510,0.443,0.912),vec3(0.416,0.371,0.761));\n  sdLine(dis_col,pos,vec2(-0.216909, 0.467215),vec2(-0.261703, 0.386747),vec3(0.943,0.525,0.555),vec3(0.851,0.796,0.924));\n  sdLine(dis_col,pos,vec2(-0.140684, 0.554868),vec2(-0.216981, 0.467356),vec3(0.898,0.506,0.527),vec3(0.851,0.786,0.865));\n  sdLine(dis_col,pos,vec2(-0.294609, 0.328762),vec2(-0.320297, 0.253955),vec3(0.945,0.480,0.496),vec3(0.655,0.545,0.908));\n  sdLine(dis_col,pos,vec2(-0.261515, 0.386675),vec2(-0.294411, 0.328660),vec3(0.953,0.482,0.498),vec3(0.678,0.576,0.945),vec3(0.953,0.482,0.494),vec3(0.776,0.694,0.961));\n  sdLine(dis_col,pos,vec2(-0.320312, 0.152344),vec2(-0.320312, 0.250000),vec3(0.227,0.159,0.249),vec3(0.892,0.455,0.476));\n  sdLine(dis_col,pos,vec2(-0.285102, 0.093592),vec2(-0.320160, 0.152217),vec3(0.194,0.129,0.220),vec3(0.878,0.441,0.463));\n  sdLine(dis_col,pos,vec2(-0.249821, 0.058499),vec2(-0.285083, 0.093620),vec3(0.206,0.137,0.220),vec3(0.861,0.422,0.445));\n  sdLine(dis_col,pos,vec2(-0.370886, 0.200884),vec2(-0.296881, 0.058849),vec3(0.210,0.208,0.296),vec3(0.506,0.441,0.829));\n  sdLine(dis_col,pos,vec2(-0.371080, 0.218669),vec2(-0.370863, 0.200571),vec3(0.216,0.208,0.275),vec3(0.539,0.473,0.853));\n  sdLine(dis_col,pos,vec2(-0.320338, 0.250030),vec2(-0.371125, 0.218779),vec3(0.214,0.182,0.245),vec3(0.573,0.504,0.873));\n  sdLine(dis_col,pos,vec2(-0.318397, 0.038871),vec2(-0.296987, 0.058686),vec3(0.408,0.345,0.751),vec3(0.235,0.243,0.371));\n  sdLine(dis_col,pos,vec2(-0.335799, 0.000126),vec2(-0.318147, 0.038906),vec3(0.394,0.337,0.686),vec3(0.225,0.229,0.355));\n  sdLine(dis_col,pos,vec2(-0.457045, 0.015479),vec2(-0.343771, 0.003763),vec3(0.404,0.341,0.757),vec3(0.714,0.702,0.792),vec3(0.427,0.369,0.796),vec3(0.478,0.443,0.510));\n  sdLine(dis_col,pos,vec2(-0.524601,-0.011832),vec2(-0.457157, 0.015632),vec3(0.427,0.369,0.796),vec3(0.478,0.443,0.510),vec3(0.475,0.424,0.792),vec3(0.627,0.596,0.741));\n  sdLine(dis_col,pos,vec2(-0.567845,-0.048929),vec2(-0.524475,-0.011939),vec3(0.475,0.424,0.792),vec3(0.627,0.596,0.741),vec3(0.545,0.490,0.871),vec3(0.522,0.490,0.647));\n  sdLine(dis_col,pos,vec2(-0.687512,-0.202819),vec2(-0.567697,-0.048786),vec3(0.545,0.490,0.871),vec3(0.522,0.490,0.647),vec3(0.749,0.706,0.980),vec3(0.702,0.651,0.710));\n  sdLine(dis_col,pos,vec2(-0.738370,-0.246033),vec2(-0.687782,-0.202852),vec3(0.749,0.706,0.980),vec3(0.702,0.651,0.710),vec3(0.690,0.651,0.929),vec3(0.259,0.235,0.337));\n  sdLine(dis_col,pos,vec2(-0.819820,-0.267858),vec2(-0.738322,-0.246131),vec3(0.690,0.651,0.929),vec3(0.259,0.235,0.337),vec3(0.631,0.604,0.933),vec3(0.380,0.333,0.416));\n  sdLine(dis_col,pos,vec2(-0.925652,-0.360953),vec2(-0.819489,-0.267857),vec3(0.631,0.604,0.933),vec3(0.380,0.333,0.416),vec3(0.525,0.502,0.808),vec3(0.243,0.188,0.333));\n  sdLine(dis_col,pos,vec2(-0.924077,-0.382938),vec2(-0.926012,-0.360824),vec3(0.525,0.502,0.808),vec3(0.243,0.188,0.333),vec3(0.506,0.478,0.733),vec3(0.541,0.486,0.631));\n  sdLine(dis_col,pos,vec2(-0.908709,-0.396678),vec2(-0.923914,-0.383129),vec3(0.502,0.473,0.714),vec3(0.524,0.476,0.637));\n  sdLine(dis_col,pos,vec2(-0.877801,-0.327818),vec2(-0.908834,-0.396482),vec3(0.498,0.467,0.694),vec3(0.506,0.467,0.643),vec3(0.584,0.565,0.894),vec3(0.490,0.439,0.659));\n  sdLine(dis_col,pos,vec2(-0.850665,-0.306523),vec2(-0.877737,-0.328046),vec3(0.584,0.565,0.894),vec3(0.490,0.439,0.659),vec3(0.553,0.510,0.765),vec3(0.329,0.278,0.439));\n  sdLine(dis_col,pos,vec2(-0.842943,-0.336355),vec2(-0.850644,-0.306423),vec3(0.553,0.510,0.765),vec3(0.329,0.278,0.439),vec3(0.518,0.478,0.761),vec3(0.537,0.494,0.643));\n  sdLine(dis_col,pos,vec2(-0.646520,-0.253453),vec2(-0.842985,-0.336477),vec3(0.518,0.478,0.761),vec3(0.537,0.494,0.643),vec3(0.671,0.620,0.957),vec3(0.467,0.392,0.565));\n  sdLine(dis_col,pos,vec2(-0.613162,-0.227037),vec2(-0.646645,-0.253104),vec3(0.651,0.602,0.945),vec3(0.469,0.398,0.555));\n  sdLine(dis_col,pos,vec2(-0.561901,-0.162148),vec2(-0.613081,-0.227201),vec3(0.594,0.549,0.910),vec3(0.476,0.429,0.539));\n  sdLine(dis_col,pos,vec2(-0.500240,-0.050707),vec2(-0.562155,-0.162105),vec3(0.557,0.514,0.886),vec3(0.482,0.455,0.533),vec3(0.443,0.408,0.812),vec3(0.286,0.267,0.369));\n  sdLine(dis_col,pos,vec2(-0.464788,-0.030266),vec2(-0.500093,-0.050719),vec3(0.443,0.408,0.812),vec3(0.286,0.267,0.369),vec3(0.408,0.376,0.780),vec3(0.157,0.114,0.267));\n  sdLine(dis_col,pos,vec2(-0.439427,-0.045861),vec2(-0.464616,-0.030239),vec3(0.408,0.376,0.780),vec3(0.157,0.114,0.267),vec3(0.455,0.427,0.784),vec3(0.416,0.353,0.435));\n  sdLine(dis_col,pos,vec2(-0.421871,-0.081990),vec2(-0.439501,-0.045912),vec3(0.443,0.418,0.773),vec3(0.404,0.369,0.437));\n  sdLine(dis_col,pos,vec2(-0.386711,-0.105557),vec2(-0.421868,-0.082119),vec3(0.431,0.408,0.761),vec3(0.392,0.384,0.439),vec3(0.357,0.349,0.655),vec3(0.376,0.427,0.447));\n  sdLine(dis_col,pos,vec2(-0.339923, 0.003866),vec2(-0.386802,-0.101587),vec3(0.200,0.196,0.267),vec3(0.345,0.333,0.365));\n  sdLine(dis_col,pos,vec2(-0.407061,-0.201258),vec2(-0.386665,-0.105627),vec3(0.361,0.341,0.624),vec3(0.792,0.812,0.751));\n  sdLine(dis_col,pos,vec2(-0.403323,-0.268221),vec2(-0.406911,-0.201492),vec3(0.363,0.329,0.606),vec3(0.771,0.769,0.724));\n  sdLine(dis_col,pos,vec2(-0.390770,-0.273672),vec2(-0.403673,-0.268054),vec3(0.384,0.333,0.643),vec3(0.771,0.749,0.704));\n  sdLine(dis_col,pos,vec2(-0.345881,-0.060745),vec2(-0.386656,-0.101656),vec3(0.776,0.835,0.784),vec3(0.361,0.400,0.427),vec3(0.792,0.839,0.780),vec3(0.145,0.176,0.227));\n  sdLine(dis_col,pos,vec2(-0.328983,-0.056141),vec2(-0.345818,-0.060743),vec3(0.792,0.839,0.780),vec3(0.145,0.176,0.227),vec3(0.808,0.847,0.780),vec3(0.220,0.251,0.310));\n  sdLine(dis_col,pos,vec2(-0.252749,-0.126588),vec2(-0.329397,-0.055845),vec3(0.837,0.859,0.775),vec3(0.227,0.247,0.306));\n  sdLine(dis_col,pos,vec2(-0.230481,-0.160125),vec2(-0.252484,-0.126757),vec3(0.867,0.871,0.769),vec3(0.235,0.243,0.302),vec3(0.859,0.851,0.749),vec3(0.161,0.153,0.204));\n  sdLine(dis_col,pos,vec2(-0.226341,-0.219167),vec2(-0.230372,-0.160222),vec3(0.882,0.869,0.757),vec3(0.151,0.133,0.180));\n  sdLine(dis_col,pos,vec2(-0.277439,-0.343654),vec2(-0.226534,-0.219015),vec3(0.906,0.886,0.765),vec3(0.141,0.114,0.157),vec3(0.929,0.898,0.761),vec3(0.251,0.212,0.239));\n  sdLine(dis_col,pos,vec2(-0.331270,-0.274257),vec2(-0.390414,-0.273335),vec3(0.076,0.061,0.096),vec3(0.808,0.780,0.714));\n  sdLine(dis_col,pos,vec2(-0.307108,-0.285553),vec2(-0.331497,-0.274239),vec3(0.075,0.059,0.094),vec3(0.829,0.806,0.718));\n  sdLine(dis_col,pos,vec2(-0.285269,-0.316297),vec2(-0.307202,-0.285572),vec3(0.075,0.059,0.094),vec3(0.835,0.820,0.722));\n  sdLine(dis_col,pos,vec2(-0.277101,-0.348165),vec2(-0.284918,-0.316904),vec3(0.075,0.059,0.094),vec3(0.831,0.820,0.722),vec3(0.086,0.063,0.102),vec3(0.620,0.584,0.522));\n  sdLine(dis_col,pos,vec2( 0.191818,-0.655109),vec2( 0.210666,-0.574643),vec3(0.137,0.122,0.129),vec3(0.729,0.608,0.541),vec3(0.145,0.133,0.133),vec3(0.804,0.737,0.616));\n  sdLine(dis_col,pos,vec2( 0.177802,-0.664657),vec2( 0.191779,-0.655002),vec3(0.145,0.133,0.133),vec3(0.804,0.737,0.616),vec3(0.063,0.059,0.075),vec3(0.796,0.753,0.620));\n  sdLine(dis_col,pos,vec2( 0.168515,-0.738957),vec2( 0.178126,-0.664256),vec3(0.096,0.092,0.100),vec3(0.812,0.759,0.625));\n  sdLine(dis_col,pos,vec2( 0.155592,-0.752345),vec2( 0.168584,-0.738793),vec3(0.104,0.100,0.102),vec3(0.824,0.757,0.627));\n  sdLine(dis_col,pos,vec2( 0.132513,-0.757861),vec2( 0.155207,-0.752647),vec3(0.073,0.069,0.073),vec3(0.820,0.747,0.624));\n  sdLine(dis_col,pos,vec2( 0.086261,-0.759725),vec2(-0.023197,-0.695559),vec3(0.157,0.141,0.184),vec3(0.063,0.055,0.067),vec3(0.286,0.275,0.325),vec3(0.055,0.043,0.055));\n  sdLine(dis_col,pos,vec2( 0.132843,-0.757744),vec2( 0.086059,-0.759407),vec3(0.286,0.275,0.325),vec3(0.055,0.043,0.055),vec3(0.761,0.722,0.522),vec3(0.059,0.043,0.059));\n  sdLine(dis_col,pos,vec2(-0.008536,-0.523957),vec2(-0.113095,-0.546922),vec3(0.761,0.722,0.522),vec3(0.051,0.033,0.051));\n  sdLine(dis_col,pos,vec2( 0.028417,-0.535309),vec2(-0.008810,-0.523762),vec3(0.792,0.767,0.563),vec3(0.055,0.041,0.057));\n  sdLine(dis_col,pos,vec2( 0.049655,-0.559962),vec2( 0.028517,-0.535386),vec3(0.798,0.782,0.580),vec3(0.076,0.065,0.073));\n  sdLine(dis_col,pos,vec2( 0.071714,-0.659300),vec2( 0.049649,-0.559687),vec3(0.771,0.751,0.557),vec3(0.082,0.073,0.080));\n  sdLine(dis_col,pos,vec2( 0.062107,-0.673453),vec2( 0.072068,-0.659420),vec3(0.731,0.704,0.520),vec3(0.088,0.080,0.088));\n  sdLine(dis_col,pos,vec2(-0.019664,-0.695497),vec2( 0.061596,-0.673865),vec3(0.722,0.694,0.514),vec3(0.090,0.082,0.090),vec3(0.722,0.690,0.502),vec3(0.220,0.216,0.180));\n  sdLine(dis_col,pos,vec2(-0.103143,-0.577233),vec2(-0.113704,-0.546335),vec3(0.078,0.063,0.094),vec3(0.669,0.586,0.406));\n  sdLine(dis_col,pos,vec2(-0.128872,-0.656514),vec2(-0.102680,-0.578043),vec3(0.078,0.063,0.094),vec3(0.643,0.573,0.396),vec3(0.078,0.063,0.094),vec3(0.545,0.506,0.349));\n  sdLine(dis_col,pos,vec2(-0.110341,-0.684318),vec2(-0.132708,-0.656415),vec3(0.090,0.076,0.129),vec3(0.712,0.680,0.494));\n  sdLine(dis_col,pos,vec2(-0.065097,-0.698489),vec2(-0.110606,-0.684138),vec3(0.106,0.094,0.133),vec3(0.712,0.680,0.494));\n  sdLine(dis_col,pos,vec2(-0.023516,-0.695404),vec2(-0.065017,-0.698593),vec3(0.124,0.112,0.137),vec3(0.718,0.686,0.498));\n  sdLine(dis_col,pos,vec2(-0.356409,-0.396602),vec2(-0.363344,-0.417840),vec3(0.667,0.684,0.514),vec3(0.086,0.073,0.102));\n  sdLine(dis_col,pos,vec2(-0.329514,-0.372734),vec2(-0.356301,-0.396902),vec3(0.678,0.694,0.525),vec3(0.098,0.086,0.110),vec3(0.796,0.792,0.624),vec3(0.075,0.059,0.094));\n  sdLine(dis_col,pos,vec2(-0.304495,-0.384405),vec2(-0.329372,-0.372760),vec3(0.794,0.786,0.625),vec3(0.073,0.055,0.094));\n  sdLine(dis_col,pos,vec2(-0.304686,-0.445287),vec2(-0.304686,-0.384176),vec3(0.792,0.780,0.627),vec3(0.071,0.051,0.094),vec3(0.678,0.667,0.541),vec3(0.071,0.047,0.094));\n  sdLine(dis_col,pos,vec2(-0.329703,-0.471680),vec2(-0.304762,-0.445327),vec3(0.678,0.667,0.541),vec3(0.071,0.047,0.094),vec3(0.533,0.522,0.427),vec3(0.071,0.051,0.094));\n  sdLine(dis_col,pos,vec2(-0.352235,-0.461623),vec2(-0.329757,-0.471344),vec3(0.504,0.494,0.406),vec3(0.071,0.051,0.094));\n  sdLine(dis_col,pos,vec2(-0.363307,-0.418071),vec2(-0.352136,-0.462043),vec3(0.475,0.467,0.384),vec3(0.071,0.051,0.094),vec3(0.561,0.565,0.439),vec3(0.129,0.118,0.137));\n  sdLine(dis_col,pos,vec2(-0.276110,-0.521710),vec2(-0.289045,-0.550497),vec3(0.641,0.637,0.478),vec3(0.035,0.033,0.063));\n  sdLine(dis_col,pos,vec2(-0.258075,-0.516729),vec2(-0.275890,-0.521970),vec3(0.684,0.682,0.514),vec3(0.047,0.045,0.075));\n  sdLine(dis_col,pos,vec2(-0.206378,-0.541564),vec2(-0.258683,-0.516738),vec3(0.706,0.706,0.529),vec3(0.047,0.047,0.078),vec3(0.792,0.788,0.600),vec3(0.051,0.055,0.063));\n  sdLine(dis_col,pos,vec2(-0.187895,-0.563812),vec2(-0.206382,-0.541493),vec3(0.757,0.753,0.576),vec3(0.063,0.057,0.078));\n  sdLine(dis_col,pos,vec2(-0.189739,-0.573083),vec2(-0.187133,-0.563528),vec3(0.735,0.731,0.561),vec3(0.075,0.059,0.094));\n  sdLine(dis_col,pos,vec2(-0.251815,-0.589992),vec2(-0.189995,-0.573544),vec3(0.749,0.745,0.569),vec3(0.075,0.059,0.094),vec3(0.498,0.502,0.345),vec3(0.075,0.063,0.098));\n  sdLine(dis_col,pos,vec2(-0.272446,-0.579505),vec2(-0.251715,-0.590033),vec3(0.514,0.518,0.363),vec3(0.075,0.063,0.098));\n  sdLine(dis_col,pos,vec2(-0.289115,-0.550792),vec2(-0.272717,-0.579388),vec3(0.549,0.551,0.398),vec3(0.086,0.075,0.106));\n  sdLine(dis_col,pos,vec2(-0.192736,-0.469520),vec2(-0.277483,-0.347082),vec3(0.108,0.076,0.120),vec3(0.065,0.057,0.090));\n  sdLine(dis_col,pos,vec2(-0.113128,-0.547007),vec2(-0.192449,-0.470244),vec3(0.080,0.045,0.080),vec3(0.063,0.047,0.073));\n  sdLine(dis_col,pos,vec2(-0.399689,-0.363777),vec2(-0.390465,-0.273580),vec3(0.355,0.292,0.675),vec3(0.088,0.075,0.112));\n  sdLine(dis_col,pos,vec2(-0.414173,-0.390763),vec2(-0.399958,-0.363772),vec3(0.347,0.288,0.651),vec3(0.090,0.075,0.110));\n  sdLine(dis_col,pos,vec2( 0.402104,-0.164371),vec2( 0.429754,-0.097640),vec3(0.237,0.182,0.180),vec3(0.784,0.296,0.143));\n  sdLine(dis_col,pos,vec2( 0.366996,-0.206976),vec2( 0.401848,-0.164337),vec3(0.210,0.145,0.145),vec3(0.778,0.304,0.147));\n  sdLine(dis_col,pos,vec2( 0.296913,-0.238165),vec2( 0.367225,-0.206912),vec3(0.194,0.118,0.120),vec3(0.743,0.304,0.149));\n  sdLine(dis_col,pos,vec2( 0.167900,-0.203204),vec2( 0.113213,-0.128975),vec3(0.706,0.690,0.678),vec3(0.145,0.110,0.157));\n  sdLine(dis_col,pos,vec2( 0.454448,-0.085567),vec2( 0.429490,-0.097974),vec3(0.898,0.478,0.357),vec3(0.945,0.643,0.580));\n  sdLine(dis_col,pos,vec2( 0.501070,-0.040927),vec2( 0.454701,-0.085293),vec3(0.898,0.475,0.349),vec3(0.941,0.631,0.561),vec3(0.902,0.439,0.278),vec3(0.910,0.525,0.416));\n  sdLine(dis_col,pos,vec2( 0.536751, 0.019080),vec2( 0.501035,-0.040870),vec3(0.904,0.425,0.247),vec3(0.902,0.502,0.384));\n  sdLine(dis_col,pos,vec2( 0.554739, 0.081950),vec2( 0.536789, 0.018991),vec3(0.906,0.412,0.216),vec3(0.900,0.508,0.390));\n  sdLine(dis_col,pos,vec2( 0.535861, 0.166934),vec2( 0.554677, 0.082064),vec3(0.906,0.412,0.216),vec3(0.906,0.537,0.427),vec3(0.906,0.416,0.224),vec3(0.925,0.647,0.557));\n  sdLine(dis_col,pos,vec2( 0.419826, 0.338301),vec2( 0.535615, 0.166647),vec3(0.906,0.414,0.220),vec3(0.920,0.614,0.524));\n  sdLine(dis_col,pos,vec2( 0.406078, 0.390921),vec2( 0.419883, 0.338831),vec3(0.906,0.412,0.216),vec3(0.910,0.565,0.473));\n  sdLine(dis_col,pos,vec2( 0.146477, 0.567224),vec2( 0.031189, 0.523314),vec3(0.863,0.475,0.404),vec3(0.963,0.447,0.278));\n  sdLine(dis_col,pos,vec2( 0.238636, 0.574102),vec2( 0.146891, 0.567233),vec3(0.869,0.484,0.425),vec3(0.957,0.427,0.241));\n  sdLine(dis_col,pos,vec2( 0.276654, 0.562718),vec2( 0.238421, 0.574198),vec3(0.876,0.496,0.445),vec3(0.949,0.400,0.192));\n  sdLine(dis_col,pos,vec2( 0.328054, 0.527362),vec2( 0.276439, 0.562762),vec3(0.880,0.508,0.463),vec3(0.939,0.382,0.165));\n  sdLine(dis_col,pos,vec2( 0.407058, 0.213498),vec2( 0.371072, 0.195345),vec3(0.988,0.973,0.969),vec3(0.992,0.855,0.831));\n  sdLine(dis_col,pos,vec2( 0.458303, 0.213407),vec2( 0.407282, 0.213566),vec3(0.988,0.973,0.969),vec3(0.992,0.855,0.831));\n  sdLine(dis_col,pos,vec2( 0.481278, 0.196816),vec2( 0.457990, 0.213665),vec3(0.988,0.973,0.967),vec3(0.992,0.855,0.829));\n  sdLine(dis_col,pos,vec2( 0.499009, 0.163011),vec2( 0.481392, 0.196333),vec3(0.988,0.973,0.965),vec3(0.992,0.855,0.827));\n  sdLine(dis_col,pos,vec2( 0.503604, 0.090461),vec2( 0.499073, 0.163192),vec3(0.988,0.971,0.965),vec3(0.990,0.855,0.827));\n  sdLine(dis_col,pos,vec2( 0.489446, 0.076448),vec2( 0.503554, 0.090238),vec3(0.988,0.969,0.963),vec3(0.986,0.847,0.816));\n  sdLine(dis_col,pos,vec2( 0.443782, 0.062339),vec2( 0.489220, 0.076528),vec3(0.986,0.969,0.961),vec3(0.986,0.845,0.814));\n  sdLine(dis_col,pos,vec2( 0.378683, 0.066466),vec2( 0.443770, 0.062469),vec3(0.984,0.969,0.959),vec3(0.988,0.851,0.822));\n  sdLine(dis_col,pos,vec2( 0.339578, 0.097522),vec2( 0.378706, 0.066500),vec3(0.984,0.967,0.957),vec3(0.986,0.851,0.820));\n  sdLine(dis_col,pos,vec2( 0.329906, 0.140698),vec2( 0.339788, 0.097651),vec3(0.984,0.965,0.955),vec3(0.984,0.851,0.818));\n  sdLine(dis_col,pos,vec2( 0.349815, 0.180720),vec2( 0.329907, 0.140407),vec3(0.984,0.965,0.953),vec3(0.982,0.849,0.814));\n  sdLine(dis_col,pos,vec2( 0.371027, 0.195457),vec2( 0.349730, 0.180934),vec3(0.984,0.965,0.953),vec3(0.982,0.849,0.814));\n  sdLine(dis_col,pos,vec2(-0.117425, 0.341220),vec2(-0.074257, 0.417986),vec3(0.847,0.318,0.216),vec3(0.794,0.425,0.357));\n  sdLine(dis_col,pos,vec2(-0.131058, 0.286069),vec2(-0.117280, 0.341245),vec3(0.847,0.318,0.216),vec3(0.814,0.429,0.355));\n  sdLine(dis_col,pos,vec2(-0.120979, 0.239269),vec2(-0.131229, 0.286301),vec3(0.847,0.318,0.216),vec3(0.831,0.435,0.355));\n  sdLine(dis_col,pos,vec2(-0.094915, 0.195662),vec2(-0.120748, 0.238869),vec3(0.853,0.308,0.194),vec3(0.847,0.439,0.355));\n  sdLine(dis_col,pos,vec2(-0.058454, 0.163892),vec2(-0.094941, 0.195621),vec3(0.861,0.296,0.171),vec3(0.861,0.439,0.351));\n  sdLine(dis_col,pos,vec2( 0.096154, 0.101755),vec2(-0.058568, 0.164000),vec3(0.855,0.304,0.188),vec3(0.884,0.443,0.349));\n  sdLine(dis_col,pos,vec2( 0.148627, 0.066296),vec2( 0.096309, 0.101713),vec3(0.845,0.316,0.214),vec3(0.906,0.447,0.349));\n  sdLine(dis_col,pos,vec2( 0.238337,-0.218583),vec2( 0.296931,-0.238114),vec3(0.188,0.059,0.055),vec3(0.941,0.714,0.384));\n  sdLine(dis_col,pos,vec2( 0.356732, 0.495659),vec2( 0.328217, 0.527093),vec3(0.475,0.510,0.604),vec3(0.418,0.445,0.533));\n  sdLine(dis_col,pos,vec2( 0.406416, 0.390930),vec2( 0.356795, 0.496206),vec3(0.475,0.510,0.604),vec3(0.398,0.414,0.496));\n  sdLine(dis_col,pos,vec2( 0.351847, 0.563942),vec2( 0.328272, 0.527247),vec3(0.439,0.475,0.569),vec3(0.725,0.459,0.408),vec3(0.443,0.475,0.569),vec3(0.882,0.420,0.259));\n  sdLine(dis_col,pos,vec2( 0.386954, 0.567493),vec2( 0.352309, 0.564131),vec3(0.431,0.453,0.537),vec3(0.884,0.416,0.247));\n  sdLine(dis_col,pos,vec2( 0.434360, 0.555848),vec2( 0.386390, 0.567397),vec3(0.420,0.431,0.506),vec3(0.886,0.412,0.235),vec3(0.361,0.341,0.396),vec3(0.882,0.416,0.247));\n  sdLine(dis_col,pos,vec2( 0.481493, 0.527439),vec2( 0.434614, 0.555661),vec3(0.376,0.353,0.406),vec3(0.882,0.416,0.247));\n  sdLine(dis_col,pos,vec2( 0.556668, 0.460958),vec2( 0.481472, 0.527483),vec3(0.392,0.365,0.416),vec3(0.882,0.416,0.247),vec3(0.522,0.502,0.557),vec3(0.882,0.412,0.247));\n  sdLine(dis_col,pos,vec2( 0.568077, 0.433950),vec2( 0.556441, 0.461051),vec3(0.524,0.506,0.563),vec3(0.880,0.414,0.247));\n  sdLine(dis_col,pos,vec2( 0.550912, 0.394412),vec2( 0.568131, 0.433870),vec3(0.494,0.480,0.541),vec3(0.880,0.416,0.247));\n  sdLine(dis_col,pos,vec2( 0.490768, 0.382274),vec2( 0.550937, 0.394469),vec3(0.422,0.425,0.496),vec3(0.882,0.416,0.247));\n  sdLine(dis_col,pos,vec2( 0.406039, 0.390810),vec2( 0.490402, 0.382519),vec3(0.375,0.382,0.457),vec3(0.882,0.418,0.253));\n  sdLine(dis_col,pos,vec2( 0.330744, 0.478846),vec2( 0.328238, 0.527133),vec3(0.908,0.586,0.498),vec3(0.475,0.510,0.604));\n  sdLine(dis_col,pos,vec2( 0.365538, 0.422127),vec2( 0.330688, 0.479010),vec3(0.910,0.588,0.498),vec3(0.475,0.510,0.604));\n  sdLine(dis_col,pos,vec2( 0.406309, 0.390576),vec2( 0.365537, 0.422123),vec3(0.910,0.588,0.498),vec3(0.475,0.502,0.592));\n  sdLine(dis_col,pos,vec2( 0.037170, 0.502175),vec2( 0.031325, 0.523294),vec3(0.357,0.220,0.255),vec3(0.725,0.404,0.349),vec3(0.357,0.220,0.255),vec3(0.914,0.506,0.408));\n  sdLine(dis_col,pos,vec2( 0.009112, 0.456598),vec2( 0.036991, 0.502416),vec3(0.357,0.220,0.255),vec3(0.900,0.484,0.404));\n  sdLine(dis_col,pos,vec2(-0.014264, 0.437994),vec2( 0.009264, 0.456398),vec3(0.357,0.220,0.255),vec3(0.882,0.457,0.398));\n  sdLine(dis_col,pos,vec2(-0.074384, 0.418060),vec2(-0.014479, 0.438192),vec3(0.357,0.220,0.255),vec3(0.873,0.443,0.394));\n  sdLine(dis_col,pos,vec2(-0.034865, 0.469095),vec2(-0.074326, 0.418051),vec3(0.357,0.220,0.255),vec3(0.325,0.153,0.310));\n  sdLine(dis_col,pos,vec2( 0.031160, 0.519567),vec2(-0.034850, 0.469051),vec3(0.357,0.220,0.255),vec3(0.312,0.147,0.269));\n  sdLine(dis_col,pos,vec2(-0.476788,-0.270699),vec2(-0.413803,-0.390958),vec3(0.400,0.333,0.724),vec3(0.529,0.406,0.447));\n  sdLine(dis_col,pos,vec2(-0.515771,-0.226315),vec2(-0.477190,-0.270110),vec3(0.439,0.367,0.784),vec3(0.571,0.437,0.476));\n  sdLine(dis_col,pos,vec2(-0.548925,-0.216192),vec2(-0.515512,-0.226748),vec3(0.475,0.408,0.808),vec3(0.588,0.451,0.490),vec3(0.580,0.529,0.878),vec3(0.404,0.282,0.416));\n  sdLine(dis_col,pos,vec2(-0.563920,-0.221379),vec2(-0.548931,-0.216115),vec3(0.580,0.529,0.878),vec3(0.404,0.282,0.416),vec3(0.671,0.635,0.937),vec3(0.533,0.455,0.702));\n  sdLine(dis_col,pos,vec2(-0.487346,-0.300005),vec2(-0.564121,-0.221089),vec3(0.671,0.635,0.937),vec3(0.533,0.455,0.702),vec3(0.502,0.459,0.749),vec3(0.522,0.392,0.561));\n  sdLine(dis_col,pos,vec2(-0.456709,-0.351242),vec2(-0.487322,-0.300058),vec3(0.502,0.459,0.749),vec3(0.522,0.392,0.561),vec3(0.396,0.349,0.639),vec3(0.412,0.290,0.471));\n  sdLine(dis_col,pos,vec2(-0.437438,-0.426111),vec2(-0.456570,-0.351699),vec3(0.396,0.349,0.639),vec3(0.412,0.290,0.471),vec3(0.294,0.243,0.537),vec3(0.553,0.475,0.596));\n  sdLine(dis_col,pos,vec2(-0.426103,-0.437341),vec2(-0.437819,-0.425625),vec3(0.294,0.243,0.537),vec3(0.553,0.475,0.596),vec3(0.380,0.345,0.600),vec3(0.659,0.600,0.761));\n  sdLine(dis_col,pos,vec2(-0.137942,-0.735671),vec2(-0.234693,-0.652174),vec3(0.390,0.329,0.331),vec3(0.078,0.075,0.145));\n  sdLine(dis_col,pos,vec2(-0.101453,-0.787596),vec2(-0.137531,-0.736006),vec3(0.376,0.318,0.302),vec3(0.067,0.067,0.141),vec3(0.729,0.698,0.671),vec3(0.051,0.055,0.137));\n  sdLine(dis_col,pos,vec2(-0.093467,-0.816814),vec2(-0.101262,-0.787835),vec3(0.729,0.698,0.671),vec3(0.051,0.055,0.137),vec3(0.592,0.549,0.522),vec3(0.059,0.059,0.141));\n  sdLine(dis_col,pos,vec2(-0.101072,-0.835520),vec2(-0.094078,-0.816636),vec3(0.592,0.549,0.522),vec3(0.059,0.059,0.141),vec3(0.427,0.369,0.341),vec3(0.067,0.067,0.145));\n  sdLine(dis_col,pos,vec2(-0.120105,-0.842187),vec2(-0.100815,-0.835333),vec3(0.427,0.369,0.341),vec3(0.067,0.067,0.145),vec3(0.541,0.467,0.439),vec3(0.129,0.129,0.192));\n  sdLine(dis_col,pos,vec2(-0.139116,-0.832593),vec2(-0.120099,-0.842135),vec3(0.541,0.467,0.439),vec3(0.129,0.129,0.192),vec3(0.651,0.561,0.541),vec3(0.220,0.212,0.298));\n  sdLine(dis_col,pos,vec2(-0.182775,-0.748898),vec2(-0.139277,-0.832422),vec3(0.651,0.561,0.541),vec3(0.220,0.212,0.298),vec3(0.176,0.090,0.090),vec3(0.329,0.290,0.529));\n  sdLine(dis_col,pos,vec2(-0.242482,-0.691315),vec2(-0.182860,-0.748982),vec3(0.176,0.090,0.090),vec3(0.329,0.290,0.529),vec3(0.376,0.247,0.227),vec3(0.247,0.212,0.412));\n  sdLine(dis_col,pos,vec2(-0.376186,-0.507215),vec2(-0.414107,-0.390583),vec3(0.341,0.347,0.365),vec3(0.071,0.061,0.108));\n  sdLine(dis_col,pos,vec2(-0.334872,-0.560660),vec2(-0.375961,-0.507315),vec3(0.347,0.353,0.337),vec3(0.061,0.051,0.096));\n  sdLine(dis_col,pos,vec2(-0.234322,-0.652779),vec2(-0.334981,-0.561046),vec3(0.333,0.337,0.322),vec3(0.059,0.047,0.090),vec3(0.251,0.251,0.255),vec3(0.067,0.063,0.098));\n  sdLine(dis_col,pos,vec2(-0.443668,-0.478495),vec2(-0.425835,-0.437392),vec3(0.365,0.322,0.592),vec3(0.392,0.392,0.510),vec3(0.353,0.310,0.580),vec3(0.235,0.227,0.365));\n  sdLine(dis_col,pos,vec2(-0.439128,-0.529675),vec2(-0.443433,-0.478735),vec3(0.353,0.310,0.580),vec3(0.235,0.227,0.365),vec3(0.282,0.275,0.471),vec3(0.110,0.106,0.200));\n  sdLine(dis_col,pos,vec2(-0.375449,-0.627070),vec2(-0.439486,-0.529481),vec3(0.282,0.275,0.471),vec3(0.110,0.106,0.200),vec3(0.361,0.314,0.592),vec3(0.110,0.102,0.133));\n  sdLine(dis_col,pos,vec2(-0.332113,-0.645086),vec2(-0.375323,-0.626910),vec3(0.361,0.314,0.592),vec3(0.131,0.122,0.145));\n  sdLine(dis_col,pos,vec2(-0.265559,-0.648265),vec2(-0.332002,-0.645122),vec3(0.361,0.314,0.592),vec3(0.165,0.153,0.165));\n  sdLine(dis_col,pos,vec2( 0.205231,-0.817938),vec2( 0.109033,-0.765411),vec3(0.429,0.459,0.576),vec3(0.820,0.737,0.624));\n  sdLine(dis_col,pos,vec2( 0.293818,-0.895384),vec2( 0.205808,-0.818524),vec3(0.447,0.478,0.592),vec3(0.820,0.737,0.624),vec3(0.529,0.557,0.659),vec3(0.820,0.737,0.624));\n  sdLine(dis_col,pos,vec2( 0.354093,-0.996256),vec2( 0.293952,-0.895611),vec3(0.529,0.557,0.659),vec3(0.820,0.737,0.624),vec3(0.612,0.635,0.722),vec3(0.820,0.737,0.624));\n  sdLine(dis_col,pos,vec2( 0.367427,-1.054936),vec2( 0.353965,-0.995872),vec3(0.612,0.635,0.722),vec3(0.820,0.737,0.624),vec3(0.725,0.690,0.663),vec3(0.816,0.737,0.624));\n  sdLine(dis_col,pos,vec2(-0.954948,-0.473706),vec2(-0.984357,-0.410454),vec3(0.161,0.147,0.363),vec3(0.398,0.363,0.714));\n  sdLine(dis_col,pos,vec2(-0.903811,-0.638807),vec2(-0.954931,-0.473614),vec3(0.153,0.141,0.349),vec3(0.404,0.369,0.718),vec3(0.067,0.063,0.188),vec3(0.420,0.392,0.722));\n  sdLine(dis_col,pos,vec2(-0.875055,-0.699107),vec2(-0.903928,-0.638463),vec3(0.073,0.069,0.202),vec3(0.408,0.380,0.702));\n  sdLine(dis_col,pos,vec2(-0.629447,-0.956558),vec2(-0.687403,-0.870736),vec3(0.029,0.029,0.135),vec3(0.120,0.114,0.286));\n  sdLine(dis_col,pos,vec2(-0.605535,-1.023209),vec2(-0.629620,-0.956694),vec3(0.029,0.029,0.125),vec3(0.096,0.096,0.247));\n  sdLine(dis_col,pos,vec2(-0.265320,-0.663013),vec2(-0.242156,-0.691406),vec3(0.216,0.129,0.125),vec3(0.361,0.310,0.592),vec3(0.325,0.267,0.251),vec3(0.361,0.310,0.592));\n  sdLine(dis_col,pos,vec2(-0.265459,-0.648465),vec2(-0.265186,-0.663040),vec3(0.355,0.298,0.288),vec3(0.355,0.306,0.580));\n  sdLine(dis_col,pos,vec2(-0.630864,-0.893412),vec2(-0.687487,-0.870996),vec3(0.125,0.112,0.275),vec3(0.259,0.253,0.482));\n  sdLine(dis_col,pos,vec2(-0.586520,-0.885655),vec2(-0.630843,-0.893310),vec3(0.108,0.092,0.233),vec3(0.208,0.206,0.418));\n  sdLine(dis_col,pos,vec2(-0.487897,-0.819075),vec2(-0.586679,-0.885778),vec3(0.104,0.088,0.218),vec3(0.176,0.176,0.375));\n  sdLine(dis_col,pos,vec2(-0.300556,-0.770950),vec2(-0.487735,-0.819175),vec3(0.098,0.082,0.188),vec3(0.188,0.182,0.373));\n  sdLine(dis_col,pos,vec2(-0.274553,-0.751048),vec2(-0.300678,-0.771091),vec3(0.094,0.078,0.163),vec3(0.202,0.188,0.363));\n  sdLine(dis_col,pos,vec2(-0.242248,-0.691634),vec2(-0.274548,-0.751130),vec3(0.090,0.075,0.147),vec3(0.216,0.196,0.359));\n  sdLine(dis_col,pos,vec2(-0.800847,-0.800581),vec2(-0.875072,-0.699008),vec3(0.069,0.057,0.225),vec3(0.351,0.331,0.616));\n  sdLine(dis_col,pos,vec2(-0.687515,-0.871181),vec2(-0.800804,-0.800859),vec3(0.055,0.049,0.192),vec3(0.331,0.316,0.584));\n  sdLine(dis_col,pos,vec2(-0.727078, 0.837400),vec2(-0.792967, 0.812525),vec3(0.851,0.773,0.682),vec3(0.453,0.390,0.737));\n  sdLine(dis_col,pos,vec2(-0.657094, 0.890944),vec2(-0.727080, 0.837365),vec3(0.859,0.780,0.682),vec3(0.475,0.412,0.759));\n  sdLine(dis_col,pos,vec2(-0.603768, 0.961718),vec2(-0.657083, 0.890933),vec3(0.857,0.780,0.682),vec3(0.508,0.445,0.794));\n  sdLine(dis_col,pos,vec2(-0.589831, 0.999997),vec2(-0.603747, 0.961733),vec3(0.857,0.780,0.682),vec3(0.527,0.467,0.816));\n  sdLine(dis_col,pos,vec2(-0.902586, 0.451620),vec2(-0.836020, 0.550739),vec3(0.569,0.553,0.867),vec3(0.618,0.624,0.949));\n  sdLine(dis_col,pos,vec2(-0.958157, 0.411244),vec2(-0.902331, 0.451519),vec3(0.506,0.494,0.859),vec3(0.637,0.647,0.957));\n  sdLine(dis_col,pos,vec2(-0.988291, 0.406328),vec2(-0.958317, 0.411469),vec3(0.465,0.453,0.851),vec3(0.649,0.663,0.961));\n  sdLine(dis_col,pos,vec2(-0.790561, 0.737649),vec2(-0.792976, 0.808576),vec3(0.722,0.694,0.898),vec3(0.859,0.788,0.661));\n  sdLine(dis_col,pos,vec2(-0.835941, 0.550741),vec2(-0.790568, 0.737610),vec3(0.708,0.680,0.892),vec3(0.849,0.778,0.680));\n  sdLine(dis_col,pos,vec2( 0.124987,-0.012010),vec2( 0.128540,-0.077336),vec3(0.153,0.094,0.125),vec3(0.980,0.929,0.725),vec3(0.082,0.039,0.075),vec3(0.773,0.251,0.153));\n\n  return dis_col;\n}\n\n\n\/\/ --------------------------------------\n\/\/ oldschool rand() from Visual Studio\n\/\/ --------------------------------------\nint   seed = 1;\nint   rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())\/32767.0; }\nvoid  srand( ivec2 p, int frame )\n{\n    int n = frame;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589; \/\/ by Hugo Elias\n    n += p.y;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589;\n    n += p.x;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589;\n    seed = n;\n}\n\n\/\/ --------------------------------------\n\nvec2 randomInCircle( void )\n{\n    float an = 6.283185*float(rand())\/32767.0;\n    return vec2(cos(an),sin(an));\n}\n\n\/\/ WoS\nvec3 march( in vec2 p )\n{\n    vec4 h = vec4(0.0);\n\tfor( int i=0; i<24; i++ )\n    {\n        h = map(p);\n        if( h.x<0.001 ) break;\n        p = p + h.x*randomInCircle();\n    }\n    return h.yzw;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\/\/ init randoms\n    srand( ivec2(fragCoord), iFrame );\n    \n\t\/\/ coords\n    vec2 p = (2.0*fragCoord-iResolution.xy)\/iResolution.y;\n    \n#if 1\n    \/\/ solve\n    vec3 col = march(p);\n#else\n    \/\/ display SDF (reset shader after enabling this)\n    vec4 dist_col = map(p);\n    vec3 col = dist_col.yzw*smoothstep(0.01,0.0,abs(dist_col.x));\n#endif\n    \n    \/\/ montecarlo\n    vec4 data = texelFetch(iChannel0,ivec2(fragCoord),0);\n    fragColor = data + vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"wtSSDm","date":"1566080491","viewed":7142,"name":"Communication and Grouping","username":"wyatt","description":"What you think something is has a lot more to do with how it interacts with you than what it is to itself. ","likes":84,"published":3,"flags":32,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"\/media\/previz\/buffer03.png","previewfilepath":"\/media\/previz\/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float ln (vec3 p, vec3 a, vec3 b) {return length(p-a-(b-a)*min(dot(p-a,b-a),0.)\/dot(b-a,b-a));}\nvoid mainImage( out vec4 Q, in vec2 U )\n{\n \tvec4 \n        n = D(U+vec2(0,1)),\n        e = D(U+vec2(1,0)),\n        s = D(U-vec2(0,1)),\n        w = D(U-vec2(1,0));\n    vec4 a = A(U);\n    Q = C(U);\n    Q = vec4(.7,.8,.9,1);\n    vec3 no = normalize(vec3(e.w-w.w,n.w-s.w,2));\n    vec3 re = reflect(normalize(vec3((U-0.5*R)\/R.y,1)),no);\n    float light = ln(vec3(2,2,2),vec3(U\/R.y,0),vec3(U\/R.y,0)+re);\n    Q *= (exp(-light)+.4*exp(-.3*light))*(0.7+0.5*dot(re,normalize(vec3(U\/R.y,0)-vec3(2,2,2))));\n\n    \n\t\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"\/media\/previz\/buffer03.png","previewfilepath":"\/media\/previz\/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void swap (inout vec4 Q, vec2 U, vec2 r) {\n\tvec4 n = A(U+r);\n    if (length(U-n.xy)<length(U-Q.xy)) Q = n;\n} \nvoid mainImage( out vec4 Q, in vec2 U )\n{\n   Q = A(U);\n   swap(Q,U, vec2(0,1));\n   swap(Q,U, vec2(1,0));\n   swap(Q,U,-vec2(0,1));\n   swap(Q,U,-vec2(1,0));\n   swap(Q,U, vec2(1,1));\n   swap(Q,U, vec2(1,-1));\n   swap(Q,U,-vec2(1,1));\n   swap(Q,U,-vec2(1,-1));\n   swap(Q,U, vec2(0,2));\n   swap(Q,U, vec2(2,0));\n   swap(Q,U,-vec2(0,2));\n   swap(Q,U,-vec2(2,0));\n    \n    vec2 u = mix(Q.xy,U,0.);\n    vec4\n        n = D(u+vec2(0,1)),\n        e = D(u+vec2(1,0)),\n        s = D(u-vec2(0,1)),\n        w = D(u-vec2(1,0));\n    Q.xy -= .5*Q.zw;\n    vec2\n        g = vec2(e.w-w.w,n.w-s.w);\n    Q.zw = -g;\n    if (length(Q.zw)>1.) Q.zw = normalize(Q.zw);\n  \t\n    if (iFrame < 1||(iMouse.z>0.&&length(U-iMouse.xy)<10.)){\n        vec2 u =floor(U\/10.+0.5)*10.;\n        Q = vec4(u,0,0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 Q, in vec2 U )\n{\n   Q = vec4(0);\n    \n    for (int i = -I; i <= I; i++) {\n        vec2 u = U+vec2(i,0);\n        vec4 a = A(u);\n    \tQ += (exp(-O*float(i*i)))*smoothstep(1.5,1.,length(u-a.xy));\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 Q, in vec2 U )\n{\n   Q = vec4(0);\n    \n    for (int i = -I; i <= I; i++) {\n    \tQ += (exp(-O*float(i*i)))*A(U+vec2(0,i));\n    }\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)\/R)\n#define B(U) texture(iChannel1,(U)\/R)\n#define C(U) texture(iChannel2,(U)\/R)\n#define D(U) texture(iChannel3,(U)\/R)\n\n#define O vec4(.01,.2,.5,.01)\n#define I 20","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"\/media\/previz\/buffer03.png","previewfilepath":"\/media\/previz\/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\nvoid mainImage( out vec4 Q, in vec2 U )\n{\n   Q = C(U);\n   \n   Q.w = .1*Q.x - Q.y;\n   \n    if (iMouse.z>0.) Q.w -= 100.*exp(-.05*length(iMouse.xy-U));\n   Q.w = mix(Q.w,D(U).w,.75);\n}","name":"Buffer D","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"Ms23Wm","date":"1389637734","viewed":7119,"name":"SSAO (basic)","username":"iq","description":"SSAO, without using normals for better sampling nor bilateral filtering for smoothing the noise out","likes":49,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"\/media\/a\/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"\/media\/ap\/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ The MIT License\n\/\/ Copyright \u00a9 2014 Inigo Quilez\n\/\/ Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \/\/ sample zbuffer (in linear eye space) at the current shading point\t\n\tfloat zr = 1.0-texture( iChannel0, fragCoord.xy \/ iResolution.xy ).x;\n\n    \/\/ sample neighbor pixels\n\tfloat ao = 0.0;\n\tfor( int i=0; i<8; i++ )\n\t{\n        \/\/ get a random 2D offset vector\n        vec2 off = -1.0 + 2.0*texture( iChannel1, (fragCoord.xy + 23.71*float(i))\/iChannelResolution[1].xy ).xz;\t\n        \/\/ sample the zbuffer at a neightbor pixel (in a 16 pixel radious)        \t\t\n        float z = 1.0-texture( iChannel0, (fragCoord.xy + floor(off*16.0))\/iResolution.xy ).x;\n        \/\/ accumulate occlusion if difference is less than 0.1 units\t\t\n\t\tao += clamp( (zr-z)\/0.1, 0.0, 1.0);\n\t}\n    \/\/ average down the occlusion\t\n    ao = clamp( 1.0 - ao\/8.0, 0.0, 1.0 );\n\t\n\tvec3 col = vec3(ao);\n\t\n    \/\/ uncomment this one out for seeing AO with actual image\/zbuffer\t\n\t\/\/col *= texture( iChannel0, fragCoord.xy \/ iResolution.xy ).xyz;\n\t\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"XdS3Wm","date":"1389008433","viewed":7118,"name":"Hello Morph!","username":"Dave_Hoskins","description":"Aardman's (from Wallace & Gromit fame) early work. Morph, the plasticine animation from British childhoods in the 70s and 80s.\nEpisode on YouTube: [url]https:\/\/www.youtube.com\/watch?v=daQfoN_xXIc[\/url]","likes":49,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"\/media\/a\/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"\/media\/ap\/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Hello Morph! By David Hoskins. Jan 2014.\n\/\/ Aardman's (from Wallace & Gromit fame) early work.\n\/\/ http:\/\/www.youtube.com\/watch?v=jSMRPKM1evk\n\n\/\/ Morph, the plasticine animation from British childhoods in the 70s and 80s:-\n\/\/ https:\/\/www.youtube.com\/watch?v=daQfoN_xXIc\n\n\/\/ COMMENT THE NEXT LINE TO REMOVE STOP MOTION FRAME JUDDER...\n#define STOP_MOTION_EFFECT\n\n\/\/ Some often adjusted defines in one place...\n#define elbowR\t\tvec3(1.0, -.1, 0.3)\n#define shoulderR\tvec3(0.4, 0.56,  -.05)\n#define wristR\t\tvec3(.5, -.4, -0.1)\n#define shoulderL\tvec3(-0.4, 0.56, -.05)\n#define sunColour\tvec3(1.0)\n#define skinColour  vec3(.65, .22, 0.14)\n#define sunDir\t\tvec3(.42562, .59588, -.681005)\n#define PI 3.14159265359\n\n\/\/ Animation variables.\n\/\/ Possibly a bad idea using globals, but it seems OK if there's only a few of them.\n\/\/ They make it much quicker and easier than passing everything in functions.\nfloat wave;\nfloat hel;\nfloat low;\nfloat nod;\nfloat time;\n\n\/\/----------------------------------------------------------------------------------------\nfloat Hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(32.3391, 38.5373))) * 74638.5453);\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ 2D rotations for 3D vectors make them quicker on axis rotations...\nvec2 Rotate2(vec2 p, float a)\n{\n\tfloat si = sin(a);\n\tfloat co = cos(a);\n\treturn mat2(co, si, -si, co) * p;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat Segment(vec3 p,  vec3 a, vec3 b, float r1, float r2)\n{\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r1 + r2*h;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat Mouth( vec3 p, vec3 a)\n{\n\tfloat curve = cos(p.x*(5.35+sin(-time)*1.25))*.11;\n\tp.y += curve;\n\ta.y += pow(abs(curve), 2.0);\n\treturn length(max(abs(p) - a,0.0)) -.02;\n}\n\n\/\/ I\u00c3\u00b1igo's distance functions...\n\/\/----------------------------------------------------------------------------------------\nfloat  Sphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat Cylinder( vec3 p, vec2 h )\n{\n  return max( length(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat RoundBox( vec3 p, vec3 b, float r )\n{\n\t\/\/b.x -= p.y * .08;\n\treturn length(max(abs(p)-b,0.0))-r;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat Nose(vec3 p, vec3 a, float r )\n{\n\tfloat h = clamp( dot(p,a)\/dot(a,a), 0.0, 1.0 );\n\treturn length( p - a*h ) - r;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat sMin( float a, float b )\n{\n    float k = .12;\n\tfloat h = clamp(0.5 + 0.5*(b-a)\/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.-h);\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec2 Map( in vec3 pos )\n{\n    vec2 res = vec2( 1000.0, 3);\n\tfloat d;\n\tpos.y += -1.0;\n\tvec3 elbowL\t\t= vec3(-.95-wave*.05, .2, -0.25);\n\tvec3 wristL\t\t= vec3(elbowL.x+1.0*sin(wave)*.55, elbowL.y+cos(wave)*.55, -.75);\n\t\n\t\/\/ Head...\n\tvec3 p = pos;\n\t\/\/ Rotate around Y axis for waist movment...\n\tfloat h = sin(time*2.3) * .1 - wave*0.01;\n\tp.xz = Rotate2(p.xz, h);\n\tvec3 p2 = p;\n\t\/\/ Rotate head around X axis...\n\tp2.zy = Rotate2(p.zy, nod+hel*2.0+wave*.012);\n\tp2 -= vec3(0.0, 0.0, -0.05);\n\t\n\td = Sphere(p2, .37);\n\tif (d < res.x)\n\t{\n\t\tres.x = d;\n\t\tvec3 p3 = vec3(abs(p2.x), p2.yz);\n\t\tif (dot(normalize(p3*vec3(1.0, .9, 1.0)), normalize(vec3(.32, 0.24, -.7))) > .95) res.y = 4.0;\n\t\tif (dot(normalize(p3), normalize(vec3(.32, 0.18-nod*.2, -.8))) > .993) res.y = 5.0;\n\t}\n\n\t\/\/ Mouth and inside colour...\n\tfloat mo = -Mouth(p2-vec3(0.0, -.057-hel, -0.3), vec3(.155-low, -.006+hel, .2));\n\tif (res.x  < mo ) res = vec2(mo, 2.0);\n\n\t\/\/ Nose\n\tp2 = p2-vec3(0.0, 0.0, 0.0);\n\tres.x = min(res.x, Nose(p2, vec3(.0,0.0,-.5), 0.06));\n\t\n\t\/\/ Neck...\n\tp = p-vec3(0.0, -.4, .1);\n\td = Cylinder(p, vec2(0.171, .17));\n\tres.x = sMin(res.x, d);\n\n\t\/\/ Body...\t\n\tp = p-vec3(0.0, -.82, 0.0);\n\td = RoundBox(p, vec3(0.175, .45, 0.0), .26);\n\tres.x = sMin(res.x, d);\n\t\t\t\n\t\/\/ Right arm upper...\n\tp = p-vec3(0.0, 0.0, 0.0);\n\td = Segment(p, shoulderR, elbowR, .17, .05);\n\tres.x = sMin(res.x, d);\n\t\/\/ Right arm lower...\n\td = Segment(p, elbowR, wristR, .15, .05);\n\tres.x = sMin(res.x, d);\n\t\/\/ Right hand...\t\n\td = Segment(p*vec3(1.0, .75, 1.0), wristR+vec3(0, .1, 0.), wristR+vec3(-.15, .05, -.15), .13, .02);\n\tres.x = min(res.x, d);\n\t\n\t\/\/ Left arm upper...\n\td = Segment(p, shoulderL, elbowL, .17, .05);\n\tres.x = sMin(res.x, d);\n\t\/\/ Left arm lower...\n\td = Segment(p, elbowL, wristL, .15, .05);\n\tres.x = sMin(res.x, d);\n\t\n\t\/\/ Left Hand...\t\n\tp = (p-wristL);\n\tp.z -= p.x*.5;\n\tp.yx = Rotate2(p.yx, -wave*1.5);\n\td = Segment(p, vec3(0.0), -vec3(-.25, -0.15, 0.1), .06, .01);\n\tres.x = sMin(res.x, d);\n\td = RoundBox(p-vec3(0.0, .25, 0.0), vec3(.042, .085, -.05), .09);\n\tres.x = sMin(res.x, d);\n\t\n\t\/\/ Mirrored legs...\n\tp = pos + vec3(0.0, .35, -.05);\n\tp.y += .8;\n\tp.x = abs(p.x);  \/\/ <- does the mirroring.\n\tvec3 ankle  = vec3(0.3, -1.85, 0.0);\n\td = Segment(p, vec3(0.22, -.75, 0.0), ankle, .225, .05);\n\tres.x = sMin(res.x, d);\n\t\n\t\/\/ Feet...\n\tankle.y -=.3;\n\td = Segment(p, ankle, ankle + vec3(0.27, -.05, -0.3), .24, .05);\n\td = max((ankle.y-p.y), d);\n\tres.x = sMin(res.x, d);\n\n\t\/\/ Do wooden box...\n\td = RoundBox(pos + vec3(-4.2, 2.7, -1.0), vec3(2.0, .5, 1.0), .075);\n\td = min(d, RoundBox(pos + vec3(-4.2, 1.9, -1.0), vec3(2.0, .185, 1.0), .075));\n\tif (d < res.x)\n\t{\n\t\tres = vec2(d, 1.0);\n\t}\n    \n\n    return res;\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec2 RayMarch( in vec3 ro, in vec3 rd, in vec2 fragCoord, out int hit)\n{\n\tconst float precis = 0.01;\n\tfloat t = .5 + .1 * Hash(fragCoord.xy);\n\thit = 0;\n\tvec2 res = vec2(precis*2.0, 0.0);\n    for( int i = 0; i < 73; i++ )\n    {\n\t\tif (hit == 0 && t < 20.0)\n\t\t{\n\t\t\tres = Map(ro + rd * t);\n\t\t\tif(res.x < precis)\n\t\t\t{\n\t\t\t\thit = 1;\n                break;\n\t\t\t}else\n\t\t\t\tt += max(.005, res.x * .5);\n\t\t}\n    }\n\t\/\/ Missed scene, so do table with basic ray casting.\n\t\/\/ There's no point in ray-marching the flat gound as it's a\n\t\/\/ waste of cycles, especially for background location and accuracy.\n\t\/\/ (Well, in this case anyway)\n\tif (hit == 0 && rd.y < 0.0)\n\t{\n\t\thit = 2;\n\t\trd.y = min(rd.y, 0.0);\n\t\tt = (-2.3-ro.y) \/ rd.y;\n\t\tres.y = 6.0;\n\t}\n\t\/\/ Return the distance to point and material type.\n\treturn vec2( t, res.y);\t\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat Shadow( in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    float t = 0.1;\n\tfloat h;\n\t\n    for (int i = 0; i < 7; i++)\n\t{\n\t\th = Map( ro + rd*t ).x;\n\t\tres = min(7.0*h \/ t, res);\n\t\tt += h+.04;\n\t}\n    return max(res, 0.0);\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 Normal( in vec3 pos )\n{\n\n\tconst vec2 eps = vec2( 0.015, 0.0);\n\tvec3 nor = vec3(\n\t    Map(pos+eps.xyy).x - Map(pos-eps.xyy).x,\n\t    Map(pos+eps.yxy).x - Map(pos-eps.yxy).x,\n\t    Map(pos+eps.yyx).x - Map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvec3 GetMaterial(vec3 pos, vec3 norm, float mat)\n{\n\t\/\/ These teture reads had to be moved out of the 'if' statements as\n\t\/\/ Windoes Chrome34 WebGL broke badly in the hands of those ANGLE guys! :p\n\tvec3 col = texture(iChannel0, pos.xz*.3).xyz*.65;\t\/\/ Table\n\tvec3 tx1 = texture(iChannel0, pos.xy*vec2(.05, .25)).xyz * abs(norm.z+norm.x);\n\tvec3 tx2 = texture(iChannel0, pos.xz*vec2(.05, .25)).xyz * norm.y;\n\n\tfloat blink = step(mod(time-1.0, 3.0), .11);\n\tif (mat < 1.5)\n\t{\n\t\t\/\/ Wooden box is a lighter version of the table texture.\n\t\tcol =  tx1;\n\t\tcol += tx2;\n\t\tcol = sqrt(col);\n\t}else if (mat < 2.5)\n\t{\n\t\t\/\/ Inside mouth...\n\t\tcol = skinColour*.5;\n\n\t}else if (mat < 3.5)\n\t{\n\t\t\/\/ Plasticine...\n\t\tcol = skinColour;\n\n\t}else if (mat < 4.5)\n\t{\n\t\t\/\/ Eye balls...\n\t\tcol = skinColour * .7 * blink + vec3(1.0) * (1.0-blink);\n\t}else if (mat < 5.5)\n\t{\n\t\t\/\/ Pupil...\n\t\tcol = skinColour * .7 * blink;\/\/ + vec3(0.0) * (1.0-blink);\n\t}\n\treturn col;\n}\n\n\/\/----------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\/\/ Stop motion time...\n#ifdef STOP_MOTION_EFFECT\n\ttime = mod((floor(iTime*30.0) \/ 30.0), 20.0)-.7;\n#else\n\ttime = mod(iTime, 20.0)-.7;\n#endif\n\n\tvec3 col = vec3(0.85);\t\n\tvec2 q = fragCoord.xy\/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x\/iResolution.y;\n\t\n\t\/\/ Animation...\n\twave = sin(time*15.0-.8+sin(time)*2.0)*.5+.5;\n\twave = wave*wave*(3.0-2.0*wave)-.7;\n\tfloat m = fract(time*.19);\n\thel = (1.0+sin(m*100.0)) * .02 * (smoothstep(0.0, .015, m) - smoothstep(0.05, .15, m));\n\tlow = (smoothstep(0.05, .1, m)-smoothstep(0.12, .15, m))*.11;\n\tnod = -(smoothstep(0.22, .28, m)-smoothstep(0.28, .31, m))*.5;\n\t\n\t\/\/ Camera position...\n\tfloat t = clamp(time-3.5, 0.0, 1.0);\n\tt = t*t*(3.0-2.0*t);\n\tvec3 origin = mix(vec3(0.0, 1.0, -1.275), vec3(-1.0, 1.0, -5.5), t);\n\tvec3 target = mix(vec3(0.0, 1.0, 4.0),  vec3( 0.5, -.4, 0.0), t);\n\torigin = mix(origin, vec3( 1.0, 1.0, -5.0), clamp((time-6.0)*.075, 0.0, 1.0));\n\n\t\/\/ Camera matrix...\n\tvec3 cw = normalize( target-origin);\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = cross(cu,cw);\n\tvec3 ray = normalize( p.x*cu + p.y*cv + 2.6*cw );\n\n\t\/\/ Do the rendering...\n\tvec3 pos, norm;\n\tint hit = 0;\n\tvec2 res = RayMarch(origin, ray, fragCoord, hit);\n\n\tif (hit > 0)\n\t{\n\t\tpos = origin + res.x * ray;\n\t\t\/\/ Is it the ground?...\n\t\thit == 2 ? norm = vec3(0.0, 1.0, 0.0) : norm = Normal(pos);\n\n\t\tcol\t= GetMaterial(pos, norm, res.y);\n\t\t\n\t\tfloat diff = max(dot(norm, sunDir), 0.0);\n\t\tfloat ambi = clamp(.2 + 0.2 * norm.y,0.0, 1.0);\n\t\tfloat shad = Shadow(pos, sunDir);\n\t\tfloat spec = max( 0.0, pow( max( dot(sunDir,reflect(ray, norm)), 0.0), 5.0) ) * .08;\n\t\t\/\/ Do the lighting... \n\t\tvec3 lite = diff * sunColour * shad + col*ambi;\n\t\tcol = col * lite + spec * shad;\n\t\t\/\/ Fog the background...\n\t\tcol = mix(col, vec3(.85), clamp(res.x*res.x*.001-.2, 0.0, 1.0));\n\t}\t\n\t\n\t\/\/ Post effects...\n\tcol = pow(col,vec3(.5));\n\t\/\/ Add noise and fake flicker for old animation effect.\n\tfloat flick = max(1.-sin(fract(iTime*1.1) * PI), 0.0) * .03;\n\tcol += Hash(floor(p*iResolution.y*.25)-time) * .035 -flick;\n\tt = 32.0*q.x*q.y*(1.0-q.x)*(1.0-q.y);\n\t\/\/ Make screen edge effects to frame the scene and make it look older...\n\tcol   -= (1.0-pow(t, 0.1)) * .25;\n\tcol.y -= (1.0-pow(t, 0.3-flick*3.0)) * .1;\n\tcol.z -= (1.0-pow(t, 0.3)) * .05;\n    fragColor=vec4(clamp(col, 0.0, 1.0), 1.0 );\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"XlS3DD","date":"1428958340","viewed":7118,"name":"spectrum analysor","username":"FabriceNeyret2","description":"speak, sing, play guitar, and see the sound formants !\nMouse.y: time window from 1\" to 10\".\nOrange: 440Hz=A   Red: octaves   Green: harmonics ","likes":30,"published":3,"flags":4,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XdXGRr","filepath":"\/presets\/mic.png","previewfilepath":"\/presets\/mic.png","type":"mic","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"float message(vec2 uv) { \/\/ to alter in the icon\n    uv-=vec2(1.,10.); if ((uv.x<0.)||(uv.x>=32.)||(uv.y<0.)||(uv.y>=3.)) return -1.; \n    int i=1, bit=int(pow(2.,floor(32.-uv.x)));\n    if (int(uv.y)==2) i=  757737252\/bit; \/\/ 11010010 11010101 11011000 11011011\n    if (int(uv.y)==1) i= 1869043565\/bit; \/\/ 10010000 10011000 10101000 10010010\n    if (int(uv.y)==0) i=  623593060\/bit; \/\/ 11011010 11010100 10111001 10011011\n \treturn float(1-i+2*(i\/2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iResolution.y<200.) {float c=message(fragCoord.xy\/8.);if(c>=0.){fragColor=vec4(c);return;}}\n    \n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n \tfloat fmax = iSampleRate\/4.;\n \n    float T = pow(10.,iMouse.y\/ iResolution.y); \/\/ time window on screen\n    \n    if (mod(iTime\/T-uv.x,1.)>.1) discard;  \/\/ update only one column on screen\n    \n    float zoom = 5.;               \/\/ zoom in frequencies\n    uv.y \/= zoom;\n    float f = uv.y*fmax;           \/\/ mapping y - frequency\n    \nfor (int once=0; once<1; once++) { \/\/ because early returns cause issues on some compilers\n\n    \/\/ bars\n    if (mod(fragCoord.x,8.)<2.) {\n    if (abs(f-440.)< fmax\/(zoom*iResolution.y))\n        { fragColor = vec4(1.,.7,0.,0.); break;\t}\n \tif (mod(log(f\/440.)\/log(2.),1.)< .25\/(iResolution.y*uv.y))\n        { fragColor = vec4(.7,0.,0.,0.); break;\t}\n \tif (mod(f,440.)< fmax\/(zoom*iResolution.y))\n        { fragColor = vec4(0.,.7,0.,0.); break;\t}\n    }\n    \/\/ data\n    float c =  texture(iChannel0,vec2(uv.y,.5\/2.)).r;\n\n    c = (c-.3)\/.7; \/\/ cut 30% of noise\n    fragColor = vec4(1.5*c,c,.7*c,1);\n}}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4dsGRn","date":"1361131642","viewed":7108,"name":"Ray tracer with volumetric light","username":"anji","description":"Your basic sphere\/plane ray tracer with some volumetric shadowing thrown into the mix. Code can still be made a little more elegant I think. Nearly melted my Macbook making this.","likes":46,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Ray tracing with improvised volumetric shadows\n\/\/ Attempting to make it windows friendly by reducing loopiness.\n\/\/ Thanks to iq for fixing the sphere intersection code, sqrt(-n) is bad :)\n\/\/ Matthijs De Smedt\n\/\/ @anji_nl\n\nconst float ZMAX = 99999.0;\nconst float EPSILON = 0.001;\nconst int MAX_BOUNCES = 3; \/\/ For looping version\nconst int VOLUMETRIC_SAMPLES = 10;\n\nstruct Intersection\n{\n\tvec3 p;\n\tfloat dist;\n\t\n\tvec3 n;\n\tvec3 diffuse;\n\tvec3 specular;\n};\n\t\nstruct Ray\n{\n\tvec3 o;\n\tvec3 dir;\n};\n\t\nstruct Light\n{\n\tvec3 p;\n\tvec3 color;\n\tfloat radius;\n};\n\t\nstruct Plane\n{\n\tvec3 n;\n\tfloat d;\n};\n\t\nstruct Sphere\n{\n\tvec3 c;\n\tfloat r;\n};\n\t\nfloat saturate(float f)\n{\n\treturn clamp(f,0.0,1.0);\n}\n\nvec3 saturate(vec3 v)\n{\n\treturn clamp(v,vec3(0,0,0),vec3(1,1,1));\n}\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453 + iTime);\n}\n\nIntersection RaySphere(Ray ray, Sphere sphere)\n{\n\tIntersection i;\n\ti.dist = ZMAX;\n\tvec3 c = sphere.c;\n\tfloat r = sphere.r;\n\tvec3 e = c-ray.o;\n\tfloat a = dot(e, ray.dir);\n\tfloat b = r*r - dot(e,e) + a*a;\n\tif( b>0.0 )\n\t{\n\t\tfloat f = sqrt(b);\n\t\tfloat t = a - f;\n\t\tif(t > EPSILON)\n\t\t{\n\t\t\ti.p = ray.o + ray.dir*t;\n\t\t\ti.n = normalize(i.p-c);\n\t\t\ti.dist = t;\n\t\t}\n\t}\n\treturn i;\n}\n\nIntersection RayPlane(Ray ray, Plane p)\n{\n\tIntersection i;\n\tfloat num = p.d-dot(p.n, ray.o);\n\tfloat denom = dot(p.n, ray.dir);\n\tfloat t = num\/denom;\n\tif(t > EPSILON)\n\t{\n\t\ti.p = ray.o + ray.dir * t;\n\t\ti.n = p.n;\n\t\ti.dist = t;\n\t}\n\telse\n\t{\n\t\ti.dist = ZMAX;\n\t}\n\treturn i;\n}\n\nIntersection MinIntersection(Intersection a, Intersection b)\n{\n\tif(a.dist < b.dist)\n\t{\n\t\treturn a;\n\t}\n\telse\n\t{\n\t\treturn b;\n\t}\n}\n\nvec3 PlaneMaterial(Intersection i)\n{\n\tfloat d = 0.0;\n\td = mod(floor(i.p.x)+floor(i.p.z),2.0);\n\treturn vec3(d,d,d)*0.8;\n}\n\nIntersection SceneIntersection(Ray r)\n{\n\tIntersection iOut;\n\t\n\tPlane plane;\n\tplane.n = normalize(vec3(0,1,0));\n\tplane.d = -2.0;\n\tIntersection iPlane = RayPlane(r, plane);\n\tiPlane.diffuse = PlaneMaterial(iPlane);\n\tiPlane.specular = vec3(1,1,1)-iPlane.diffuse;\n\tiOut = iPlane;\n\t\n\tfor(int s = 0; s <= 3; s++)\n\t{\n\t\tfloat fs = float(s);\n\t\tfloat t = iTime*0.3+fs*2.0;\n\t\tvec3 pos;\n\t\tpos.x = sin(t*2.0)*2.0+sin(t*2.0)*3.0;\n\t\tpos.y = abs(sin(t))*2.0;\n\t\tpos.z = 6.0+cos(t)*2.0+cos(t*1.5)*2.0;\n\t\tSphere sphere;\n\t\tsphere.c = pos;\n\t\tsphere.r = 2.0;\n\t\tIntersection iSphere = RaySphere(r, sphere);\n\t\tiSphere.diffuse = vec3(0.0,0.0,0.2);\n\t\tiSphere.specular = vec3(0.2,0.2,0.6);\n\t\tiOut = MinIntersection(iOut, iSphere);\n\t}\n\t\n\treturn iOut;\n}\n\nvec3 CalcIrradiance(Light light, vec3 p)\n{\n\tfloat distA = 1.0-saturate(length(light.p-p)\/light.radius);\n\treturn distA * light.color;\n}\n\nvec3 CalcLighting(Light light, Intersection i, vec3 origin)\n{\n\tvec3 n = i.n;\n\tvec3 p = i.p;\n\tvec3 l = normalize(light.p-p);\n\tvec3 v = normalize(origin-p);\n\tvec3 h = normalize(l+v);\n\tfloat NdotL = saturate(dot(n,l));\n\tfloat NdotH = saturate(dot(n,h));\n\tvec3 diffuse = NdotL*i.diffuse;\n\tvec3 spec = pow(NdotH,8.0) * i.specular;\n\tfloat distA = 1.0-saturate(length(light.p-p)\/light.radius);\n\tvec3 color;\n\tcolor = (diffuse+spec) * distA * light.color;\n\t\n\tfloat shadow = 1.0;\n\tRay shadowRay;\n\tshadowRay.o = i.p;\n\tfloat lightDist = length(light.p-i.p);\n\tshadowRay.dir = (light.p-i.p)\/lightDist;\n\tIntersection shadowI = SceneIntersection(shadowRay);\n\tif(shadowI.dist < lightDist)\n\t{\n\t\tshadow = 0.0;\n\t}\n\tcolor *= shadow;\n\t\n\treturn color;\n}\n\nvec3 GetLighting(Intersection i, vec3 origin)\n{\n\tvec3 color = vec3(0,0,0);\n\tLight light;\n\t\n\tlight.p = vec3(sin(iTime*0.3)*2.0,5,cos(iTime*0.3)*2.0+4.0);\n\tlight.color = vec3(1,1,1);\n\tlight.radius = 20.0;\n\tcolor += CalcLighting(light, i, origin);\n\t\n\t\/*\n\tlight.p = vec3(cos(time*0.2)*2.0,5,sin(time*0.2)*2.0+8.0);\n\tlight.color = vec3(1,1,1);\n\tlight.radius = 20.0;\n\tcolor += CalcLighting(light, i, origin);\n*\/\n\t\n\treturn color;\n}\n\nvec3 GetVolumetricLighting(Ray ray, float maxDist, vec2 fragCoord)\n{\n\tvec3 color = vec3(0,0,0);\n\tLight light;\n\tlight.p = vec3(sin(iTime*0.3)*2.0,5,cos(iTime*0.3)*2.0+4.0);\n\tlight.color = vec3(1,1,1);\n\tlight.radius = 20.0;\n\t\n\tfloat inscattering = maxDist\/200.0;\n\tfloat volRayStep = maxDist\/float(VOLUMETRIC_SAMPLES-1);\n\tfloat randomStep = rand(fragCoord.xy)*volRayStep;\n\tRay volRay;\n\tvolRay.o = ray.o + ray.dir*randomStep;\n\tfor(int v = 0; v < VOLUMETRIC_SAMPLES; v++)\n\t{\n\t\tvec3 lightVec = light.p-volRay.o;\n\t\tfloat lightDist = length(lightVec);\n\t\tvolRay.dir = lightVec\/lightDist;\n\t\tIntersection i = SceneIntersection(volRay);\n\t\tif(i.dist > lightDist)\n\t\t{\n\t\t\tcolor += CalcIrradiance(light, volRay.o)*inscattering;\n\t\t}\n\t\tvolRay.o += ray.dir * volRayStep;\n\t}\n\t\n\treturn color;\n}\n\nvec3 GetColor(Ray ray, vec2 fragCoord)\n{\n\tvec3 color = vec3(0,0,0);\n\tvec3 volumetric = vec3(0,0,0);\n\tvec3 prevSpecular = vec3(1.0,1.0,1.0);\n\t\/*\n\t\/\/ Loop version\n\tfor(int r = 0; r <= MAX_BOUNCES; r++)\n\t{\n\t\tIntersection i;\n\t\t\/\/ Find intersection\n\t\ti = SceneIntersection(ray);\n\t\tif(r == 0)\n\t\t{\n\t\t\tvolumetric = GetVolumetricLighting(ray, min(i.dist, 20.0));\n\t\t}\n\t\tif(i.dist >= ZMAX-EPSILON)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\/\/ Blend color\n\t\tvec3 diffuse = GetLighting(i, ray.o);\n\t\tcolor += diffuse * prevSpecular;\n\t\tprevSpecular *= i.specular;\n\t\t\/\/ Calculate next ray\n\t\tvec3 incident = normalize(i.p-ray.o);\n\t\tray.dir = reflect(incident,i.n);\n\t\tray.o = i.p+ray.dir*EPSILON;\n\t}\n\t*\/\n\t\/\/ Branch version\n\tIntersection i = SceneIntersection(ray);\n\t\/\/ Volumetrics\n\tvolumetric = GetVolumetricLighting(ray, min(i.dist, 20.0), fragCoord);\n\tvec3 specular;\n\tvec3 incident;\n\tif(i.dist < ZMAX-EPSILON)\n\t{\n\t\tcolor += GetLighting(i, ray.o);\n\t\tspecular = i.specular;\n\t\tincident = normalize(i.p-ray.o);\n\t\tray.dir = reflect(incident,i.n);\n\t\tray.o = i.p+ray.dir*EPSILON;\n\t\t\/\/ First bounce\n\t\ti = SceneIntersection(ray);\n\t\tif(i.dist < ZMAX-EPSILON)\n\t\t{\n\t\t\tcolor += GetLighting(i, ray.o) * specular;\n\t\t\tspecular *= i.specular;\n\t\t\tincident = normalize(i.p-ray.o);\n\t\t\tray.dir = reflect(incident,i.n);\n\t\t\tray.o = i.p+ray.dir*EPSILON;\n\t\t\t\/\/ Second bounce\n\t\t\ti = SceneIntersection(ray);\n\t\t\tif(i.dist < ZMAX-EPSILON)\n\t\t\t{\n\t\t\t\tcolor += GetLighting(i, ray.o) * specular;\n\t\t\t}\n\t\t}\n\t}\n\tcolor -= volumetric*0.5; \/\/ Ho ho ho.\n\tcolor += volumetric;\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pos = -1.0 + 2.0 * ( fragCoord.xy \/ iResolution.xy );\n\tvec2 posAR;\n\tposAR.x = pos.x * (iResolution.x\/iResolution.y);\n\tposAR.y = pos.y;\n\tvec3 rayDir = normalize(vec3(posAR.x, posAR.y, 1.0));\n\tRay ray;\n\tray.o = vec3(sin(iTime*0.2),0,0);\n\tray.dir = rayDir;\n\t\n\tvec3 color = GetColor(ray, fragCoord);\n\tfragColor = vec4(color.x, color.y, color.z, 1.0 );\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"XsX3DB","date":"1377969882","viewed":7107,"name":"Banished","username":"Dave_Hoskins","description":"[*RE-WIND TO  SYNC AUDIO*] In the dog house again... .. . Should to be full-screen to see the rain effect properly. :) Mouse drag to look.\nPress rewind to sync the audio correctly.\n\n","likes":85,"published":3,"flags":8,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"\/media\/a\/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"\/media\/ap\/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRn","filepath":"\/media\/a\/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"\/media\/ap\/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"\/media\/a\/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"\/media\/ap\/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Banished. By David Hoskins. August 2013.\n\/\/ Back in the Dog House again!... .. . *sigh*\n\nfloat\tsigh;\nmat3\tturn;\nvec3\tlightning;\nfloat\tnose;\n\n\/\/----------------------------------------------------------------------------------------\nfloat Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel3, (uv+ 0.5)\/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat  Sphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat Roof( vec3 p)\n{\n\tvec3 b = vec3(1.3, .05, 1.0);\n\tp.x = abs(p.x);\n  \tp.y += p.x*.75;\n\treturn length(max(abs(p)-b,0.0))-.03;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat AboveRoof(vec3 p)\n{\n\tp.x = abs(p.x);\n  \tp.y += p.x*.75;\n\treturn -p.y+1.97;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat RoundBox( vec3 p, vec3 b)\n{\n\treturn length(max(abs(p)-b,0.0))-.02;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat Torus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat Capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\t\n\treturn length( pa - ba*h ) - r;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat Conk( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d = max(q.z-h.y*8.6,max(q.x*.3466025+p.y*.5,p.y*.5)-h.x*.55);\n\td = mix(Capsule(p, vec3(0.0,-.5,-0.4), vec3(.0,0.4,1.2), 0.2), d, .4);\n\treturn d;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec2 Map( in vec3 pos )\n{\t\/\/ Floor...\n    vec2 res = vec2( pos.y, -1.0);\n\t\/\/ Dog...\n\tvec3 p = turn * pos;\n\tres = opU( res, vec2(Conk( p-vec3(0.0,.95+sigh, .0), vec2(0.25,0.05) ), 1.0 ));\n\tres = opU(res, vec2(Sphere(p-vec3(0.0, .58+sigh+nose, -.4),  .165), 5.0));\n\t\/\/ House...\n\tres = opU( res, vec2(Roof(pos-vec3(0.0, 2.4, .5)), 2.0 ));\n\tfloat d = RoundBox(pos-vec3(0.0, 0.5, -.3), vec3(1.2, 2.5, .05));\n\td = opS(d, Sphere(pos-vec3(0.0, 0.8, -.3), .7));\n\td = opS(d, RoundBox(pos-vec3(0.0, 0.3, -.3), vec3(.675, .5, .2)));\n\td = opS(d, AboveRoof(pos-vec3(0.0, 0.5, -.3)));\n\tres = opU(res, vec2(d, 3.0));\n\tres = opU(res, vec2(RoundBox(pos-vec3(-1.2, .26, .52), vec3(.03, 1.1, .9)), 3.0));\n\tres = opU(res, vec2(RoundBox(pos-vec3(+1.2, .26, .52), vec3(.03, 1.1, .9)), 3.0));\n\tres = opU(res, vec2(-pos.z+1.5, 4.0));\n\t\n\t\/\/ Bone on front...\n\td = Capsule(pos, vec3(-.2, 1.65, -.3), vec3(.2, 1.65, -.3), .092);\n\t\/\/ Spheres for bone ends are one sphere reflected into four...\t\n\tp = vec3(abs(pos.xy-vec2(0.0, 1.65)), pos.z);\n\td = min(d, Sphere(p- vec3(0.23, .04, -.28), .115));\n\t\/\/ Now slice the front off bone...\n\td = opS(d, pos.z+.39);\n\tres = opU(res, vec2(d, 6.0));\n\t\n    return res;\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec2 RayMarch( in vec3 ro, in vec3 rd)\n{\n\tfloat precis = 0.01;\n\tfloat t = 2.0;\n\t\n\tvec2 res = vec2(precis*2.0, -1.0);\n    for( int i = 0; i < 40; i++ )\n    {\n        if(res.x > precis)\n\t\t{\n\t\t\tt += res.x*.65;\n\t\t\tres = Map( ro+rd*t );\n\t\t}\n    }\n\treturn vec2( t, res.y);\t\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat Shadow( in vec3 ro, in vec3 rd, in float maxt)\n{\n\tfloat res = 1.0;\n    float dt = 0.04;\n    float t = .02;\n    for( int i=0; i < 20; i++ )\n    {\n        float h = Map( ro + rd*t ).x;\n        res = min( res, 2.0*h\/t );\n        t += max( 0.15, dt );\n    }\n    return res;\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 Normal( in vec3 pos )\n{\n\tvec2 eps = vec2( 0.0005, 0.0);\n\tvec3 nor = vec3(\n\t    Map(pos+eps.xyy).x - Map(pos-eps.xyy).x,\n\t    Map(pos+eps.yxy).x - Map(pos-eps.yxy).x,\n\t    Map(pos+eps.yyx).x - Map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat WoodBump( in vec2 pos )\n{\n    float y = mod( pos.y*3.0, 1.0 );\n    float f = smoothstep( 0.0, 0.05, y ) - smoothstep( 0.95, 1.0, y );\n    return f-.5;\n}\n\n\/\/----------------------------------------------------------------------------------------\nmat3 RotMat(vec3 v, float angle)\n{\n\tv = normalize(v);\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\t\n\treturn mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n\t\t(1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n\t\t(1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n\t\t);\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 Render( in vec3 ro, in vec3 rd )\n{ \n\tvec3 col;\n\tlightning = vec3(0.0);\n\tvec2 res = RayMarch(ro, rd);\n\tfloat t = res.x;\n\tfloat m = res.y;\n\t\n   \tvec3 pos = ro + t*rd;\n\tvec3 nor = Normal( pos );\n\tfloat shiny = 0.0;\n\tif (m < .5)\n\t{\n\t\t\/\/ Ground...\n\t\tcol = texture(iChannel2, pos.xz*vec2(.2)+.5).xxx*.4+vec3(.04);\n\t\tcol = col*col;\n\t}else if (m < 1.5)\n\t{\n\t\t\/\/ Dog fur...\n\t\tcol = mix(vec3(.5, 0.5, 0.5), vec3(.3), Noise(pos*vec3(114.0, 13.0, 114.0)));\n\t\tshiny = .5;\n\t}else if (m < 2.5)\n\t{\n\t\t\/\/ Roof...\n\t\tcol = mix(vec3(.4, 0.0, 0.0), vec3(.15, 0., 0.0), min(pow(abs(Noise(pos*14.0)), 10.0)*40.0, .5));\n\t\tshiny = 1.5;\n\t}else if (m < 3.5)\n\t{\n\t\t\/\/ Wood...\n\t\tcol = texture(iChannel1, pos.xy*vec2(.5, 1.15)).xyz+vec3(.0, .1, 0.1);\n\t\tnor.y += WoodBump(pos.xy)*.5;\n\t\tnor = normalize(nor);\n\t\tshiny = .5;\n\t}else if (m < 4.5)\n\t{\n\t\t\/\/ Wall...\n\t\tcol = texture(iChannel0, pos.xy*vec2(.2, .5)).xyz;\n\t\tcol *= col*col*2.5;\n\t\tnor += col;\n\t\tshiny = 1.5;\n\t}else if (m < 5.5)\n\t{\n\t\tcol = vec3(.01, 0.01, 0.0);\n\t\tshiny = .8;\n\t}else\n\t{\n\t\tcol = vec3(.7);\n\t}\n\t\/\/ Rain washing down noise...\n\tfloat f = Noise(pos*vec3(50.0, 5.0, 50.0)+vec3(0.0, iTime*7.0, 0.0));\n\tcol += f * .07;\n\tshiny *= f*.25;\n\tvec3 lig = normalize( vec3(-0.3, 1.3, -0.5) );\n       float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n\tfloat sh = Shadow( pos, lig, 10.0);\n\tdif *= sh;\n\t\n\tvec3 brdf = 1.50*dif*vec3(1.00,0.90,0.70);\n\t\n\tfloat ti = mod(iTime, 12.0);\n\tf = 0.0;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tf+=.25;\n\t\tif (i == 2) f-=.1;\n\t\tlightning = smoothstep(1.3+f,1.35+f, ti) * smoothstep(1.8+f,1.4+f, ti)*vec3(1.9, 1.9, 3.7)*sh;\n\t\tbrdf += lightning;\n\t\tshiny += lightning.x;\n\t\tshiny = clamp(shiny, 0.0, 1.0);\n\t}\n\tfloat pp = clamp( dot( reflect(rd,nor), lig ), 0.0, 1.0 );\n\tfloat spe = sh*pow(max(pp, 0.0),2.0)*shiny;\n\n\tcol = (col*brdf + spe) * exp(-0.0005*t*t*t*t);\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\n\/\/----------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy\/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x\/iResolution.y;\n    vec2 mo = iMouse.xy;\n\t\/\/ Lift head...\n\tsigh = cos(iTime*1.2+1.5)*.03 + sin(iTime*.746)*.03;\n\t\/\/ Sniff stuff...\n\tfloat ti = mod(iTime, 9.0);\n\tfloat f = floor(mod(iTime\/9., 2.0));\n\tfloat r = (smoothstep(2.0, 3.0, ti) * smoothstep(8.0, 5.0, ti)) * .4;\n\t\/\/ Left or right rotation...\n\tif (f == 0.0)\n\t\tturn = RotMat(vec3(.1, 0.5, .0), r);\n\telse\n\t\tturn = RotMat(vec3(.1, -0.5, .0), r);\n\t\/\/ Do nose stuff... snff, sniff, sniiiff...\n\tnose = smoothstep(3.0, 3.1, ti)* smoothstep(3.2, 3.1, ti)*.007;\n\tnose += smoothstep(3.2, 3.3, ti)* smoothstep(3.5, 3.3, ti)*.01;\n\tnose += smoothstep(3.7, 3.9, ti)* smoothstep(4.4, 3.8, ti)*.02;\n\tsigh += nose*.75;\n\tmo = (mo \/ iResolution.xy) - .5;\n\t\n\tif (iMouse.z == 0.0)\n\t\tmo = vec2(.25,.0);\n\n\t\/\/ Camera...\n\tvec3 origin = vec3(6.0*mo.x, 3.0 + 4.0*mo.y, -4.0);\n\tvec3 target = vec3( 0.0, 0.8, 1.2 );\n\t\n\tvec3 cw = normalize( target-origin);\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = ( cross(cu,cw) );\n\tvec3 ray = normalize( p.x*cu + p.y*cv + 2.5*cw );\n\n\t\/\/ Do the pixel colours...\t\n    vec3 col = Render(origin, ray);\n\t\n\t\/\/ Tweek the colour...\n\tcol = pow( abs(col), vec3(.5));\n\t\/\/ Ye olde vignette fx...\n\tcol *= pow( abs(65.0*q.x*q.y*(1.0-q.x)*(1.0-q.y)), .4 );\n\t\n\t\/\/ Rain & Lightning together... \n\tvec2 st =  p * vec2(.5, .01)+vec2(iTime*.3-q.y*.6*-cw.x, iTime*.3);\n\t\/\/ I'm adding two parts of the texture to stop repetition...\n\tf = texture(iChannel3, st).y * texture(iChannel3, st*.773).x * 1.55;\n\tf = clamp(pow(abs(f), 23.0) * 13.0, 0.0, q.y*.14) * (lightning.x*.7+1.0);\n\tcol += f;\n\t\/\/ Fade in...\n\tcol *= min(iTime, 1.0);\n    fragColor=vec4(clamp(col, 0.0, 1.0), 1.0 );\n\t\n}\n\n\/\/----------------------------------------------------------------------------------------","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3Rn","filepath":"\/media\/a\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"\/media\/ap\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"\/media\/a\/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"\/media\/ap\/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsfGRr","channel":0}],"code":"\/\/======================================================================================================\nvec2 Rain(float n)\n{\n    \/\/ Splattering on roof sound mixed with ambient noise.\n    float vary = sin(n * .1) * .5;\n    vec2 pos = vec2(n * (5.7331+vary), n * (43.66927 - vary));\n    \/\/ High pass the sound by subtracting a lower mipmap...\n    vec2 top = (texture( iChannel0, pos, -100.0).xy) * 2.0;\n    vec2 bot = (texture( iChannel0, pos,   -5.7).xy) * 2.0;\n    \n\treturn top-bot + (texture( iChannel1, pos,   -100.0).xy-.5)* .5;\n}\n\n\/\/======================================================================================================\nvec2 Thunder(float n, float pitch, float time)\n{\n    vec2 top = (texture( iChannel0, vec2(n*pitch*4.88238+time, n*pitch*3.834181), -100.0).xz-.5)* 2.0;\n\treturn top;\n}\n\n\/\/======================================================================================================\nfloat Noise(float n)\n{\n    return (texture( iChannel1, vec2(n*343.88238, n*153.834181), -100.0).x-.5)* 2.0;\n}\n\n\/\/======================================================================================================\nvec2 mainSound( in int samp,float time)\n{\n    vec2 audio = Rain(time) * .6;\n    \n    float ti  = mod(time - .4, 12.0);\n\tfloat lightning = smoothstep(1.5, 2.2, ti) * smoothstep(9.0, 2.2, ti);\n    audio += Thunder(ti, lightning + .75, time) * lightning;\n    \n    ti = mod(time, 9.0);\n\tfloat nose = smoothstep(3.0, 3.1, ti)* smoothstep(3.2, 3.1, ti)*.6;\n\tnose += smoothstep(3.2, 3.3, ti)* smoothstep(3.5, 3.3, ti)*.3;\n\tnose += smoothstep(3.7, 3.9, ti)* smoothstep(4.4, 3.8, ti)*.7;\n    float sniff = Noise(time) * nose;\n  \taudio += vec2(sniff);\n\n    return clamp(audio, -1.0, 1.0) * (smoothstep(0.0, 3.0, time) * smoothstep(250.0, 240.0, time));\n}","name":"Sound","description":"","type":"sound"}]}];    var gUseScreenshots = piIsMobile();
    var gThemeName = "classic";



    </script>
</head>

<!-- <body onload="resultsInit(12,null,null)"> -->
<body onload="resultsInitStatic(12,null,null)">

<!-- header =================================================================================== -->


<div id="header">

    <div id="headerBlock1">
        <a href="/" id="headerTitle">Shadertoy</a>
        <form name="formSearch" action="/results" method="get" style="display:inline-block;">
        <div  id="headerSearch">
            <input type="search" id="mySearch" name="query" placeholder="Search..." value=""/>
        </div>
        </form>
    </div>

    <div id="headerBlock2">
            <a class="headerLinks" href="/browse">Browse</a>
        <a class="headerLinks" href="/new">New</a>
        <a class="headerLinks" href="/signin">Sign In</a>
        </div>
</div>
<!-- content ================================================================================== -->

<div id="content">

  <div id="controls">
    <div>
      <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
      Sort:      </div>
      <div class="controlOptions"><div class="pageButtonsCurrent" href="/results?query=&sort=popular&filter=">Popular</div><a class="pageButtons" href="/results?query=&sort=newest&filter=">Newest</a><a class="pageButtons" href="/results?query=&sort=love&filter=">Love</a><a class="pageButtons" href="/results?query=&sort=hot&filter=">Hot</a></div>
    </div>

    <div id="controlFilter">
      <div style="display:flex;margin-right:8px;align-items:center;">Filter:</div>
      <div class="controlOptions"> <a class="pageButtons" href="/results?query=&sort=popular&filter=multipass">Multipass</a><a class="pageButtons" href="/results?query=&sort=popular&filter=soundoutput">GPU Sound</a><a class="pageButtons" href="/results?query=&sort=popular&filter=vr">VR</a><a class="pageButtons" href="/results?query=&sort=popular&filter=soundinput">Microphone</a><a class="pageButtons" href="/results?query=&sort=popular&filter=musicstream">Soundcloud</a><a class="pageButtons" href="/results?query=&sort=popular&filter=webcam">Webcam</a></div>
    </div>

    <div>
        <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
        View:</div>
        <div><a class="pageButtons" href="/slideshow?query=&sort=popular">Slideshow</a></div>
    </div>

    <div class="navigation" id="navTop" ><span style="padding-right:8px;">Results (74098):</span><div class="controlOptions"><a id="pageButtonFirst" class="pageButtons" href="results?query=&sort=popular&from=0&num=12">1</a><span>...</span><a id="pageButton"0 class="pageButtons" href="results?query=&sort=popular&from=984&num=12">83</a><a id="pageButton"1 class="pageButtons" href="results?query=&sort=popular&from=996&num=12">84</a><div id="pageButton"2 class="pageButtonsCurrent" href="results?query=&sort=popular&from=1008&num=12">85</div><a id="pageButton"3 class="pageButtons" href="results?query=&sort=popular&from=1020&num=12">86</a><a id="pageButton"4 class="pageButtons" href="results?query=&sort=popular&from=1032&num=12">87</a><span>...</span><a id="pageButtonLast" class="pageButtons" href="results?query=&sort=popular&from=74088&num=12">6175</a></div>
</div>
  </div>


  <div id="shaderGrid">
    <div class='searchResult'><div class='searchResultContainer' id='Preview_0_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_0_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_0_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_0_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_0_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_0_Thumnail'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_0_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_0_Info'>  <span class='previewText'  id='Preview_0_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_0_TextUser'></span>  <span class='previewStats' id='Preview_0_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_1_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_1_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_1_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_1_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_1_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_1_Thumnail'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_1_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_1_Info'>  <span class='previewText'  id='Preview_1_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_1_TextUser'></span>  <span class='previewStats' id='Preview_1_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_2_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_2_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_2_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_2_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_2_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_2_Thumnail'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_2_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_2_Info'>  <span class='previewText'  id='Preview_2_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_2_TextUser'></span>  <span class='previewStats' id='Preview_2_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_3_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_3_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_3_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_3_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_3_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_3_Thumnail'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_3_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_3_Info'>  <span class='previewText'  id='Preview_3_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_3_TextUser'></span>  <span class='previewStats' id='Preview_3_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_4_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_4_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_4_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_4_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_4_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_4_Thumnail'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_4_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_4_Info'>  <span class='previewText'  id='Preview_4_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_4_TextUser'></span>  <span class='previewStats' id='Preview_4_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_5_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_5_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_5_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_5_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_5_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_5_Thumnail'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_5_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_5_Info'>  <span class='previewText'  id='Preview_5_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_5_TextUser'></span>  <span class='previewStats' id='Preview_5_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_6_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_6_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_6_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_6_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_6_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_6_Thumnail'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_6_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_6_Info'>  <span class='previewText'  id='Preview_6_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_6_TextUser'></span>  <span class='previewStats' id='Preview_6_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_7_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_7_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_7_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_7_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_7_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_7_Thumnail'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_7_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_7_Info'>  <span class='previewText'  id='Preview_7_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_7_TextUser'></span>  <span class='previewStats' id='Preview_7_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_8_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_8_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_8_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_8_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_8_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_8_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_8_Thumnail'>        <img class='previewThumbnailImage' id='Preview_8_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_8_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_8_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_8_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_8_Info'>  <span class='previewText'  id='Preview_8_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_8_TextUser'></span>  <span class='previewStats' id='Preview_8_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_9_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_9_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_9_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_9_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_9_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_9_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_9_Thumnail'>        <img class='previewThumbnailImage' id='Preview_9_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_9_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_9_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_9_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_9_Info'>  <span class='previewText'  id='Preview_9_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_9_TextUser'></span>  <span class='previewStats' id='Preview_9_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_10_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_10_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_10_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_10_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_10_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_10_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_10_Thumnail'>        <img class='previewThumbnailImage' id='Preview_10_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_10_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_10_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_10_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_10_Info'>  <span class='previewText'  id='Preview_10_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_10_TextUser'></span>  <span class='previewStats' id='Preview_10_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_11_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_11_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_11_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_11_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_11_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_11_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_11_Thumnail'>        <img class='previewThumbnailImage' id='Preview_11_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_11_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_11_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_11_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_11_Info'>  <span class='previewText'  id='Preview_11_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_11_TextUser'></span>  <span class='previewStats' id='Preview_11_Stats'></span></div></div>  </div>
  <br>
  <div class="navigation" id="navBottom" ><span style="padding-right:8px;">Results (74098):</span><div class="controlOptions"><a id="pageButtonFirst" class="pageButtons" href="results?query=&sort=popular&from=0&num=12">1</a><span>...</span><a id="pageButton"0 class="pageButtons" href="results?query=&sort=popular&from=984&num=12">83</a><a id="pageButton"1 class="pageButtons" href="results?query=&sort=popular&from=996&num=12">84</a><div id="pageButton"2 class="pageButtonsCurrent" href="results?query=&sort=popular&from=1008&num=12">85</div><a id="pageButton"3 class="pageButtons" href="results?query=&sort=popular&from=1020&num=12">86</a><a id="pageButton"4 class="pageButtons" href="results?query=&sort=popular&from=1032&num=12">87</a><span>...</span><a id="pageButtonLast" class="pageButtons" href="results?query=&sort=popular&from=74088&num=12">6175</a></div>
</div>  <br>      
</div>

<!-- footer ================================================================================== -->

<div id="footer">
    
    <div><span style="color:#ffffff;">Community Forums</span>
      <ul>
      <li><a class="regular" href="/events">Official Events</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/147749602472741">In Facebook (english)</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/1339783682699494">In Facebook (korean)</a></li>
      <li><a class="regular" href="https://discord.gg/XtmMN6E">In Discord</a> (<a class="regular" href="https://discordapp.com/channels/578696555612209173/579531723348639754">direct link</a>)</li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Feedback and Support</span>
      <ul>
      <li><a class="regular" href="https://www.facebook.com/Shadertoy">Facebook</a></li>
      <li><a class="regular" href="https://twitter.com/shadertoy">Twitter</a></li>
      <li><a class="regular" href="https://www.patreon.com/shadertoy">Patreon</a></li>
      <li><a class="regular" href="https://trello.com/b/5hM0CjId">Roadmap</a></li>

      
      </ul>
    </div>

    <div><span style="color:#ffffff;">Shadertoy</span>
      <ul>
      <li><a class="regular" href="/store">Store</a></li>
      <li><a class="regular" href="/howto">Documentation</a></li>
      <li><a class="regular" href="/terms">Terms & Privacy</a></li>
      <li><a class="regular" href="/about">About</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Apps and Plugins</span>
      <ul>
      <li><a class="regular" href="https://itunes.apple.com/us/app/shadertoy/id717961814">Official iPhone App</a> by <a class="user" href="/user/reinder">Reinder</a></li>
      <li><a class="regular" href="https://steamcommunity.com/sharedfiles/filedetails/?id=1726697188">Screensaver</a> by <a class="user" href="/user/kosro">Kosro</a></li>
      <li><a class="regular" href="https://chrome.google.com/webstore/detail/shadertoy-unofficial-plug/ohicbclhdmkhoabobgppffepcopomhgl">Shadertoy plugin</a> by <a class="user" href="/user/patu">Patu</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Tutorials</span>
      <ul>
      <li><a class="regular" href="https://www.youtube.com/watch?v=0ifChJ0nJfM">Shader coding intro</a> by <a class="user" href="/user/iq">iq</a></li>
      <li><a class="regular" href="https://shadertoyunofficial.wordpress.com/">Shadertoy Unofficial</a> by <a class="user" href="/user/FabriceNeyret2">FabriceNeyret2</a></li>
      </ul>
    </div>

</div>

<div id="compliance" style="padding-bottom:6px;visibility:hidden;left:0;top:0px;width:100%;background-color:rgb(200,120,20,0.93);position:absolute;color:#FFFFFF">
    <div style="text-align: center; margin-top:8px">
        We use cookies to give you the best experience on our website. If you continue using Shadertoy, we'll assume that you are happy to receive all cookies on this website. 
        For more information, please review our <a class="regular" href="/terms">Terms & Privacy</a>.
    </div> 
    <div style="text-align: center;margin-top:6px">
        <button type="button" style="width:100px;font-size:inherit" onclick="acceptCompliance()">Accept</button>
    </div>
</div>

<script>
(function runCompliance() 
{
    let showCompliance = 1;
    let allcookies = document.cookie;
    let cookiearray = allcookies.split(';');
    for (var i=0; i<cookiearray.length; i++)
    {
        let name  = cookiearray[i].split('=')[0];
        let value = cookiearray[i].split('=')[1];
        if (name.trim() == "scmp") 
        {
            showCompliance = value;
            break;
        }
    }

    if (showCompliance === 1) 
    {
        var ve = document.getElementById("compliance");
        ve.style.visibility="visible";
    }
})();

function acceptCompliance()
{
    let now = new Date();
    now.setTime( now.getTime() + (5*365*24*60*60*1000) );
    document.cookie="scmp=0;expires=" + now.toUTCString() + ";";

    var ve = document.getElementById("compliance");
    ve.style.visibility="hidden";
}
</script>

</body>
</html>
