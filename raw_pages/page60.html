<!DOCTYPE HTML>
<html lang="en">
<head>

    
<script async src="https://www.googletagmanager.com/gtag/js?id=G-7SYLWGZYJ2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-7SYLWGZYJ2');
</script>

<title>Browse (61) - Shadertoy BETA</title>
<meta charset="utf-8" />
<meta name="Keywords" content="shadertoy, shader toy, quilez, inigo, jeremias, pol, fractals, demoscene, computer graphics, mathematics, rendering, demo, 3D, realtime, shader, raytracing, raymarching, webgl, glsl" />
<meta name="Description" content="Build shaders, share them, and learn from the best community." />
<meta name="Author" content="Beautypi" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<link rel="image_src" href="https://www.shadertoy.com/img/logo.png" />
<link rel="apple-touch-icon" href="/img/launch_icon_57.png"/>
<link rel="apple-touch-icon" sizes="72x72" href="/img/launch_icon_72.png"/>
<link rel="apple-touch-icon" sizes="114x114" href="/img/launch_icon_114.png"/>
<link rel="shortcut icon" href="/img/favicon.ico"/>

<style>::-webkit-scrollbar {
    height: 8px;
    width: 8px;
    background: #404040;
}

::-webkit-scrollbar-thumb
{
    background: #909090;
    border-radius: 0ex;
}

::-webkit-scrollbar-corner
{
    background: #000;
}

::-webkit-input-placeholder
{
	font-style:italic;
}
input:-moz-placeholder, textarea:-moz-placeholder
{
	font-style:italic;
}
input.placeholder-text, textarea.placeholder-text
{
	font-style:italic;
}

pre 
{
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
    white-space: -pre-wrap;
    white-space: -o-pre-wrap;
    word-wrap: break-word;
}

@font-face
{
    font-family: Lobster;
    src: url("/img/lobster.otf") format("opentype");
}

div#centerScreen
{
    left: 50%;
    top: 50%;
    position: absolute;
}

a.headerLinks:hover
{
    background-color:#505050;
    color : #ff8020;
}

body
{
    color: #000000;
    font-size:12px;
    font-style:normal;
    font-family:Tahoma,Arial;
    background-repeat: no-repeat;
    //background-attachment: fixed;
    padding:0px;
    margin:0px;
    text-align: left;
    background-color: #d0d0d0;
    background-repeat: repeat;
    user-select: text;
}

a,
a:hover,
a:visited
{
  color : inherit;
}

div#content {
    width: 95%;
    overflow: hidden;
    margin: auto;
    padding: 0px;
    min-height: calc(100vh - 80px);
    //box-sizing: border-box;
}


.notificationCount
{
 background-color:#ff0000;
 padding-left:3px;
 padding-right:1px;
 padding-top:1px;
 padding-bottom:1px;
}

div#header
{
    background-color: #404040;
    top: 0px;
    left: 0px;
    width: 100%;
    padding: 0;
    margin: 0;
    color: #ffffff;
    display: flex;
    flex-direction:row;
}

#headerBlock1
{
    width: 50%;
    display:flex;
    align-items:center;
}

a#headerTitle
{
    font-size: 2.25em;
    font-family: Lobster,Tahoma,Arial;
    text-decoration: none;
    padding-left:32px;
    padding-right:32px;
}

#headerSearch
{
    display: inline-block;
    color: #000000;
    width: 300px;
}

input[type=search]#mySearch
{
    width: 100%;
    border-radius: 6px;
    border: 1px solid black;
    padding:12px;
}

#headerBlock2
{
    width: 50%;
    margin-left: auto;
    display: flex;
    justify-content: flex-end;
}


a#headerTitle:hover
{
    color : #ff8020;
}

a.headerLinks
{
    font-weight: bold;
    padding-top: 14px;
    padding-bottom: 14px;
    padding-left: 14px;
    padding-right: 14px;
    margin:0px;
    text-decoration: none;
    transition: background-color 0.15s linear, color 0.15s linear;
}

#footer
{
    background-color: rgba(64,64,64,0.25);
    color: #000000;
    padding: 0px;
    margin: 0px;
    width: 100%;
    display: flex;
    justify-content: space-between;
    flex-wrap: wrap;
}

#footer div
{
    padding-top:10px;
    padding-bottom:0px;
    padding-left:16px;
    padding-right:16px;
}

#footer div ul
{
    margin-left:0px;
    padding-left:16px;
}

#footer div ul li
{
    padding-top:6px;
}

a.regular
{
    font-weight:bold;
    text-decoration:none
}

a.regular:hover
{
  color : #ff8020;
}

a.user
{
    font-weight:bold;
    text-decoration:none;
}

a.user:hover
{
  color : #ff8020;
  text-decoration: underline;
}

.uiButton
{
    border: none;
    outline: none;
    margin: 0px;
    padding: 0px;
    width: 22px;
    height: 22px;
    position: absolute;
    cursor: pointer;
    border-radius: 4px;
}

.uiButton:hover
{
    box-shadow: inset 0px 0px 1px 1px #808080, 0px 0px 1px 1px #808080;
}

.uiDivBUtton
{
    cursor:pointer;
}

.uiDivBUtton:hover
{
    color: #ffffff;
}


.dialog
{
    display: block;
    background-color: #e0e0e0;
    color: #000000;
    border:1px solid #000;
    padding:0px;
    margin:0px;
    text-align:left;
    border-radius: 4px;
    box-shadow:4px 4px 6px 0px rgba(0,0,0,0.5);
    overflow: hidden;
    z-index:1000;
    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;
}

.dialogHeader
{
    left:0px;
    top: 0px;
    width:100%;
    height:32px;
    position: absolute;
    background-color: #808080;
    cursor:move;
}

.dialogTitle
{
    left: 12px;
    top: 4px;
    position: absolute;
    padding: 0px;
    margin: 0px;
    color:#000000;
    font-size:1.5em;
    text-align: left;
    user-select: none;
    -moz-user-select: -moz-none;
    -webkit-user-select: none;
}

.dialogOverlay
{
    z-index:1000;

    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;

    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    width:100%;
    height:100%;
    position:absolute;

    background-color:rgba(0,0,0,.4);
}

.viewsIcon, .likesIcon
{
    border: none;
    outline: none;
    display:inline-block;
    background-repeat:no-repeat;
    top:0px;
    left:0px;
    padding:0px;
    padding-right: 2px;
    margin:0px;
    position:relative;
}

.userPictureSmall
{
    background-color:#808080;
    border: 1px solid #000000;
    width:32px;
    height:32px;
}

.dialogCloseButton
{
    right:8px;
    top: 4px;
    width:22px;
    height:22px;
    position: absolute;
    background-image: url("/img/close.png");
    cursor: pointer;
    border-radius: 4px;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContentButtons
{
     padding:0;
     border:0;
     text-align: justify;
     left: 24px;
     bottom:40px;
     position:absolute;
}

.dialogButton
{
    text-align: center;
    vertical-align: middle;
    display: inline-block;
    border-radius: 4px;
    font-weight: bold;
    cursor: pointer;
    padding-bottom:5px;
    padding-top:4px;
    padding-left: 8px;
    padding-right: 8px;
    margin-left:4px;
    margin-right:4px;
    text-decoration: none;
    color:#000000;
    width: 80px;
    -moz-transition:    background-color 0.15s linear, color 0.15s linear;
    -webkit-transition: background-color 0.15s linear, color 0.15s linear;
    transition:         background-color 0.15s linear, color 0.15s linear;
}

.dialogButton:hover
{
  background-color:#808080;
  color : #ff8020;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContent
{
    color: inherit;
    overflow: auto;
    width:100%;
    height:100%;
    left: 0px;
    top: 32px;
    position:absolute
}

.dialogContentBody
{
    color: inherit;
    width:100%;
    height:auto;
    padding-top:24px;
    padding-bottom:24px;
    padding-left:24px;
    padding-right:24px;
    text-align: left;
}

.formButton
{
    font-weight:bold;
	color:#ffffff;
	border:none;
    text-align:center;
	background-color:#808080;
    border-radius: 4px;
	padding-left:8px;
	padding-right:8px;
	padding-top:4px;
	padding-bottom:4px;
    cursor:pointer;
    min-width:80px;
    box-sizing: border-box;
}
.formInput {
    border-radius: 6px;
    border: 1px solid black;
    padding: 4px;
    border: none;
}
.formButton:hover {
    background-color: #e0e0e0;
}
.formButton:disabled
{
	color:#b0b0b0;
	background-color:#808080;
}

.formButtonSmall
{
    color:#ffffff;
    border:none;
    text-align:center;
    background-color:#808080;
    border-radius: 4px;
    padding-left:2px;
    padding-right:2px;
    padding-top:2px;
    padding-bottom:2px;
    cursor:pointer;
    min-width:40px;
}

.formButtonSmall:hover
{
    background-color: #e0e0e0;
}

.formButtonSmall:disabled
{
    color:#b0b0b0;
    background-color:#808080;
}

.formButtonSmall.disabled2,
.formButton.disabled2 { color:#b0b0b0; background-color:#808080; pointer-events: none; }

.inputForm
{
    padding-left:2%;
    padding-right:2%;
    resize: none;
    text-align: left;
    background-color:#e0e0e0;
    outline: none;
    border-radius: 4px;
    border: 1px solid #808080;
    color:inherit;
    box-sizing: border-box;
}

.inputForm:focus
{
    border: 1px solid #AFCDD8;
    background-color: #EBF2F4;
}

.transparentPannel
{
    background-color:rgba(64,64,64,0.1);
    padding:16px;
}

.comment, .commentSelf, .commentNew
{
    border-radius: 4px;
    width: 100%;
    margin-left: 0px;
    margin-right: 0px;
    margin-top: 0px;
    margin-bottom: 6px;

    padding: 14px;
    box-sizing: border-box;
    display: grid;
    grid-template-columns: 32px auto 8px;
    grid-template-rows: 1fr;
    grid-gap:8px;
}

.comment:nth-child(even)
{
    background-color: rgba(64,64,64,0.1);
}

.comment:nth-child(odd)
{
    background-color: rgba(128,128,128,0.1);
}

.commentSelf
{
    background-color: rgba(240,160,64,0.1);
}

.commentNew
{
    padding-right: 0px;
    grid-template-columns: 40px auto;
}

.commentContent
{
    vertical-align: top;
    text-align: left;
    word-break: break-all;
    word-break: break-word;
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
}


/* ----------------------- media resolutions ------------------------ */

@media screen and (max-width:799px)
{
    div#header {flex-direction:column; }
    #headerBlock1 { width:100%; }
    #headerBlock2 { width:100%; justify-content: space-around;}
    div#headerSearch {width:200px;}
    input#mySearch { width:200px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:10px; }
}

@media screen and (min-width:800px) and (max-width:1279px)
{
    body { font-size: 9px; }
    div#headerSearch {width: 250px;}
    input#mySearch { width:250px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:11px; }
}

@media screen and (min-width:1280px) and (max-width:1439px)
{
    body { font-size: 10px; }
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1440px) and (max-width:1919px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1920px) and (max-width:2559px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}

@media screen and (min-width:2560px) 
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}
body
{
    background-image: url("/img/themes/classic/background.jpg");
}
</style>

    <script>"use strict"

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piCamera
//
//==============================================================================

function piCamera()
{
    var mMatrix = setIdentity();
    var mMatrixInv = setIdentity();

    var mPosition = [0.0,0.0,0.0];
    var mXRotation = 0.0;
    var mYRotation = 0.0;

    var mPositionTarget = [0.0,0.0,0.0];
    var mXRotationTarget = 0.0;
    var mYRotationTarget = 0.0;

    var me = {};
/*
    me.Set = function( pos, dir, roll) 
             {
                 mMatrix    = setLookat( pos, add(pos,dir), [Math.sin(roll),Math.cos(roll),Math.sin(roll)] );
                 mMatrixInv = invertFast( mMatrix );
             };
*/
    me.SetPos = function(pos)
                {
                    mPosition = pos;
                    //mMatrix[ 3] = -(mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                    //mMatrix[ 7] = -(mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                    //mMatrix[11] = -(mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                };
/*
    me.GlobalMove = function(pos)
                    {
                        mMatrix[ 3] -= (mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                        mMatrix[ 7] -= (mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                        mMatrix[11] -= (mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                        mMatrixInv = invertFast(mMatrix);
                    };
*/
    me.LocalMove = function( dis )
                    {
                        dis = matMulvec( setRotationY(-mYRotation), dis);
                        mPositionTarget = sub(mPositionTarget,dis)
                    };

    me.RotateXY = function( x, y)
                  {
                    mXRotationTarget -= x;
                    mYRotationTarget -= y;
                    mXRotationTarget = Math.min( Math.max( mXRotationTarget, -Math.PI/2), Math.PI/2 );
                  };


    me.CameraExectue = function( dt )
    {
        // smooth position
        mXRotation += (mXRotationTarget-mXRotation) * 12.0*dt;
        mYRotation += (mYRotationTarget-mYRotation) * 12.0*dt;
        mPosition = add(mPosition, mul( sub(mPositionTarget, mPosition), 12.0*dt));

        // Make Camera matrix
        mMatrix = matMul( matMul(setRotationX(mXRotation), 
                                 setRotationY(mYRotation)),  
                                 setTranslation(mPosition));
        mMatrixInv = invertFast(mMatrix);

    }

    me.GetMatrix = function() { return mMatrix; };
    me.GetMatrixInverse = function() { return mMatrixInv; };
    me.SetMatrix = function( mat ) 
                    {
                        mMatrix = mat;
                        mMatrixInv = invertFast(mMatrix);

                        mPosition = getXYZ(matMulpoint(mat, [0.0,0.0,0.0]));
                        mPositionTarget = mPosition;
                    };

    me.GetPos = function() { return getXYZ(matMulpoint(mMatrixInv, [0.0,0.0,0.0])); }
    me.GetDir = function() { return getXYZ(normalize(matMulvec(mMatrixInv, [0.0,0.0,-1.0]))); }

    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piFile
//
//==============================================================================

function piFile( binaryDataArrayBuffer )
{
    // private
    //var mDataView = new DataView( binaryDataArrayBuffer, 0 );
    var mDataView = binaryDataArrayBuffer;
    var mOffset = 0;

    // public members
    var me = {};
    me.mDummy = 0;
/*
    // public functions
    me.Seek = function( off ) { mOffset = off - 3; };
    me.ReadUInt16 = function()  { var res = mDataView.getUint16( mOffset ); mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = mDataView.getUint32( mOffset ); mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = mDataView.getFloat32( mOffset ); mOffset+=4; return res; };
*/

    me.Seek = function( off ) { mOffset = off; };
    me.ReadUInt8  = function()  { var res = (new Uint8Array(mDataView,mOffset))[0]; mOffset+=1; return res; };
    me.ReadUInt16 = function()  { var res = (new Uint16Array(mDataView,mOffset))[0]; mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = (new Uint32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = (new Float32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadFloat32Array = function(n) 
                          { 
                              var src = new Float32Array(mDataView, mOffset);
                              var res = [];  for( var i=0; i<n; i++ ) { res[i] = src[i]; }
                              mOffset += 4*n;
                              return res;
                          };
    me.ReadFloat32ArrayNative = function(n) { var src = new Float32Array(mDataView, mOffset); mOffset += 4*n; return src; };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piMesh
//
//==============================================================================

function piMesh()
{
    this.mChunks = [];
    this.mPrimitiveType = 0;
    this.mVertexFormat = null;
}

/*
piMesh.prototype.normalize = function( ppos, npos )
{
    var numv = this.mVertexData.length;
    var numt = this.mIndices.length;

    for( var i=0; i<numv; i++ )
    {
        //float *v = (float*)piMesh_GetVertexData( me, i, npos );
        //v[0] = 0.0f;
        //v[1] = 0.0f;
        //v[2] = 0.0f;
        this.mVerts[8 * i + 3] = 0.0;
        this.mVerts[8 * i + 4] = 0.0;
        this.mVerts[8 * i + 5] = 0.0;
    }

    for( var i=0; i<numt; i++ )
    {
        piMeshFace *face = me->mFaceData.mIndexArray[0].mBuffer + i;

        const int ft = face->mNum;
        
        vec3 nor = vec3( 0.0f, 0.0f, 0.0f );
        for( int j=0; j<ft; j++ )
        {
            const vec3 va = *((vec3*)piMesh_GetVertexData( me, face->mIndex[ j      ], ppos ));
            const vec3 vb = *((vec3*)piMesh_GetVertexData( me, face->mIndex[(j+1)%ft], ppos ));

            nor += cross( va, vb );
        }

        for( int j=0; j<ft; j++ )
        {
            vec3 *n = (vec3*)piMesh_GetVertexData( me, face->mIndex[j], npos );
            n->x += nor.x;
            n->y += nor.y;
            n->z += nor.z;
        }
    }

    for( var i=0; i<numv; i++ )
    {
        vec3 *v = (vec3*)piMesh_GetVertexData( me, i, npos );
        *v = normalize( *v );
    }
}
*/

piMesh.prototype.createCube = function(renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([ -1.0, -1.0, -1.0,
                                       1.0, -1.0, -1.0,
                                      -1.0,  1.0, -1.0,
                                       1.0,  1.0, -1.0,
                                      -1.0, -1.0,  1.0,
                                       1.0, -1.0,  1.0,
                                      -1.0,  1.0,  1.0,
                                       1.0,  1.0,  1.0 ]),

                        mIndices : new Uint16Array([ 0, 2, 1,   1, 2, 3,   5, 1, 3,   5, 3, 7,   4, 5, 7,   4, 7, 6,   4, 6, 2,   4, 2, 0,   6, 7, 3,   6, 3, 2,   4, 0, 1,   4, 1, 5 ]),
                        mNumVertices : 8,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };

    this.mVertexFormat = { mStride:12, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}

piMesh.prototype.createCubeSharp = function (renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 1.0,
                                    -1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 0.0,

                                     1.0, 1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 0.0,

                                     1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 1.0,
                                    -1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   1.0, 1.0,
                                     1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   1.0, 0.0,

                                    -1.0, 1.0, 1.0,  -1.0, 0.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0,-1.0,  -1.0, 0.0, 0.0,   0.0, 1.0,
                                    -1.0,-1.0,-1.0,  -1.0, 0.0, 0.0,   1.0, 1.0,
                                    -1.0,-1.0, 1.0,  -1.0, 0.0, 0.0,   1.0, 0.0 ]),

                        mIndices : new Uint16Array([0,1,2, 0,2,3,   4,5,6, 4,6,7,    8,9,10,8,10,11,   12,13,14,12,14,15,   16,17,18,16,18,19,   20,21,22,20,22,23]),
                        mNumVertices : 24,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };


    this.mVertexFormat = { mStride:32, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}


piMesh.prototype.createUnitQuad = function (renderer)
{
    this.mPrimitiveType = 0;
    this.mVertexFormat = { mStride:8, mChannels: [ {mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false} ] };

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0,  1.0, 1.0,  1.0]),
                        mIndices : new Uint16Array([0, 2, 1, 1, 2, 3]),
                        mNumVertices : 4,
                        mNumFaces : 2, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };
 
    return true;
}




piMesh.prototype.destroy = function()
{
    //delete this.mVerts;   this.mVerts = null;
    //delete this.mIndices; this.mIndices = null;
}

piMesh.prototype.scale = function (x, y, z)
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] *= x;
            this.mChunks[j].mVerts[stride * i + 1] *= y;
            this.mChunks[j].mVerts[stride * i + 2] *= z;
        }
    }
}

piMesh.prototype.translate = function (x, y, z) 
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] += x;
            this.mChunks[j].mVerts[stride * i + 1] += y;
            this.mChunks[j].mVerts[stride * i + 2] += z;
        }
    }
}

piMesh.prototype.GPULoad = function (renderer)
{
    for( var i=0; i<this.mChunks.length; i++ )
    {
        var vbo = renderer.CreateVertexArray(this.mChunks[i].mVerts, renderer.BUFTYPE.STATIC );
        if (vbo == null)
            return false;

        var ibo = renderer.CreateIndexArray(this.mChunks[i].mIndices, renderer.BUFTYPE.STATIC);
        if (ibo == null)
            return false;

        this.mChunks[i].mVBO = vbo;
        this.mChunks[i].mIBO = ibo;
    }
    return true;
}

piMesh.prototype.GPURender = function (renderer, positions )//, matPrj, matCam )
{
    //renderer.SetShaderConstantMat4F("unMPrj", matPrj, false );

    var num = this.mChunks.length;
    for( var i=0; i<num; i++ )
    {
        //var mat =  matMul( matCam, this.mChunks[i].mTransform );
        //renderer.SetShaderConstantMat4F("unMMod", mat, false);

        renderer.AttachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat, positions );
        renderer.AttachIndexArray(this.mChunks[i].mIBO );
        renderer.DrawPrimitive(renderer.PRIMTYPE.TRIANGLES, this.mChunks[i].mNumFaces * 3, true, 1);
        renderer.DetachIndexArray(this.mChunks[i].mIBO);
        renderer.DetachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat );
    }
}
//==============================================================================
//
// piLibs 2014-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piRenderer
//
//==============================================================================

function piRenderer()
{
    // private members

    var mGL = null;
    var mBindedShader = null;
    var mIs20 = false;
    var mFloat32Textures;
    var mFloat32Filter;
    var mFloat16Textures;
    var mDrawBuffers;
    var mDepthTextures;
    var mDerivatives;
    var mFloat16Filter;
    var mShaderTextureLOD;
    var mAnisotropic;
    var mRenderToFloat32F;
    var mDebugShader;
    var mAsynchCompile;

    var mVBO_Quad = null;
    var mVBO_Tri = null;
    var mVBO_CubePosNor = null;
    var mVBO_CubePos = null;
    var mShaderHeader = ["",""];
    var mShaderHeaderLines = [0,0];

    // public members
    var me = {};

    me.CLEAR      = { Color: 1, Zbuffer : 2, Stencil : 4 };
    me.TEXFMT     = { C4I8 : 0, C1I8 : 1, C1F16 : 2, C4F16 : 3, C1F32 : 4, C4F32 : 5, Z16 : 6, Z24 : 7, Z32 : 8, C3F32:9 };
    me.TEXWRP     = { CLAMP : 0, REPEAT : 1 };
    me.BUFTYPE    = { STATIC : 0, DYNAMIC : 1 };
    me.PRIMTYPE   = { POINTS : 0, LINES : 1, LINE_LOOP : 2, LINE_STRIP : 3, TRIANGLES : 4, TRIANGLE_STRIP : 5 };
    me.RENDSTGATE = { WIREFRAME : 0, FRONT_FACE : 1, CULL_FACE : 2, DEPTH_TEST : 3, ALPHA_TO_COVERAGE : 4 };
    me.TEXTYPE    = { T2D : 0, T3D : 1, CUBEMAP : 2 };
    me.FILTER     = { NONE : 0, LINEAR : 1, MIPMAP : 2, NONE_MIPMAP : 3 };
    me.TYPE       = { UINT8 : 0, UINT16 : 1, UINT32 : 2, FLOAT16: 3, FLOAT32 : 4, FLOAT64: 5 };

    // private functions

    var iFormatPI2GL = function( format )
    {
        if( mIs20 )
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA8,           mGLExternal: mGL.RGBA,             mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.R8,              mGLExternal: mGL.RED,              mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.R16F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA16F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.R32F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA32F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C3F32) return { mGLFormat: mGL.RGB32F,          mGLExternal: mGL.RGB,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT16, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z24)   return { mGLFormat: mGL.DEPTH_COMPONENT24, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z32)   return { mGLFormat: mGL.DEPTH_COMPONENT32F, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        }
        else
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.RED,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT, mGLExternal: mGL.DEPTH_COMPONENT, mGLType: mGL.UNSIGNED_SHORT }
        }

        return null;
     }

    // public functions

    me.Initialize = function( gl )
                    {
                        mGL = gl;

                        mIs20 = !(gl instanceof WebGLRenderingContext);

                        if( mIs20 )
                        {
                            mFloat32Textures  = true;
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = true;
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = true;
                            mDrawBuffers      = true;
                            mDepthTextures    = true;
                            mShaderTextureLOD = true;
                            mAnisotropic = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mGL.getExtension( 'EXT_color_buffer_float');
                            mDebugShader = mGL.getExtension('WEBGL_debug_shaders');
                            mAsynchCompile = mGL.getExtension('KHR_parallel_shader_compile');

							mGL.hint( mGL.FRAGMENT_SHADER_DERIVATIVE_HINT, mGL.NICEST);
                        }
                        else
                        {
                            mFloat32Textures  = mGL.getExtension( 'OES_texture_float' );
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = mGL.getExtension( 'OES_texture_half_float' );
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = mGL.getExtension( 'OES_standard_derivatives' );
                            mDrawBuffers      = mGL.getExtension( 'WEBGL_draw_buffers' );
                            mDepthTextures    = mGL.getExtension( 'WEBGL_depth_texture' );
                            mShaderTextureLOD = mGL.getExtension( 'EXT_shader_texture_lod' );
                            mAnisotropic      = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mFloat32Textures;
                            mDebugShader      = null;
                            mAsynchCompile    = null;
							
							if( mDerivatives !== null) mGL.hint( mDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, mGL.NICEST);
                        }
                        
                        
                        var maxTexSize = mGL.getParameter( mGL.MAX_TEXTURE_SIZE );
                        var maxCubeSize = mGL.getParameter( mGL.MAX_CUBE_MAP_TEXTURE_SIZE );
                        var maxRenderbufferSize = mGL.getParameter( mGL.MAX_RENDERBUFFER_SIZE );
                        var extensions = mGL.getSupportedExtensions();
                        var textureUnits = mGL.getParameter( mGL.MAX_TEXTURE_IMAGE_UNITS );
                        console.log("WebGL (2.0=" + mIs20 + "):" +
                                    " Asynch Compile: "  + ((mAsynchCompile !==null) ? "yes" : "no") +
                                    ", Textures: F32 ["   + ((mFloat32Textures !==null) ? "yes" : "no") +
                                    "], F16 ["   + ((mFloat16Textures !==null) ? "yes" : "no") +
                                    "], Depth [" + ((mDepthTextures   !==null) ? "yes" : "no") +
                                    "], LOD ["    + ((mShaderTextureLOD!==null) ? "yes" : "no") +
                                    "], Aniso ["   + ((mAnisotropic     !==null) ? "yes" : "no") +
                                    "], Units [" + textureUnits +
                                    "], Max Size [" + maxTexSize +
                                    "], Cube Max Size [" + maxCubeSize +
                                    "], Targets: MRT ["            + ((mDrawBuffers     !==null) ? "yes" : "no") +
                                    "], F32 ["     + ((mRenderToFloat32F!==null) ? "yes" : "no") +
                                    "], Max Size [" + maxRenderbufferSize + "]");

                        // create a 2D quad Vertex Buffer
                        var vertices = new Float32Array( [ -1.0, -1.0,   1.0, -1.0,    -1.0,  1.0,     1.0, -1.0,    1.0,  1.0,    -1.0,  1.0] );
                        mVBO_Quad = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                        mGL.bufferData( mGL.ARRAY_BUFFER, vertices, mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 2D triangle Vertex Buffer
                        mVBO_Tri = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0,   3.0, -1.0,    -1.0,  3.0] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePosNor = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0, -1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                               1.0,  1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                               1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                               1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                               1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0,  1.0, -1.0,   0.0,  0.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePos = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0,  1.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        //-------------------------------------------------------------------

                        mShaderHeader[0] = "";
                        mShaderHeaderLines[0] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[0] += "#version 300 es\n" +
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[0] += 6;
                        }
                        else
                        {
                            mShaderHeader[0] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "#endif\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+                                                
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[0] += 26;
                        }

                        //-------------------------------------------------------

                        mShaderHeader[1] = "";
                        mShaderHeaderLines[1] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[1] += "#version 300 es\n"+
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[1] += 6;
                        }
                        else
                        {
                            if( mDerivatives ) { mShaderHeader[1] += "#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n"; mShaderHeaderLines[1]+=3; }
                            if( mShaderTextureLOD  ) { mShaderHeader[1] += "#extension GL_EXT_shader_texture_lod : enable\n"; mShaderHeaderLines[1]++; }
                            mShaderHeader[1] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "#endif\n"+ 
                                                "vec4 texture(     sampler2D   s, vec2 c)                   { return texture2D(s,c); }\n"+
                                                "vec4 texture(     sampler2D   s, vec2 c, float b)          { return texture2D(s,c,b); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c )                  { return textureCube(s,c); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c, float b)          { return textureCube(s,c,b); }\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[1] += 30;
                            if( mShaderTextureLOD )
                            {
                            mShaderHeader[1] += "vec4 textureLod(  sampler2D   s, vec2 c, float b)          { return texture2DLodEXT(s,c,b); }\n";
                            mShaderHeader[1] += "vec4 textureGrad( sampler2D   s, vec2 c, vec2 dx, vec2 dy) { return texture2DGradEXT(s,c,dx,dy); }\n";
                            mShaderHeaderLines[1] += 2;

                            //mShaderHeader[1] += "vec4 texelFetch( sampler2D s, ivec2 c, int l) { return texture2DLodEXT(s,(vec2(c)+0.5)/vec2(800,450),float(l)); }\n";
                            //mShaderHeaderLines[1] += 1;
                            }
                        }

                        return true;
                    };

        me.GetCaps =    function ()
                        {   
                            return { mIsGL20 : mIs20,
                                     mFloat32Textures: mFloat32Textures != null,
                                     mFloat16Textures: mFloat16Textures != null,
                                     mDrawBuffers: mDrawBuffers != null,
                                     mDepthTextures: mDepthTextures != null,
                                     mDerivatives: mDerivatives != null,
                                     mShaderTextureLOD: mShaderTextureLOD != null };
                        };

        me.GetShaderHeaderLines = function (shaderType)
                        {   
                            return mShaderHeaderLines[shaderType];
                        };

        me.CheckErrors = function()
                         {
                                var error = mGL.getError();
                                if( error != mGL.NO_ERROR ) 
                                { 
                                    for( var prop in mGL ) 
                                    {
                                        if( typeof mGL[prop] == 'number' ) 
                                        {
                                            if( mGL[prop] == error )
                                            {
                                                console.log( "GL Error " + error + ": " + prop );
                                                break;
                                            }
                                        }
                                    }
                                }
                         };

        me.Clear =  function( flags, ccolor, cdepth, cstencil )
                    {
                        var mode = 0;
                        if( flags & 1 ) { mode |= mGL.COLOR_BUFFER_BIT;   mGL.clearColor( ccolor[0], ccolor[1], ccolor[2], ccolor[3] ); }
                        if( flags & 2 ) { mode |= mGL.DEPTH_BUFFER_BIT;   mGL.clearDepth( cdepth ); }
                        if( flags & 4 ) { mode |= mGL.STENCIL_BUFFER_BIT; mGL.clearStencil( cstencil ); }
                        mGL.clear( mode );
                    };


        me.CreateTexture = function ( type, xres, yres, format, filter, wrap, buffer)
                           {
                                if( mGL===null ) return null;

                                var id = mGL.createTexture();

                                var glFoTy = iFormatPI2GL( format );
                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                if( type===me.TEXTYPE.T2D )
                                {
                                    mGL.bindTexture( mGL.TEXTURE_2D, id );
//if( buffer==null )
    //mGL.texStorage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres);
//else
                                    mGL.texImage2D( mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap );

                                    if (filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                }
                                else if( type===me.TEXTYPE.T3D )
                                {
                                    if( mIs20 )
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_3D, id );
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_BASE_LEVEL, 0);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAX_LEVEL, Math.log2(xres));
                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_3D);
                                        }
                                        mGL.texImage3D( mGL.TEXTURE_3D, 0, glFoTy.mGLFormat, xres, yres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap );

                                        if (filter === me.FILTER.MIPMAP)
                                            mGL.generateMipmap( mGL.TEXTURE_3D );
                                        mGL.bindTexture( mGL.TEXTURE_3D, null );
                                    }
                                    else 
                                    {
                                        return null;
                                    }
                                }
                                else 
                                {
                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );

                                    // this works great if we know the number of required mipmaps in advance (1, or other)
                                   //mGL.texStorage2D( mGL.TEXTURE_CUBE_MAP, 1, glFoTy.mGLFormat, xres, yres );

                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                    if( filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                    }

                                    if (filter === me.FILTER.MIPMAP)
                                        mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );

                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                }
                        return { mObjectID: id, mXres: xres, mYres: yres, mFormat: format, mType: type, mFilter: filter, mWrap: wrap, mVFlip:false };
                        };

        me.CreateTextureFromImage = function ( type, image, format, filter, wrap, flipY) 
                                {
                                    if( mGL===null ) return null;

                                    var id = mGL.createTexture();

                                    var glFoTy = iFormatPI2GL( format );

                                    var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                    if( type===me.TEXTYPE.T2D )
                                    {
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);

                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.pixelStorei(mGL.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                                        if( mIs20 ) mGL.pixelStorei(mGL.UNPACK_COLORSPACE_CONVERSION_WEBGL, mGL.NONE );

                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);

                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);

                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if( filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                    }
                                    else if( type===me.TEXTYPE.T3D )
                                    {
                                        return null;
                                    }
                                    else 
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );

                                        if( filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                    }
                                    return { mObjectID: id, mXres: image.width, mYres: image.height, mFormat: format, mType: type, mFilter: filter, mWrap:wrap, mVFlip:flipY };
                                };

        me.SetSamplerFilter = function (te, filter, doGenerateMipsIfNeeded) 
                            {
                                if (te.mFilter === filter) return;

                                if (te.mType === me.TEXTYPE.T2D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_3D, null);

                                }
                                else
                                {
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }


                                te.mFilter = filter;
                            };

        me.SetSamplerWrap = function (te, wrap)
                            {
                                if (te.mWrap === wrap) return;

                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, id);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, id);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_3D, null);
                                }

                                te.mWrap = wrap;
                            };

        me.SetSamplerVFlip = function (te, vflip, image)
                            {
                                if (te.mVFlip === vflip) return;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    if( image != null)
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                }
                                else if (te.mType === me.TEXTYPE.CUBEMAP)
                                {
                                    if( image != null)
                                    {
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei( mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
        
                                }

                                te.mVFlip = vflip;
                            };

        me.CreateMipmaps =  function (te)
                            {
                                if( te.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);
                                    mGL.generateMipmap(mGL.TEXTURE_2D);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);
                                }
                                else if( te.mType===me.TEXTYPE.CUBEMAP )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);
                                    mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }
                            };

        me.UpdateTexture =  function( tex, x0, y0, xres, yres, buffer )
                            {
                                var glFoTy = iFormatPI2GL( tex.mFormat );
                                if( tex.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture( mGL.TEXTURE0);
                                    mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                    mGL.texSubImage2D( mGL.TEXTURE_2D, 0, x0, y0, xres, yres, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                }
                            };

        me.UpdateTextureFromImage = function( tex, image )
                                {
                                    var glFoTy = iFormatPI2GL( tex.mFormat );
                                    if( tex.mType===me.TEXTYPE.T2D )
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                        mGL.texImage2D(  mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image );
                                        mGL.bindTexture( mGL.TEXTURE_2D, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                };

        me.DestroyTexture = function( te )
                            {
                                 mGL.deleteTexture( te.mObjectID );
                            };

        me.AttachTextures = function (num, t0, t1, t2, t3) 
                            {
                                if (num > 0 && t0 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                         if (t0.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t0.mObjectID);
                                }

                                if (num > 1 && t1 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE1);
                                         if (t1.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t1.mObjectID);
                                }

                                if (num > 2 && t2 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE2);
                                         if (t2.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t2.mObjectID);
                                }

                                if (num > 3 && t3 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE3);
                                         if (t3.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t3.mObjectID);
                                }
                            };

        me.DettachTextures = function()
                             {
                                mGL.activeTexture(mGL.TEXTURE0);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE1);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE2);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE3);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                             };

        me.CreateRenderTarget = function ( color0, color1, color2, color3, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);

                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_2D, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.DestroyRenderTarget = function ( tex )
                                 {
                                     mGL.deleteFramebuffer(tex.mObjectID);
                                 };

        me.SetRenderTarget = function (tex)
                             {
                                if( tex===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, tex.mObjectID);

                                //mGL.drawBuffers([mGL.COLOR_ATTACHMENT0, mGL.COLOR_ATTACHMENT1]);
                             };

        me.CreateRenderTargetNew = function ( wantColor0, wantZbuffer, xres, yres, samples )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if( wantZbuffer===true )
                                    {
                                        var zb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);

                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.DEPTH_COMPONENT16, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                    }

                                    if( wantColor0 )
                                    {
                                        var cb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, cb);
                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.RGBA8, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.RGBA8, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.RENDERBUFFER, cb);
                                    }

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                    {
                                        return null;
                                    }
                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mXres: xres, mYres:yres, mTex0: color0 };
                                };

        me.CreateRenderTargetCubeMap = function ( color0, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);
                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.SetRenderTargetCubeMap = function (fbo, face)
                             {
                                if( fbo===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                {
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, fbo.mObjectID);
                                    mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X+face, fbo.mTex0.mObjectID, 0);
                                }
                             };


        me.BlitRenderTarget = function( dst, src )
                                {
                                    mGL.bindFramebuffer(mGL.READ_FRAMEBUFFER, src.mObjectID);
                                    mGL.bindFramebuffer(mGL.DRAW_FRAMEBUFFER, dst.mObjectID);
                                    mGL.clearBufferfv(mGL.COLOR, 0, [0.0, 0.0, 0.0, 1.0]);
                                    mGL.blitFramebuffer( 0, 0, src.mXres, src.mYres,
                                                         0, 0, src.mXres, src.mYres,
                                                         mGL.COLOR_BUFFER_BIT, mGL.LINEAR
                                    );
                                };

        me.SetViewport = function( vp )
                         {
                              mGL.viewport( vp[0], vp[1], vp[2], vp[3] );
                         };

        me.SetWriteMask = function( c0, c1, c2, c3, z )
                          {
                              mGL.depthMask(z);
                              mGL.colorMask(c0,c0,c0,c0);
                          };

        me.SetState = function( stateName, stateValue )
                      {
                            if (stateName === me.RENDSTGATE.WIREFRAME)
                            {
                                if( stateValue ) mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.LINE );
                                else             mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.FILL );
                            }
                            else if (stateName === me.RENDSTGATE.FRONT_FACE)
                            {
                                if( stateValue ) mGL.cullFace( mGL.BACK );
                                else             mGL.cullFace( mGL.FRONT );
                            }
                            else if (stateName === me.RENDSTGATE.CULL_FACE)
                            {
                                if( stateValue ) mGL.enable( mGL.CULL_FACE );
                                else             mGL.disable( mGL.CULL_FACE );
                            }
                            else if (stateName === me.RENDSTGATE.DEPTH_TEST)
                            {
                                if( stateValue ) mGL.enable( mGL.DEPTH_TEST );
                                else             mGL.disable( mGL.DEPTH_TEST );
                            }
                            else if (stateName === me.RENDSTGATE.ALPHA_TO_COVERAGE)
                            {
                                if( stateValue ) { mGL.enable(  mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                                else             { mGL.disable( mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                            }
                      };

        me.SetMultisample = function( v)
                    {
                        if( v===true )
                        {
                            mGL.enable(mGL.SAMPLE_COVERAGE);
                            mGL.sampleCoverage(1.0, false);
                        }
                        else
                        {
                            mGL.disable(mGL.SAMPLE_COVERAGE);
                        }
                    };

        me.GetTranslatedShaderSource = function (shader) 
                          {
                            if( mGL===null ) return null;
                            if( mDebugShader===null ) return null;
                            let vfs = mGL.getAttachedShaders(shader.mProgram);
                            let str = mDebugShader.getTranslatedShaderSource(vfs[1]);
                            let parts = str.split("GLSL END"); str = (parts.length<2) ? str : parts[1];
                            return str;
                          };

        me.CreateShader = function (vsSource, fsSource, preventCache, forceSynch, onResolve) 
                          {
                            if( mGL===null ) return;

                            var vs = mGL.createShader( mGL.VERTEX_SHADER   );
                            var fs = mGL.createShader( mGL.FRAGMENT_SHADER );

                            vsSource = mShaderHeader[0] + vsSource;
                            fsSource = mShaderHeader[1] + fsSource;

                            if( preventCache )
                            {
                                let vran = Math.random().toString(36).substring(7);
                                let fran = Math.random().toString(36).substring(7);
                                vsSource += "\n#define K" + vran + "\n";
                                fsSource += "\n#define K" + fran + "\n";
                            }

                            var timeStart = getRealTime();

                            mGL.shaderSource(vs, vsSource);
                            mGL.shaderSource(fs, fsSource);
                            mGL.compileShader(vs);
                            mGL.compileShader(fs);

                            var pr = mGL.createProgram();
                            mGL.attachShader(pr, vs);
                            mGL.attachShader(pr, fs);
                            mGL.linkProgram(pr);

                            //-------------
                            let checkErrors = function()
                            {
                                if (!mGL.getProgramParameter(pr, mGL.LINK_STATUS))
                                {
                                    // vs error
                                    if (!mGL.getShaderParameter(vs, mGL.COMPILE_STATUS))
                                    {
                                        let vsLog = mGL.getShaderInfoLog(vs);
                                        onResolve(false, { mErrorType: 0, mErrorStr: vsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // fs error
                                    else if (!mGL.getShaderParameter(fs, mGL.COMPILE_STATUS))
                                    {
                                        let fsLog = mGL.getShaderInfoLog(fs);
                                        onResolve(false, { mErrorType: 1, mErrorStr: fsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // link error
                                    else
                                    {
                                        let infoLog = mGL.getProgramInfoLog(pr);
                                        onResolve(false, { mErrorType: 2, mErrorStr: infoLog });
                                        mGL.deleteProgram(pr);
                                    }
                                }
                                // no errors
                                else
                                {
                                    let compilationTime = getRealTime() - timeStart;
                                    onResolve(true, { mProgram: pr, mTime: compilationTime });
                                }
                            };

                            // check compilation
                            if (mAsynchCompile === null || forceSynch===true )
                            {
                                checkErrors();
                            }
                            else
                            {
                                let loopCheckCompletion = function ()
                                {
                                    if( mGL.getProgramParameter(pr, mAsynchCompile.COMPLETION_STATUS_KHR) === true )
                                        checkErrors();
                                    else
                                        setTimeout(loopCheckCompletion, 10);
                                };
                                setTimeout(loopCheckCompletion, 10);
                            }
                        };

        me.AttachShader = function( shader )
                          {
                                if( shader===null )
                                {
                                    mBindedShader = null;
                                    mGL.useProgram( null );
                                }
                                else
                                {
                                    mBindedShader = shader;
                                    mGL.useProgram(shader.mProgram);
                                }
                          };

        me.DetachShader = function ()
                        {
                            mGL.useProgram(null);
                        };

        me.DestroyShader = function( tex )
                        {
                            mGL.deleteProgram(tex.mProgram);
                        };

        me.GetAttribLocation = function (shader, name)
                        {
                            return mGL.getAttribLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantLocation = function (shader, name)
                        {
                            return mGL.getUniformLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantMat4F = function( uname, params, istranspose )
                        {
                            var program = mBindedShader;

                            let pos = mGL.getUniformLocation( program.mProgram, uname );
                            if( pos===null )
                                return false;

                            if( istranspose===false )
                            {
                                var tmp = new Float32Array( [ params[0], params[4], params[ 8], params[12],
                                                              params[1], params[5], params[ 9], params[13],
                                                              params[2], params[6], params[10], params[14],
                                                              params[3], params[7], params[11], params[15] ] );
	                            mGL.uniformMatrix4fv(pos,false,tmp);
                            }
                            else
                                mGL.uniformMatrix4fv(pos,false,new Float32Array(params) );
                            return true;
                        };

        me.SetShaderConstant1F_Pos = function(pos, x)
                        {
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1FV_Pos = function(pos, x)
                        {
                            mGL.uniform1fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant1F = function( uname, x )
                        {
                            var pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1I = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1i(pos, x);
                            return true;
                        };
        me.SetShaderConstant1I_Pos = function(pos, x)
                        {
                            mGL.uniform1i(pos, x);
                            return true;
                        };


        me.SetShaderConstant2F = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform2fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant3F = function(uname, x, y, z)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform3f(pos, x, y, z);
                            return true;
                        };

        me.SetShaderConstant1FV = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1fv(pos, new Float32Array(x));
                            return true;
                        };

        me.SetShaderConstant3FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform3fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderConstant4FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform4fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderTextureUnit = function( uname, unit )
                        {
                            var program = mBindedShader;
                            let pos = mGL.getUniformLocation(program.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform1i(pos, unit);
                            return true;
                        };

        me.CreateVertexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, id);
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.CreateIndexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, id );
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.DestroyArray = function( tex )
                        {
                            mGL.destroyBuffer(tex.mObject);
                        };

        me.AttachVertexArray = function( tex, attribs, pos )
                        {
                            let shader = mBindedShader;

                            mGL.bindBuffer( mGL.ARRAY_BUFFER, tex.mObject);

                            var num = attribs.mChannels.length;
                            var stride = attribs.mStride;

                            var offset = 0;
                            for (var i = 0; i < num; i++)
                            {
                                var id = pos[i];
                                mGL.enableVertexAttribArray(id);
                                var dtype = mGL.FLOAT;
                                var dsize = 4;
                                     if( attribs.mChannels[i].mType === me.TYPE.UINT8   ) { dtype = mGL.UNSIGNED_BYTE;  dsize = 1; }
                                else if( attribs.mChannels[i].mType === me.TYPE.UINT16  ) { dtype = mGL.UNSIGNED_SHORT; dsize = 2; }
                                else if( attribs.mChannels[i].mType === me.TYPE.FLOAT32 ) { dtype = mGL.FLOAT;          dsize = 4; }
                                mGL.vertexAttribPointer(id, attribs.mChannels[i].mNumComponents, dtype, attribs.mChannels[i].mNormalize, stride, offset);
                                offset += attribs.mChannels[i].mNumComponents * dsize;
                            }
                        };

        me.AttachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, tex.mObject);
                        };

        me.DetachVertexArray = function (tex, attribs)
                        {
                            let num = attribs.mChannels.length;
                            for (let i = 0; i < num; i++)
                                mGL.disableVertexAttribArray(i);
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, null);
                        };

        me.DetachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, null);
                        };

        me.DrawPrimitive = function( typeOfPrimitive, num, useIndexArray, numInstances )
                        {
                            let glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.POINTS ) glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.LINES ) glType = mGL.LINES;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_LOOP ) glType = mGL.LINE_LOOP;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_STRIP ) glType = mGL.LINE_STRIP;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLES ) glType = mGL.TRIANGLES;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLE_STRIP ) glType = mGL.TRIANGLE_STRIP;

                            if( numInstances<=1 )
                            {
  	                            if( useIndexArray ) mGL.drawElements( glType, num, mGL.UNSIGNED_SHORT, 0 );
	                            else                mGL.drawArrays( glType, 0, num );
                            }
                            else
                            {
                                mGL.drawArraysInstanced(glType, 0, num, numInstances);
                                mGL.drawElementsInstanced( glType, num, mGL.UNSIGNED_SHORT, 0, numInstances);
                            }
                        };


        me.DrawFullScreenTriangle_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 3 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };


        me.DrawUnitQuad_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 6 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };

        me.DrawUnitCube_XYZ_NOR = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                            mGL.vertexAttribPointer( vpos[0], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.vertexAttribPointer( vpos[1], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos[0] );
                            mGL.enableVertexAttribArray( vpos[1] );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos[0] );
                            mGL.disableVertexAttribArray( vpos[1] );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.DrawUnitCube_XYZ = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                            mGL.vertexAttribPointer( vpos, 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.SetBlend = function( enabled )
                    {
                        if( enabled )
                        {
                            mGL.enable( mGL.BLEND );
                            mGL.blendEquationSeparate( mGL.FUNC_ADD, mGL.FUNC_ADD );
                            mGL.blendFuncSeparate( mGL.SRC_ALPHA, mGL.ONE_MINUS_SRC_ALPHA, mGL.ONE, mGL.ONE_MINUS_SRC_ALPHA );
                        }
                        else
                        {
                            mGL.disable( mGL.BLEND );
                        }
                    };

        me.GetPixelData = function( data, offset, xres, yres )
                        {
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.UNSIGNED_BYTE, data, offset);
                        };

        me.GetPixelDataRenderTarget = function( obj, data, xres, yres )
                        {
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, obj.mObjectID);
                            mGL.readBuffer(mGL.COLOR_ATTACHMENT0);
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.FLOAT, data, 0);
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                        };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piShading
//
//==============================================================================

function smoothstep(a, b, x)
{
    x = (x - a) / (b - a);
    if (x < 0) x = 0; else if (x > 1) x = 1;
    return x * x * (3.0 - 2.0 * x);
}

function clamp01(x)
{
    if( x < 0.0 ) x = 0.0;
    if( x > 1.0 ) x = 1.0;
    return x;
}

function clamp(x, a, b)
{
    if( x < a ) x = a;
    if( x > b ) x = b;
    return x;
}

function screen(a, b)
{
    return 1.0 - (1.0 - a) * (1.0 - b);
}

function parabola(x)
{
    return 4.0 * x * (1.0 - x);
}

function min(a, b)
{
    return (a < b) ? a : b;
}

function max(a, b)
{
    return (a > b) ? a : b;
}

function noise( x )
{
    function grad(i, j, x, y)
    {
        var h = 7 * i + 131 * j;
        h = (h << 13) ^ h;
        h = (h * (h * h * 15731 + 789221) + 1376312589);

        var rx = (h & 0x20000000) ? x : -x;
        var ry = (h & 0x10000000) ? y : -y;

        return rx + ry;
    }

    var i = [ Math.floor(x[0]), Math.floor(x[1]) ];
    var f = [ x[0] - i[0], x[1] - i[1] ];
    var w = [ f[0]*f[0]*(3.0-2.0*f[0]), f[1]*f[1]*(3.0-2.0*f[1]) ];

    var a = grad( i[0]+0, i[1]+0, f[0]+0.0, f[1]+0.0 );
    var b = grad( i[0]+1, i[1]+0, f[0]-1.0, f[1]+0.0 );
    var c = grad( i[0]+0, i[1]+1, f[0]+0.0, f[1]-1.0 );
    var d = grad( i[0]+1, i[1]+1, f[0]-1.0, f[1]-1.0 );

    return a + (b-a)*w[0] + (c-a)*w[1] + (a-b-c+d)*w[0]*w[1];
}//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piVecTypes
//
//==============================================================================


function vec3( a, b, c )
{
    return [ a, b, c ];
}

function add( a, b )
{
    return [ a[0]+b[0], a[1]+b[1], a[2]+b[2] ];
}

function sub( a, b )
{
    return [ a[0]-b[0], a[1]-b[1], a[2]-b[2] ];
}

function mul( a, s ) 
{
    return [ a[0]*s, a[1]*s, a[2]*s ];
}

function cross( a, b )
{
    return [ a[1]*b[2] - a[2]*b[1],
             a[2]*b[0] - a[0]*b[2],
             a[0]*b[1] - a[1]*b[0] ];
}

function dot( a, b ) 
{
    return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
}

function normalize( v ) 
{
    var is = 1.0 / Math.sqrt( v[0]*v[0] + v[1]*v[1] + v[2]*v[2] );
    return [ v[0]*is, v[1]*is, v[2]*is ];
}

function createCirclePoint( cen, uuu, vvv, rad, s, t )
{
    return [ cen[0] + rad*(uuu[0]*s + vvv[0]*t),
             cen[1] + rad*(uuu[1]*s + vvv[1]*t),
             cen[2] + rad*(uuu[2]*s + vvv[2]*t) ];
}

function createTangent( a, b, c )
{
    var cb = normalize( [ c[0]-b[0], c[1]-b[1], c[2]-b[2] ] );
    var ba = normalize( [ b[0]-a[0], b[1]-a[1], b[2]-a[2] ] );
    return normalize( [ ba[0]+cb[0], ba[1]+cb[1], ba[2]+cb[2] ] );

}

//===================================

function vec4( a, b, c, d )
{
    return [ a, b, c, d ];
}

function getXYZ( v )
{
    return [ v[0], v[1], v[2] ];
}

//===================================

function setIdentity()
{
    return [ 1.0, 0.0, 0.0, 0.0,
             0.0, 1.0, 0.0, 0.0,
             0.0, 0.0, 1.0, 0.0,
             0.0, 0.0, 0.0, 1.0 ];
}

function setRotationX( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ 1.0,   0.0,   0.0, 0.0,
             0.0,  cost, -sint, 0.0, 
             0.0,  sint,  cost, 0.0,
             0.0,   0.0,   0.0, 1.0 ];
}

function setRotationY( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ cost, 0.0, -sint, 0.0,
              0.0, 1.0,   0.0, 0.0, 
             sint, 0.0,  cost, 0.0,
              0.0, 0.0,   0.0, 1.0 ];
}

function extractRotationEuler( m)
{
    var res = [];
    if (m[0] == 1.0)
    {
        res[0] = Math.atan2(m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;

    }
    else if (m[0] == -1.0)
    {
        res[0] = Math.atan2( m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;
    }
    else
    {
        res[0] = Math.atan2( -m[9], m[10]);
        res[1] = Math.atan2( m[8], Math.sqrt(m[9]*m[9] + m[10]*m[10]));
        res[2] = Math.atan2( m[4], m[0]);
    }
    return res;
}

function setFromQuaternion( q )
{
    var ww = q[3]*q[3];
    var xx = q[0]*q[0];
    var yy = q[1]*q[1];
    var zz = q[2]*q[2];

    return [ ww+xx-yy-zz,                   2.0*(q[0]*q[1] - q[3]*q[2]), 2.0*(q[0]*q[2] + q[3]*q[1]), 0.0,
               2.0*(q[0]*q[1] + q[3]*q[2]),   ww-xx+yy-zz,                 2.0*(q[1]*q[2] - q[3]*q[0]), 0.0,
               2.0*(q[0]*q[2] - q[3]*q[1]),   2.0*(q[1]*q[2] + q[3]*q[0]), ww-xx-yy+zz,                 0.0,
               0.0,                           0.0,                         0.0,                         1.0 ];
}

function setPerspective( fovy, aspect, znear, zfar )
{
    var tan = Math.tan(fovy * Math.PI/180.0);
    var x = 1.0 / (tan*aspect);
    var y = 1.0 / (tan);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0 * zfar * znear) / (zfar - znear);

    return [ x,    0.0,  0.0,  0.0,
             0.0,  y,    0.0,  0.0,
             0.0,  0.0,  c,     d,
             0.0,  0.0, -1.0,  0.0 ];
}

function setLookAt( eye, tar, up )
{
    var dir = [ -tar[0]+eye[0], -tar[1]+eye[1], -tar[2]+eye[2] ];

	var m00 = dir[2]*up[1] - dir[1]*up[2]; 
    var m01 = dir[0]*up[2] - dir[2]*up[0];
    var m02 = dir[1]*up[0] - dir[0]*up[1];
    var im = 1.0/Math.sqrt( m00*m00 + m01*m01 + m02*m02 );
    m00 *= im;
    m01 *= im;
    m02 *= im;

	var m04 = m02*dir[1] - m01*dir[2]; 
    var m05 = m00*dir[2] - m02*dir[0];
    var m06 = m01*dir[0] - m00*dir[1];
    im = 1.0/Math.sqrt( m04*m04 + m05*m05 + m06*m06 );
    m04 *= im;
    m05 *= im;
    m06 *= im;

	var m08 = dir[0];
	var m09 = dir[1];
	var m10 = dir[2];
    im = 1.0/Math.sqrt( m08*m08 + m09*m09 + m10*m10 );
    m08 *= im;
    m09 *= im;
    m10 *= im;

	var m03 = -(m00*eye[0] + m01*eye[1] + m02*eye[2] );
	var m07 = -(m04*eye[0] + m05*eye[1] + m06*eye[2] );
	var m11 = -(m08*eye[0] + m09*eye[1] + m10*eye[2] );

    return [ m00, m01, m02, m03,
             m04, m05, m06, m07,
             m08, m09, m10, m11,
             0.0, 0.0, 0.0, 1.0 ];
}


function setOrtho( left, right, bottom, top, znear, zfar )
{
   var x = 2.0 / (right - left);
   var y = 2.0 / (top - bottom);
   var a = (right + left) / (right - left);
   var b = (top + bottom) / (top - bottom);
   var c = -2.0 / (zfar - znear);
   var d = -(zfar + znear) / ( zfar - znear);

   return [  x, 0.0, 0.0,   a,
           0.0,   y, 0.0,   b,
           0.0, 0.0,   c,   d,
           0.0, 0.0, 0.0, 1.0 ];
}

function setTranslation( p )
{
    return [ 1.0, 0.0, 0.0, p[0],
             0.0, 1.0, 0.0, p[1],
             0.0, 0.0, 1.0, p[2],
             0.0, 0.0, 0.0, 1.0 ];
}

function setScale( s )
{
    return [ s[0], 0.0,  0.0,  0.0,
             0.0,  s[1], 0.0,  0.0,
             0.0,  0.0,  s[2], 0.0,
             0.0,  0.0,  0.0,  1.0];
}

function setProjection( fov, znear, zfar )
{
    var x = 2.0 / (fov[3]+fov[2]);
    var y = 2.0 / (fov[0]+fov[1]);
    var a = (fov[3]-fov[2]) / (fov[3]+fov[2]);
    var b = (fov[0]-fov[1]) / (fov[0]+fov[1]);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0*zfar*znear) / (zfar - znear);
    return [   x, 0.0,    a, 0.0,
             0.0,   y,    b, 0.0,
             0.0, 0.0,    c,   d,
             0.0, 0.0, -1.0, 0.0 ];
   // inverse is:
   //return mat4x4( 1.0/x, 0.0f,  0.0f,   a/x,
   //               0.0f,  1.0/y, 0.0f,   b/x,
   //               0.0f,  0.0f,  0.0f,   -1.0,
   //               0.0f,  0.0f,  1.0f/d, c/d );
}


function invertFast( m )
{
    var inv = [
   
             m[5]  * m[10] * m[15] - 
             m[5]  * m[11] * m[14] - 
             m[9]  * m[6]  * m[15] + 
             m[9]  * m[7]  * m[14] +
             m[13] * m[6]  * m[11] - 
             m[13] * m[7]  * m[10],

             -m[1]  * m[10] * m[15] + 
              m[1]  * m[11] * m[14] + 
              m[9]  * m[2] * m[15] - 
              m[9]  * m[3] * m[14] - 
              m[13] * m[2] * m[11] + 
              m[13] * m[3] * m[10],

             m[1]  * m[6] * m[15] - 
             m[1]  * m[7] * m[14] - 
             m[5]  * m[2] * m[15] + 
             m[5]  * m[3] * m[14] + 
             m[13] * m[2] * m[7] - 
             m[13] * m[3] * m[6],

             -m[1] * m[6] * m[11] + 
              m[1] * m[7] * m[10] + 
              m[5] * m[2] * m[11] - 
              m[5] * m[3] * m[10] - 
              m[9] * m[2] * m[7] + 
              m[9] * m[3] * m[6],

             -m[4]  * m[10] * m[15] + 
              m[4]  * m[11] * m[14] + 
              m[8]  * m[6]  * m[15] - 
              m[8]  * m[7]  * m[14] - 
              m[12] * m[6]  * m[11] + 
              m[12] * m[7]  * m[10],

             m[0]  * m[10] * m[15] - 
             m[0]  * m[11] * m[14] - 
             m[8]  * m[2] * m[15] + 
             m[8]  * m[3] * m[14] + 
             m[12] * m[2] * m[11] - 
             m[12] * m[3] * m[10],

             -m[0]  * m[6] * m[15] + 
              m[0]  * m[7] * m[14] + 
              m[4]  * m[2] * m[15] - 
              m[4]  * m[3] * m[14] - 
              m[12] * m[2] * m[7] + 
              m[12] * m[3] * m[6],


             m[0] * m[6] * m[11] - 
             m[0] * m[7] * m[10] - 
             m[4] * m[2] * m[11] + 
             m[4] * m[3] * m[10] + 
             m[8] * m[2] * m[7] - 
             m[8] * m[3] * m[6],


             m[4]  * m[9] * m[15] - 
             m[4]  * m[11] * m[13] - 
             m[8]  * m[5] * m[15] + 
             m[8]  * m[7] * m[13] + 
             m[12] * m[5] * m[11] - 
             m[12] * m[7] * m[9],



             -m[0]  * m[9] * m[15] + 
              m[0]  * m[11] * m[13] + 
              m[8]  * m[1] * m[15] - 
              m[8]  * m[3] * m[13] - 
              m[12] * m[1] * m[11] + 
              m[12] * m[3] * m[9],

              m[0]  * m[5] * m[15] - 
              m[0]  * m[7] * m[13] - 
              m[4]  * m[1] * m[15] + 
              m[4]  * m[3] * m[13] + 
              m[12] * m[1] * m[7] - 
              m[12] * m[3] * m[5],

              -m[0] * m[5] * m[11] + 
               m[0] * m[7] * m[9] + 
               m[4] * m[1] * m[11] - 
               m[4] * m[3] * m[9] - 
               m[8] * m[1] * m[7] + 
               m[8] * m[3] * m[5],

              -m[4]  * m[9] * m[14] + 
               m[4]  * m[10] * m[13] +
               m[8]  * m[5] * m[14] - 
               m[8]  * m[6] * m[13] - 
               m[12] * m[5] * m[10] + 
               m[12] * m[6] * m[9],

              m[0]  * m[9] * m[14] - 
              m[0]  * m[10] * m[13] - 
              m[8]  * m[1] * m[14] + 
              m[8]  * m[2] * m[13] + 
              m[12] * m[1] * m[10] - 
              m[12] * m[2] * m[9],

              -m[0]  * m[5] * m[14] + 
               m[0]  * m[6] * m[13] + 
               m[4]  * m[1] * m[14] - 
               m[4]  * m[2] * m[13] - 
               m[12] * m[1] * m[6] + 
               m[12] * m[2] * m[5],

              m[0] * m[5] * m[10] - 
              m[0] * m[6] * m[9] - 
              m[4] * m[1] * m[10] + 
              m[4] * m[2] * m[9] + 
              m[8] * m[1] * m[6] - 
              m[8] * m[2] * m[5] ];

    var det = m[0] * inv[0] + m[1] * inv[4] + m[2] * inv[8] + m[3] * inv[12];

    det = 1.0/det;

    for( var i = 0; i<16; i++ ) inv[i] = inv[i] * det;

    return inv;
}

function matMul( a, b )
{
    var res = [];
    for( var i=0; i<4; i++ )
    {
        var x = a[4*i+0];
        var y = a[4*i+1];
        var z = a[4*i+2];
        var w = a[4*i+3];

        res[4*i+0] = x * b[ 0] + y * b[ 4] + z * b[ 8] + w * b[12];
        res[4*i+1] = x * b[ 1] + y * b[ 5] + z * b[ 9] + w * b[13];
        res[4*i+2] = x * b[ 2] + y * b[ 6] + z * b[10] + w * b[14];
        res[4*i+3] = x * b[ 3] + y * b[ 7] + z * b[11] + w * b[15];
    }

    return res;
}

function matMulpoint( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2] + m[ 3],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2] + m[ 7],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] + m[11] ];
}

function matMulvec( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] ];
}


function bound3( infi )
{
    return [ infi, -infi, infi, -infi, infi, -infi ];
}

function bound3_include( a, p )
{
    return [
        (p[0]<a[0]) ? p[0] : a[0],
        (p[0]>a[1]) ? p[0] : a[1],
        (p[1]<a[2]) ? p[1] : a[2],
        (p[1]>a[3]) ? p[1] : a[3],
        (p[2]<a[4]) ? p[2] : a[4],
        (p[2]>a[5]) ? p[2] : a[5] ];
}

function bound3_center( b )
{
    return [ 0.5*(b[0]+b[1]),
             0.5*(b[2]+b[3]),
             0.5*(b[4]+b[5]) ];
}

function bound3_radius( b )
{
    return [ 0.5*(b[1]-b[0]),
             0.5*(b[3]-b[2]),
             0.5*(b[5]-b[4]) ];
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebVR
//
//==============================================================================

function WebVR( isVREnabledCallback, canvasElement )
{
    isVREnabledCallback(false);
    /*


    this.mSupportVR = false;
    this.mHMD = null;

    var me = this;
    var listVRDisplays = function (vrdevs) {
        for (var i = 0; i < vrdevs.length; i++)
        {
            if (vrdevs[i] instanceof VRDisplay)
            {
                me.mHMD = vrdevs[i];
                console.log("WebVR is available.");
                console.log(me.mHMD);
                break;
            }
        }

        isVREnabledCallback(true);
        me.mSupportVR = true;
    }

    if (navigator.getVRDisplays)
    {
        navigator.getVRDisplays().then(listVRDisplays);
    }

    isVREnabledCallback(false);
    this.mCanvas = canvasElement;
    */
}

WebVR.prototype.IsSupported = function()
{
    return false;
    //return this.mSupportVR;
}

WebVR.prototype.GetData = function( id )
{
    return {};
    /*
    var frameData = new VRFrameData();
    var s = this.mHMD.getFrameData(frameData);
    var ss = frameData.pose;
    
    var fovL = this.mHMD.getEyeParameters("left");
    var fovR = this.mHMD.getEyeParameters( "right" );

    // camera info
    var cPos = vec3(0.0, 0.0, 0.0);
    if (ss.position)
        cPos = vec3(-ss.position[0], -ss.position[1], -ss.position[2]);
    var rot = vec4(0.0, 0.0, 0.0, 0.0);
    if (ss.orientation)
        rot = vec4(ss.orientation[0], ss.orientation[1], ss.orientation[2], ss.orientation[3]);
    var cRot = setFromQuaternion(rot);
    var cTra = setTranslation(cPos);
    var cMat = matMul(invertFast(cRot), cTra);
    
    // per eye info
    var lTra = setTranslation( vec3(-fovL.offset[0], -fovL.offset[1], -fovL.offset[2]) );
    var lMat = matMul(lTra, cMat);
    var lPrj = [ Math.tan( fovL.fieldOfView.upDegrees * Math.PI/180.0),
                 Math.tan(fovL.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.rightDegrees * Math.PI / 180.0)];

    var rTra = setTranslation(vec3(-fovR.offset[0], -fovR.offset[1], -fovR.offset[2]));
    var rMat = matMul(rTra, cMat);
    var rPrj = [Math.tan(fovR.fieldOfView.upDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.rightDegrees * Math.PI / 180.0)];

    return {
        mCamera   : { mCamera: cMat },
        mLeftEye  : { mVP:[0,0,fovL.renderWidth,fovL.renderHeight], mProjection:lPrj, mCamera:lMat },
        mRightEye : { mVP:[fovR.renderWidth/2,0,fovR.renderWidth,fovR.renderHeight], mProjection:rPrj, mCamera:rMat }
           };
    */
}

WebVR.prototype.Enable = function( id )
{
    /*
    this.mHMD.requestPresent([{ source: this.mCanvas }]).then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : requestPresent failed.");
        }
    );
    */
}

WebVR.prototype.Disable = function( id )
{
    /*
    if (!this.mHMD.isPresenting)
    {
        return;
    }

    this.mHMD.exitPresent().then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : exitPresent failed.");
        }
    );
    */
}

WebVR.prototype.RequestAnimationFrame = function (id)
{
    //this.mHMD.requestAnimationFrame(id);
}

WebVR.prototype.IsPresenting = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        return true;
    }
    */
    return false;
}

WebVR.prototype.Finish = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        this.mHMD.submitFrame();
    }
    */
}

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebUtils
//
//==============================================================================


// RequestAnimationFrame
window.requestAnimFrame = ( function () { return window.requestAnimationFrame    || window.webkitRequestAnimationFrame ||
                                                 window.mozRequestAnimationFrame || window.oRequestAnimationFrame ||
                                                 window.msRequestAnimationFrame  || function( cb ) { window.setTimeout(cb,1000/60); };
                                        } )();

// performance.now
window.getRealTime = ( function() { if ("performance" in window ) return function() { return window.performance.now(); }
                                                                  return function() { return (new Date()).getTime(); }
                                  } )();

window.URL = window.URL || window.webkitURL;

navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;

function htmlEntities(str) 
{
    return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g,'&apos;');
}

function piDisableTouch()
{
    document.body.addEventListener('touchstart', function(e){ e.preventDefault(); });
}

var piGetTime = function ( timestamp )
{
    if (timestamp == 0)
        return "";
    return new Date(timestamp * 1000).toISOString().substr(0, 10);
}

function piGetCoords( obj )
{
    var x = 0;
    var y = 0; 
    do
    {
         x += obj.offsetLeft;
         y += obj.offsetTop;
    }while( obj = obj.offsetParent );

    return { mX:x, mY:y };
}

function piGetMouseCoords( ev, canvasElement )
{
    var pos = piGetCoords(canvasElement );
    var mcx =                        (ev.pageX - pos.mX) * canvasElement.width / canvasElement.offsetWidth;
    var mcy = canvasElement.height - (ev.pageY - pos.mY) * canvasElement.height / canvasElement.offsetHeight;

    return { mX: mcx, mY: mcy };

}

function piGetSourceElement( e )
{
    var ele = null;
    if( e.target )     ele = e.target;
    if( e.srcElement ) ele = e.srcElement;
    return ele;
}

function piRequestFullScreen( ele )
{
    if( ele==null ) ele =   document.documentElement;
         if( ele.requestFullscreen       ) ele.requestFullscreen();
    else if( ele.msRequestFullscreen     ) ele.msRequestFullscreen();
    else if( ele.mozRequestFullScreen    ) ele.mozRequestFullScreen();
    else if( ele.webkitRequestFullscreen ) ele.webkitRequestFullscreen( Element.ALLOW_KEYBOARD_INPUT );
}

function piIsFullScreen()
{
    return document.fullscreen || document.mozFullScreen || document.webkitIsFullScreen || document.msFullscreenElement || false;
}

function piExitFullScreen()
{
       if( document.exitFullscreen       ) document.exitFullscreen();
  else if( document.msExitFullscreen     ) document.msExitFullscreen();
  else if( document.mozCancelFullScreen  ) document.mozCancelFullScreen();
  else if( document.webkitExitFullscreen ) document.webkitExitFullscreen();
}

function piIsMobile()
{
    return (navigator.userAgent.match(/Android/i) ||
            navigator.userAgent.match(/webOS/i) ||
            navigator.userAgent.match(/iPhone/i) ||
            navigator.userAgent.match(/iPad/i) ||
            navigator.userAgent.match(/iPod/i) ||
            navigator.userAgent.match(/BlackBerry/i) ||
            navigator.userAgent.match(/Windows Phone/i)) ? true : false;
}

function piCreateGlContext( cv, useAlpha, useDepth, usePreserveBuffer, useSupersampling )
{
    var opts = { alpha: useAlpha, 
                 depth: useDepth, 
                 stencil: false, 
                 premultipliedAlpha: false, 
                 antialias: useSupersampling, 
                 preserveDrawingBuffer: usePreserveBuffer, 
                 powerPreference: "high-performance" }; // "low_power", "high_performance", "default"

    var gl = null;
    if( gl === null) gl = cv.getContext( "webgl2", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl2", opts );
    if( gl === null) gl = cv.getContext( "webgl", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl", opts );

    return gl;
}

function piCreateAudioContext()
{
    var res = null;
    try
    {
        if( window.AudioContext ) res = new AudioContext();
        if( res==null && window.webkitAudioContext ) res = new webkitAudioContext();
    }
    catch( e )
    {
        res = null;
    }
    return res;
}

function piHexColorToRGB(str) // "#ff3041"
{
    var rgb = parseInt(str.slice(1), 16);
    var r = (rgb >> 16) & 255;
    var g = (rgb >> 8) & 255;
    var b = (rgb >> 0) & 255;
    return [r, g, b];
}

function piCreateFPSCounter()
{
    var mFrame;
    var mTo;
    var mFPS;

    var iReset = function( time )
    {
        mFrame = 0;
        mTo = time;
        mFPS = 60.0;
    }

    var iCount = function( time )
    {
        mFrame++;

        if( (time-mTo)>500.0 )
        {
            mFPS = 1000.0*mFrame/(time-mTo);
            mFrame = 0;
            mTo = time;
            return true;
        }
        return false;
    }

    var iGetFPS = function()
    {
        return mFPS;
    }
    
    return { Reset : iReset, Count : iCount, GetFPS : iGetFPS };
}

function piCanMediaRecorded(canvas)
{
    if (typeof window.MediaRecorder !== 'function' || typeof canvas.captureStream !== 'function') {
        return false;
    }
    return true;
}

function piCreateMediaRecorder(isRecordingCallback, canvas) 
{
    if (piCanMediaRecorded(canvas) == false)
    {
        return null;
    }
    
    var options = { audioBitsPerSecond : 0, videoBitsPerSecond : 8000000 }; 
	     if (MediaRecorder.isTypeSupported('video/webm;codecs=h264')) options.mimeType = 'video/webm;codecs=h264';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9' )) options.mimeType = 'video/webm;codecs=vp9';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8' )) options.mimeType = 'video/webm;codecs=vp8';
    else                                                              options.mimeType = 'video/webm;';

    var mediaRecorder = new MediaRecorder(canvas.captureStream(), options);
    var chunks = [];
    
    mediaRecorder.ondataavailable = function(e) 
    {
        if (e.data.size > 0) 
        {
            chunks.push(e.data);
        }
    };
 
    mediaRecorder.onstart = function(){ 
        isRecordingCallback( true );
    };
    
    mediaRecorder.onstop = function()
    {
         isRecordingCallback( false );
         let blob     = new Blob(chunks, {type: "video/webm"});
         chunks       = [];
         let videoURL = window.URL.createObjectURL(blob);
         let url      = window.URL.createObjectURL(blob);
         let a        = document.createElement("a");
         document.body.appendChild(a);
         a.style      = "display: none";
         a.href       = url;
         a.download   = "capture.webm";
         a.click();
         window.URL.revokeObjectURL(url);
     };
    
    return mediaRecorder;
}

function piExportToEXR(width, height, numComponents, type, bytes)
{
    var bytesPerComponent = 0;
    if      (type=="Uint")   bytesPerComponent = 4; 
    else if (type=="Half")   bytesPerComponent = 2;
    else if (type=="Float")  bytesPerComponent = 4;

    var tHeader = 258 + (18 * numComponents + 1);
    var tTable = 8 * height;
    var tScanlines = height * (4 + 4 + (numComponents * bytesPerComponent * width));
    var tTotal = tHeader + tTable + tScanlines;

    //console.log("    header size = " + tHeader);
    //console.log("    table size = " + tTable);
    //console.log("    scanlines size = " + tScanlines);
    //console.log("    total = " + tTotal);

    var buffer = new ArrayBuffer(tTotal); 
    var data = new DataView(buffer);

    // Header
    {
        // Header : 4 bytes -> 0x76, 0x2f, 0x31, 0x01
        var c = 0;
        data.setUint8 (c++, 0x76);
        data.setUint8 (c++, 0x2f);
        data.setUint8 (c++, 0x31);
        data.setUint8 (c++, 0x01);

        // Version : 4 bytes -> 2, 0, 0, 0
        data.setUint8 (c++, 0x02);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        
        // Write channel info
        // Write attribute name : "channels"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x73);
            data.setUint8 (c++, 0x0);

            // Write attribute type : "chlist"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : 18 x 3 + 1 = 55
            var attribSize = 18 * numComponents + 1;
            data.setUint8 (c++, attribSize); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            var i;
            for (i = 0; i < numComponents; i++)
            {
                // Attribute : "B" (42) "G" (47) "R" (52)
                if (i==0)       data.setUint8 (c++, 0x42);
                else if (i==1)  data.setUint8 (c++, 0x47);
                else if (i==2)  data.setUint8 (c++, 0x52);
                data.setUint8 (c++, 0x00);
                
                // Value : Float (2), Half (1), Uint (0)
                if      (type=="Uint")   data.setUint8 (c++, 0x00); 
                else if (type=="Half")   data.setUint8 (c++, 0x01);
                else if (type=="Float")  data.setUint8 (c++, 0x02);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);

                // Plinear
                data.setUint8 (c++, 0x01);

                // Reserved
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 

                // X sampling
                data.setUint8 (c++, 0x01); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                
                // Y sampling
                data.setUint8 (c++, 0x01);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
            }
            // End attribute
            data.setUint8 (c++, 0x00);
    
        // Write attribute name : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute type : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : "1"
            data.setUint8 (c++, 0x01); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // Write attribute value : "0" (None)
            data.setUint8 (c++, 0x00);

        // datawindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00); 

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00);

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 

            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // displayWindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x79); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00);

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00); 

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // size
            data.setUint8 (c++, 0x01);
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);
            
            // value 
            data.setUint8 (c++, 0x00);

        // PixelAspectRatio
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x41); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x52); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x00); 

            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);
        
            // size 4
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 1.0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);
        
        // screenWindowCenter
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63);
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x43); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e);
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00);

            // v2f
            data.setUint8 (c++, 0x76); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x00);

            // size 8
            data.setUint8 (c++, 0x08); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

        // screenWindowWidth
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x00); 
            
            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00); 

            // size
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);

            // value
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);

        // End of header
        data.setUint8 (c++, 0x00);
    }
    //console.log("header size = " + c);

    // Scanline table
    var initc = c + height * 8;
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        var jump = initc + scanline * (8 + width * bytesPerComponent * numComponents); 
        data.setUint32 (c, jump, true);
        c += 4; 

        data.setUint32 (c, 0x00, true);
        c += 4;
    }
    //console.log("header + scanlines table size = " + c);

    // Scanlines
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        // Scanline
        data.setUint32(c, scanline, true);
        c += 4;

        // size 24
        var size = width * numComponents * bytesPerComponent; 
        data.setUint32(c, size, true);
        c += 4;

        var numComponentsSource = 4; // number of components in the SOURCE image
        for (var component = 0; component < numComponents ; component ++) 
        {
            for (var pixel = 0 ; pixel < width ; pixel ++) 
            {
                // flip vertical, so we read OpenGL buffers without JS image flipping
                var v = bytes[(height-1-scanline) * width *numComponentsSource + pixel * numComponentsSource + (2-component)];
                if      (type=="Float") data.setFloat32(c, v, true);
                else if (type=="Half")  data.setUint16(c, v, true);

                c += bytesPerComponent;
            }
        }
    }
    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}


function piExportToWAV(numSamples, rate, bits, numChannels, words)
{
    let numBytes = numSamples * numChannels * bits/8;

    let buffer = new ArrayBuffer(44 + numBytes); 
    let data = new DataView(buffer);

    {
        data.setUint32( 0, 0x46464952, true );  // RIFF
        data.setUint32( 4, numBytes + 36, true);
        {
            data.setUint32( 8, 0x45564157, true );  // WAV_WAVE
            data.setUint32( 12, 0x20746D66, true );  // WAV_FMT
            {
                data.setUint32( 16, 16, true);
                data.setUint16( 20, 1, true ); // WAV_FORMAT_PCM
                data.setUint16( 22, numChannels, true);
                data.setUint32( 24, rate, true);
                data.setUint32( 28, rate*numChannels*bits / 8, true);
                data.setUint16( 32, numChannels*bits / 8, true);
                data.setUint16( 34, bits, true);
            }

            data.setUint32( 36, 0x61746164, true);  // WAV_DATA
            {
                data.setUint32( 40, numBytes, true);
                let numWords = numSamples * numChannels;
                for(let i=0; i<numWords; i++ )
                {
                    data.setInt16( 44 + i*2, words[i], true );
                }
            }
        }
    }


    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}

function piTriggerDownload(name, blob)
{
    let url = URL.createObjectURL(blob);
    let aElement = document.createElement("a");
    aElement.href     = url;
    aElement.target   = "_self";
    aElement.download = name;
    document.body.appendChild(aElement);
    aElement.click();
    document.body.removeChild(aElement);
}</script>
    <script>"use strict"

function bufferID_to_assetID( id )
{
    if( id===0 ) return '4dXGR8';
    if( id===1 ) return 'XsXGR8';
    if( id===2 ) return '4sXGR8';
    if( id===3 ) return 'XdfGR8';
    return 'none';
}
function assetID_to_bufferID( id )
{
    if( id==='4dXGR8' ) return 0;
    if( id==='XsXGR8' ) return 1;
    if( id==='4sXGR8' ) return 2;
    if( id==='XdfGR8' ) return 3;
    return -1;
}

function assetID_to_cubemapBuferID( id )
{
    if( id==='4dX3Rr' ) return 0;
    return -1;
}
function cubamepBufferID_to_assetID( id )
{
    if( id===0 ) return '4dX3Rr';
    return 'none';
}

function EffectPass( renderer, is20, isLowEnd, hasShaderTextureLOD, callback, obj, forceMuted, forcePaused, outputGainNode, copyProgram, id, effect  )
{
    this.mID = id;
    this.mInputs  = [null, null, null, null ];
    this.mOutputs = [null, null, null, null ];
    this.mSource = null;

    this.mGainNode = outputGainNode;
    this.mSoundShaderCompiled = false;

    this.mEffect = effect;
    this.mRenderer = renderer;
    this.mProgramCopy = copyProgram; 
    this.mCompilationTime = 0;

    this.mType = "none";
    this.mName = "none";
    this.mFrame = 0;

    this.mShaderTextureLOD = hasShaderTextureLOD;
    this.mIs20 = is20;
    this.mIsLowEnd = isLowEnd;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mForceMuted = forceMuted;
    this.mForcePaused = forcePaused;
}

EffectPass.prototype.MakeHeader_Image = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        // old API
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                   header += "uniform sampler2D iChannel" + i + ";\n";

        // new API (see shadertoy.com/view/wtdGW8)
        header += "uniform struct {\n";
             if( inp===null )                  header += "  sampler2D";
        else if( inp.mInfo.mType==="cubemap" ) header += "  samplerCube";
        else if( inp.mInfo.mType==="volume"  ) header += "  sampler3D";
        else                                  header += "  sampler2D";
        header +=        " sampler;\n";
        header += "  vec3  size;\n";
        header += "  float time;\n";
        header += "  int   loaded;\n";
        header += "}iCh" + i + ";\n";
    }
	header += "void mainImage( out vec4 c, in vec2 f );\n";
    header += "void st_assert( bool cond );\n";
    header += "void st_assert( bool cond, int v );\n";

    if( this.mIs20 ) 
    {
        header += "\nout vec4 shadertoy_out_color;\n" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)shadertoy_out_color.x=-1.0;else if(v==1)shadertoy_out_color.y=-1.0;else if(v==2)shadertoy_out_color.z=-1.0;else shadertoy_out_color.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)shadertoy_out_color.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "shadertoy_out_color = vec4(1.0,1.0,1.0,1.0);" + 
            "vec4 color = vec4(1e20);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "if(shadertoy_out_color.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(shadertoy_out_color.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(shadertoy_out_color.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(shadertoy_out_color.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "shadertoy_out_color = vec4(color.xyz,1.0);" +
        "}";
    }
    else
    {
        header += "" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)gl_FragColor.x=-1.0;else if(v==1)gl_FragColor.y=-1.0;else if(v==2)gl_FragColor.z=-1.0;else gl_FragColor.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)gl_FragColor.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "gl_FragColor = vec4(0.0,0.0,0.0,1.0);" + 
            "vec4 color = vec4(1e20);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "color.w = 1.0;" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(gl_FragColor.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "gl_FragColor = vec4(color.xyz,1.0);"+
        "}";
    }
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 ) 
        this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "void main( void )" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );" +
        "color.w = 1.0;"
    if( this.mIs20 ) 
        this.mImagePassFooterVR +=  "outColor = color;}";
    else
        this.mImagePassFooterVR +=  "gl_FragColor = color;}";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Buffer = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                  header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainImage( out vec4 c,  in vec2 f );\n"

    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +
        "mainImage( color, gl_FragCoord.xy );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
    this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        this.mImagePassFooterVR +="outColor = color; }";
    else
        this.mImagePassFooterVR +="gl_FragColor = color; }";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Cubemap = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                   header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainCubemap( out vec4 c, in vec2 f, in vec3 ro, in vec3 rd );\n"

    header += "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainCubemap( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Sound = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform float     iChannelTime[4];\n" +
              "uniform float     iTimeOffset;\n" +
              "uniform int       iSampleOffset;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n";

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp!==null && inp.mInfo.mType==="cubemap" )
            header += "uniform samplerCube iChannel" + i + ";\n";
        else
            header += "uniform sampler2D iChannel" + i + ";\n";
    }
    header += "\n";
    header += "vec2 mainSound( in int samp, float time );\n";

    if( this.mIs20 )
    {
        header += "out vec4 outColor; void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "int   s = iSampleOffset + int(gl_FragCoord.y-0.2)*512 + int(gl_FragCoord.x-0.2);" +
            "vec2 y = mainSound( s, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "outColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    else
    {
        header += "void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "vec2 y = mainSound( 0, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "gl_FragColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    header += "\n";
    this.mHeader = header;
    this.mHeaderLength = 0;
}


EffectPass.prototype.MakeHeader_Common = function ()
{
    let header = "";
    let headerlength = 0;

    header += "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n";
    headerlength += 2;

    if (this.mIs20)
    {
        header += "out vec4 outColor;\n";
        headerlength += 1;
    }
    header += "void main( void )\n";
    headerlength += 1;

    if (this.mIs20)
        header += "{ outColor = vec4(0.0); }";
    else
        header += "{ gl_FragColor = vec4(0.0); }";
    headerlength += 1;
    header += "\n";
    headerlength += 1;

    this.mHeader = header;
    this.mHeaderLength = headerlength;
}

EffectPass.prototype.MakeHeader = function()
{
         if( this.mType==="image" ) this.MakeHeader_Image();
    else if( this.mType==="sound" ) this.MakeHeader_Sound();
    else if( this.mType==="buffer") this.MakeHeader_Buffer();
    else if( this.mType==="common") this.MakeHeader_Common();
    else if( this.mType==="cubemap") this.MakeHeader_Cubemap();
    else console.log("ERROR 4");
}

EffectPass.prototype.Create_Image = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}
EffectPass.prototype.Destroy_Image = function( wa )
{
}

EffectPass.prototype.Create_Buffer = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}

EffectPass.prototype.Destroy_Buffer = function( wa )
{
}

EffectPass.prototype.Create_Cubemap = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
}

EffectPass.prototype.Destroy_Cubemap = function( wa )
{
}

EffectPass.prototype.Create_Common = function( wa )
{
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.MakeHeader();
}
EffectPass.prototype.Destroy_Common = function( wa )
{
}

EffectPass.prototype.Create_Sound = function (wa)
{
    this.MakeHeader();

    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    this.mSampleRate = 44100;
    this.mPlayTime = 60*3;
    this.mPlaySamples = this.mPlayTime*this.mSampleRate;
    this.mBuffer = wa.createBuffer( 2, this.mPlaySamples, this.mSampleRate );

    //-------------------
    this.mTextureDimensions = 512;
    this.mRenderTexture = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D, 
                                                       this.mTextureDimensions, this.mTextureDimensions,
                                                       this.mRenderer.TEXFMT.C4I8,
                                                       this.mRenderer.FILTER.NONE,
                                                       this.mRenderer.TEXWRP.CLAMP, null);
    this.mRenderFBO = this.mRenderer.CreateRenderTarget(this.mRenderTexture, null, null, null, null, false);

    //-----------------------------

    // ArrayBufferView pixels;
    this.mTmpBufferSamples = this.mTextureDimensions*this.mTextureDimensions;
    this.mData = new Uint8Array( this.mTmpBufferSamples*4 );

    this.mPlaying = false;
}

EffectPass.prototype.Destroy_Sound = function( wa )
{
    if( this.mPlayNode!==null ) this.mPlayNode.stop();
    this.mPlayNode = null;
    this.mBuffer = null;
    this.mData = null;

    this.mRenderer.DestroyRenderTarget(this.mRenderFBO);
    this.mRenderer.DestroyTexture(this.mRenderTexture);
}

EffectPass.prototype.Create = function( passType, wa )
{
    this.mType = passType;
    this.mSource = null;

         if( passType==="image" ) this.Create_Image( wa );
    else if( passType==="sound" ) this.Create_Sound( wa );
    else if( passType==="buffer") this.Create_Buffer( wa );
    else if( passType==="common") this.Create_Common( wa );
    else if( passType==="cubemap") this.Create_Cubemap( wa );
    else alert("ERROR 1");
}

EffectPass.prototype.SetName = function (passName)
{
    this.mName = passName;
}

EffectPass.prototype.SetCode = function (src)
{
    this.mSource = src;
}

EffectPass.prototype.Destroy = function( wa )
{
    this.mSource = null;
         if( this.mType==="image" ) this.Destroy_Image( wa );
    else if( this.mType==="sound" ) this.Destroy_Sound( wa );
    else if( this.mType==="buffer") this.Destroy_Buffer( wa );
    else if( this.mType==="common") this.Destroy_Common( wa );
    else if( this.mType==="cubemap") this.Destroy_Cubemap( wa );
    else alert("ERROR 2");
}

EffectPass.prototype.NewShader_Sound = function( shaderCode, commonShaderCodes)
{
    let vsSource = null;

    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for( let i=0; i<commonShaderCodes.length; i++ )
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    this.mSoundShaderCompiled = false;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader_Image = function ( shaderCode, commonShaderCodes )
{
    this.mSupportsVR = false;

    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    return [vsSource, fsSource];


    /*
    let n1 = shaderCode.indexOf("mainVR(");
    let n2 = shaderCode.indexOf("mainVR (");
    let n3 = shaderCode.indexOf("mainVR  (");
    if( n1>0 || n2>0 || n3>0 )
    {
        let vsSourceVR;
        if( this.mIs20 )
            vsSourceVR = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        else
            vsSourceVR = "attribute in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

        let fsSourceVR = this.mHeader;
        for (let i = 0; i < commonShaderCodes.length; i++) {
            fsSourceVR += commonShaderCodes[i];
        }
        fsSourceVR += shaderCode;
        fsSourceVR += this.mImagePassFooterVR;

        let res = this.mRenderer.CreateShader(vsSource, fsSourceVR, preventCache);
        if( res.mResult == false )
        {
            return res.mInfo;
        }
        if( this.mProgramVR != null )
            this.mRenderer.DestroyShader( this.mProgramVR );

        this.mSupportsVR = true;
        this.mProgramVR = res;
    }
    */
}

EffectPass.prototype.NewShader_Cubemap = function( shaderCode, commonShaderCodes )
{
    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }

    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;

    fsSource += shaderCode;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader_Common = function (shaderCode )
{
    let vsSource = null;
    if (this.mIs20)
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader + shaderCode;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader = function ( commonSourceCodes, preventCache, onResolve)
{
    if( this.mRenderer===null ) return;

    let vs_fs = null;

         if( this.mType==="sound"  ) vs_fs = this.NewShader_Sound(   this.mSource, commonSourceCodes );
    else if( this.mType==="image"  ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="buffer" ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="common" ) vs_fs = this.NewShader_Common(  this.mSource,                   );
    else if( this.mType==="cubemap") vs_fs = this.NewShader_Cubemap( this.mSource, commonSourceCodes );
    else { console.log("ERROR 3: \"" + this.mType + "\""); return; }

    let me = this;
    this.mRenderer.CreateShader(vs_fs[0], vs_fs[1], preventCache, false,
        function (worked, info)
        {
            if (worked === true)
            {
                if (me.mType === "sound")
                {
                    me.mSoundShaderCompiled = true;
                }

                me.mCompilationTime = info.mTime;
                me.mError = false;
                me.mErrorStr = "No Errors";
                if (me.mProgram !== null)
                    me.mRenderer.DestroyShader(me.mProgram);
                me.mTranslatedSource = me.mRenderer.GetTranslatedShaderSource(info);
                me.mProgram = info;
            }
            else
            {
                me.mError = true;
                me.mErrorStr = info.mErrorStr;
            }
            onResolve();
        });
}

EffectPass.prototype.DestroyInput = function( id )
{
    if( this.mInputs[id]===null ) return;

    if( this.mInputs[id].mInfo.mType==="texture" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    if( this.mInputs[id].mInfo.mType==="volume" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="webcam" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video.src = "";

        if( this.mInputs[id].video.srcObject!==null )
        {
        let tracks = this.mInputs[id].video.srcObject.getVideoTracks();
        if( tracks ) tracks[0].stop();
        }
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="video" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="music" || this.mInputs[id].mInfo.mType==="musicstream")
    {
        this.mInputs[id].audio.pause();
        this.mInputs[id].audio.mSound.mFreqData = null;
        this.mInputs[id].audio.mSound.mWaveData = null;
        this.mInputs[id].audio = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="cubemap" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="keyboard" )
    {
        //if( this.mInputs[id].globject != null )
          //  this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="mic" )
    {
        this.mInputs[id].mic = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }

    this.mInputs[id] = null;
}

EffectPass.prototype.TooglePauseInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        else
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.audio.mPaused )
        {
            if( inp.loaded )
            {
                inp.audio.play();
            }
            inp.audio.mPaused = false;
        }
        else
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }

    return null;
}

EffectPass.prototype.StopInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused === false )
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused === false )
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.ResumeInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused )
        {
            inp.audio.play();
            inp.audio.mPaused = false;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.RewindInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp==null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.loaded )
        {
            inp.video.currentTime = 0;
        }
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.loaded )
        {
            inp.audio.currentTime = 0;
        }
    }
}

EffectPass.prototype.MuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = true;
        inp.video.mMuted = true;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 0.0;
        inp.audio.mMuted = true;
    }
}

EffectPass.prototype.UnMuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = false;
        inp.video.mMuted = false;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 1.0;
        inp.audio.mMuted = false;
    }
}

EffectPass.prototype.ToggleMuteInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];
    if( inp===null ) return null;

    if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.video.mMuted;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if( inp.audio.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.audio.mMuted;
    }

    return null;
}

EffectPass.prototype.UpdateInputs = function( wa, forceUpdate, keyboard )
{
   for (let i=0; i<this.mInputs.length; i++ )
   {
        let inp = this.mInputs[i];

        if( inp===null )
        {
            if( forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, null, false, 0, 0, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.image, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mPreview, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if( inp.loaded && forceUpdate )
            {
                if( this.mTextureCallbackFun!==null )
                {
                    let img = (assetID_to_cubemapBuferID(inp.mInfo.mID)===-1) ? inp.image[0] : inp.mImage;
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, img, true, 2, 1, -1.0, this.mID );
                }
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:keyboard.mIcon,mData:keyboard.mData}, false, 6, 0, -1.0, this.mID );
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, -1, this.mID );
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
              if( inp.loaded && inp.audio.mPaused === false && inp.audio.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                      inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                  }

                  if (this.mTextureCallbackFun!==null)
                  {
                           if (inp.mInfo.mType === "music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData}, false, 4, 1, inp.audio.currentTime, this.mID);
                      else if (inp.mInfo.mType === "musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData, info: inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                  }
              }
              else if( inp.loaded===false )
              {
                  if (this.mTextureCallbackFun!==null)
                      this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:null}, false, 4, 0, -1.0, this.mID);
              }
        }
        else if( inp.mInfo.mType==="mic" )
        {
              if( inp.loaded && inp.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                      inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
                  }
                  if( this.mTextureCallbackFun!==null )
                      this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave: ((wa==null)?null:inp.mFreqData) }, false, 5, 1, 0, this.mID );
              }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:null}, true, 9, 1, -1.0, this.mID );
            }
        }
    }
}

EffectPass.prototype.Sampler2Renderer = function (sampler)
{
    let filter = this.mRenderer.FILTER.NONE;
    if (sampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
    if (sampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
    let wrap = this.mRenderer.TEXWRP.REPEAT;
    if (sampler.wrap === "clamp") wrap = this.mRenderer.TEXWRP.CLAMP;
    let vflip = false;
    if (sampler.vflip === "true") vflip = true;

    return { mFilter: filter, mWrap: wrap, mVFlip: vflip };
}

EffectPass.prototype.GetSamplerVFlip = function (id)
{
    let inp = this.mInputs[id];
    return inp.mInfo.mSampler.vflip;
}

EffectPass.prototype.GetTranslatedShaderSource = function ()
{
    return this.mTranslatedSource;
}

EffectPass.prototype.SetSamplerVFlip = function (id, str) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = false;
    if (str === "true") filter = true;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, null);
            inp.mInfo.mSampler.vflip = str;
        }
    }
}

EffectPass.prototype.GetAcceptsVFlip = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return false;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return false;
    return true;
}

EffectPass.prototype.GetSamplerFilter = function (id)
{
    let inp = this.mInputs[id];
    if( inp===null) return;
    return inp.mInfo.mSampler.filter;
}

EffectPass.prototype.SetSamplerFilter = function (id, str, buffers, cubeBuffers) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = renderer.FILTER.NONE;
    if (str === "linear") filter = renderer.FILTER.LINEAR;
    if (str === "mipmap") filter = renderer.FILTER.MIPMAP;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0)
            {
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[0], filter, true);
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[1], filter, true);
                inp.mInfo.mSampler.filter = str;
            }
            else
            {
                renderer.SetSamplerFilter(inp.globject, filter, true);
                inp.mInfo.mSampler.filter = str;
            }
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[0], filter, true);
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[1], filter, true);
        inp.mInfo.mSampler.filter = str;
    }
    else if (inp.mInfo.mType === "keyboard")
    {
        inp.mInfo.mSampler.filter = str;
    }
}

EffectPass.prototype.GetAcceptsMipmapping = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetAcceptsLinear = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return true;
    if (inp.mInfo.mType === "musicstream") return true;
    if (inp.mInfo.mType === "mic")  return true;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return true;
    return false;
}

EffectPass.prototype.GetAcceptsWrapRepeat = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return false;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetSamplerWrap = function (id)
{
    return this.mInputs[id].mInfo.mSampler.wrap;
}

EffectPass.prototype.SetSamplerWrap = function (id, str, buffers)
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let restr = renderer.TEXWRP.REPEAT;
    if (str === "clamp") restr = renderer.TEXWRP.CLAMP;

    if (inp === null) 
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "video") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap") 
    {
        if (inp.loaded)
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "webcam") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[0], restr);
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[1], restr);
        inp.mInfo.mSampler.wrap = str;
    }
}


EffectPass.prototype.GetTexture = function( slot )
{
    let inp = this.mInputs[slot];
    if( inp===null ) return null;
    return inp.mInfo;
}

EffectPass.prototype.SetOutputs = function( slot, id )
{
    this.mOutputs[slot] = id;
}

EffectPass.prototype.SetOutputsByBufferID = function( slot, id )
{
    if( this.mType==="buffer" )
    {
        this.mOutputs[slot] = bufferID_to_assetID( id );

        this.mEffect.ResizeBuffer( id, this.mEffect.mXres, this.mEffect.mYres, false );
    }
    else if( this.mType==="cubemap" )
    {
        this.mOutputs[slot] = cubamepBufferID_to_assetID( id );
        this.mEffect.ResizeCubemapBuffer(id, 1024, 1024 );
    }
}

EffectPass.prototype.NewTexture = function( wa, slot, url, buffers, cubeBuffers, keyboard )
{
    var me = this;
    var renderer = this.mRenderer;

    if( renderer===null ) return;

    let texture = null;

    if( url===null || url.mType===null )
    {
        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( this.mTextureCallbackObj, slot, null, true, 0, 0, -1.0, me.mID );
        me.DestroyInput( slot );
        me.mInputs[slot] = null;
        me.MakeHeader();
        return { mFailed:false, mNeedsShaderCompile:false };
    }
    else if( url.mType==="texture" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.image = new Image();
        texture.image.crossOrigin = '';
        texture.image.onload = function()
        {
            let rti = me.Sampler2Renderer(url.mSampler);

            // O.M.G. FIX THIS
            let channels = renderer.TEXFMT.C4I8;
            if (url.mID === "Xdf3zn" || url.mID === "4sf3Rn" || url.mID === "4dXGzn" || url.mID === "4sf3Rr")
                channels = renderer.TEXFMT.C1I8;
            
            texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.image, channels, rti.mFilter, rti.mWrap, rti.mVFlip);

            texture.loaded = true;
            if( me.mTextureCallbackFun!==null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.image, true, 1, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="volume" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mImage = { mData:null, mXres:1, mYres:0, mZres:0 };
        texture.mPreview = new Image();
        texture.mPreview.crossOrigin = '';

	    var xmlHttp = new XMLHttpRequest();
        if( xmlHttp===null ) return { mFailed:true };

        xmlHttp.open('GET', url.mSrc, true);
        xmlHttp.responseType = "arraybuffer";
        xmlHttp.onerror = function()
        {
            console.log( "Error 1 loading Volume" );
        }
        xmlHttp.onload = function()
        {
            let data = xmlHttp.response;
            if (!data ) { console.log( "Error 2 loading Volume" ); return; }

            let file = piFile(data);

            let signature = file.ReadUInt32();
            texture.mImage.mXres = file.ReadUInt32();
            texture.mImage.mYres = file.ReadUInt32();
            texture.mImage.mZres = file.ReadUInt32();
            let binNumChannels = file.ReadUInt8();
            let binLayout = file.ReadUInt8();
            let binFormat = file.ReadUInt16();
            let format = renderer.TEXFMT.C1I8;
                 if( binNumChannels===1 && binFormat===0 )  format = renderer.TEXFMT.C1I8;
            else if( binNumChannels===2 && binFormat===0 )  format = renderer.TEXFMT.C2I8;
            else if( binNumChannels===3 && binFormat===0 )  format = renderer.TEXFMT.C3I8;
            else if( binNumChannels===4 && binFormat===0 )  format = renderer.TEXFMT.C4I8;
            else if( binNumChannels===1 && binFormat===10 ) format = renderer.TEXFMT.C1F32;
            else if( binNumChannels===2 && binFormat===10 ) format = renderer.TEXFMT.C2F32;
            else if( binNumChannels===3 && binFormat===10 ) format = renderer.TEXFMT.C3F32;
            else if( binNumChannels===4 && binFormat===10 ) format = renderer.TEXFMT.C4F32;
            else return;

            let buffer = new Uint8Array(data, 20); // skip 16 bytes (header of .bin)

            let rti = me.Sampler2Renderer(url.mSampler);

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T3D, texture.mImage.mXres, texture.mImage.mYres, format, rti.mFilter, rti.mWrap, buffer);

            if( texture.globject===null )
            {
                console.log( "Error 4: loading Volume" ); 
                return { mFailed:true };
            }

            if (me.mTextureCallbackFun !== null)
            {
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }

            texture.loaded = true;

            // load icon for it
            texture.mPreview.onload = function()
            {
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }
            texture.mPreview.src = url.mPreviewSrc;
        }
        xmlHttp.send("");


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="volume")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="cubemap" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        let rti = me.Sampler2Renderer(url.mSampler);

        if( assetID_to_cubemapBuferID(url.mID)!==-1 )
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 2, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/cubemap00.png";

            this.mEffect.ResizeCubemapBuffer(0, 1024, 1024 );

        }
        else
        {
            texture.image = [ new Image(), new Image(), new Image(), new Image(), new Image(), new Image() ];

            let numLoaded = 0;
            for (var i=0; i<6; i++ )
            {
                texture.image[i].mId = i;
                texture.image[i].crossOrigin = '';
                texture.image[i].onload = function()
                {
                    var id = this.mId;
                    numLoaded++;
                    if( numLoaded===6 )
                    {
                        texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.CUBEMAP, texture.image, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                        texture.loaded = true;
                        if (me.mTextureCallbackFun !== null)
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, texture.image[0], true, 2, 1, -1.0, me.mID);
                    }
                }

                if( i === 0) 
                {
                    texture.image[i].src = url.mSrc;
                } 
                else 
                {
                    let n = url.mSrc.lastIndexOf(".");
                    texture.image[i].src = url.mSrc.substring(0, n) + "_" + i + url.mSrc.substring(n, url.mSrc.length);
                }
            }
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="cubemap")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="webcam" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        texture.video = document.createElement('video');
    	texture.video.width = 320;
    	texture.video.height = 240;
    	texture.video.autoplay = true;
    	texture.video.loop = true;
        texture.mForceMuted = this.mForceMuted;
        texture.mImage = null;

        let rti = me.Sampler2Renderer(url.mSampler);

        var loadImageInsteadOfWebCam = function()
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.mImage, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 7, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/webcam.png";
        }
        
        loadImageInsteadOfWebCam();

        if( typeof navigator.getUserMedia !== "undefined"  && texture.mForceMuted===false )
        {
            texture.video.addEventListener("canplay", function (e)
            {
				try
				{
                    texture.mImage = null;
                    if( texture.globject != null )
                        renderer.DestroyTexture( texture.globject );
					texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
					texture.loaded = true;
                }
                catch(e)
                {
                    loadImageInsteadOfWebCam();
	                alert( 'Your browser can not transfer webcam data to the GPU.');
                }
            } );

            navigator.mediaDevices.getUserMedia( 
                                { "video": { width: 1280, height: 720 }, "audio": false } )
                                .then( function(stream)
                                       {
                                            texture.video.srcObject = stream;
    	                               } )
                                .catch( function(error)
                                        {
                                            loadImageInsteadOfWebCam();
    		                                alert( 'Unable to capture WebCam. Please reload the page.' );
    	                                } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="mic" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mForceMuted = this.mForceMuted;
        texture.mAnalyser = null;
        let num = 512;
        texture.mFreqData = new Uint8Array( num );
        texture.mWaveData = new Uint8Array( num );

        if( wa === null || typeof navigator.getUserMedia === "undefined" )
        {
            if( !texture.mForceMuted ) alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.mForceMuted = true; 
        }

        if( texture.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, num, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)
            texture.loaded = true;
        }
        else
        {
        navigator.getUserMedia( { "audio": true },
                                function(stream)
                                {
                                  texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, null)
                                  texture.mic = wa.createMediaStreamSource(stream);
                                  texture.mAnalyser = wa.createAnalyser();
                                  texture.mic.connect( texture.mAnalyser );
                                  texture.loaded = true;
    	                        },
                                function(error)
                                {
    		                        alert( 'Unable open Mic. Please reload the page.' );
    	                        } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="video" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.video = document.createElement('video');
    	texture.video.loop = true;
        texture.video.preload = "auto";
        texture.video.mPaused = this.mForcePaused;
        texture.video.mMuted = true;//this.mForceMuted;
    	texture.video.muted  = true;//this.mForceMuted;
        if( this.mForceMuted===true )
            texture.video.volume = 0;
    	texture.video.autoplay = false;
        texture.video.hasFalled = false;
        
        let rti = me.Sampler2Renderer(url.mSampler);

        texture.video.addEventListener("canplay", function (e)
        {
            texture.video.play().then( function()
                                       {
                                           texture.video.mPaused = false;

                                           texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                                           texture.loaded = true;
            
                                           if( me.mTextureCallbackFun!=null )
                                               me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.video, true, 3, 1, -1.0, me.mID );
                                        } )
                               .catch( function(error)
                                       {
                                           console.log( error );
                                       }
                                );
        } );

        texture.video.addEventListener( "error", function(e)
        {
               if( texture.video.hasFalled===true ) { alert("Error: cannot load video" ); return; }
               let str = texture.video.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".mp4";
               texture.video.src = str;
               texture.video.hasFalled = true;
        } );

        texture.video.src = url.mSrc;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="music" || url.mType==="musicstream" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.audio = document.createElement('audio');
    	texture.audio.loop = true;
        texture.audio.mMuted = this.mForceMuted;
        texture.audio.mForceMuted = this.mForceMuted;
        texture.audio.muted = this.mForceMuted;
        if( this.mForceMuted===true )
            texture.audio.volume = 0;
        texture.audio.autoplay = false;
        texture.audio.hasFalled = false;
        texture.audio.mPaused = false;
        texture.audio.mSound = {};

        if( this.mForceMuted===false )
        {
            if(url.mType==="musicstream" && SC === null)
            {
                alert( "Shadertoy: Soundcloud could not be reached" );
                texture.audio.mForceMuted = true;
            }
            }

        if( wa === null && this.mForceMuted===false )
        {
            alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.audio.mForceMuted = true;
        }

        if( texture.audio.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null);
            let num = 512;
            texture.audio.mSound.mFreqData = new Uint8Array( num );
            texture.audio.mSound.mWaveData = new Uint8Array( num );
            texture.loaded = true;
        }

        texture.audio.addEventListener( "canplay", function()
        {
            if( texture===null || texture.audio===null ) return;
            if( this.mForceMuted  ) return;
            if( texture.loaded === true ) return;

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)

            texture.audio.mSound.mSource   = wa.createMediaElementSource( texture.audio );
            texture.audio.mSound.mAnalyser = wa.createAnalyser();
            texture.audio.mSound.mGain     = wa.createGain();

            texture.audio.mSound.mSource.connect(   texture.audio.mSound.mAnalyser );
            texture.audio.mSound.mAnalyser.connect( texture.audio.mSound.mGain );
            texture.audio.mSound.mGain.connect(me.mGainNode);

            texture.audio.mSound.mFreqData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );
            texture.audio.mSound.mWaveData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );

            if( texture.audio.mPaused )
            {
                texture.audio.pause();
            }
            else
            {
                texture.audio.play().then( function() {} ).catch( function(e){console.log("error " + e);} );
            }
            texture.loaded = true;
        } );

        texture.audio.addEventListener( "error", function(e)
        {
               if( this.mForceMuted  ) return;

               if( texture.audio.hasFalled===true ) { return; }
               let str = texture.audio.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".ogg";
               texture.audio.src = str;
               texture.audio.hasFalled = true;
        } );

        if( !texture.audio.mForceMuted )
        {
            if(url.mType==="musicstream")
            {
                SC.resolve(url.mSrc, 
                    function(song) 
                    {
                        if( song.streamable===true )
                        {
                            texture.audio.crossOrigin = 'anonymous';
                            texture.audio.src = song.stream_url;
                            texture.audio.soundcloudInfo = song;
                        }
                        else
                        {
                            alert('Shadertoy: Soundcloud 3 - This track cannot be streamed' );
                        }
                    },
                    function(error)
                    {
                        if (me.mTextureCallbackFun!==null)
                        {
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
                        }
                    } );
            } 
            else
            {
                texture.audio.src = url.mSrc;
            }
        }

        if (me.mTextureCallbackFun!==null)
        {
            if (url.mType === "music")            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
            else if (url.mType === "musicstream") me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null, info: texture.audio.soundcloudInfo}, false, 8, 0, -1.0, me.mID);
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="keyboard" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = true;

        texture.keyboard = {};

        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {mImage: keyboard.mIcon, mData: keyboard.mData}, false, 6, 1, -1.0, me.mID );

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="buffer" )
    {
        texture = {};
        texture.mInfo = url;

        texture.image = new Image();
        texture.image.onload = function()
        {
            if( me.mTextureCallbackFun!==null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {texture: texture.image, data:null}, true, 9, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;
        texture.id = assetID_to_bufferID( url.mID );
        texture.loaded = true;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;

        this.mEffect.ResizeBuffer(texture.id, this.mEffect.mXres, this.mEffect.mYres, false );

        this.SetSamplerFilter(slot, url.mSampler.filter, buffers, cubeBuffers, true);
        this.SetSamplerVFlip(slot, url.mSampler.vflip);
        this.SetSamplerWrap(slot, url.mSampler.wrap, buffers);

        this.MakeHeader();
        return returnValue;
    }
    else
    {
        alert( "input type error" );
        return { mFailed: true };
    }

    return { mFailed: true };
}

EffectPass.prototype.Paint_Image = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];

    //------------------------
    
    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];
    let texIsLoaded = [0, 0, 0, 0 ];
    let texID = [ null, null, null, null];

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
            texIsLoaded[i] = 1;
            resos[3*i+0] = 256;
            resos[3*i+1] = 3;
            resos[3*i+2] = 1;
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;

                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                }
            }
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {

                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                texIsLoaded[i] = 0;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    times[i] = 10.0 + time;
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            let id = inp.id;
            if( inp.loaded===true  )
            {
                texID[i] = buffers[id].mTexture[ buffers[id].mLastRenderDone ];
                texIsLoaded[i] = 1;
                resos[3*i+0] = xres;
                resos[3*i+1] = yres;
                resos[3*i+2] = 1;
                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID[i], filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    let prog = this.mProgram;

    //if( vrData!=null && this.mSupportsVR ) prog = this.mProgramVR;

    this.mRenderer.AttachShader(prog);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F("iFrameRate", fps);

    this.mRenderer.SetShaderConstant1F(  "iCh0.time", times[0] );
    this.mRenderer.SetShaderConstant1F(  "iCh1.time", times[1] );
    this.mRenderer.SetShaderConstant1F(  "iCh2.time", times[2] );
    this.mRenderer.SetShaderConstant1F(  "iCh3.time", times[3] );
    this.mRenderer.SetShaderConstant3F(  "iCh0.size", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iCh1.size", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iCh2.size", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iCh3.size", resos[9], resos[10], resos[11] );
    this.mRenderer.SetShaderConstant1I(  "iCh0.loaded", texIsLoaded[0] );
    this.mRenderer.SetShaderConstant1I(  "iCh1.loaded", texIsLoaded[1] );
    this.mRenderer.SetShaderConstant1I(  "iCh2.loaded", texIsLoaded[2] );
    this.mRenderer.SetShaderConstant1I(  "iCh3.loaded", texIsLoaded[3] );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    if( (vrData !== null) && this.mSupportsVR )
    {
        for (let i=0; i<2; i++ )
        {
            let ei = (i===0) ? vrData.mLeftEye : vrData.mRightEye;

            let vp = [i * xres / 2, 0, xres / 2, yres];

            this.mRenderer.SetViewport(vp);

            let fov = ei.mProjection;
            let corA = [ -fov[2], -fov[1], -1.0 ];
            let corB = [  fov[3], -fov[1], -1.0 ];
            let corC = [  fov[3],  fov[0], -1.0 ];
            let corD = [ -fov[2],  fov[0], -1.0 ];
            let apex = [ 0.0, 0.0, 0.0 ];

            let ma = invertFast( ei.mCamera );
            corA = matMulpoint( ma, corA ); 
            corB = matMulpoint( ma, corB ); 
            corC = matMulpoint( ma, corC ); 
            corD = matMulpoint( ma, corD ); 
            apex = matMulpoint( ma, apex ); 

            let corners = [ corA[0], corA[1], corA[2], 
                            corB[0], corB[1], corB[2], 
                            corC[0], corC[1], corC[2], 
                            corD[0], corD[1], corD[2],
                            apex[0], apex[1], apex[2]];

            this.mRenderer.SetShaderConstant3FV("unCorners", corners);
            this.mRenderer.SetShaderConstant4FV("unViewport", vp);

            this.mRenderer.DrawUnitQuad_XY(l1);
        }
    }
    else 
    {
        this.mRenderer.SetViewport([0, 0, xres, yres]);
        this.mRenderer.DrawFullScreenTriangle_XY( l1 );
    }

    this.mRenderer.DettachTextures();
}

EffectPass.prototype.iRenderSound = function(d, callback )
{
    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds() ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    this.mRenderer.SetRenderTarget(this.mRenderFBO);

    this.mRenderer.SetViewport([0, 0, this.mTextureDimensions, this.mTextureDimensions]);
    this.mRenderer.AttachShader(this.mProgram);
    this.mRenderer.SetBlend( false );

    let texID = [null, null, null, null];
    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
    }

    this.mRenderer.AttachTextures(4, texID[0], texID[1], texID[2], texID[3]);

    let l2 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iTimeOffset");
    let l3 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iSampleOffset");
    this.mRenderer.SetShaderConstant4FV("iDate", dates);
    this.mRenderer.SetShaderConstant3FV("iChannelResolution", resos);
    this.mRenderer.SetShaderConstant1F("iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit("iChannel0", 0);
    this.mRenderer.SetShaderTextureUnit("iChannel1", 1);
    this.mRenderer.SetShaderTextureUnit("iChannel2", 2);
    this.mRenderer.SetShaderTextureUnit("iChannel3", 3);

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    //--------------------------------
    let numSamples = this.mTmpBufferSamples;
    let numBlocks = this.mPlaySamples / numSamples;
    for (let j=0; j<numBlocks; j++ )
    {
        let off = j*numSamples;
        
        this.mRenderer.SetShaderConstant1F_Pos(l2, off / this.mSampleRate);
        this.mRenderer.SetShaderConstant1I_Pos(l3, off );
        this.mRenderer.DrawUnitQuad_XY(l1);

        this.mRenderer.GetPixelData(this.mData, 0, this.mTextureDimensions, this.mTextureDimensions);

        callback( off, this.mData, numSamples );
    }

    this.mRenderer.DetachShader();
    this.mRenderer.DettachTextures();
    this.mRenderer.SetRenderTarget(null);
}

EffectPass.prototype.Paint_Sound = function( wa, d )
{
    let bufL = this.mBuffer.getChannelData(0); // Float32Array
    let bufR = this.mBuffer.getChannelData(1); // Float32Array

    this.iRenderSound( d, function(off, data, numSamples)
                         {
                            for( let i=0; i<numSamples; i++ )
                            {
                                bufL[off+i] = -1.0 + 2.0*(data[4*i+0]+256.0*data[4*i+1])/65535.0;
                                bufR[off+i] = -1.0 + 2.0*(data[4*i+2]+256.0*data[4*i+3])/65535.0;
                            }
                         }
                     );
}

EffectPass.prototype.SetUniforms = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    //------------------------
    
    let texID = [ null, null, null, null];

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
        }
        else if( inp.mInfo.mType=="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
    
                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                }
            }

        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
           if( inp.loaded===true )
           { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                times[i] = 10.0 + time;
            }

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = buffers[inp.id].mTexture[ buffers[inp.id].mLastRenderDone ];
                resos[3*i+0] = buffers[inp.id].mResolution[0];
                resos[3*i+1] = buffers[inp.id].mResolution[1];
                resos[3*i+2] = 1;
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    this.mRenderer.AttachShader(this.mProgram);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F(  "iFrameRate", fps );

    this.mRenderer.SetShaderConstant1F(  "iChannel[0].time",       times[0] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[1].time",       times[1] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[2].time",       times[2] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[3].time",       times[3] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[0].resolution", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[1].resolution", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[2].resolution", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[3].resolution", resos[9], resos[10], resos[11] );
}

EffectPass.prototype.ProcessInputs = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
        }
        else if( inp.mInfo.mType==="volume" )
        {
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );
                }
                else if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                if( inp.audio.mForceMuted === true )
                {
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                let id = inp.id;
                let texID = buffers[id].mTexture[ buffers[id].mLastRenderDone ];

                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID, filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
				let id = inp.id;
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }
}

EffectPass.prototype.Paint_Cubemap = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face )
{
    this.ProcessInputs(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
    this.SetUniforms(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    let vp = [0, 0, xres, yres];

    this.mRenderer.SetViewport(vp);

    let corA = [-1.0, -1.0, -1.0];
    let corB = [ 1.0, -1.0, -1.0];
    let corC = [ 1.0,  1.0, -1.0];
    let corD = [-1.0,  1.0, -1.0];
    let apex = [ 0.0,  0.0,  0.0];

         if( face===0 ) { corA=[ 1.0,  1.0,  1.0]; corB=[ 1.0,  1.0, -1.0]; corC=[ 1.0, -1.0, -1.0]; corD=[ 1.0, -1.0,  1.0]; }
    else if( face===1 ) { corA=[-1.0,  1.0, -1.0]; corB=[-1.0,  1.0,  1.0]; corC=[-1.0, -1.0,  1.0]; corD=[-1.0, -1.0, -1.0]; }
    else if( face===2 ) { corA=[-1.0,  1.0, -1.0]; corB=[ 1.0,  1.0, -1.0]; corC=[ 1.0,  1.0,  1.0]; corD=[-1.0,  1.0,  1.0]; }
    else if( face===3 ) { corA=[-1.0, -1.0,  1.0]; corB=[ 1.0, -1.0,  1.0]; corC=[ 1.0, -1.0, -1.0]; corD=[-1.0, -1.0, -1.0]; }
    else if( face===4 ) { corA=[-1.0,  1.0,  1.0]; corB=[ 1.0,  1.0,  1.0]; corC=[ 1.0, -1.0,  1.0]; corD=[-1.0, -1.0,  1.0]; }
    else if( face===5 ) { corA=[ 1.0,  1.0, -1.0]; corB=[-1.0,  1.0, -1.0]; corC=[-1.0, -1.0, -1.0]; corD=[ 1.0, -1.0, -1.0]; }

    let corners = [ corA[0], corA[1], corA[2], 
                    corB[0], corB[1], corB[2], 
                    corC[0], corC[1], corC[2], 
                    corD[0], corD[1], corD[2],
                    apex[0], apex[1], apex[2]];

    this.mRenderer.SetShaderConstant3FV("unCorners", corners);
    this.mRenderer.SetShaderConstant4FV("unViewport", vp);

    this.mRenderer.DrawUnitQuad_XY(l1);

    this.mRenderer.DettachTextures();
}

EffectPass.prototype.Paint = function( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, bufferNeedsMimaps, buffers, cubeBuffers, keyboard, effect )
{
    if( this.mType==="sound" )
    {
        if (this.mSoundShaderCompiled === true)
        {
            // make sure all textures are loaded
            for (let i=0; i<this.mInputs.length; i++ )
            {
                let inp = this.mInputs[i];
                if (inp === null) continue;

                if (inp.mInfo.mType === "texture" && !inp.loaded) return;
                if (inp.mInfo.mType === "cubemap" && !inp.loaded) return;
            }

            this.Paint_Sound(wa, da);
            this.mSoundShaderCompiled = false;
        }
        if (this.mFrame === 0)
        {
            if (this.mPlaying===true)
            {
                this.mPlayNode.disconnect();
                this.mPlayNode.stop();
                this.mPlayNode = null;
            }
            this.mPlaying = true;

            this.mPlayNode = wa.createBufferSource();
            this.mPlayNode.buffer = this.mBuffer;
            this.mPlayNode.connect(this.mGainNode);
            this.mPlayNode.start(0);
        }
        this.mFrame++;
    }
    else if( this.mType==="image" )
    {
        this.mRenderer.SetRenderTarget( null );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );
        this.mFrame++;
    }
    else if( this.mType==="common" )
    {
    }
    else if( this.mType==="buffer" )
    {
        this.mEffect.ResizeBuffer(bufferID, this.mEffect.mXres, this.mEffect.mYres, false );

        let buffer = buffers[bufferID];

        let dstID = 1 - buffer.mLastRenderDone;

        this.mRenderer.SetRenderTarget( buffer.mTarget[dstID] );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }

        // make thumbnail
        //if( this.mTextureCallbackFun != null )
        /*
        {
            this.mRenderer.SetRenderTarget( buffer.mThumbnailRenderTarget );
            let v = [0, 0, buffer.mThumbnailRes[0], buffer.mThumbnailRes[1]];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            this.mRenderer.SetShaderConstant4FV("v", v);
            this.mRenderer.AttachTextures(1, buffer.mTexture[dstID], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);
            this.mRenderer.DettachTextures();
            this.mRenderer.DetachShader();
            this.mRenderer.GetPixelData( new Uint8Array(buffer.mThumbnailBuffer.data.buffer), buffer.mThumbnailRes[0], buffer.mThumbnailRes[1] );
            this.mRenderer.SetRenderTarget(null);
        }
        */
        buffers[bufferID].mLastRenderDone = 1 - buffers[bufferID].mLastRenderDone;
        this.mFrame++;
    }
    else if( this.mType==="cubemap" )
    {
        this.mEffect.ResizeCubemapBuffer(bufferID, 1024, 1024, false );

        let buffer = cubeBuffers[bufferID];

        xres = buffer.mResolution[0];
        yres = buffer.mResolution[1];
        let dstID = 1 - buffer.mLastRenderDone;
        for( let face=0; face<6; face++ )
        {
            this.mRenderer.SetRenderTargetCubeMap( buffer.mTarget[dstID], face );
            this.Paint_Cubemap( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
        }
        this.mRenderer.SetRenderTargetCubeMap( null, 0 );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }
        cubeBuffers[bufferID].mLastRenderDone = 1 - cubeBuffers[bufferID].mLastRenderDone;

        this.mFrame++;
    }
}

EffectPass.prototype.StopOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;
    this.mPlayNode.disconnect();
}

EffectPass.prototype.ResumeOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;

    wa.resume()
    this.mPlayNode.connect( this.mGainNode );
}

EffectPass.prototype.StopOutput_Image = function( wa )
{
}

EffectPass.prototype.ResumeOutput_Image = function( wa )
{
}

EffectPass.prototype.StopOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.StopInput(j);

    if( this.mType==="sound" )
         this.StopOutput_Sound( wa );
    else
         this.StopOutput_Image( wa );
}

EffectPass.prototype.ResumeOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.ResumeInput(j);

    if( this.mType==="sound" )
         this.ResumeOutput_Sound( wa );
    else
         this.ResumeOutput_Image( wa );
}

EffectPass.prototype.GetCompilationTime = function()
{
    return this.mCompilationTime;
}

//============================================================================================================
function Screenshots()
{
    // private
    let mTexture = null;
    let mTarget = null;
    let mXres = 0;
    let mYres = 0;
    let mCubemapToEquirectProgram;
    let mRenderer = null;

    // public
    var me = {};

    me.Initialize = function(renderer)
    {
        mRenderer = renderer;
        let caps = mRenderer.GetCaps();
        let is20 = caps.mIsGL20;

        let vsSourceC, fsSourceC;
        if( is20 )
        {
            vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; out vec4 outColor; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); outColor = texture(t, rd); }";
        }
        else
        {
            vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); gl_FragColor = texture(t, rd); }";
        }

        let compileShader = function (worked, info)
        {
            if (worked === false)
            {
                console.log("Failed to compile cubemap resample shader (" + errorType + "): " + log);
            }
            else
            {
                mCubemapToEquirectProgram = info;
            }
        }
        mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, compileShader);

        return true;
    };

    me.Allocate = function( xres, yres )
    {
        if( xres>mXres || yres>mYres )
        {
            let texture = mRenderer.CreateTexture(mRenderer.TEXTYPE.T2D, xres, yres, mRenderer.TEXFMT.C4F32, mRenderer.FILTER.NONE, mRenderer.TEXWRP.CLAMP, null);
            let target = mRenderer.CreateRenderTarget( texture, null, null, null, null, false);

            if( mXres!==0 )
            {
                mRenderer.DestroyTexture(mTexture);
                mRenderer.DestroyRenderTarget(mTarget);
            }

            mTexture = texture;
            mTarget = target;
            mXres = xres;
            mYres = yres;
        }
    };

    me.GetProgram = function()
    {
        return mCubemapToEquirectProgram;
    };
    me.GetTarget = function()
    {
        return mTarget;
    };

    return me;
};

//============================================================================================================

function Effect(vr, ac, canvas, callback, obj, forceMuted, forcePaused, resizeCallback, crashCallback )
{
    let xres = canvas.width;
    let yres = canvas.height;

    let me = this;
    this.mCanvas = canvas;
    this.mCreated = false;
    this.mRenderer = null;
    this.mAudioContext = ac;
    this.mGLContext = null;
    this.mWebVR = vr;
    this.mRenderingStereo = false;
    this.mXres = xres;
    this.mYres = yres;
    this.mForceMuted = forceMuted;
    if( ac===null ) this.mForceMuted = true;
    this.mForcePaused = forcePaused;
    this.mGainNode = null;
    this.mPasses = [];
    this.mFrame = 0;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mMaxBuffers = 4;
    this.mMaxCubeBuffers = 1;
    this.mMaxPasses = this.mMaxBuffers + 1 + 1 + 1 + 1; // some day decouple passes from buffers (4 buffers + common + Imagen + sound + cubemap)
    this.mBuffers = [];
    this.mCubeBuffers = [];
    this.mScreenshotSytem = null;
    this.mCompilationTime = 0;
    this.mIsLowEnd = piIsMobile();

    this.mGLContext = piCreateGlContext(canvas, false, false, true, false); // need preserve-buffe to true in order to capture screenshots
    if (this.mGLContext === null)
    {
        return;
    }

    canvas.addEventListener("webglcontextlost", function (event)
        {
            event.preventDefault();
            crashCallback();
        }, false);

    this.mRenderer = piRenderer();
    if (!this.mRenderer.Initialize(this.mGLContext))
        return;

    this.mScreenshotSytem = Screenshots();
    if (!this.mScreenshotSytem.Initialize(this.mRenderer))
        return;

    var caps = this.mRenderer.GetCaps();
    this.mIs20 = caps.mIsGL20;
    this.mShaderTextureLOD = caps.mShaderTextureLOD;
    //-------------
    if( ac!==null )
    {   
        this.mGainNode = ac.createGain();
        if( !forceMuted )
        {
            this.mGainNode.connect( ac.destination);
        }
        if (this.mForceMuted )
            this.mGainNode.gain.value = 0.0;
        else
            this.mGainNode.gain.value = 1.0;
    }

    //-------------
    let vsSourceC, fsSourceC;
    if( this.mIs20 )
    {
        vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { outColor = textureLod(t, gl_FragCoord.xy / v.zw, 0.0); }";
    }
    else
    {
        vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; void main() { gl_FragColor = texture2D(t, gl_FragCoord.xy / v.zw, -100.0); }";
    }

    this.mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, function(worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to copy buffers : " + info.mErrorStr);
            else me.mProgramCopy = info;
        });

    let vsSourceD, fsSourceD;
    if( this.mIs20 )
    {
        vsSourceD = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { vec2 uv = gl_FragCoord.xy / v.zw; outColor = texture(t, vec2(uv.x,1.0-uv.y)); }";
    }
    else
    {
        vsSourceD = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; void main() { vec2 uv = gl_FragCoord.xy / v.zw; gl_FragColor = texture2D(t, vec2(uv.x,1.0-uv.y)); }";
    }

    this.mRenderer.CreateShader(vsSourceD, fsSourceD, false, true, function (worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to downscale buffers : " + info.mErrorStr);
            else me.mProgramDownscale = info;
        });


    // set all buffers and cubemaps to null
    for( let i=0; i<this.mMaxBuffers; i++ )
    {
        this.mBuffers[i] = { mTexture: [null, null], 
                             mTarget:  [null, null], 
                             mResolution: [0, 0],
                             mLastRenderDone: 0,
                             mThumbnailRenderTarget: null,
                             mThumbnailTexture: null,
                             mThumbnailBuffer:  null,
                             mThumbnailRes: [0, 0] };
    }

    for( let i=0; i<this.mMaxCubeBuffers; i++ )
    {
        this.mCubeBuffers[i] = { mTexture: [null, null], 
                                mTarget:  [null, null], 
                                mResolution: [0, 0],
                                mLastRenderDone: 0,
                                mThumbnailRenderTarget: null,
                                mThumbnailTexture: null,
                                mThumbnailBuffer:  null,
                                mThumbnailRes: [0, 0] };
    }

    //-------

    let keyboardData = new Uint8Array( 256*3 );
    for (let j=0; j<(256*3); j++ ) { keyboardData[j] = 0; }
    let kayboardTexture = this.mRenderer.CreateTexture( this.mRenderer.TEXTYPE.T2D, 256, 3, this.mRenderer.TEXFMT.C1I8, this.mRenderer.FILTER.NONE, this.mRenderer.TEXWRP.CLAMP, null);
    let keyboardImage = new Image();
    if( callback!==null )
        keyboardImage.src = "/img/keyboard.png"; // don't load PNG if no UI 
    this.mKeyboard = { mData: keyboardData, mTexture: kayboardTexture, mIcon: keyboardImage };

    let iResize = function( xres, yres )
    {
        me.mCanvas.width = xres;
        me.mCanvas.height = yres;
        me.mXres = xres;
        me.mYres = yres;
        me.ResizeBuffers(xres, yres);
        resizeCallback(xres, yres);
    };

    let bestAttemptFallback = function()
    {
        let devicePixelRatio = window.devicePixelRatio || 1;
        let xres = Math.round(me.mCanvas.offsetWidth  * devicePixelRatio) | 0;
        let yres = Math.round(me.mCanvas.offsetHeight * devicePixelRatio) | 0;
        iResize(xres, yres);
    };

    if(!window.ResizeObserver)
    {
        console.log("WARNING: This browser doesn't support ResizeObserver.");
        bestAttemptFallback();
        window.addEventListener("resize", bestAttemptFallback);
    }
    else
    {
        this.mRO = new ResizeObserver( function(entries, observer)
        {
            var entry = entries[0];
            if (!entry['devicePixelContentBoxSize'])
            {
                observer.unobserve(me.mCanvas);
                console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (2)");
                bestAttemptFallback();
                window.addEventListener("resize", bestAttemptFallback);
            }
            else
            {
                let box = entry.devicePixelContentBoxSize[0];
                let xres = box.inlineSize;
                let yres = box.blockSize;
                iResize(xres, yres);
            }
        });
        try
        {
            this.mRO.observe(this.mCanvas, { box: ["device-pixel-content-box"] });
            //this.mRO.observe(this.mCanvas);
        }
        catch (e)
        {
            console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (1)");
            bestAttemptFallback();
            window.addEventListener("resize", bestAttemptFallback);
        }
    }

    this.mCreated = true;
}

Effect.prototype.ResizeCubemapBuffer = function(i, xres, yres )
{
    let oldXres = this.mCubeBuffers[i].mResolution[0];
    let oldYres = this.mCubeBuffers[i].mResolution[1];

    if( this.mCubeBuffers[i].mTexture[0]===null || oldXres !== xres || oldYres !== yres )
    {
        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);
        let target1 = this.mRenderer.CreateRenderTargetCubeMap( texture1, null, false);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target2 = this.mRenderer.CreateRenderTargetCubeMap( texture2, null, false);

        // Store new buffers
        this.mCubeBuffers[i].mTexture = [texture1,texture2], 
        this.mCubeBuffers[i].mTarget =  [target1, target2 ], 
        this.mCubeBuffers[i].mLastRenderDone = 0;
        this.mCubeBuffers[i].mResolution[0] = xres;
        this.mCubeBuffers[i].mResolution[1] = yres;
    }
}

Effect.prototype.ResizeBuffer = function( i, xres, yres, skipIfNotExists )
{
    if( skipIfNotExists && this.mBuffers[i].mTexture[0]===null ) return;

    let oldXres = this.mBuffers[i].mResolution[0];
    let oldYres = this.mBuffers[i].mResolution[1];

    if( oldXres !== xres || oldYres !== yres )
    {
        let needCopy = (this.mBuffers[i].mTexture[0]!==null);

        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[0].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[0].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[1].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[1].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target1 = this.mRenderer.CreateRenderTarget( texture1, null, null, null, null, false);
        let target2 = this.mRenderer.CreateRenderTarget( texture2, null, null, null, null, false);

        if( needCopy )
        {
            let v = [0, 0, Math.min(xres, oldXres), Math.min(yres, oldYres)];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            let vOld = [0, 0, oldXres, oldYres];
            this.mRenderer.SetShaderConstant4FV("v", vOld);

            // Copy old buffers 1 to new buffer
            this.mRenderer.SetRenderTarget(target1);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[0], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Copy old buffers 2 to new buffer
            this.mRenderer.SetRenderTarget(target2);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[1], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Deallocate old memory
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[0]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[0]);
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[1]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[1]);
            //this.mRenderer.DestroyTexture(this.mBuffers[i].thumbnailTexture);
        }

        // Store new buffers
        this.mBuffers[i].mTexture = [texture1,texture2], 
        this.mBuffers[i].mTarget =  [target1, target2 ], 
        this.mBuffers[i].mLastRenderDone = 0;
        this.mBuffers[i].mResolution[0] = xres;
        this.mBuffers[i].mResolution[1] = yres;
    }
}

Effect.prototype.saveScreenshot = function(passid)
{
    let pass = this.mPasses[passid];

    if( pass.mType === "buffer" )
    {
        let bufferID = assetID_to_bufferID( this.mPasses[passid].mOutputs[0] );

        let texture = this.mBuffers[bufferID].mTarget[ this.mBuffers[bufferID].mLastRenderDone ];

        let numComponents = 3;
        let width = texture.mTex0.mXres;
        let height = texture.mTex0.mYres;
        let type = "Float"; // Other options Float, Half, Uint
        let bytes = new Float32Array(width * height * 4 );//numComponents);
        this.mRenderer.GetPixelDataRenderTarget( texture, bytes, width, height );
        let blob = piExportToEXR(width, height, numComponents, type, bytes);

        // Offer download automatically to the user
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "cubemap" )
    {
        let xres = 4096;
        let yres = 2048;
        this.mScreenshotSytem.Allocate( xres, yres );

        let cubeBuffer = this.mCubeBuffers[0];

        let target = this.mScreenshotSytem.GetTarget();
        this.mRenderer.SetRenderTarget( target );

        let program = this.mScreenshotSytem.GetProgram();

        this.mRenderer.AttachShader(program);
        let l1 = this.mRenderer.GetAttribLocation(program, "pos");
        this.mRenderer.SetViewport( [0, 0, xres, yres] );
        this.mRenderer.AttachTextures(1, cubeBuffer.mTexture[ cubeBuffer.mLastRenderDone ], null, null, null);
        this.mRenderer.DrawUnitQuad_XY(l1);
        this.mRenderer.DettachTextures();
        this.mRenderer.SetRenderTarget( null );

        let data = new Float32Array(xres*yres*4);
        this.mRenderer.GetPixelDataRenderTarget( target, data, xres, yres );

        let blob = piExportToEXR(xres, yres, 3, "Float", data );
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "sound" )
    {
        let offset = 0;
        const bits = 16;
        const numChannels = 2;
        let words = new Int16Array(60*pass.mSampleRate*numChannels );

        pass.iRenderSound( new Date(), function(off, data, numSamples)
                                         {
                                            for( let i=0; i<numSamples; i++ )
                                            {
                                                words[offset++] = (data[4*i+0]+256.0*data[4*i+1]) - 32767;
                                                words[offset++] = (data[4*i+2]+256.0*data[4*i+3]) - 32767;
                                            }
                                         }
                                     );

        let blob = piExportToWAV( 60*pass.mSampleRate, pass.mSampleRate, bits, numChannels, words);

        piTriggerDownload("sound.wav", blob);
    }    
}

Effect.prototype.ResizeBuffers = function(xres, yres)
{
    for (let i=0; i<this.mMaxBuffers; i++ )
    {
        this.ResizeBuffer(i, xres, yres, true);
    }
}

Effect.prototype.IsEnabledVR = function ()
{
    if (this.mRenderingStereo) return true;
    return false;
}

Effect.prototype.EnableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( this.mRenderingStereo ) return;

    this.mRenderingStereo = true;
    this.mWebVR.Enable();
}

Effect.prototype.DisableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( !this.mRenderingStereo ) return;

    this.mRenderingStereo = false;
    this.mWebVR.Disable();
}

Effect.prototype.GetTexture = function( passid, slot ) { return this.mPasses[passid].GetTexture( slot ); }
Effect.prototype.NewTexture = function (passid, slot, url) { return this.mPasses[passid].NewTexture( this.mAudioContext, slot, url, this.mBuffers, this.mCubeBuffers, this.mKeyboard ); }
Effect.prototype.SetOutputs = function( passid, slot, url ) { this.mPasses[passid].SetOutputs( slot, url ); }
Effect.prototype.SetOutputsByBufferID = function( passid, slot, id ) { this.mPasses[passid].SetOutputsByBufferID( slot, id ); }
Effect.prototype.GetAcceptsLinear = function (passid, slot) { return this.mPasses[passid].GetAcceptsLinear(slot); }
Effect.prototype.GetAcceptsMipmapping = function (passid, slot) { return this.mPasses[passid].GetAcceptsMipmapping(slot); }
Effect.prototype.GetAcceptsWrapRepeat = function (passid, slot) { return this.mPasses[passid].GetAcceptsWrapRepeat(slot); }
Effect.prototype.GetAcceptsVFlip = function (passid, slot) { return this.mPasses[passid].GetAcceptsVFlip(slot); }
Effect.prototype.SetSamplerFilter = function (passid, slot, str) { this.mPasses[passid].SetSamplerFilter(slot, str, this.mBuffers, this.mCubeBuffers); }
Effect.prototype.GetTranslatedShaderSource = function (passid) { return this.mPasses[passid].GetTranslatedShaderSource(); }
Effect.prototype.GetSamplerFilter = function (passid, slot) { return this.mPasses[passid].GetSamplerFilter(slot); }
Effect.prototype.SetSamplerWrap = function (passid, slot, str) { this.mPasses[passid].SetSamplerWrap(slot, str, this.mBuffers); }
Effect.prototype.GetSamplerWrap = function (passid, slot) { return this.mPasses[passid].GetSamplerWrap(slot); }
Effect.prototype.SetSamplerVFlip = function (passid, slot, str) { this.mPasses[passid].SetSamplerVFlip(slot, str); }
Effect.prototype.GetSamplerVFlip = function (passid, slot) { return this.mPasses[passid].GetSamplerVFlip(slot); }

Effect.prototype.GetHeaderSize = function (passid)
{
    return this.mPasses[passid].mHeaderLength + 
           this.mRenderer.GetShaderHeaderLines(1);
}

Effect.prototype.ToggleVolume = function()
{
    this.mForceMuted = !this.mForceMuted;

    // outp
    if (this.mForceMuted)
        this.mGainNode.gain.value = 0.0;
    else
        this.mGainNode.gain.value = 1.0;

    // inp
    let num = this.mPasses.length;
    for( let j=0; j<num; j++ )
    {
        for( let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            if( this.mForceMuted )
                this.mPasses[j].MuteInput( this.mAudioContext, i );
            else
                this.mPasses[j].UnMuteInput( this.mAudioContext, i );
        }
    }

    return this.mForceMuted;
}

Effect.prototype.SetKeyDown = function( passid, k )
{
    if( this.mKeyboard.mData[ k + 0*256 ] == 255 ) return;

    this.mKeyboard.mData[ k + 0*256 ] = 255;
    this.mKeyboard.mData[ k + 1*256 ] = 255;
    this.mKeyboard.mData[ k + 2*256 ] = 255 - this.mKeyboard.mData[ k + 2*256 ];
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }
}

Effect.prototype.SetKeyUp = function( passid, k )
{
    this.mKeyboard.mData[ k + 0*256 ] = 0;
    this.mKeyboard.mData[ k + 1*256 ] = 0;
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }
}

Effect.prototype.StopOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].StopOutput( wa );
    }
}

Effect.prototype.ResumeOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].ResumeOutput( wa );
    }
}

Effect.prototype.PauseInput = function( passid, id )
{
    return this.mPasses[passid].TooglePauseInput( this.mAudioContext, id );
}

Effect.prototype.ToggleMuteInput = function( passid, id )
{
    return this.mPasses[passid].ToggleMuteInput( this.mAudioContext, id );
}

Effect.prototype.RewindInput = function( passid, id )
{
    this.mPasses[passid].RewindInput( this.mAudioContext, id );
}

Effect.prototype.UpdateInputs = function( passid, forceUpdate )
{
   this.mPasses[passid].UpdateInputs( this.mAudioContext, forceUpdate, this.mKeyboard );
}

Effect.prototype.ResetTime = function()
{
    this.mFrame = 0;
    this.mAudioContext.resume()

    let num = this.mPasses.length;
    for( let i=0; i<num; i++ )
    {
        this.mPasses[i].mFrame = 0;
        for( let j=0; j<this.mPasses[i].mInputs.length; j++ )
            this.mPasses[i].RewindInput(this.mAudioContext, j)
    }
}

Effect.prototype.RequestAnimationFrame = function (id)
{
    if (this.mRenderingStereo && this.mWebVR.IsPresenting())
    {
        this.mWebVR.RequestAnimationFrame(id);
    }
    else
    {
        requestAnimFrame(id);
    }
}

Effect.prototype.Paint = function(time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, isPaused)
{
    let wa = this.mAudioContext;
    let da = new Date();
    let vrData = null; if (this.mRenderingStereo) vrData = this.mWebVR.GetData();
    let xres = this.mXres / 1;
    let yres = this.mYres / 1;

    if( this.mFrame===0 )
    {
        for( let i=0; i<this.mMaxBuffers; i++ )
        {
            if( this.mBuffers[i].mTexture[0]!==null )
            {
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[0] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[1] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
				
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[0] );
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[1] );
            }
        }
        for( let i=0; i<this.mMaxCubeBuffers; i++ )
        {
            if( this.mCubeBuffers[i].mTexture[0]!==null )
            {
                for( let face=0; face<6; face++ )
                {
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[0], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[1], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
					this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[0] );
				    this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[1] );
                }
            }
        }
    }

    let num = this.mPasses.length;

    // render sound first
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "sound" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "buffer" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;
        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="buffer" && inp.id === bufferID && inp.mInfo.mSampler.filter === "mipmap")
                {
                    needMipMaps = true;
                    break;
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render cubemap buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "cubemap" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = 0;//assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;

        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="cubemap" )
                {
                    if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0 && inp.mInfo.mSampler.filter === "mipmap" )
                    {
                        needMipMaps = true;
                        break;
                    }
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render image last
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "image" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }   

    // erase keypresses
    for (let k=0; k<256; k++ )
    {
       this.mKeyboard.mData[ k + 1*256 ] = 0;
    }
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    if( this.mRenderingStereo ) this.mWebVR.Finish();

    this.mFrame++;
}

Effect.prototype.NewShader = function( passid, preventCache, onResolve )
{
    let commonSourceCodes = [];
    for (let i=0; i<this.mPasses.length; i++ )
    {
        if( this.mPasses[i].mType==="common")
        {
            commonSourceCodes.push(this.mPasses[i].mSource);
        }
    }

    this.mPasses[passid].NewShader(commonSourceCodes, preventCache, onResolve );
}

Effect.prototype.GetNumPasses = function()
{
    return this.mPasses.length;
}

Effect.prototype.GetNumOfType = function(passtype)
{
    let id = 0;
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType===passtype )
        {
            id++;
        }
    }
    return id;
}

Effect.prototype.GetPassType = function( id ) { return this.mPasses[id].mType; }
Effect.prototype.GetPassName = function( id ) { return this.mPasses[id].mName; }
Effect.prototype.GetCode = function( id ) { return this.mPasses[id].mSource; }
Effect.prototype.SetCode = function( id, source ) { this.mPasses[id].SetCode(source); }
Effect.prototype.GetError = function (id) { return this.mPasses[id].mError; }
Effect.prototype.GetErrorStr = function (id) { return this.mPasses[id].mErrorStr; }
Effect.prototype.GetErrorGlobal = function()
{
    for (let i = 0; i < this.mPasses.length; i++)
    {
        if (this.mPasses[i].mError)
        {
            return true;
        }
    }
    return false;
}

Effect.prototype.Load = function (jobj )
{
    if (jobj.ver !== "0.1")
    {
        console.log("Wrong Format");
        return false;
    }

    let numPasses = jobj.renderpass.length;

    if( numPasses<1 || numPasses>this.mMaxPasses )
    {
        console.log("Corrupted Shader - " + numPasses);
        return false;
    }

    this.mPasses = [];
    for (let j = 0; j < numPasses; j++)
    {
        let rpass = jobj.renderpass[j];

        // skip sound passes if in thumbnail mode
        if( this.mForceMuted && rpass.type === "sound" ) continue;

        let wpass = new EffectPass(this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                   this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode,
                                   this.mProgramDownscale, j, this);

        wpass.Create(rpass.type, this.mAudioContext);

        let numInputs = rpass.inputs.length;

        for (let i = 0; i < 4; i++)
        {
            wpass.NewTexture(this.mAudioContext, i, null, null, null);
        }
        for (let i = 0; i < numInputs; i++)
        {
            let lid  = rpass.inputs[i].channel;
            let styp = rpass.inputs[i].type;
            let sid  = rpass.inputs[i].id;
            let ssrc = rpass.inputs[i].filepath;
            let psrc = rpass.inputs[i].previewfilepath;
            let samp = rpass.inputs[i].sampler;

            wpass.NewTexture(this.mAudioContext, lid, { mType: styp, mID: sid, mSrc: ssrc, mSampler: samp, mPreviewSrc: psrc }, this.mBuffers, this.mCubeBuffers, this.mKeyboard);
        }

        for (let i = 0; i < 4; i++)
        {
            wpass.SetOutputs(i, null);
        }

        let numOutputs = rpass.outputs.length;
        for (let i = 0; i < numOutputs; i++)
        {
            let outputID = rpass.outputs[i].id;
            let outputCH = rpass.outputs[i].channel;
            wpass.SetOutputs(outputCH, outputID);
        }

        // create some hardcoded names. This should come from the DB
        let rpassName = "";
        if (rpass.type === "common" ) rpassName = "Common";
        if (rpass.type === "sound"  ) rpassName = "Sound";
        if (rpass.type === "image"  ) rpassName = "Image";
        if (rpass.type === "buffer") rpassName = "Buffer " + String.fromCharCode(65 + assetID_to_bufferID(wpass.mOutputs[0]));
        if (rpass.type === "cubemap") rpassName = "Cube A";// " + String.fromCharCode(65 + assetID_to_bufferID(this.mPasses[j].mOutputs[0]));
        wpass.SetName(rpassName);
        wpass.SetCode(rpass.code);

        this.mPasses.push(wpass);
    }
    return true;
}

Effect.prototype.CompileSome = function ( passes, preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    for (let j = 0; j < passes.length; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(passes[j], preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < me.mPasses.length; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.Compile = function (preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(j, preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < numPasses; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.GetCompilationTime = function( id )
{
    return this.mPasses[id].GetCompilationTime()/1000.0;
}
Effect.prototype.GetTotalCompilationTime = function()
{
    return this.mCompilationTime/1000.0;
}

Effect.prototype.DestroyPass = function( id )
{
   this.mPasses[id].Destroy( this.mAudioContext );
   this.mPasses.splice(id, 1);
}

Effect.prototype.AddPass = function( passType, passName, onResolve )
{
    let shaderStr = null;

    if( passType==="sound"   ) shaderStr = "vec2 mainSound( int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n}";
    if( passType==="buffer"  ) shaderStr = "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}";
    if( passType==="common"  ) shaderStr = "vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}";
    if( passType==="cubemap" ) shaderStr = "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rayDir;\n\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}";

    let id = this.GetNumPasses();
    this.mPasses[id] = new EffectPass( this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                       this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode, 
                                       this.mProgramDownscale, id, this );

    this.mPasses[id].Create( passType, this.mAudioContext );
    this.mPasses[id].SetName( passName );
    this.mPasses[id].SetCode( shaderStr );
    this.NewShader(id, false, function ()
    {
        onResolve();
    });

    return { mId : id, mShader : shaderStr };
}

// this should be removed once we have MultiPass 2.0 and passes render to arbitrary buffers
Effect.prototype.IsBufferPassUsed = function( bufferID )
{
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType !== "buffer" ) continue;
        if( this.mPasses[j].mOutputs[0] === bufferID_to_assetID(bufferID) ) return true;
    }
    return false;
}

Effect.prototype.Save = function()
{
    var result = {};

    result.ver = "0.1";

    result.renderpass = [];

    let numPasses = this.mPasses.length;
    for (let j=0; j<numPasses; j++ )
    {
        result.renderpass[j] = {};

        result.renderpass[j].outputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            let outputID = this.mPasses[j].mOutputs[i];
            if( outputID===null ) continue;
            result.renderpass[j].outputs.push( { channel: i, id: outputID } );
        }
        result.renderpass[j].inputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            if( this.mPasses[j].mInputs[i]===null ) continue;
            result.renderpass[j].inputs.push( {channel: i,
                                               type    : this.mPasses[j].mInputs[i].mInfo.mType,
                                               id      : this.mPasses[j].mInputs[i].mInfo.mID,
                                               filepath: this.mPasses[j].mInputs[i].mInfo.mSrc,
                                               sampler : this.mPasses[j].mInputs[i].mInfo.mSampler });
        }

        result.renderpass[j].code = this.mPasses[j].mSource;
        result.renderpass[j].name = this.mPasses[j].mName
        result.renderpass[j].description = "";
        result.renderpass[j].type = this.mPasses[j].mType;
    }

    result.flags = this.calcFlags();

    return result;
}

Effect.prototype.calcFlags = function ()
{
    let flagVR = false;
    let flagWebcam = false;
    let flagSoundInput = false;
    let flagSoundOutput = false;
    let flagKeyboard = false;
    let flagMultipass = false;
    let flagMusicStream = false;

    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        let pass = this.mPasses[j];

        if (pass.mType === "sound") flagSoundOutput = true;
        if (pass.mType === "buffer") flagMultipass = true;

        for (let i = 0; i < 4; i++)
        {
            if (pass.mInputs[i] === null) continue;

            if (pass.mInputs[i].mInfo.mType === "webcam") flagWebcam = true;
            else if (pass.mInputs[i].mInfo.mType === "keyboard") flagKeyboard = true;
            else if (pass.mInputs[i].mInfo.mType === "mic") flagSoundInput = true;
            else if (pass.mInputs[i].mInfo.mType === "musicstream") flagMusicStream = true;
        }

        let n1 = pass.mSource.indexOf("mainVR(");
        let n2 = pass.mSource.indexOf("mainVR (");
        if (n1 > 0 || n2 > 0) flagVR = true;
    }

    return {
        mFlagVR: flagVR,
        mFlagWebcam: flagWebcam,
        mFlagSoundInput: flagSoundInput,
        mFlagSoundOutput: flagSoundOutput,
        mFlagKeyboard: flagKeyboard,
        mFlagMultipass: flagMultipass,
        mFlagMusicStream: flagMusicStream
    };
}</script>
    <script>"use strict"

const kMaxCompileTime = 10.0;

function iReportCrash(shaderID)
{
    let req = new XMLHttpRequest();
    req.onload = function ()
    {
        let jsn = req.response;
        if (jsn === null) return;
        if (jsn.result === 0)
        {
            // yep
        }
    };
    req.open("POST", "/shadertoy", true);
    req.responseType = "json";
    req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    req.send( "s=" + shaderID + "&r=2" );
}
</script>
    <script>"use strict"

var gActive = -1;
var mShaders = [];
var gNumCanvases = 0;

function myrefresh( id, slot, img, forceFrame, gui, guiID, renderID, time )
{
    if( mShaders[id].mReady===false ) return;
    if( forceFrame )
    {
        if (mShaders[id].mScreenshot === false)
        {
            mShaders[id].gEffect.Paint(mShaders[id].mTime / 1000.0, 1.0 / 60.0, 60.0, 0, 0, 0, 0, false);
        }
    }
}

function startRendering()
{
    if( gActive<0 ) return;
    if( mShaders[gActive].mReady===false ) return;
    if( mShaders[gActive].mScreenshot===true ) return;

    let time = getRealTime();

    mShaders[gActive].mFPS.Count( time );
    mShaders[gActive].mTime = mShaders[gActive].mTime0 + (time - mShaders[gActive].mTo);
    let dtime = 1000.0/60.0;
    mShaders[gActive].gEffect.Paint( mShaders[gActive].mTime/1000.0, dtime/1000.0, mShaders[gActive].mFPS.GetFPS(), 0,0,0,0, false);

    requestAnimFrame( startRendering );
}

function iLoadAndCompile(jsn, i )
{
    var shaderObj = jsn[i];
    if (shaderObj === null) return;

    var resizeCB = function (xres, yres) { myrefresh(i, 0, null, true, false, 0, -1.0) };
    var crashCB = function () { alert('crash');/*iReportCrash(gShaderIDs[i])*/ };
    mShaders[i].gEffect = new Effect(null, null, mShaders[i].mPreview.mCanvas, myrefresh, i, true, true, resizeCB, crashCB);

    if (!mShaders[i].gEffect.Load(shaderObj)) return;

    mShaders[i].gEffect.Compile(false, function (worked)
    {
        if (worked === true)
        {
            previewShowRender(mShaders[i].mPreview);

            mShaders[i].mScreenshot = false;
            mShaders[i].mReady = true;
            mShaders[i].mTime = 10.0 * 1000.0;
            mShaders[i].mTime0 = 0.0;
            mShaders[i].mTo = 0.0;
            mShaders[i].mFPS = piCreateFPSCounter();
            mShaders[i].mPreview.mCanvas.addEventListener("mouseout", function (ev) { gActive = -1; }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseover", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.add('isVisible'); }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseout", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.remove('isVisible'); }, true);
            mShaders[i].mPreview.mCanvas.addEventListener("mouseover", function (ev)
            {
                let ele = piGetSourceElement(ev);
                if (ele.mId === undefined) return;

                gActive = ele.mId;
                if (!mShaders[gActive].mReady) return;
                let time = getRealTime();
                mShaders[gActive].mTo = time;
                mShaders[gActive].mTime0 = mShaders[gActive].mTime;
                mShaders[gActive].mFPS.Reset(time);

                startRendering();
            }, true);


            /*
            let compilationTime = mShaders[i].gEffect.GetTotalCompilationTime();
            if (compilationTime > kMaxCompileTime)
            {
                iReportCrash(mShaders[i].mShaderID);
            }*/

            myrefresh(i, null, null, true, false, 0, -1.0);
        }
        else
        {
            mShaders[i].mReady = false;
            previewShowError(mShaders[i].mPreview);
        }
    });
};


function iProcessShader( jsn, i )
{
    var shaderObj = jsn[i];
    if( shaderObj===null ) return;

    if ((shaderObj.info.usePreview === 0 && !gUseScreenshots) || (mShaders[i].mPreviewReady !== 1))
    {
        iLoadAndCompile(jsn, i);
    }
    else
    {
        mShaders[i].mScreenshot = true;
        if( shaderObj.info.usePreview === 1 )
            previewShowScreenshot(mShaders[i].mPreview, 1); // comp
        else if (gUseScreenshots)
            previewShowScreenshot(mShaders[i].mPreview, 2); // sett
    }

    if( i<(jsn.length-1) ) setTimeout( function(){iProcessShader(jsn,i+1);}, 10 );
}

function iInitUI(numCanvases, uiCallback, windowTitle)
{
    gNumCanvases = numCanvases;
    document.getElementById("mySearch").focus();

    //-----------------------------------------------------------------
    // window
    //-----------------------------------------------------------------
    if (windowTitle !== null) {
        document.title = windowTitle;
    }

    //-----------------------------------------------------------------
    // ui
    //-----------------------------------------------------------------
    var num = Math.min(gShaders.length, gNumCanvases);

    //var base = document.getElementsByClassName( "searchResult" );

    for (let i = 0; i < gNumCanvases; i++)
    {
        let pv = createPreview(i);

        if (i >= num) {
            previewHide(pv);
            continue;
        }

        let shaderID = gShaders[i].info.id;
        
        if (pv.mUI !== null && uiCallback !== null) {
            pv.mUI.addEventListener('click', function (ev) {
                uiCallback(shaderID);
                ev.preventDefault();
            }, false);
        }
        
        previewShowLoading(pv);
        
        mShaders[i] = {};
        mShaders[i].mShaderID = shaderID;
        mShaders[i].mPreview = pv;
        mShaders[i].mScreenshot = false;
        mShaders[i].mPreview.mLink.href = "/view/" + shaderID;
        mShaders[i].mPreviewReady = 0;
        mShaders[i].mReady = false;
        mShaders[i].gEffect = null;

        previewLoadScreenshot(mShaders[i].mPreview,
            function () { mShaders[i].mPreviewReady = 1; if (mShaders[i].mReady === false) previewShowScreenshot(mShaders[i].mPreview, 0); },
            function () { mShaders[i].mPreviewReady = 2; },
            shaderID);
    }

    if (num <= 0) {
        return;
    }
}

function iInitShaders(jsn)
{
    for (let i = 0; i < jsn.length; i++)
    {
        let shaderObj = jsn[i];
        if (shaderObj === null) continue;
        let inf = shaderObj.info;
        mShaders[i].mPreview.mTextA.textContent = inf.name;
        mShaders[i].mPreview.mTextB.innerHTML = "<a class='user' href='/user/" + htmlEntities(inf.username) + "'>" + htmlEntities(inf.username) + "</a>";
        mShaders[i].mPreview.mTextC.innerHTML = "<img src='/img/themes/" + gThemeName + "/views.png' class='viewsIcon'></img>" + inf.viewed + "    &nbsp;&nbsp;  <img src='/img/themes/" + gThemeName + "/likes.png' class='likesIcon'></img>" + inf.likes;
    }

    setTimeout(function () { iProcessShader(jsn, 0); }, 10);
}

function resultsInitStatic(numCanvases, uiCallback, windowTitle)
{
    iInitUI(numCanvases, uiCallback, windowTitle);

    iInitShaders(gShaders);
}

function resultsInit(numCanvases, uiCallback, windowTitle)
{	
    iInitUI(numCanvases, uiCallback, windowTitle);

    var num = Math.min(gShaderIDs.length, gNumCanvases);

    var mHttpReq = new XMLHttpRequest();

    mHttpReq.abort();

    var str = "{ \"shaders\" : [";
    for( let i=0; i<num; i++ )
    {
         str += "\"" + gShaderIDs[i] + "\"";
         if( i!==(num-1) ) str += ", ";
    }
    str += "] }";

    str = "s=" + encodeURIComponent( str ) + "&nt=0&nl=0&np=0";

    mHttpReq.open( "POST", "/shadertoy", true );
    mHttpReq.responseType = "json";
    mHttpReq.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    mHttpReq.onload = function ()
    {
        let jsn = this.response;
        if( jsn===null )
        {
            console.log( "Could not load shaders" );
            return;
        }

        iInitShaders(jsn);
    }
    mHttpReq.send( str );
}</script>
    <style>
    .shaderPreview
    {
    display: block;
    background-color: #000000;
    background-image: url("/img/loading.gif");
    background-repeat: no-repeat;
    background-position: center;
    padding: 0px;
    margin: 0px;
    border: 0px solid #000000;
    border-radius: 8px;
    width:100%;
    height:100%;
    position: absolute;
    overflow:hidden;
    }

    .previewInfo
    {
    width: 100%;
    left: 0px;
    top: 2px;
    position: relative;
    visibility: hidden;
    }

    .previewCanvas
    {
    left: 0px;
    top: 0px;
    padding: 0px;
    margin: 0px;
    position: absolute;
    cursor: pointer;
    width:100%;
    height:100%;
    border-radius: 8px;
    border: 0px solid #000000;
    backgroundColor: transparent;
visibility: hidden;
opacity:0;
transition: opacity 1.0s ease;
    }

    .previewText
    {
        text-overflow: ellipsis;
    white-space: nowrap;
    padding-right: 1px;
    }

    .previewTextUser
    {
    text-overflow: ellipsis;
    white-space: nowrap;
    padding-left: 3px;
    }

    .previewStats
    {
    padding-right: 1px;
    right: 0px;
    top: 0px;
    position: absolute;
    }

    .previewErrorContainer
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    visibility:hidden;
    }

    .previewErrorMessage
    {
    top:50%;
    position:absolute;
    width:100%;
    text-align:center;
    padding:0;
    margin:auto;
    color:#ff0000;
    font-size:2em;
    font-style:italic;
    }

    .previewNoGLContainter
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    position:absolute;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    pointer-events:none;
    visibility:hidden;
    font-size:2em;
    }

    .previewNoGLMessage
    {
    width:86%;
    height:90%;
    padding-left:7%;
    padding-right:7%;
    padding-top:10%;
    padding-bottom:0px;
    color:#ff0000;
    position:absolute;
    visibility:hidden;
    }

    .previewThumbnailContainer
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    visibility:hidden;
    border-radius:8px;
    border:0px solid #000000;
    }

    .previewThumbnailImage
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    border-radius:8px;
    border:0px solid #000000;
opacity: 0.0;
transition: opacity 1.0s ease;
    }

    .previewThumbnailIcon
    {
    width:64px;
    height:32px;
    left:0px;
    top:0px;
    padding:0px;
    padding-top:12px;
    margin:0px;
    position:absolute;
    color:#ffffff;
    background-color:#ff8020;
    font-weight:bold;
    border-radius:0px 0px 8px 0px;
    text-align:center;
    //visibility:hidden;
    }


    .previewUIContainter
    {
    display: block;
    right:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    //cursor:pointer;
    //pointer-events:none;
    //visibility:hidden;
    }
</style>

<script>
    function previewHide(me)
    {
    me.mBase.style.visibility = "hidden";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";
    }

    function previewShowRender(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "visible";
me.mCanvas.style.opacity = 1.0;
    me.mCanvas.style.borderRadius ="8px;";
//  me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    }

    function previewShowScreenshot(me, message)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "visible";
me.mThumbnailImg.style.opacity = 1.0;
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    me.mThumbnailWar1.style.visibility = (message===1)?"visible":"hidden";
    me.mThumbnailWar2.style.visibility = (message===2)?"visible":"hidden";
    }

    function previewShowLoading(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";

    me.mLink.style.visibility = "visible";
    me.mBase.style.backgroundColor = "#ff0000;"
    me.mCont.style.visibility = "visible";
    }

    function previewShowNoWebGL(me, shaderID)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "visible";
    me.mError.style.visibility = "visible";
    me.mThumbnailImgNoWebGL.onerror = function(ev) 
                                      { 
                                            me.mThumbnailImgNoWebGL.style.visibility="hidden"; 
                                            me.mMessageNoWebGL.style.visibility="visible"; 
                                      };
    me.mThumbnailImgNoWebGL.src = "/media/shaders/" + shaderID + ".jpg";
    }

    function previewShowError(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "visible";
    me.mCont.style.visibility = "visible";
    }

    function previewLoadScreenshot( me, cbSuccess, cbError, shaderID )
    {
    var url = "/media/shaders/" + shaderID + ".jpg";
    me.mThumbnailImg.onload = cbSuccess;
    me.mThumbnailImg.onerror = function(ev) { cbError(); };
    me.mThumbnailImg.src = url;
    }
        
    function createPreview(id)
    {
        var bar = document.getElementById( "Preview_"+id+"_Canvas" );
        bar.width = bar.offsetWidth;
        bar.height = bar.offsetHeight;
        bar.mId = id;

        return { mBase: document.getElementById( "Preview_"+id+"_Container" ),
        mLink: document.getElementById( "Preview_"+id+"_Link" ),
        mCanvas: bar,
        mCont: document.getElementById( "Preview_"+id+"_Info" ),
        mTextA: document.getElementById( "Preview_"+id+"_Text" ),
        mTextB: document.getElementById( "Preview_"+id+"_TextUser" ),
        mTextC: document.getElementById( "Preview_"+id+"_Stats" ),
        mNoWebGL: document.getElementById( "Preview_"+id+"_NoWebGL" ),
        mError: document.getElementById( "Preview_"+id+"_Error" ),
        mCanvas2D: document.getElementById( "Preview_"+id+"_Thumnail" ),
        mThumbnailImg: document.getElementById( "Preview_"+id+"_ThumnailImage" ),
        mThumbnailWar1: document.getElementById( "Preview_"+id+"_ThumnailWarning1" ),
        mThumbnailWar2: document.getElementById( "Preview_"+id+"_ThumnailWarning2" ),
        mThumbnailImgNoWebGL: document.getElementById( "Preview_"+id+"_ThumnailImageNoWebGL" ),
        mMessageNoWebGL: document.getElementById( "Preview_"+id+"_MessageNoWebGL"),
        mUI: document.getElementById( "Preview_"+id+"_UI" )
        };
    }
</script>

    <style>

    div#shaderGrid
    {
        width:100%;
        padding:0px;
        margin:0px;
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        grid-template-rows: repeat(3, 1fr);
        grid-column-gap: 64px;
        grid-row-gap: 24px;
    }
    .searchResult
    {
        margin: 0px;
        padding: 0px;
        width: 100%;
    }
    .searchResultContainer
    {
        width: 100%;
        padding-bottom:56.25%;
        height: 0;
        position: relative;
    }
    .navigation
    {
        display:flex;
        align-items:center;
    }
    div#navBottom
    {
        display:none;
        justify-content:center;
    }
    a.pageButtons, .pageButtonsCurrent
    {
        border-style: solid;
        border-width: 1px;
        border-color: #808080;
        text-align: center;
        vertical-align: middle;
        margin-left: 12px;
        display: inline-block;
        border-radius: 4px;
		font-weight:bold;
        cursor: pointer;
        padding-bottom:5px;
        padding-top:4px;
        padding-left: 8px;
        padding-right: 8px;
        margin:8px;
    }
    a.pageButtons
    {
        text-decoration: none;
        -moz-transition:    background-color 0.15s linear, color 0.15s linear;
        -webkit-transition: background-color 0.15s linear, color 0.15s linear;
        transition:         background-color 0.15s linear, color 0.15s linear;
    }
    a.pageButtons:hover
    {
      background-color:#808080;
      color : #ff8020;
    }
    .pageButtonsCurrent
    {
        background-color: #808080;
        color:#000000;
    }
    div#controls
    {
        width:100%;
        padding-top:16px;
        padding-bottom:16px;
        display:flex;
        justify-content:space-between; 
        flex-wrap:wrap;
    }
    div#controls > div
    {
        display:inline-flex;
    }
    .controlOptions
    {
        display:inline-block;
    }

    /* ----------------------- media resolutions ------------------------ */

    @media screen and (max-width:799px) 
    {
        div#shaderGrid  { grid-template-columns: 1fr; grid-template-rows: repeat(12, 1fr); grid-column-gap: 0px; grid-row-gap: 16px; }
        div#controls
        {
            width:100%;
            display:flex;
            justify-content:flex-start; 
            flex-wrap:wrap;
        }
        div#controls > div
        {
            display:inline-flex;
            width:100%;
            margin-left: 0px;
            margin-right: 0px;
            padding-bottom:16px;
        }
        div#navBottom
        {
            display: flex;
        }
    }
    
    </style>
    <script>
    var gShaders=[{"ver":"0.1","info":{"id":"MttGz4","date":"1468711886","viewed":9545,"name":"[SH16B] Mach 1","username":"P_Malin","description":"Thrust SSC (SuperSonic Car)\nhttps:\/\/en.wikipedia.org\/wiki\/ThrustSSC\nFirst car to officially break the sound barrier.\n\nYoutube video here: https:\/\/www.youtube.com\/watch?v=hliTD0YGq1Q","likes":109,"published":3,"flags":41,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"\/media\/a\/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"\/media\/ap\/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"\/media\/previz\/buffer03.png","previewfilepath":"\/media\/previz\/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ PostFX\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec3 PostFX_ApplyVignetting( const in vec2 vUV, const in vec3 vInput, float fStrength )\n{\n\tvec2 vOffset = (vUV - 0.5) * sqrt(2.0);\n\t\n\tfloat fDist = dot(vOffset, vOffset);\n\t\n\tfloat fShade = mix( 1.0, 1.0 - fStrength, fDist );\t\n\n\treturn vInput * fShade;\n}\n\nvec3 PostFX_ApplyTonemap( const in vec3 vLinear, float fExposure )\n{\n\treturn 1.0 - exp2( vLinear * -fExposure );\t\n}\n\nvec3 PostFX_ApplyGamma( const in vec3 vLinear, float fGamma )\n{\n\treturn pow( vLinear, vec3(1.0\/fGamma) );\t\n}\n\nvec3 PostFX_Apply( vec3 vColor, vec2 vUV, float fExposure, float fVignetteStrength, float fGamma )\n{\n    vColor = PostFX_ApplyVignetting( vUV, vColor, fVignetteStrength );\n    vColor = PostFX_ApplyTonemap( vColor, fExposure );\n    vColor = PostFX_ApplyGamma( vColor, fGamma );\n    return vColor;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nfloat Blueprint_Grid( vec2 vGridUV, float fSpacing )\n{   \n    vec2 vScaledUV = vGridUV * fSpacing;\n    \n    vec2 vGridLinePos = fract( vScaledUV - 0.5 ) - 0.5;\n    \n    vec2 vToLine = abs(vGridLinePos) \/ fSpacing;\n    \n    float fAmount = min( vToLine.x, vToLine.y );\n    \n    fAmount = 1.0 - fAmount * 400.0;\n    \n    return clamp( fAmount, 0.0, 1.0);\n}\n\nfloat Blueprint_SampleDepth( vec2 vUV )\n{\n    return min( textureLod( iChannel0, vUV, 0.0 ).a, 10.0 );\n}\n\nvec3 Blueprint( const vec2 vUV )\n{\n    vec3 vColor = vec3(1.0);\n    \n    vec2 vPixelSize = 1.0 \/ iResolution.xy;\n    vec3 vDelta = vec3( -1.0, 0.0, 1.0 );\n    \n\tfloat fSample_tl = Blueprint_SampleDepth( vUV + vDelta.xx * vPixelSize );\n\tfloat fSample_tc = Blueprint_SampleDepth( vUV + vDelta.xy * vPixelSize );\n\tfloat fSample_tr = Blueprint_SampleDepth( vUV + vDelta.xz * vPixelSize );\n    \n\tfloat fSample_cl = Blueprint_SampleDepth( vUV + vDelta.yx * vPixelSize );\n\tfloat fSample_cc = Blueprint_SampleDepth( vUV + vDelta.yy * vPixelSize );\n\tfloat fSample_cr = Blueprint_SampleDepth( vUV + vDelta.yz * vPixelSize );\n\n    float fSample_bl = Blueprint_SampleDepth( vUV + vDelta.zx * vPixelSize );\n\tfloat fSample_bc = Blueprint_SampleDepth( vUV + vDelta.zy * vPixelSize );\n\tfloat fSample_br = Blueprint_SampleDepth( vUV + vDelta.zz * vPixelSize );\n    \n    vec2 edge;\n    edge.x = fSample_tl * -1.0 + fSample_tr * 1.0\n    \t \t + fSample_cl * -2.0 + fSample_cr * 2.0\n        \t + fSample_bl * -1.0 + fSample_br * 1.0;\n    \n    edge.y = fSample_tl * -1.0 + fSample_tc * -2.0 + fSample_tr * -1.0\n        \t + fSample_bl *  1.0 + fSample_bc * 2.0 + fSample_br * 1.0;\n    \n    float amount = clamp( (sqrt(length(edge))- 1.5) * 2.0 , 0.0, 1.0);\n\n    vec2 vGridUV = vUV;\n    vGridUV.x *= iResolution.x \/ iResolution.y;\n    amount += Blueprint_Grid(vGridUV, 8.0) * 0.2;\n    amount += Blueprint_Grid(vGridUV, 16.0) * 0.05;\n    amount += Blueprint_Grid(vGridUV, 80.0) * 0.05;\n    \n    vColor = mix( vec3(0.1,0.1,.25), vec3(.9,1,1), amount );\n    \n    return vColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 gBloomSize = min( vec2(320.0, 240.0), iChannelResolution[1].xy );\n    \n\tvec2 vUV = fragCoord.xy \/ iResolution.xy;\n\n    \/\/ Show environment map\n\t\/\/fragColor = texture( iChannel3, vUV ).rgba; return;    \n    \n    \/\/ Show raw scene render\n\t\/\/fragColor = texture( iChannel0, vUV ).rgba; return;    \n    \n    \/\/ Show bloom buffer\n    \/\/fragColor = texture( iChannel1, vUV ).rgba; return;    \n    \n\tvec4 vImageSample = textureLod( iChannel0, vUV, 0.0 ).rgba;\n\tvec4 vBloomSample = textureLod( iChannel1, vUV * gBloomSize \/ iResolution.xy, 0.0 ).rgba;\n\n    const float fBloomAmount = 0.2;\n    \n    vec3 vResult = mix( vImageSample.rgb, vBloomSample.rgb, fBloomAmount );\n    \n    vResult += textureLod( iChannel1, (0.5 + (vUV - 0.5) * 0.6) * gBloomSize \/ iResolution.xy, 0.0 ).rgb * 0.00015 * vec3(1,1,0);\n    \n    vResult += textureLod( iChannel1, (0.5 + (vUV - 0.5) * -0.5) * gBloomSize \/ iResolution.xy, 0.0 ).rgb * 0.0015 * vec3(1,0,0);\n    vResult += textureLod( iChannel1, (0.5 + (vUV - 0.5) * -0.525) * gBloomSize \/ iResolution.xy, 0.0 ).rgb * 0.0015 * vec3(0,1,0);\n    vResult += textureLod( iChannel1, (0.5 + (vUV - 0.5) * -0.55) * gBloomSize \/ iResolution.xy, 0.0 ).rgb * 0.0015 * vec3(0,0,1);\n\n    float fExposure = 3.0;\n    \n    float fBlend = clamp( (iTime - 64.0) * 0.1 , 0.0, 1.0 );\n    if ( iTime > 78.0 )\n    {\n        fBlend = 0.0;\n    }\n    fExposure *= 1.0 - fBlend;\n\n    vec3 vFinal = PostFX_Apply( vResult.rgb, vUV, fExposure, 0.9, 1.2 );   \n    \n    vec3 vBlueprintScene = vec3(0);\n    \n    {\n        vec2 vSceneUV = vUV; \n\n        vSceneUV -= 0.5;\n\t\tvSceneUV.x *= iResolution.x \/ iResolution.y;\n\n        vSceneUV *= 1.2;\n        float p = 0.1;\n        vSceneUV *= mat2( cos(p), sin(p), -sin(p), cos(p) );\n        \n        vSceneUV *= (0.3 + exp2( iTime) * 0.03) ;\n        \n        vSceneUV += 0.5;\n        \n        vec2 vPageUV = vSceneUV;        \n        \/\/float t = 0.1;\n        \/\/vPageUV -= 0.5;\n        \/\/vPageUV *= mat2( cos(t), sin(t), -sin(t), cos(t) );\n        \/\/vPageUV += 0.5;\n        \/\/vPageUV.x += sin(iTime);\n\n        vPageUV -= 0.5;\n\t\tvPageUV.x \/= iResolution.x \/ iResolution.y;\n        vPageUV += 0.5;        \n        \n        if ( any( greaterThan( vPageUV, vec2(1))) || any( lessThanEqual( vPageUV, vec2(0))) )\n        {\n            vBlueprintScene.rgb = textureLod( iChannel2, vSceneUV, 0.0 ).rgb;\n            vBlueprintScene.rgb *= textureLod( iChannel2, vSceneUV * 0.01, 0.0 ).rgb;\n            vBlueprintScene.rgb = sqrt( vBlueprintScene.rgb );\n            \n            vec2 vShadowPos = vPageUV + vec2(-0.001, 0.05);\n            vec2 vClosest = clamp( vShadowPos, vec2(0), vec2(1) );\n            float fDist = length( vClosest - vShadowPos );\n            vBlueprintScene.rgb *= clamp( fDist * 30.0, 0.0, 1.0) * 0.5 + 0.5;\n        }\n        else\n        {\n            vBlueprintScene = Blueprint( vPageUV );\n        }\n    }\n\n    float fBlueprint = step(iTime, 8.0);\/\/step( 0.5, fract( (vUV.x + vUV.y * .5) * 0.1 + iTime ) ) ;\n    vFinal.rgb = mix( vFinal, vBlueprintScene, fBlueprint);\n\n    \/\/ Draw depth\n    \/\/vFinal = vec3( 1.0 - exp2( abs(vImageSample.a) * -0.02 ) ); \n    \n\tfragColor = vec4(vFinal, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGRn","filepath":"\/media\/a\/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"\/media\/ap\/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRn","filepath":"\/media\/a\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"\/media\/ap\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"\/media\/a\/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"\/media\/ap\/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\/\/ Scene Render\n\n\/\/ This buffer was used like an environment map before shadertoy added cubemap support\n#if 0\n\n#define kMaxTraceDist 1000.0\n#define kFarDist 1100.0\n\n#define MAT_FG_BEGIN \t10.0\n\n#define PI 3.141592654\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Data Storage\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec4 LoadVec4( sampler2D sampler, in ivec2 vAddr )\n{\n    return texelFetch( sampler, vAddr, 0 );\n}\n\nvec3 LoadVec3( sampler2D sampler, in ivec2 vAddr )\n{\n    return LoadVec4( sampler, vAddr ).xyz;\n}\n\nbool AtAddress( vec2 p, vec2 c ) { return all( equal( floor(p), floor(c) ) ); }\n\nvoid StoreVec4( in vec2 vAddr, in vec4 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in vec2 vAddr, in vec3 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Camera\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nstruct CameraState\n{\n    vec3 vPos;\n    vec3 vTarget;\n    float fFov;\n};\n    \nvoid Cam_LoadState( out CameraState cam, sampler2D sampler, ivec2 addr )\n{\n    cam.vPos = LoadVec3( sampler, addr + ivec2(0,0) );\n    vec4 targetFov = LoadVec4( sampler, addr + ivec2(1,0) );\n    cam.vTarget = targetFov.xyz;\n    cam.fFov = targetFov.w;\n}\n\nvoid Cam_StoreState( vec2 addr, const in CameraState cam, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec3( addr + vec2(0,0), cam.vPos, fragColor, fragCoord );\n    StoreVec4( addr + vec2(1,0), vec4( cam.vTarget, cam.fFov ), fragColor, fragCoord );    \n}\n\nmat3 Cam_GetWorldToCameraRotMatrix( const CameraState cameraState )\n{\n    vec3 vForward = normalize( cameraState.vTarget - cameraState.vPos );\n\tvec3 vRight = normalize( cross(vec3(0, 1, 0), vForward) );\n\tvec3 vUp = normalize( cross(vForward, vRight) );\n    \n    return mat3( vRight, vUp, vForward );\n}\n\nvec2 Cam_GetViewCoordFromUV( const in vec2 vUV )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x \/ iResolution.y;\n\n\treturn vWindow;\t\n}\n\nvoid Cam_GetCameraRay( const vec2 vUV, const CameraState cam, out vec3 vRayOrigin, out vec3 vRayDir )\n{\n    vec2 vView = Cam_GetViewCoordFromUV( vUV );\n    vRayOrigin = cam.vPos;\n    float fPerspDist = 1.0 \/ tan( radians( cam.fFov ) );\n    vRayDir = normalize( Cam_GetWorldToCameraRotMatrix( cam ) * vec3( vView, fPerspDist ) );\n}\n\nvec2 Cam_GetUVFromWindowCoord( const in vec2 vWindow )\n{\n    vec2 vScaledWindow = vWindow;\n    vScaledWindow.x *= iResolution.y \/ iResolution.x;\n\n    return vScaledWindow * 0.5 + 0.5;\n}\n\nvec2 Cam_WorldToWindowCoord(const in vec3 vWorldPos, const in CameraState cameraState )\n{\n    vec3 vOffset = vWorldPos - cameraState.vPos;\n    vec3 vCameraLocal;\n\n    vCameraLocal = vOffset * Cam_GetWorldToCameraRotMatrix( cameraState );\n\t\n    vec2 vWindowPos = vCameraLocal.xy \/ (vCameraLocal.z * tan( radians( cameraState.fFov ) ));\n    \n    return vWindowPos;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Scene\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nstruct SceneResult\n{\n\tfloat fDist;\n\tfloat fObjectId;\n    vec3 vUVW;\n};\n\nSceneResult Scene_Union( const in SceneResult a, const in SceneResult b )\n{\n    if ( a.fDist < b.fDist )\n    {\n        return a;\n    }\n    return b;\n}\n    \nSceneResult Scene_Subtract( const in SceneResult a, const in SceneResult b )\n{\n    if ( -a.fDist < b.fDist )\n    {\n        return a;\n    }\n\n    SceneResult result;\n    result.fDist = -b.fDist;\n    result.fObjectId = b.fObjectId;\n    result.vUVW = b.vUVW;\n    return result;\n}\n\nSceneResult Scene_Intersection( const in SceneResult a, const in SceneResult b )\n{\n    if ( a.fDist > b.fDist )\n    {\n        return a;\n    }\n    return b;\n}\n    \nSceneResult Scene_GetDistance( const vec3 vPos );    \n\nvec3 Scene_GetNormal(const in vec3 vPos)\n{\n    const float fDelta = 0.001;\n    vec2 e = vec2( -1, 1 );\n    \n    vec3 vNormal = \n        Scene_GetDistance( vPos + e.yxx * fDelta ).fDist * e.yxx + \n        Scene_GetDistance( vPos + e.xxy * fDelta ).fDist * e.xxy + \n        Scene_GetDistance( vPos + e.xyx * fDelta ).fDist * e.xyx + \n        Scene_GetDistance( vPos + e.yyy * fDelta ).fDist * e.yyy;\n    \n    if ( dot( vNormal, vNormal ) < 0.00001 )\n    {\n        return vec3(0, 1, 0);\n    }\n    \n    return normalize( vNormal );\n}    \n    \nSceneResult Scene_Trace( const in vec3 vRayOrigin, const in vec3 vRayDir, float maxDist )\n{\t\n    SceneResult result;\n    result.fDist = 0.0;\n    result.vUVW = vec3(0.0);\n    result.fObjectId = 0.0;\n    \n\tfloat t = 0.1;\n\tconst int kRaymarchMaxIter = 128;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\t\t\n\t\tresult = Scene_GetDistance( vRayOrigin + vRayDir * t );\t\t\n        t += result.fDist;\n\n        if ( abs(result.fDist) < 0.001 )\n\t\t{\n\t\t\tbreak;\n\t\t}\t\t\n        if ( t > maxDist )\n        {\n            result.fObjectId = -1.0;\n\t        t = maxDist;\n            break;\n        }\n\t}\n    \n    result.fDist = t;\n\n    return result;\n}    \n\nfloat Scene_TraceShadow( const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fLightDist )\n{\n    \/\/return 1.0;\n    \/\/return ( Scene_Trace( vRayOrigin, vRayDir, fLightDist ).fDist < fLightDist ? 0.0 : 1.0;\n    \n    float mint = 0.02, tmax = 2.5;\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = Scene_GetDistance( vRayOrigin + vRayDir * t ).fDist;\n        res = min( res, 8.0*h\/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );    \n}\n\nfloat Scene_GetAmbientOcclusion( const in vec3 vPos, const in vec3 vDir )\n{\n    float fOcclusion = 0.0;\n    float fScale = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float fOffsetDist = 0.01 + 1.0*float(i)\/4.0;\n        vec3 vAOPos = vDir * fOffsetDist + vPos;\n        float fDist = Scene_GetDistance( vAOPos ).fDist;\n        fOcclusion += (fOffsetDist - fDist) * fScale;\n        fScale *= 0.4;\n    }\n    \n    return clamp( 1.0 - 2.0*fOcclusion, 0.0, 1.0 );\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Lighting\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \nstruct SurfaceInfo\n{\n    vec3 vPos;\n    vec3 vNormal;\n    vec3 vBumpNormal;    \n    vec3 vAlbedo;\n    vec3 vR0;\n    float fSmoothness;\n    vec3 vEmissive;\n};\n    \nSurfaceInfo Scene_GetSurfaceInfo( const in vec3 vRayOrigin,  const in vec3 vRayDir, SceneResult traceResult );\n\nstruct SurfaceLighting\n{\n    vec3 vDiffuse;\n    vec3 vSpecular;\n};\n    \nSurfaceLighting Scene_GetSurfaceLighting( const in vec3 vRayDir, in SurfaceInfo surfaceInfo );\n\nfloat Light_GIV( float dotNV, float k)\n{\n\treturn 1.0 \/ ((dotNV + 0.0001) * (1.0 - k)+k);\n}\n\nvoid Light_Add(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\n\tfloat fNDotL = clamp(dot(vLightDir, surface.vBumpNormal), 0.0, 1.0);\n\t\n\tlighting.vDiffuse += vLightColour * fNDotL;\n    \n\tvec3 vH = normalize( -vViewDir + vLightDir );\n\tfloat fNdotV = clamp(dot(-vViewDir, surface.vBumpNormal), 0.0, 1.0);\n\tfloat fNdotH = clamp(dot(surface.vBumpNormal, vH), 0.0, 1.0);\n    \n\tfloat alpha = 1.0 - surface.fSmoothness;\n\t\/\/ D\n\n\tfloat alphaSqr = alpha * alpha;\n\tfloat pi = 3.14159;\n\tfloat denom = fNdotH * fNdotH * (alphaSqr - 1.0) + 1.0;\n\tfloat d = alphaSqr \/ (pi * denom * denom);\n\n\tfloat k = alpha \/ 2.0;\n\tfloat vis = Light_GIV(fNDotL, k) * Light_GIV(fNdotV, k);\n\n\tfloat fSpecularIntensity = d * vis * fNDotL;    \n\tlighting.vSpecular += vLightColour * fSpecularIntensity;    \n}\n\nvoid Light_AddPoint(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightPos, const in vec3 vLightColour)\n{    \n    vec3 vPos = surface.vPos;\n\tvec3 vToLight = vLightPos - vPos;\t\n    \n\tvec3 vLightDir = normalize(vToLight);\n\tfloat fDistance2 = dot(vToLight, vToLight);\n\tfloat fAttenuation = 100.0 \/ (fDistance2);\n\t\n\tfloat fShadowFactor = Scene_TraceShadow( surface.vPos, vLightDir, length(vToLight) );\n\t\n\tLight_Add( lighting, surface, vViewDir, vLightDir, vLightColour * fShadowFactor * fAttenuation);\n}\n\nvoid Light_AddDirectional(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\t\n\tfloat fAttenuation = 1.0;\n\tfloat fShadowFactor = Scene_TraceShadow( surface.vPos, vLightDir, 10.0 );\n\t\n\tLight_Add( lighting, surface, vViewDir, vLightDir, vLightColour * fShadowFactor * fAttenuation);\n}\n\nvec3 Light_GetFresnel( vec3 vView, vec3 vNormal, vec3 vR0, float fGloss )\n{\n    float NdotV = max( 0.0, dot( vView, vNormal ) );\n\n    return vR0 + (vec3(1.0) - vR0) * pow( 1.0 - NdotV, 5.0 ) * pow( fGloss, 20.0 );\n}\n\nvoid Env_AddPointLightFlare(inout vec3 vEmissiveGlow, const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fIntersectDistance, const in vec3 vLightPos, const in vec3 vLightColour)\n{\n    vec3 vToLight = vLightPos - vRayOrigin;\n    float fPointDot = dot(vToLight, vRayDir);\n    fPointDot = clamp(fPointDot, 0.0, fIntersectDistance);\n\n    vec3 vClosestPoint = vRayOrigin + vRayDir * fPointDot;\n    float fDist = length(vClosestPoint - vLightPos);\n\tvEmissiveGlow += sqrt(vLightColour * 0.05 \/ (fDist * fDist));\n}\n\nvoid Env_AddDirectionalLightFlareToFog(inout vec3 vFogColour, const in vec3 vRayDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\n\tfloat fDirDot = clamp(dot(vLightDir, vRayDir) * 0.5 + 0.5, 0.0, 1.0);\n\tfloat kSpreadPower = 2.0;\n\tvFogColour += vLightColour * pow(fDirDot, kSpreadPower) * 0.25;\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Rendering\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec4 Env_GetSkyColor( const vec3 vViewPos, const vec3 vViewDir );\nvec3 Env_ApplyAtmosphere( const in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist);\nvec3 FX_Apply( in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist);\n\nvec4 Scene_GetColorAndDepth( const in vec3 vInRayOrigin, const in vec3 vInRayDir )\n{\n    vec3 vRayOrigin = vInRayOrigin;\n    vec3 vRayDir = vInRayDir;\n    \n\tvec3 vResultColor = vec3(0.0);\n\tvec3 vPassContribution = vec3(1.0);\n            \n\tSceneResult firstTraceResult;\n    \n\tfor( int iPassIndex=0; iPassIndex<3; iPassIndex++ )\n\t{\t        \n    \tSceneResult traceResult = Scene_Trace( vRayOrigin, vRayDir, kMaxTraceDist );\n        \n        if ( iPassIndex == 0 )\n        {\n            firstTraceResult = traceResult;\n        }\n        \n\t\tvec3 vPassColor = vec3(0.0);\n\t\tvec3 vReflectance = vec3(1.0);\n\n\t\tif( traceResult.fObjectId < 0.0 )\n\t\t{\n            break; \n        }\n        else\n        {\n            SurfaceInfo surfaceInfo = Scene_GetSurfaceInfo( vRayOrigin, vRayDir, traceResult );\n            SurfaceLighting surfaceLighting = Scene_GetSurfaceLighting( vRayDir, surfaceInfo );\n                \n            \/\/ calculate reflectance (Fresnel)\n            float NdotV = clamp( dot(surfaceInfo.vBumpNormal, -vRayDir), 0.0, 1.0);\n\t\t\tvReflectance = Light_GetFresnel( -vRayDir, surfaceInfo.vBumpNormal, surfaceInfo.vR0, surfaceInfo.fSmoothness );\n\t\t\t\n\t\t\tvPassColor = \n                mix( surfaceInfo.vAlbedo * surfaceLighting.vDiffuse + surfaceInfo.vEmissive, surfaceLighting.vSpecular, vReflectance );\n        \n\t        vPassColor = Env_ApplyAtmosphere( vPassColor, vRayOrigin, vRayDir, traceResult.fDist );\t\t\n            \n            \/\/ Reflect Ray\n            vRayOrigin = surfaceInfo.vPos;\n            vRayDir = normalize( reflect( vRayDir, surfaceInfo.vBumpNormal ) );\n        }\n                \n\t\tvResultColor += vPassColor * vPassContribution;\n\t\tvPassContribution *= vReflectance;\t\t\t        \n    }\n    \n    vec4 vFinalSkyColor = Env_GetSkyColor( vRayOrigin, vRayDir );\n    vFinalSkyColor.rgb = Env_ApplyAtmosphere( vFinalSkyColor.rgb, vRayOrigin, vRayDir, vFinalSkyColor.a );\t\t\n\tvResultColor += vFinalSkyColor.rgb * vPassContribution;\n    \n    vResultColor = FX_Apply( vResultColor, vInRayOrigin, vInRayDir, firstTraceResult.fDist );\n    \n    if ( firstTraceResult.fObjectId >= MAT_FG_BEGIN )\n    {\n        firstTraceResult.fDist = -firstTraceResult.fDist;\n    }\n    \n    return vec4( vResultColor, firstTraceResult.fDist );\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Utility Functions\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define MOD2 vec2(4.438975,3.972973)\n\nfloat Hash( float p ) \n{\n    \/\/ https:\/\/www.shadertoy.com\/view\/4djSRW - Dave Hoskins\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);    \n\t\/\/return fract(sin(n)*43758.5453);\n}\n\nfloat SmoothNoise(in vec2 o) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat a = Hash(n+  0.0);\n\tfloat b = Hash(n+  1.0);\n\tfloat c = Hash(n+ 57.0);\n\tfloat d = Hash(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n    return res;\n}\n\n\nvec3 SmoothNoise_DXY(in vec2 o) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat a = Hash(n+  0.0);\n\tfloat b = Hash(n+  1.0);\n\tfloat c = Hash(n+ 57.0);\n\tfloat d = Hash(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\tvec2 dt = 6.0 * f - 6.0 * f2;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\tfloat du = dt.x;\t\n\tfloat dv = dt.y;\t\n\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n\tfloat dx = (b-a)*du + (a-b+d-c)*du*v;\n\tfloat dy = (c-a)*dv + (a-b+d-c)*u*dv;    \n    \n    return vec3(dx, dy, res);\n}\n\nvec3 FBM_DXY( vec2 p, vec2 flow, float ps, float df ) {\n\tvec3 f = vec3(0.0);\n    float tot = 0.0;\n    float a = 1.0;\n    \/\/flow *= 0.6;\n    for( int i=0; i<4; i++)\n    {\n        p += flow;\n        flow *= -0.75; \/\/ modify flow for each octave - negating this is fun\n        vec3 v = SmoothNoise_DXY( p );\n        f += v * a;\n        p += v.xy * df;\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f \/ tot;\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Scene Description\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ Materials\n\n#define MAT_SKY \t\t-1.0\n#define MAT_MOUNTAIN \t0.0\n#define MAT_SAND \t\t2.0\n\nSurfaceInfo Scene_GetSurfaceInfo( const in vec3 vRayOrigin,  const in vec3 vRayDir, SceneResult traceResult )\n{\n    SurfaceInfo surfaceInfo;\n    \n    surfaceInfo.vPos = vRayOrigin + vRayDir * (traceResult.fDist);\n    surfaceInfo.vNormal = Scene_GetNormal( surfaceInfo.vPos ); \n    surfaceInfo.vBumpNormal = surfaceInfo.vNormal;\n    surfaceInfo.vAlbedo = vec3(1.0); \/\/fract( surfaceInfo.vPos + 0.1 );\n    surfaceInfo.vR0 = vec3( 0.01 );\n    surfaceInfo.fSmoothness = 0.0;\n    surfaceInfo.vEmissive = vec3( 0.0 );\n    \n    surfaceInfo.vR0 = vec3( 0.01 );\n    vec3 vSand = texture( iChannel2, surfaceInfo.vPos.xz * 0.01).rgb;\n    vSand = vSand * vSand;\n    vec3 vMountain = texture( iChannel1, surfaceInfo.vPos.xz * 0.01).rgb;\n    vMountain = vMountain * vMountain;\n    \n    surfaceInfo.vAlbedo = mix(vSand, vMountain, clamp( surfaceInfo.vPos.y * 0.2, 0.0, 1.0) ); \n    \n    \/\/surfaceInfo.vAlbedo = mix(surfaceInfo.vAlbedo, vec3(1,1,1), clamp( (surfaceInfo.vPos.y - 55.0) * 0.2, 0.0, 1.0) ); \n            \n    \n    return surfaceInfo;\n}\n\n\/\/ Scene Description\n\n\nSceneResult Scene_GetDistance( const vec3 vPos )\n{\n    SceneResult result = SceneResult( kMaxTraceDist, MAT_SKY, vec3(0.0) );\n    \n\n    float fMountainDist = 50.0 - length(vPos.xz);\n    float fAngle = atan( vPos.x, vPos.z );\n    fMountainDist = max( fMountainDist, vPos.y - 10.0 + sin( fAngle * 50.0 ) * 5.0);\n    \n\/\/    result = Scene_Union( result, SceneResult( fMountainDist, MAT_MOUNTAIN, vec3(0.0) ) );\n    \/\/result = Scene_Subtract( result, SceneResult( length( vPos - vec3( 0, 3, 0 ) ) - 1.9, MAT_CHROME, vec3(0.0) ) );\n    \/\/result = Scene_Intersection( result, SceneResult( length( vPos - vec3( 0, 3, 0 ) ) - 1.9, MAT_CHROME, vec3(0.0) ) );\n    \n\t\/\/float fHeight = 0.0;\/\/1.0 - texture( iChannel1, vPos.xz * 0.1 - vec2(0, iTime) ).r;\n    \n    float fHeight = FBM_DXY( vPos.xz * 0.005, vec2(0.0), 0.8, -0.1).z;\n    fHeight = fHeight* fHeight * fHeight * fHeight;\n    fHeight = fHeight * 200.0;\n    fHeight = fHeight * (1.0 - exp2( length( vPos.xz ) * -0.003 ) );\n    \n    result = Scene_Union( result, SceneResult( vPos.y - fHeight, MAT_SAND, vec3(0.0) ) );\n                                              \n\/*    float l = length( vPos.xz );\n    result = Scene_Union( result, SceneResult( vPos.y - 2.0 + exp(-l * 0.1) * 4.0, MAT_SAND, vec3(0.0) ) );\n    result = Scene_Union( result, SceneResult( vPos.y \n\/\/                                              + sin(iTime + vPos.x * 8.0) * 0.02\n\/\/                                              + sin(iTime * 2.0 + vPos.z * 8.0) * 0.02\n\/\/                                              + sin(iTime * 3.0 + vPos.x * 10.0) * 0.01\n\/\/                                              + sin(iTime * 4.0 + vPos.z * 10.0) * 0.01\n                                              , MAT_WATER, vec3(0.0) ) );*\/\n        \n    return result;\n}\n\n\/\/ Scene Lighting\n\nvec3 g_vSunDir = normalize(vec3(1.0, 0.4, -0.8));\nvec3 g_vSunColor = vec3(1, 0.5, 0.25) * 5.0;\n\nSurfaceLighting Scene_GetSurfaceLighting( const in vec3 vViewDir, in SurfaceInfo surfaceInfo )\n{\n    SurfaceLighting surfaceLighting;\n    \n    surfaceLighting.vDiffuse = vec3(0.0);\n    surfaceLighting.vSpecular = vec3(0.0);    \n    \n    Light_AddDirectional( surfaceLighting, surfaceInfo, vViewDir, g_vSunDir, g_vSunColor );\n    \/\/Light_AddPoint( surfaceLighting, surfaceInfo, vViewDir, vec3(-2.0, 5.0, 0.0), vec3( 0.5, 1, 0.5 ) );\n    \n    float fAO = 1.0;\/\/Scene_GetAmbientOcclusion( surfaceInfo.vPos, surfaceInfo.vNormal );\n    \/\/ AO\n    surfaceLighting.vDiffuse += fAO * (surfaceInfo.vBumpNormal.y * 0.5 + 0.5) * vec3(0.5, 1, 1);\n    \n    return surfaceLighting;\n}\n\n\/\/ Environment\n\nvec4 Env_GetSkyColor( const vec3 vViewPos, const vec3 vViewDir )\n{\n\tvec4 vResult = vec4(0.0);\n\t\n    vResult.rgb = mix( vec3(0.02, 0.04, 0.06), vec3(0.1, 0.3, 0.8) * 3.0, vViewDir.y * 0.5 + 0.5 );\n\t\n\n\n    \/\/ Cloud\n    float fCloud = texture( iChannel3, vViewDir.xz * 0.01 \/ vViewDir.y ).r;\n    fCloud = clamp( fCloud * fCloud * 3.0 - 1.0, 0.0, 1.0);\n    vResult.rgb = mix( vResult.rgb, vec3(8.0), fCloud );\n    \n    \n    \/\/ Sun\n    \/\/float NdotV = dot( g_vSunDir, vViewDir );\n    \/\/vResult += smoothstep( cos(radians(.7)), cos(radians(.5)), NdotV ) * g_vSunColor * 2000.0;\n    \n    vResult.w = kFarDist;\n    \n\treturn vResult;\t\n}\n\nvec3 Env_ApplyAtmosphere( const in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist)\n{\n    return vColor;\n    \/*\n\tfloat fFogFactor = Env_GetFogFactor( fDist );\n\tvec3 vFogColor = Env_GetFogColor( vRayDir );\n\t\n\tEnv_AddDirectionalLightFlareToFog( vFogColor, vRayDir, g_vSunDir, g_vSunColor);\n    \n    return mix( vFogColor, vColor, fFogFactor );\t    \n\t*\/\n}\n\n\/\/ FX\n\nvec4 FX_ColDensity( vec3 vPos )\n{\n    float density = 0.0;\n    if (length( vPos ) < 5.0 )\n        density = 0.02;\n    return vec4(10,10,10, density);\n}\n\nvec3 FX_Apply( in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist)\n{\n\/*    float t= 0.03;\n    float f = 1.0;\n    for(int iter=0; iter<64; iter++)\n    {\n        if( t > fDist )\n        {\n            break;\n        }\n        \n        vec3 p = vRayOrigin + vRayDir * t;\n        vec4 vEffect = FX_ColDensity( p );\n        vec4 vEffect2 = FX_ColDensity( p + g_vSunDir * 0.1 ) ;\n        \n        vEffect.xyz *= clamp( (vEffect.w - vEffect2.w) \/ 0.1, 0.0, 1.0 );\n        \n        vColor = mix(vColor, vEffect.rgb, f * vEffect.w);\n        f = f * (1.0 - vEffect.w);\n        \n\t\tt += (0.04+t*0.012);        \n    }    *\/\n    \n    return vColor;\n}\n\n\/\/ Camera \n\nCameraState GetCameraState()\n{\n    CameraState camera;\n    \n    float fAngle = (iMouse.x \/ iResolution.x) * 3.14 * 2.0;\n    float fDist = 15.0;\n    \n    float fHeight = (iMouse.y \/ iResolution.y) * 15.0;\n    \n    camera.vPos = vec3( sin(fAngle) * fDist, fHeight, cos(fAngle) * fDist );\n    camera.vTarget = vec3( 0.0, 2.0, 0.5 );\n    camera.fFov = 25.0;\n    \n    return camera;\n}\n\nvoid mainImage( out vec4 vFragColor, in vec2 vFragCoord )\n{\n    vec2 vUV = vFragCoord.xy \/ iResolution.xy; \n    vec4 vOldData = LoadVec4( iChannel0, ivec2(0,0) );\n \n    \n    vec3 vRayOrigin, vRayDir;\n\n\/\/ Environment map render\n#if 1\n    \/\/ Passthrough shader if previous value was valid\n\tif ( iFrame > 0 && vOldData.x == iResolution.x && vOldData.y == iResolution.y )\n    {\n        vFragColor = texture( iChannel0, vUV );\n        return;\n    }\n    \n    vRayOrigin = vec3(0.0, 1.0, 0.0);\n    \n    float fSkyElevationMin = -PI * 0.125;\n    float fSkyElevationMax = PI * 0.5;\n    \n    float fHeading = vUV.x * PI;\n    if ( vUV.y > 0.5 )\n    {\n\t    vUV.y = 1.0 - vUV.y;\n        fHeading += PI;\n    }\n    float fElevation = mix( fSkyElevationMin, fSkyElevationMax, vUV.y * 2.0 );\n    \n    vRayDir.x = sin( fHeading ) * cos( fElevation );\n    vRayDir.y = sin( fElevation );\n    vRayDir.z = cos( fHeading ) * cos( fElevation );\n#else    \n    CameraState cam = GetCameraState();\n    Cam_GetCameraRay( vUV, cam, vRayOrigin, vRayDir );\n#endif\n    \n\tvec4 vColorLinAmdDepth = Scene_GetColorAndDepth( vRayOrigin, vRayDir );    \n\n    vColorLinAmdDepth.rgb = max( vColorLinAmdDepth.rgb, vec3(0.0) );\n        \n    vFragColor = vColorLinAmdDepth;\n    \n    \/\/vFragColor.r = fract( atan(vRayDir.x, vRayDir.z) \/ (PI * 2.0) );\n    \n    \/\/ Debug update frequency\n    \/\/vFragColor.r = fract( iTime * 10.0 );\n    \n    if ( vColorLinAmdDepth.r > 40000.0 || vColorLinAmdDepth.g > 40000.0 || vColorLinAmdDepth.b > 40000.0 )\n    {\n        vFragColor = vec4(0.0);\n    }\n\n    vec4 textureA = texture( iChannel1, vec2(0,0) );\n    vec4 textureB = texture( iChannel2, vec2(0,0) );\n    vec4 textureC = texture( iChannel3, vec2(0,0) );\n\n    vec4 vFrameData = vec4( 0 );\n    \/\/ Don't stamp output as valud until input textures have loaded\n    if ( length(textureA.rgb) > 0.01 && length(textureB.rgb) > 0.01 && length(textureC.rgb) > 0.01 )\n    {  \n        vFrameData =  vec4( floor(iResolution.x), floor(iResolution.y), 0, 0 );\n    }\n    \n    StoreVec4( vec2(0,0), vFrameData, vFragColor, vFragCoord );\n}\n\n\n#endif\n\nvoid mainImage( out vec4 vFragColor, in vec2 vFragCoord )\n{\n    discard;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"\/media\/a\/\/media\/previz\/cubemap00.png","previewfilepath":"\/media\/ap\/\/media\/previz\/cubemap00.png","type":"cubemap","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"\/media\/a\/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"\/media\/ap\/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/\/ Scene Render\n\n#define kMaxTraceDist 1000.0\n#define kFarDist 1100.0\n\n#define MAT_FG_BEGIN \t10.0\n\n#define PI 3.141592654\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Data Storage\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec4 LoadVec4( sampler2D sampler, in ivec2 vAddr )\n{\n    return texelFetch( sampler, vAddr, 0 );\n}\n\nvec3 LoadVec3( sampler2D sampler, in ivec2 vAddr )\n{\n    return LoadVec4( sampler, vAddr ).xyz;\n}\n\nbool AtAddress( vec2 p, vec2 c ) { return all( equal( floor(p), floor(c) ) ); }\n\nvoid StoreVec4( in vec2 vAddr, in vec4 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in vec2 vAddr, in vec3 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Camera\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nstruct CameraState\n{\n    vec3 vPos;\n    vec3 vTarget;\n    float fFov;\n    float fAperture;\n};\n    \nvoid Cam_LoadState( out CameraState cam, sampler2D sampler, ivec2 addr )\n{\n    vec4 posAperture = LoadVec4( sampler, addr + ivec2(0,0) );\n    cam.vPos = posAperture.xyz;\n    cam.fAperture = posAperture.w;\n    vec4 targetFov = LoadVec4( sampler, addr + ivec2(1,0) );\n    cam.vTarget = targetFov.xyz;\n    cam.fFov = targetFov.w;\n}\n\nvoid Cam_StoreState( vec2 addr, const in CameraState cam, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec4( addr + vec2(0,0), vec4( cam.vPos, cam.fAperture ), fragColor, fragCoord );\n    StoreVec4( addr + vec2(1,0), vec4( cam.vTarget, cam.fFov ), fragColor, fragCoord );    \n}\n\nmat3 Cam_GetWorldToCameraRotMatrix( const CameraState cameraState )\n{\n    vec3 vForward = normalize( cameraState.vTarget - cameraState.vPos );\n\tvec3 vRight = normalize( cross(vec3(0, 1, 0), vForward) );\n\tvec3 vUp = normalize( cross(vForward, vRight) );\n    \n    return mat3( vRight, vUp, vForward );\n}\n\nvec2 Cam_GetViewCoordFromUV( const in vec2 vUV )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x \/ iResolution.y;\n\n\treturn vWindow;\t\n}\n\nvoid Cam_GetCameraRay( const vec2 vUV, const CameraState cam, out vec3 vRayOrigin, out vec3 vRayDir )\n{\n    vec2 vView = Cam_GetViewCoordFromUV( vUV );\n    vRayOrigin = cam.vPos;\n    float fPerspDist = 1.0 \/ tan( radians( cam.fFov ) );\n    vRayDir = normalize( Cam_GetWorldToCameraRotMatrix( cam ) * vec3( vView, fPerspDist ) );\n}\n\nvec2 Cam_GetUVFromWindowCoord( const in vec2 vWindow )\n{\n    vec2 vScaledWindow = vWindow;\n    vScaledWindow.x *= iResolution.y \/ iResolution.x;\n\n    return vScaledWindow * 0.5 + 0.5;\n}\n\nvec2 Cam_WorldToWindowCoord(const in vec3 vWorldPos, const in CameraState cameraState )\n{\n    vec3 vOffset = vWorldPos - cameraState.vPos;\n    vec3 vCameraLocal;\n\n    vCameraLocal = vOffset * Cam_GetWorldToCameraRotMatrix( cameraState );\n\t\n    vec2 vWindowPos = vCameraLocal.xy \/ (vCameraLocal.z * tan( radians( cameraState.fFov ) ));\n    \n    return vWindowPos;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Scene\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nstruct SceneResult\n{\n\tfloat fDist;\n\tfloat fObjectId;\n    vec3 vUVW;\n};\n\nSceneResult Scene_Union( const in SceneResult a, const in SceneResult b )\n{\n    if ( a.fDist < b.fDist )\n    {\n        return a;\n    }\n    return b;\n}\n    \nSceneResult Scene_Subtract( const in SceneResult a, const in SceneResult b )\n{\n    if ( -a.fDist < b.fDist )\n    {\n        return a;\n    }\n\n    SceneResult result;\n    result.fDist = -b.fDist;\n    result.fObjectId = b.fObjectId;\n    result.vUVW = b.vUVW;\n    return result;\n}\n\nSceneResult Scene_Intersection( const in SceneResult a, const in SceneResult b )\n{\n    if ( a.fDist > b.fDist )\n    {\n        return a;\n    }\n    return b;\n}\n    \nSceneResult Scene_GetDistance( const vec3 vPos );    \n\nvec3 Scene_GetNormal(const in vec3 vPos)\n{\n    const float fDelta = 0.001;\n    vec2 e = vec2( -1, 1 );\n    \n    vec3 vNormal = \n        Scene_GetDistance( vPos + e.yxx * fDelta ).fDist * e.yxx + \n        Scene_GetDistance( vPos + e.xxy * fDelta ).fDist * e.xxy + \n        Scene_GetDistance( vPos + e.xyx * fDelta ).fDist * e.xyx + \n        Scene_GetDistance( vPos + e.yyy * fDelta ).fDist * e.yyy;\n    \n    if ( dot( vNormal, vNormal ) < 0.00001 )\n    {\n        return vec3(0, 1, 0);\n    }\n    \n    return normalize( vNormal );\n}    \n    \nSceneResult Scene_Trace( const in vec3 vRayOrigin, const in vec3 vRayDir, float maxDist )\n{\t\n    SceneResult result;\n    result.fDist = 0.0;\n    result.vUVW = vec3(0.0);\n    result.fObjectId = 0.0;\n    \n\tfloat t = 0.1;\n\tconst int kRaymarchMaxIter = 128;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\t\t\n\t\tresult = Scene_GetDistance( vRayOrigin + vRayDir * t );\t\t\n        t += result.fDist;\n\n        if ( abs(result.fDist) < 0.001 )\n\t\t{\n\t\t\tbreak;\n\t\t}\t\t\n        if ( t > maxDist )\n        {\n            result.fObjectId = -1.0;\n\t        t = maxDist;\n            break;\n        }\n\t}\n    \n    result.fDist = t;\n\n    return result;\n}    \n\nfloat Scene_TraceShadow( const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fLightDist )\n{\n    \/\/return 1.0;\n    \/\/return Scene_Trace( vRayOrigin, vRayDir, fLightDist ).fDist < fLightDist ? 0.0 : 1.0;\n    \n    float mint = 0.02, tmax = 5.0;\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = Scene_GetDistance( vRayOrigin + vRayDir * t ).fDist;\n        res = min( res, 10.0*h\/t );\n        t += clamp( h, 0.02, 0.40 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 ) * 0.75 + 0.25;    \n}\n\nfloat Scene_GetAmbientOcclusion( const in vec3 vPos, const in vec3 vDir )\n{\n    float fOcclusion = 0.0;\n    float fScale = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float fOffsetDist = 0.01 + 1.0*float(i)\/4.0;\n        vec3 vAOPos = vDir * fOffsetDist + vPos;\n        float fDist = Scene_GetDistance( vAOPos ).fDist;\n        fOcclusion += (fOffsetDist - fDist) * fScale;\n        fScale *= 0.4;\n    }\n    \n    return clamp( 1.0 - 2.0*fOcclusion, 0.0, 1.0 );\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Lighting\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \nstruct SurfaceInfo\n{\n    vec3 vPos;\n    vec3 vNormal;\n    vec3 vBumpNormal;    \n    vec3 vAlbedo;\n    vec3 vR0;\n    float fSmoothness;\n    vec3 vEmissive;\n};\n    \nSurfaceInfo Scene_GetSurfaceInfo( const in vec3 vRayOrigin,  const in vec3 vRayDir, SceneResult traceResult );\n\nstruct SurfaceLighting\n{\n    vec3 vDiffuse;\n    vec3 vSpecular;\n};\n    \nSurfaceLighting Scene_GetSurfaceLighting( const in vec3 vRayDir, in SurfaceInfo surfaceInfo );\n\nfloat Light_GIV( float dotNV, float k)\n{\n\treturn 1.0 \/ ((dotNV + 0.0001) * (1.0 - k)+k);\n}\n\nvoid Light_Add(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\n\tfloat fNDotL = clamp(dot(vLightDir, surface.vBumpNormal), 0.0, 1.0);\n\t\n\tlighting.vDiffuse += vLightColour * fNDotL;\n    \n\tvec3 vH = normalize( -vViewDir + vLightDir );\n\tfloat fNdotV = clamp(dot(-vViewDir, surface.vBumpNormal), 0.0, 1.0);\n\tfloat fNdotH = clamp(dot(surface.vBumpNormal, vH), 0.0, 1.0);\n    \n\tfloat alpha = 1.0 - surface.fSmoothness;\n\t\/\/ D\n\n\tfloat alphaSqr = alpha * alpha;\n\tfloat pi = 3.14159;\n\tfloat denom = fNdotH * fNdotH * (alphaSqr - 1.0) + 1.0;\n\tfloat d = alphaSqr \/ (pi * denom * denom);\n\n\tfloat k = alpha \/ 2.0;\n\tfloat vis = Light_GIV(fNDotL, k) * Light_GIV(fNdotV, k);\n\n\tfloat fSpecularIntensity = d * vis * fNDotL;    \n\tlighting.vSpecular += vLightColour * fSpecularIntensity;    \n}\n\nvoid Light_AddPoint(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightPos, const in vec3 vLightColour)\n{    \n    vec3 vPos = surface.vPos;\n\tvec3 vToLight = vLightPos - vPos;\t\n    \n\tvec3 vLightDir = normalize(vToLight);\n\tfloat fDistance2 = dot(vToLight, vToLight);\n\tfloat fAttenuation = 100.0 \/ (fDistance2);\n\t\n\tfloat fShadowFactor = Scene_TraceShadow( surface.vPos, vLightDir, length(vToLight) );\n\t\n\tLight_Add( lighting, surface, vViewDir, vLightDir, vLightColour * fShadowFactor * fAttenuation);\n}\n\nvoid Light_AddDirectional(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\t\n\tfloat fAttenuation = 1.0;\n\tfloat fShadowFactor = Scene_TraceShadow( surface.vPos, vLightDir, 10.0 );\n\t\n\tLight_Add( lighting, surface, vViewDir, vLightDir, vLightColour * fShadowFactor * fAttenuation);\n}\n\nvec3 Light_GetFresnel( vec3 vView, vec3 vNormal, vec3 vR0, float fGloss )\n{\n    float NdotV = max( 0.0, dot( vView, vNormal ) );\n\n    return vR0 + (vec3(1.0) - vR0) * pow( 1.0 - NdotV, 5.0 ) * pow( fGloss, 20.0 );\n}\n\nvoid Env_AddPointLightFlare(inout vec3 vEmissiveGlow, const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fIntersectDistance, const in vec3 vLightPos, const in vec3 vLightColour)\n{\n    vec3 vToLight = vLightPos - vRayOrigin;\n    float fPointDot = dot(vToLight, vRayDir);\n    fPointDot = clamp(fPointDot, 0.0, fIntersectDistance);\n\n    vec3 vClosestPoint = vRayOrigin + vRayDir * fPointDot;\n    float fDist = length(vClosestPoint - vLightPos);\n\tvEmissiveGlow += sqrt(vLightColour * 0.05 \/ (fDist * fDist));\n}\n\nvoid Env_AddDirectionalLightFlareToFog(inout vec3 vFogColour, const in vec3 vRayDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\n\tfloat fDirDot = clamp(dot(vLightDir, vRayDir) * 0.5 + 0.5, 0.0, 1.0);\n\tfloat kSpreadPower = 2.0;\n\tvFogColour += vLightColour * pow(fDirDot, kSpreadPower) * 0.25;\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Rendering\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec4 Env_GetSkyColor( const vec3 vViewPos, const vec3 vViewDir );\nvec3 Env_ApplyAtmosphere( const in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist);\nvec3 FX_Apply( in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist);\n\nvec4 Scene_GetColorAndDepth( const in vec3 vInRayOrigin, const in vec3 vInRayDir )\n{\n    vec3 vRayOrigin = vInRayOrigin;\n    vec3 vRayDir = vInRayDir;\n    \n\tvec3 vResultColor = vec3(0.0);\n\tvec3 vPassContribution = vec3(1.0);\n            \n\tSceneResult firstTraceResult;\n    \n\tfor( int iPassIndex=0; iPassIndex<3; iPassIndex++ )\n\t{\t        \n    \tSceneResult traceResult = Scene_Trace( vRayOrigin, vRayDir, kMaxTraceDist );\n        \n        if ( iPassIndex == 0 )\n        {\n            firstTraceResult = traceResult;\n        }\n        \n\t\tvec3 vPassColor = vec3(0.0);\n\t\tvec3 vReflectance = vec3(1.0);\n\n\t\tif( traceResult.fObjectId < 0.0 )\n\t\t{\n            break; \n        }\n        else\n        {\n            SurfaceInfo surfaceInfo = Scene_GetSurfaceInfo( vRayOrigin, vRayDir, traceResult );\n            SurfaceLighting surfaceLighting = Scene_GetSurfaceLighting( vRayDir, surfaceInfo );\n                \n            \/\/ calculate reflectance (Fresnel)\n            float NdotV = clamp( dot(surfaceInfo.vBumpNormal, -vRayDir), 0.0, 1.0);\n\t\t\tvReflectance = Light_GetFresnel( -vRayDir, surfaceInfo.vBumpNormal, surfaceInfo.vR0, surfaceInfo.fSmoothness );\n\t\t\t\n\t\t\tvPassColor = \n                mix( surfaceInfo.vAlbedo * surfaceLighting.vDiffuse + surfaceInfo.vEmissive, surfaceLighting.vSpecular, vReflectance );\n        \n\t        vPassColor = Env_ApplyAtmosphere( vPassColor, vRayOrigin, vRayDir, traceResult.fDist );\t\t\n    \t\tvPassColor = FX_Apply( vPassColor, vRayOrigin, vRayDir, traceResult.fDist );\n            \n            \/\/ Reflect Ray\n            vRayOrigin = surfaceInfo.vPos;\n            vRayDir = normalize( reflect( vRayDir, surfaceInfo.vBumpNormal ) );\n        }\n                \n\t\tvResultColor += vPassColor * vPassContribution;\n\t\tvPassContribution *= vReflectance;\t\t\t        \n    }\n    \n    vec4 vFinalSkyColor = Env_GetSkyColor( vRayOrigin, vRayDir );\n    vFinalSkyColor.rgb = Env_ApplyAtmosphere( vFinalSkyColor.rgb, vRayOrigin, vRayDir, vFinalSkyColor.a );\t\t\n\tvFinalSkyColor.rgb = FX_Apply( vFinalSkyColor.rgb, vRayOrigin, vRayDir, vFinalSkyColor.a );\n    vResultColor += vFinalSkyColor.rgb * vPassContribution;\n    \n    \/\/vResultColor = FX_Apply( vResultColor, vInRayOrigin, vInRayDir, firstTraceResult.fDist );\n    \n    if ( firstTraceResult.fObjectId >= MAT_FG_BEGIN )\n    {\n        firstTraceResult.fDist = -firstTraceResult.fDist;\n    }\n    \n    return vec4( vResultColor, firstTraceResult.fDist );\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Utility Functions\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define MOD2 vec2(4.438975,3.972973)\n\nfloat Hash( float p ) \n{\n    \/\/ https:\/\/www.shadertoy.com\/view\/4djSRW - Dave Hoskins\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);    \n\t\/\/return fract(sin(n)*43758.5453);\n}\n\nfloat SmoothNoise(in vec2 o) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat a = Hash(n+  0.0);\n\tfloat b = Hash(n+  1.0);\n\tfloat c = Hash(n+ 57.0);\n\tfloat d = Hash(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n    return res;\n}\n\n\nvec3 SmoothNoise_DXY(in vec2 o) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat a = Hash(n+  0.0);\n\tfloat b = Hash(n+  1.0);\n\tfloat c = Hash(n+ 57.0);\n\tfloat d = Hash(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\tvec2 dt = 6.0 * f - 6.0 * f2;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\tfloat du = dt.x;\t\n\tfloat dv = dt.y;\t\n\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n\tfloat dx = (b-a)*du + (a-b+d-c)*du*v;\n\tfloat dy = (c-a)*dv + (a-b+d-c)*u*dv;    \n    \n    return vec3(dx, dy, res);\n}\n\nvec3 FBM_DXY( vec2 p, vec2 flow, float ps, float df ) {\n\tvec3 f = vec3(0.0);\n    float tot = 0.0;\n    float a = 1.0;\n    \/\/flow *= 0.6;\n    for( int i=0; i<4; i++)\n    {\n        p += flow;\n        flow *= -0.75; \/\/ modify flow for each octave - negating this is fun\n        vec3 v = SmoothNoise_DXY( p );\n        f += v * a;\n        p += v.xy * df;\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f \/ tot;\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Scene Description\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nstruct SceneState\n{\n    vec3 vCarPos;\n    float fThruster;\n    float fDustTrail;\n    float fCarVel;\n    float fEffect;\n};  \n    \nSceneState g_sceneState;\n    \n\/\/ Materials\n\n#define MAT_SKY \t\t-1.0\n#define MAT_SAND \t\t1.0\n\n\/\/#define MAT_WATER \t\t0.0\n\/\/#define MAT_GOLD \t\t2.0\n\n#define MAT_CHROME \t\t10.0\n#define MAT_CAR_PAINT\t11.0\n\n\nvec3 GetWaterExtinction( float dist )\n{\n    float fOpticalDepth = dist * 6.0;\n\n    vec3 vExtinctCol = 1.0 - vec3(0.5, 0.4, 0.1);           \n    vec3 vExtinction = exp2( -fOpticalDepth * vExtinctCol );\n    \n    return vExtinction;\n}\n\nSurfaceInfo Scene_GetSurfaceInfo( const in vec3 vRayOrigin,  const in vec3 vRayDir, SceneResult traceResult )\n{\n    SurfaceInfo surfaceInfo;\n    \n    surfaceInfo.vPos = vRayOrigin + vRayDir * (traceResult.fDist);\n    \n    surfaceInfo.vNormal = Scene_GetNormal( surfaceInfo.vPos ); \n    surfaceInfo.vBumpNormal = surfaceInfo.vNormal;\n    surfaceInfo.vAlbedo = vec3(1.0); \/\/fract( surfaceInfo.vPos + 0.1 );\n    surfaceInfo.vR0 = vec3( 0.01 );\n    surfaceInfo.fSmoothness = 1.0;\n    surfaceInfo.vEmissive = vec3( 0.0 );\n        \n    if ( traceResult.fObjectId == MAT_CHROME )\n    {\n    \tsurfaceInfo.vR0 = vec3( 0.3 );\n\t    surfaceInfo.vAlbedo = vec3( 0.0 );\n    }\n    \/*else\n    if ( traceResult.fObjectId == MAT_GOLD )\n    {\n        surfaceInfo.vR0 = vec3( 0.8, 0.6, 0.1 );\n\t    surfaceInfo.vAlbedo = vec3( 0.0 );\n        \n        float f = fract(surfaceInfo.vPos.y);\n        if ( f > 0.9 )\n        {\n            surfaceInfo.vEmissive = vec3( 1, 4, 8 ) * 100.0;\n        }\n    }\n    else\n    if ( traceResult.fObjectId == MAT_WATER )\n    {\n\t    surfaceInfo.vR0 = vec3( 0.01 );\n        surfaceInfo.fSmoothness = 1.0;\n        surfaceInfo.vBumpNormal.xy += FBM_DXY( surfaceInfo.vPos.xz * 2.0, vec2(0), 0.9, 0.2).yz * 0.2;\n        surfaceInfo.vBumpNormal = normalize( surfaceInfo.vBumpNormal );\n        vec3 vRefractedRay = refract( -vRayDir, surfaceInfo.vBumpNormal, 1.0 \/ 1.33 );\n        float fDepth = vRefractedRay.y;\n        float fRayLength = 2.0 \/ fDepth;\n        vec2 vUVOffset = vRefractedRay.xz * fRayLength;\n        surfaceInfo.vAlbedo = texture( iChannel0, surfaceInfo.vPos.xz + vUVOffset ).rgb;\n        surfaceInfo.vAlbedo = surfaceInfo.vAlbedo * surfaceInfo.vAlbedo;\n        \n        surfaceInfo.vAlbedo *= GetWaterExtinction( -fRayLength * 0.25 );\n    }*\/\n    else\n    if ( traceResult.fObjectId == MAT_SAND )\n    {\n    \tsurfaceInfo.vR0 = vec3( 0.0 );\n\t    \/\/surfaceInfo.vAlbedo = vec3( 1.0, 0.0, 0.0 );\n        vec2 vSandPos = surfaceInfo.vPos.xz + 0.2;\n        vec3 vSample1 = texture( iChannel0, vSandPos * 0.05).rgb;\n        \/\/vSample1 = vSample1 * vSample1;\n        vec3 vSample2 = texture( iChannel0, vSandPos * 0.001).rgb;\n        \/\/vSample2 = vSample2 * vSample2;\n        surfaceInfo.vAlbedo = vSample1 * vSample2;\n        \/\/float f = FBM_DXY( surfaceInfo.vPos.xz * 3.0, vec2(0,0), 0.7, -0.5 ).z;\n        \/\/f = f * f;\n        \/\/surfaceInfo.vAlbedo = mix( vec3(0.2, 0.1, 0.05), vec3(0.6, 0.5, 0.2), f );\n        surfaceInfo.fSmoothness = 0.1;        \n        \/\/surfaceInfo.fSmoothness = 1.0 - surfaceInfo.vAlbedo.r;        \n\n        \n        \/\/ heat haze\n        \n        \/\/surfaceInfo.vR0 = vec3(0.02);\n        \/\/surfaceInfo.fSmoothness = 0.95;\n        \/\/surfaceInfo.vBumpNormal.xz += FBM_DXY(surfaceInfo.vPos.xz * 2.0, vec2(iTime, 0.0), 0.5, 0.5 ).xy * .1;\n        \/\/surfaceInfo.vBumpNormal = normalize( surfaceInfo.vBumpNormal );\n        vec2 vMin = vec2(0.0, -97.5);\n        vec2 vMax = vec2(2.0, -95.0);\n        vec2 vUV = (surfaceInfo.vPos.xz - vMin) \/ (vMax - vMin);\n\t\tif ( vUV.x > 0.0 && vUV.x < 1.0 &&\n            vUV.y > 0.0 && vUV.y < 1.0 )\n        {\n            float fAmount = max(0.0, 1.0 - surfaceInfo.vAlbedo.r * 2.5);\n            surfaceInfo.vAlbedo = mix( vec3(0.1,0.1,.25), vec3(.9,1,1), fAmount );\n            \n\t\t\tsurfaceInfo.vAlbedo = surfaceInfo.vAlbedo * surfaceInfo.vAlbedo;\n        }\n    }\n    else\n    if ( traceResult.fObjectId == MAT_CAR_PAINT )\n    {\n    \tsurfaceInfo.vR0 = vec3( 0.02 );\n\t    surfaceInfo.vAlbedo = vec3( 0.01, 0.01, 0.01 );\n        surfaceInfo.fSmoothness = 0.95;       \n    }\n    \n    if ( traceResult.fObjectId == MAT_CAR_PAINT || traceResult.fObjectId == MAT_CHROME )\n    {\n        vec3 vDirt = mix(texture(iChannel0, traceResult.vUVW.zy * vec2(0.2, 1.0)).rgb, texture(iChannel0, traceResult.vUVW.xy).rgb, abs(surfaceInfo.vNormal.z) ) ;\n        float fDirt = vDirt.r;\n        \n        float fMix = clamp( fDirt - traceResult.vUVW.y * 0.4, 0.0, 1.0 );\n        \n        vDirt = vDirt * vDirt * 0.15;\n\n        surfaceInfo.vAlbedo = mix( surfaceInfo.vAlbedo, vDirt, fMix );\n        surfaceInfo.vR0 = mix( surfaceInfo.vR0, vec3(0.01), fMix );\n        surfaceInfo.fSmoothness = mix( surfaceInfo.fSmoothness, 0.01, fMix ); \n    }\n    \n    return surfaceInfo;\n}\n\n\/\/ Scene Description\n\nfloat NozzleDist( vec2 vProfile, float r1, float r2, float l, float thickness )\n{\n    float f = vProfile.x  \/ l;\n    float fDist = vProfile.y - mix( r1, r2, f );\n    fDist = max( fDist, - fDist - thickness );\n    fDist = max( fDist, vProfile.x - l );\n    fDist = max( fDist, -vProfile.x  );    \n    \n    return fDist;\n}\n\nfloat ConvexCurveSectionDist( vec2 vProfile, float r1, float r2, float x1, float x2 )\n{    \n    float l = x2 - x1;\n    float curveDR = abs(r2 - r1);\n    float circleR = (l * l + curveDR * curveDR) \/ (2.0 * curveDR);\n    float fDist = length( vProfile - vec2(x2, r1 - circleR) )  - circleR;\n    \n    return fDist;\n}\n\nfloat ConcaveCurveSectionDist( vec2 vProfile, float r1, float r2, float x1, float x2 )\n{    \n    \/*float l = x2 - x1;\n    float curveDR = abs(r2 - r1);\n    float circleR = (l * l + curveDR * curveDR) \/ (2.0 * curveDR);\n    float fDist = length( vProfile - vec2(0, r1 - circleR) )  - circleR;*\/\n    \n    float l = x2 - x1;\n    float curveDR = r2 - r1;    \n    float circleR = (l * l + curveDR * curveDR) \/ (2.0 * curveDR);    \n    float fDist = circleR - length( vProfile - vec2(x1, r1 + circleR) );\n\n    fDist = max( fDist, vProfile.y - r2 );\n    \n    return fDist;\n}\n    \nSceneResult CarCentre_GetDistance( vec3 vPos )\n{\n    \/\/vPos.y -= clamp(vPos.z, -3.0, 0.0) * 0.1;\n    vec2 vProfile = vec2( vPos.z, length( vPos.xy ) );\n    \n    const float fNoseStartRadius = 0.5;\n    const float fNoseEndRadius = 0.1;\n    const float fNoseLength = 3.0;\n    \n    const float fNoseDR = fNoseStartRadius - fNoseEndRadius;\n    \n    const float frontCurveCircleRadius = (fNoseLength * fNoseLength + fNoseDR * fNoseDR) \/ (2.0 * fNoseDR);    \n    \n    \/\/float dist = length( vProfile - vec2(0, fNoseStartRadius-frontCurveCircleRadius) ) - frontCurveCircleRadius;\n    \n    float dist = ConvexCurveSectionDist( vProfile, fNoseStartRadius, fNoseEndRadius, -fNoseLength, 0.0 );\n    \n    const float fSpikeLength = 2.0;\n    dist = min(dist, vProfile.y - 0.05);\n\tdist = max(dist, (vProfile.y - 0.05 - (vProfile.x + (fNoseLength + fSpikeLength))) * (1.0 \/ sqrt(2.0))); \/\/ pointy tip    \n\n\t\/\/ cabin cone\n    const float fCCStartRadius = fNoseStartRadius;\n    const float fCCEndRadius = 1.0;\n    const float fCCLength = 5.0;\n    \n    float fCCRadius = ConcaveCurveSectionDist(vProfile, fCCStartRadius, fCCEndRadius, 0.0, fCCLength );\n    \n\/*        if ( vProfile.x < 0.0 )\n        {\n            fCCRadius = 0.0;\n        }\n        if ( vProfile.x > fCCLength)\n        {\n            fCCRadius = fCCEndRadius;\n        }*\/\n    \n     \n    if ( vProfile.x > 0.0 )\n    {\n    \tdist = min ( dist, fCCRadius );\n    }\n    \n    const float rRCEndRadius = 1.5;\n    float fRRadius = ConvexCurveSectionDist(vProfile, rRCEndRadius, fCCEndRadius, fCCLength, 15.0 );\n    \n    dist = min( dist, fRRadius );\n\n    \/\/ back end cap\n    dist = max( dist, vProfile.x - 14.0 );\n    \n    \/\/ taper body\n    dist = max( dist, vPos.x + vPos.z * 0.02 - 0.8 );\n    \n    \/\/ flatten base\n    dist = max( dist, -vPos.y - 0.6 );\n    \n    \/\/ Fin Vertical\n    \n    float fVFinDist = (vPos.y - vPos.z) \/ sqrt(2.0) + 8.0;\n    fVFinDist = max( fVFinDist, abs(vPos.x ) - 0.1 );\n    fVFinDist = max( fVFinDist, abs(vPos.y - 1.0 ) - 1.0 );\n    fVFinDist = max( fVFinDist, vPos.z - 13.8 );\n    dist = min( dist, fVFinDist );\n    \n    \/\/ Fin\n    vec3 vFinDir = normalize(vec3( 1.0, -0.5, -0.5 ));\n    float fFinDist = dot(vPos - vec3(0.0, 2.0, 11.5), vFinDir) ;\n    fFinDist = max( fFinDist, vPos.z - 16.0 );\n    fFinDist = max( fFinDist, abs(vPos.y - 2.0 ) - 0.1 );\n    dist = min( dist, fFinDist );\n    \n    SceneResult result = SceneResult( dist, MAT_CAR_PAINT, vec3(vPos) );\n\n    \n    if ( -vProfile.x > fNoseLength - 0.1 )\n    {\n        result.fObjectId = MAT_CHROME;\n    }\n    \n    \/\/result = Scene_Union( result, SceneResult( vProfile.y - 0.05, MAT_CHROME, vec3(0.0) ) );\n    \n    \/\/vPos.x *= 1.5;\n    \/\/SceneResult result = SceneResult( kMaxTraceDist, MAT_SKY, vec3(0.0) );\n    \n    \/*\n    vec3 vClosest = vPos;\n    vClosest.z = clamp( vClosest.z, 0.0, 4.0 );\n        \n    float fRadius = 1.0;\n    \n    fRadius = min( fRadius, smoothstep( 0.0, 1.0, vPos.z * 0.2 + 0.5) );\n    \n    float fRearRadius = clamp( vPos.z * 0.5 - 5.0 , 0.0, 1.0 );\n    fRadius = min( fRadius, sqrt( 1.0 - fRearRadius * fRearRadius )  );\n    \/\/fRadius = max(fRadius, -vPos.z * 0.25 );\n\n    \/\/{\n\/\/    \tfRadius = smoothstep(0.0, 1.0, fRadius);\n\/\/    }\n\n    \/\/vClosest.xy = normalize(vClosest.xy) * min( length(vClosest.xy), fRadius );\n    \n    \/\/float dist = length(vPos - vClosest) - 0.5;\n    float dist = length(vPos.xy) - fRadius;\n    dist = max( dist, -vPos.z + -10.0 );\n    dist = max( dist, vPos.z -8.0 );\n    \n    \/\/dist \/= 1.5;\n    *\/\n    \n    return result;\n}\n\nSceneResult CarEngine_GetDistance( vec3 vPos )\n{\n    \/\/SceneResult result = SceneResult( kMaxTraceDist, MAT_SKY, vec3(0.0) );\n    \n    vec2 vProfile = vec2( vPos.z, length( vPos.xy ) );\n\n    float fDist = kMaxTraceDist;\n    \n    const float fEngineRadius1 = 1.0;\n    const float fEngineRadius2 = 0.9;\n    const float fEngineRearLength = 7.0;\n    \n    float fEngineRadiusCurr = mix( fEngineRadius1, fEngineRadius2, vProfile.x  \/ fEngineRearLength);\n    float fCylinderDist = vProfile.y - fEngineRadiusCurr;\n    fCylinderDist = max( fCylinderDist, -vProfile.x );\n    \n    fDist = min( fDist, fCylinderDist );\n    \n    const float fEngineFrontCurveLength = 1.5;\n    const float fEngineFrontCurveRadius = 0.6;\n    \n    float frontCurveDist = ConvexCurveSectionDist( vProfile, fEngineRadius1, fEngineFrontCurveRadius, -fEngineFrontCurveLength, 0.0 );\n    frontCurveDist = max( frontCurveDist, -vProfile.x - fEngineFrontCurveLength);\n    \n    \n    fDist = min( fDist, frontCurveDist );\n    \n    fDist = max( fDist, vProfile.x - fEngineRearLength);\n    \n    SceneResult result = SceneResult( fDist, MAT_CAR_PAINT, vec3(vPos) );\n\n    const float fEngineInnerCylinderRadius1 = fEngineFrontCurveRadius - 0.025;\n    const float fEngineInnerCylinderRadius2 = fEngineRadius2 - 0.0;\n    \n    result = Scene_Union( result, SceneResult( length( vProfile - vec2(-fEngineFrontCurveLength + 0.08, fEngineFrontCurveRadius - 0.2 )) - 0.22, MAT_CHROME, vec3(0.0) ) );\n    \n\n    float fGroovePos = floor(vProfile.x) + 0.5;\n    float fGrooveDist = abs( vProfile.x - fGroovePos ) - vProfile.y - 0.025 + fEngineRadiusCurr;\n    result = Scene_Subtract( result, SceneResult( fGrooveDist, MAT_CAR_PAINT, vec3(vPos) ) );\n    \n    float fInnerCylinderDist = vProfile.y - mix( fEngineInnerCylinderRadius1, fEngineInnerCylinderRadius2, (vProfile.x - fEngineFrontCurveLength) \/ (fEngineFrontCurveLength + fEngineRearLength) );    \n    \/\/fInnerCylinderDist = max( fInnerCylinderDist, 1.0 - abs( vProfile.x - 5.0 ) );\n    result = Scene_Subtract( result, SceneResult( fInnerCylinderDist, MAT_CHROME, vec3(0.0) ) );\n\t\n    const float rearNozzleStart = fEngineRearLength - 1.0;\n    const float rearNozzleEnd = fEngineRearLength + 0.2;\n    float fRearNozzleDist = NozzleDist( vProfile - vec2(rearNozzleStart, 0.0), 0.4, 0.85, rearNozzleEnd - rearNozzleStart, 0.05 );\n    result = Scene_Union( result, SceneResult( fRearNozzleDist, MAT_CHROME, vec3(0.0) ) );\n    \n    const float rearNozzle2Start = fEngineRearLength - 0.2;\n    const float rearNozzle2End = fEngineRearLength + 0.4;\n    float fRearNozzle2Dist = NozzleDist( vProfile - vec2(rearNozzle2Start, 0.0), 0.5, 0.3, rearNozzle2End - rearNozzle2Start + 0.1, 0.05 );\n    result = Scene_Union( result, SceneResult( fRearNozzle2Dist, MAT_CHROME, vec3(0.0) ) );\n        \n    \/*\n    vec3 vClosest = vec3(0.0);\n    vClosest.z = clamp( vPos.z, 0.0, 6.0 );\n\n    float dist = length( vPos - vClosest ) - 1.0;\n    \n    SceneResult result = SceneResult( dist, MAT_CAR_PAINT, vec3(0.0) );\n\n    float fRadialDist = length(vPos.xy);\n    result = Scene_Subtract( result, SceneResult( fRadialDist - 0.6, MAT_CHROME, vec3(0.0) ) );\n    \n\t*\/\n    \n    if ( vPos.z < -1.3 )\n    {\n        result.fObjectId = MAT_CHROME;\n    }\n    return result;\n}\n\nSceneResult Car_GetDistance( const vec3 vPos )\n{\n    \/\/SceneResult result = SceneResult( kMaxTraceDist, MAT_SKY, vec3(0.0) );\n    \/\/SceneResult result = SceneResult( length( vPos - vec3( 0, 1, 0 ) ) - 2.0, MAT_GOLD, vec3(0.0) );\n    \n    vec3 vMirror = vPos;\n    vMirror.x = abs(vMirror.x);\n    \n    SceneResult result = CarEngine_GetDistance( vMirror - vec3( 1.4, 1.1, -2 ) );\n    \/\/result = Scene_Union( result, CarEngine_GetDistance( vPos - vec3( 1.5, 1, -2 ) ) );\n    \n    result = Scene_Union( result, CarCentre_GetDistance( vMirror - vec3( 0, .7, -4 ) ) );\n    \n    result.vUVW = vPos;\n    \n    return result;\n}\n\nSceneResult Scene_GetDistance( const vec3 vPos )\n{\n    SceneResult result = SceneResult( kMaxTraceDist, MAT_SKY, vec3(0.0) );\n\n    result = Scene_Union( result, Car_GetDistance( vPos - g_sceneState.vCarPos ) );\n    \n    \n    \/\/result = Scene_Union( result, SceneResult( length( vPos - vec3( 0, 1, 0 ) ) - 2.0, MAT_GOLD, vec3(0.0) ) );\n    \/\/result = Scene_Subtract( result, SceneResult( length( vPos - vec3( 0, 3, 0 ) ) - 1.9, MAT_CHROME, vec3(0.0) ) );\n    \/\/result = Scene_Intersection( result, SceneResult( length( vPos - vec3( 0, 3, 0 ) ) - 1.9, MAT_CHROME, vec3(0.0) ) );\n    \n\tfloat fHeight = 1.0;\/\/1.0 - texture( iChannel1, vPos.xz * 0.1 - vec2(0, iTime) ).r;\n    \n    result = Scene_Union( result, SceneResult( vPos.y + fHeight * 0.5, MAT_SAND, vec3(0.0) ) );\n                                                  \n\/*    float l = length( vPos.xz );\n    result = Scene_Union( result, SceneResult( vPos.y - 2.0 + exp(-l * 0.1) * 4.0, MAT_SAND, vec3(0.0) ) );\n    result = Scene_Union( result, SceneResult( vPos.y \n\/\/                                              + sin(iTime + vPos.x * 8.0) * 0.02\n\/\/                                              + sin(iTime * 2.0 + vPos.z * 8.0) * 0.02\n\/\/                                              + sin(iTime * 3.0 + vPos.x * 10.0) * 0.01\n\/\/                                              + sin(iTime * 4.0 + vPos.z * 10.0) * 0.01\n                                              , MAT_WATER, vec3(0.0) ) );*\/\n        \n    return result;\n}\n\n\/\/ Scene Lighting\n\nvec3 g_vSunDir = normalize(vec3(1.0, 0.4, -0.8));\nvec3 g_vSunColor = vec3(1, 0.5, 0.25) * 5.0;\nvec3 g_vAmbientColor = vec3(0.5, 1, 1);\n\nSurfaceLighting Scene_GetSurfaceLighting( const in vec3 vViewDir, in SurfaceInfo surfaceInfo )\n{\n    SurfaceLighting surfaceLighting;\n    \n    surfaceLighting.vDiffuse = vec3(0.0);\n    surfaceLighting.vSpecular = vec3(0.0);    \n    \n    Light_AddDirectional( surfaceLighting, surfaceInfo, vViewDir, g_vSunDir, g_vSunColor );\n    \n    vec3 vThrusterLightCol = vec3( 1.0, 0.5, 0.3 ) * 1.0 * g_sceneState.fThruster;\n    Light_AddPoint( surfaceLighting, surfaceInfo, vViewDir, g_sceneState.vCarPos + vec3(1.4, 1.0, 5.8), vThrusterLightCol );\n    Light_AddPoint( surfaceLighting, surfaceInfo, vViewDir, g_sceneState.vCarPos + vec3(-1.4, 1.0, 5.8), vThrusterLightCol );\n    \n    float fAO = 1.0;\/\/Scene_GetAmbientOcclusion( surfaceInfo.vPos, surfaceInfo.vNormal );\n    \/\/ AO\n    surfaceLighting.vDiffuse += fAO * (surfaceInfo.vBumpNormal.y * 0.5 + 0.5) * g_vAmbientColor;\n    \n    return surfaceLighting;\n}\n\n\/\/ Environment\n\nvec4 Env_GetSkyColor( const vec3 vViewPos, const vec3 vViewDir )\n{\n\tvec4 vResult = vec4( 0.0, 0.0, 0.0, kFarDist );\n\t\n    float fElevation = atan( vViewDir.y, length(vViewDir.xz) );\n    float fHeading = atan( vViewDir.x, vViewDir.z );\n    \n    float fSkyElevationMin = -PI * 0.125;\n    float fSkyElevationMax = PI * 0.5;\n\n    float fScaledElevation = 0.5 * ((fElevation - fSkyElevationMin) \/ (fSkyElevationMax - fSkyElevationMin));\n    if (fHeading < 0.0) fScaledElevation = 1.0 - fScaledElevation;\n    vec2 vUV = vec2( fract(fHeading \/ PI), fScaledElevation );\n    \n    \/\/vResult = textureLod( iChannel3, vUV, 0.0 );\n    vResult = textureLod( iChannel3, vViewDir, 0.0 );\n    \n    \/\/vResult = mix( vec3(0.02, 0.04, 0.06), vec3(0.1, 0.3, 0.8) * 3.0, vViewDir.y * 0.5 + 0.5 );\n\t\n    \/\/ Sun\n    float NdotV = dot( g_vSunDir, vViewDir );\n    vResult.rgb += smoothstep( cos(radians(.7)), cos(radians(.5)), NdotV ) * g_vSunColor * 5000.0;\n    \n\treturn vResult;\t\n}\n\nfloat Env_GetFogFactor(const in float fDist)\n{\n\tfloat kFogDensity = 0.0015;\n\treturn exp(fDist * -kFogDensity);\t\n}\n\nvec3 Env_GetFogColor(const in vec3 vDir)\n{\n\treturn vec3(0.4, 0.5, 0.6) * 2.0;\t\t\n}\n\nvec3 Env_ApplyAtmosphere( const in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist)\n{\n\tfloat fFogFactor = Env_GetFogFactor( fDist );\n\tvec3 vFogColor = Env_GetFogColor( vRayDir );\n\t\n\tEnv_AddDirectionalLightFlareToFog( vFogColor, vRayDir, g_vSunDir, g_vSunColor * 3.0);\n    \n    vec3 vResult = mix( vFogColor, vColor, fFogFactor );\n\n    if ( g_sceneState.fEffect == 1.0 )\n    {        \n        vec3 vWorldPos = vRayOrigin + vRayDir * fDist;\n        if ( vWorldPos.y < 0.001 )\n        {\n\t\t\tvResult = vec3(1.0, 1.0, 0.02) * 0.25;          \n            vWorldPos.z -= iTime * 10.0;\n        }\n        else\n        {\n\t\t\tvResult = vec3(0.01, 1.0, 0.02) * 20.0;\n        }\n\n        vec3 vFractPos = abs(fract(vWorldPos - 0.2) - 0.5) * 2.0;\n        float f = max( max( vFractPos.x, vFractPos.y ), vFractPos.z );\n        vResult *= pow( f, 20.0 );\n    }\n\n    return vResult;\t    \n}\n\n\/\/ FX\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel1, (uv+ 0.5)\/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n\nfloat FX_SmokeDensity(vec3 vPos)\n{\n    vec2 vProfile = vec2( vPos.z, length( vPos.xy) );\n    \n    vec2 vClamped;\n    vClamped.x = clamp( vProfile.x, 0.0, 10000.0 );\n    vClamped.y = 0.0;\n    \n    float t = vClamped.x \/ 500.0;\n    \n    float r = (1.0 - exp2( t * -30.0 )) * 10.0;\n    \/\/float r = sqrt(t) * 10.0;\n    \n    \n    float l = length( vProfile - vClamped ) - r;\n    \n    \/\/ gradual fade\n    return l * exp2( t * -0.05 ) * g_sceneState.fDustTrail;\n}\n\nfloat FX_Noise( vec3 vPos )\n{\n    vec3 vNoisePos = vPos;\n    return noise( vNoisePos );\n}\n\nvec4 FX_ColDensity( vec3 vPos )\n{\n    float density = 0.0;\n\n \tvec3 vLocalCarPos = vPos - g_sceneState.vCarPos;\n    \n    vec3 vSmokePos = vec3( 0, 0.0, 10.0 );\n        \n    float n1 = FX_SmokeDensity( vLocalCarPos - vSmokePos );\n    vec3 vOffsetPos = vLocalCarPos + g_vSunDir * 0.3;\n    float n2 = FX_SmokeDensity( vOffsetPos - vSmokePos);\n    \n    vec3 vNoisePos = vLocalCarPos - vSmokePos;\n    float fNoiseSpeed = 50.0;\n    float fFreq = 3.5;\n    if ( vLocalCarPos.z > 10.0 )\n    {\n        vNoisePos = vPos;\n        fFreq = 1.5;\n        fNoiseSpeed = 20.0;\n        vNoisePos.y -= iTime;\n    }\n    else\n    {\n    \tvNoisePos.z -= iTime * 30.0;\n        \n    }\n\n    float fNoise1 = FX_Noise( vNoisePos * fFreq );\n    float fNoise2 = FX_Noise( (vNoisePos + g_vSunDir * 0.3) * fFreq );\n    \n    n1 += fNoise1 * 3.0;\n    n2 += fNoise2 * 3.0;\n    \n    if ( n1 < 0.0 )\n        density = min( 1.0, -n1 * 0.1);\n    else\n    \tdensity = -n1;\n    \n    float sh = clamp( (n2 - n1)* 0.5 + 0.1, 0.0, 1.0 );\n    \n    vec3 vCol = g_vSunColor * sh + g_vAmbientColor * 0.4;\n    \n    \/\/ Darken middle\n    vCol *= clamp( 1.0 + n1 * 0.25, 0.0, 1.0);\n    vCol *= vec3(1.0, 0.8, 0.65);\n\n    vec3 vMirror = vLocalCarPos;\n    vMirror.x = abs(vMirror.x);\n    \n    vec3 vFlamePos = vMirror - vec3( +1.4, 1.1, 5.2 );\n    float fFlameDist = length( vFlamePos.xy ) - 0.4;\n    fFlameDist = max( fFlameDist, -vFlamePos.z - 0.5 );\n    float fFlameFade = clamp( (vFlamePos.z + 0.2 ) * 0.25, 0.0, 1.0 );\n    fFlameDist += fFlameFade * fFlameFade;\n    \n    float fl = fFlameDist - fNoise1 * 0.5;\n    fl += 0.7 * (1.0 - g_sceneState.fThruster);\n    if ( fl < 0.0)\n    {\n        density = -fl * 0.5;\n    \tvCol = mix( vec3(0.01, 0.01, 1.) * 30.0, vec3( 1.0, 0.2, 0.05) * 30.0, pow( fFlameFade, 0.05) );\n    }\n    else\n    {\n        density = max( density, -fl );\n    }\n    \n    \/\/vCol *= 10.0;\n    \n    return vec4(vCol, density);\n}\n\nvec3 FX_Apply( in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist)\n{\n    float t= 0.03;\n    float f = 1.0;\n    float st = 0.03;\n    for(int iter=0; iter<64; iter++)\n    {\n        if( t > fDist )\n        {\n            break;\n        }\n        \n        vec3 p = vRayOrigin + vRayDir * t;\n        vec4 vEffect = FX_ColDensity( p );\n        if ( vEffect.w >= 0.0 )\n        {\n        \tvColor = mix(vColor, vEffect.rgb, f * vEffect.w);\n        \tf = f * (1.0 - vEffect.w);\n        \n            t += st;\n\t\t\tst += (0.04+st*0.012);     \n        }\n        else\n        {\n\t\t\tt += -vEffect.w + 0.03;\n            st = 0.03;\n        }\n            \n    }\n    \n    return vColor;\n}\n\n\/\/ Camera \n\n\nCameraState GetCameraState_MouseOrbitCar()\n{\n    CameraState camera;\n\n    float fAngle = (iMouse.x \/ iResolution.x) * 3.14 * 2.0;\n    float fDist = (iMouse.y \/ iResolution.y) * 40.0;\n    \n    float fHeight = 1.0;\n    \n    camera.vTarget = g_sceneState.vCarPos + vec3( 0.0, 1.0, 0.5 );\n    camera.vPos = camera.vTarget + vec3( sin(fAngle) * fDist, fHeight, cos(fAngle) * fDist );\n    camera.fFov = 20.0;\n    \n    return camera;\n}\n\nstruct Sequence\n{\n    float fDt;\n    float fTime;\n    float fLength;\n    float fBlend;\n    float fSmoothBlend;\n};\n    \nSequence Sequence_Init( float fTime, float fDt )\n{\n    Sequence seq;\n    seq.fDt = fDt;\n    seq.fTime = fTime + fDt;\n    seq.fLength = 0.0;\n    seq.fBlend = 0.0;\n    seq.fSmoothBlend = 0.0;\n    return seq;\n}\n\nbool Sequence_Next( inout Sequence seq, float fLength )\n{\n    seq.fTime -= seq.fLength;\n    seq.fLength = fLength;\n    seq.fBlend = seq.fTime \/ fLength;\n    seq.fSmoothBlend = smoothstep( 0.0, 1.0, seq.fBlend );\n    \n    float fTestTime = seq.fTime - seq.fDt;\n    return fTestTime >= 0.0 && fTestTime < fLength;\n}\n\nstruct CarInt\n{\n    float s;\n    float u;\n    float a;\n};\n    \nvoid CarInt_Update( inout CarInt carInt, float fTime )\n{\n    carInt.s += carInt.u * fTime + .5 * carInt.a * fTime * fTime;\n    carInt.u += carInt.a * fTime;\n}\n\nfloat CarInt_GetDisplacement( CarInt carInt, float fTime )\n{\n    return carInt.s + carInt.u * fTime + .5 * carInt.a * fTime * fTime;    \n}\n\nfloat CarInt_GetVelocity( CarInt carInt, float fTime )\n{\n    return carInt.u + carInt.a * fTime;\n}\n\nvoid GetSceneState( out SceneState scene, out CameraState camera, float fTime, float fDt )\n{\n    scene.vCarPos = vec3(0.0);\n    scene.vCarPos.y -= 0.7;\n    scene.fThruster = 0.0;\n    scene.fDustTrail = 0.0;\n    scene.fCarVel = 0.0;\n    scene.fEffect = 0.0;\n\n    camera.vPos = vec3( 0.0, 1.0, -10.0 );\n    camera.vTarget = vec3( 0.0, 0.0, 0.0 );\n    camera.fFov = 15.0;\n    camera.fAperture = 0.5;\n    \n    float fCameraShake = 0.0;\n\n    \/\/scene.fThruster = clamp( sin(iTime) * 0.5 + 0.5, 0.0, 1.0);\n    \/\/scene.fDustTrail = scene.fThruster;\n    \/\/    scene.vCarPos.z = -iTime * 100.0;\/\/343.0;\n        \n    Sequence seq = Sequence_Init( fTime, fDt );\n\n    CarInt carInt;\n    carInt.s = 0.0;\n    carInt.u = 0.0;\n    carInt.a = 0.0;\n    \n    if ( Sequence_Next( seq, 8.0 ) )\n    {\n\t    scene.vCarPos.y = 0.0;\n    }\n\n    \/\/ Initial Vel\n    carInt.u = 100.0;    \n    if ( Sequence_Next( seq, 4.0 ) )\n    {\n        scene.vCarPos.z = -CarInt_GetDisplacement( carInt, seq.fTime );\n        scene.fCarVel = -CarInt_GetVelocity( carInt, seq.fTime );\n\n\t    camera.vTarget = vec3( 0.0, 1.0, -100.0 );\n        camera.vPos = camera.vTarget + vec3( 10.0, -0.5, -5.0 );\n        \n        \/\/camera.vTarget = camera.vPos + normalize(camera.vTarget - camera.vPos) * 100.0 * (1.0 - seq.fBlend * 0.9);\n    \t\/\/camera.fAperture = 1.5;\n    }\n    \n    CarInt_Update( carInt, seq.fLength );\n\n    \/\/ vel +50 in 10 secs\n    carInt.a = 100.0 \/ 15.0;    \n\n    if ( Sequence_Next( seq, 5.0 ) )\n    {\n        scene.vCarPos.z = -CarInt_GetDisplacement( carInt, seq.fTime );\n        scene.fCarVel = -CarInt_GetVelocity( carInt, seq.fTime );\n\n\t    camera.vTarget = scene.vCarPos + vec3( 0.0, 1.0, -15.0 );\n        camera.vTarget.z += seq.fSmoothBlend * 20.0;\n        camera.vPos = camera.vTarget + vec3( -8.0, 1.5, -3.0 );\n        camera.fFov = 20.0;\n    \tcamera.fAperture = 0.5;\n        fCameraShake = 1.0;\n    }\n    CarInt_Update( carInt, seq.fLength );\n    \n    if ( Sequence_Next( seq, 5.0 ) )\n    {\n        scene.vCarPos.z = -CarInt_GetDisplacement( carInt, seq.fTime );\n        scene.fCarVel = -CarInt_GetVelocity( carInt, seq.fTime );\n\n\t    camera.vTarget = scene.vCarPos + vec3( 0.0, 1.0, -4.5 );\n        camera.vPos = camera.vTarget + mix( vec3( -4.0, 2.0, -20.0 ), vec3( -30.0, 1.0, 40.0 ) ,seq.fBlend );\n        camera.vTarget.z += seq.fBlend * 10.0;\n        camera.fFov = mix( 25.0, 15.0, seq.fBlend );\n    \tcamera.fAperture = 1.5;\n        fCameraShake = 1.0;\n    }    \n    CarInt_Update( carInt, seq.fLength );\n    \n    if ( Sequence_Next( seq, 5.0 ) )\n    {\n        scene.vCarPos.z = -CarInt_GetDisplacement( carInt, seq.fTime );\n        scene.fCarVel = -CarInt_GetVelocity( carInt, seq.fTime );\n\n\t    camera.vTarget = scene.vCarPos + vec3( 0.0, 1.5, -2.5 );\n        camera.vPos = camera.vTarget + mix( vec3( 10.0, 3.0, -20.0 ), vec3( -10.0, 3.0, -20.0 ) ,seq.fSmoothBlend );\n        camera.fFov = 8.0;\n    \tcamera.fAperture = 1.5;\n        fCameraShake = 1.0;\n    }\n    \n    CarInt_Update( carInt, seq.fLength );\n\n    carInt.a = 0.0;    \n    if ( Sequence_Next( seq, 3.0 ) )\n    {\n        scene.vCarPos.z = -CarInt_GetDisplacement( carInt, seq.fTime );\n        scene.fCarVel = -CarInt_GetVelocity( carInt, seq.fTime );\n\n\t    camera.vTarget = scene.vCarPos + vec3( 1.5, 1.4, 5.5 );\n        camera.vPos = camera.vTarget + vec3( 3.0, -0.5 + seq.fSmoothBlend * 2.0, 4.0+ pow( seq.fBlend, 4.0) * 16.0 );\n        camera.fFov = 20.0;\n    \tcamera.fAperture = 0.5;\n        \n        scene.fThruster = seq.fSmoothBlend;\n        fCameraShake = 1.0;\n    }\n\n    \/\/ vel +150 in 10 secs\n    carInt.a = 150.0 \/ 30.0;    \n    if ( Sequence_Next( seq, 5.0 ) )\n    {\n        scene.vCarPos.z = -CarInt_GetDisplacement( carInt, seq.fTime );\n        scene.fCarVel = -CarInt_GetVelocity( carInt, seq.fTime );\n\n        \/\/ Tail fin cam\n\t    camera.vTarget = scene.vCarPos + vec3( 0.0, 1.8, 3.5 );\n        camera.vPos = camera.vTarget + vec3( 0.0, 1.2, 4.0 );\n        camera.fFov = 35.0;\n    \tcamera.fAperture = 0.3;\n        \n        scene.fThruster = 1.0;\n        scene.fDustTrail = seq.fBlend * 0.1;\n        fCameraShake = 1.0;\n    }\n    \n    CarInt_Update( carInt, seq.fLength );\n\n\n    if ( Sequence_Next( seq, 5.0 ) )\n    {\n        scene.vCarPos.z = -CarInt_GetDisplacement( carInt, seq.fTime );\n        scene.fCarVel = -CarInt_GetVelocity( carInt, seq.fTime );\n\n\t    camera.vTarget = scene.vCarPos + vec3( 0.0, 1.0, seq.fSmoothBlend * 10.5 );\n        camera.vPos = camera.vTarget + vec3( 10.0, 2.0, -30.0 );\n        camera.fFov = 15.0;\n    \tcamera.fAperture = 1.0;\n\n        scene.fThruster = 1.0;\n        scene.fDustTrail = 0.1 + seq.fSmoothBlend * 0.9;\n        fCameraShake = 1.0;\n    }\n    \n    CarInt_Update( carInt, seq.fLength );\n\n    if ( Sequence_Next( seq, 15.0 ) )\n    {\n        scene.vCarPos.z = -CarInt_GetDisplacement( carInt, seq.fTime );\n        scene.fCarVel = -CarInt_GetVelocity( carInt, seq.fTime );\n\n        camera.vTarget = scene.vCarPos + mix( vec3( 0.0, 1.0, 20.0 ), vec3( 0.0, 1.0, -15.0 ), seq.fBlend );\n\t    camera.vPos = camera.vTarget + vec3( -8.0, 2.0, 4.5 );\n        camera.fFov = 20.0;\n    \tcamera.fAperture = 0.4;\n\n        scene.fThruster = 1.0;\n        scene.fDustTrail = 1.0;\n        fCameraShake = 1.0;\n    }\n    CarInt_Update( carInt, seq.fLength );\n    \n    if ( Sequence_Next( seq, 5.0 ) )\n    {\n        scene.vCarPos.z = -CarInt_GetDisplacement( carInt, seq.fTime );\n        scene.fCarVel = -CarInt_GetVelocity( carInt, seq.fTime );\n\n        \/\/ Tail fin cam\n\t    camera.vTarget = scene.vCarPos + vec3( 0.0, 1.8, 3.5 );\n        camera.vPos = camera.vTarget + vec3( 0.0, 1.2, 4.0 );\n        camera.fFov = 45.0;\n    \tcamera.fAperture = 0.3;\n        \n        scene.fThruster = 1.0;\n        scene.fDustTrail = 1.0;\n        fCameraShake = 1.0;\n    }\n    CarInt_Update( carInt, seq.fLength );\n\n    carInt.a = 0.0;    \n    if ( Sequence_Next( seq, 17.0 ) )\n    {\n        scene.vCarPos.z = -CarInt_GetDisplacement( carInt, seq.fTime );\n        scene.fCarVel = -CarInt_GetVelocity( carInt, seq.fTime );\n\n        camera.vPos = vec3(0.0);\n        camera.vPos.z = -CarInt_GetDisplacement( carInt, 0.0 );\n        \n        camera.vPos += vec3( 12.0, 0.5, -650.0 );\n\t    camera.vTarget = camera.vPos + vec3( -4.0, 0.0, 10.0 );\n        \n        camera.fFov = 10.0;\n    \tcamera.fAperture = 0.5;\n        \n        scene.fThruster = 1.0;\n        scene.fDustTrail = 1.0;\n        fCameraShake = 1.0;\n    }\n    \n    camera.vTarget.y += (noise(camera.vPos * 0.2) - 0.5) * fCameraShake \/ length(camera.vTarget - camera.vPos);\n    \n    if ( Sequence_Next( seq, 1000.0 ) )\n    {\n        scene.vCarPos = vec3(0.0, 0.0, 0.0);\n        scene.fCarVel = 0.0;\n\n\t    camera.vTarget = scene.vCarPos + vec3( 0.0, 0.0, 2.0 );\n        camera.vPos = camera.vTarget + vec3(sin(seq.fTime * 0.4) * 40.0, 20.0, cos(seq.fTime * 0.4) * 40.0 );        \n        \n        camera.fFov = 10.0;\n    \tcamera.fAperture = 5.0;\n        \n        scene.fThruster = 0.0;\n        scene.fDustTrail = 0.0;\n        fCameraShake = 0.0;\n\n        scene.fEffect = 1.0;\n\t}\n    \n    \/\/camera = GetCameraState_MouseOrbitCar();\n}\n\nvoid mainImage( out vec4 vFragColor, in vec2 vFragCoord )\n{\n    vec2 vUV = vFragCoord.xy \/ iResolution.xy; \n\n    float fTime = iTime;\n    \n    \/\/ Scrubbing\n    if (false)\n    if (iMouse.z > 0.0 )\n    {\n        fTime = iMouse.x * 100.0 \/ iResolution.x;\n    }\n       \n\n    CameraState camPrev;       \n    SceneState temp;\n    GetSceneState( temp, camPrev, fTime, - 1.0 \/ 60.0 );\n    \n    CameraState cam;       \n    GetSceneState( g_sceneState, cam, fTime, 0.0 );\n    \n    vec3 vRayOrigin, vRayDir;\n    Cam_GetCameraRay( vUV, cam, vRayOrigin, vRayDir );\n    \n    \/\/float l = abs( vRayDir.y ) \/ vRayOrigin.y;\n    \/\/float fAmount = .0001 \/ (l + 0.02);\n    \/\/vRayDir.yz += FBM_DXY(vUV * 30.0, vec2(0.0, -iTime * 3.0), 0.5, -0.0 ).xy * fAmount;\n \n    if ( iTime < 8.0 )        \n    {      \n        vec2 vCoord = vUV - 0.5;\n        vCoord.x *= iResolution.x \/ iResolution.y;\n        vRayOrigin = vec3( 100.0, 100.0, 100.0 );\n        vRayDir = vec3(0.0, -1.0, 0.0);\n\n        vec2 vRegion;\n        \n        vRegion = (vCoord + vec2(0,0.25)) * vec2(1.0, 2.0) * 0.5 + 0.5;\n        if ( vRegion.x >= 0.0 && vRegion.x < 1.0 && vRegion.y >= 0.0 && vRegion.y < 1.0 )\n        {\n            vec2 vRangeMin = vec2( -13.0, -7.5 );\n            vec2 vRangeMax = vec2( 18.0, 7.5 );\n            vRayOrigin.zx = mix(vRangeMin, vRangeMax, vRegion );\n            vRayOrigin.y = 20.0;\n            vRayDir = vec3(0.0, -1.0, 0.0);\n        }\n\n        vRegion = (vCoord + vec2(0,-0.78)) * vec2(1.0, 2.0) * 0.5 + 0.5;\n        if ( vRegion.x >= 0.0 && vRegion.x < 1.0 && vRegion.y >= 0.0 && vRegion.y < 1.0 )\n        {\n            vec2 vRangeMin = vec2( -13.0, 0.1 );\n            vec2 vRangeMax = vec2( 18.0, 15. );\n            vRayOrigin.zy = mix(vRangeMin, vRangeMax, vRegion );\n            vRayOrigin.x = 20.0;\n            vRayDir = vec3(-1.0, 0.0, 0.0);\n        }\n        \n        vRegion = (vCoord + vec2(.3,-0.12)) * vec2(3.0, 6.0) * 0.5 + 0.5;\n        if ( vRegion.x >= 0.1 && vRegion.x < 0.9 && vRegion.y >= 0.0 && vRegion.y < 0.85 )\n        {\n            vec2 vRangeMin = vec2( -3.5, 0.1 );\n            vec2 vRangeMax = vec2( 3.5, 3.5 );\n            vRayOrigin.xy = mix(vRangeMin, vRangeMax, vRegion );\n            vRayOrigin.z = -20.0;\n            vRayDir = vec3(0.0, 0.0, 1.0);\n        }\n\n        vRegion = (vCoord + vec2(-0.3,-0.12)) * vec2(3.0, 6.0) * 0.5 + 0.5;\n        if ( vRegion.x >= 0.1 && vRegion.x < 0.9 && vRegion.y >= 0.0 && vRegion.y < 0.85 )\n        {\n            vec2 vRangeMin = vec2( -3.5, 0.1 );\n            vec2 vRangeMax = vec2( 3.5, 3.5 );\n            vRayOrigin.xy = mix(vRangeMin, vRangeMax, vRegion );\n            vRayOrigin.z = 20.0;\n            vRayDir = vec3(0.0, 0.0, -1.0);\n        }\n    }\n    \n\tvec4 vColorLinAmdDepth = Scene_GetColorAndDepth( vRayOrigin, vRayDir );    \n    vColorLinAmdDepth.rgb = max( vColorLinAmdDepth.rgb, vec3(0.0) );\n        \n    vFragColor = vColorLinAmdDepth;\n    \n    if ( vColorLinAmdDepth.r > 40000.0 || vColorLinAmdDepth.g > 40000.0 || vColorLinAmdDepth.b > 40000.0 )\n    {\n        vFragColor = vec4(0.0);\n    }\n    \/*\n    if ( vColorLinAmdDepth.r > 400.0 || vColorLinAmdDepth.g > 400.0 || vColorLinAmdDepth.b > 400.0 )\n    {\n        vFragColor.rgb = vec3(1.0 * (sin(iTime * 10.0) * 0.5 + 0.5), 0.0, 0.0);\n    }\n    else\n    {\n        vFragColor.rgb *= .25;\n\t}\n\t*\/    \n    \n    Cam_StoreState( vec2(0,0), cam, vFragColor, vFragCoord );\n    \n    Cam_StoreState( vec2(2,0), camPrev, vFragColor, vFragCoord );\n    \n\tStoreVec4( vec2(4,0), vec4(g_sceneState.fCarVel \/ 60.0), vFragColor, vFragCoord );\n}\n\n#if 1\nvoid mainVR( out vec4 vFragColor, in vec2 vFragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{   \n    \n    float fTime = iTime;\n    \n    CameraState camPrev;       \n    SceneState temp;\n    GetSceneState( temp, camPrev, fTime, - 1.0 \/ 60.0 );\n    \n    CameraState cam;       \n    GetSceneState( g_sceneState, cam, fTime, 0.0 );\n    \n    vec3 vRayOrigin, vRayDir;\n    \n    Cam_GetCameraRay( vec2(0.5), cam, vRayOrigin, vRayDir );\n    \n    vRayOrigin += fragRayOri;\n    vRayDir = fragRayDir;\n    \n    \n\tvec4 vColorLinAmdDepth = Scene_GetColorAndDepth( vRayOrigin, vRayDir );    \n    vColorLinAmdDepth.rgb = max( vColorLinAmdDepth.rgb, vec3(0.0) );\n        \n    vFragColor = vColorLinAmdDepth;\n    \n    if ( vColorLinAmdDepth.r > 40000.0 || vColorLinAmdDepth.g > 40000.0 || vColorLinAmdDepth.b > 40000.0 )\n    {\n        vFragColor = vec4(0.0);\n    }\n    \n    \n    Cam_StoreState( vec2(0,0), cam, vFragColor, vFragCoord );\n    \n    Cam_StoreState( vec2(2,0), camPrev, vFragColor, vFragCoord );\n    \n\tStoreVec4( vec2(4,0), vec4(g_sceneState.fCarVel \/ 60.0), vFragColor, vFragCoord );    \n}\n#endif\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\/\/ Depth of field \/ motion blur effect\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Data Storage\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec4 LoadVec4( sampler2D sampler, in ivec2 vAddr )\n{\n    return texelFetch( sampler, vAddr, 0 );\n}\n\nvec3 LoadVec3( sampler2D sampler, in ivec2 vAddr )\n{\n    return LoadVec4( sampler, vAddr ).xyz;\n}\n\nbool AtAddress( vec2 p, vec2 c ) { return all( equal( floor(p), floor(c) ) ); }\n\nvoid StoreVec4( in vec2 vAddr, in vec4 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in vec2 vAddr, in vec3 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Camera\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nstruct CameraState\n{\n    vec3 vPos;\n    vec3 vTarget;\n    float fFov;\n    float fAperture;\n};\n    \nvoid Cam_LoadState( out CameraState cam, sampler2D sampler, ivec2 addr )\n{\n    vec4 posAperture = LoadVec4( sampler, addr + ivec2(0,0) );\n    cam.vPos = posAperture.xyz;\n    cam.fAperture = posAperture.w;\n    vec4 targetFov = LoadVec4( sampler, addr + ivec2(1,0) );\n    cam.vTarget = targetFov.xyz;\n    cam.fFov = targetFov.w;\n}\n\nvoid Cam_StoreState( vec2 addr, const in CameraState cam, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec4( addr + vec2(0,0), vec4( cam.vPos, cam.fAperture ), fragColor, fragCoord );\n    StoreVec4( addr + vec2(1,0), vec4( cam.vTarget, cam.fFov ), fragColor, fragCoord );    \n}\n\nmat3 Cam_GetWorldToCameraRotMatrix( const CameraState cameraState )\n{\n    vec3 vForward = normalize( cameraState.vTarget - cameraState.vPos );\n\tvec3 vRight = normalize( cross(vec3(0, 1, 0), vForward) );\n\tvec3 vUp = normalize( cross(vForward, vRight) );\n    \n    return mat3( vRight, vUp, vForward );\n}\n\nvec2 Cam_GetViewCoordFromUV( const in vec2 vUV )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x \/ iResolution.y;\n\n\treturn vWindow;\t\n}\n\nvoid Cam_GetCameraRay( const vec2 vUV, const CameraState cam, out vec3 vRayOrigin, out vec3 vRayDir )\n{\n    vec2 vView = Cam_GetViewCoordFromUV( vUV );\n    vRayOrigin = cam.vPos;\n    float fPerspDist = 1.0 \/ tan( radians( cam.fFov ) );\n    vRayDir = normalize( Cam_GetWorldToCameraRotMatrix( cam ) * vec3( vView, fPerspDist ) );\n}\n\nvec2 Cam_GetUVFromWindowCoord( const in vec2 vWindow )\n{\n    vec2 vScaledWindow = vWindow;\n    vScaledWindow.x *= iResolution.y \/ iResolution.x;\n\n    return vScaledWindow * 0.5 + 0.5;\n}\n\nvec2 Cam_WorldToWindowCoord(const in vec3 vWorldPos, const in CameraState cameraState )\n{\n    vec3 vOffset = vWorldPos - cameraState.vPos;\n    vec3 vCameraLocal;\n\n    vCameraLocal = vOffset * Cam_GetWorldToCameraRotMatrix( cameraState );\n\t\n    vec2 vWindowPos = vCameraLocal.xy \/ (vCameraLocal.z * tan( radians( cameraState.fFov ) ));\n    \n    return vWindowPos;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\nfloat GetCoC( float fDistance, float fPlaneInFocus, float fAperture )\n{\n\t\/\/ http:\/\/http.developer.nvidia.com\/GPUGems\/gpugems_ch23.html\n\n    float fFocalLength = 0.15;\n    \n    if ( iMouse.z > 0.0 )\n    {\n        fFocalLength += (iMouse.y \/ iResolution.y) * 0.5;\n    }\n    \n\treturn abs(fAperture * (fFocalLength * (fDistance - fPlaneInFocus)) \/\n          (fDistance * (fPlaneInFocus - fFocalLength)));  \n}\n\n\/\/ Random\n\n#define MOD2 vec2(4.438975,3.972973)\n#define HASHSCALE1 443.8975\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n#define HASHSCALE4 vec3(443.897, 441.423, 437.195, 444.129)\n\nfloat Hash( float p ) \n{\n    \/\/ https:\/\/www.shadertoy.com\/view\/4djSRW - Dave Hoskins\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);    \n}\n\nvec2 Hash23(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n\n#define MOTION_BLUR_TAPS 32\n\nfloat fGolden = 3.141592 * (3.0 - sqrt(5.0));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vUV = fragCoord.xy \/ iResolution.xy;\n\n    \/\/ output linear color\n    \/\/fragColor = texture( iChannel0, vUV );\n    \/\/return;\n    \n    vec4 vSample = textureLod( iChannel0, vUV, 0.0 ).rgba;\n\t\n    float fDepth = abs(vSample.w);\n    \n    CameraState cameraStateCurr;\n    Cam_LoadState( cameraStateCurr, iChannel0, ivec2(0,0) );\n    \n    CameraState cameraStatePrev;\n    Cam_LoadState( cameraStatePrev, iChannel0, ivec2(2,0) );\n\n    vec4 vCarVel = LoadVec4( iChannel0, ivec2(4,0) );\n   \n    float fShutterAngle = 0.5;\n    \n    if ( iMouse.z > 0.0 )\n    {\n        fShutterAngle = (iMouse.x \/ iResolution.x);\n    }\n    \n    \n    cameraStatePrev.vPos = mix( cameraStateCurr.vPos, cameraStatePrev.vPos, fShutterAngle );\n    cameraStatePrev.vTarget = mix( cameraStateCurr.vTarget, cameraStatePrev.vTarget, fShutterAngle );\n    cameraStatePrev.fFov = mix( cameraStateCurr.fFov, cameraStatePrev.fFov, fShutterAngle );\n    cameraStatePrev.fAperture = mix( cameraStateCurr.fAperture, cameraStatePrev.fAperture, fShutterAngle );\n        \n    \/\/cameraStatePrev.vTarget.z -= 2.0;\n    \/\/cameraStatePrev.vPos.z -= 2.0;\n    \n    \/\/cameraStatePrev.fFov -= 10.0;\n\n    if( vSample.a < 0.0 )\n    {\n    \tcameraStatePrev.vTarget.z += vCarVel.x * fShutterAngle;\n    \tcameraStatePrev.vPos.z += vCarVel.x * fShutterAngle;\n        \n    }    \n\n\n    \n\tvec3 vCameraPos, vRayDir;\n    Cam_GetCameraRay( vUV, cameraStateCurr, vCameraPos, vRayDir );\n        \n    vec3 vWorldPos = vCameraPos + vRayDir * fDepth;\n    \n    \/\/fragColor.xyz = fract( vWorldPos );\n    \/\/fragColor.a = 1.0;\n    \/\/return;\n    \n    vec2 vPrevWindow = Cam_WorldToWindowCoord( vWorldPos, cameraStatePrev );\n    vec2 vPrevUV = Cam_GetUVFromWindowCoord( vPrevWindow );\n\n    \/\/ No motion blur for FG objects\n    \/\/if( vSample.a < 0.0 )\n    \/\/{\n      \/\/  vPrevUV = vUV;\n    \/\/}\n        \n\tvec3 vResult = vec3(0.0);\n    \n    float fTot = 0.0;\n    \n    float fPlaneInFocus = length(cameraStateCurr.vPos - cameraStateCurr.vTarget);\n    \n    float fCoC = GetCoC( abs(fDepth), fPlaneInFocus, cameraStateCurr.fAperture );\n    \n    float r = 1.0;\n    vec2 vangle = vec2(0.0,fCoC); \/\/ Start angle\n    \n    vResult.rgb = vec3(0.0);\/\/vSample.rgb * fCoC;\n    fTot += 0.0;\/\/fCoC;\n    \n    float fMotionBlurTaps = float(MOTION_BLUR_TAPS);\n    \n    float fAspect = iResolution.y \/ iResolution.x;\n    \n    float f = 0.0;\n    float fIndex = 0.0;\n    for(int i=1; i<MOTION_BLUR_TAPS; i++)\n    {\n        vec2 vTapUV = mix( vUV, vPrevUV, f - .5);\n                \n        vec2 vRand = Hash23( vec3( vUV.x, vUV.y, fract(iTime * .123 + fIndex * 1.234) ) );\n        \/\/float fRand = Hash2( iTime + fIndex + vUV.x + vUV.y * 12.345);\n        \n        \/\/ http:\/\/blog.marmakoide.org\/?p=1\n        \n        float fTheta = vRand.x * 3.14 * 2.0;\/\/fRand * fGolden * fMotionBlurTaps;\n        \/\/float fRadius = fCoC * sqrt( vRand.y ); \/\/ uniform disc\n        float fRadius = fCoC * pow( vRand.y, 0.4 ); \/\/ less dense centre\n        \n        \/\/float fRadius = fCoC * sqrt( fRand * fMotionBlurTaps ) \/ sqrt( fMotionBlurTaps );        \n        \n        vTapUV += vec2( sin(fTheta) * fAspect, cos(fTheta) ) * fRadius;\n        \n        \/\/vTapUV.y = abs( vTapUV.y );\n        \n        vec4 vTapSample = textureLod( iChannel0, vTapUV, 0.0 ).rgba;        \n        if( vTapUV.y < 1.0 \/ iResolution.y )\n        {\n            vTapSample = vec4(0.0);\n        }        \n        \/\/if(vTapUV.y > 0.0)\n        if( sign(vTapSample.a) == sign(vSample.a) )\n        {\n  \t\t  \tfloat fCurrCoC = GetCoC( abs(vTapSample.a), fPlaneInFocus, cameraStateCurr.fAperture );\n            \n            float fWeight = fCurrCoC;\n            \n    \t\tvResult += vTapSample.rgb * fWeight;\n        \tfTot += fWeight;\n        }\n        f += 1.0 \/ fMotionBlurTaps;\n        fIndex += 1.0;\n    }\n    vResult \/= fTot;\n        \n    \/\/ Draw depth\n    \/\/vFinal = vec3(1.0) \/ abs(vSample.a);    \n    \n    \/\/ passthrough depth\n\tfragColor = vec4(vResult, vSample.a);\n\n    Cam_StoreState( vec2(0,0), cameraStateCurr, fragColor, fragCoord );\n}\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"XdfGzn","filepath":"\/media\/a\/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","previewfilepath":"\/media\/ap\/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","type":"music","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"\/media\/previz\/buffer03.png","previewfilepath":"\/media\/previz\/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\/\/ Bloom\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 gBloomSize = min( vec2(320.0, 240.0), iResolution.xy );\n    \n\tvec2 vUV = fragCoord.xy \/ gBloomSize;\n    \n    if ( vUV.x > 1.0 ) discard;\n    if ( vUV.y > 1.0 ) discard;\n\n    \/\/ output linear color\n    \/\/fragColor = texture( iChannel0, vUV );\n    \/\/return;\n    \n    #define KERNEL_SIZE 8\n    #define BLOOM_STRENGTH 6.0\n    #define KERNEL_SIZE_F float(KERNEL_SIZE)    \n    \n\tvec3 vResult = vec3(0.0);\n    \n    float fTot = 0.0;\n    \n    float fY = -KERNEL_SIZE_F;\n    for( int y=-KERNEL_SIZE; y<=KERNEL_SIZE; y++ )\n    {\n        float fX = -KERNEL_SIZE_F;\n\t    for( int x=-KERNEL_SIZE; x<=KERNEL_SIZE; x++ )\n        {            \n\n            vec2 vOffset = vec2( fX, fY );\n            vec2 vTapUV =  (fragCoord.xy + vOffset + 0.5) \/ gBloomSize;\n\n            vec4 vTapSample = textureLod( iChannel0, vTapUV, 0.0 ).rgba;\n\t        if( vTapUV.y < 1.0 \/ iResolution.y )\n            {\n               vTapSample = vec4(0.0);\n            }\n            \n            vec2 vDelta = vOffset \/ KERNEL_SIZE_F;\n            \n            float f = dot( vDelta, vDelta );\n            float fWeight = exp2( -f * BLOOM_STRENGTH );\n            vResult += vTapSample.xyz * fWeight;\n            fTot += fWeight;\n            \n\t        fX += 1.0;\n        }\n        \n        fY += 1.0;\n    }\n    vResult \/= fTot; \n    \n    vec4 vPrevSample = textureLod( iChannel1, vUV* gBloomSize \/ iResolution.xy, 0.0 ).rgba;\n    vResult = max( vResult, vPrevSample.xyz * 0.3 );\n    \/\/vResult += vPrevSample.xyz * 0.9;\n    \n\tfragColor = vec4(vResult, 1.0);\n}\n","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsfGRr","channel":0}],"code":"#define INVERT_STEREO\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Camera\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nstruct CameraState\n{\n    vec3 vPos;\n    vec3 vTarget;\n    float fFov;\n    float fAperture;\n};\n   \nmat3 Cam_GetWorldToCameraRotMatrix( const CameraState cameraState )\n{\n    vec3 vForward = normalize( cameraState.vTarget - cameraState.vPos );\n\tvec3 vRight = normalize( cross(vec3(0, 1, 0), vForward) );\n\tvec3 vUp = normalize( cross(vForward, vRight) );\n    \n    return mat3( vRight, vUp, vForward );\n}    \n\nstruct SceneState\n{\n    vec3 vCarPos;\n    float fThruster;\n    float fDustTrail;\n    float fCarVel;\n};  \n    \nSceneState g_sceneState;\n\nstruct Sequence\n{\n    float fTime;\n    float fLength;\n    float fBlend;\n    float fSmoothBlend;\n};\n    \nSequence Sequence_Init( float fTime )\n{\n    Sequence seq;\n    seq.fTime = fTime;\n    seq.fLength = 0.0;\n    seq.fBlend = 0.0;\n    seq.fSmoothBlend = 0.0;\n    return seq;\n}\n\nbool Sequence_Next( inout Sequence seq, float fLength )\n{\n    seq.fTime -= seq.fLength;\n    seq.fLength = fLength;\n    seq.fBlend = seq.fTime \/ fLength;\n    seq.fSmoothBlend = smoothstep( 0.0, 1.0, seq.fBlend );\n    \n    return seq.fTime >= 0.0 && seq.fTime < fLength;\n}\n\nstruct CarInt\n{\n    float s;\n    float u;\n    float a;\n};\n    \nvoid CarInt_Update( inout CarInt carInt, float fTime )\n{\n    carInt.s += carInt.u * fTime + .5 * carInt.a * fTime * fTime;\n    carInt.u += carInt.a * fTime;\n}\n\nfloat CarInt_GetDisplacement( CarInt carInt, float fTime )\n{\n    return carInt.s + carInt.u * fTime + .5 * carInt.a * fTime * fTime;    \n}\n\nfloat CarInt_GetVelocity( CarInt carInt, float fTime )\n{\n    return carInt.u + carInt.a * fTime;\n}\n\nvoid GetSceneState( out SceneState scene, out CameraState camera, float fTime )\n{\n    scene.vCarPos = vec3(0.0);\n    scene.fThruster = 0.0;\n    scene.fDustTrail = 0.0;\n    scene.fCarVel = 0.0;\n\n    camera.vPos = vec3( 0.0, 1.0, -10.0 );\n    camera.vTarget = vec3( 0.0, 0.0, 0.0 );\n    camera.fFov = 15.0;\n    camera.fAperture = 0.5;\n    \n    float fCameraShake = 0.0;\n\n    \/\/scene.fThruster = clamp( sin(iTime) * 0.5 + 0.5, 0.0, 1.0);\n    \/\/scene.fDustTrail = scene.fThruster;\n    \/\/    scene.vCarPos.z = -iTime * 100.0;\/\/343.0;\n        \n    Sequence seq = Sequence_Init( fTime );\n\n    CarInt carInt;\n    carInt.s = 0.0;\n    carInt.u = 0.0;\n    carInt.a = 0.0;\n    \n    if ( Sequence_Next( seq, 8.0 ) )\n    {\n    }\n\n    \/\/ Initial Vel\n    carInt.u = 100.0;    \n    if ( Sequence_Next( seq, 4.0 ) )\n    {\n        scene.vCarPos.z = -CarInt_GetDisplacement( carInt, seq.fTime );\n        scene.fCarVel = -CarInt_GetVelocity( carInt, seq.fTime );\n\n\t    camera.vTarget = vec3( 0.0, 1.0, -100.0 );\n        camera.vPos = camera.vTarget + vec3( 10.0, -0.5, -5.0 );\n        \n        \/\/camera.vTarget = camera.vPos + normalize(camera.vTarget - camera.vPos) * 100.0 * (1.0 - seq.fBlend * 0.9);\n    \t\/\/camera.fAperture = 1.5;\n    }\n    \n    CarInt_Update( carInt, seq.fLength );\n\n    \/\/ vel +50 in 10 secs\n    carInt.a = 100.0 \/ 15.0;    \n\n    if ( Sequence_Next( seq, 5.0 ) )\n    {\n        scene.vCarPos.z = -CarInt_GetDisplacement( carInt, seq.fTime );\n        scene.fCarVel = -CarInt_GetVelocity( carInt, seq.fTime );\n\n\t    camera.vTarget = scene.vCarPos + vec3( 0.0, 1.5, -15.0 );\n        camera.vTarget.z += seq.fSmoothBlend * 20.0;\n        camera.vPos = camera.vTarget + vec3( -8.0, 0.5, -3.0 );\n        camera.fFov = 20.0;\n    \tcamera.fAperture = 0.5;\n        fCameraShake = 1.0;\n    }\n    CarInt_Update( carInt, seq.fLength );\n    \n    if ( Sequence_Next( seq, 5.0 ) )\n    {\n        scene.vCarPos.z = -CarInt_GetDisplacement( carInt, seq.fTime );\n        scene.fCarVel = -CarInt_GetVelocity( carInt, seq.fTime );\n\n\t    camera.vTarget = scene.vCarPos + vec3( 0.0, 2.0, -4.5 );\n        camera.vPos = camera.vTarget + mix( vec3( -4.0, 2.0, -20.0 ), vec3( -30.0, 1.0, 40.0 ) ,seq.fBlend );\n        camera.vTarget.z += seq.fBlend * 10.0;\n        camera.fFov = mix( 25.0, 15.0, seq.fBlend );\n    \tcamera.fAperture = 1.5;\n        fCameraShake = 1.0;\n    }    \n    CarInt_Update( carInt, seq.fLength );\n    \n    if ( Sequence_Next( seq, 5.0 ) )\n    {\n        scene.vCarPos.z = -CarInt_GetDisplacement( carInt, seq.fTime );\n        scene.fCarVel = -CarInt_GetVelocity( carInt, seq.fTime );\n\n\t    camera.vTarget = scene.vCarPos + vec3( 0.0, 1.5, -2.5 );\n        camera.vPos = camera.vTarget + mix( vec3( 10.0, 3.0, -20.0 ), vec3( -10.0, 3.0, -20.0 ) ,seq.fSmoothBlend );\n        camera.fFov = 8.0;\n    \tcamera.fAperture = 1.5;\n        fCameraShake = 1.0;\n    }\n    \n    CarInt_Update( carInt, seq.fLength );\n\n    carInt.a = 0.0;    \n    if ( Sequence_Next( seq, 3.0 ) )\n    {\n        scene.vCarPos.z = -CarInt_GetDisplacement( carInt, seq.fTime );\n        scene.fCarVel = -CarInt_GetVelocity( carInt, seq.fTime );\n\n\t    camera.vTarget = scene.vCarPos + vec3( 1.5, 1.4, 5.5 );\n        camera.vPos = camera.vTarget + vec3( 3.0, -0.5 + seq.fSmoothBlend * 2.0, 4.0+ pow( seq.fBlend, 4.0) * 16.0 );\n        camera.fFov = 20.0;\n    \tcamera.fAperture = 0.5;\n        \n        scene.fThruster = seq.fSmoothBlend;\n        fCameraShake = 1.0;\n    }\n\n    \/\/ vel +150 in 10 secs\n    carInt.a = 150.0 \/ 30.0;    \n    if ( Sequence_Next( seq, 5.0 ) )\n    {\n        scene.vCarPos.z = -CarInt_GetDisplacement( carInt, seq.fTime );\n        scene.fCarVel = -CarInt_GetVelocity( carInt, seq.fTime );\n\n        \/\/ Tail fin cam\n\t    camera.vTarget = scene.vCarPos + vec3( 0.0, 1.8, 3.5 );\n        camera.vPos = camera.vTarget + vec3( 0.0, 1.2, 4.0 );\n        camera.fFov = 35.0;\n    \tcamera.fAperture = 0.3;\n        \n        scene.fThruster = 1.0;\n        scene.fDustTrail = seq.fBlend * 0.1;\n        fCameraShake = 1.0;\n    }\n    \n    CarInt_Update( carInt, seq.fLength );\n\n\n    if ( Sequence_Next( seq, 5.0 ) )\n    {\n        scene.vCarPos.z = -CarInt_GetDisplacement( carInt, seq.fTime );\n        scene.fCarVel = -CarInt_GetVelocity( carInt, seq.fTime );\n\n\t    camera.vTarget = scene.vCarPos + vec3( 0.0, 1.0, seq.fSmoothBlend * 10.5 );\n        camera.vPos = camera.vTarget + vec3( 10.0, 2.0, -30.0 );\n        camera.fFov = 15.0;\n    \tcamera.fAperture = 0.5;\n\n        scene.fThruster = 1.0;\n        scene.fDustTrail = 0.1 + seq.fSmoothBlend * 0.9;\n        fCameraShake = 1.0;\n    }\n    \n    CarInt_Update( carInt, seq.fLength );\n\n    if ( Sequence_Next( seq, 15.0 ) )\n    {\n        scene.vCarPos.z = -CarInt_GetDisplacement( carInt, seq.fTime );\n        scene.fCarVel = -CarInt_GetVelocity( carInt, seq.fTime );\n\n        camera.vTarget = scene.vCarPos + mix( vec3( 0.0, 1.0, 20.0 ), vec3( 0.0, 1.0, -15.0 ), seq.fBlend );\n\t    camera.vPos = camera.vTarget + vec3( -8.0, 1.0, 4.5 );\n        camera.fFov = 20.0;\n    \tcamera.fAperture = 0.4;\n\n        scene.fThruster = 1.0;\n        scene.fDustTrail = 1.0;\n        fCameraShake = 1.0;\n    }\n    CarInt_Update( carInt, seq.fLength );\n    \n    if ( Sequence_Next( seq, 5.0 ) )\n    {\n        scene.vCarPos.z = -CarInt_GetDisplacement( carInt, seq.fTime );\n        scene.fCarVel = -CarInt_GetVelocity( carInt, seq.fTime );\n\n        \/\/ Tail fin cam\n\t    camera.vTarget = scene.vCarPos + vec3( 0.0, 1.8, 3.5 );\n        camera.vPos = camera.vTarget + vec3( 0.0, 1.2, 4.0 );\n        camera.fFov = 45.0;\n    \tcamera.fAperture = 0.3;\n        \n        scene.fThruster = 1.0;\n        scene.fDustTrail = 1.0;\n        fCameraShake = 1.0;\n    }\n    CarInt_Update( carInt, seq.fLength );\n\n    carInt.a = 0.0;    \n    if ( Sequence_Next( seq, 17.0 ) )\n    {\n        scene.vCarPos.z = -CarInt_GetDisplacement( carInt, seq.fTime );\n        scene.fCarVel = -CarInt_GetVelocity( carInt, seq.fTime );\n\n        camera.vPos = vec3(0.0);\n        camera.vPos.z = -CarInt_GetDisplacement( carInt, 0.0 );\n        \n        camera.vPos += vec3( 12.0, 0.5, -650.0 );\n\t    camera.vTarget = camera.vPos + vec3( -4.0, 0.0, 10.0 );\n        \n        camera.fFov = 10.0;\n    \tcamera.fAperture = 0.5;\n        \n        scene.fThruster = 1.0;\n        scene.fDustTrail = 1.0;\n        fCameraShake = 1.0;\n    }\n    \n    \/\/camera.vTarget.y += (noise(camera.vPos * 0.2) - 0.5) * fCameraShake \/ length(camera.vTarget - camera.vPos);\n    \n    \n    \/\/camera = GetCameraState_MouseOrbitCar();\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nstruct C_Listener\n{\n    vec3 m_vPos;\n    mat3 m_ToWorld;\n    float m_fEarSeparation;\n    vec3 m_vEarDirL;\n    vec3 m_vEarDirR;\n};\n\nstruct C_MixerValues\n{\n    vec2 m_vPan;\n    vec2 m_vDopplerOffset;\n};\n\nstruct C_Source\n{\n    vec3 m_Pos;\n    float m_Volume;\n};    \n    \nC_Source g_SourceInfo[4];\n\n#define GET_VELOCITY(X, T) ((X(T + 0.1) - X(T)) \/ 0.1)\n\nvoid SetupListener( out C_Listener listener, const in vec3 vCameraCurrPos, const in mat3 mCameraCurrRot )\n{\n    listener.m_vPos = vCameraCurrPos;\n    listener.m_ToWorld = mCameraCurrRot;    \n    listener.m_fEarSeparation = 0.1;\n    listener.m_vEarDirL = normalize(vec3( -1.0, 0.0, 0.1));\n    listener.m_vEarDirR = normalize(vec3( 1.0, 0.0, 0.1));    \n}\n\n\nvoid GetMixerValues( const in C_Listener listener, const in C_Source source, out C_MixerValues mixerValues )\n{\n    vec3 vLocalEarPosL = vec3(-listener.m_fEarSeparation, 0.0, 0.0);\n    vec3 vLocalEarPosR = vec3( listener.m_fEarSeparation, 0.0, 0.0);\n    \n    vec3 vWorldEarPosL = listener.m_ToWorld * vLocalEarPosL + listener.m_vPos;\n    vec3 vWorldEarPosR = listener.m_ToWorld * vLocalEarPosR + listener.m_vPos;\n\n    vec3 vSourceToEarL = vWorldEarPosL - source.m_Pos;\n    vec3 vSourceToEarR = vWorldEarPosR - source.m_Pos;\n    \n    vec2 vDist = vec2(length(vSourceToEarL), length(vSourceToEarR));\n    const float kSpeedOfSound = 340.29;\n    mixerValues.m_vDopplerOffset = -vDist \/ kSpeedOfSound;\n    vec2 vVolume = vec2(source.m_Volume) \/ (vDist * vDist);\n\n    vec3 vWorldEarDirL = normalize( listener.m_ToWorld * listener.m_vEarDirL );\n    vec3 vWorldEarDirR = normalize( listener.m_ToWorld * listener.m_vEarDirR );\n    vec2 vPan = clamp(vec2( dot(normalize(vSourceToEarL), vWorldEarDirL), dot(normalize(vSourceToEarR), vWorldEarDirR) ) * 0.4 + 0.6 , 0.0, 1.0);\n    \n    mixerValues.m_vPan = vPan * vVolume;\n    \n#ifdef INVERT_STEREO\n    mixerValues.m_vPan = mixerValues.m_vPan.yx; \/\/ erm?!\n#endif\n}\n\n#define DOPPLER_PER_EAR\n\n#ifdef DOPPLER_PER_EAR\n\t#define MIX(SAMPLE_FN, TIME, MIXER_VALUES) (vec2(SAMPLE_FN(TIME + MIXER_VALUES.m_vDopplerOffset.x), SAMPLE_FN(TIME + MIXER_VALUES.m_vDopplerOffset.y)) * MIXER_VALUES.m_vPan);\n#else\n\t#define MIX(SAMPLE_FN, TIME, MIXER_VALUES) (SAMPLE_FN(TIME + dot(MIXER_VALUES.m_vDopplerOffset, vec2(0.5))) * MIXER_VALUES.m_vPan);\n#endif\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\nfloat Envelope( float time, float decay )\n{\t\n\treturn exp2( -time * (5.0 \/ decay) );\n}\n\nfloat Envelope( float time, float attack, float decay )\n{\n\tif( time < attack )\n\t{\n\t\treturn time\/attack;\/\/exp2( -(attack - time) * (5.0 \/ attack) );\n\t}\n\n\ttime -= attack;\n\n\treturn Envelope( time, decay );\n}\n\n\nfloat Envelope( float time, float attack, float sustain, float decay )\n{\n\tif( time < attack )\n\t{\n\t\treturn time\/attack;\/\/exp2( -(attack - time) * (5.0 \/ attack) );\n\t}\n\n\ttime -= attack;\n\t\n\tif(time < sustain)\n\t{\n\t\treturn 1.0;\n\t}\n\n\ttime -= sustain;\n\t\n\treturn Envelope( time, decay );\n}\n\nfloat Tri( float t )\n{\n\treturn abs(fract( t ) * 4.0 - 2.0) - 1.0;\n}\n\nfloat Saw( float t )\n{\n\treturn fract( t ) * 2.0 - 1.0;\n}\n\nfloat Cos( float t )\n{\n\treturn cos( t * radians(360.0) );\n}\n\nfloat Square( float t )\n{\n\treturn step( fract(t), 0.5 ) * 2.0 - 1.0;\n}\n\nfloat Hash( float x )\n{\n\treturn fract(sin(x * 1.2345678)*123456.78);\n}\n\nfloat Noise( float x )\n{\n\treturn Hash( floor(x * 32.0) ) * 2.0 - 1.0;\n}\n\nfloat SmoothNoise( float t )\n{\n\tfloat noiset = t * 32.0;\n\tfloat tfloor = floor(noiset);\n\tfloat ffract = fract(noiset);\n\t\n\tfloat n0 = Hash(tfloor);\n\tfloat n1 = Hash(tfloor + 1.0);\n\tfloat blend = ffract*ffract*(3.0 - 2.0*ffract);\n\treturn mix(n0, n1, blend) * 2.0 - 1.0;\n}\n\nfloat FBM( float t, float persistence )\n{\n    float result = 0.0;\n    \n    float a = 1.0;\n    float tot = 0.0;\n    result += SmoothNoise(t) * a; tot += a; t *= 2.02; a *= persistence;\n    result += SmoothNoise(t) * a; tot += a; t *= 2.02; a *= persistence; \n    result += SmoothNoise(t) * a; tot += a; t *= 2.02; a *= persistence; \n    result += SmoothNoise(t) * a; tot += a; t *= 2.02; a *= persistence; \n    tot += a; \n    return result \/ tot;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/*\nfloat GetSource0Sample(float t)\n{     \n    \/\/return 0.0;\n    return Square(220.0*fract(t)) * Envelope(fract(t), 0.05, 0.95);\n\n    \/\/return FBM( t * 30.0, 0.5 );\n    \/\/return Square(220.0*fract(t)) * Envelope(fract(t), 0.05, 0.95);\n    \/\/return Saw(220.0*fract(t)) * Envelope(fract(t), 0.05, 0.95);\n    \/\/return Cos(220.0*fract(t)) * Envelope(fract(t), 0.05, 0.95);\n    \/\/return Tri(220.0*fract(t)) * Envelope(fract(t), 0.05, 0.95);\n}\n\nvec3 GetSource0Pos(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n*\/\n\nfloat GetSource0Sample(float t)\n{        \n    float s = FBM( t * 30.0 , 0.6 ) * 1.0\n        + Saw(t*(440.0 - g_sceneState.fCarVel)) * 0.1\n        + FBM( t * 30.0 , 0.4 ) * 2.0 * -g_sceneState.fCarVel \/ 300.0;\n        \n    return s;\n}\n\nvec3 GetSource0Pos(float t)\n{\n    return g_sceneState.vCarPos + vec3( 0.0, 0.0, 0.0 );\n}\n\n\nfloat GetSource1Sample(float t)\n{        \n    float s = FBM( t * 20.0 , 0.2 ) * 1.0 * g_sceneState.fThruster;\n        \n    return s;\n    \/\/ + Saw(220.1*t + 0.5) * 0.5;\n    \n    \/\/return FBM( t * 30.0, 0.5 );\n    \/\/return Square(440.0*fract(t)) * Envelope(fract(t), 0.05, 0.95);\n    \/\/return Saw(220.1*t + 0.5);\/\/ * Envelope(fract(t), 0.05, 0.95);\n    \/\/return Cos(440.0*fract(t)) * Envelope(fract(t), 0.05, 0.95);\n    \/\/return Tri(440.0*fract(t)) * Envelope(fract(t), 0.05, 0.95);\n}\n\nvec3 GetSource1Pos(float t)\n{\n    return g_sceneState.vCarPos + vec3( 0.0, 1.0, 5.8 );\n}\n\nfloat FBoom( float t )\n{\n    float fResult = 0.0;\n    \n    float a = 1.0;\n    \n    for ( int i=0; i<10; i++)\n    {      \n        if ( t > 0.0 )\n        {\n            fResult += SmoothNoise( t * 100.0 )*exp(-8.0*t) * a;\n       \t}\n        t -= 0.2;        \n\t    a *= 0.4;\n    }\n    return fResult;\n}\n\nvec2 mainSound( in int samp,float time)\n{\n    float iTime = time;\n    \n    CameraState cam;       \n    GetSceneState( g_sceneState, cam, time );\n    \n\tvec3 vCameraCurrPos = cam.vPos;\n    mat3 mCameraCurrRot = Cam_GetWorldToCameraRotMatrix( cam );    \n    \n    C_Listener listener;\n    SetupListener( listener, vCameraCurrPos, mCameraCurrRot );\n\n    g_SourceInfo[0].m_Pos = GetSource0Pos(time);\n    g_SourceInfo[0].m_Volume = 50.0;\n\n    g_SourceInfo[1].m_Pos = GetSource1Pos(time);\n    g_SourceInfo[1].m_Volume = 50.0;\n    \n    vec2 vResult = vec2(0.0);    \n\n    C_MixerValues mixerValues;\n\n    GetMixerValues( listener, g_SourceInfo[0], mixerValues );\n    vResult += MIX( GetSource0Sample, time, mixerValues );\n\n    GetMixerValues( listener, g_SourceInfo[1], mixerValues );\n    vResult += MIX( GetSource1Sample, time, mixerValues );\n\n    vResult += FBoom( time - 61.85 ) * 8.0;\n    \n    if ( time < 8.0 || time > 75.0 )\n    {\n        vResult = vec2(0.0);\n    }\n    \n    return vResult;   \n}\n","name":"Sound","description":"","type":"sound"},{"inputs":[{"id":"XsXGRn","filepath":"\/media\/a\/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"\/media\/ap\/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRn","filepath":"\/media\/a\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"\/media\/ap\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"\/media\/a\/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"\/media\/ap\/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"\/\/ Scene Render\n\n#define kMaxTraceDist 1000.0\n#define kFarDist 1100.0\n\n#define MAT_FG_BEGIN \t10.0\n\n#define PI 3.141592654\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Data Storage\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec4 LoadVec4( sampler2D sampler, in ivec2 vAddr )\n{\n    return texelFetch( sampler, vAddr, 0 );\n}\n\nvec3 LoadVec3( sampler2D sampler, in ivec2 vAddr )\n{\n    return LoadVec4( sampler, vAddr ).xyz;\n}\n\nbool AtAddress( vec2 p, vec2 c ) { return all( equal( floor(p), floor(c) ) ); }\n\nvoid StoreVec4( in vec2 vAddr, in vec4 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in vec2 vAddr, in vec3 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Camera\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nstruct CameraState\n{\n    vec3 vPos;\n    vec3 vTarget;\n    float fFov;\n};\n    \nvoid Cam_LoadState( out CameraState cam, sampler2D sampler, ivec2 addr )\n{\n    cam.vPos = LoadVec3( sampler, addr + ivec2(0,0) );\n    vec4 targetFov = LoadVec4( sampler, addr + ivec2(1,0) );\n    cam.vTarget = targetFov.xyz;\n    cam.fFov = targetFov.w;\n}\n\nvoid Cam_StoreState( vec2 addr, const in CameraState cam, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec3( addr + vec2(0,0), cam.vPos, fragColor, fragCoord );\n    StoreVec4( addr + vec2(1,0), vec4( cam.vTarget, cam.fFov ), fragColor, fragCoord );    \n}\n\nmat3 Cam_GetWorldToCameraRotMatrix( const CameraState cameraState )\n{\n    vec3 vForward = normalize( cameraState.vTarget - cameraState.vPos );\n\tvec3 vRight = normalize( cross(vec3(0, 1, 0), vForward) );\n\tvec3 vUp = normalize( cross(vForward, vRight) );\n    \n    return mat3( vRight, vUp, vForward );\n}\n\nvec2 Cam_GetViewCoordFromUV( const in vec2 vUV )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x \/ iResolution.y;\n\n\treturn vWindow;\t\n}\n\nvoid Cam_GetCameraRay( const vec2 vUV, const CameraState cam, out vec3 vRayOrigin, out vec3 vRayDir )\n{\n    vec2 vView = Cam_GetViewCoordFromUV( vUV );\n    vRayOrigin = cam.vPos;\n    float fPerspDist = 1.0 \/ tan( radians( cam.fFov ) );\n    vRayDir = normalize( Cam_GetWorldToCameraRotMatrix( cam ) * vec3( vView, fPerspDist ) );\n}\n\nvec2 Cam_GetUVFromWindowCoord( const in vec2 vWindow )\n{\n    vec2 vScaledWindow = vWindow;\n    vScaledWindow.x *= iResolution.y \/ iResolution.x;\n\n    return vScaledWindow * 0.5 + 0.5;\n}\n\nvec2 Cam_WorldToWindowCoord(const in vec3 vWorldPos, const in CameraState cameraState )\n{\n    vec3 vOffset = vWorldPos - cameraState.vPos;\n    vec3 vCameraLocal;\n\n    vCameraLocal = vOffset * Cam_GetWorldToCameraRotMatrix( cameraState );\n\t\n    vec2 vWindowPos = vCameraLocal.xy \/ (vCameraLocal.z * tan( radians( cameraState.fFov ) ));\n    \n    return vWindowPos;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Scene\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nstruct SceneResult\n{\n\tfloat fDist;\n\tfloat fObjectId;\n    vec3 vUVW;\n};\n\nSceneResult Scene_Union( const in SceneResult a, const in SceneResult b )\n{\n    if ( a.fDist < b.fDist )\n    {\n        return a;\n    }\n    return b;\n}\n    \nSceneResult Scene_Subtract( const in SceneResult a, const in SceneResult b )\n{\n    if ( -a.fDist < b.fDist )\n    {\n        return a;\n    }\n\n    SceneResult result;\n    result.fDist = -b.fDist;\n    result.fObjectId = b.fObjectId;\n    result.vUVW = b.vUVW;\n    return result;\n}\n\nSceneResult Scene_Intersection( const in SceneResult a, const in SceneResult b )\n{\n    if ( a.fDist > b.fDist )\n    {\n        return a;\n    }\n    return b;\n}\n    \nSceneResult Scene_GetDistance( const vec3 vPos );    \n\nvec3 Scene_GetNormal(const in vec3 vPos)\n{\n    const float fDelta = 0.001;\n    vec2 e = vec2( -1, 1 );\n    \n    vec3 vNormal = \n        Scene_GetDistance( vPos + e.yxx * fDelta ).fDist * e.yxx + \n        Scene_GetDistance( vPos + e.xxy * fDelta ).fDist * e.xxy + \n        Scene_GetDistance( vPos + e.xyx * fDelta ).fDist * e.xyx + \n        Scene_GetDistance( vPos + e.yyy * fDelta ).fDist * e.yyy;\n    \n    if ( dot( vNormal, vNormal ) < 0.00001 )\n    {\n        return vec3(0, 1, 0);\n    }\n    \n    return normalize( vNormal );\n}    \n    \nSceneResult Scene_Trace( const in vec3 vRayOrigin, const in vec3 vRayDir, float maxDist )\n{\t\n    SceneResult result;\n    result.fDist = 0.0;\n    result.vUVW = vec3(0.0);\n    result.fObjectId = 0.0;\n    \n\tfloat t = 0.1;\n\tconst int kRaymarchMaxIter = 128;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\t\t\n\t\tresult = Scene_GetDistance( vRayOrigin + vRayDir * t );\t\t\n        t += result.fDist;\n\n        if ( abs(result.fDist) < 0.001 )\n\t\t{\n\t\t\tbreak;\n\t\t}\t\t\n        if ( t > maxDist )\n        {\n            result.fObjectId = -1.0;\n\t        t = maxDist;\n            break;\n        }\n\t}\n    \n    result.fDist = t;\n\n    return result;\n}    \n\nfloat Scene_TraceShadow( const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fLightDist )\n{\n    \/\/return 1.0;\n    \/\/return ( Scene_Trace( vRayOrigin, vRayDir, fLightDist ).fDist < fLightDist ? 0.0 : 1.0;\n    \n    float mint = 0.02, tmax = 2.5;\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = Scene_GetDistance( vRayOrigin + vRayDir * t ).fDist;\n        res = min( res, 8.0*h\/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );    \n}\n\nfloat Scene_GetAmbientOcclusion( const in vec3 vPos, const in vec3 vDir )\n{\n    float fOcclusion = 0.0;\n    float fScale = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float fOffsetDist = 0.01 + 1.0*float(i)\/4.0;\n        vec3 vAOPos = vDir * fOffsetDist + vPos;\n        float fDist = Scene_GetDistance( vAOPos ).fDist;\n        fOcclusion += (fOffsetDist - fDist) * fScale;\n        fScale *= 0.4;\n    }\n    \n    return clamp( 1.0 - 2.0*fOcclusion, 0.0, 1.0 );\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Lighting\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \nstruct SurfaceInfo\n{\n    vec3 vPos;\n    vec3 vNormal;\n    vec3 vBumpNormal;    \n    vec3 vAlbedo;\n    vec3 vR0;\n    float fSmoothness;\n    vec3 vEmissive;\n};\n    \nSurfaceInfo Scene_GetSurfaceInfo( const in vec3 vRayOrigin,  const in vec3 vRayDir, SceneResult traceResult );\n\nstruct SurfaceLighting\n{\n    vec3 vDiffuse;\n    vec3 vSpecular;\n};\n    \nSurfaceLighting Scene_GetSurfaceLighting( const in vec3 vRayDir, in SurfaceInfo surfaceInfo );\n\nfloat Light_GIV( float dotNV, float k)\n{\n\treturn 1.0 \/ ((dotNV + 0.0001) * (1.0 - k)+k);\n}\n\nvoid Light_Add(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\n\tfloat fNDotL = clamp(dot(vLightDir, surface.vBumpNormal), 0.0, 1.0);\n\t\n\tlighting.vDiffuse += vLightColour * fNDotL;\n    \n\tvec3 vH = normalize( -vViewDir + vLightDir );\n\tfloat fNdotV = clamp(dot(-vViewDir, surface.vBumpNormal), 0.0, 1.0);\n\tfloat fNdotH = clamp(dot(surface.vBumpNormal, vH), 0.0, 1.0);\n    \n\tfloat alpha = 1.0 - surface.fSmoothness;\n\t\/\/ D\n\n\tfloat alphaSqr = alpha * alpha;\n\tfloat pi = 3.14159;\n\tfloat denom = fNdotH * fNdotH * (alphaSqr - 1.0) + 1.0;\n\tfloat d = alphaSqr \/ (pi * denom * denom);\n\n\tfloat k = alpha \/ 2.0;\n\tfloat vis = Light_GIV(fNDotL, k) * Light_GIV(fNdotV, k);\n\n\tfloat fSpecularIntensity = d * vis * fNDotL;    \n\tlighting.vSpecular += vLightColour * fSpecularIntensity;    \n}\n\nvoid Light_AddPoint(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightPos, const in vec3 vLightColour)\n{    \n    vec3 vPos = surface.vPos;\n\tvec3 vToLight = vLightPos - vPos;\t\n    \n\tvec3 vLightDir = normalize(vToLight);\n\tfloat fDistance2 = dot(vToLight, vToLight);\n\tfloat fAttenuation = 100.0 \/ (fDistance2);\n\t\n\tfloat fShadowFactor = Scene_TraceShadow( surface.vPos, vLightDir, length(vToLight) );\n\t\n\tLight_Add( lighting, surface, vViewDir, vLightDir, vLightColour * fShadowFactor * fAttenuation);\n}\n\nvoid Light_AddDirectional(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\t\n\tfloat fAttenuation = 1.0;\n\tfloat fShadowFactor = Scene_TraceShadow( surface.vPos, vLightDir, 10.0 );\n\t\n\tLight_Add( lighting, surface, vViewDir, vLightDir, vLightColour * fShadowFactor * fAttenuation);\n}\n\nvec3 Light_GetFresnel( vec3 vView, vec3 vNormal, vec3 vR0, float fGloss )\n{\n    float NdotV = max( 0.0, dot( vView, vNormal ) );\n\n    return vR0 + (vec3(1.0) - vR0) * pow( 1.0 - NdotV, 5.0 ) * pow( fGloss, 20.0 );\n}\n\nvoid Env_AddPointLightFlare(inout vec3 vEmissiveGlow, const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fIntersectDistance, const in vec3 vLightPos, const in vec3 vLightColour)\n{\n    vec3 vToLight = vLightPos - vRayOrigin;\n    float fPointDot = dot(vToLight, vRayDir);\n    fPointDot = clamp(fPointDot, 0.0, fIntersectDistance);\n\n    vec3 vClosestPoint = vRayOrigin + vRayDir * fPointDot;\n    float fDist = length(vClosestPoint - vLightPos);\n\tvEmissiveGlow += sqrt(vLightColour * 0.05 \/ (fDist * fDist));\n}\n\nvoid Env_AddDirectionalLightFlareToFog(inout vec3 vFogColour, const in vec3 vRayDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\n\tfloat fDirDot = clamp(dot(vLightDir, vRayDir) * 0.5 + 0.5, 0.0, 1.0);\n\tfloat kSpreadPower = 2.0;\n\tvFogColour += vLightColour * pow(fDirDot, kSpreadPower) * 0.25;\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Rendering\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec4 Env_GetSkyColor( const vec3 vViewPos, const vec3 vViewDir );\nvec3 Env_ApplyAtmosphere( const in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist);\nvec3 FX_Apply( in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist);\n\nvec4 Scene_GetColorAndDepth( const in vec3 vInRayOrigin, const in vec3 vInRayDir )\n{\n    vec3 vRayOrigin = vInRayOrigin;\n    vec3 vRayDir = vInRayDir;\n    \n\tvec3 vResultColor = vec3(0.0);\n\tvec3 vPassContribution = vec3(1.0);\n            \n\tSceneResult firstTraceResult;\n    \n\tfor( int iPassIndex=0; iPassIndex<3; iPassIndex++ )\n\t{\t        \n    \tSceneResult traceResult = Scene_Trace( vRayOrigin, vRayDir, kMaxTraceDist );\n        \n        if ( iPassIndex == 0 )\n        {\n            firstTraceResult = traceResult;\n        }\n        \n\t\tvec3 vPassColor = vec3(0.0);\n\t\tvec3 vReflectance = vec3(1.0);\n\n\t\tif( traceResult.fObjectId < 0.0 )\n\t\t{\n            break; \n        }\n        else\n        {\n            SurfaceInfo surfaceInfo = Scene_GetSurfaceInfo( vRayOrigin, vRayDir, traceResult );\n            SurfaceLighting surfaceLighting = Scene_GetSurfaceLighting( vRayDir, surfaceInfo );\n                \n            \/\/ calculate reflectance (Fresnel)\n            float NdotV = clamp( dot(surfaceInfo.vBumpNormal, -vRayDir), 0.0, 1.0);\n\t\t\tvReflectance = Light_GetFresnel( -vRayDir, surfaceInfo.vBumpNormal, surfaceInfo.vR0, surfaceInfo.fSmoothness );\n\t\t\t\n\t\t\tvPassColor = \n                mix( surfaceInfo.vAlbedo * surfaceLighting.vDiffuse + surfaceInfo.vEmissive, surfaceLighting.vSpecular, vReflectance );\n        \n\t        vPassColor = Env_ApplyAtmosphere( vPassColor, vRayOrigin, vRayDir, traceResult.fDist );\t\t\n            \n            \/\/ Reflect Ray\n            vRayOrigin = surfaceInfo.vPos;\n            vRayDir = normalize( reflect( vRayDir, surfaceInfo.vBumpNormal ) );\n        }\n                \n\t\tvResultColor += vPassColor * vPassContribution;\n\t\tvPassContribution *= vReflectance;\t\t\t        \n    }\n    \n    vec4 vFinalSkyColor = Env_GetSkyColor( vRayOrigin, vRayDir );\n    vFinalSkyColor.rgb = Env_ApplyAtmosphere( vFinalSkyColor.rgb, vRayOrigin, vRayDir, vFinalSkyColor.a );\t\t\n\tvResultColor += vFinalSkyColor.rgb * vPassContribution;\n    \n    vResultColor = FX_Apply( vResultColor, vInRayOrigin, vInRayDir, firstTraceResult.fDist );\n    \n    if ( firstTraceResult.fObjectId >= MAT_FG_BEGIN )\n    {\n        firstTraceResult.fDist = -firstTraceResult.fDist;\n    }\n    \n    return vec4( vResultColor, firstTraceResult.fDist );\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Utility Functions\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define MOD2 vec2(4.438975,3.972973)\n\nfloat Hash( float p ) \n{\n    \/\/ https:\/\/www.shadertoy.com\/view\/4djSRW - Dave Hoskins\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);    \n\t\/\/return fract(sin(n)*43758.5453);\n}\n\nfloat SmoothNoise(in vec2 o) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat a = Hash(n+  0.0);\n\tfloat b = Hash(n+  1.0);\n\tfloat c = Hash(n+ 57.0);\n\tfloat d = Hash(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n    return res;\n}\n\n\nvec3 SmoothNoise_DXY(in vec2 o) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat a = Hash(n+  0.0);\n\tfloat b = Hash(n+  1.0);\n\tfloat c = Hash(n+ 57.0);\n\tfloat d = Hash(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\tvec2 dt = 6.0 * f - 6.0 * f2;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\tfloat du = dt.x;\t\n\tfloat dv = dt.y;\t\n\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n\tfloat dx = (b-a)*du + (a-b+d-c)*du*v;\n\tfloat dy = (c-a)*dv + (a-b+d-c)*u*dv;    \n    \n    return vec3(dx, dy, res);\n}\n\nvec3 FBM_DXY( vec2 p, vec2 flow, float ps, float df ) {\n\tvec3 f = vec3(0.0);\n    float tot = 0.0;\n    float a = 1.0;\n    \/\/flow *= 0.6;\n    for( int i=0; i<4; i++)\n    {\n        p += flow;\n        flow *= -0.75; \/\/ modify flow for each octave - negating this is fun\n        vec3 v = SmoothNoise_DXY( p );\n        f += v * a;\n        p += v.xy * df;\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f \/ tot;\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Scene Description\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ Materials\n\n#define MAT_SKY \t\t-1.0\n#define MAT_MOUNTAIN \t0.0\n#define MAT_SAND \t\t2.0\n\nSurfaceInfo Scene_GetSurfaceInfo( const in vec3 vRayOrigin,  const in vec3 vRayDir, SceneResult traceResult )\n{\n    SurfaceInfo surfaceInfo;\n    \n    surfaceInfo.vPos = vRayOrigin + vRayDir * (traceResult.fDist);\n    surfaceInfo.vNormal = Scene_GetNormal( surfaceInfo.vPos ); \n    surfaceInfo.vBumpNormal = surfaceInfo.vNormal;\n    surfaceInfo.vAlbedo = vec3(1.0); \/\/fract( surfaceInfo.vPos + 0.1 );\n    surfaceInfo.vR0 = vec3( 0.01 );\n    surfaceInfo.fSmoothness = 0.0;\n    surfaceInfo.vEmissive = vec3( 0.0 );\n    \n    surfaceInfo.vR0 = vec3( 0.01 );\n    vec3 vSand = texture( iChannel2, surfaceInfo.vPos.xz * 0.01).rgb;\n    vSand = vSand * vSand;\n    vec3 vMountain = texture( iChannel1, surfaceInfo.vPos.xz * 0.01).rgb;\n    vMountain = vMountain * vMountain;\n    \n    surfaceInfo.vAlbedo = mix(vSand, vMountain, clamp( surfaceInfo.vPos.y * 0.2, 0.0, 1.0) ); \n    \n    \/\/surfaceInfo.vAlbedo = mix(surfaceInfo.vAlbedo, vec3(1,1,1), clamp( (surfaceInfo.vPos.y - 55.0) * 0.2, 0.0, 1.0) ); \n            \n    \n    return surfaceInfo;\n}\n\n\/\/ Scene Description\n\n\nSceneResult Scene_GetDistance( const vec3 vPos )\n{\n    SceneResult result = SceneResult( kMaxTraceDist, MAT_SKY, vec3(0.0) );\n    \n\n    float fMountainDist = 50.0 - length(vPos.xz);\n    float fAngle = atan( vPos.x, vPos.z );\n    fMountainDist = max( fMountainDist, vPos.y - 10.0 + sin( fAngle * 50.0 ) * 5.0);\n    \n\/\/    result = Scene_Union( result, SceneResult( fMountainDist, MAT_MOUNTAIN, vec3(0.0) ) );\n    \/\/result = Scene_Subtract( result, SceneResult( length( vPos - vec3( 0, 3, 0 ) ) - 1.9, MAT_CHROME, vec3(0.0) ) );\n    \/\/result = Scene_Intersection( result, SceneResult( length( vPos - vec3( 0, 3, 0 ) ) - 1.9, MAT_CHROME, vec3(0.0) ) );\n    \n\t\/\/float fHeight = 0.0;\/\/1.0 - texture( iChannel1, vPos.xz * 0.1 - vec2(0, iTime) ).r;\n    \n    float fHeight = FBM_DXY( vPos.xz * 0.005, vec2(0.0), 0.8, -0.1).z;\n    fHeight = fHeight* fHeight * fHeight * fHeight;\n    fHeight = fHeight * 200.0;\n    fHeight = fHeight * (1.0 - exp2( length( vPos.xz ) * -0.003 ) );\n    \n    result = Scene_Union( result, SceneResult( vPos.y - fHeight, MAT_SAND, vec3(0.0) ) );\n                                              \n\/*    float l = length( vPos.xz );\n    result = Scene_Union( result, SceneResult( vPos.y - 2.0 + exp(-l * 0.1) * 4.0, MAT_SAND, vec3(0.0) ) );\n    result = Scene_Union( result, SceneResult( vPos.y \n\/\/                                              + sin(iTime + vPos.x * 8.0) * 0.02\n\/\/                                              + sin(iTime * 2.0 + vPos.z * 8.0) * 0.02\n\/\/                                              + sin(iTime * 3.0 + vPos.x * 10.0) * 0.01\n\/\/                                              + sin(iTime * 4.0 + vPos.z * 10.0) * 0.01\n                                              , MAT_WATER, vec3(0.0) ) );*\/\n        \n    return result;\n}\n\n\/\/ Scene Lighting\n\nvec3 g_vSunDir = normalize(vec3(1.0, 0.4, -0.8));\nvec3 g_vSunColor = vec3(1, 0.5, 0.25) * 5.0;\n\nSurfaceLighting Scene_GetSurfaceLighting( const in vec3 vViewDir, in SurfaceInfo surfaceInfo )\n{\n    SurfaceLighting surfaceLighting;\n    \n    surfaceLighting.vDiffuse = vec3(0.0);\n    surfaceLighting.vSpecular = vec3(0.0);    \n    \n    Light_AddDirectional( surfaceLighting, surfaceInfo, vViewDir, g_vSunDir, g_vSunColor );\n    \/\/Light_AddPoint( surfaceLighting, surfaceInfo, vViewDir, vec3(-2.0, 5.0, 0.0), vec3( 0.5, 1, 0.5 ) );\n    \n    float fAO = 1.0;\/\/Scene_GetAmbientOcclusion( surfaceInfo.vPos, surfaceInfo.vNormal );\n    \/\/ AO\n    surfaceLighting.vDiffuse += fAO * (surfaceInfo.vBumpNormal.y * 0.5 + 0.5) * vec3(0.5, 1, 1);\n    \n    return surfaceLighting;\n}\n\n\/\/ Environment\n\nvec4 Env_GetSkyColor( const vec3 vViewPos, const vec3 vViewDir )\n{\n\tvec4 vResult = vec4(0.0);\n\t\n    vResult.rgb = mix( vec3(0.02, 0.04, 0.06), vec3(0.1, 0.3, 0.8) * 3.0, vViewDir.y * 0.5 + 0.5 );\n\t\n\n\n    \/\/ Cloud\n    float fCloud = texture( iChannel3, vViewDir.xz * 0.01 \/ vViewDir.y ).r;\n    fCloud = clamp( fCloud * fCloud * 3.0 - 1.0, 0.0, 1.0);\n    vResult.rgb = mix( vResult.rgb, vec3(8.0), fCloud );\n    \n    \n    \/\/ Sun\n    \/\/float NdotV = dot( g_vSunDir, vViewDir );\n    \/\/vResult += smoothstep( cos(radians(.7)), cos(radians(.5)), NdotV ) * g_vSunColor * 2000.0;\n    \n    vResult.w = kFarDist;\n    \n\treturn vResult;\t\n}\n\nvec3 Env_ApplyAtmosphere( const in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist)\n{\n    return vColor;\n    \/*\n\tfloat fFogFactor = Env_GetFogFactor( fDist );\n\tvec3 vFogColor = Env_GetFogColor( vRayDir );\n\t\n\tEnv_AddDirectionalLightFlareToFog( vFogColor, vRayDir, g_vSunDir, g_vSunColor);\n    \n    return mix( vFogColor, vColor, fFogFactor );\t    \n\t*\/\n}\n\n\/\/ FX\n\nvec4 FX_ColDensity( vec3 vPos )\n{\n    float density = 0.0;\n    if (length( vPos ) < 5.0 )\n        density = 0.02;\n    return vec4(10,10,10, density);\n}\n\nvec3 FX_Apply( in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist)\n{\n\/*    float t= 0.03;\n    float f = 1.0;\n    for(int iter=0; iter<64; iter++)\n    {\n        if( t > fDist )\n        {\n            break;\n        }\n        \n        vec3 p = vRayOrigin + vRayDir * t;\n        vec4 vEffect = FX_ColDensity( p );\n        vec4 vEffect2 = FX_ColDensity( p + g_vSunDir * 0.1 ) ;\n        \n        vEffect.xyz *= clamp( (vEffect.w - vEffect2.w) \/ 0.1, 0.0, 1.0 );\n        \n        vColor = mix(vColor, vEffect.rgb, f * vEffect.w);\n        f = f * (1.0 - vEffect.w);\n        \n\t\tt += (0.04+t*0.012);        \n    }    *\/\n    \n    return vColor;\n}\n\n\/\/ Camera \n\nCameraState GetCameraState()\n{\n    CameraState camera;\n    \n    float fAngle = (iMouse.x \/ iResolution.x) * 3.14 * 2.0;\n    float fDist = 15.0;\n    \n    float fHeight = (iMouse.y \/ iResolution.y) * 15.0;\n    \n    camera.vPos = vec3( sin(fAngle) * fDist, fHeight, cos(fAngle) * fDist );\n    camera.vTarget = vec3( 0.0, 2.0, 0.5 );\n    camera.fFov = 25.0;\n    \n    return camera;\n}\n\n\/*\nvoid mainImage( out vec4 vFragColor, in vec2 vFragCoord )\n{\n    vec2 vUV = vFragCoord.xy \/ iResolution.xy; \n    vec4 vOldData = LoadVec4( iChannel0, ivec2(0,0) );\n \n    \n    vec3 vRayOrigin, vRayDir;\n\n\/\/ Environment map render\n#if 1\n    \/\/ Passthrough shader if previous value was valid\n\tif ( iFrame > 0 && vOldData.x == iResolution.x && vOldData.y == iResolution.y )\n    {\n        vFragColor = texture( iChannel0, vUV );\n        return;\n    }\n    \n    vRayOrigin = vec3(0.0, 1.0, 0.0);\n    \n    float fSkyElevationMin = -PI * 0.125;\n    float fSkyElevationMax = PI * 0.5;\n    \n    float fHeading = vUV.x * PI;\n    if ( vUV.y > 0.5 )\n    {\n\t    vUV.y = 1.0 - vUV.y;\n        fHeading += PI;\n    }\n    float fElevation = mix( fSkyElevationMin, fSkyElevationMax, vUV.y * 2.0 );\n    \n    vRayDir.x = sin( fHeading ) * cos( fElevation );\n    vRayDir.y = sin( fElevation );\n    vRayDir.z = cos( fHeading ) * cos( fElevation );\n#else    \n    CameraState cam = GetCameraState();\n    Cam_GetCameraRay( vUV, cam, vRayOrigin, vRayDir );\n#endif\n    \n\tvec4 vColorLinAmdDepth = Scene_GetColorAndDepth( vRayOrigin, vRayDir );    \n\n    vColorLinAmdDepth.rgb = max( vColorLinAmdDepth.rgb, vec3(0.0) );\n        \n    vFragColor = vColorLinAmdDepth;\n    \n    \/\/vFragColor.r = fract( atan(vRayDir.x, vRayDir.z) \/ (PI * 2.0) );\n    \n    \/\/ Debug update frequency\n    \/\/vFragColor.r = fract( iTime * 10.0 );\n    \n    if ( vColorLinAmdDepth.r > 40000.0 || vColorLinAmdDepth.g > 40000.0 || vColorLinAmdDepth.b > 40000.0 )\n    {\n        vFragColor = vec4(0.0);\n    }\n\n    vec4 textureA = texture( iChannel1, vec2(0,0) );\n    vec4 textureB = texture( iChannel2, vec2(0,0) );\n    vec4 textureC = texture( iChannel3, vec2(0,0) );\n\n    vec4 vFrameData = vec4( 0 );\n    \/\/ Don't stamp output as valud until input textures have loaded\n    if ( length(textureA.rgb) > 0.01 && length(textureB.rgb) > 0.01 && length(textureC.rgb) > 0.01 )\n    {  \n        vFrameData =  vec4( floor(iResolution.x), floor(iResolution.y), 0, 0 );\n    }\n    \n    StoreVec4( vec2(0,0), vFrameData, vFragColor, vFragCoord );\n}\n*\/\n\nvoid mainCubemap( out vec4 vFragColor, in vec2 fragCoord, in vec3 vRayOrigin, in vec3 vRayDir )\n{\n\tvec4 vColorLinAmdDepth = Scene_GetColorAndDepth( vec3(0, 1, 0), vRayDir );    \n\n    vColorLinAmdDepth.rgb = max( vColorLinAmdDepth.rgb, vec3(0.0) );\n        \n    vFragColor = vColorLinAmdDepth;\n    \n    \/\/vFragColor.r = fract( atan(vRayDir.x, vRayDir.z) \/ (PI * 2.0) );\n    \n    \/\/ Debug update frequency\n    \/\/vFragColor.r = fract( iTime * 10.0 );\n    \n    if ( vColorLinAmdDepth.r > 40000.0 || vColorLinAmdDepth.g > 40000.0 || vColorLinAmdDepth.b > 40000.0 )\n    {\n        vFragColor = vec4(0.0);\n    }\n\n    if ( iFrame > 60 )\n    {\n        discard;\n    }\n    \n    \/*\n    vec4 textureA = texture( iChannel1, vec2(0,0) );\n    vec4 textureB = texture( iChannel2, vec2(0,0) );\n    vec4 textureC = texture( iChannel3, vec2(0,0) );\n\n    vec4 vFrameData = vec4( 0 );\n    \/\/ Don't stamp output as valud until input textures have loaded\n    if ( length(textureA.rgb) > 0.01 && length(textureB.rgb) > 0.01 && length(textureC.rgb) > 0.01 )\n    {  \n        vFrameData =  vec4( floor(iResolution.x), floor(iResolution.y), 0, 0 );\n    } \n\t*\/\n}","name":"Cube A","description":"","type":"cubemap"}]},{"ver":"0.1","info":{"id":"ld3SDl","date":"1462110373","viewed":9544,"name":"Fast Thin-Film Interference","username":"cornusammonis","description":"A fast and fairly realistic thin-film interference and chromatic dispersion simulation shader.","likes":182,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"\/media\/a\/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"\/media\/ap\/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"\/media\/a\/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"\/media\/ap\/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/*\n\tFast Thin-Film Interference\n\n\tThis is a performance-optimized version of my previous \n\tthin-film interference shader here: https:\/\/www.shadertoy.com\/view\/XddXRj\n\tThis version also fixes a platform-specific bug and has\n\ta few other tweaks as well.\n\n\tThin-film interference and chromatic dispersion are simulated at\n\tsix different wavelengths and then downsampled to RGB.\n*\/\n\n\/\/ To see just the reflection (no refraction\/transmission) uncomment this next line:\n\/\/#define REFLECTANCE_ONLY\n\n\/\/ performance and raymarching options\n#define INTERSECTION_PRECISION 0.01  \/\/ raymarcher intersection precision\n#define ITERATIONS 20\t\t\t\t \/\/ max number of iterations\n#define AA_SAMPLES 1\t\t\t\t \/\/ anti aliasing samples\n#define BOUND 6.0\t\t\t\t\t \/\/ cube bounds check\n#define DIST_SCALE 0.9   \t\t\t \/\/ scaling factor for raymarching position update\n\n\/\/ optical properties\n#define DISPERSION 0.05\t\t\t\t \/\/ dispersion amount\n#define IOR 0.9     \t\t\t\t \/\/ base IOR value specified as a ratio\n#define THICKNESS_SCALE 32.0\t\t \/\/ film thickness scaling factor\n#define THICKNESS_CUBEMAP_SCALE 0.1  \/\/ film thickness cubemap scaling factor\n#define REFLECTANCE_SCALE 3.0        \/\/ reflectance scaling factor\n#define REFLECTANCE_GAMMA_SCALE 2.0  \/\/ reflectance gamma scaling factor\n#define FRESNEL_RATIO 0.7\t\t\t \/\/ fresnel weight for reflectance\n#define SIGMOID_CONTRAST 8.0         \/\/ contrast enhancement\n\n#define TWO_PI 6.28318530718\n#define WAVELENGTHS 6\t\t\t\t \/\/ number of wavelengths, not a free parameter\n\n\/\/ iq's cubemap function\nvec3 fancyCube( sampler2D sam, in vec3 d, in float s, in float b )\n{\n    vec3 colx = textureLod( sam, 0.5 + s*d.yz\/d.x, b ).xyz;\n    vec3 coly = textureLod( sam, 0.5 + s*d.zx\/d.y, b ).xyz;\n    vec3 colz = textureLod( sam, 0.5 + s*d.xy\/d.z, b ).xyz;\n    \n    vec3 n = d*d;\n    \n    return (colx*n.x + coly*n.y + colz*n.z)\/(n.x+n.y+n.z);\n}\n\n\/\/ iq's 3D noise function\nfloat hash( float n ){\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\nvec3 noise3(vec3 x) {\n\treturn vec3( noise(x+vec3(123.456,.567,.37)),\n\t\t\t\t noise(x+vec3(.11,47.43,19.17)),\n\t\t\t\t noise(x) );\n}\n\n\/\/ a sphere with a little bit of warp\nfloat sdf( vec3 p ) {\n\tvec3 n = vec3(sin(iDate.w * 0.5), sin(iDate.w * 0.3), cos(iDate.w * 0.2));\n\tvec3 q = 0.1 * (noise3(p + n) - 0.5);\n  \n\treturn length(q + p) - 3.5;\n}\n\nvec3 fresnel( vec3 rd, vec3 norm, vec3 n2 ) {\n   vec3 r0 = pow((1.0-n2)\/(1.0+n2), vec3(2));\n   return r0 + (1. - r0)*pow(clamp(1. + dot(rd, norm), 0.0, 1.0), 5.);\n}\n\nvec3 calcNormal( in vec3 pos ) {\n    const float eps = INTERSECTION_PRECISION;\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*sdf( pos + v1*eps ) + \n\t\t\t\t\t  v2*sdf( pos + v2*eps ) + \n\t\t\t\t\t  v3*sdf( pos + v3*eps ) + \n\t\t\t\t\t  v4*sdf( pos + v4*eps ) );\n}\n\n#define GAMMA_CURVE 50.0\n#define GAMMA_SCALE 4.5\nvec3 filmic_gamma(vec3 x) {\n\treturn log(GAMMA_CURVE * x + 1.0) \/ GAMMA_SCALE;    \n}\n\nvec3 filmic_gamma_inverse(vec3 y) {\n\treturn (1.0 \/ GAMMA_CURVE) * (exp(GAMMA_SCALE * y) - 1.0); \n}\n\n\/\/ sample weights for the cubemap given a wavelength i\n\/\/ room for improvement in this function\n#define GREEN_WEIGHT 2.8\nvec3 texCubeSampleWeights(float i) {\n\tvec3 w = vec3((1.0 - i) * (1.0 - i), GREEN_WEIGHT * i * (1.0 - i), i * i);\n    return w \/ dot(w, vec3(1.0));\n}\n\nvec3 sampleCubeMap(vec3 i, vec3 rd) {\n\tvec3 col = textureLod(iChannel0, rd * vec3(1.0,-1.0,1.0), 0.0).xyz; \n    return vec3(\n        dot(texCubeSampleWeights(i.x), col),\n        dot(texCubeSampleWeights(i.y), col),\n        dot(texCubeSampleWeights(i.z), col)\n    );\n}\n\nvec3 sampleCubeMap(vec3 i, vec3 rd0, vec3 rd1, vec3 rd2) {\n\tvec3 col0 = textureLod(iChannel0, rd0 * vec3(1.0,-1.0,1.0), 0.0).xyz;\n    vec3 col1 = textureLod(iChannel0, rd1 * vec3(1.0,-1.0,1.0), 0.0).xyz; \n    vec3 col2 = textureLod(iChannel0, rd2 * vec3(1.0,-1.0,1.0), 0.0).xyz; \n    return vec3(\n        dot(texCubeSampleWeights(i.x), col0),\n        dot(texCubeSampleWeights(i.y), col1),\n        dot(texCubeSampleWeights(i.z), col2)\n    );\n}\n\n\n\nvec3 sampleWeights(float i) {\n\treturn vec3((1.0 - i) * (1.0 - i), GREEN_WEIGHT * i * (1.0 - i), i * i);\n}\n\nvec3 resample(vec3 wl0, vec3 wl1, vec3 i0, vec3 i1) {\n\tvec3 w0 = sampleWeights(wl0.x);\n    vec3 w1 = sampleWeights(wl0.y);\n    vec3 w2 = sampleWeights(wl0.z);\n    vec3 w3 = sampleWeights(wl1.x);\n    vec3 w4 = sampleWeights(wl1.y);\n    vec3 w5 = sampleWeights(wl1.z);\n    \n    return i0.x * w0 + i0.y * w1 + i0.z * w2\n         + i1.x * w3 + i1.y * w4 + i1.z * w5;\n}\n\n\/\/ downsample to RGB\nvec3 resampleColor(vec3[WAVELENGTHS] rds, vec3 refl0, vec3 refl1, vec3 wl0, vec3 wl1) {\n\n    \n    #ifdef REFLECTANCE_ONLY\n    \tvec3 intensity0 = refl0;\n    \tvec3 intensity1 = refl1;\n    #else\n        vec3 cube0 = sampleCubeMap(wl0, rds[0], rds[1], rds[2]);\n    \tvec3 cube1 = sampleCubeMap(wl1, rds[3], rds[4], rds[5]);\n    \n        vec3 intensity0 = filmic_gamma_inverse(cube0) + refl0;\n    \tvec3 intensity1 = filmic_gamma_inverse(cube1) + refl1;\n    #endif\n    vec3 col = resample(wl0, wl1, intensity0, intensity1);\n\n    return 1.4 * filmic_gamma(col \/ float(WAVELENGTHS));\n}\n\nvec3 resampleColorSimple(vec3 rd, vec3 wl0, vec3 wl1) {\n    vec3 cube0 = sampleCubeMap(wl0, rd);\n    vec3 cube1 = sampleCubeMap(wl1, rd);\n    \n    vec3 intensity0 = filmic_gamma_inverse(cube0);\n    vec3 intensity1 = filmic_gamma_inverse(cube1);\n    vec3 col = resample(wl0, wl1, intensity0, intensity1);\n\n    return 1.4 * filmic_gamma(col \/ float(WAVELENGTHS));\n}\n\n\/\/ compute the wavelength\/IOR curve values.\nvec3 iorCurve(vec3 x) {\n\treturn x;\n}\n\nvec3 attenuation(float filmThickness, vec3 wavelengths, vec3 normal, vec3 rd) {\n\treturn 0.5 + 0.5 * cos(((THICKNESS_SCALE * filmThickness)\/(wavelengths + 1.0)) * dot(normal, rd));    \n}\n\nvec3 contrast(vec3 x) {\n\treturn 1.0 \/ (1.0 + exp(-SIGMOID_CONTRAST * (x - 0.5)));    \n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in vec4 m ) {\n    camTar = vec3(0.0,0.0,0.0); \n    if (max(m.z, m.w) <= 0.0) {\n    \tfloat an = 1.5 + sin(time * 0.05) * 4.0;\n\t\tcamPos = vec3(6.5*sin(an), 0.0 ,6.5*cos(an));   \n    } else {\n    \tfloat an = 10.0 * m.x - 5.0;\n\t\tcamPos = vec3(6.5*sin(an),10.0 * m.y - 5.0,6.5*cos(an)); \n    }\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)\/iResolution.y;\n    vec4 m = vec4(iMouse.xy\/iResolution.xy, iMouse.zw);\n\n    \/\/ camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m );\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );\n    \n    float dh = (0.666 \/ iResolution.y);\n    const float rads = TWO_PI \/ float(AA_SAMPLES);\n    \n    vec3 col = vec3(0.0);\n    \n    vec3 wavelengths0 = vec3(1.0, 0.8, 0.6);\n    vec3 wavelengths1 = vec3(0.4, 0.2, 0.0);\n    vec3 iors0 = IOR + iorCurve(wavelengths0) * DISPERSION;\n    vec3 iors1 = IOR + iorCurve(wavelengths1) * DISPERSION;\n    \n    vec3 rds[WAVELENGTHS];\n    \n    for (int samp = 0; samp < AA_SAMPLES; samp++) {\n        vec2 dxy = dh * vec2(cos(float(samp) * rads), sin(float(samp) * rads));\n        vec3 rd = normalize(camMat * vec3(p.xy + dxy, 1.5)); \/\/ 1.5 is the lens length\n\t\tvec3 pos = ro;\n        bool hit = false;\n        for (int j = 0; j < ITERATIONS; j++) {\n            float t = DIST_SCALE * sdf(pos);\n            pos += t * rd;\n            hit = t < INTERSECTION_PRECISION;\n            if ( clamp(pos, -BOUND, BOUND) != pos || hit ) {\n                break;    \n            }\n        }\n        \n        if (hit) {\n            vec3 normal = calcNormal(pos);\n\n            float filmThickness = fancyCube( iChannel1, normal, THICKNESS_CUBEMAP_SCALE, 0.0 ).x + 0.1;\n\n            vec3 att0 = attenuation(filmThickness, wavelengths0, normal, rd);\n            vec3 att1 = attenuation(filmThickness, wavelengths1, normal, rd);\n\n            vec3 f0 = (1.0 - FRESNEL_RATIO) + FRESNEL_RATIO * fresnel(rd, normal, 1.0 \/ iors0);\n            vec3 f1 = (1.0 - FRESNEL_RATIO) + FRESNEL_RATIO * fresnel(rd, normal, 1.0 \/ iors1);\n\n            vec3 rrd = reflect(rd, normal);\n\n            vec3 cube0 = REFLECTANCE_GAMMA_SCALE * att0 * sampleCubeMap(wavelengths0, rrd);\n            vec3 cube1 = REFLECTANCE_GAMMA_SCALE * att1 * sampleCubeMap(wavelengths1, rrd);\n\n            vec3 refl0 = REFLECTANCE_SCALE * filmic_gamma_inverse(mix(vec3(0), cube0, f0));\n            vec3 refl1 = REFLECTANCE_SCALE * filmic_gamma_inverse(mix(vec3(0), cube1, f1));\n\n            rds[0] = refract(rd, normal, iors0.x);\n            rds[1] = refract(rd, normal, iors0.y);\n            rds[2] = refract(rd, normal, iors0.z);\n            rds[3] = refract(rd, normal, iors1.x);\n            rds[4] = refract(rd, normal, iors1.y);\n            rds[5] = refract(rd, normal, iors1.z);\n\n            col += resampleColor(rds, refl0, refl1, wavelengths0, wavelengths1);\n        } else {\n        \tcol += resampleColorSimple(rd, wavelengths0, wavelengths1);    \n        }\n\n    }\n    \n    col \/= float(AA_SAMPLES);\n\t   \n    fragColor = vec4( contrast(col), 1.0 );\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"XsfGzn","date":"1357136829","viewed":9524,"name":"Matte compositing","username":"iq","description":"A simple green screen image comping","likes":61,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"\/media\/a\/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"\/media\/ap\/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRr","filepath":"\/media\/a\/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"\/media\/ap\/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n#define METHOD 2  \/\/ try method 1 and method 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy \/ iResolution.xy;\n    \n\tvec3 bg = texture( iChannel0, q ).xyz;\n\tvec3 fg = texture( iChannel1, q ).xyz;\n\t\n    \n    float maxrb = max( fg.r, fg.b );\n    float k = clamp( (fg.g-maxrb)*5.0, 0.0, 1.0 );\n    \n#if METHOD==1\n    \n\tfloat ll = length( fg );\n    fg.g = min( fg.g, maxrb*0.8 );\n    fg = ll*normalize(fg);\n\n#else    \n\n    float dg = fg.g; \n    fg.g = min( fg.g, maxrb*0.8 ); \n    fg += dg - fg.g;\n\n#endif\n\n    fragColor = vec4( mix(fg, bg, k), 1.0 );\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"Md2SR3","date":"1414562258","viewed":9524,"name":"Starfield01","username":"xaot88","description":"Updated with Camera Motion.  A random, procedural starfield.  This shader is very efficient on the GPU, even with thousands of stars.  It's customizable with a single \"threshhold\" value to create denser or sparser starfields.  Comments are welcome!","likes":51,"published":1,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ Return random noise in the range [0.0, 1.0], as a function of x.\nfloat Noise2d( in vec2 x )\n{\n    float xhash = cos( x.x * 37.0 );\n    float yhash = cos( x.y * 57.0 );\n    return fract( 415.92653 * ( xhash + yhash ) );\n}\n\n\/\/ Convert Noise2d() into a \"star field\" by stomping everthing below fThreshhold to zero.\nfloat NoisyStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    float StarVal = Noise2d( vSamplePos );\n    if ( StarVal >= fThreshhold )\n        StarVal = pow( (StarVal - fThreshhold)\/(1.0 - fThreshhold), 6.0 );\n    else\n        StarVal = 0.0;\n    return StarVal;\n}\n\n\/\/ Stabilize NoisyStarField() by only sampling at integer values.\nfloat StableStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    \/\/ Linear interpolation between four samples.\n    \/\/ Note: This approach has some visual artifacts.\n    \/\/ There must be a better way to \"anti alias\" the star field.\n    float fractX = fract( vSamplePos.x );\n    float fractY = fract( vSamplePos.y );\n    vec2 floorSample = floor( vSamplePos );    \n    float v1 = NoisyStarField( floorSample, fThreshhold );\n    float v2 = NoisyStarField( floorSample + vec2( 0.0, 1.0 ), fThreshhold );\n    float v3 = NoisyStarField( floorSample + vec2( 1.0, 0.0 ), fThreshhold );\n    float v4 = NoisyStarField( floorSample + vec2( 1.0, 1.0 ), fThreshhold );\n\n    float StarVal =   v1 * ( 1.0 - fractX ) * ( 1.0 - fractY )\n        \t\t\t+ v2 * ( 1.0 - fractX ) * fractY\n        \t\t\t+ v3 * fractX * ( 1.0 - fractY )\n        \t\t\t+ v4 * fractX * fractY;\n\treturn StarVal;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\/\/ Sky Background Color\n\tvec3 vColor = vec3( 0.1, 0.2, 0.4 ) * fragCoord.y \/ iResolution.y;\n\n    \/\/ Note: Choose fThreshhold in the range [0.99, 0.9999].\n    \/\/ Higher values (i.e., closer to one) yield a sparser starfield.\n    float StarFieldThreshhold = 0.97;\n\n    \/\/ Stars with a slow crawl.\n    float xRate = 0.2;\n    float yRate = -0.06;\n    vec2 vSamplePos = fragCoord.xy + vec2( xRate * float( iFrame ), yRate * float( iFrame ) );\n\tfloat StarVal = StableStarField( vSamplePos, StarFieldThreshhold );\n    vColor += vec3( StarVal );\n\t\n\tfragColor = vec4(vColor, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"Mtl3Rj","date":"1423449458","viewed":9511,"name":"Pseudo Gaussian Blur","username":"Loadus","description":"Same as the quick linear blur, but this time the blending has a sigmoid curve applied to it, similar to the bell curve used for gaussian. Written for speed, not Quality. : )","likes":61,"published":1,"flags":32,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nfloat SCurve (float x) {\n\t\n    \n    \/\/ ---- by CeeJayDK\n\n\t\tx = x * 2.0 - 1.0;\n\t\treturn -x * abs(x) * 0.5 + x + 0.5;\n\t\t\n        \/\/return dot(vec3(-x, 2.0, 1.0 ),vec3(abs(x), x, 1.0)) * 0.5; \/\/ possibly faster version\n\t\n\n    \n    \n    \/\/ ---- original for posterity\n    \n    \/\/ How to do this without if-then-else?\n    \/\/ +edited the too steep curve value\n    \n    \/\/ if (value < 0.5)\n    \/\/ {\n    \/\/    return value * value * 2.0;\n    \/\/ }\n    \n    \/\/ else\n    \/\/ {\n    \/\/ \tvalue -= 1.0;\n    \n    \/\/ \treturn 1.0 - value * value * 2.0;\n    \/\/ }\n}\n\nvec4 BlurH (sampler2D source, vec2 size, vec2 uv, float radius) {\n\n\tif (radius >= 1.0)\n\t{\n\t\tvec4 A = vec4(0.0); \n\t\tvec4 C = vec4(0.0); \n\n\t\tfloat width = 1.0 \/ size.x;\n\n\t\tfloat divisor = 0.0; \n        float weight = 0.0;\n        \n        float radiusMultiplier = 1.0 \/ radius;\n        \n        \/\/ Hardcoded for radius 20 (normally we input the radius\n        \/\/ in there), needs to be literal here\n        \n\t\tfor (float x = -20.0; x <= 20.0; x++)\n\t\t{\n\t\t\tA = texture(source, uv + vec2(x * width, 0.0));\n            \n            \tweight = SCurve(1.0 - (abs(x) * radiusMultiplier)); \n            \n            \tC += A * weight; \n            \n\t\t\tdivisor += weight; \n\t\t}\n\n\t\treturn vec4(C.r \/ divisor, C.g \/ divisor, C.b \/ divisor, 1.0);\n\t}\n\n\treturn texture(source, uv);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n    \n    \/\/ Apply horizontal blur to final output\n\tfragColor = BlurH(iChannel0, iResolution.xy, uv, 20.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sX3Rn","filepath":"\/media\/a\/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"\/media\/ap\/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\nfloat SCurve (float x) {\n\t\n    \n\t\tx = x * 2.0 - 1.0;\n\t\treturn -x * abs(x) * 0.5 + x + 0.5;\n\t\t\n        \/\/return dot(vec3(-x, 2.0, 1.0 ),vec3(abs(x), x, 1.0)) * 0.5; \/\/ possibly faster version\n\n}\n\nvec4 BlurV (sampler2D source, vec2 size, vec2 uv, float radius) {\n\n\tif (radius >= 1.0)\n\t{\n\t\tvec4 A = vec4(0.0); \n\t\tvec4 C = vec4(0.0); \n\n\t\tfloat height = 1.0 \/ size.y;\n\n\t\tfloat divisor = 0.0; \n        float weight = 0.0;\n        \n        float radiusMultiplier = 1.0 \/ radius;\n\n        for (float y = -20.0; y <= 20.0; y++)\n\t\t{\n\t\t\tA = texture(source, uv + vec2(0.0, y * height));\n            \t\n            \tweight = SCurve(1.0 - (abs(y) * radiusMultiplier)); \n            \n            \tC += A * weight; \n            \n\t\t\tdivisor += weight; \n\t\t}\n\n\t\treturn vec4(C.r \/ divisor, C.g \/ divisor, C.b \/ divisor, 1.0);\n\t}\n\n\treturn texture(source, uv);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord.xy \/ iResolution.xy; \n    \n    \/\/ Apply vertical blur to buffer A\n\tfragColor = BlurV(iChannel0, iResolution.xy, uv, 20.0);\n}","name":"Buf A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"4ssXW2","date":"1407004040","viewed":9500,"name":"Alps","username":"Dave_Hoskins","description":"Uses a ridged fractal noise with corrosion effects for higher altitudes. I tried to remove as many artefacts as possible and still have a long draw distance. Now includes fractal wind. :)","likes":115,"published":3,"flags":8,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Alps.\n\/\/ by David Hoskins.\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ https:\/\/www.shadertoy.com\/view\/4ssXW2\n\/\/ Uses a ridged fractal noise with corrosion effects for higher altitudes.\n\n\/\/#define STEREO   \/\/ RED left eye.\n\/\/#define SHADOWS  \/\/ fake shadows.\n#define MOD3 vec3(.0631,.07369,.08787)\n\/\/#define MOD4 vec4(.0631,.07369,.08787, .09987)\nvec3 sunLight  = normalize( vec3(  -0.2, 0.2,  -1.0 ) );\nvec3 sunColour = vec3(1.0, .88, .75);\nfloat specular = 0.0;\nvec3 cameraPos;\nfloat ambient;\nconst vec2 add = vec2(1.0,0.0);\n\n\/\/ This peturbs the fractal positions for each iteration down...\n\/\/ Helps make nice twisted landscapes...\nconst mat2 rotate2D = mat2(1.6623, 1.850, -1.7131, 1.4623);\n\n\/\/--------------------------------------------------------------------------\n\/\/ Noise functions...\n\/\/----------------------------------------------------------------------------------------\nfloat Hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract(p3.x * p3.y * p3.z);\n}\n\/\/--------------------------------------------------------------------------\nfloat Noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(1.5-f)*2.0;\n    \n    float res = mix(mix( Hash12(p), Hash12(p + add.xy),f.x),\n                    mix( Hash12(p + add.yx), Hash12(p + add.xx),f.x),f.y);\n    return res;\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 NoiseD( in vec2 x )\n{\n\tx+=4.2;\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    vec2 u = f*f*(1.5-f)*2.0;;\n    \n    float a = Hash12(p);\n    float b = Hash12(p + add.xy);\n    float c = Hash12(p + add.yx);\n    float d = Hash12(p + add.xx);\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t6.0*f*(f-1.0)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\nfloat Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(1.5-f)*2.0;\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)\/256.0, -0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n#define WARP  .15\n#define SCALE  .0023\n#define HEIGHT 55.\n#define LACUNARITY 2.13\n\/\/--------------------------------------------------------------------------\n\/\/ Low-def version for ray-marching through the height field...\nfloat Terrain( in vec2 p)\n{\n\tp *= SCALE;\n\tfloat sum = 0.0;\n\tfloat freq = 1.;\n\tfloat amp = 3.5;\n\tvec2 dsum = vec2(0,0);\n\tfor(int i=0; i < 5; i++)\n\t{\n\t\tvec3 n = NoiseD(p + (WARP * dsum * freq));\n\t\tsum += amp * (1.0 - abs(n.x-.5)*2.0);\n\t\tdsum += amp * n.yz * -n.x;\n\t\tfreq *= LACUNARITY;\n\t\tamp = amp*.4 * min(sum*.22, 1.0);\n\t\tp = rotate2D * p;\n\t}\n\treturn sum * HEIGHT;\t\n}\n\n\/\/--------------------------------------------------------------------------\n\/\/ High-def version only used for grabbing normal information....\nfloat Terrain2( in vec2 p, in float d)\n{\n    int stop = 1+int(9.0-d*.000004);\n\tp *= SCALE;\n\tfloat sum = 0.0;\n\tfloat freq = 1.;\n\tfloat amp = 3.5;\n\tvec2 dsum = vec2(0,0);\n    vec3 n;\n\tfor(int i=0; i < 9; i++)\n\t{\n        if (i > stop) break;\n\t\tn = NoiseD(p + (WARP * dsum * freq));\n\t\tsum += amp * (1.0 - abs(n.x-.5)*2.0);\n\t\tdsum += amp * n.yz * -n.x;\n\t\tfreq *= LACUNARITY;\n\t\tamp = amp*.4 * min(sum*.22, 1.0);\n        sum += n.x\/(222.5+dot(dsum, dsum));\n\t\tp = rotate2D * p;\n\t}\n\treturn sum * HEIGHT;\n}\n\n\/\/ Low detailed camera version... \nfloat TerrainCam( in vec2 p)\n{\n    \n\tp *= SCALE;\n\tfloat sum = 0.0;\n\tfloat freq = 1.;\n\tfloat amp = 3.5;\n\tvec2 dsum = vec2(0,0);\n\tfor(int i=0; i < 2; i++)\n\t{\n\t\tvec3 n = NoiseD(p + (WARP * dsum * freq));\n\t\tsum += amp * (1.0 - abs(n.x-.5)*2.0);\n\t\tdsum += amp * n.yz * -n.x;\n\t\tfreq *= LACUNARITY;\n\t\tamp = amp*.4 * min(sum*.22, 1.0);\n\t\tp = rotate2D * p;\n\t}\n\treturn sum * HEIGHT;\n\t\n}\n\nfloat FBM( vec3 p )\n{\n    \n    p *= .015;\n    p.xz *= .3;\n    \/\/p.zy -= iTime * .04;\n    \n    float f;\n\tf  = 0.5000\t * Noise(p); p = p * 3.02; \/\/p.y -= gTime*.2;\n\tf += 0.2500\t * Noise(p); p = p * 3.03; \/\/p.y += gTime*.06;\n\tf += 0.1250\t * Noise(p); p = p * 4.01;\n    f += 0.0625\t * Noise(p); p = p * 4.023;\n    \/\/f += 0.03125 * Noise(p);\n    return f;\n}\n\n\n\/\/--------------------------------------------------------------------------\n\/\/ Map to lower resolution for height field mapping for Scene function...\nfloat Map(in vec3 p)\n{\n\tfloat h = Terrain(p.xz);\n    return p.y - h;\n}\n\n\/\/--------------------------------------------------------------------------\nfloat MapClouds(vec3 p)\n{\n\tfloat h = FBM(p)*1.0;\n\treturn (-h+.6);\/\/ + (p.y)*.0002);\n}\n\/\/--------------------------------------------------------------------------\n\/\/ Grab all sky information for a given ray from camera\nvec3 GetSky(in vec3 rd)\n{\n\tfloat v = pow(1.0-max(rd.y,0.0),10.);\n\tvec3  sky = vec3(v*sunColour.x*0.42+.04, v*sunColour.y*0.4+0.09, v*sunColour.z*0.4+.17);\n\treturn sky;\n}\n\n\/\/--------------------------------------------------------------------------\n\/\/ Merge mountains into the sky background for correct disappearance...\nvec3 ApplyFog( in vec3  rgb, in float dis, in vec3 dir)\n{\n\treturn mix(GetSky(dir), rgb, exp(-.000001*dis) );\n}\n\n\/\/--------------------------------------------------------------------------\n\/\/ Calculate sun light...\nvoid DoLighting(inout vec3 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float dis)\n{\n    float h = dot(sunLight,normal);\n\n#ifdef SHADOWS\n   \tvec3  eps = vec3(1.0,0.0,0.0);\n    vec3 nor;\n\tnor.x = Terrain(pos.xz-eps.xy) - Terrain(pos.xz+eps.xy);\n    nor.y = 1.0*eps.x;\n    nor.z = Terrain(pos.xz-eps.yx) - Terrain(pos.xz+eps.yx);\n\tnor = normalize(nor);\n\tfloat shad = clamp(1.0*dot(nor,sunLight), 0.0, 1.0 );\n    float c = max(h, 0.0) * shad;\n#else\n    float c = max(h, 0.0);\n#endif    \n\tvec3 R = reflect(sunLight, normal);\n\tmat = mat * sunColour * c * vec3(.9, .9, 1.0) +  GetSky(R)*ambient;\n\t\/\/ Specular...\n\tif (h > 0.0)\n\t{\n\t\tfloat specAmount = pow( max(dot(R, normalize(eyeDir)), 0.0), 34.0)*specular;\n\t\tmat += sunColour * specAmount;\n\t}\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 TerrainColour(vec3 pos, vec3 normal, float dis)\n{\n\tvec3 mat;\n\tspecular = .0;\n\tambient = .4 * abs(normal.y);\n\tvec3 dir = normalize(pos-cameraPos);\n\t\n\tfloat disSqrd = dis * dis;\/\/ Squaring it gives better distance scales.\n\n\tfloat f = clamp(Noise(pos.xz*.001), 0.0,1.0);\/\/*10.8;\n\tf *= Noise(pos.zx*.2+normal.xz*1.5);\n\t\/\/f *= .5;\n\tmat = mix(vec3(.1), vec3(.1, .07, .01), f);\n\n\t\/\/ Snow...\n\tif (pos.y > 75.0 && normal.y > .2)\n\t{\n\t\tfloat snow = smoothstep(0.0, 1.0, (pos.y - 75.0 - Noise(pos.xz * .3)*Noise(pos.xz * .027)*83.0) * 0.2 * (normal.y));\n\t\tmat = mix(mat, vec3(.8,.9,1.0), min(snow, 1.0));\n\t\tspecular += snow*.7;\n\t\tambient+=snow *.05;\n\t}\n\n\tDoLighting(mat, pos, normal,dir, disSqrd);\n\t\n\tmat = ApplyFog(mat, disSqrd, dir);\n\treturn mat;\n}\n\n\/\/--------------------------------------------------------------------------\nfloat BinarySubdivision(in vec3 rO, in vec3 rD, vec2 dist)\n{\n\t\/\/ Home in on the surface by dividing by two and split...\n\tfor (int n = 0; n < 6; n++)\n\t{\n\t\tfloat halfwayT = (dist.x + dist.y) * .5;\n\t\tvec3 p = rO + halfwayT*rD;\n\t\tMap(p) < .5 ? dist.x = halfwayT : dist.y = halfwayT;\n\t}\n\treturn dist.x;\n}\n\n\/\/--------------------------------------------------------------------------\nbool Scene(in vec3 rO, in vec3 rD, in vec2 uv, out float resT, out vec2 cloud)\n{\n    float t = 10.0 + Hash12(uv*3333.0)* 13.0;\n\tfloat oldT = 0.0;\n\tfloat delta = 0.0;\n\tbool fin = false;\n\tvec2 distances;\n    vec2 shade = cloud = vec2(0.0, 0.0);\n    vec3 p = vec3(0.0);\n\tfor( int j=0; j< 105; j++ )\n\t{\n\t\tif (p.y > 650.0 || t > 1300.0) break;\n\t\tp = rO + t*rD;\n\t\tfloat h = Map(p); \/\/ ...Get this positions height mapping.\n\t\t\/\/ Are we inside, and close enough to fudge a hit?...\n\t\tif( h < .5)\n\t\t{\n\t\t\tfin = true;\n\t\t\tdistances = vec2(t, oldT);\n\t\t\tbreak;\n\t\t}\n        \t\t\n\t\tdelta = clamp(0.5*h, .002, 20.0) + (t*0.004);\n\t\toldT = t;\n\t\tt += delta;\n\n   \t\th = MapClouds(p);\n        \n\t\tshade.y = max(-h, 0.0); \n\t\tshade.x = smoothstep(.03, 1.5, shade.y);\n        \/\/shade.x = shade.x*shade.x;\n\t\tcloud += shade * (1.0 - cloud.y);\n\n\n\t}\n\tif (fin) resT = BinarySubdivision(rO, rD, distances);\n    \n    cloud.x = 1.0-(cloud.x*5.3);\/\/cloud.x = min(pow(max(cloud.x, 0.05), .3), 1.0);\n \n\n\treturn fin;\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 CameraPath( float t )\n{\n\tfloat m = 1.0+(iMouse.x\/iResolution.x)*300.0;\n\tt =((iTime*2.0)+m+4005.0)*.004 + t;\n    vec2 p = 1500.0*vec2( sin(4.5*t), cos(4.0*t) );\n\treturn vec3(-4800.0+p.x, 0.6, -200.0+p.y);\n}\n\n\/\/--------------------------------------------------------------------------\n\/\/ Some would say, most of the magic is done in post! :D\nvec3 PostEffects(vec3 rgb, vec2 uv)\n{\n\n    rgb = mix( rgb, vec3(dot(rgb,vec3(0.333))), -1. );\n    rgb = sqrt(rgb);\n   \trgb *= .5+0.5*pow(70.0*uv.x*(uv.y-.12)*(1.0-uv.x)*(.88-uv.y), 0.2 );\n    \/\/rgb = clamp(rgb+Hash12(rgb.rb+uv*iTime)*.1, 0.0, 1.0);\n\treturn rgb;\n}\n\n\/\/--------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = fragCoord.xy \/ iResolution.xy;\n\tvec2 uv = (-1.0 + 2.0*xy) * vec2(iResolution.x\/iResolution.y,1.0);\n\tvec3 camTar;\n    \n    if (xy.y < .12 || xy.y >= .88)\n\t{\n\t\t\/\/ Top and bottom cine-crop - what a waste! :)\n\t\tfragColor=vec4(vec4(0.0));\n\t\treturn;\n\t}\n\n\t#ifdef STEREO\n\tfloat isCyan = mod(fragCoord.x + mod(fragCoord.y,2.0),2.0);\n\t#endif\n\n\t\/\/ Use several forward heights, of decreasing influence with distance from the camera.\n\n\tcameraPos.xz = CameraPath(0.0).xz;\n\tcamTar.xz\t = CameraPath(.05).xz;\n\tcamTar.y = cameraPos.y = TerrainCam(CameraPath(0.0).xz) + 85.0;\n    cameraPos.y +=  smoothstep(5.0, 0.0, iTime)*180.0;\n    camTar.y -= camTar.y * .005;\n\t\n\tfloat roll = 0.2*sin(iTime*.3);\n\tvec3 cw = normalize(camTar-cameraPos);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = (cross(cw,cp));\n\tvec3 cv = (cross(cu,cw));\n\tvec3 rd = normalize( uv.x*cu + uv.y*cv + 1.4*cw );\n\n\t#ifdef STEREO\n\tcameraPos += 6.*cu*isCyan; \/\/ move camera to the right - the rd vector is still good\n\t#endif\n\n\tvec3 col;\n\tfloat distance;\n    vec2 cloud;\n\tif( !Scene(cameraPos,rd, uv, distance, cloud) )\n\t{\n\t\t\/\/ Missed scene, now just get the sky value...\n\t\tcol = GetSky(rd);\n        float sunAmount = max( dot( rd, sunLight), 0.0 );\n       \tcol = col + sunColour * pow(sunAmount, 8.0)*.8;\n\t\tcol = col+ sunColour * min(pow(sunAmount, 800.0), .4);\n\t} \n\telse\n\t{\n\t\t\/\/ Get world coordinate of landscape...\n\t\tvec3 pos = cameraPos + distance * rd;\n\t\t\/\/ Get normal from sampling the high definition height map\n\t\t\/\/ Use the distance to sample larger gaps to help stop aliasing...\n        float d = distance*distance;\n\t\tfloat p = min(4.0, .0001+.00002 * d);\n        \n\t\tvec3 nor  \t= vec3(0.0,\t\t    Terrain2(pos.xz, d), 0.0);\n\t\tvec3 v2\t\t= nor-vec3(p,\t\tTerrain2(pos.xz+vec2(p,0.0), d), 0.0);\n\t\tvec3 v3\t\t= nor-vec3(0.0,\t\tTerrain2(pos.xz+vec2(0.0,-p), d), -p);\n\t\tnor = cross(v2, v3);\n\t\tnor = normalize(nor);\n\n\t\t\/\/ Get the colour using all available data...\n\t\tcol = TerrainColour(pos, nor, distance);\n\t}\n    float bri = pow(max(dot(rd, sunLight), 0.0), 24.0)*2.0;\n    bri = ((cloud.y)) * bri;\n    col = mix(col, vec3(min(bri+cloud.x * vec3(1.,.95, .9), 1.0)), min(cloud.y*(bri+1.0), 1.0));\n\n\tcol = PostEffects(min(col, 1.0), xy);\n\t\n\t#ifdef STEREO\t\n\tcol *= vec3( isCyan, 1.0-isCyan, 1.0-isCyan );\t\n\t#endif\n\t\n\tfragColor=vec4(col*smoothstep(0.0, 2.0, iTime) ,1.0);\n}\n\n\/\/--------------------------------------------------------------------------","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsfGRr","channel":0}],"code":"\nvec2 Hash( vec2 n)\n{\n\tvec4 p = textureLod( iChannel0, n*vec2(.78271, .32837), 0.0 );\n    return (p.xy + p.zw) * .5; \n}\n\n\/\/--------------------------------------------------------------------------\nvec2 Noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 res = mix(mix( Hash(p + 0.0), Hash(p + vec2(1.0, 0.0)),f.x),\n                   mix( Hash(p + vec2(0.0, 1.0) ), Hash(p + vec2(1.0, 1.0)),f.x),f.y);\n    return res-.5;\n}\n\n\/\/--------------------------------------------------------------------------\nvec2 FBM( vec2 p )\n{\n    vec2 f;\n\tf  = 0.5000\t * Noise(p); p = p * 2.32;\n\tf += 0.2500  * Noise(p); p = p * 2.23;\n\tf += 0.1250  * Noise(p); p = p * 2.31;\n    f += 0.0625  * Noise(p); p = p * 2.28;\n    f += 0.03125 * Noise(p);\n    return f;\n}\n\n\/\/--------------------------------------------------------------------------\nvec2 Wind(float n)\n{\n    vec2 pos = vec2(n * (162.017331), n * (132.066927));\n    vec2 vol = Noise(vec2(n*23.131, -n*42.13254))*1.0 + 1.0;\n    \n    vec2 noise = vec2(FBM(pos*33.313))* vol.x *.5 + vec2(FBM(pos*4.519)) * vol.y;\n    \n\treturn noise;\n}\n\n\/\/--------------------------------------------------------------------------\nvec2 mainSound( in int samp,float time)\n{\n    vec2 audio = Wind(time*.1) * 6.0;\n    return clamp(audio, -1.0, 1.0) * (smoothstep(0.0, 2.0, time) * smoothstep(180.0, 175.0, time));;\n}","name":"Sound","description":"","type":"sound"}]},{"ver":"0.1","info":{"id":"XlXcW4","date":"1504747362","viewed":9489,"name":"Integer Hash - II","username":"iq","description":"Based on [url=https:\/\/www.shadertoy.com\/view\/4tfyW4]4tfyW4[\/url]. but simpler and faster. See [url]https:\/\/www.shadertoy.com\/view\/llGSzw[\/url] too.","likes":73,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ The MIT License\n\/\/ Copyright \u00a9 2017 Inigo Quilez\n\/\/ Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\/\/ Based on https:\/\/www.shadertoy.com\/view\/4tfyW4, but simpler and faster\n\/\/\n\/\/ See these too: \n\/\/\n\/\/ - https:\/\/www.shadertoy.com\/view\/llGSzw\n\/\/ - https:\/\/www.shadertoy.com\/view\/XlXcW4\n\/\/ - https:\/\/www.shadertoy.com\/view\/4tXyWN\n\/\/\n\/\/ Not testes for uniformity, stratification, periodicity or whatever. Use (or not!) at your own risk\n\n\n  const uint k = 1103515245U;  \/\/ GLIB C\n\/\/const uint k = 134775813U;   \/\/ Delphi and Turbo Pascal\n\/\/const uint k = 20170906U;    \/\/ Today's date (use three days ago's dateif you want a prime)\n\/\/const uint k = 1664525U;     \/\/ Numerical Recipes\n\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0\/float(0xffffffffU));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uvec3 p = uvec3(fragCoord, iFrame);\n    \n    fragColor = vec4( hash(p), 1.0 );\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"Wt2BR1","date":"1598321080","viewed":9471,"name":"Emergence of life","username":"michael0884","description":"No really, what the heck","likes":180,"published":3,"flags":48,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"\/media\/a\/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"\/media\/ap\/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"\/media\/a\/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"\/media\/ap\/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"\/media\/previz\/buffer03.png","previewfilepath":"\/media\/previz\/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Fork of \"Fireballs\" by michael0884. https:\/\/shadertoy.com\/view\/tlfBDX\n\/\/ 2020-08-20 00:44:41\n\n\/\/ Fork of \"Random slime mold generator\" by michael0884. https:\/\/shadertoy.com\/view\/ttsfWn\n\/\/ 2020-08-19 23:28:40\n\n\/\/ Fork of \"Everflow\" by michael0884. https:\/\/shadertoy.com\/view\/ttBcWm\n\/\/ 2020-07-19 18:18:22\n\n\/\/ Fork of \"Paint streams\" by michael0884. https:\/\/shadertoy.com\/view\/WtfyDj\n\/\/ 2020-07-11 22:38:47\n\n\/\/3d mode\n\/\/#define heightmap\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); \/\/ cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n#define FOV 1.56\n#define RAD R.x*0.6\n\nfloat gauss(float x, float r)\n{\n    x\/=r;\n    return exp(-x*x);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat rho(vec3 pos)\n{\n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    vec4 v = P(pos.xy);\n    return v.z;\n}\n\nvec3 color(vec3 pos)\n{\n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n\n    vec4 v = C(pos.xy);\n    return v.xyz;\n}\n\n\nfloat DE(vec3 pos)\n{\n    float y = 16.*rho(pos);  \n    \n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    float de = 1e10;\n    de = min(de, 0.7*sdBox(pos - vec3(R, 4.*y)*0.5, vec3(R*0.51, 3.)));\n    return de;\n}\n\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 K = vec3(1,-1,0);\n\treturn  (K.xyyx*DE(p + K.xyy*dx) +\n\t\t\t K.yyxx*DE(p + K.yyx*dx) +\n\t\t\t K.yxyx*DE(p + K.yxy*dx) +\n\t\t\t K.xxxx*DE(p + K.xxx*dx))\/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\n#define marches 70.\n#define min_d 1.\nvec4 ray_march(vec3 p, vec3 r)\n{\n    float d;\n    for(float i = 0.; i < marches; i++)\n    {\n        d = DE(p); \n        p += r*d;\n        if(d < min_d || d > R.x) break;\n    }\n    return vec4(p, d);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{    \n    #ifdef heightmap\n        \/\/ Normalized pixel coordinates \n        pos = (pos - R*0.5)\/max(R.x,R.y);\n\t\tpos = vec2(pos.x, pos.y);\n        vec2 uv = iMouse.xy\/R;\n        vec2 angles = vec2(-1.5 + 0.03*iTime, -0.4)*PI;\n\n        vec3 camera_z = vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n        vec3 camera_x = normalize(vec3(cos(angles.x+PI*0.5), sin(angles.x+PI*0.5),0.)); \n        vec3 camera_y = -normalize(cross(camera_x,camera_z));\n\n        \/\/tracking particle\n        vec4 fp = vec4(R*0.5 + 0.*vec2(150.*iTime, 0.), 0., 0.);\n\n        vec3 ray = normalize(camera_z + FOV*(pos.x*camera_x + pos.y*camera_y));\n        vec3 cam_pos = vec3(fp.xy-R*0.5, 0.) - RAD*vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n\n        vec4 X = ray_march(cam_pos, ray);\n\n        if(X.w < min_d)\n        {\n\n            float D = rho(X.xyz);\n          \tvec3 c = color(X.xyz);\n           \n            vec3 albedo =sin(vec3(1,2,3)*3.*D*D);\n            float rough = 1. - 0.1*distance(albedo, vec3(1.));\n\n            vec4 N0 = calcNormal(X.xyz, 2.*X.w)*vec4(4.,4.,1.,1.);\n            vec3 n = normalize(N0.xyz);\n            vec3 rd = reflect(ray, n);\n            vec3 colA =texture(iChannel2,  rd.yzx).xyz;\n            vec3 colB = (vec3(0.5) + 0.5*dot(rd, normalize(vec3(1.))));\n            colB += 4.*rough*pow(max(dot(rd, normalize(vec3(1.))), 0.), 8.);\n            colB += 4.*rough*pow(max(dot(rd, normalize(vec3(-0.5,-0.9,0.8))), 0.), 8.);\n            float b = clamp(0.5 + 0.5*dot(n, normalize(vec3(1,1,1))), 0.,1.);\n            float K = 1. - pow(max(dot(n,rd),0.), 2.);\n            col.xyz = 1.*albedo*colB + 0.*rough*colA*K;\n        }\n        else\n        {    \n            \/\/background\n            col = 1.*texture(iChannel2,  ray.yzx);\n        }\n    col = tanh(2.*col);\n    #else\n    \tfloat r = P(pos.xy).z;\n    \tvec4 c = C(pos.xy);\n    \t\n    \t\/\/get neighbor data\n        vec4 d_u = T(pos + dx.xy), d_d = T(pos - dx.xy);\n        vec4 d_r = T(pos + dx.yx), d_l = T(pos - dx.yx);\n        \n        \/\/position deltas\n        vec2 p_u = DECODE(d_u.x), p_d = DECODE(d_d.x);\n        vec2 p_r = DECODE(d_r.x), p_l = DECODE(d_l.x);\n        \n        \/\/velocities\n        vec2 v_u = DECODE(d_u.y), v_d = DECODE(d_d.y);\n        vec2 v_r = DECODE(d_r.y), v_l = DECODE(d_l.y);\n       \n        \/\/pressure gradient\n        vec2 p = vec2(Pressure(d_r) - Pressure(d_l),\n                      Pressure(d_u) - Pressure(d_d));\n        \n        \/\/velocity operators\n        float div = (v_r.x - v_l.x + v_u.y - v_d.y);\n        float curl = (v_r.y - v_l.y - v_u.x + v_d.x);\n    \t\n    \t\n    \tcol=sin(vec4(1,2,3,4)*25.*r*r*r);\n    \t\/\/col.xyz += vec3(1,0.1,0.1)*max(curl,0.) + vec3(0.1,0.1,1.)*max(-curl,0.);\n    \t\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define T(p) texelFetch(iChannel0, ivec2(mod(p,R)), 0)\n#define P(p) texture(iChannel0, mod(p,R)\/R)\n#define C(p) texture(iChannel1, mod(p,R)\/R)\n#define D(p) texture(iChannel2, mod(p,R)\/R)\n\n#define PI 3.14159265\n#define dt 1.\n#define R iResolution.xy\n\nconst vec2 dx = vec2(0, 1);\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n#define rand_interval 250\n#define random_gen(a, b, seed) ((a) + ((b)-(a))*hash11(seed + float(iFrame\/rand_interval)))\n\n\/\/i.e. diffusion \n#define distribution_size 1.7\n\n\/\/slime mold sensors\n#define sense_num 12\n#define sense_ang 0.2\n#define sense_dis 40.\n\/\/weird oscillation force\n#define sense_oscil 0.0 \n#define oscil_scale 1.\n#define oscil_pow 1.\n#define sense_force 0.11\n\/\/slime mold sensor distance power law dist = sense_dispow(rho, pw)\n#define distance_scale 0.\n#define force_scale 2.\n#define acceleration 0.\n\n#define density_normalization_speed 0.25\n#define density_target 0.24\n#define vorticity_confinement 0.0\n\n\/\/useful functions\n#define GS(x) exp(-dot(x,x))\n#define GSS(x) exp(-dot(x,x))\n#define GS0(x) exp(-length(x))\n#define Dir(ang) vec2(cos(ang), sin(ang))\n#define Rot(ang) mat2(cos(ang), sin(ang), -sin(ang), cos(ang))\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n\/\/SPH pressure\n   \n\/\/density*temp = pressure - i.e. ideal gas law\n#define Pressure(rho) 0.9*rho.z\n#define fluid_rho 0.2\n\n\n\/\/data packing\n#define PACK(X) ( uint(round(65534.0*clamp(0.5*X.x+0.5, 0., 1.))) + \\\n           65535u*uint(round(65534.0*clamp(0.5*X.y+0.5, 0., 1.))) )   \n               \n#define UNPACK(X) (clamp(vec2(X%65535u, X\/65535u)\/65534.0, 0.,1.)*2.0 - 1.0)              \n\n#define DECODE(X) UNPACK(floatBitsToUint(X))\n#define ENCODE(X) uintBitsToFloat(PACK(X))","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"\/presets\/tex00.jpg","previewfilepath":"\/presets\/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    vec2 X = vec2(0);\n    vec2 V = vec2(0);\n    float M = 0.;\n    \n    \/\/basically integral over all updated neighbor distributions\n    \/\/that fall inside of this pixel\n    \/\/this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n       \n        vec2 X0 = DECODE(data.x) + tpos;\n    \tvec2 V0 = DECODE(data.y);\n    \tvec2 M0 = data.zw;\n       \n        X0 += V0*dt; \/\/integrate position\n\n        \/\/particle distribution size\n        float K = distribution_size;\n        \n        vec4 aabbX = vec4(max(pos - 0.5, X0 - K*0.5), min(pos + 0.5, X0 + K*0.5)); \/\/overlap aabb\n        vec2 center = 0.5*(aabbX.xy + aabbX.zw); \/\/center of mass\n        vec2 size = max(aabbX.zw - aabbX.xy, 0.); \/\/only positive\n        \n        \/\/the deposited mass into this cell\n        float m = M0.x*size.x*size.y\/(K*K); \n        \n        \/\/add weighted by mass\n        X += center*m;\n        V += V0*m;\n      \n        \/\/add mass\n        M += m;\n    }\n    \n    \/\/normalization\n    if(M != 0.)\n    {\n        X \/= M;\n        V \/= M;\n    }\n    \n    \/\/mass renormalization\n    float prevM = M;\n    M = mix(M, density_target, density_normalization_speed);\n    V = V*prevM\/M;\n    \n    \/\/initial condition\n    if(iFrame < 1 || isKeyPressed(KEY_SPACE))\n    {\n        X = pos;\n        vec2 dx0 = (pos - R*0.3); vec2 dx1 = (pos - R*0.7);\n        V = 0.5*Rot(PI*0.5)*dx0*GS(dx0\/30.) - 0.5*Rot(PI*0.5)*dx1*GS(dx1\/30.);\n        V += 0.2*Dir(2.*PI*hash11(floor(pos.x\/20.) + R.x*floor(pos.y\/20.)));\n        M = 0.1 + pos.x\/R.x*0.01 + pos.y\/R.x*0.01;\n    }\n    \n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"\/media\/previz\/buffer03.png","previewfilepath":"\/media\/previz\/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 uv = pos\/R;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = T(pos); \n    vec2 X = DECODE(data.x) + pos;\n    vec2 V = DECODE(data.y);\n    float M = data.z;\n    \n    if(M != 0.) \/\/not vacuum\n    {\n        \/\/Compute the force\n        vec2 F = vec2(0.);\n        \n        \/\/get neighbor data\n        vec4 d_u = T(pos + dx.xy), d_d = T(pos - dx.xy);\n        vec4 d_r = T(pos + dx.yx), d_l = T(pos - dx.yx);\n        \n        \/\/position deltas\n        vec2 p_u = DECODE(d_u.x), p_d = DECODE(d_d.x);\n        vec2 p_r = DECODE(d_r.x), p_l = DECODE(d_l.x);\n        \n        \/\/velocities\n        vec2 v_u = DECODE(d_u.y), v_d = DECODE(d_d.y);\n        vec2 v_r = DECODE(d_r.y), v_l = DECODE(d_l.y);\n       \n        \n        \n        \/\/pressure gradient\n        vec2 p = vec2(Pressure(d_r) - Pressure(d_l),\n                      Pressure(d_u) - Pressure(d_d));\n        \n        \/\/density gradient\n        vec2 dgrad = vec2(d_r.z - d_l.z,\n                      d_u.z - d_d.z);\n        \n        \/\/velocity operators\n        float div = v_r.x - v_l.x + v_u.y - v_d.y;\n        float curl = v_r.y - v_l.y - v_u.x + v_d.x;\n        \/\/vec2 laplacian = \n     \n        F -= 1.0*M*p;\n        \n\n        float ang = atan(V.y, V.x);\n        float dang =sense_ang*PI\/float(sense_num);\n        vec2 slimeF = vec2(0.);\n        \/\/slime mold sensors\n        range(i, -sense_num, sense_num)\n        {\n            float cang = ang + float(i) * dang;\n        \tvec2 dir = (1. + sense_dis*pow(M, distance_scale))*Dir(cang);\n        \tvec3 s0 = C(X + dir).xyz;  \n   \t\t\tfloat fs = pow(s0.z, force_scale);\n            float os = oscil_scale*pow(s0.z - M, oscil_pow);\n        \tslimeF +=  sense_oscil*Rot(os)*s0.xy \n                     + sense_force*Dir(ang + sign(float(i))*PI*0.5)*fs; \n        }\n        \n        \/\/remove acceleration component from slime force and leave rotation only\n        slimeF -= dot(slimeF, normalize(V))*normalize(V);\n\t\tF += slimeF\/float(2*sense_num);\n        \n        if(iMouse.z > 0.)\n        {\n            vec2 dx= pos - iMouse.xy;\n             F += 0.1*Rot(PI*0.5)*dx*GS(dx\/30.);\n        }\n        \n        \/\/integrate velocity\n        V += Rot(-vorticity_confinement*curl)*F*dt\/M;\n        \n        \/\/acceleration for fun effects\n        V *= 1. + acceleration;\n        \n        \/\/velocity limit\n        float v = length(V);\n        V \/= (v > 1.)?v\/1.:1.;\n    }\n    \n    \/\/mass decay\n   \/\/ M *= 0.999;\n    \n    \/\/input\n    \/\/if(iMouse.z > 0.)\n    \/\/\\\\\tM = mix(M, 0.5, GS((pos - iMouse.xy)\/13.));\n    \/\/else\n     \/\/   M = mix(M, 0.5, GS((pos - R*0.5)\/13.));\n    \n    \/\/save\n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"#define radius 2.\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    float rho = 0.001;\n    vec2 vel = vec2(0., 0.);\n\n    \/\/compute the smoothed density and velocity\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n\n        vec2 X0 = DECODE(data.x) + tpos;\n        vec2 V0 = DECODE(data.y);\n        float M0 = data.z;\n        vec2 dx = X0 - pos;\n\n        float K = GS(dx\/radius)\/(radius);\n        rho += M0*K;\n        vel += M0*K*V0;\n    }\n\n    vel \/= rho;\n\n    fragColor = vec4(vel, rho, 1.0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dfGRn","filepath":"\/media\/a\/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"\/media\/ap\/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"\/presets\/tex00.jpg","previewfilepath":"\/presets\/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"\/media\/previz\/buffer03.png","previewfilepath":"\/media\/previz\/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\/\/normal advection\nconst int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    vec2 V0 = vec2(0.);\n    if(iFrame%1 == 0)\n    {\n    \tvec4 data = T(pos);\n    \tV0 = 1.*DECODE(data.y);\n   \t\tfloat M0 = data.z;\n    }\n    else\n    {\n      \n    }\n    \n    fragColor = C(pos - V0*dt);\n    \/\/initial condition\n    if(iFrame < 1 || isKeyPressed(KEY_SPACE))\n    {\n        fragColor.xy = pos\/R;\n    }\n}","name":"Buffer D","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"lssGzn","date":"1361875819","viewed":9470,"name":"Coffee and Tablet","username":"P_Malin","description":"Use the mouse to rotate.\nI wanted to combine some raymarching with interesting materials and lighting.\nBased on the textureless version here: http:\/\/glsl.heroku.com\/e#6171.0","likes":65,"published":3,"flags":1,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"\/media\/a\/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"\/media\/ap\/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3Rn","filepath":"\/media\/a\/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"\/media\/ap\/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rn","filepath":"\/media\/a\/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"\/media\/ap\/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"\/media\/a\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"\/media\/ap\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Coffee & Tablet - @P_Malin\n\n#define PI 3.141592654\n\n\/\/#define LOW_QUALITY\n\n\/\/#define ENABLE_MONTE_CARLO\n#define ENABLE_REFLECTIONS\n#define ENABLE_FOG\n#define ENABLE_SPECULAR\n#define ENABLE_POINT_LIGHT\n#define ENABLE_POINT_LIGHT_FLARE\n\n#ifdef LOW_QUALITY\n\n#define kRaymarchMatIter 32\n\n#else\n\n#define kRaymarchMatIter 128\n\n#endif\n\n#ifdef ENABLE_MONTE_CARLO\nuniform sampler2D backbuffer;\n\nvec4 gPixelRandom;\nvec3 gRandomNormal;\n \nvoid CalcPixelRandom( const in vec2 fragCoord, float seed )\n{\n\tvec2 vOffset = fract(sin(seed * 123.3 + vec2(0.2, 0.43)) * 30.0);\n\tgPixelRandom = texture(iChannel3, fragCoord.xy \/ 64.0 + vOffset);\n\tgRandomNormal = normalize( gPixelRandom.xyz - 0.5);\n}\n \n#endif\n \n \nstruct C_Ray\n{\n\tvec3 vOrigin;\n\tvec3 vDir;\n};\n\nstruct C_HitInfo\n{\n\tvec3 vPos;\n\tfloat fDistance;\n\tvec3 vObjectId;\n};\n\nstruct C_Material\n{\n\tvec3 cAlbedo;\n\tfloat fR0;\n\tfloat fSmoothness;\n\tvec2 vParam;\n};\n\nvec2 SinCos( const in float x )\n{\n\treturn vec2(sin(x), cos(x));\n}\n\t\nvec3 RotateX( const in vec3 vPos, const in vec2 vSinCos )\n{\n\treturn vec3( vPos.x, vSinCos.y * vPos.y + vSinCos.x * vPos.z, -vSinCos.x * vPos.y + vSinCos.y * vPos.z);\n}\n\nvec3 RotateY( const in vec3 vPos, const in vec2 vSinCos )\n{\n\treturn vec3( vSinCos.y * vPos.x + vSinCos.x * vPos.z, vPos.y, -vSinCos.x * vPos.x + vSinCos.y * vPos.z );\n}\n\nvec3 RotateZ( const in vec3 vPos, const in vec2 vSinCos )\n{\n\treturn vec3( vSinCos.y * vPos.x + vSinCos.x * vPos.y, -vSinCos.x * vPos.x + vSinCos.y * vPos.y, vPos.z);\n}\n\t\nvec3 RotateX( const in vec3 vPos, const in float fAngle )\n{\n\treturn RotateX( vPos, SinCos(fAngle) );\n}\n\nvec3 RotateY( const in vec3 vPos, const in float fAngle )\n{\n\treturn RotateY( vPos, SinCos(fAngle) );\n}\n      \nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n\treturn RotateZ( vPos, SinCos(fAngle) );\n}\n\nvec4 DistCombineUnion( const in vec4 v1, const in vec4 v2 )\n{\n\t\/\/if(v1.x < v2.x) return v1; else return v2;\n\treturn mix(v1, v2, step(v2.x, v1.x));\n}\n\nvec4 DistCombineIntersect( const in vec4 v1, const in vec4 v2 )\n{\n\treturn mix(v2, v1, step(v2.x,v1.x));\n}\n\nvec4 DistCombineSubtract( const in vec4 v1, const in vec4 v2 )\n{\n\treturn DistCombineIntersect(v1, vec4(-v2.x, v2.yzw));\n}\n\nfloat GetDistanceYZTorus( const in vec3 p, const in float r1, const in float r2 )\n{\n\tvec2 q = vec2(length(p.yz)-r1,p.x);\n\treturn length(q)-r2;\n}\n\nfloat GetDistanceRoundedBox( const in vec3 vPos, const in vec3 vSize, float fRadius )\n{\n\tvec3 vClosest = max(min(vPos, vSize), -vSize);\n\treturn length(vClosest - vPos) - fRadius;\n}\n\n\nfloat GetDistanceMug( const in vec3 vPos )\n{\n\tfloat fDistCylinderOutside = length(vPos.xz) - 1.0;\n\tfloat fDistCylinderInterior = length(vPos.xz) - 0.9;\n\tfloat fTop = vPos.y - 1.0;\n       \n\tfloat r1 = 0.6;\n\tfloat r2 = 0.15;\n\tvec2 q = vec2(length(vPos.xy + vec2(1.2, -0.1))-r1,vPos.z);\n\tfloat fDistHandle = length(q)-r2;\n       \n\tfloat fDistMug = max(max(min(fDistCylinderOutside, fDistHandle), fTop), -fDistCylinderInterior);\n\treturn fDistMug;\n}\n\nfloat GetDistanceCoffee( const in vec3 vPos )\n{\n\tfloat fTopCoffee = vPos.y - 0.7;\n\tfloat fDistCylinderCoffee = length(vPos.xz) - 0.95;\n\t\n\tfloat fDistCoffee = max(fTopCoffee, fDistCylinderCoffee);\n\treturn fDistCoffee;\n}\n\nvec4 GetDistanceTablet( const in vec3 vPos )\n{             \n\tvec3 vBevelPos = vPos - vec3(0.0, 1.71, 0.0);\n\tfloat r = 1.0;\n\tfloat fBevelDist = GetDistanceRoundedBox( vBevelPos, vec3(1.5, 1.0, 2.0), r );\n\n\tvec3 vCasePos = vPos - vec3(0.0, 0.0, 0.0);\n\tfloat fCaseDist = GetDistanceRoundedBox( vCasePos, vec3(1.5, 1.0, 2.0), 0.5 );\n\n\tvec4 vResult = vec4(max(fBevelDist, fCaseDist), 4.0, vPos.xz);\n\t\n\tvec4 vScreenDist = vec4(-vPos.y, 5.0, vPos.xz);\n\tvResult = DistCombineSubtract(vResult, vScreenDist);\n       \n\tvec4 vButtonDist = vec4( length(vPos + vec3(0.0, -0.25, 2.1)) - 0.3, 5.0, vPos.xz);\n\tvResult = DistCombineSubtract(vResult, vButtonDist);\n\t\n\treturn vResult;\n}\n\n\/\/ result is x=scene distance y=material or object id; zw are material specific parameters (maybe uv co-ordinates)\nvec4 GetDistanceScene( const in vec3 vPos )\n{           \n\tvec4 vResult = vec4(10000.0, -1.0, 0.0, 0.0);\n\t\n\tvec3 vMugDomain = vPos + vec3(2.4, 0.0, -2.0);\n\tvMugDomain = RotateY(vMugDomain, 1.0);\n\t\n\tvec4 vDistMug = vec4( GetDistanceMug(vMugDomain), 2.0, atan(vMugDomain.z,vMugDomain.x), vMugDomain.y);\n\tvResult = DistCombineUnion(vResult, vDistMug);\n\t\n\tvec4 vDistCoffee = vec4( GetDistanceCoffee(vMugDomain), 3.0, vMugDomain.xz);\n\tvResult = DistCombineUnion(vResult, vDistCoffee);\n\t\n\tvec4 vDistFloor = vec4(vPos.y + 1.0, 1.0, vPos.xz);\n\tvResult = DistCombineUnion(vResult, vDistFloor);\n\t\n\tvec3 vTabletDomain = vPos;\n\tvTabletDomain += vec3(-0.8, 0.7, 0.0);\n\tvTabletDomain = RotateY(vTabletDomain, -1.0);\n\tvec4 vDistTablet = GetDistanceTablet(vTabletDomain);\n\tvResult = DistCombineUnion(vResult, vDistTablet);\n\t\n\treturn vResult;\n}\n \nC_Material GetObjectMaterial( const in vec3 vObjId, const in vec3 vPos )\n{\n\tC_Material mat;\n\t\n\tif(vObjId.x < 1.5)\n\t{\n\t\t\/\/ floor\n\t\tvec4 cTextureSample = texture(iChannel0, vPos.xz * 0.2);                    \n\t\tmat.fR0 = 0.02;\n\t\tmat.cAlbedo = cTextureSample.rgb * cTextureSample.rgb; \/\/ cheap gamma\n\t\tmat.fSmoothness = mat.cAlbedo.r;\n\t}\n\telse\n\tif(vObjId.x < 2.5)\n\t{\n\t\t\/\/ mug\n\t\tmat.fR0 = 0.05;\n\t\tmat.fSmoothness = 0.9;\n\t\tvec2 vUV = vObjId.yz \/ vec2(PI, -2.0) + vec2(1.0, 0.5);\n\t\tvUV = clamp( vUV, 0.0, 1.0);\n\t\tvUV = (vUV \/ (vec2(6.0,1.0)) - vec2(0.0,0.0));\n\t\tvec4 cTextureSample = texture(iChannel2, vUV);  \n\t\tvec3 vColour = cTextureSample.rgb * cTextureSample.rgb;\n\t\tmat.cAlbedo = mix(vec3(0.05, 0.35, 0.75), vColour, cTextureSample.a);\n\t}\n\telse\n\tif(vObjId.x < 3.5)\n\t{\n\t\t\/\/ coffee\n\t\tmat.fR0 = 0.01;\n\t\tmat.fSmoothness = 1.0;\n\t\tmat.cAlbedo = vec3(0.5, 0.3, 0.2);\n\t}\n\telse\n\tif(vObjId.x < 4.5)\n\t{\n\t\t\/\/ tablet back\n\t\tmat.fR0 = 0.25;\n\t\tmat.fSmoothness = 0.0;\n\t\tmat.cAlbedo = vec3(0.8, 0.8, 0.8);                            \n\t}\n\telse\n\t{\n\t\t\/\/ tablet screen\n\t\tmat.fR0 = 0.01;\n\t\tmat.fSmoothness = 1.0;                               \n\t\tmat.cAlbedo = vec3(0.025);\n\t}\n               \t\n\t\n\treturn mat;\n}\n \nvec3 GetSkyGradient( const in vec3 vDir )\n{\n\tfloat fBlend = vDir.y * 0.5 + 0.5;\n\treturn mix(vec3(0.0, 0.0, 0.0), vec3(0.4, 0.9, 1.0), fBlend);\n}\n \nvec3 GetLightPos()\n{\n\tvec3 vLightPos = vec3(0.0, 1.0, 3.0);\n\t#ifdef ENABLE_MONTE_CARLO         \n\tvLightPos += gRandomNormal * 0.2;\n\t#endif\n\treturn vLightPos;\n}\n \nvec3 GetLightCol()\n{\n\treturn vec3(32.0, 6.0, 1.0);\n}\n\nvec3 GetAmbientLight(const in vec3 vNormal)\n{\n\treturn GetSkyGradient(vNormal);\n}\n \n#define kFogDensity 0.025\nvoid ApplyAtmosphere(inout vec3 col, const in C_Ray ray, const in C_HitInfo intersection)\n{\n\t#ifdef ENABLE_FOG\n\t\/\/ fog\n\tfloat fFogAmount = exp(intersection.fDistance * -kFogDensity);\n\tvec3 cFog = GetSkyGradient(ray.vDir);\n\tcol = mix(cFog, col, fFogAmount);\n\t#endif\n\t\n\t\/\/ glare from light (a bit hacky - use length of closest approach from ray to light)\n\t#ifdef ENABLE_POINT_LIGHT_FLARE\n\tvec3 vToLight = GetLightPos() - ray.vOrigin;\n\tfloat fDot = dot(vToLight, ray.vDir);\n\tfDot = clamp(fDot, 0.0, intersection.fDistance);\n\t\n\tvec3 vClosestPoint = ray.vOrigin + ray.vDir * fDot;\n\tfloat fDist = length(vClosestPoint - GetLightPos());\n\tcol += GetLightCol() * 0.01\/ (fDist * fDist);\n\t#endif      \n}\n \nvec3 GetSceneNormal( const in vec3 vPos )\n{\n\t\/\/ tetrahedron normal\n\tfloat fDelta = 0.025;\n\n\tvec3 vOffset1 = vec3( fDelta, -fDelta, -fDelta);\n\tvec3 vOffset2 = vec3(-fDelta, -fDelta,  fDelta);\n\tvec3 vOffset3 = vec3(-fDelta,  fDelta, -fDelta);\n\tvec3 vOffset4 = vec3( fDelta,  fDelta,  fDelta);\n\n\tfloat f1 = GetDistanceScene( vPos + vOffset1 ).x;\n\tfloat f2 = GetDistanceScene( vPos + vOffset2 ).x;\n\tfloat f3 = GetDistanceScene( vPos + vOffset3 ).x;\n\tfloat f4 = GetDistanceScene( vPos + vOffset4 ).x;\n\n\tvec3 vNormal = vOffset1 * f1 + vOffset2 * f2 + vOffset3 * f3 + vOffset4 * f4;\n\n\treturn normalize( vNormal );\n}\n \n#define kRaymarchEpsilon 0.01\n#define kRaymarchStartDistance 0.1\n \n\/\/ This is an excellent resource on ray marching -> https:\/\/iquilezles.org\/articles\/distfunctions\nvoid Raymarch( const in C_Ray ray, out C_HitInfo result, const float fMaxDist, const int maxIter )\n{          \n\tresult.fDistance = kRaymarchStartDistance;\n\tresult.vObjectId.x = 0.0;\n\t\t\t\t    \n\tfor(int i=0;i<=kRaymarchMatIter;i++)                \n\t{\n\t\tresult.vPos = ray.vOrigin + ray.vDir * result.fDistance;\n\t\tvec4 vSceneDist = GetDistanceScene( result.vPos );\n\t\tresult.vObjectId = vSceneDist.yzw;\n\t\t\n\t\t\/\/ abs allows backward stepping - should only be necessary for non uniform distance functions\n\t\tif((abs(vSceneDist.x) <= kRaymarchEpsilon) || (result.fDistance >= fMaxDist) || (i > maxIter))\n\t\t{\n\t\t\tbreak;\n\t\t}                          \t\n\t\t\n\t\tresult.fDistance = result.fDistance + vSceneDist.x;      \n\t}\n\t\n\t\n\tif(result.fDistance >= fMaxDist)\n\t{\n\t\tresult.vPos = ray.vOrigin + ray.vDir * result.fDistance;\n\t\tresult.vObjectId.x = 0.0;\n\t\tresult.fDistance = 1000.0;\n\t}\n}\n \nfloat GetShadow( const in vec3 vPos, const in vec3 vLightDir, const in float fLightDistance )\n{\n\tC_Ray shadowRay;\n\tshadowRay.vDir = vLightDir;\n\tshadowRay.vOrigin = vPos;\n\n\tC_HitInfo shadowIntersect;\n\tRaymarch(shadowRay, shadowIntersect, fLightDistance, 32);\n\t\t\t\t\t\t\t\t\t\t\t\t\t     \n\treturn step(0.0, shadowIntersect.fDistance) * step(fLightDistance, shadowIntersect.fDistance );           \n}\n \n\/\/ http:\/\/en.wikipedia.org\/wiki\/Schlick's_approximation\nfloat Schlick( const in vec3 vNormal, const in vec3 vView, const in float fR0, const in float fSmoothFactor)\n{\n\tfloat fDot = dot(vNormal, -vView);\n\tfDot = min(max((1.0 - fDot), 0.0), 1.0);\n\tfloat fDot2 = fDot * fDot;\n\tfloat fDot5 = fDot2 * fDot2 * fDot;\n\treturn fR0 + (1.0 - fR0) * fDot5 * fSmoothFactor;\n}\n \nfloat GetDiffuseIntensity(const in vec3 vLightDir, const in vec3 vNormal)\n{\n\treturn max(0.0, dot(vLightDir, vNormal));\n}\n \nfloat GetBlinnPhongIntensity(const in C_Ray ray, const in C_Material mat, const in vec3 vLightDir, const in vec3 vNormal)\n{            \n\tvec3 vHalf = normalize(vLightDir - ray.vDir);\n\tfloat fNdotH = max(0.0, dot(vHalf, vNormal));\n\n\tfloat fSpecPower = exp2(4.0 + 6.0 * mat.fSmoothness);\n\tfloat fSpecIntensity = (fSpecPower + 2.0) * 0.125;\n\n\treturn pow(fNdotH, fSpecPower) * fSpecIntensity;\n}\n \n\/\/ use distance field to evaluate ambient occlusion\nfloat GetAmbientOcclusion(const in C_Ray ray, const in C_HitInfo intersection, const in vec3 vNormal)\n{\n\tvec3 vPos = intersection.vPos;\n\t\n\tfloat fAmbientOcclusion = 1.0;\n\t\n\tfloat fDist = 0.0;\n\tfor(int i=0; i<=5; i++)\n\t{\n\t\tfDist += 0.1;\n\t\n\t\tvec4 vSceneDist = GetDistanceScene(vPos + vNormal * fDist);\n\t\n\t\tfAmbientOcclusion *= 1.0 - max(0.0, (fDist - vSceneDist.x) * 0.2 \/ fDist );                                    \n\t}\n\t\n\treturn fAmbientOcclusion;\n}\n\nvec3 GetObjectLighting(const in C_Ray ray, const in C_HitInfo intersection, const in C_Material material, const in vec3 vNormal, const in vec3 cReflection)\n{\n\tvec3 cScene ;\n\t\n\tvec3 vSpecularReflection = vec3(0.0);\n\tvec3 vDiffuseReflection = vec3(0.0);\n\t\n\tfloat fAmbientOcclusion = GetAmbientOcclusion(ray, intersection, vNormal);\n\tvec3 vAmbientLight = GetAmbientLight(vNormal) * fAmbientOcclusion;\n\t\n\tvDiffuseReflection += vAmbientLight;\n\t\n\tvSpecularReflection += cReflection * fAmbientOcclusion;\n\t\t\n\t#ifdef ENABLE_POINT_LIGHT\n\tvec3 vLightPos = GetLightPos();\n\tvec3 vToLight = vLightPos - intersection.vPos;\n\tvec3 vLightDir = normalize(vToLight);\n\tfloat fLightDistance = length(vToLight);\n\t\n\tfloat fAttenuation = 1.0 \/ (fLightDistance * fLightDistance);\n\t\n\tfloat fShadowBias = 0.1;              \n\tfloat fShadowFactor = GetShadow( intersection.vPos + vLightDir * fShadowBias, vLightDir, fLightDistance - fShadowBias );\n\tvec3 vIncidentLight = GetLightCol() * fShadowFactor * fAttenuation;\n\t\n\tvDiffuseReflection += GetDiffuseIntensity( vLightDir, vNormal ) * vIncidentLight;                                                                                  \n\tvSpecularReflection += GetBlinnPhongIntensity( ray, material, vLightDir, vNormal ) * vIncidentLight;\n\t#endif \/\/ ENABLE_POINT_LIGHT\n\t\n\tvDiffuseReflection *= material.cAlbedo;\n\n\t\/\/ emmissive glow from screen\n\tif(intersection.vObjectId.x > 4.5)\n\t{\n\t\tvec2 vScreenPos = intersection.vObjectId.zy * vec2(-0.25, -0.3) + vec2(0.54, 0.5);\n\t       \n\t\t\/\/ emissive brightness is 0 unless screen\n\t\tvec2 vMul = step(vScreenPos, vec2(1.0)) * step(vec2(0.0), vScreenPos);\n\t\tfloat kScreenBrightness = 0.8;\n\t\tfloat fMul = vMul.x * vMul.y * kScreenBrightness;\n\t\tvec3 cVideoColour = texture(iChannel1, vScreenPos).xyz;\n\t\tvDiffuseReflection += cVideoColour * cVideoColour * fMul; \/\/ cheap gamma correction\n\t}\n\t\n\t\n\t#ifdef ENABLE_SPECULAR\n\tfloat fFresnel = Schlick(vNormal, ray.vDir, material.fR0, material.fSmoothness * 0.9 + 0.1);\n\tcScene = mix(vDiffuseReflection , vSpecularReflection, fFresnel);\n\t#else\n\tcScene = vDiffuseReflection;\n\t#endif\n\t\n\treturn cScene;\n}\n \nvec3 GetSceneColourSimple( const in C_Ray ray )\n{\n\tC_HitInfo intersection;\n\tRaymarch(ray, intersection, 16.0, 32);\n\t\t\t     \n\tvec3 cScene;\n       \n\tif(intersection.vObjectId.x < 0.5)\n\t{\n\t\tcScene = GetSkyGradient(ray.vDir);\n\t}\n\telse\n\t{\n\t\tC_Material material = GetObjectMaterial(intersection.vObjectId, intersection.vPos);\n\t\tvec3 vNormal = GetSceneNormal(intersection.vPos);\n      \n\t\t\/\/ use sky gradient instead of reflection\n\t\tvec3 cReflection = GetSkyGradient(reflect(ray.vDir, vNormal));\n      \n\t\t\/\/ apply lighting\n\t\tcScene = GetObjectLighting(ray, intersection, material, vNormal, cReflection );\n\t}\n       \n\tApplyAtmosphere(cScene, ray, intersection);\n       \n\treturn cScene;\n}\n \nvec3 GetSceneColour( const in C_Ray ray )\n{                                                           \n\tC_HitInfo intersection;\n\tRaymarch(ray, intersection, 30.0, 256);\n\t\t     \n\tvec3 cScene;\n\t\n\tif(intersection.vObjectId.x < 0.5)\n\t{\n\t\tcScene = GetSkyGradient(ray.vDir);\n\t}\n\telse\n\t{\n\t\tC_Material material = GetObjectMaterial(intersection.vObjectId, intersection.vPos);\n\t\tvec3 vNormal = GetSceneNormal(intersection.vPos);\n\t\n\t\t#ifdef ENABLE_MONTE_CARLO\n\t\tvNormal = normalize(vNormal + gRandomNormal \/ (5.0 + material.fSmoothness * 200.0));\n\t\t#endif\n\t\n\t\tvec3 cReflection;\n\t\t#ifdef ENABLE_REFLECTIONS\t\n\t\t{\n\t\t\t\/\/ get colour from reflected ray\n\t\t\tfloat fSepration = 0.05;\n\t\t\tC_Ray reflectRay;\n\t\t\treflectRay.vDir = reflect(ray.vDir, vNormal);\n\t\t\treflectRay.vOrigin = intersection.vPos + reflectRay.vDir * fSepration;\n\t\t\t\t\t\t\t\t\t       \n\t\t\tcReflection = GetSceneColourSimple(reflectRay);                                                                          \n\t\t}\n\t\t#else\n\t\tcReflection = GetSkyGradient(reflect(ray.vDir, vNormal));                               \n\t\t#endif\n\t\t\/\/ apply lighting\n\t\tcScene = GetObjectLighting(ray, intersection, material, vNormal, cReflection );\n\t}\n\t\n\tApplyAtmosphere(cScene, ray, intersection);\n\t\n\treturn cScene;\n}\n \nvoid GetCameraRay( const in vec3 vPos, const in vec3 vForwards, const in vec3 vWorldUp, const in vec2 fragCoord, out C_Ray ray)\n{\n\tvec2 vPixelCoord = fragCoord.xy;\n\t#ifdef ENABLE_MONTE_CARLO\n\tvPixelCoord += gPixelRandom.zw;\n\t#endif\n\tvec2 vUV = ( vPixelCoord \/ iResolution.xy );\n\tvec2 vViewCoord = vUV * 2.0 - 1.0;\n\n\tvViewCoord *= 0.75;\n\t\n\tfloat fRatio = iResolution.x \/ iResolution.y;\n\n\tvViewCoord.y \/= fRatio;                            \n\n\tray.vOrigin = vPos;\n\n\tvec3 vRight = normalize(cross(vForwards, vWorldUp));\n\tvec3 vUp = cross(vRight, vForwards);\n\t     \n\tray.vDir = normalize( vRight * vViewCoord.x + vUp * vViewCoord.y + vForwards);         \n}\n \nvoid GetCameraRayLookat( const in vec3 vPos, const in vec3 vInterest, const in vec2 fragCoord, out C_Ray ray)\n{\n\tvec3 vForwards = normalize(vInterest - vPos);\n\tvec3 vUp = vec3(0.0, 1.0, 0.0);\n\n\tGetCameraRay(vPos, vForwards, vUp, fragCoord, ray);\n}\n \nvec3 OrbitPoint( const in float fHeading, const in float fElevation )\n{\n\treturn vec3(sin(fHeading) * cos(fElevation), sin(fElevation), cos(fHeading) * cos(fElevation));\n}\n \nvec3 Tonemap( const in vec3 cCol )\n{\n\treturn 1.0 - exp2(-cCol);\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t#ifdef ENABLE_MONTE_CARLO              \n\tCalcPixelRandom( fragCoord, iTime );\n\t#endif\n\t\n\tC_Ray ray;\n\t\n\tvec2 mouse = iMouse.xy \/ iResolution.xy;\n\t\n\t\/\/ If we have never moved the mouse\n\tif(iMouse.x <= 0.0)\n\t{\n\t\tmouse.xy = vec2(0.5);\n\t}\n\t\n\tvec3 vCameraPos = OrbitPoint(-mouse.x * 14.0 + PI, (mouse.y) * PI * 0.2 + PI * 0.025) * 7.0 - vec3(0.0, 0.9, 0.0);\n\t#ifdef ENABLE_MONTE_CARLO              \n\tfloat fDepthOfField = 0.1;\n\tvCameraPos += gRandomNormal * 0.05;\n\t#endif\n\t\n\tGetCameraRayLookat( vCameraPos, vec3(0.0, 0.0, 0.0), fragCoord, ray);\n\t\/\/GetCameraRayLookat(vec3(0.0, 0.0, -5.0), vec3(0.0, 0.0, 0.0), ray);\n\t\n\tvec3 cScene = GetSceneColour( ray );\t\n\t\n\tfloat fExposure = 2.5;\n\tcScene = cScene * fExposure;\n\tvec3 cCurr = Tonemap(cScene );\n\t\n\t#ifdef ENABLE_MONTE_CARLO                              \n\tvec3 cPrev = texture(backbuffer, fragCoord.xy \/ iResolution.xy).xyz;\n\t\/\/ would be nice to combine before tonemap but undoing a gamma=2.0 will do instead\n\tcPrev = cPrev * cPrev;\n\t\/\/ add noise to pixel value (helps values converge)\n\tcPrev += (gPixelRandom.xyz - 0.5) * (1.0 \/ 255.0);\n\tcCurr = cCurr * cCurr;\n\t\/\/ converge speed\n\t\/\/float fBlend = 8.0\/255.0;\n\tfloat fBlend = 1.0;\n\tvec3 cFinal = mix(cPrev, cCurr, fBlend);\n\t\/\/ re-apply gamma 2.0\n\tcFinal = sqrt(cFinal);\n\t#else\n\tvec3 cFinal = cCurr;\n\t#endif\n\t\n\tfloat fAlpha = 1.0;\n\n\t\n\tfragColor = vec4( cFinal, fAlpha );    \n}\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n\tC_Ray ray;\n    \n    fragRayOri.x *= -1.0;\n    fragRayDir.x *= -1.0;\n    \n    fragRayOri.z *= -1.0;\n    fragRayDir.z *= -1.0;\n    \n    fragRayOri *= 20.0;\n    \n    fragRayOri.y += 6.0;\n    fragRayOri.z -= 5.0;\n    fragRayOri.x += 2.0;\n        \n    ray.vOrigin = fragRayOri;\n    ray.vDir = fragRayDir;\n    \n\tvec3 cScene = GetSceneColour( ray );\t\n        \n\tfloat fExposure = 2.5;\n\tcScene = cScene * fExposure;\n\tvec3 cFinal = Tonemap(cScene );    \n    \n  \tfragColor = vec4( cFinal, 1.0 ); \n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"tl2fWD","date":"1598998758","viewed":9464,"name":"Reintegration diffusion radius","username":"michael0884","description":"A static velocity field is used\nSine wave oscillation between different distribution radii\nSpace to restart","likes":29,"published":3,"flags":48,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Fork of \"Cell system 2\" by michael0884. https:\/\/shadertoy.com\/view\/3tSfRW\n\/\/ 2020-09-01 21:18:13\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{    \t\n    col.xyz=sqrt(hsv2rgb(P(pos.xy).zwy));\n    col.w = 1.0;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define T(p) texelFetch(iChannel0, ivec2(mod(p,R)), 0)\n#define P(p) texture(iChannel0, mod(p,R)\/R)\n#define C(p) texture(iChannel1, mod(p,R)\/R)\n#define D(p) texture(iChannel2, mod(p,R)\/R)\n\n#define PI 3.14159265\n#define dt 1.\n#define R iResolution.xy\n\n\/\/i.e. diffusion \n#define distribution_size (0.75 + 0.4*step(sin(iTime), 0.))\n\n\n\/\/ from https:\/\/shadertoy.com\/view\/ttK3Rc\n\/\/ --- rand, noise and fluids \n\nuint hash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nfloat hash3i1f(uvec3 p) {\n    return float(hash(hash(hash(p.x) ^ p.y) ^ p.z) >> 8) \/ 16777216.;\n}\n#define tau   6.283185\n\/\/computes the x and y derivatives of a noise field \nvec2 noise(vec3 p) {\n    uvec3 i = uvec3(ivec3(floor(p)));\n     vec3 f =             fract(p)  ,\n          u = f*f*f*(f*(f*6.-15.)+10.),\n         du = 30.*f*f*(f*(f-2.)+1.);\n\n#define g(x,y,z) sin( tau* ( hash3i1f(i+uvec3(x,y,z)) + vec2(0,.25) ) ) \/\/ SC(rand angle)\n    vec2 ga = g(0,0,0),\n         gb = g(1,0,0),\n         gc = g(0,1,0),\n         gd = g(1,1,0),\n         ge = g(0,0,1),\n         gf = g(1,0,1),\n         gg = g(0,1,1),\n         gh = g(1,1,1);\n \n#define v(g,i,j)  dot(g, f.xy - vec2(i,j))\n    float va = v(ga,0,0),\n          vb = v(gb,1,0),\n          vc = v(gc,0,1),\n          vd = v(gd,1,1),\n          ve = v(ge,0,0),\n          vf = v(gf,1,0),\n          vg = v(gg,0,1),\n          vh = v(gh,1,1);\n    \n    return mix(mix(mix(ga, gb, u.x), mix(gc, gd, u.x), u.y),\n               mix(mix(ge, gf, u.x), mix(gg, gh, u.x), u.y), u.z)\n         + du.xy * mix(u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va,\n                       u.yx*(ve-vf-vg+vh) + vec2(vf,vg) - ve, u.z);\n}\n\nvec2 fluidnoise(vec3 p) {\n    vec2 total = vec2(0);\n    float amp = 1.;\n    for(int i = 0; i < 1; i++) {\n        total += noise(p) * amp;\n        p = p*2. + 4.3; amp *= 1.5;\n    }\n    return total.yx * vec2(-1,1); \/\/ divergence-free field\n}\n\n\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 \/ 3.0, 2.0 \/ 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) \/ (6.0 * d + e)), d \/ (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 \/ 3.0, 1.0 \/ 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\/\/useful functions\n#define GS(x) exp(-dot(x,x))\n#define GSS(x) exp(-dot(x,x))\n#define GS0(x) exp(-length(x))\n#define Dir(ang) vec2(cos(ang), sin(ang))\n#define Rot(ang) mat2(cos(ang), sin(ang), -sin(ang), cos(ang))\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n\/\/data packing\n#define PACK(X) ( uint(round(65534.0*clamp(0.5*X.x+0.5, 0., 1.))) + \\\n           65535u*uint(round(65534.0*clamp(0.5*X.y+0.5, 0., 1.))) )   \n               \n#define UNPACK(X) (clamp(vec2(X%65535u, X\/65535u)\/65534.0, 0.,1.)*2.0 - 1.0)              \n\n#define DECODE(X) UNPACK(floatBitsToUint(X))\n#define ENCODE(X) uintBitsToFloat(PACK(X))","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dfGRn","filepath":"\/media\/a\/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"\/media\/ap\/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"\/presets\/tex00.jpg","previewfilepath":"\/presets\/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    vec2 X = vec2(0.);\n    vec3 M = vec3(0.);\n    float mass = 0.;\n    \n    \/\/basically integral over all updated neighbor distributions\n    \/\/that fall inside of this pixel\n    \/\/this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        \/\/get the particle data\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n       \n        vec2 X0 = DECODE(data.x) + tpos;\n    \tvec3 M0 = data.yzw;\n        \n        vec2 V0 = 1.*fluidnoise(vec3(8.*mod(X0,R)\/R,1.0*iTime));\n       \n        X0 += V0*dt; \/\/integrate position\n\n        \/\/particle distribution size\n        float K = distribution_size;\n        \n        \/\/overlap box\n        vec4 aabbX = vec4(max(pos - 0.5, X0 - K*0.5), min(pos + 0.5, X0 + K*0.5));\n        \/\/center of mass\n        vec2 center = 0.5*(aabbX.xy + aabbX.zw); \n        \/\/only positive\n        vec2 size = max(aabbX.zw - aabbX.xy, 0.); \n        \n        \/\/the deposited mass into this cell\n        float m = M0.x*size.x*size.y\/(K*K); \n        \n        mass += m;\n       \n        \/\/add weighted by mass\n        X += center*m;\n      \n        \/\/add color\n        M += M0*m;\n    }\n    \n    \/\/normalization\n    if(mass > 0.)\n    {\n        X \/= mass;\n        M \/= mass;\n    }\n    M.x = mass;\n    \n    \/\/initial condition\n    if(iFrame < 150 || isKeyPressed(KEY_SPACE))\n    {\n        X = pos;\n        \/\/here mass is brightness\n        M = rgb2hsv(texture(iChannel1, pos\/R).xyz).zxy;\n    }\n    \n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), M);\n}","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"ttXGWH","date":"1556289065","viewed":9458,"name":"Abstract Terrain Objects","username":"Shane","description":"Rendering some abstract objects onto terrain. Inspired by Mike Winkelmann's imagery.","likes":219,"published":3,"flags":0,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/*\n\n    Abstract Terrain Objects\n    ------------------------\n\n\tRendering some abstract geometry onto some terrain in a basic sci-fi tone.\n\n\tThis was inspired by one of Mike Winkelmann's images, which I've included \n\ta link to below. The original image is nicer -- partly due to the fact that\n\tI'm restricted by realtime constraints, and possibly, because I have the\n\tartistic vision of a programmer. :D\n\t\n\tMike Winkelmann is the guy behind the amazing sci-fi flavored Beeple imagery \n\tthat appears in various corners of the internet. For anyone not familiar \n\twith his work, it's well worth the look. Shau has been putting up a few \n\tBeeple inspired shaders lately, which reminded me that I'd been meaning to\n\tdo the same.\n\n\tMost of this is pretty standard stuff: Render some sky, terrain, and some \n\tobjects, with an extra reflective pass on the objects to make them shiny.\n\tI went to the trouble to blend materials when the shiny objects were near \n\tthe terrain. That involved a little bit of fiddly mixing, which complicated \n\tthe code a little, but nothing that anyone here couldn't handle. :)\n\n\n\tOriginal Image:\n\n\t\/\/ Putting abstract geometry on terrain is a weird but common concept \n\t\/\/ amongst the graphics community, and this is a beautiful example.\n\tTRIOMETRIC - Beeple\n\thttps:\/\/twitter.com\/beeple\/status\/848029629973749760\n\n\n\tExamples:\n\n\t\/\/ One of Shau's Beeple inspired shaders.\n\tData Surge - shau\n\thttps:\/\/www.shadertoy.com\/view\/3dSXzm\n\n\t\/\/ Cool and qwirky. I love the rendering style.\n\t[SH16B] valley flight  - Bananaft\n\thttps:\/\/www.shadertoy.com\/view\/XldGR7\n\n\t\/\/ I like the rendering style of this also.\n\tRayCraft - jolle\n\thttps:\/\/www.shadertoy.com\/view\/tslGRX\n\n\t\/\/ Another one of Shau's. Fun to watch.\n\tXANNN - shau\n\thttps:\/\/www.shadertoy.com\/view\/llSfzR\n\n*\/\n\n\/\/ Maximum ray distance. Analogous to the far plane.\n#define FAR 100. \n\n\/\/ More correct third pass: The reflection off the reflected surface is less\n\/\/ noticeable, so we're saving some computing power and faking it, which means\n\/\/ this is not on by default. However, if your computer can afford it, this is \n\/\/ a better option.\n\/\/#define THIRD_PASS\n\n\n\/\/ Scene object ID. Either the Terrain object (0) or the chrome object (0).\nvec4 objID, oSvObjID;\nfloat svObjID; \/\/ Global ID to keep a copy of the above from pass to pass.\n\n\n\/\/ vec2 to vec2 hash.\nvec2 hash22(vec2 p) { \n\n    \/\/ Faster, but doesn't disperse things quite as nicely. However, when framerate\n    \/\/ is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    \/\/ amalgamation I put together, based on a couple of other random algorithms I've \n    \/\/ seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(1, 113)));\n    return fract(vec2(262144, 32768)*n)*2. - 1.; \n    \n    \/\/ Animated.\n    \/\/p = fract(vec2(262144, 32768)*n); \n    \/\/ Note the \".45,\" insted of \".5\" that you'd expect to see. When edging, it can open \n    \/\/ up the cells ever so slightly for a more even spread. In fact, lower numbers work \n    \/\/ even better, but then the random movement would become too restricted. Zero would \n    \/\/ give you square cells.\n    \/\/return sin( p*6.2831853 + iTime ); \n    \n}\n\n\n\/\/ Fabrice's consice, 2D rotation formula.\n\/\/mat2 r2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\/\/ Standard 2D rotation formula.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n\/\/ The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float t){ \n\n    \/\/return vec2(0);\n    \/\/float s = sin(t\/24.)*cos(t\/12.);\n    \/\/return vec2(s*4., 0.);\n    \n    float a = sin(t*.11);\n    float b = cos(t*.14);\n    return vec2((a*2.\/2. - b*1.5\/2.), b*1.7\/4. + a*1.5\/4.);\n    \n    \/\/return vec2(sin(t*.15)*2.4, cos(t*.25)*1.7*.5); \n}\n\n\/\/ Smooth fract function.\nfloat sFract(float x, float sf){\n    \n    x = fract(x);\n    return min(x, (1. - x)*x*sf);\n    \n}\n\n\n\/\/ Compact, self-contained version of IQ's 3D value noise function.\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(113., 57., 27.);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \/\/p = p*p*(3. - 2.*p);\n    p *= p*p*(p*(p*6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); \/\/ Range: [0, 1].\n}\n\n\n\/\/ Smooth maximum, based on IQ's smooth minimum.\nfloat smax(float a, float b, float s){\n    \n    float h = clamp(.5 + .5*(a - b)\/s, 0., 1.);\n    return mix(b, a, h) + h*(1. - h)*s;\n}\n\n\n\n\n\/\/ Cheap and nasty 2D smooth noise function with inbuilt hash function -- based on IQ's \n\/\/ original. Very trimmed down. In fact, I probably went a little overboard. I think it \n\/\/ might also degrade with large time values.\nfloat n2D(vec2 p) {\n\n\tvec2 i = floor(p); p -= i; \/\/p *= p*(3. - p*2.);  \n    \n    p *= p*p*(p*p*6. - p*15. + 10.); \n    \n    return dot(mat2(fract(sin(mod(vec4(0, 1, 113, 114) + dot(i, vec2(1, 113)), 6.2831853))*43758.5453))*\n                vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n\n}\n\n\/\/ FBM -- 4 accumulated noise layers of modulated amplitudes and frequencies.\nfloat fbm(vec2 p){ return n2D(p)*.533 + n2D(p*2.)*.267 + n2D(p*4.)*.133 + n2D(p*8.)*.067; }\nfloat fbmCam(vec2 p){ return n2D(p)*.533 + n2D(p*2.)*.267; }\n\n\/\/ The triangle function that Shadertoy user Nimitz has used in various triangle noise demonstrations.\n\/\/ See Xyptonjtroz - Very cool. Anyway, it's not really being used to its full potential here.\nvec2 tri(in vec2 x){return abs(x - floor(x) - .5);} \/\/ Triangle function.\nvec2 triS(in vec2 x){return cos(x*6.2831853)*.25 + .25;} \/\/ Smooth version.\n\n\/\/ Height function layers. \nfloat h1(vec2 p){ return dot(tri(p + tri(p.yx*.5 + .25)), vec2(1)); }\nfloat h1Low(vec2 p){ return dot(triS(p + triS(p.yx*.5 + .25)), vec2(1)); }\n\n\/\/ Terrain height function. Just a few layers.\nfloat h(vec2 p) {\n    \n    float ret = 0., m = 1., a = 1., s = 0.;\n    \n    \/\/for(int i=0; i<1; i++) {\n    \n        ret += a*h1Low(p\/m);\n        \/\/ret += a * n2D(p\/m);\n        p = r2(1.57\/3.73)*p;\n        \/\/p = mat2(1, .75, -.75, 1)*p;\n        m *= -.375;\n        s += a;\n        a *= .3;\n    \/\/}\n    \n    for(int i=1; i<5; i++) {\n        ret += a*h1(p\/m);\n        \/\/ret += a * n2D(p\/m);\n        p = r2(1.57\/3.73)*p;\n        \/\/p = mat2(1, .75, -.75, 1)*p;\n        m *= -.375;\n        s += a;\n        a *= .3;\n    }\n    \n    ret \/= s;\n    \n    return ret*.25 + ret*ret*ret*.75;\n\n}\n\n\/\/ The camera height function, which is a smoother version of the terrain function.\nfloat hLow(vec2 p) {\n    \n    float ret = 0., m = 1., a = 1., s = 0.;\n    for(int i=0; i<2; i++){\n        \n        ret += a*h1Low(p\/m);\n        \/\/ret += a * n2D(p\/m);\n        p = r2(1.57\/3.73)*p;\n        \/\/p = mat2(1, .75, -.75, 1)*p;\n        m *= -.375;\n        s += a;\n        a *= .3;\n    }\n    \n    ret \/= s;\n    \n    return ret*.25 + ret*ret*ret*.75;\n\n}\n\n\/\/ Surface function.\nfloat surfaceFunc(vec3 q){\n    \n    \/\/ Height.\n    float sf = h(q.xz\/20.);\n    \n    \/\/ Experimental way to dig out a trench.\n    sf -= smax(1.4 - q.x*q.x*.5, 0., 1.)*.12;\n    \n    return (.5 - sf)*5.;\n}\n\n\/\/ Surface function for the camera.\nfloat surfaceFuncCam(vec3 q){\n    \n    \/\/ Height.\n    float sf = hLow(q.xz\/20.);\n    \n    \/\/ Experimental way to dig out a trench.\n    sf -= smax(1.4 - q.x*q.x*.5, 0., 1.)*.12;\n    \n    return (.5 - sf)*3.;\n}\n\n\/\/ Toroidal distance function... Technically, a lot of these are just\n\/\/ bounds, so not exactly correct, which means shadows, glow, and other\n\/\/ things can be effected. However, they're cheaper, and you can't really\n\/\/ tell here.\nfloat distT(vec2 p){\n    \n    \/\/ Try some of the others, if you get bored enough. :)\n    \n    \/\/return max(abs(p.x)*.866025 + p.y*.5, -p.y); \/\/ Triangle.\n    \/\/return length(p); \/\/ Circle.\n    \n    p = abs(p);\n    return (p.x + p.y)*.7071; \/\/ Diamond.\n    \/\/return max(p.x, p.y); \/\/ Square.\n    \/\/return max(p.x*.866025 + p.y*.5, p.y); \/\/ Hexagon.\n    \/\/return max((p.x + p.y)*.7071 - .4, max(p.x, p.y)); \/\/ Octagon.\n    \n}\n\n\/\/ Poloidal distance function. As mentioned above these are technically\n\/\/ bounds, but they work well enough.\nfloat distP(vec2 p){\n    \n    \/\/return length(p); \/\/ Circle.\n    \n    p = abs(p);\n    return max((p.x + p.y)*.7071 - .06, max(p.x, p.y)); \/\/ Beveled square.\n    \/\/return max(p.x*.866025 + p.y*.5, p.y); \/\/ Hexagon.\n    \/\/return max(p.x, p.y); \/\/ Square.\n    \n}\n\n\/\/ Global scale, to space out the chrome objects.\nconst vec3 sc = vec3(16, 4, 4);\n\nfloat objects(vec3 p){\n    \n    \n    p.xz += sc.xz\/2.;\n    \n    vec3 ip = floor(p\/sc)*sc;\n    \n \n    \/\/ Repeating objects across the terrain in Z direction.\n    p.xz = vec2(p.x, p.z - ip.z) - sc.xz*.5; \/\/ Equivalent to: mod(p.xz, sc) - sc*.5;\n    \/\/ Repeating objects across the terrain in the X and Z directions.\n    \/\/p.xz = (p.xz - ip.xz) - sc.xz*.5; \/\/ vec2(p.x, mod(p.z, sc.y)) - sc*.5;\n    \n    \n    \/\/ Obtaining the surface height at the center of the grid. This height is used\n    \/\/ to shift the object to the approximate top of the terrain.\n    float sf = surfaceFunc(ip);\n    \n    \/\/ Add the grid height to the object's Y position.\n    p.y += sf - 1.8;\n    \n    \/\/ Use the object's Z position to rotate it about the XY plane. This effect looks\n    \/\/ better on a flat terrain.\n    p.xy = r2(sc.z\/16. - ip.z\/16.)*p.xy;\n    \/\/ Random XZ rotation, just to show it can be done.\n    \/\/p.xz = r2((hash(ip.z) - .5)\/2.)*p.xz;\n    \n    \n    const float sz = 1.8;\n    const float th = .5;\n     \n    \/\/ Toroidal angle. \n    \/\/float a = atan(p.y, p.x);\n    \n    \/\/ Toroidal distance -- The large radius part.\n    p.xy = vec2(distT(p.xy) - sz, p.z);\n    \/\/ Windows logo warp. :)\n    \/\/p.xy = vec2(distT(p.xy) - sz + sin(a*4.)*.125, p.z);\n    \n    \/\/ Mobius-like twisting: Twisting the toroidal axis one full revolution\n    \/\/ about the poloidal plane... Yeah, it confuses me too. :) Be sure to\n    \/\/ uncomment the \"atan\" bit above.\n    \/\/p.xz = r2(a)*p.xz;\n    \n    \n    \/\/ Poloidal distance. The smaller radius part. \n    float obj = distP(p.xz) - th\/2.;\n    \n     \n    \/\/ Return the cell object.\n    return obj;\n    \n}\n\n\n\/\/ The distance function. Just some geometric objects and some terrain.\nfloat map(vec3 p){\n    \n    \/\/ Wrap everything around the path.\n    p.xy -= path(p.z);\n    \n    \/\/ The surface function. Essentially, the bumps we add to the terrain.\n    float sf = surfaceFunc(p);\n    \n    \/\/ The terrain, which we're lowering a bit.\n    float terr = p.y + .0 + sf;\n\n    \/\/ The chrome objects. \n    float obj = objects(p);\n    \n    \/\/ Store the terrain and object IDs, for sorting later.\n    objID = vec4(terr, obj, 0, 0);\n    \n    \/\/ Return the minimum distance.\n    return min(terr, obj);\n    \n}\n\n\n\/\/ Standard raymarching routine.\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 0., d;\n    \n    for (int i=0; i<80; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.001*(t*.1 + 1.) || t>FAR) break;\n        \n        t += d*.866; \/\/ Using slightly more accuracy in the first pass.\n    }\n    \n    return min(t, FAR);\n}\n\n\/\/ Second pass, which is the first, and only, reflected bounce. \n\/\/ Virtually the same as above, but with fewer iterations and less \n\/\/ accuracy.\n\/\/\n\/\/ The reason for a second, virtually identical equation is that \n\/\/ raymarching is usually a pretty expensive exercise, so since the \n\/\/ reflected ray doesn't require as much detail, you can relax things \n\/\/ a bit - in the hope of speeding things up a little.\nfloat traceRef(vec3 ro, vec3 rd){\n    \n    float t = 0., d;\n    \n    for (int i=0; i<56; i++){\n\n        d = map(ro + rd*t);\/\/*rDir;\n        \n        if(abs(d)<.001*(t*.1 + 1.) || t>FAR) break;\n        \n        t += d*.9;\n    }\n    \n    return min(t, FAR);\n}\n\n\n\n\/\/ Bump function. \nfloat bumpSurf3D( in vec3 p, float t){\n    \n    \n    float c, c0 = 0., c1 = 0.;\n    \n    \/\/float bordTx0Tx1 = oSvObjID.x - oSvObjID.y;\n    \/\/const float bordW = .0;\n    \n    \n    \/\/ Terrain.\n    if(svObjID == 0.){\/\/ || abs(bordTx0Tx1)<bordW) {\n        \n        c0 = fbm(p.xz*8.);\n        \n        c0 = (1. - c0)\/3.;\n    }\n    \/*\n    \/\/ Metallic objects. The original image has a metallic bump, \n    \/\/ but I wanted to keep it smooth.\n    if(svObjID == 1.){\/\/ || abs(bordTx0Tx1)<bordW) {\n    \n        \n        c1 = (n3D(p*6.)*.66 + n3D(p*12.)*.34);\n        c1 = smoothstep(0., .1, n3D(p*3.) - .65)*c1\/12.;\n        \n        \/\/c1 = (1. - smoothstep(.05, .3, c1))\/4.;\n        \n    }\n    *\/\n    \/\/ Used to fade the bump when objects are near one another, but\n    \/\/ I feel it's a little bit of overkill, for this particular example.\n    \/\/c = mix(c0, c1, step(oSvObjID.y, oSvObjID.x));\n    \/\/c = mix(c0, c1, smoothstep(-bordW\/2., bordW\/2., bordTx0Tx1));\n    \n    c = c0;\n    \n    \/\/ Fading the bump out over distance.\n    return c\/(1. + t*t*3.);\n    \n}\n\n\n\/\/ Standard function-based bump mapping routine: This is the cheaper four tap version. There's\n\/\/ a six tap version (samples taken from either side of each axis), but this works well enough.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor, float t){\n    \n    \/\/ Larger sample distances give a less defined bump, but can sometimes lessen the aliasing.\n    const vec2 e = vec2(.001, 0); \n    \n    \/\/ Gradient vector: vec3(df\/dx, df\/dy, df\/dz);\n    float ref = bumpSurf3D(p, t);\n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy, t),\n                      bumpSurf3D(p - e.yxy, t),\n                      bumpSurf3D(p - e.yyx, t)) - ref)\/e.x; \n    \n    \/*\n    \/\/ Six tap version, for comparisson. No discernible visual difference, in a lot of cases.\n    vec3 grad = vec3(bumpSurf3D(p - e.xyy, t) - bumpSurf3D(p + e.xyy, t),\n                     bumpSurf3D(p - e.yxy, t) - bumpSurf3D(p + e.yxy, t),\n                     bumpSurf3D(p - e.yyx, t) - bumpSurf3D(p + e.yyx, t))\/e.x*.5;\n    *\/\n       \n    \/\/ Adjusting the tangent vector so that it's perpendicular to the normal. It's some kind \n    \/\/ of orthogonal space fix using the Gram-Schmidt process, or something to that effect.\n    grad -= nor*dot(nor, grad);          \n         \n    \/\/ Applying the gradient vector to the normal. Larger bump factors make things more bumpy.\n    return normalize(nor + grad*bumpfactor);\n\t\n}\n\n\n\n\/\/ Cheap shadows are the bain of my raymarching existence, since trying to alleviate artifacts is an excercise in\n\/\/ futility. In fact, I'd almost say, shadowing - in a setting like this - with limited  iterations is impossible... \n\/\/ However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k, float t){\n\n    \/\/ More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 32; \n    \n    vec3 rd = lp - ro; \/\/ Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = .0015; \/\/ Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    \/\/float stepDist = end\/float(maxIterationsShad);\n    rd \/= end;\n\n    \/\/ Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    \/\/ number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        shade = min(shade, k*h\/dist);\n        \/\/shade = min(shade, smoothstep(0.0, 1.0, k*h\/dist)); \/\/ Subtle difference. Thanks to IQ for this tidbit.\n        \/\/ So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        dist += clamp(h, .05, .5); \n        \n        \/\/ Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0. || dist > end) break; \n    }\n\n    \/\/ I've added a constant to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    \/\/ Really dark shadows look too brutal to me. Sometimes, I'll add AO also just for kicks. :)\n    return min(max(shade, 0.) + .2, 1.); \n}\n\n\n\/\/ Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p) {\n    \n    \/\/const vec2 e = vec2(.001, 0);\n    \/\/return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\t\n    \/\/                      map(p + e.yyx) - map(p - e.yyx)));\n     \n    \/\/ This mess is an attempt to speed up compiler time by contriving a break... It's \n    \/\/ based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; \/\/ Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n\n\nvec3 getSky(vec3 ro, vec3 rd, vec3 lp){\n\n    \/\/ Gradient blues, and red, or something.\n    vec3 sky = max(mix(vec3(1, .7, .6), vec3(.7, .9, 1.5), rd.y + .0), 0.)\/4.; \n    \n    \/\/ Last minute contrast.\n    sky = pow(sky, vec3(1.25))*1.25;\n    \n    \/\/ Horizon strip.\n    sky = mix(sky, vec3(1, .1, .05), (1. - smoothstep(-.1, .25, rd.y))*.3);\n    \n    \n\t\/\/ Blending in the sun.\n    float sun = max(dot(normalize(lp - ro), rd), 0.);\n    \/\/sky = mix(sky, vec3(.6, 1, .5), pow(sun, 6.)*.5);\n    sky = mix(sky, vec3(1, .7, .6)*.9, pow(sun, 6.));\n    sky = mix(sky, vec3(1, .9, .8)*1.2, pow(sun, 32.));\n\n\n    \/\/ Subtle, fake sky curvature.\n    rd.z *= 1. + length(rd.xy)*.25;\n    rd = normalize(rd);\n\n    \/\/ A simple way to place some clouds on a distant plane above the terrain -- Based on something IQ uses.\n    const float SC = 1e5;\n    float tt = (SC - ro.y - .15)\/(rd.y + .15); \/\/ Trace out to a distant XZ plane.\n    vec2 uv = (ro + tt*rd).xz; \/\/ UV coordinates.\n\n    \/\/ Mix the sky with the clouds, whilst fading out a little toward the horizon (The rd.y bit).\n    if(tt>0.) {\n\n        float cl = fbm(1.5*uv\/SC);\n\n        \/\/ White clouds.\n        sky =  mix(sky, vec3(1)*vec3(1, .9, .85), smoothstep(.3, .95, cl)*\n                   smoothstep(.475, .575, rd.y*.5 + .5)*.5); \n        \/\/ Fake dark shadow. Subtle, but kind of worth doing. :)\n        sky =  mix(sky, vec3(0), smoothstep(.0, .95, cl)*fbm(7.*uv\/SC)*\n                   smoothstep(.475, .575, rd.y*.5 + .5)*.3);\n\n    }\n\n    \/\/ Speckles. Not science based, but it looks intering.\n    vec3 p = (ro + rd*FAR)\/1. + vec3(0, 0, iTime);\n    float st = n3D(p)*.66 + n3D(p*2.)*.34;\n    st = smoothstep(.1, .9, st - .0);\n    sky = mix(sky, vec3(.7, .9, 1), (1. - sqrt(st))*.05);\n    \n    \/\/ The sky color.\n    return sky;\n\n}\n\n\n\/\/ Coloring\\texturing the scene objects, according to the object IDs.\nvec3 getObjectColor(vec3 p, vec3 n){\n    \n    \/\/ Object texture color.\n\n    \/\/ Contorting the texture coordinates to math the contorted scene.\n    \/\/vec3 txP = p - vec3(path(p.z), 0.);\n    p = p - vec3(path(p.z), 0.);\n\n    \/\/ Texture value, and individual texture values.\n    vec3 tx, tx0, tx1;\n    \n    float bordTx0Tx1 = oSvObjID.x - oSvObjID.y;\n    const float bordW = .075;\n    \n     \n    \/\/ If we hit the terrain, or hit the region near the terrain, color\n    \/\/ it up.\n    if(svObjID==0. || abs(bordTx0Tx1)<bordW){\n        \n        \/\/ Noisy color mixing. Tweaked until it looked right.\n        vec2 q = p.xz;\n\n        float c = n2D(q)*.6 + n2D(q*3.)*.3 + n2D(q*9.)*.1;\n        c = c*c*.7 + sFract(c*4., 12.)*.3;\n        c = c*.9 + .2;\n        tx0 = mix(vec3(1, .3, .2), vec3(1, .35, .25), n2D(q*6.));\n        tx0 *= c;\n\n        float c2 = n2D(q*20.)*.66 + n2D(q*40.)*.34;\n        c2 = smoothstep(.1, .6, c2*c2);\n\n\n        tx0 = mix(tx0*vec3(1.2, .8, .65).zyx, tx0, abs(n));\n        tx0 = mix(tx0, vec3(0), c2*.4);\n\n        \/\/tx0 *= mix(vec3(1.2, .8, .6), vec3(1.2, .8, .6).yxz, -n.y*.5 + .5);\n\n        \n        \/*\n        \/\/ Extra shadowing. A bit much, in this case.\n \t\t\n\t\t\/\/ Matches the terrain height function.\n        float sf = h(p.xz\/20.);\n    \n        \/\/ Experimental way to dig out a trench.\n    \tsf -= smax(1.4 - q.x*q.x*.5, 0., 1.)*.12;\n        \n        tx0 *= smoothstep(-.1, .5, sf) + .5;\n        *\/\n        \n    }\n     \n    \/\/ If the ray hits the metallic object, or close to it, color it dark.\n    \/\/ The shininess is provided with the relective color. I used to get \n    \/\/ this wrong all the time. :)\n    if(svObjID==1. || abs(bordTx0Tx1)<bordW) tx1 = vec3(.08, .1, .12);\n    \n    \n    \/\/ Return the color, which is either the terrain color, the shiny object color,\n    \/\/ or if we're in the vicinity of both, make it a mixture of the two.\n    tx = mix(tx0, tx1, smoothstep(-bordW, bordW, bordTx0Tx1));\n   \n    \n    return tx; \/\/ Return the object color.\n    \n}\n\n\/\/ Using the hit point, unit direction ray, etc, to color the scene. Diffuse, specular, falloff, etc. \n\/\/ It's all pretty standard stuff.\nvec3 doColor(in vec3 ro, in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, float edge, float crv, float ao, float t){\n    \n    \/\/ Initiate the scene (for this pass) to zero.\n    vec3 sceneCol = vec3(0);\n    \n    if(t<FAR){ \/\/ If we've hit a scene object, light it up.\n    \n        vec3 ld = lp - sp; \/\/ Light direction vector.\n        float lDist = max(length(ld), 0.001); \/\/ Light to surface distance.\n        ld \/= lDist; \/\/ Normalizing the light vector.\n\n        \/\/ Attenuating the light, based on distance.\n        float atten = 1.5\/(1. + lDist*0.001 + lDist*lDist*0.0001);\n\n        \/\/ Standard diffuse term.\n        float diff = max(dot(ld, sn), 0.);\n        \/\/diff = pow(diff, 2.)*.66 + pow(diff, 4.)*.34;\n        \/\/ Standard specualr term.\n        float spec = pow(max(dot(reflect(-ld, sn), -rd), 0.), 32.);\n        float fres = clamp(1. + dot(rd, sn), 0., 1.);\n        \/\/float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.0);\n        \/\/float fre2 = mix(.5, 1., Schlick);  \/\/F0 = .5.\n        \n        \/\/ Ramp up the diffuse value on the shiny geometric object. It's a cheap\n        \/\/ trick to make things look shiny.\n        if(svObjID==1.) diff *= diff*2.;\n\n        \/\/ Coloring the object, accoring to object ID,.        \n        vec3 objCol = getObjectColor(sp, sn);\n\n        \n        \/\/ Combining the above terms to produce the final scene color.\n        sceneCol = objCol*(diff + .35 + fres*fres*0. + vec3(.5, .7, 1)*spec);\n        \n        \n        \/\/ Attenuation only. To save cycles, the shadows and ambient occlusion\n        \/\/ from the first pass only are used.\n        sceneCol *= atten;\n    \n    }\n    \n    \n    \/\/ Get the sky color.  \n    vec3 sky = getSky(ro, rd, lp);\n    \n    \/\/ Smoothly blend it in, according to the FAR plane distance. Basically, we want it\n    \/\/ to fade in strongly as we hit the horizon.\n    sceneCol = mix(sceneCol, sky, smoothstep(0., .95, t\/FAR)); \/\/ exp(-.002*t*t), etc.\n \n    \n  \n    \/\/ Return the color. Done once for each pass.\n    return sceneCol;\n    \n}\n\n\/\/ I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n\/\/ Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calculateAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 2., occ = 0.;\n    for(int i=0; i<5; i++){\n    \n        float hr = .01 + float(i)*.5\/4.;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= .7;\n    }\n    return clamp(1. - occ, 0., 1.);    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \/\/ Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)\/iResolution.y;\n    \n\t\n\t\/\/ Camera Setup.\n\tvec3 ro = vec3(0, 1.25, iTime*2.); \/\/ Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(0, 0, .5);  \/\/ \"Look At\" position.\n    \n    \n    \/\/ Light position. Set in up in the sky above the horizon -- out near the far plane.\n    vec3 lp = ro + vec3(-20, 30, 60);\n    \n   \n\t\/\/ Using the Z-value to perturb the XY-plane.\n\t\/\/ Sending the camera, \"look at,\" and light vector down the path, which is \n\t\/\/ synchronized with the distance function.\n    ro.xy += path(ro.z);\n\tlk.xy += path(lk.z);\n\tlp.xy += path(lp.z);\n    \n    \/\/ Using a smoother version of the terrain function to move the camera up and down.\n    \/\/ Alternatively, you could thread it through some Bezier points... if you're not\n    \/\/ lazy, like me. :D\n    ro.y -= surfaceFuncCam(ro.xyz);\n    lk.y -= surfaceFuncCam(lk.xyz);\n    \n\n    \/\/ Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159\/2.; \/\/ FOV - Field of view.\n    vec3 forward = normalize(lk-ro);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    \/\/ rd - Ray direction.\n    \/\/vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    \n    \/\/ Warped unit direction vector, for a warped lens effect.\n    vec3 rd = (forward + FOV*uv.x*right + FOV*uv.y*up);\n    rd = normalize(vec3(rd.xy, rd.z - length(rd.xy)*.15));\n    \n    \n    \/\/ Edge and curvature variables. Not used here.\n    float edge = 0., crv = 1.;\n\n    \n    \/\/ FIRST PASS.\n    \/\/\n    float t = trace(ro, rd); \/\/ Trace.\n\n    \/\/ Save the object IDs after the first pass.\n    svObjID = objID.x<objID.y? 0. : 1.;\n    oSvObjID = objID;\n    \n    \/\/ Advancing the ray origin, \"ro,\" to the new hit point.\n    vec3 sp = ro + rd*t;\n    \n    \/\/ Retrieving the normal at the hit point, plus the edge and curvature values.\n    \/\/vec3 sn = getNormal(sp, edge, crv);\n    vec3 sn = getNormal(sp);\n    \n    \/\/ Function based bump mapping. the final value is a fade off with\n    \/\/ respect to distance.\n    sn = doBumpMap(sp, sn, .2, t\/FAR);\n    \n\n    \n    \/\/ Fresnel. Handy for all kinds of aesthetic purposes. Not used here.\n    \/\/float fr = clamp(1. + dot(rd, sn), 0., 1.);\n    \n    \/\/ Shading. Shadows, ambient occlusion, etc. We're only performing this on the \n    \/\/ first pass. Not accurate, but faster, and in most cases, not that noticeable.\n    \/\/ In fact, the shadows almost didn't make the cut, but it didn't quite feel \n    \/\/ right without them.\n    float sh = softShadow(sp + sn*.002, lp, 12., t); \/\/ Set to \"1.,\" if you can do without them.\n    float ao = calculateAO(sp, sn);\n    sh = (sh + ao*.3)*ao;\n    \n\n    \/\/ Retrieving the color at the initial hit point.\n    vec3 sceneColor = doColor(ro, sp, rd, sn, lp, edge, crv, ao, t);\n\n    \n   \n    \/\/ SECOND PASS\n    \n    \/\/ Reflected and refracted rays.\n    vec3 refl = reflect(rd, sn); \/\/ Standard reflection.\n    \/\/vec3 refr = refract(rd, sn, 1.\/1.33); \/\/ Water refraction. Note the inverted index.\n    \n    \/\/ We're branching off from the same spot in two directions, so we'll use this so as\n    \/\/ not to interfere with the original surface point vector, \"sp.\" It was a style\n    \/\/ choice on my part, but there are other ways.\n    vec3 refSp; \n    \n    \/\/ REFLECTED PASS\n    \/\/\n    \/\/ Standard reflected ray, which is just a reflection of the unit\n    \/\/ direction ray off of the intersected surface. You use the normal\n    \/\/ at the surface point to do that.\n    \n    \n    \/\/ Making thing complicated for myself, and anyone trying to read this, just so I\n    \/\/ can blend the terrain into the object... In my defence, the unblended dirt doesn't\n    \/\/ quite look right sitting against the object. :)\n    float bordTx0Tx1 = oSvObjID.x - oSvObjID.y;\n    const float bordW = .075; \/\/ Blend border width... Kind of.\n    \n    \/\/ If the ray hits the chrome geometric object, or the ground nearby, perform a\n    \/\/ reflective pass.\n    if((svObjID==1. || abs(bordTx0Tx1)<bordW)  && t<FAR){\n\n        \/\/ The ray is edged off the surface, as required, but note that it has to be enough\n        \/\/ to avoid conflict with the break condition in the \"reflected\" trace algorithm.\n        t = traceRef(sp + refl*.002, refl);\n\n        \/\/ Save the object IDs after the second pass.\n        svObjID = objID.x<objID.y? 0. : 1.;\n    \toSvObjID = objID;\n\n\n        \/\/ Advancing the ray from the new origin, \"sp,\" to the new reflected hit point.\n        refSp = sp + refl*t;\n\n        \/\/ Retrieving the normal at the reflected hit point.\n        sn = getNormal(refSp);\n        \n        \/\/ Color at the reflected hit point.\n        vec3 reflColor = doColor(sp, refSp, refl, sn, lp, edge, crv, 1., t);\n        sceneColor = mix(sceneColor, sceneColor + reflColor*1.33, smoothstep(-bordW\/2., bordW\/2., bordTx0Tx1));\n        \/\/sceneColor = sceneColor + reflColor*1.33;\n        \/\/sceneColor = sceneColor*.35 + mix(reflColor, sceneColor, fr*fr*.66 + .34)*2.5;\n        \n        \n        #ifndef THIRD_PASS\n        \/\/ Very cheap third pass: It'd be nice to put a proper third pass in, but we're \n        \/\/ pushing our luck as it is, so we'll make do with a makeshift sky reflection.\n      \n        \/\/if((svObjID==1. || abs(bordTx0Tx1)<bordW)  && t<FAR){\n        if(svObjID == 1. && t<FAR){\n            \n            refl = reflect(refl, sn);\n            vec3 sky = getSky(ro, refl, lp);\n            sceneColor = mix(sceneColor, sceneColor*.7 + sceneColor*sky*5.*vec3(1.15, 1, .85), smoothstep(-bordW\/2., bordW\/2., bordTx0Tx1));\n      \n            \/\/sceneColor = sceneColor + tpCol*sky*4.;\n            \/\/sceneColor = sceneColor*.7 + tpCol;\n            \/\/sceneColor = sceneColor*.35 + mix(reflColor, sceneColor, fr*fr*.66 + .34)*2.5;\n            \n        }\n        #endif\n    \n    }\n    \n    \/*\n\t\/\/ Really bad cheap reflection pass. Only here for debug purposes. \n    \/\/if(svObjID==1. && t<FAR){\n    if((svObjID==1. || abs(bordTx0Tx1)<bordW)  && t<FAR){\n        \n         vec3 sky = getSky(sp, refl, lp);\n         sceneColor = mix(sceneColor, sceneColor + sceneColor*sky*20., smoothstep(-bordW\/2., bordW\/2., bordTx0Tx1));\n      \n    }\n    *\/\n    \n    #ifdef THIRD_PASS\n    \/\/ More correct third pass: Since it's just a reflection off a reflection of one\n    \/\/ object, we're not using it by default, but it's there if you want it.\n    if(svObjID == 1. && t<FAR){\n        \n        refl = reflect(refl, sn);\n        \n        t = traceRef(refSp + refl*.002, refl);\n\n        \/\/ Save the object IDs after the third pass.\n        svObjID = objID.x<objID.y? 0. : 1.;\n    \toSvObjID = objID;\n        \n\n        \/\/ Advancing the ray from the new origin, \"sp,\" to the new reflected hit point.\n        refSp = refSp + refl*t;\n\n        \/\/ Retrieving the normal at the reflected hit point.\n        sn = getNormal(refSp);\/\/*rDir;\n        \/\/edge = 0.;\n\n        \n        \/\/ Color at the reflected hit point.\n        vec3 reflColor = doColor(sp, refSp, refl, sn, lp, edge, crv, 1., t);\n        sceneColor = mix(sceneColor, sceneColor + reflColor*1.33, smoothstep(-bordW\/2., bordW\/2., bordTx0Tx1));\n     \n        \/\/sceneColor = sceneColor + reflColor*1.25; \n    }\n    #endif\n     \n    \/\/ APPLYING SHADOWS\n    \/\/\n    \/\/ Multiply the shadow from the first pass by the final scene color. Ideally, you'd check to\n    \/\/ see if the reflected point was in shadow, and incorporate that too, but we're cheating to\n    \/\/ save cycles and skipping it. It's not really noticeable anyway.\n    sceneColor *= sh;\n    \n    \n    \n   \n    \/\/ POSTPROCESSING\n    \/\/ Interesting red to blueish mix.\n    \/\/sceneColor = mix(sceneColor, pow(min(vec3(1.5, 1, 1)*sceneColor, 1.), vec3(1, 2.5, 12.)), uv.y);\n    \/\/sceneColor = pow(max(sceneColor, 0.), vec3(1.25))*1.33; \/\/ Adding a bit of contrast.\n    \/\/sceneColor *= mix(vec3(1.2, 1, .9).yxz, vec3(1.2, 1, .9).zyx, -rd.y*.5 + .5);\n    \n    \/*\n    vec2 u2 = uv*r2(3.14159\/6.);\n    float overlay = 1. + .35*sin(u2.x*3.14159*iResolution.y\/1.5);\n    overlay *= 1. + .35*sin(u2.y*3.14159*iResolution.y\/1.5); \n    sceneColor *= overlay*1.1;\n    *\/\n    \n    \/\/ Subtle vignette.\n    uv = fragCoord\/iResolution.xy;\n    sceneColor *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625)*.5 + .5;\n    \/\/ Colored varation.\n    \/\/sceneColor = mix(pow(min(vec3(1.5, 1, 1)*sceneColor, 1.), vec3(1, 2.5, 12.)).zyx, sceneColor, \n                    \/\/ pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y) , .125)*.5 + .5);\n    \n    \n\n    \/\/ Clamping the scene color, then presenting to the screen.\n\tfragColor = vec4(sqrt(max(sceneColor, 0.)), 1);\n}\n\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"MsdyD4","date":"1518994180","viewed":9439,"name":"gammatest","username":"hellotanjent","description":"This shader generates test bars for calibrating your monitor against the sRGB standard. See code comments for details.","likes":8,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/*\nThis shader generates a test image for calibrating your monitor against the sRGB\nstandard.\n\nTo use, click the \"Go Fullscreen\" button at the bottom right of the shader and\nview the monitor from 3-5 feet away.\n\nIn a \"perfect\" result the color blocks will appear flat and motionless.\nIn a \"decent\" result the blocks will appear to have a faint wave pattern.\nIn a \"bad\" result the blocks will have very bright or dark waves.\n\nA monitor can be perfectly color-calibrated and still display waves in this test\n- the test is _very_ picky about the monitor displaying _exactly_ what the GPU\nis sending it.\n\nThe following things will all cause the waves to be more visible:\n\n- Non-native resolution\n- Display scaling not at 100%\n- Non-sRGB color space\n- Compressed color signals like YUV422, YUV420 YCbCr422, YCbCr420, etcetera.\n- \"Limited\" dynamic range color output\n- Too-high or too-low contrast, brightness, or gamma\n- Very high refresh rates\n- \"Fastest\" monitor overdrive modes\n- GSYNC or FreeSync turned on (in some cases, not all)\n- Sharpening filters\n- Black stabilizer filters\n- Inter-pixel interference inside the panel itself (mostly on VA panels)\n- Display stream compression, probably, though I can't currently test it.\n*\/\n\n\nfloat gamma(float x) {\n  x = clamp(x, 0.0, 1.0);\n  \/\/ srgb standard\n  x = (x < 0.0031308) ? 12.92 * x : (1.0 + 0.055) * pow(x, 1.0 \/ 2.4) - 0.055;\n  \n  \/\/ gamma 2.2\n  \/\/x = pow(x, 1.0 \/ 2.2);\n  return x;\n}\n\nfloat bit(float x, int bit) {\n    x = fract(x * exp2(float(-bit - 1)));\n    return x < 0.5 ? 0.0 : 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ Divide the screen into 7 vertical stripes and make each one a different color.\n    float barX = floor(7.0 * fragCoord.x \/ iResolution.x) + 1.0;\n    float r = bit(barX, 0);\n    float g = bit(barX, 1);\n    float b = bit(barX, 2);\n    vec4 barColor = vec4(r, g, b, 1.0);\n\n    \/\/ Make each horizontal region 1\/2 the brightness of the one above it.\n    int barY = int(8.0 * fragCoord.y \/ iResolution.y);\n    barColor *= exp2(float(barY - 8));\n    \n    \/\/ Make a moving horizontal wave pattern with a bit of a flat top and bottom.\n    float waveX = sin((iTime * 2.7 + 15.0 * fragCoord.x \/ iResolution.x) * 2.0 * 3.14159);\n    waveX *= 1.05;\n    waveX = clamp(waveX * 0.5 + 0.5, 0.0, 1.0);\n\n    \/\/ Interpolate between the pure color and a \"checkerboard\" version of the color\n    \/\/ based on the wave pattern.\n    float checker = (bit(fragCoord.x, 0) + bit(fragCoord.y, 0)) == 1.0 ? 0.0 : 1.0;\n    checker = checker * 2.0 - 1.0;\n    \n    fragColor = mix(barColor, barColor + barColor * float(checker), waveX);\n    \n    \/\/ Convert from linear color to inverse-gamma-corrected color.\n    \/\/ When displayed on a calibrated monitor, this will turn back into linear color.\n    fragColor.r = gamma(fragColor.r);\n    fragColor.g = gamma(fragColor.g);\n    fragColor.b = gamma(fragColor.b);\n}","name":"Image","description":"","type":"image"}]}];    var gUseScreenshots = piIsMobile();
    var gThemeName = "classic";



    </script>
</head>

<!-- <body onload="resultsInit(12,null,null)"> -->
<body onload="resultsInitStatic(12,null,null)">

<!-- header =================================================================================== -->


<div id="header">

    <div id="headerBlock1">
        <a href="/" id="headerTitle">Shadertoy</a>
        <form name="formSearch" action="/results" method="get" style="display:inline-block;">
        <div  id="headerSearch">
            <input type="search" id="mySearch" name="query" placeholder="Search..." value=""/>
        </div>
        </form>
    </div>

    <div id="headerBlock2">
            <a class="headerLinks" href="/browse">Browse</a>
        <a class="headerLinks" href="/new">New</a>
        <a class="headerLinks" href="/signin">Sign In</a>
        </div>
</div>
<!-- content ================================================================================== -->

<div id="content">

  <div id="controls">
    <div>
      <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
      Sort:      </div>
      <div class="controlOptions"><div class="pageButtonsCurrent" href="/results?query=&sort=popular&filter=">Popular</div><a class="pageButtons" href="/results?query=&sort=newest&filter=">Newest</a><a class="pageButtons" href="/results?query=&sort=love&filter=">Love</a><a class="pageButtons" href="/results?query=&sort=hot&filter=">Hot</a></div>
    </div>

    <div id="controlFilter">
      <div style="display:flex;margin-right:8px;align-items:center;">Filter:</div>
      <div class="controlOptions"> <a class="pageButtons" href="/results?query=&sort=popular&filter=multipass">Multipass</a><a class="pageButtons" href="/results?query=&sort=popular&filter=soundoutput">GPU Sound</a><a class="pageButtons" href="/results?query=&sort=popular&filter=vr">VR</a><a class="pageButtons" href="/results?query=&sort=popular&filter=soundinput">Microphone</a><a class="pageButtons" href="/results?query=&sort=popular&filter=musicstream">Soundcloud</a><a class="pageButtons" href="/results?query=&sort=popular&filter=webcam">Webcam</a></div>
    </div>

    <div>
        <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
        View:</div>
        <div><a class="pageButtons" href="/slideshow?query=&sort=popular">Slideshow</a></div>
    </div>

    <div class="navigation" id="navTop" ><span style="padding-right:8px;">Results (74098):</span><div class="controlOptions"><a id="pageButtonFirst" class="pageButtons" href="results?query=&sort=popular&from=0&num=12">1</a><span>...</span><a id="pageButton"0 class="pageButtons" href="results?query=&sort=popular&from=696&num=12">59</a><a id="pageButton"1 class="pageButtons" href="results?query=&sort=popular&from=708&num=12">60</a><div id="pageButton"2 class="pageButtonsCurrent" href="results?query=&sort=popular&from=720&num=12">61</div><a id="pageButton"3 class="pageButtons" href="results?query=&sort=popular&from=732&num=12">62</a><a id="pageButton"4 class="pageButtons" href="results?query=&sort=popular&from=744&num=12">63</a><span>...</span><a id="pageButtonLast" class="pageButtons" href="results?query=&sort=popular&from=74088&num=12">6175</a></div>
</div>
  </div>


  <div id="shaderGrid">
    <div class='searchResult'><div class='searchResultContainer' id='Preview_0_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_0_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_0_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_0_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_0_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_0_Thumnail'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_0_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_0_Info'>  <span class='previewText'  id='Preview_0_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_0_TextUser'></span>  <span class='previewStats' id='Preview_0_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_1_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_1_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_1_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_1_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_1_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_1_Thumnail'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_1_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_1_Info'>  <span class='previewText'  id='Preview_1_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_1_TextUser'></span>  <span class='previewStats' id='Preview_1_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_2_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_2_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_2_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_2_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_2_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_2_Thumnail'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_2_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_2_Info'>  <span class='previewText'  id='Preview_2_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_2_TextUser'></span>  <span class='previewStats' id='Preview_2_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_3_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_3_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_3_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_3_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_3_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_3_Thumnail'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_3_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_3_Info'>  <span class='previewText'  id='Preview_3_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_3_TextUser'></span>  <span class='previewStats' id='Preview_3_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_4_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_4_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_4_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_4_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_4_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_4_Thumnail'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_4_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_4_Info'>  <span class='previewText'  id='Preview_4_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_4_TextUser'></span>  <span class='previewStats' id='Preview_4_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_5_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_5_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_5_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_5_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_5_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_5_Thumnail'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_5_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_5_Info'>  <span class='previewText'  id='Preview_5_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_5_TextUser'></span>  <span class='previewStats' id='Preview_5_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_6_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_6_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_6_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_6_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_6_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_6_Thumnail'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_6_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_6_Info'>  <span class='previewText'  id='Preview_6_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_6_TextUser'></span>  <span class='previewStats' id='Preview_6_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_7_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_7_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_7_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_7_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_7_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_7_Thumnail'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_7_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_7_Info'>  <span class='previewText'  id='Preview_7_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_7_TextUser'></span>  <span class='previewStats' id='Preview_7_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_8_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_8_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_8_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_8_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_8_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_8_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_8_Thumnail'>        <img class='previewThumbnailImage' id='Preview_8_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_8_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_8_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_8_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_8_Info'>  <span class='previewText'  id='Preview_8_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_8_TextUser'></span>  <span class='previewStats' id='Preview_8_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_9_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_9_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_9_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_9_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_9_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_9_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_9_Thumnail'>        <img class='previewThumbnailImage' id='Preview_9_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_9_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_9_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_9_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_9_Info'>  <span class='previewText'  id='Preview_9_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_9_TextUser'></span>  <span class='previewStats' id='Preview_9_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_10_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_10_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_10_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_10_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_10_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_10_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_10_Thumnail'>        <img class='previewThumbnailImage' id='Preview_10_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_10_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_10_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_10_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_10_Info'>  <span class='previewText'  id='Preview_10_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_10_TextUser'></span>  <span class='previewStats' id='Preview_10_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_11_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_11_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_11_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_11_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_11_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_11_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_11_Thumnail'>        <img class='previewThumbnailImage' id='Preview_11_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_11_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_11_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_11_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_11_Info'>  <span class='previewText'  id='Preview_11_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_11_TextUser'></span>  <span class='previewStats' id='Preview_11_Stats'></span></div></div>  </div>
  <br>
  <div class="navigation" id="navBottom" ><span style="padding-right:8px;">Results (74098):</span><div class="controlOptions"><a id="pageButtonFirst" class="pageButtons" href="results?query=&sort=popular&from=0&num=12">1</a><span>...</span><a id="pageButton"0 class="pageButtons" href="results?query=&sort=popular&from=696&num=12">59</a><a id="pageButton"1 class="pageButtons" href="results?query=&sort=popular&from=708&num=12">60</a><div id="pageButton"2 class="pageButtonsCurrent" href="results?query=&sort=popular&from=720&num=12">61</div><a id="pageButton"3 class="pageButtons" href="results?query=&sort=popular&from=732&num=12">62</a><a id="pageButton"4 class="pageButtons" href="results?query=&sort=popular&from=744&num=12">63</a><span>...</span><a id="pageButtonLast" class="pageButtons" href="results?query=&sort=popular&from=74088&num=12">6175</a></div>
</div>  <br>      
</div>

<!-- footer ================================================================================== -->

<div id="footer">
    
    <div><span style="color:#ffffff;">Community Forums</span>
      <ul>
      <li><a class="regular" href="/events">Official Events</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/147749602472741">In Facebook (english)</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/1339783682699494">In Facebook (korean)</a></li>
      <li><a class="regular" href="https://discord.gg/XtmMN6E">In Discord</a> (<a class="regular" href="https://discordapp.com/channels/578696555612209173/579531723348639754">direct link</a>)</li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Feedback and Support</span>
      <ul>
      <li><a class="regular" href="https://www.facebook.com/Shadertoy">Facebook</a></li>
      <li><a class="regular" href="https://twitter.com/shadertoy">Twitter</a></li>
      <li><a class="regular" href="https://www.patreon.com/shadertoy">Patreon</a></li>
      <li><a class="regular" href="https://trello.com/b/5hM0CjId">Roadmap</a></li>

      
      </ul>
    </div>

    <div><span style="color:#ffffff;">Shadertoy</span>
      <ul>
      <li><a class="regular" href="/store">Store</a></li>
      <li><a class="regular" href="/howto">Documentation</a></li>
      <li><a class="regular" href="/terms">Terms & Privacy</a></li>
      <li><a class="regular" href="/about">About</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Apps and Plugins</span>
      <ul>
      <li><a class="regular" href="https://itunes.apple.com/us/app/shadertoy/id717961814">Official iPhone App</a> by <a class="user" href="/user/reinder">Reinder</a></li>
      <li><a class="regular" href="https://steamcommunity.com/sharedfiles/filedetails/?id=1726697188">Screensaver</a> by <a class="user" href="/user/kosro">Kosro</a></li>
      <li><a class="regular" href="https://chrome.google.com/webstore/detail/shadertoy-unofficial-plug/ohicbclhdmkhoabobgppffepcopomhgl">Shadertoy plugin</a> by <a class="user" href="/user/patu">Patu</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Tutorials</span>
      <ul>
      <li><a class="regular" href="https://www.youtube.com/watch?v=0ifChJ0nJfM">Shader coding intro</a> by <a class="user" href="/user/iq">iq</a></li>
      <li><a class="regular" href="https://shadertoyunofficial.wordpress.com/">Shadertoy Unofficial</a> by <a class="user" href="/user/FabriceNeyret2">FabriceNeyret2</a></li>
      </ul>
    </div>

</div>

<div id="compliance" style="padding-bottom:6px;visibility:hidden;left:0;top:0px;width:100%;background-color:rgb(200,120,20,0.93);position:absolute;color:#FFFFFF">
    <div style="text-align: center; margin-top:8px">
        We use cookies to give you the best experience on our website. If you continue using Shadertoy, we'll assume that you are happy to receive all cookies on this website. 
        For more information, please review our <a class="regular" href="/terms">Terms & Privacy</a>.
    </div> 
    <div style="text-align: center;margin-top:6px">
        <button type="button" style="width:100px;font-size:inherit" onclick="acceptCompliance()">Accept</button>
    </div>
</div>

<script>
(function runCompliance() 
{
    let showCompliance = 1;
    let allcookies = document.cookie;
    let cookiearray = allcookies.split(';');
    for (var i=0; i<cookiearray.length; i++)
    {
        let name  = cookiearray[i].split('=')[0];
        let value = cookiearray[i].split('=')[1];
        if (name.trim() == "scmp") 
        {
            showCompliance = value;
            break;
        }
    }

    if (showCompliance === 1) 
    {
        var ve = document.getElementById("compliance");
        ve.style.visibility="visible";
    }
})();

function acceptCompliance()
{
    let now = new Date();
    now.setTime( now.getTime() + (5*365*24*60*60*1000) );
    document.cookie="scmp=0;expires=" + now.toUTCString() + ";";

    var ve = document.getElementById("compliance");
    ve.style.visibility="hidden";
}
</script>

</body>
</html>
