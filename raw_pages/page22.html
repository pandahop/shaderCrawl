<!DOCTYPE HTML>
<html lang="en">
<head>

    
<script async src="https://www.googletagmanager.com/gtag/js?id=G-7SYLWGZYJ2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-7SYLWGZYJ2');
</script>

<title>Browse (23) - Shadertoy BETA</title>
<meta charset="utf-8" />
<meta name="Keywords" content="shadertoy, shader toy, quilez, inigo, jeremias, pol, fractals, demoscene, computer graphics, mathematics, rendering, demo, 3D, realtime, shader, raytracing, raymarching, webgl, glsl" />
<meta name="Description" content="Build shaders, share them, and learn from the best community." />
<meta name="Author" content="Beautypi" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<link rel="image_src" href="https://www.shadertoy.com/img/logo.png" />
<link rel="apple-touch-icon" href="/img/launch_icon_57.png"/>
<link rel="apple-touch-icon" sizes="72x72" href="/img/launch_icon_72.png"/>
<link rel="apple-touch-icon" sizes="114x114" href="/img/launch_icon_114.png"/>
<link rel="shortcut icon" href="/img/favicon.ico"/>

<style>::-webkit-scrollbar {
    height: 8px;
    width: 8px;
    background: #404040;
}

::-webkit-scrollbar-thumb
{
    background: #909090;
    border-radius: 0ex;
}

::-webkit-scrollbar-corner
{
    background: #000;
}

::-webkit-input-placeholder
{
	font-style:italic;
}
input:-moz-placeholder, textarea:-moz-placeholder
{
	font-style:italic;
}
input.placeholder-text, textarea.placeholder-text
{
	font-style:italic;
}

pre 
{
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
    white-space: -pre-wrap;
    white-space: -o-pre-wrap;
    word-wrap: break-word;
}

@font-face
{
    font-family: Lobster;
    src: url("/img/lobster.otf") format("opentype");
}

div#centerScreen
{
    left: 50%;
    top: 50%;
    position: absolute;
}

a.headerLinks:hover
{
    background-color:#505050;
    color : #ff8020;
}

body
{
    color: #000000;
    font-size:12px;
    font-style:normal;
    font-family:Tahoma,Arial;
    background-repeat: no-repeat;
    //background-attachment: fixed;
    padding:0px;
    margin:0px;
    text-align: left;
    background-color: #d0d0d0;
    background-repeat: repeat;
    user-select: text;
}

a,
a:hover,
a:visited
{
  color : inherit;
}

div#content {
    width: 95%;
    overflow: hidden;
    margin: auto;
    padding: 0px;
    min-height: calc(100vh - 80px);
    //box-sizing: border-box;
}


.notificationCount
{
 background-color:#ff0000;
 padding-left:3px;
 padding-right:1px;
 padding-top:1px;
 padding-bottom:1px;
}

div#header
{
    background-color: #404040;
    top: 0px;
    left: 0px;
    width: 100%;
    padding: 0;
    margin: 0;
    color: #ffffff;
    display: flex;
    flex-direction:row;
}

#headerBlock1
{
    width: 50%;
    display:flex;
    align-items:center;
}

a#headerTitle
{
    font-size: 2.25em;
    font-family: Lobster,Tahoma,Arial;
    text-decoration: none;
    padding-left:32px;
    padding-right:32px;
}

#headerSearch
{
    display: inline-block;
    color: #000000;
    width: 300px;
}

input[type=search]#mySearch
{
    width: 100%;
    border-radius: 6px;
    border: 1px solid black;
    padding:12px;
}

#headerBlock2
{
    width: 50%;
    margin-left: auto;
    display: flex;
    justify-content: flex-end;
}


a#headerTitle:hover
{
    color : #ff8020;
}

a.headerLinks
{
    font-weight: bold;
    padding-top: 14px;
    padding-bottom: 14px;
    padding-left: 14px;
    padding-right: 14px;
    margin:0px;
    text-decoration: none;
    transition: background-color 0.15s linear, color 0.15s linear;
}

#footer
{
    background-color: rgba(64,64,64,0.25);
    color: #000000;
    padding: 0px;
    margin: 0px;
    width: 100%;
    display: flex;
    justify-content: space-between;
    flex-wrap: wrap;
}

#footer div
{
    padding-top:10px;
    padding-bottom:0px;
    padding-left:16px;
    padding-right:16px;
}

#footer div ul
{
    margin-left:0px;
    padding-left:16px;
}

#footer div ul li
{
    padding-top:6px;
}

a.regular
{
    font-weight:bold;
    text-decoration:none
}

a.regular:hover
{
  color : #ff8020;
}

a.user
{
    font-weight:bold;
    text-decoration:none;
}

a.user:hover
{
  color : #ff8020;
  text-decoration: underline;
}

.uiButton
{
    border: none;
    outline: none;
    margin: 0px;
    padding: 0px;
    width: 22px;
    height: 22px;
    position: absolute;
    cursor: pointer;
    border-radius: 4px;
}

.uiButton:hover
{
    box-shadow: inset 0px 0px 1px 1px #808080, 0px 0px 1px 1px #808080;
}

.uiDivBUtton
{
    cursor:pointer;
}

.uiDivBUtton:hover
{
    color: #ffffff;
}


.dialog
{
    display: block;
    background-color: #e0e0e0;
    color: #000000;
    border:1px solid #000;
    padding:0px;
    margin:0px;
    text-align:left;
    border-radius: 4px;
    box-shadow:4px 4px 6px 0px rgba(0,0,0,0.5);
    overflow: hidden;
    z-index:1000;
    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;
}

.dialogHeader
{
    left:0px;
    top: 0px;
    width:100%;
    height:32px;
    position: absolute;
    background-color: #808080;
    cursor:move;
}

.dialogTitle
{
    left: 12px;
    top: 4px;
    position: absolute;
    padding: 0px;
    margin: 0px;
    color:#000000;
    font-size:1.5em;
    text-align: left;
    user-select: none;
    -moz-user-select: -moz-none;
    -webkit-user-select: none;
}

.dialogOverlay
{
    z-index:1000;

    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;

    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    width:100%;
    height:100%;
    position:absolute;

    background-color:rgba(0,0,0,.4);
}

.viewsIcon, .likesIcon
{
    border: none;
    outline: none;
    display:inline-block;
    background-repeat:no-repeat;
    top:0px;
    left:0px;
    padding:0px;
    padding-right: 2px;
    margin:0px;
    position:relative;
}

.userPictureSmall
{
    background-color:#808080;
    border: 1px solid #000000;
    width:32px;
    height:32px;
}

.dialogCloseButton
{
    right:8px;
    top: 4px;
    width:22px;
    height:22px;
    position: absolute;
    background-image: url("/img/close.png");
    cursor: pointer;
    border-radius: 4px;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContentButtons
{
     padding:0;
     border:0;
     text-align: justify;
     left: 24px;
     bottom:40px;
     position:absolute;
}

.dialogButton
{
    text-align: center;
    vertical-align: middle;
    display: inline-block;
    border-radius: 4px;
    font-weight: bold;
    cursor: pointer;
    padding-bottom:5px;
    padding-top:4px;
    padding-left: 8px;
    padding-right: 8px;
    margin-left:4px;
    margin-right:4px;
    text-decoration: none;
    color:#000000;
    width: 80px;
    -moz-transition:    background-color 0.15s linear, color 0.15s linear;
    -webkit-transition: background-color 0.15s linear, color 0.15s linear;
    transition:         background-color 0.15s linear, color 0.15s linear;
}

.dialogButton:hover
{
  background-color:#808080;
  color : #ff8020;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContent
{
    color: inherit;
    overflow: auto;
    width:100%;
    height:100%;
    left: 0px;
    top: 32px;
    position:absolute
}

.dialogContentBody
{
    color: inherit;
    width:100%;
    height:auto;
    padding-top:24px;
    padding-bottom:24px;
    padding-left:24px;
    padding-right:24px;
    text-align: left;
}

.formButton
{
    font-weight:bold;
	color:#ffffff;
	border:none;
    text-align:center;
	background-color:#808080;
    border-radius: 4px;
	padding-left:8px;
	padding-right:8px;
	padding-top:4px;
	padding-bottom:4px;
    cursor:pointer;
    min-width:80px;
    box-sizing: border-box;
}
.formInput {
    border-radius: 6px;
    border: 1px solid black;
    padding: 4px;
    border: none;
}
.formButton:hover {
    background-color: #e0e0e0;
}
.formButton:disabled
{
	color:#b0b0b0;
	background-color:#808080;
}

.formButtonSmall
{
    color:#ffffff;
    border:none;
    text-align:center;
    background-color:#808080;
    border-radius: 4px;
    padding-left:2px;
    padding-right:2px;
    padding-top:2px;
    padding-bottom:2px;
    cursor:pointer;
    min-width:40px;
}

.formButtonSmall:hover
{
    background-color: #e0e0e0;
}

.formButtonSmall:disabled
{
    color:#b0b0b0;
    background-color:#808080;
}

.formButtonSmall.disabled2,
.formButton.disabled2 { color:#b0b0b0; background-color:#808080; pointer-events: none; }

.inputForm
{
    padding-left:2%;
    padding-right:2%;
    resize: none;
    text-align: left;
    background-color:#e0e0e0;
    outline: none;
    border-radius: 4px;
    border: 1px solid #808080;
    color:inherit;
    box-sizing: border-box;
}

.inputForm:focus
{
    border: 1px solid #AFCDD8;
    background-color: #EBF2F4;
}

.transparentPannel
{
    background-color:rgba(64,64,64,0.1);
    padding:16px;
}

.comment, .commentSelf, .commentNew
{
    border-radius: 4px;
    width: 100%;
    margin-left: 0px;
    margin-right: 0px;
    margin-top: 0px;
    margin-bottom: 6px;

    padding: 14px;
    box-sizing: border-box;
    display: grid;
    grid-template-columns: 32px auto 8px;
    grid-template-rows: 1fr;
    grid-gap:8px;
}

.comment:nth-child(even)
{
    background-color: rgba(64,64,64,0.1);
}

.comment:nth-child(odd)
{
    background-color: rgba(128,128,128,0.1);
}

.commentSelf
{
    background-color: rgba(240,160,64,0.1);
}

.commentNew
{
    padding-right: 0px;
    grid-template-columns: 40px auto;
}

.commentContent
{
    vertical-align: top;
    text-align: left;
    word-break: break-all;
    word-break: break-word;
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
}


/* ----------------------- media resolutions ------------------------ */

@media screen and (max-width:799px)
{
    div#header {flex-direction:column; }
    #headerBlock1 { width:100%; }
    #headerBlock2 { width:100%; justify-content: space-around;}
    div#headerSearch {width:200px;}
    input#mySearch { width:200px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:10px; }
}

@media screen and (min-width:800px) and (max-width:1279px)
{
    body { font-size: 9px; }
    div#headerSearch {width: 250px;}
    input#mySearch { width:250px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:11px; }
}

@media screen and (min-width:1280px) and (max-width:1439px)
{
    body { font-size: 10px; }
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1440px) and (max-width:1919px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1920px) and (max-width:2559px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}

@media screen and (min-width:2560px) 
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}
body
{
    background-image: url("/img/themes/classic/background.jpg");
}
</style>

    <script>"use strict"

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piCamera
//
//==============================================================================

function piCamera()
{
    var mMatrix = setIdentity();
    var mMatrixInv = setIdentity();

    var mPosition = [0.0,0.0,0.0];
    var mXRotation = 0.0;
    var mYRotation = 0.0;

    var mPositionTarget = [0.0,0.0,0.0];
    var mXRotationTarget = 0.0;
    var mYRotationTarget = 0.0;

    var me = {};
/*
    me.Set = function( pos, dir, roll) 
             {
                 mMatrix    = setLookat( pos, add(pos,dir), [Math.sin(roll),Math.cos(roll),Math.sin(roll)] );
                 mMatrixInv = invertFast( mMatrix );
             };
*/
    me.SetPos = function(pos)
                {
                    mPosition = pos;
                    //mMatrix[ 3] = -(mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                    //mMatrix[ 7] = -(mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                    //mMatrix[11] = -(mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                };
/*
    me.GlobalMove = function(pos)
                    {
                        mMatrix[ 3] -= (mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                        mMatrix[ 7] -= (mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                        mMatrix[11] -= (mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                        mMatrixInv = invertFast(mMatrix);
                    };
*/
    me.LocalMove = function( dis )
                    {
                        dis = matMulvec( setRotationY(-mYRotation), dis);
                        mPositionTarget = sub(mPositionTarget,dis)
                    };

    me.RotateXY = function( x, y)
                  {
                    mXRotationTarget -= x;
                    mYRotationTarget -= y;
                    mXRotationTarget = Math.min( Math.max( mXRotationTarget, -Math.PI/2), Math.PI/2 );
                  };


    me.CameraExectue = function( dt )
    {
        // smooth position
        mXRotation += (mXRotationTarget-mXRotation) * 12.0*dt;
        mYRotation += (mYRotationTarget-mYRotation) * 12.0*dt;
        mPosition = add(mPosition, mul( sub(mPositionTarget, mPosition), 12.0*dt));

        // Make Camera matrix
        mMatrix = matMul( matMul(setRotationX(mXRotation), 
                                 setRotationY(mYRotation)),  
                                 setTranslation(mPosition));
        mMatrixInv = invertFast(mMatrix);

    }

    me.GetMatrix = function() { return mMatrix; };
    me.GetMatrixInverse = function() { return mMatrixInv; };
    me.SetMatrix = function( mat ) 
                    {
                        mMatrix = mat;
                        mMatrixInv = invertFast(mMatrix);

                        mPosition = getXYZ(matMulpoint(mat, [0.0,0.0,0.0]));
                        mPositionTarget = mPosition;
                    };

    me.GetPos = function() { return getXYZ(matMulpoint(mMatrixInv, [0.0,0.0,0.0])); }
    me.GetDir = function() { return getXYZ(normalize(matMulvec(mMatrixInv, [0.0,0.0,-1.0]))); }

    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piFile
//
//==============================================================================

function piFile( binaryDataArrayBuffer )
{
    // private
    //var mDataView = new DataView( binaryDataArrayBuffer, 0 );
    var mDataView = binaryDataArrayBuffer;
    var mOffset = 0;

    // public members
    var me = {};
    me.mDummy = 0;
/*
    // public functions
    me.Seek = function( off ) { mOffset = off - 3; };
    me.ReadUInt16 = function()  { var res = mDataView.getUint16( mOffset ); mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = mDataView.getUint32( mOffset ); mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = mDataView.getFloat32( mOffset ); mOffset+=4; return res; };
*/

    me.Seek = function( off ) { mOffset = off; };
    me.ReadUInt8  = function()  { var res = (new Uint8Array(mDataView,mOffset))[0]; mOffset+=1; return res; };
    me.ReadUInt16 = function()  { var res = (new Uint16Array(mDataView,mOffset))[0]; mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = (new Uint32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = (new Float32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadFloat32Array = function(n) 
                          { 
                              var src = new Float32Array(mDataView, mOffset);
                              var res = [];  for( var i=0; i<n; i++ ) { res[i] = src[i]; }
                              mOffset += 4*n;
                              return res;
                          };
    me.ReadFloat32ArrayNative = function(n) { var src = new Float32Array(mDataView, mOffset); mOffset += 4*n; return src; };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piMesh
//
//==============================================================================

function piMesh()
{
    this.mChunks = [];
    this.mPrimitiveType = 0;
    this.mVertexFormat = null;
}

/*
piMesh.prototype.normalize = function( ppos, npos )
{
    var numv = this.mVertexData.length;
    var numt = this.mIndices.length;

    for( var i=0; i<numv; i++ )
    {
        //float *v = (float*)piMesh_GetVertexData( me, i, npos );
        //v[0] = 0.0f;
        //v[1] = 0.0f;
        //v[2] = 0.0f;
        this.mVerts[8 * i + 3] = 0.0;
        this.mVerts[8 * i + 4] = 0.0;
        this.mVerts[8 * i + 5] = 0.0;
    }

    for( var i=0; i<numt; i++ )
    {
        piMeshFace *face = me->mFaceData.mIndexArray[0].mBuffer + i;

        const int ft = face->mNum;
        
        vec3 nor = vec3( 0.0f, 0.0f, 0.0f );
        for( int j=0; j<ft; j++ )
        {
            const vec3 va = *((vec3*)piMesh_GetVertexData( me, face->mIndex[ j      ], ppos ));
            const vec3 vb = *((vec3*)piMesh_GetVertexData( me, face->mIndex[(j+1)%ft], ppos ));

            nor += cross( va, vb );
        }

        for( int j=0; j<ft; j++ )
        {
            vec3 *n = (vec3*)piMesh_GetVertexData( me, face->mIndex[j], npos );
            n->x += nor.x;
            n->y += nor.y;
            n->z += nor.z;
        }
    }

    for( var i=0; i<numv; i++ )
    {
        vec3 *v = (vec3*)piMesh_GetVertexData( me, i, npos );
        *v = normalize( *v );
    }
}
*/

piMesh.prototype.createCube = function(renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([ -1.0, -1.0, -1.0,
                                       1.0, -1.0, -1.0,
                                      -1.0,  1.0, -1.0,
                                       1.0,  1.0, -1.0,
                                      -1.0, -1.0,  1.0,
                                       1.0, -1.0,  1.0,
                                      -1.0,  1.0,  1.0,
                                       1.0,  1.0,  1.0 ]),

                        mIndices : new Uint16Array([ 0, 2, 1,   1, 2, 3,   5, 1, 3,   5, 3, 7,   4, 5, 7,   4, 7, 6,   4, 6, 2,   4, 2, 0,   6, 7, 3,   6, 3, 2,   4, 0, 1,   4, 1, 5 ]),
                        mNumVertices : 8,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };

    this.mVertexFormat = { mStride:12, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}

piMesh.prototype.createCubeSharp = function (renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 1.0,
                                    -1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 0.0,

                                     1.0, 1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 0.0,

                                     1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 1.0,
                                    -1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   1.0, 1.0,
                                     1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   1.0, 0.0,

                                    -1.0, 1.0, 1.0,  -1.0, 0.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0,-1.0,  -1.0, 0.0, 0.0,   0.0, 1.0,
                                    -1.0,-1.0,-1.0,  -1.0, 0.0, 0.0,   1.0, 1.0,
                                    -1.0,-1.0, 1.0,  -1.0, 0.0, 0.0,   1.0, 0.0 ]),

                        mIndices : new Uint16Array([0,1,2, 0,2,3,   4,5,6, 4,6,7,    8,9,10,8,10,11,   12,13,14,12,14,15,   16,17,18,16,18,19,   20,21,22,20,22,23]),
                        mNumVertices : 24,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };


    this.mVertexFormat = { mStride:32, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}


piMesh.prototype.createUnitQuad = function (renderer)
{
    this.mPrimitiveType = 0;
    this.mVertexFormat = { mStride:8, mChannels: [ {mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false} ] };

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0,  1.0, 1.0,  1.0]),
                        mIndices : new Uint16Array([0, 2, 1, 1, 2, 3]),
                        mNumVertices : 4,
                        mNumFaces : 2, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };
 
    return true;
}




piMesh.prototype.destroy = function()
{
    //delete this.mVerts;   this.mVerts = null;
    //delete this.mIndices; this.mIndices = null;
}

piMesh.prototype.scale = function (x, y, z)
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] *= x;
            this.mChunks[j].mVerts[stride * i + 1] *= y;
            this.mChunks[j].mVerts[stride * i + 2] *= z;
        }
    }
}

piMesh.prototype.translate = function (x, y, z) 
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] += x;
            this.mChunks[j].mVerts[stride * i + 1] += y;
            this.mChunks[j].mVerts[stride * i + 2] += z;
        }
    }
}

piMesh.prototype.GPULoad = function (renderer)
{
    for( var i=0; i<this.mChunks.length; i++ )
    {
        var vbo = renderer.CreateVertexArray(this.mChunks[i].mVerts, renderer.BUFTYPE.STATIC );
        if (vbo == null)
            return false;

        var ibo = renderer.CreateIndexArray(this.mChunks[i].mIndices, renderer.BUFTYPE.STATIC);
        if (ibo == null)
            return false;

        this.mChunks[i].mVBO = vbo;
        this.mChunks[i].mIBO = ibo;
    }
    return true;
}

piMesh.prototype.GPURender = function (renderer, positions )//, matPrj, matCam )
{
    //renderer.SetShaderConstantMat4F("unMPrj", matPrj, false );

    var num = this.mChunks.length;
    for( var i=0; i<num; i++ )
    {
        //var mat =  matMul( matCam, this.mChunks[i].mTransform );
        //renderer.SetShaderConstantMat4F("unMMod", mat, false);

        renderer.AttachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat, positions );
        renderer.AttachIndexArray(this.mChunks[i].mIBO );
        renderer.DrawPrimitive(renderer.PRIMTYPE.TRIANGLES, this.mChunks[i].mNumFaces * 3, true, 1);
        renderer.DetachIndexArray(this.mChunks[i].mIBO);
        renderer.DetachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat );
    }
}
//==============================================================================
//
// piLibs 2014-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piRenderer
//
//==============================================================================

function piRenderer()
{
    // private members

    var mGL = null;
    var mBindedShader = null;
    var mIs20 = false;
    var mFloat32Textures;
    var mFloat32Filter;
    var mFloat16Textures;
    var mDrawBuffers;
    var mDepthTextures;
    var mDerivatives;
    var mFloat16Filter;
    var mShaderTextureLOD;
    var mAnisotropic;
    var mRenderToFloat32F;
    var mDebugShader;
    var mAsynchCompile;

    var mVBO_Quad = null;
    var mVBO_Tri = null;
    var mVBO_CubePosNor = null;
    var mVBO_CubePos = null;
    var mShaderHeader = ["",""];
    var mShaderHeaderLines = [0,0];

    // public members
    var me = {};

    me.CLEAR      = { Color: 1, Zbuffer : 2, Stencil : 4 };
    me.TEXFMT     = { C4I8 : 0, C1I8 : 1, C1F16 : 2, C4F16 : 3, C1F32 : 4, C4F32 : 5, Z16 : 6, Z24 : 7, Z32 : 8, C3F32:9 };
    me.TEXWRP     = { CLAMP : 0, REPEAT : 1 };
    me.BUFTYPE    = { STATIC : 0, DYNAMIC : 1 };
    me.PRIMTYPE   = { POINTS : 0, LINES : 1, LINE_LOOP : 2, LINE_STRIP : 3, TRIANGLES : 4, TRIANGLE_STRIP : 5 };
    me.RENDSTGATE = { WIREFRAME : 0, FRONT_FACE : 1, CULL_FACE : 2, DEPTH_TEST : 3, ALPHA_TO_COVERAGE : 4 };
    me.TEXTYPE    = { T2D : 0, T3D : 1, CUBEMAP : 2 };
    me.FILTER     = { NONE : 0, LINEAR : 1, MIPMAP : 2, NONE_MIPMAP : 3 };
    me.TYPE       = { UINT8 : 0, UINT16 : 1, UINT32 : 2, FLOAT16: 3, FLOAT32 : 4, FLOAT64: 5 };

    // private functions

    var iFormatPI2GL = function( format )
    {
        if( mIs20 )
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA8,           mGLExternal: mGL.RGBA,             mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.R8,              mGLExternal: mGL.RED,              mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.R16F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA16F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.R32F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA32F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C3F32) return { mGLFormat: mGL.RGB32F,          mGLExternal: mGL.RGB,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT16, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z24)   return { mGLFormat: mGL.DEPTH_COMPONENT24, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z32)   return { mGLFormat: mGL.DEPTH_COMPONENT32F, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        }
        else
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.RED,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT, mGLExternal: mGL.DEPTH_COMPONENT, mGLType: mGL.UNSIGNED_SHORT }
        }

        return null;
     }

    // public functions

    me.Initialize = function( gl )
                    {
                        mGL = gl;

                        mIs20 = !(gl instanceof WebGLRenderingContext);

                        if( mIs20 )
                        {
                            mFloat32Textures  = true;
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = true;
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = true;
                            mDrawBuffers      = true;
                            mDepthTextures    = true;
                            mShaderTextureLOD = true;
                            mAnisotropic = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mGL.getExtension( 'EXT_color_buffer_float');
                            mDebugShader = mGL.getExtension('WEBGL_debug_shaders');
                            mAsynchCompile = mGL.getExtension('KHR_parallel_shader_compile');

							mGL.hint( mGL.FRAGMENT_SHADER_DERIVATIVE_HINT, mGL.NICEST);
                        }
                        else
                        {
                            mFloat32Textures  = mGL.getExtension( 'OES_texture_float' );
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = mGL.getExtension( 'OES_texture_half_float' );
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = mGL.getExtension( 'OES_standard_derivatives' );
                            mDrawBuffers      = mGL.getExtension( 'WEBGL_draw_buffers' );
                            mDepthTextures    = mGL.getExtension( 'WEBGL_depth_texture' );
                            mShaderTextureLOD = mGL.getExtension( 'EXT_shader_texture_lod' );
                            mAnisotropic      = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mFloat32Textures;
                            mDebugShader      = null;
                            mAsynchCompile    = null;
							
							if( mDerivatives !== null) mGL.hint( mDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, mGL.NICEST);
                        }
                        
                        
                        var maxTexSize = mGL.getParameter( mGL.MAX_TEXTURE_SIZE );
                        var maxCubeSize = mGL.getParameter( mGL.MAX_CUBE_MAP_TEXTURE_SIZE );
                        var maxRenderbufferSize = mGL.getParameter( mGL.MAX_RENDERBUFFER_SIZE );
                        var extensions = mGL.getSupportedExtensions();
                        var textureUnits = mGL.getParameter( mGL.MAX_TEXTURE_IMAGE_UNITS );
                        console.log("WebGL (2.0=" + mIs20 + "):" +
                                    " Asynch Compile: "  + ((mAsynchCompile !==null) ? "yes" : "no") +
                                    ", Textures: F32 ["   + ((mFloat32Textures !==null) ? "yes" : "no") +
                                    "], F16 ["   + ((mFloat16Textures !==null) ? "yes" : "no") +
                                    "], Depth [" + ((mDepthTextures   !==null) ? "yes" : "no") +
                                    "], LOD ["    + ((mShaderTextureLOD!==null) ? "yes" : "no") +
                                    "], Aniso ["   + ((mAnisotropic     !==null) ? "yes" : "no") +
                                    "], Units [" + textureUnits +
                                    "], Max Size [" + maxTexSize +
                                    "], Cube Max Size [" + maxCubeSize +
                                    "], Targets: MRT ["            + ((mDrawBuffers     !==null) ? "yes" : "no") +
                                    "], F32 ["     + ((mRenderToFloat32F!==null) ? "yes" : "no") +
                                    "], Max Size [" + maxRenderbufferSize + "]");

                        // create a 2D quad Vertex Buffer
                        var vertices = new Float32Array( [ -1.0, -1.0,   1.0, -1.0,    -1.0,  1.0,     1.0, -1.0,    1.0,  1.0,    -1.0,  1.0] );
                        mVBO_Quad = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                        mGL.bufferData( mGL.ARRAY_BUFFER, vertices, mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 2D triangle Vertex Buffer
                        mVBO_Tri = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0,   3.0, -1.0,    -1.0,  3.0] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePosNor = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0, -1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                               1.0,  1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                               1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                               1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                               1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0,  1.0, -1.0,   0.0,  0.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePos = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0,  1.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        //-------------------------------------------------------------------

                        mShaderHeader[0] = "";
                        mShaderHeaderLines[0] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[0] += "#version 300 es\n" +
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[0] += 6;
                        }
                        else
                        {
                            mShaderHeader[0] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "#endif\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+                                                
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[0] += 26;
                        }

                        //-------------------------------------------------------

                        mShaderHeader[1] = "";
                        mShaderHeaderLines[1] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[1] += "#version 300 es\n"+
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[1] += 6;
                        }
                        else
                        {
                            if( mDerivatives ) { mShaderHeader[1] += "#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n"; mShaderHeaderLines[1]+=3; }
                            if( mShaderTextureLOD  ) { mShaderHeader[1] += "#extension GL_EXT_shader_texture_lod : enable\n"; mShaderHeaderLines[1]++; }
                            mShaderHeader[1] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "#endif\n"+ 
                                                "vec4 texture(     sampler2D   s, vec2 c)                   { return texture2D(s,c); }\n"+
                                                "vec4 texture(     sampler2D   s, vec2 c, float b)          { return texture2D(s,c,b); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c )                  { return textureCube(s,c); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c, float b)          { return textureCube(s,c,b); }\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[1] += 30;
                            if( mShaderTextureLOD )
                            {
                            mShaderHeader[1] += "vec4 textureLod(  sampler2D   s, vec2 c, float b)          { return texture2DLodEXT(s,c,b); }\n";
                            mShaderHeader[1] += "vec4 textureGrad( sampler2D   s, vec2 c, vec2 dx, vec2 dy) { return texture2DGradEXT(s,c,dx,dy); }\n";
                            mShaderHeaderLines[1] += 2;

                            //mShaderHeader[1] += "vec4 texelFetch( sampler2D s, ivec2 c, int l) { return texture2DLodEXT(s,(vec2(c)+0.5)/vec2(800,450),float(l)); }\n";
                            //mShaderHeaderLines[1] += 1;
                            }
                        }

                        return true;
                    };

        me.GetCaps =    function ()
                        {   
                            return { mIsGL20 : mIs20,
                                     mFloat32Textures: mFloat32Textures != null,
                                     mFloat16Textures: mFloat16Textures != null,
                                     mDrawBuffers: mDrawBuffers != null,
                                     mDepthTextures: mDepthTextures != null,
                                     mDerivatives: mDerivatives != null,
                                     mShaderTextureLOD: mShaderTextureLOD != null };
                        };

        me.GetShaderHeaderLines = function (shaderType)
                        {   
                            return mShaderHeaderLines[shaderType];
                        };

        me.CheckErrors = function()
                         {
                                var error = mGL.getError();
                                if( error != mGL.NO_ERROR ) 
                                { 
                                    for( var prop in mGL ) 
                                    {
                                        if( typeof mGL[prop] == 'number' ) 
                                        {
                                            if( mGL[prop] == error )
                                            {
                                                console.log( "GL Error " + error + ": " + prop );
                                                break;
                                            }
                                        }
                                    }
                                }
                         };

        me.Clear =  function( flags, ccolor, cdepth, cstencil )
                    {
                        var mode = 0;
                        if( flags & 1 ) { mode |= mGL.COLOR_BUFFER_BIT;   mGL.clearColor( ccolor[0], ccolor[1], ccolor[2], ccolor[3] ); }
                        if( flags & 2 ) { mode |= mGL.DEPTH_BUFFER_BIT;   mGL.clearDepth( cdepth ); }
                        if( flags & 4 ) { mode |= mGL.STENCIL_BUFFER_BIT; mGL.clearStencil( cstencil ); }
                        mGL.clear( mode );
                    };


        me.CreateTexture = function ( type, xres, yres, format, filter, wrap, buffer)
                           {
                                if( mGL===null ) return null;

                                var id = mGL.createTexture();

                                var glFoTy = iFormatPI2GL( format );
                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                if( type===me.TEXTYPE.T2D )
                                {
                                    mGL.bindTexture( mGL.TEXTURE_2D, id );
//if( buffer==null )
    //mGL.texStorage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres);
//else
                                    mGL.texImage2D( mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap );

                                    if (filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                }
                                else if( type===me.TEXTYPE.T3D )
                                {
                                    if( mIs20 )
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_3D, id );
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_BASE_LEVEL, 0);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAX_LEVEL, Math.log2(xres));
                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_3D);
                                        }
                                        mGL.texImage3D( mGL.TEXTURE_3D, 0, glFoTy.mGLFormat, xres, yres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap );

                                        if (filter === me.FILTER.MIPMAP)
                                            mGL.generateMipmap( mGL.TEXTURE_3D );
                                        mGL.bindTexture( mGL.TEXTURE_3D, null );
                                    }
                                    else 
                                    {
                                        return null;
                                    }
                                }
                                else 
                                {
                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );

                                    // this works great if we know the number of required mipmaps in advance (1, or other)
                                   //mGL.texStorage2D( mGL.TEXTURE_CUBE_MAP, 1, glFoTy.mGLFormat, xres, yres );

                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                    if( filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                    }

                                    if (filter === me.FILTER.MIPMAP)
                                        mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );

                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                }
                        return { mObjectID: id, mXres: xres, mYres: yres, mFormat: format, mType: type, mFilter: filter, mWrap: wrap, mVFlip:false };
                        };

        me.CreateTextureFromImage = function ( type, image, format, filter, wrap, flipY) 
                                {
                                    if( mGL===null ) return null;

                                    var id = mGL.createTexture();

                                    var glFoTy = iFormatPI2GL( format );

                                    var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                    if( type===me.TEXTYPE.T2D )
                                    {
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);

                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.pixelStorei(mGL.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                                        if( mIs20 ) mGL.pixelStorei(mGL.UNPACK_COLORSPACE_CONVERSION_WEBGL, mGL.NONE );

                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);

                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);

                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if( filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                    }
                                    else if( type===me.TEXTYPE.T3D )
                                    {
                                        return null;
                                    }
                                    else 
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );

                                        if( filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                    }
                                    return { mObjectID: id, mXres: image.width, mYres: image.height, mFormat: format, mType: type, mFilter: filter, mWrap:wrap, mVFlip:flipY };
                                };

        me.SetSamplerFilter = function (te, filter, doGenerateMipsIfNeeded) 
                            {
                                if (te.mFilter === filter) return;

                                if (te.mType === me.TEXTYPE.T2D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_3D, null);

                                }
                                else
                                {
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }


                                te.mFilter = filter;
                            };

        me.SetSamplerWrap = function (te, wrap)
                            {
                                if (te.mWrap === wrap) return;

                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, id);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, id);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_3D, null);
                                }

                                te.mWrap = wrap;
                            };

        me.SetSamplerVFlip = function (te, vflip, image)
                            {
                                if (te.mVFlip === vflip) return;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    if( image != null)
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                }
                                else if (te.mType === me.TEXTYPE.CUBEMAP)
                                {
                                    if( image != null)
                                    {
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei( mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
        
                                }

                                te.mVFlip = vflip;
                            };

        me.CreateMipmaps =  function (te)
                            {
                                if( te.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);
                                    mGL.generateMipmap(mGL.TEXTURE_2D);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);
                                }
                                else if( te.mType===me.TEXTYPE.CUBEMAP )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);
                                    mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }
                            };

        me.UpdateTexture =  function( tex, x0, y0, xres, yres, buffer )
                            {
                                var glFoTy = iFormatPI2GL( tex.mFormat );
                                if( tex.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture( mGL.TEXTURE0);
                                    mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                    mGL.texSubImage2D( mGL.TEXTURE_2D, 0, x0, y0, xres, yres, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                }
                            };

        me.UpdateTextureFromImage = function( tex, image )
                                {
                                    var glFoTy = iFormatPI2GL( tex.mFormat );
                                    if( tex.mType===me.TEXTYPE.T2D )
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                        mGL.texImage2D(  mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image );
                                        mGL.bindTexture( mGL.TEXTURE_2D, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                };

        me.DestroyTexture = function( te )
                            {
                                 mGL.deleteTexture( te.mObjectID );
                            };

        me.AttachTextures = function (num, t0, t1, t2, t3) 
                            {
                                if (num > 0 && t0 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                         if (t0.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t0.mObjectID);
                                }

                                if (num > 1 && t1 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE1);
                                         if (t1.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t1.mObjectID);
                                }

                                if (num > 2 && t2 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE2);
                                         if (t2.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t2.mObjectID);
                                }

                                if (num > 3 && t3 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE3);
                                         if (t3.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t3.mObjectID);
                                }
                            };

        me.DettachTextures = function()
                             {
                                mGL.activeTexture(mGL.TEXTURE0);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE1);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE2);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE3);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                             };

        me.CreateRenderTarget = function ( color0, color1, color2, color3, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);

                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_2D, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.DestroyRenderTarget = function ( tex )
                                 {
                                     mGL.deleteFramebuffer(tex.mObjectID);
                                 };

        me.SetRenderTarget = function (tex)
                             {
                                if( tex===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, tex.mObjectID);

                                //mGL.drawBuffers([mGL.COLOR_ATTACHMENT0, mGL.COLOR_ATTACHMENT1]);
                             };

        me.CreateRenderTargetNew = function ( wantColor0, wantZbuffer, xres, yres, samples )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if( wantZbuffer===true )
                                    {
                                        var zb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);

                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.DEPTH_COMPONENT16, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                    }

                                    if( wantColor0 )
                                    {
                                        var cb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, cb);
                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.RGBA8, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.RGBA8, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.RENDERBUFFER, cb);
                                    }

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                    {
                                        return null;
                                    }
                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mXres: xres, mYres:yres, mTex0: color0 };
                                };

        me.CreateRenderTargetCubeMap = function ( color0, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);
                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.SetRenderTargetCubeMap = function (fbo, face)
                             {
                                if( fbo===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                {
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, fbo.mObjectID);
                                    mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X+face, fbo.mTex0.mObjectID, 0);
                                }
                             };


        me.BlitRenderTarget = function( dst, src )
                                {
                                    mGL.bindFramebuffer(mGL.READ_FRAMEBUFFER, src.mObjectID);
                                    mGL.bindFramebuffer(mGL.DRAW_FRAMEBUFFER, dst.mObjectID);
                                    mGL.clearBufferfv(mGL.COLOR, 0, [0.0, 0.0, 0.0, 1.0]);
                                    mGL.blitFramebuffer( 0, 0, src.mXres, src.mYres,
                                                         0, 0, src.mXres, src.mYres,
                                                         mGL.COLOR_BUFFER_BIT, mGL.LINEAR
                                    );
                                };

        me.SetViewport = function( vp )
                         {
                              mGL.viewport( vp[0], vp[1], vp[2], vp[3] );
                         };

        me.SetWriteMask = function( c0, c1, c2, c3, z )
                          {
                              mGL.depthMask(z);
                              mGL.colorMask(c0,c0,c0,c0);
                          };

        me.SetState = function( stateName, stateValue )
                      {
                            if (stateName === me.RENDSTGATE.WIREFRAME)
                            {
                                if( stateValue ) mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.LINE );
                                else             mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.FILL );
                            }
                            else if (stateName === me.RENDSTGATE.FRONT_FACE)
                            {
                                if( stateValue ) mGL.cullFace( mGL.BACK );
                                else             mGL.cullFace( mGL.FRONT );
                            }
                            else if (stateName === me.RENDSTGATE.CULL_FACE)
                            {
                                if( stateValue ) mGL.enable( mGL.CULL_FACE );
                                else             mGL.disable( mGL.CULL_FACE );
                            }
                            else if (stateName === me.RENDSTGATE.DEPTH_TEST)
                            {
                                if( stateValue ) mGL.enable( mGL.DEPTH_TEST );
                                else             mGL.disable( mGL.DEPTH_TEST );
                            }
                            else if (stateName === me.RENDSTGATE.ALPHA_TO_COVERAGE)
                            {
                                if( stateValue ) { mGL.enable(  mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                                else             { mGL.disable( mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                            }
                      };

        me.SetMultisample = function( v)
                    {
                        if( v===true )
                        {
                            mGL.enable(mGL.SAMPLE_COVERAGE);
                            mGL.sampleCoverage(1.0, false);
                        }
                        else
                        {
                            mGL.disable(mGL.SAMPLE_COVERAGE);
                        }
                    };

        me.GetTranslatedShaderSource = function (shader) 
                          {
                            if( mGL===null ) return null;
                            if( mDebugShader===null ) return null;
                            let vfs = mGL.getAttachedShaders(shader.mProgram);
                            let str = mDebugShader.getTranslatedShaderSource(vfs[1]);
                            let parts = str.split("GLSL END"); str = (parts.length<2) ? str : parts[1];
                            return str;
                          };

        me.CreateShader = function (vsSource, fsSource, preventCache, forceSynch, onResolve) 
                          {
                            if( mGL===null ) return;

                            var vs = mGL.createShader( mGL.VERTEX_SHADER   );
                            var fs = mGL.createShader( mGL.FRAGMENT_SHADER );

                            vsSource = mShaderHeader[0] + vsSource;
                            fsSource = mShaderHeader[1] + fsSource;

                            if( preventCache )
                            {
                                let vran = Math.random().toString(36).substring(7);
                                let fran = Math.random().toString(36).substring(7);
                                vsSource += "\n#define K" + vran + "\n";
                                fsSource += "\n#define K" + fran + "\n";
                            }

                            var timeStart = getRealTime();

                            mGL.shaderSource(vs, vsSource);
                            mGL.shaderSource(fs, fsSource);
                            mGL.compileShader(vs);
                            mGL.compileShader(fs);

                            var pr = mGL.createProgram();
                            mGL.attachShader(pr, vs);
                            mGL.attachShader(pr, fs);
                            mGL.linkProgram(pr);

                            //-------------
                            let checkErrors = function()
                            {
                                if (!mGL.getProgramParameter(pr, mGL.LINK_STATUS))
                                {
                                    // vs error
                                    if (!mGL.getShaderParameter(vs, mGL.COMPILE_STATUS))
                                    {
                                        let vsLog = mGL.getShaderInfoLog(vs);
                                        onResolve(false, { mErrorType: 0, mErrorStr: vsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // fs error
                                    else if (!mGL.getShaderParameter(fs, mGL.COMPILE_STATUS))
                                    {
                                        let fsLog = mGL.getShaderInfoLog(fs);
                                        onResolve(false, { mErrorType: 1, mErrorStr: fsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // link error
                                    else
                                    {
                                        let infoLog = mGL.getProgramInfoLog(pr);
                                        onResolve(false, { mErrorType: 2, mErrorStr: infoLog });
                                        mGL.deleteProgram(pr);
                                    }
                                }
                                // no errors
                                else
                                {
                                    let compilationTime = getRealTime() - timeStart;
                                    onResolve(true, { mProgram: pr, mTime: compilationTime });
                                }
                            };

                            // check compilation
                            if (mAsynchCompile === null || forceSynch===true )
                            {
                                checkErrors();
                            }
                            else
                            {
                                let loopCheckCompletion = function ()
                                {
                                    if( mGL.getProgramParameter(pr, mAsynchCompile.COMPLETION_STATUS_KHR) === true )
                                        checkErrors();
                                    else
                                        setTimeout(loopCheckCompletion, 10);
                                };
                                setTimeout(loopCheckCompletion, 10);
                            }
                        };

        me.AttachShader = function( shader )
                          {
                                if( shader===null )
                                {
                                    mBindedShader = null;
                                    mGL.useProgram( null );
                                }
                                else
                                {
                                    mBindedShader = shader;
                                    mGL.useProgram(shader.mProgram);
                                }
                          };

        me.DetachShader = function ()
                        {
                            mGL.useProgram(null);
                        };

        me.DestroyShader = function( tex )
                        {
                            mGL.deleteProgram(tex.mProgram);
                        };

        me.GetAttribLocation = function (shader, name)
                        {
                            return mGL.getAttribLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantLocation = function (shader, name)
                        {
                            return mGL.getUniformLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantMat4F = function( uname, params, istranspose )
                        {
                            var program = mBindedShader;

                            let pos = mGL.getUniformLocation( program.mProgram, uname );
                            if( pos===null )
                                return false;

                            if( istranspose===false )
                            {
                                var tmp = new Float32Array( [ params[0], params[4], params[ 8], params[12],
                                                              params[1], params[5], params[ 9], params[13],
                                                              params[2], params[6], params[10], params[14],
                                                              params[3], params[7], params[11], params[15] ] );
	                            mGL.uniformMatrix4fv(pos,false,tmp);
                            }
                            else
                                mGL.uniformMatrix4fv(pos,false,new Float32Array(params) );
                            return true;
                        };

        me.SetShaderConstant1F_Pos = function(pos, x)
                        {
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1FV_Pos = function(pos, x)
                        {
                            mGL.uniform1fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant1F = function( uname, x )
                        {
                            var pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1I = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1i(pos, x);
                            return true;
                        };
        me.SetShaderConstant1I_Pos = function(pos, x)
                        {
                            mGL.uniform1i(pos, x);
                            return true;
                        };


        me.SetShaderConstant2F = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform2fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant3F = function(uname, x, y, z)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform3f(pos, x, y, z);
                            return true;
                        };

        me.SetShaderConstant1FV = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1fv(pos, new Float32Array(x));
                            return true;
                        };

        me.SetShaderConstant3FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform3fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderConstant4FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform4fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderTextureUnit = function( uname, unit )
                        {
                            var program = mBindedShader;
                            let pos = mGL.getUniformLocation(program.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform1i(pos, unit);
                            return true;
                        };

        me.CreateVertexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, id);
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.CreateIndexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, id );
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.DestroyArray = function( tex )
                        {
                            mGL.destroyBuffer(tex.mObject);
                        };

        me.AttachVertexArray = function( tex, attribs, pos )
                        {
                            let shader = mBindedShader;

                            mGL.bindBuffer( mGL.ARRAY_BUFFER, tex.mObject);

                            var num = attribs.mChannels.length;
                            var stride = attribs.mStride;

                            var offset = 0;
                            for (var i = 0; i < num; i++)
                            {
                                var id = pos[i];
                                mGL.enableVertexAttribArray(id);
                                var dtype = mGL.FLOAT;
                                var dsize = 4;
                                     if( attribs.mChannels[i].mType === me.TYPE.UINT8   ) { dtype = mGL.UNSIGNED_BYTE;  dsize = 1; }
                                else if( attribs.mChannels[i].mType === me.TYPE.UINT16  ) { dtype = mGL.UNSIGNED_SHORT; dsize = 2; }
                                else if( attribs.mChannels[i].mType === me.TYPE.FLOAT32 ) { dtype = mGL.FLOAT;          dsize = 4; }
                                mGL.vertexAttribPointer(id, attribs.mChannels[i].mNumComponents, dtype, attribs.mChannels[i].mNormalize, stride, offset);
                                offset += attribs.mChannels[i].mNumComponents * dsize;
                            }
                        };

        me.AttachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, tex.mObject);
                        };

        me.DetachVertexArray = function (tex, attribs)
                        {
                            let num = attribs.mChannels.length;
                            for (let i = 0; i < num; i++)
                                mGL.disableVertexAttribArray(i);
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, null);
                        };

        me.DetachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, null);
                        };

        me.DrawPrimitive = function( typeOfPrimitive, num, useIndexArray, numInstances )
                        {
                            let glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.POINTS ) glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.LINES ) glType = mGL.LINES;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_LOOP ) glType = mGL.LINE_LOOP;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_STRIP ) glType = mGL.LINE_STRIP;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLES ) glType = mGL.TRIANGLES;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLE_STRIP ) glType = mGL.TRIANGLE_STRIP;

                            if( numInstances<=1 )
                            {
  	                            if( useIndexArray ) mGL.drawElements( glType, num, mGL.UNSIGNED_SHORT, 0 );
	                            else                mGL.drawArrays( glType, 0, num );
                            }
                            else
                            {
                                mGL.drawArraysInstanced(glType, 0, num, numInstances);
                                mGL.drawElementsInstanced( glType, num, mGL.UNSIGNED_SHORT, 0, numInstances);
                            }
                        };


        me.DrawFullScreenTriangle_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 3 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };


        me.DrawUnitQuad_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 6 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };

        me.DrawUnitCube_XYZ_NOR = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                            mGL.vertexAttribPointer( vpos[0], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.vertexAttribPointer( vpos[1], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos[0] );
                            mGL.enableVertexAttribArray( vpos[1] );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos[0] );
                            mGL.disableVertexAttribArray( vpos[1] );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.DrawUnitCube_XYZ = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                            mGL.vertexAttribPointer( vpos, 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.SetBlend = function( enabled )
                    {
                        if( enabled )
                        {
                            mGL.enable( mGL.BLEND );
                            mGL.blendEquationSeparate( mGL.FUNC_ADD, mGL.FUNC_ADD );
                            mGL.blendFuncSeparate( mGL.SRC_ALPHA, mGL.ONE_MINUS_SRC_ALPHA, mGL.ONE, mGL.ONE_MINUS_SRC_ALPHA );
                        }
                        else
                        {
                            mGL.disable( mGL.BLEND );
                        }
                    };

        me.GetPixelData = function( data, offset, xres, yres )
                        {
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.UNSIGNED_BYTE, data, offset);
                        };

        me.GetPixelDataRenderTarget = function( obj, data, xres, yres )
                        {
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, obj.mObjectID);
                            mGL.readBuffer(mGL.COLOR_ATTACHMENT0);
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.FLOAT, data, 0);
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                        };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piShading
//
//==============================================================================

function smoothstep(a, b, x)
{
    x = (x - a) / (b - a);
    if (x < 0) x = 0; else if (x > 1) x = 1;
    return x * x * (3.0 - 2.0 * x);
}

function clamp01(x)
{
    if( x < 0.0 ) x = 0.0;
    if( x > 1.0 ) x = 1.0;
    return x;
}

function clamp(x, a, b)
{
    if( x < a ) x = a;
    if( x > b ) x = b;
    return x;
}

function screen(a, b)
{
    return 1.0 - (1.0 - a) * (1.0 - b);
}

function parabola(x)
{
    return 4.0 * x * (1.0 - x);
}

function min(a, b)
{
    return (a < b) ? a : b;
}

function max(a, b)
{
    return (a > b) ? a : b;
}

function noise( x )
{
    function grad(i, j, x, y)
    {
        var h = 7 * i + 131 * j;
        h = (h << 13) ^ h;
        h = (h * (h * h * 15731 + 789221) + 1376312589);

        var rx = (h & 0x20000000) ? x : -x;
        var ry = (h & 0x10000000) ? y : -y;

        return rx + ry;
    }

    var i = [ Math.floor(x[0]), Math.floor(x[1]) ];
    var f = [ x[0] - i[0], x[1] - i[1] ];
    var w = [ f[0]*f[0]*(3.0-2.0*f[0]), f[1]*f[1]*(3.0-2.0*f[1]) ];

    var a = grad( i[0]+0, i[1]+0, f[0]+0.0, f[1]+0.0 );
    var b = grad( i[0]+1, i[1]+0, f[0]-1.0, f[1]+0.0 );
    var c = grad( i[0]+0, i[1]+1, f[0]+0.0, f[1]-1.0 );
    var d = grad( i[0]+1, i[1]+1, f[0]-1.0, f[1]-1.0 );

    return a + (b-a)*w[0] + (c-a)*w[1] + (a-b-c+d)*w[0]*w[1];
}//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piVecTypes
//
//==============================================================================


function vec3( a, b, c )
{
    return [ a, b, c ];
}

function add( a, b )
{
    return [ a[0]+b[0], a[1]+b[1], a[2]+b[2] ];
}

function sub( a, b )
{
    return [ a[0]-b[0], a[1]-b[1], a[2]-b[2] ];
}

function mul( a, s ) 
{
    return [ a[0]*s, a[1]*s, a[2]*s ];
}

function cross( a, b )
{
    return [ a[1]*b[2] - a[2]*b[1],
             a[2]*b[0] - a[0]*b[2],
             a[0]*b[1] - a[1]*b[0] ];
}

function dot( a, b ) 
{
    return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
}

function normalize( v ) 
{
    var is = 1.0 / Math.sqrt( v[0]*v[0] + v[1]*v[1] + v[2]*v[2] );
    return [ v[0]*is, v[1]*is, v[2]*is ];
}

function createCirclePoint( cen, uuu, vvv, rad, s, t )
{
    return [ cen[0] + rad*(uuu[0]*s + vvv[0]*t),
             cen[1] + rad*(uuu[1]*s + vvv[1]*t),
             cen[2] + rad*(uuu[2]*s + vvv[2]*t) ];
}

function createTangent( a, b, c )
{
    var cb = normalize( [ c[0]-b[0], c[1]-b[1], c[2]-b[2] ] );
    var ba = normalize( [ b[0]-a[0], b[1]-a[1], b[2]-a[2] ] );
    return normalize( [ ba[0]+cb[0], ba[1]+cb[1], ba[2]+cb[2] ] );

}

//===================================

function vec4( a, b, c, d )
{
    return [ a, b, c, d ];
}

function getXYZ( v )
{
    return [ v[0], v[1], v[2] ];
}

//===================================

function setIdentity()
{
    return [ 1.0, 0.0, 0.0, 0.0,
             0.0, 1.0, 0.0, 0.0,
             0.0, 0.0, 1.0, 0.0,
             0.0, 0.0, 0.0, 1.0 ];
}

function setRotationX( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ 1.0,   0.0,   0.0, 0.0,
             0.0,  cost, -sint, 0.0, 
             0.0,  sint,  cost, 0.0,
             0.0,   0.0,   0.0, 1.0 ];
}

function setRotationY( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ cost, 0.0, -sint, 0.0,
              0.0, 1.0,   0.0, 0.0, 
             sint, 0.0,  cost, 0.0,
              0.0, 0.0,   0.0, 1.0 ];
}

function extractRotationEuler( m)
{
    var res = [];
    if (m[0] == 1.0)
    {
        res[0] = Math.atan2(m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;

    }
    else if (m[0] == -1.0)
    {
        res[0] = Math.atan2( m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;
    }
    else
    {
        res[0] = Math.atan2( -m[9], m[10]);
        res[1] = Math.atan2( m[8], Math.sqrt(m[9]*m[9] + m[10]*m[10]));
        res[2] = Math.atan2( m[4], m[0]);
    }
    return res;
}

function setFromQuaternion( q )
{
    var ww = q[3]*q[3];
    var xx = q[0]*q[0];
    var yy = q[1]*q[1];
    var zz = q[2]*q[2];

    return [ ww+xx-yy-zz,                   2.0*(q[0]*q[1] - q[3]*q[2]), 2.0*(q[0]*q[2] + q[3]*q[1]), 0.0,
               2.0*(q[0]*q[1] + q[3]*q[2]),   ww-xx+yy-zz,                 2.0*(q[1]*q[2] - q[3]*q[0]), 0.0,
               2.0*(q[0]*q[2] - q[3]*q[1]),   2.0*(q[1]*q[2] + q[3]*q[0]), ww-xx-yy+zz,                 0.0,
               0.0,                           0.0,                         0.0,                         1.0 ];
}

function setPerspective( fovy, aspect, znear, zfar )
{
    var tan = Math.tan(fovy * Math.PI/180.0);
    var x = 1.0 / (tan*aspect);
    var y = 1.0 / (tan);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0 * zfar * znear) / (zfar - znear);

    return [ x,    0.0,  0.0,  0.0,
             0.0,  y,    0.0,  0.0,
             0.0,  0.0,  c,     d,
             0.0,  0.0, -1.0,  0.0 ];
}

function setLookAt( eye, tar, up )
{
    var dir = [ -tar[0]+eye[0], -tar[1]+eye[1], -tar[2]+eye[2] ];

	var m00 = dir[2]*up[1] - dir[1]*up[2]; 
    var m01 = dir[0]*up[2] - dir[2]*up[0];
    var m02 = dir[1]*up[0] - dir[0]*up[1];
    var im = 1.0/Math.sqrt( m00*m00 + m01*m01 + m02*m02 );
    m00 *= im;
    m01 *= im;
    m02 *= im;

	var m04 = m02*dir[1] - m01*dir[2]; 
    var m05 = m00*dir[2] - m02*dir[0];
    var m06 = m01*dir[0] - m00*dir[1];
    im = 1.0/Math.sqrt( m04*m04 + m05*m05 + m06*m06 );
    m04 *= im;
    m05 *= im;
    m06 *= im;

	var m08 = dir[0];
	var m09 = dir[1];
	var m10 = dir[2];
    im = 1.0/Math.sqrt( m08*m08 + m09*m09 + m10*m10 );
    m08 *= im;
    m09 *= im;
    m10 *= im;

	var m03 = -(m00*eye[0] + m01*eye[1] + m02*eye[2] );
	var m07 = -(m04*eye[0] + m05*eye[1] + m06*eye[2] );
	var m11 = -(m08*eye[0] + m09*eye[1] + m10*eye[2] );

    return [ m00, m01, m02, m03,
             m04, m05, m06, m07,
             m08, m09, m10, m11,
             0.0, 0.0, 0.0, 1.0 ];
}


function setOrtho( left, right, bottom, top, znear, zfar )
{
   var x = 2.0 / (right - left);
   var y = 2.0 / (top - bottom);
   var a = (right + left) / (right - left);
   var b = (top + bottom) / (top - bottom);
   var c = -2.0 / (zfar - znear);
   var d = -(zfar + znear) / ( zfar - znear);

   return [  x, 0.0, 0.0,   a,
           0.0,   y, 0.0,   b,
           0.0, 0.0,   c,   d,
           0.0, 0.0, 0.0, 1.0 ];
}

function setTranslation( p )
{
    return [ 1.0, 0.0, 0.0, p[0],
             0.0, 1.0, 0.0, p[1],
             0.0, 0.0, 1.0, p[2],
             0.0, 0.0, 0.0, 1.0 ];
}

function setScale( s )
{
    return [ s[0], 0.0,  0.0,  0.0,
             0.0,  s[1], 0.0,  0.0,
             0.0,  0.0,  s[2], 0.0,
             0.0,  0.0,  0.0,  1.0];
}

function setProjection( fov, znear, zfar )
{
    var x = 2.0 / (fov[3]+fov[2]);
    var y = 2.0 / (fov[0]+fov[1]);
    var a = (fov[3]-fov[2]) / (fov[3]+fov[2]);
    var b = (fov[0]-fov[1]) / (fov[0]+fov[1]);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0*zfar*znear) / (zfar - znear);
    return [   x, 0.0,    a, 0.0,
             0.0,   y,    b, 0.0,
             0.0, 0.0,    c,   d,
             0.0, 0.0, -1.0, 0.0 ];
   // inverse is:
   //return mat4x4( 1.0/x, 0.0f,  0.0f,   a/x,
   //               0.0f,  1.0/y, 0.0f,   b/x,
   //               0.0f,  0.0f,  0.0f,   -1.0,
   //               0.0f,  0.0f,  1.0f/d, c/d );
}


function invertFast( m )
{
    var inv = [
   
             m[5]  * m[10] * m[15] - 
             m[5]  * m[11] * m[14] - 
             m[9]  * m[6]  * m[15] + 
             m[9]  * m[7]  * m[14] +
             m[13] * m[6]  * m[11] - 
             m[13] * m[7]  * m[10],

             -m[1]  * m[10] * m[15] + 
              m[1]  * m[11] * m[14] + 
              m[9]  * m[2] * m[15] - 
              m[9]  * m[3] * m[14] - 
              m[13] * m[2] * m[11] + 
              m[13] * m[3] * m[10],

             m[1]  * m[6] * m[15] - 
             m[1]  * m[7] * m[14] - 
             m[5]  * m[2] * m[15] + 
             m[5]  * m[3] * m[14] + 
             m[13] * m[2] * m[7] - 
             m[13] * m[3] * m[6],

             -m[1] * m[6] * m[11] + 
              m[1] * m[7] * m[10] + 
              m[5] * m[2] * m[11] - 
              m[5] * m[3] * m[10] - 
              m[9] * m[2] * m[7] + 
              m[9] * m[3] * m[6],

             -m[4]  * m[10] * m[15] + 
              m[4]  * m[11] * m[14] + 
              m[8]  * m[6]  * m[15] - 
              m[8]  * m[7]  * m[14] - 
              m[12] * m[6]  * m[11] + 
              m[12] * m[7]  * m[10],

             m[0]  * m[10] * m[15] - 
             m[0]  * m[11] * m[14] - 
             m[8]  * m[2] * m[15] + 
             m[8]  * m[3] * m[14] + 
             m[12] * m[2] * m[11] - 
             m[12] * m[3] * m[10],

             -m[0]  * m[6] * m[15] + 
              m[0]  * m[7] * m[14] + 
              m[4]  * m[2] * m[15] - 
              m[4]  * m[3] * m[14] - 
              m[12] * m[2] * m[7] + 
              m[12] * m[3] * m[6],


             m[0] * m[6] * m[11] - 
             m[0] * m[7] * m[10] - 
             m[4] * m[2] * m[11] + 
             m[4] * m[3] * m[10] + 
             m[8] * m[2] * m[7] - 
             m[8] * m[3] * m[6],


             m[4]  * m[9] * m[15] - 
             m[4]  * m[11] * m[13] - 
             m[8]  * m[5] * m[15] + 
             m[8]  * m[7] * m[13] + 
             m[12] * m[5] * m[11] - 
             m[12] * m[7] * m[9],



             -m[0]  * m[9] * m[15] + 
              m[0]  * m[11] * m[13] + 
              m[8]  * m[1] * m[15] - 
              m[8]  * m[3] * m[13] - 
              m[12] * m[1] * m[11] + 
              m[12] * m[3] * m[9],

              m[0]  * m[5] * m[15] - 
              m[0]  * m[7] * m[13] - 
              m[4]  * m[1] * m[15] + 
              m[4]  * m[3] * m[13] + 
              m[12] * m[1] * m[7] - 
              m[12] * m[3] * m[5],

              -m[0] * m[5] * m[11] + 
               m[0] * m[7] * m[9] + 
               m[4] * m[1] * m[11] - 
               m[4] * m[3] * m[9] - 
               m[8] * m[1] * m[7] + 
               m[8] * m[3] * m[5],

              -m[4]  * m[9] * m[14] + 
               m[4]  * m[10] * m[13] +
               m[8]  * m[5] * m[14] - 
               m[8]  * m[6] * m[13] - 
               m[12] * m[5] * m[10] + 
               m[12] * m[6] * m[9],

              m[0]  * m[9] * m[14] - 
              m[0]  * m[10] * m[13] - 
              m[8]  * m[1] * m[14] + 
              m[8]  * m[2] * m[13] + 
              m[12] * m[1] * m[10] - 
              m[12] * m[2] * m[9],

              -m[0]  * m[5] * m[14] + 
               m[0]  * m[6] * m[13] + 
               m[4]  * m[1] * m[14] - 
               m[4]  * m[2] * m[13] - 
               m[12] * m[1] * m[6] + 
               m[12] * m[2] * m[5],

              m[0] * m[5] * m[10] - 
              m[0] * m[6] * m[9] - 
              m[4] * m[1] * m[10] + 
              m[4] * m[2] * m[9] + 
              m[8] * m[1] * m[6] - 
              m[8] * m[2] * m[5] ];

    var det = m[0] * inv[0] + m[1] * inv[4] + m[2] * inv[8] + m[3] * inv[12];

    det = 1.0/det;

    for( var i = 0; i<16; i++ ) inv[i] = inv[i] * det;

    return inv;
}

function matMul( a, b )
{
    var res = [];
    for( var i=0; i<4; i++ )
    {
        var x = a[4*i+0];
        var y = a[4*i+1];
        var z = a[4*i+2];
        var w = a[4*i+3];

        res[4*i+0] = x * b[ 0] + y * b[ 4] + z * b[ 8] + w * b[12];
        res[4*i+1] = x * b[ 1] + y * b[ 5] + z * b[ 9] + w * b[13];
        res[4*i+2] = x * b[ 2] + y * b[ 6] + z * b[10] + w * b[14];
        res[4*i+3] = x * b[ 3] + y * b[ 7] + z * b[11] + w * b[15];
    }

    return res;
}

function matMulpoint( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2] + m[ 3],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2] + m[ 7],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] + m[11] ];
}

function matMulvec( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] ];
}


function bound3( infi )
{
    return [ infi, -infi, infi, -infi, infi, -infi ];
}

function bound3_include( a, p )
{
    return [
        (p[0]<a[0]) ? p[0] : a[0],
        (p[0]>a[1]) ? p[0] : a[1],
        (p[1]<a[2]) ? p[1] : a[2],
        (p[1]>a[3]) ? p[1] : a[3],
        (p[2]<a[4]) ? p[2] : a[4],
        (p[2]>a[5]) ? p[2] : a[5] ];
}

function bound3_center( b )
{
    return [ 0.5*(b[0]+b[1]),
             0.5*(b[2]+b[3]),
             0.5*(b[4]+b[5]) ];
}

function bound3_radius( b )
{
    return [ 0.5*(b[1]-b[0]),
             0.5*(b[3]-b[2]),
             0.5*(b[5]-b[4]) ];
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebVR
//
//==============================================================================

function WebVR( isVREnabledCallback, canvasElement )
{
    isVREnabledCallback(false);
    /*


    this.mSupportVR = false;
    this.mHMD = null;

    var me = this;
    var listVRDisplays = function (vrdevs) {
        for (var i = 0; i < vrdevs.length; i++)
        {
            if (vrdevs[i] instanceof VRDisplay)
            {
                me.mHMD = vrdevs[i];
                console.log("WebVR is available.");
                console.log(me.mHMD);
                break;
            }
        }

        isVREnabledCallback(true);
        me.mSupportVR = true;
    }

    if (navigator.getVRDisplays)
    {
        navigator.getVRDisplays().then(listVRDisplays);
    }

    isVREnabledCallback(false);
    this.mCanvas = canvasElement;
    */
}

WebVR.prototype.IsSupported = function()
{
    return false;
    //return this.mSupportVR;
}

WebVR.prototype.GetData = function( id )
{
    return {};
    /*
    var frameData = new VRFrameData();
    var s = this.mHMD.getFrameData(frameData);
    var ss = frameData.pose;
    
    var fovL = this.mHMD.getEyeParameters("left");
    var fovR = this.mHMD.getEyeParameters( "right" );

    // camera info
    var cPos = vec3(0.0, 0.0, 0.0);
    if (ss.position)
        cPos = vec3(-ss.position[0], -ss.position[1], -ss.position[2]);
    var rot = vec4(0.0, 0.0, 0.0, 0.0);
    if (ss.orientation)
        rot = vec4(ss.orientation[0], ss.orientation[1], ss.orientation[2], ss.orientation[3]);
    var cRot = setFromQuaternion(rot);
    var cTra = setTranslation(cPos);
    var cMat = matMul(invertFast(cRot), cTra);
    
    // per eye info
    var lTra = setTranslation( vec3(-fovL.offset[0], -fovL.offset[1], -fovL.offset[2]) );
    var lMat = matMul(lTra, cMat);
    var lPrj = [ Math.tan( fovL.fieldOfView.upDegrees * Math.PI/180.0),
                 Math.tan(fovL.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.rightDegrees * Math.PI / 180.0)];

    var rTra = setTranslation(vec3(-fovR.offset[0], -fovR.offset[1], -fovR.offset[2]));
    var rMat = matMul(rTra, cMat);
    var rPrj = [Math.tan(fovR.fieldOfView.upDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.rightDegrees * Math.PI / 180.0)];

    return {
        mCamera   : { mCamera: cMat },
        mLeftEye  : { mVP:[0,0,fovL.renderWidth,fovL.renderHeight], mProjection:lPrj, mCamera:lMat },
        mRightEye : { mVP:[fovR.renderWidth/2,0,fovR.renderWidth,fovR.renderHeight], mProjection:rPrj, mCamera:rMat }
           };
    */
}

WebVR.prototype.Enable = function( id )
{
    /*
    this.mHMD.requestPresent([{ source: this.mCanvas }]).then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : requestPresent failed.");
        }
    );
    */
}

WebVR.prototype.Disable = function( id )
{
    /*
    if (!this.mHMD.isPresenting)
    {
        return;
    }

    this.mHMD.exitPresent().then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : exitPresent failed.");
        }
    );
    */
}

WebVR.prototype.RequestAnimationFrame = function (id)
{
    //this.mHMD.requestAnimationFrame(id);
}

WebVR.prototype.IsPresenting = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        return true;
    }
    */
    return false;
}

WebVR.prototype.Finish = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        this.mHMD.submitFrame();
    }
    */
}

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebUtils
//
//==============================================================================


// RequestAnimationFrame
window.requestAnimFrame = ( function () { return window.requestAnimationFrame    || window.webkitRequestAnimationFrame ||
                                                 window.mozRequestAnimationFrame || window.oRequestAnimationFrame ||
                                                 window.msRequestAnimationFrame  || function( cb ) { window.setTimeout(cb,1000/60); };
                                        } )();

// performance.now
window.getRealTime = ( function() { if ("performance" in window ) return function() { return window.performance.now(); }
                                                                  return function() { return (new Date()).getTime(); }
                                  } )();

window.URL = window.URL || window.webkitURL;

navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;

function htmlEntities(str) 
{
    return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g,'&apos;');
}

function piDisableTouch()
{
    document.body.addEventListener('touchstart', function(e){ e.preventDefault(); });
}

var piGetTime = function ( timestamp )
{
    if (timestamp == 0)
        return "";
    return new Date(timestamp * 1000).toISOString().substr(0, 10);
}

function piGetCoords( obj )
{
    var x = 0;
    var y = 0; 
    do
    {
         x += obj.offsetLeft;
         y += obj.offsetTop;
    }while( obj = obj.offsetParent );

    return { mX:x, mY:y };
}

function piGetMouseCoords( ev, canvasElement )
{
    var pos = piGetCoords(canvasElement );
    var mcx =                        (ev.pageX - pos.mX) * canvasElement.width / canvasElement.offsetWidth;
    var mcy = canvasElement.height - (ev.pageY - pos.mY) * canvasElement.height / canvasElement.offsetHeight;

    return { mX: mcx, mY: mcy };

}

function piGetSourceElement( e )
{
    var ele = null;
    if( e.target )     ele = e.target;
    if( e.srcElement ) ele = e.srcElement;
    return ele;
}

function piRequestFullScreen( ele )
{
    if( ele==null ) ele =   document.documentElement;
         if( ele.requestFullscreen       ) ele.requestFullscreen();
    else if( ele.msRequestFullscreen     ) ele.msRequestFullscreen();
    else if( ele.mozRequestFullScreen    ) ele.mozRequestFullScreen();
    else if( ele.webkitRequestFullscreen ) ele.webkitRequestFullscreen( Element.ALLOW_KEYBOARD_INPUT );
}

function piIsFullScreen()
{
    return document.fullscreen || document.mozFullScreen || document.webkitIsFullScreen || document.msFullscreenElement || false;
}

function piExitFullScreen()
{
       if( document.exitFullscreen       ) document.exitFullscreen();
  else if( document.msExitFullscreen     ) document.msExitFullscreen();
  else if( document.mozCancelFullScreen  ) document.mozCancelFullScreen();
  else if( document.webkitExitFullscreen ) document.webkitExitFullscreen();
}

function piIsMobile()
{
    return (navigator.userAgent.match(/Android/i) ||
            navigator.userAgent.match(/webOS/i) ||
            navigator.userAgent.match(/iPhone/i) ||
            navigator.userAgent.match(/iPad/i) ||
            navigator.userAgent.match(/iPod/i) ||
            navigator.userAgent.match(/BlackBerry/i) ||
            navigator.userAgent.match(/Windows Phone/i)) ? true : false;
}

function piCreateGlContext( cv, useAlpha, useDepth, usePreserveBuffer, useSupersampling )
{
    var opts = { alpha: useAlpha, 
                 depth: useDepth, 
                 stencil: false, 
                 premultipliedAlpha: false, 
                 antialias: useSupersampling, 
                 preserveDrawingBuffer: usePreserveBuffer, 
                 powerPreference: "high-performance" }; // "low_power", "high_performance", "default"

    var gl = null;
    if( gl === null) gl = cv.getContext( "webgl2", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl2", opts );
    if( gl === null) gl = cv.getContext( "webgl", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl", opts );

    return gl;
}

function piCreateAudioContext()
{
    var res = null;
    try
    {
        if( window.AudioContext ) res = new AudioContext();
        if( res==null && window.webkitAudioContext ) res = new webkitAudioContext();
    }
    catch( e )
    {
        res = null;
    }
    return res;
}

function piHexColorToRGB(str) // "#ff3041"
{
    var rgb = parseInt(str.slice(1), 16);
    var r = (rgb >> 16) & 255;
    var g = (rgb >> 8) & 255;
    var b = (rgb >> 0) & 255;
    return [r, g, b];
}

function piCreateFPSCounter()
{
    var mFrame;
    var mTo;
    var mFPS;

    var iReset = function( time )
    {
        mFrame = 0;
        mTo = time;
        mFPS = 60.0;
    }

    var iCount = function( time )
    {
        mFrame++;

        if( (time-mTo)>500.0 )
        {
            mFPS = 1000.0*mFrame/(time-mTo);
            mFrame = 0;
            mTo = time;
            return true;
        }
        return false;
    }

    var iGetFPS = function()
    {
        return mFPS;
    }
    
    return { Reset : iReset, Count : iCount, GetFPS : iGetFPS };
}

function piCanMediaRecorded(canvas)
{
    if (typeof window.MediaRecorder !== 'function' || typeof canvas.captureStream !== 'function') {
        return false;
    }
    return true;
}

function piCreateMediaRecorder(isRecordingCallback, canvas) 
{
    if (piCanMediaRecorded(canvas) == false)
    {
        return null;
    }
    
    var options = { audioBitsPerSecond : 0, videoBitsPerSecond : 8000000 }; 
	     if (MediaRecorder.isTypeSupported('video/webm;codecs=h264')) options.mimeType = 'video/webm;codecs=h264';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9' )) options.mimeType = 'video/webm;codecs=vp9';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8' )) options.mimeType = 'video/webm;codecs=vp8';
    else                                                              options.mimeType = 'video/webm;';

    var mediaRecorder = new MediaRecorder(canvas.captureStream(), options);
    var chunks = [];
    
    mediaRecorder.ondataavailable = function(e) 
    {
        if (e.data.size > 0) 
        {
            chunks.push(e.data);
        }
    };
 
    mediaRecorder.onstart = function(){ 
        isRecordingCallback( true );
    };
    
    mediaRecorder.onstop = function()
    {
         isRecordingCallback( false );
         let blob     = new Blob(chunks, {type: "video/webm"});
         chunks       = [];
         let videoURL = window.URL.createObjectURL(blob);
         let url      = window.URL.createObjectURL(blob);
         let a        = document.createElement("a");
         document.body.appendChild(a);
         a.style      = "display: none";
         a.href       = url;
         a.download   = "capture.webm";
         a.click();
         window.URL.revokeObjectURL(url);
     };
    
    return mediaRecorder;
}

function piExportToEXR(width, height, numComponents, type, bytes)
{
    var bytesPerComponent = 0;
    if      (type=="Uint")   bytesPerComponent = 4; 
    else if (type=="Half")   bytesPerComponent = 2;
    else if (type=="Float")  bytesPerComponent = 4;

    var tHeader = 258 + (18 * numComponents + 1);
    var tTable = 8 * height;
    var tScanlines = height * (4 + 4 + (numComponents * bytesPerComponent * width));
    var tTotal = tHeader + tTable + tScanlines;

    //console.log("    header size = " + tHeader);
    //console.log("    table size = " + tTable);
    //console.log("    scanlines size = " + tScanlines);
    //console.log("    total = " + tTotal);

    var buffer = new ArrayBuffer(tTotal); 
    var data = new DataView(buffer);

    // Header
    {
        // Header : 4 bytes -> 0x76, 0x2f, 0x31, 0x01
        var c = 0;
        data.setUint8 (c++, 0x76);
        data.setUint8 (c++, 0x2f);
        data.setUint8 (c++, 0x31);
        data.setUint8 (c++, 0x01);

        // Version : 4 bytes -> 2, 0, 0, 0
        data.setUint8 (c++, 0x02);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        
        // Write channel info
        // Write attribute name : "channels"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x73);
            data.setUint8 (c++, 0x0);

            // Write attribute type : "chlist"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : 18 x 3 + 1 = 55
            var attribSize = 18 * numComponents + 1;
            data.setUint8 (c++, attribSize); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            var i;
            for (i = 0; i < numComponents; i++)
            {
                // Attribute : "B" (42) "G" (47) "R" (52)
                if (i==0)       data.setUint8 (c++, 0x42);
                else if (i==1)  data.setUint8 (c++, 0x47);
                else if (i==2)  data.setUint8 (c++, 0x52);
                data.setUint8 (c++, 0x00);
                
                // Value : Float (2), Half (1), Uint (0)
                if      (type=="Uint")   data.setUint8 (c++, 0x00); 
                else if (type=="Half")   data.setUint8 (c++, 0x01);
                else if (type=="Float")  data.setUint8 (c++, 0x02);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);

                // Plinear
                data.setUint8 (c++, 0x01);

                // Reserved
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 

                // X sampling
                data.setUint8 (c++, 0x01); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                
                // Y sampling
                data.setUint8 (c++, 0x01);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
            }
            // End attribute
            data.setUint8 (c++, 0x00);
    
        // Write attribute name : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute type : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : "1"
            data.setUint8 (c++, 0x01); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // Write attribute value : "0" (None)
            data.setUint8 (c++, 0x00);

        // datawindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00); 

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00);

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 

            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // displayWindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x79); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00);

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00); 

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // size
            data.setUint8 (c++, 0x01);
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);
            
            // value 
            data.setUint8 (c++, 0x00);

        // PixelAspectRatio
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x41); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x52); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x00); 

            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);
        
            // size 4
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 1.0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);
        
        // screenWindowCenter
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63);
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x43); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e);
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00);

            // v2f
            data.setUint8 (c++, 0x76); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x00);

            // size 8
            data.setUint8 (c++, 0x08); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

        // screenWindowWidth
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x00); 
            
            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00); 

            // size
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);

            // value
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);

        // End of header
        data.setUint8 (c++, 0x00);
    }
    //console.log("header size = " + c);

    // Scanline table
    var initc = c + height * 8;
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        var jump = initc + scanline * (8 + width * bytesPerComponent * numComponents); 
        data.setUint32 (c, jump, true);
        c += 4; 

        data.setUint32 (c, 0x00, true);
        c += 4;
    }
    //console.log("header + scanlines table size = " + c);

    // Scanlines
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        // Scanline
        data.setUint32(c, scanline, true);
        c += 4;

        // size 24
        var size = width * numComponents * bytesPerComponent; 
        data.setUint32(c, size, true);
        c += 4;

        var numComponentsSource = 4; // number of components in the SOURCE image
        for (var component = 0; component < numComponents ; component ++) 
        {
            for (var pixel = 0 ; pixel < width ; pixel ++) 
            {
                // flip vertical, so we read OpenGL buffers without JS image flipping
                var v = bytes[(height-1-scanline) * width *numComponentsSource + pixel * numComponentsSource + (2-component)];
                if      (type=="Float") data.setFloat32(c, v, true);
                else if (type=="Half")  data.setUint16(c, v, true);

                c += bytesPerComponent;
            }
        }
    }
    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}


function piExportToWAV(numSamples, rate, bits, numChannels, words)
{
    let numBytes = numSamples * numChannels * bits/8;

    let buffer = new ArrayBuffer(44 + numBytes); 
    let data = new DataView(buffer);

    {
        data.setUint32( 0, 0x46464952, true );  // RIFF
        data.setUint32( 4, numBytes + 36, true);
        {
            data.setUint32( 8, 0x45564157, true );  // WAV_WAVE
            data.setUint32( 12, 0x20746D66, true );  // WAV_FMT
            {
                data.setUint32( 16, 16, true);
                data.setUint16( 20, 1, true ); // WAV_FORMAT_PCM
                data.setUint16( 22, numChannels, true);
                data.setUint32( 24, rate, true);
                data.setUint32( 28, rate*numChannels*bits / 8, true);
                data.setUint16( 32, numChannels*bits / 8, true);
                data.setUint16( 34, bits, true);
            }

            data.setUint32( 36, 0x61746164, true);  // WAV_DATA
            {
                data.setUint32( 40, numBytes, true);
                let numWords = numSamples * numChannels;
                for(let i=0; i<numWords; i++ )
                {
                    data.setInt16( 44 + i*2, words[i], true );
                }
            }
        }
    }


    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}

function piTriggerDownload(name, blob)
{
    let url = URL.createObjectURL(blob);
    let aElement = document.createElement("a");
    aElement.href     = url;
    aElement.target   = "_self";
    aElement.download = name;
    document.body.appendChild(aElement);
    aElement.click();
    document.body.removeChild(aElement);
}</script>
    <script>"use strict"

function bufferID_to_assetID( id )
{
    if( id===0 ) return '4dXGR8';
    if( id===1 ) return 'XsXGR8';
    if( id===2 ) return '4sXGR8';
    if( id===3 ) return 'XdfGR8';
    return 'none';
}
function assetID_to_bufferID( id )
{
    if( id==='4dXGR8' ) return 0;
    if( id==='XsXGR8' ) return 1;
    if( id==='4sXGR8' ) return 2;
    if( id==='XdfGR8' ) return 3;
    return -1;
}

function assetID_to_cubemapBuferID( id )
{
    if( id==='4dX3Rr' ) return 0;
    return -1;
}
function cubamepBufferID_to_assetID( id )
{
    if( id===0 ) return '4dX3Rr';
    return 'none';
}

function EffectPass( renderer, is20, isLowEnd, hasShaderTextureLOD, callback, obj, forceMuted, forcePaused, outputGainNode, copyProgram, id, effect  )
{
    this.mID = id;
    this.mInputs  = [null, null, null, null ];
    this.mOutputs = [null, null, null, null ];
    this.mSource = null;

    this.mGainNode = outputGainNode;
    this.mSoundShaderCompiled = false;

    this.mEffect = effect;
    this.mRenderer = renderer;
    this.mProgramCopy = copyProgram; 
    this.mCompilationTime = 0;

    this.mType = "none";
    this.mName = "none";
    this.mFrame = 0;

    this.mShaderTextureLOD = hasShaderTextureLOD;
    this.mIs20 = is20;
    this.mIsLowEnd = isLowEnd;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mForceMuted = forceMuted;
    this.mForcePaused = forcePaused;
}

EffectPass.prototype.MakeHeader_Image = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        // old API
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                   header += "uniform sampler2D iChannel" + i + ";\n";

        // new API (see shadertoy.com/view/wtdGW8)
        header += "uniform struct {\n";
             if( inp===null )                  header += "  sampler2D";
        else if( inp.mInfo.mType==="cubemap" ) header += "  samplerCube";
        else if( inp.mInfo.mType==="volume"  ) header += "  sampler3D";
        else                                  header += "  sampler2D";
        header +=        " sampler;\n";
        header += "  vec3  size;\n";
        header += "  float time;\n";
        header += "  int   loaded;\n";
        header += "}iCh" + i + ";\n";
    }
	header += "void mainImage( out vec4 c, in vec2 f );\n";
    header += "void st_assert( bool cond );\n";
    header += "void st_assert( bool cond, int v );\n";

    if( this.mIs20 ) 
    {
        header += "\nout vec4 shadertoy_out_color;\n" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)shadertoy_out_color.x=-1.0;else if(v==1)shadertoy_out_color.y=-1.0;else if(v==2)shadertoy_out_color.z=-1.0;else shadertoy_out_color.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)shadertoy_out_color.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "shadertoy_out_color = vec4(1.0,1.0,1.0,1.0);" + 
            "vec4 color = vec4(1e20);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "if(shadertoy_out_color.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(shadertoy_out_color.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(shadertoy_out_color.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(shadertoy_out_color.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "shadertoy_out_color = vec4(color.xyz,1.0);" +
        "}";
    }
    else
    {
        header += "" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)gl_FragColor.x=-1.0;else if(v==1)gl_FragColor.y=-1.0;else if(v==2)gl_FragColor.z=-1.0;else gl_FragColor.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)gl_FragColor.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "gl_FragColor = vec4(0.0,0.0,0.0,1.0);" + 
            "vec4 color = vec4(1e20);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "color.w = 1.0;" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(gl_FragColor.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "gl_FragColor = vec4(color.xyz,1.0);"+
        "}";
    }
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 ) 
        this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "void main( void )" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );" +
        "color.w = 1.0;"
    if( this.mIs20 ) 
        this.mImagePassFooterVR +=  "outColor = color;}";
    else
        this.mImagePassFooterVR +=  "gl_FragColor = color;}";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Buffer = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                  header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainImage( out vec4 c,  in vec2 f );\n"

    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +
        "mainImage( color, gl_FragCoord.xy );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
    this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        this.mImagePassFooterVR +="outColor = color; }";
    else
        this.mImagePassFooterVR +="gl_FragColor = color; }";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Cubemap = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                   header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainCubemap( out vec4 c, in vec2 f, in vec3 ro, in vec3 rd );\n"

    header += "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainCubemap( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Sound = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform float     iChannelTime[4];\n" +
              "uniform float     iTimeOffset;\n" +
              "uniform int       iSampleOffset;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n";

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp!==null && inp.mInfo.mType==="cubemap" )
            header += "uniform samplerCube iChannel" + i + ";\n";
        else
            header += "uniform sampler2D iChannel" + i + ";\n";
    }
    header += "\n";
    header += "vec2 mainSound( in int samp, float time );\n";

    if( this.mIs20 )
    {
        header += "out vec4 outColor; void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "int   s = iSampleOffset + int(gl_FragCoord.y-0.2)*512 + int(gl_FragCoord.x-0.2);" +
            "vec2 y = mainSound( s, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "outColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    else
    {
        header += "void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "vec2 y = mainSound( 0, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "gl_FragColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    header += "\n";
    this.mHeader = header;
    this.mHeaderLength = 0;
}


EffectPass.prototype.MakeHeader_Common = function ()
{
    let header = "";
    let headerlength = 0;

    header += "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n";
    headerlength += 2;

    if (this.mIs20)
    {
        header += "out vec4 outColor;\n";
        headerlength += 1;
    }
    header += "void main( void )\n";
    headerlength += 1;

    if (this.mIs20)
        header += "{ outColor = vec4(0.0); }";
    else
        header += "{ gl_FragColor = vec4(0.0); }";
    headerlength += 1;
    header += "\n";
    headerlength += 1;

    this.mHeader = header;
    this.mHeaderLength = headerlength;
}

EffectPass.prototype.MakeHeader = function()
{
         if( this.mType==="image" ) this.MakeHeader_Image();
    else if( this.mType==="sound" ) this.MakeHeader_Sound();
    else if( this.mType==="buffer") this.MakeHeader_Buffer();
    else if( this.mType==="common") this.MakeHeader_Common();
    else if( this.mType==="cubemap") this.MakeHeader_Cubemap();
    else console.log("ERROR 4");
}

EffectPass.prototype.Create_Image = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}
EffectPass.prototype.Destroy_Image = function( wa )
{
}

EffectPass.prototype.Create_Buffer = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}

EffectPass.prototype.Destroy_Buffer = function( wa )
{
}

EffectPass.prototype.Create_Cubemap = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
}

EffectPass.prototype.Destroy_Cubemap = function( wa )
{
}

EffectPass.prototype.Create_Common = function( wa )
{
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.MakeHeader();
}
EffectPass.prototype.Destroy_Common = function( wa )
{
}

EffectPass.prototype.Create_Sound = function (wa)
{
    this.MakeHeader();

    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    this.mSampleRate = 44100;
    this.mPlayTime = 60*3;
    this.mPlaySamples = this.mPlayTime*this.mSampleRate;
    this.mBuffer = wa.createBuffer( 2, this.mPlaySamples, this.mSampleRate );

    //-------------------
    this.mTextureDimensions = 512;
    this.mRenderTexture = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D, 
                                                       this.mTextureDimensions, this.mTextureDimensions,
                                                       this.mRenderer.TEXFMT.C4I8,
                                                       this.mRenderer.FILTER.NONE,
                                                       this.mRenderer.TEXWRP.CLAMP, null);
    this.mRenderFBO = this.mRenderer.CreateRenderTarget(this.mRenderTexture, null, null, null, null, false);

    //-----------------------------

    // ArrayBufferView pixels;
    this.mTmpBufferSamples = this.mTextureDimensions*this.mTextureDimensions;
    this.mData = new Uint8Array( this.mTmpBufferSamples*4 );

    this.mPlaying = false;
}

EffectPass.prototype.Destroy_Sound = function( wa )
{
    if( this.mPlayNode!==null ) this.mPlayNode.stop();
    this.mPlayNode = null;
    this.mBuffer = null;
    this.mData = null;

    this.mRenderer.DestroyRenderTarget(this.mRenderFBO);
    this.mRenderer.DestroyTexture(this.mRenderTexture);
}

EffectPass.prototype.Create = function( passType, wa )
{
    this.mType = passType;
    this.mSource = null;

         if( passType==="image" ) this.Create_Image( wa );
    else if( passType==="sound" ) this.Create_Sound( wa );
    else if( passType==="buffer") this.Create_Buffer( wa );
    else if( passType==="common") this.Create_Common( wa );
    else if( passType==="cubemap") this.Create_Cubemap( wa );
    else alert("ERROR 1");
}

EffectPass.prototype.SetName = function (passName)
{
    this.mName = passName;
}

EffectPass.prototype.SetCode = function (src)
{
    this.mSource = src;
}

EffectPass.prototype.Destroy = function( wa )
{
    this.mSource = null;
         if( this.mType==="image" ) this.Destroy_Image( wa );
    else if( this.mType==="sound" ) this.Destroy_Sound( wa );
    else if( this.mType==="buffer") this.Destroy_Buffer( wa );
    else if( this.mType==="common") this.Destroy_Common( wa );
    else if( this.mType==="cubemap") this.Destroy_Cubemap( wa );
    else alert("ERROR 2");
}

EffectPass.prototype.NewShader_Sound = function( shaderCode, commonShaderCodes)
{
    let vsSource = null;

    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for( let i=0; i<commonShaderCodes.length; i++ )
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    this.mSoundShaderCompiled = false;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader_Image = function ( shaderCode, commonShaderCodes )
{
    this.mSupportsVR = false;

    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    return [vsSource, fsSource];


    /*
    let n1 = shaderCode.indexOf("mainVR(");
    let n2 = shaderCode.indexOf("mainVR (");
    let n3 = shaderCode.indexOf("mainVR  (");
    if( n1>0 || n2>0 || n3>0 )
    {
        let vsSourceVR;
        if( this.mIs20 )
            vsSourceVR = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        else
            vsSourceVR = "attribute in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

        let fsSourceVR = this.mHeader;
        for (let i = 0; i < commonShaderCodes.length; i++) {
            fsSourceVR += commonShaderCodes[i];
        }
        fsSourceVR += shaderCode;
        fsSourceVR += this.mImagePassFooterVR;

        let res = this.mRenderer.CreateShader(vsSource, fsSourceVR, preventCache);
        if( res.mResult == false )
        {
            return res.mInfo;
        }
        if( this.mProgramVR != null )
            this.mRenderer.DestroyShader( this.mProgramVR );

        this.mSupportsVR = true;
        this.mProgramVR = res;
    }
    */
}

EffectPass.prototype.NewShader_Cubemap = function( shaderCode, commonShaderCodes )
{
    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }

    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;

    fsSource += shaderCode;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader_Common = function (shaderCode )
{
    let vsSource = null;
    if (this.mIs20)
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader + shaderCode;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader = function ( commonSourceCodes, preventCache, onResolve)
{
    if( this.mRenderer===null ) return;

    let vs_fs = null;

         if( this.mType==="sound"  ) vs_fs = this.NewShader_Sound(   this.mSource, commonSourceCodes );
    else if( this.mType==="image"  ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="buffer" ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="common" ) vs_fs = this.NewShader_Common(  this.mSource,                   );
    else if( this.mType==="cubemap") vs_fs = this.NewShader_Cubemap( this.mSource, commonSourceCodes );
    else { console.log("ERROR 3: \"" + this.mType + "\""); return; }

    let me = this;
    this.mRenderer.CreateShader(vs_fs[0], vs_fs[1], preventCache, false,
        function (worked, info)
        {
            if (worked === true)
            {
                if (me.mType === "sound")
                {
                    me.mSoundShaderCompiled = true;
                }

                me.mCompilationTime = info.mTime;
                me.mError = false;
                me.mErrorStr = "No Errors";
                if (me.mProgram !== null)
                    me.mRenderer.DestroyShader(me.mProgram);
                me.mTranslatedSource = me.mRenderer.GetTranslatedShaderSource(info);
                me.mProgram = info;
            }
            else
            {
                me.mError = true;
                me.mErrorStr = info.mErrorStr;
            }
            onResolve();
        });
}

EffectPass.prototype.DestroyInput = function( id )
{
    if( this.mInputs[id]===null ) return;

    if( this.mInputs[id].mInfo.mType==="texture" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    if( this.mInputs[id].mInfo.mType==="volume" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="webcam" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video.src = "";

        if( this.mInputs[id].video.srcObject!==null )
        {
        let tracks = this.mInputs[id].video.srcObject.getVideoTracks();
        if( tracks ) tracks[0].stop();
        }
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="video" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="music" || this.mInputs[id].mInfo.mType==="musicstream")
    {
        this.mInputs[id].audio.pause();
        this.mInputs[id].audio.mSound.mFreqData = null;
        this.mInputs[id].audio.mSound.mWaveData = null;
        this.mInputs[id].audio = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="cubemap" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="keyboard" )
    {
        //if( this.mInputs[id].globject != null )
          //  this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="mic" )
    {
        this.mInputs[id].mic = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }

    this.mInputs[id] = null;
}

EffectPass.prototype.TooglePauseInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        else
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.audio.mPaused )
        {
            if( inp.loaded )
            {
                inp.audio.play();
            }
            inp.audio.mPaused = false;
        }
        else
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }

    return null;
}

EffectPass.prototype.StopInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused === false )
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused === false )
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.ResumeInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused )
        {
            inp.audio.play();
            inp.audio.mPaused = false;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.RewindInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp==null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.loaded )
        {
            inp.video.currentTime = 0;
        }
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.loaded )
        {
            inp.audio.currentTime = 0;
        }
    }
}

EffectPass.prototype.MuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = true;
        inp.video.mMuted = true;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 0.0;
        inp.audio.mMuted = true;
    }
}

EffectPass.prototype.UnMuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = false;
        inp.video.mMuted = false;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 1.0;
        inp.audio.mMuted = false;
    }
}

EffectPass.prototype.ToggleMuteInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];
    if( inp===null ) return null;

    if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.video.mMuted;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if( inp.audio.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.audio.mMuted;
    }

    return null;
}

EffectPass.prototype.UpdateInputs = function( wa, forceUpdate, keyboard )
{
   for (let i=0; i<this.mInputs.length; i++ )
   {
        let inp = this.mInputs[i];

        if( inp===null )
        {
            if( forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, null, false, 0, 0, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.image, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mPreview, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if( inp.loaded && forceUpdate )
            {
                if( this.mTextureCallbackFun!==null )
                {
                    let img = (assetID_to_cubemapBuferID(inp.mInfo.mID)===-1) ? inp.image[0] : inp.mImage;
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, img, true, 2, 1, -1.0, this.mID );
                }
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:keyboard.mIcon,mData:keyboard.mData}, false, 6, 0, -1.0, this.mID );
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, -1, this.mID );
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
              if( inp.loaded && inp.audio.mPaused === false && inp.audio.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                      inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                  }

                  if (this.mTextureCallbackFun!==null)
                  {
                           if (inp.mInfo.mType === "music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData}, false, 4, 1, inp.audio.currentTime, this.mID);
                      else if (inp.mInfo.mType === "musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData, info: inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                  }
              }
              else if( inp.loaded===false )
              {
                  if (this.mTextureCallbackFun!==null)
                      this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:null}, false, 4, 0, -1.0, this.mID);
              }
        }
        else if( inp.mInfo.mType==="mic" )
        {
              if( inp.loaded && inp.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                      inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
                  }
                  if( this.mTextureCallbackFun!==null )
                      this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave: ((wa==null)?null:inp.mFreqData) }, false, 5, 1, 0, this.mID );
              }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:null}, true, 9, 1, -1.0, this.mID );
            }
        }
    }
}

EffectPass.prototype.Sampler2Renderer = function (sampler)
{
    let filter = this.mRenderer.FILTER.NONE;
    if (sampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
    if (sampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
    let wrap = this.mRenderer.TEXWRP.REPEAT;
    if (sampler.wrap === "clamp") wrap = this.mRenderer.TEXWRP.CLAMP;
    let vflip = false;
    if (sampler.vflip === "true") vflip = true;

    return { mFilter: filter, mWrap: wrap, mVFlip: vflip };
}

EffectPass.prototype.GetSamplerVFlip = function (id)
{
    let inp = this.mInputs[id];
    return inp.mInfo.mSampler.vflip;
}

EffectPass.prototype.GetTranslatedShaderSource = function ()
{
    return this.mTranslatedSource;
}

EffectPass.prototype.SetSamplerVFlip = function (id, str) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = false;
    if (str === "true") filter = true;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, null);
            inp.mInfo.mSampler.vflip = str;
        }
    }
}

EffectPass.prototype.GetAcceptsVFlip = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return false;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return false;
    return true;
}

EffectPass.prototype.GetSamplerFilter = function (id)
{
    let inp = this.mInputs[id];
    if( inp===null) return;
    return inp.mInfo.mSampler.filter;
}

EffectPass.prototype.SetSamplerFilter = function (id, str, buffers, cubeBuffers) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = renderer.FILTER.NONE;
    if (str === "linear") filter = renderer.FILTER.LINEAR;
    if (str === "mipmap") filter = renderer.FILTER.MIPMAP;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0)
            {
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[0], filter, true);
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[1], filter, true);
                inp.mInfo.mSampler.filter = str;
            }
            else
            {
                renderer.SetSamplerFilter(inp.globject, filter, true);
                inp.mInfo.mSampler.filter = str;
            }
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[0], filter, true);
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[1], filter, true);
        inp.mInfo.mSampler.filter = str;
    }
    else if (inp.mInfo.mType === "keyboard")
    {
        inp.mInfo.mSampler.filter = str;
    }
}

EffectPass.prototype.GetAcceptsMipmapping = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetAcceptsLinear = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return true;
    if (inp.mInfo.mType === "musicstream") return true;
    if (inp.mInfo.mType === "mic")  return true;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return true;
    return false;
}

EffectPass.prototype.GetAcceptsWrapRepeat = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return false;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetSamplerWrap = function (id)
{
    return this.mInputs[id].mInfo.mSampler.wrap;
}

EffectPass.prototype.SetSamplerWrap = function (id, str, buffers)
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let restr = renderer.TEXWRP.REPEAT;
    if (str === "clamp") restr = renderer.TEXWRP.CLAMP;

    if (inp === null) 
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "video") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap") 
    {
        if (inp.loaded)
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "webcam") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[0], restr);
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[1], restr);
        inp.mInfo.mSampler.wrap = str;
    }
}


EffectPass.prototype.GetTexture = function( slot )
{
    let inp = this.mInputs[slot];
    if( inp===null ) return null;
    return inp.mInfo;
}

EffectPass.prototype.SetOutputs = function( slot, id )
{
    this.mOutputs[slot] = id;
}

EffectPass.prototype.SetOutputsByBufferID = function( slot, id )
{
    if( this.mType==="buffer" )
    {
        this.mOutputs[slot] = bufferID_to_assetID( id );

        this.mEffect.ResizeBuffer( id, this.mEffect.mXres, this.mEffect.mYres, false );
    }
    else if( this.mType==="cubemap" )
    {
        this.mOutputs[slot] = cubamepBufferID_to_assetID( id );
        this.mEffect.ResizeCubemapBuffer(id, 1024, 1024 );
    }
}

EffectPass.prototype.NewTexture = function( wa, slot, url, buffers, cubeBuffers, keyboard )
{
    var me = this;
    var renderer = this.mRenderer;

    if( renderer===null ) return;

    let texture = null;

    if( url===null || url.mType===null )
    {
        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( this.mTextureCallbackObj, slot, null, true, 0, 0, -1.0, me.mID );
        me.DestroyInput( slot );
        me.mInputs[slot] = null;
        me.MakeHeader();
        return { mFailed:false, mNeedsShaderCompile:false };
    }
    else if( url.mType==="texture" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.image = new Image();
        texture.image.crossOrigin = '';
        texture.image.onload = function()
        {
            let rti = me.Sampler2Renderer(url.mSampler);

            // O.M.G. FIX THIS
            let channels = renderer.TEXFMT.C4I8;
            if (url.mID === "Xdf3zn" || url.mID === "4sf3Rn" || url.mID === "4dXGzn" || url.mID === "4sf3Rr")
                channels = renderer.TEXFMT.C1I8;
            
            texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.image, channels, rti.mFilter, rti.mWrap, rti.mVFlip);

            texture.loaded = true;
            if( me.mTextureCallbackFun!==null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.image, true, 1, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="volume" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mImage = { mData:null, mXres:1, mYres:0, mZres:0 };
        texture.mPreview = new Image();
        texture.mPreview.crossOrigin = '';

	    var xmlHttp = new XMLHttpRequest();
        if( xmlHttp===null ) return { mFailed:true };

        xmlHttp.open('GET', url.mSrc, true);
        xmlHttp.responseType = "arraybuffer";
        xmlHttp.onerror = function()
        {
            console.log( "Error 1 loading Volume" );
        }
        xmlHttp.onload = function()
        {
            let data = xmlHttp.response;
            if (!data ) { console.log( "Error 2 loading Volume" ); return; }

            let file = piFile(data);

            let signature = file.ReadUInt32();
            texture.mImage.mXres = file.ReadUInt32();
            texture.mImage.mYres = file.ReadUInt32();
            texture.mImage.mZres = file.ReadUInt32();
            let binNumChannels = file.ReadUInt8();
            let binLayout = file.ReadUInt8();
            let binFormat = file.ReadUInt16();
            let format = renderer.TEXFMT.C1I8;
                 if( binNumChannels===1 && binFormat===0 )  format = renderer.TEXFMT.C1I8;
            else if( binNumChannels===2 && binFormat===0 )  format = renderer.TEXFMT.C2I8;
            else if( binNumChannels===3 && binFormat===0 )  format = renderer.TEXFMT.C3I8;
            else if( binNumChannels===4 && binFormat===0 )  format = renderer.TEXFMT.C4I8;
            else if( binNumChannels===1 && binFormat===10 ) format = renderer.TEXFMT.C1F32;
            else if( binNumChannels===2 && binFormat===10 ) format = renderer.TEXFMT.C2F32;
            else if( binNumChannels===3 && binFormat===10 ) format = renderer.TEXFMT.C3F32;
            else if( binNumChannels===4 && binFormat===10 ) format = renderer.TEXFMT.C4F32;
            else return;

            let buffer = new Uint8Array(data, 20); // skip 16 bytes (header of .bin)

            let rti = me.Sampler2Renderer(url.mSampler);

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T3D, texture.mImage.mXres, texture.mImage.mYres, format, rti.mFilter, rti.mWrap, buffer);

            if( texture.globject===null )
            {
                console.log( "Error 4: loading Volume" ); 
                return { mFailed:true };
            }

            if (me.mTextureCallbackFun !== null)
            {
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }

            texture.loaded = true;

            // load icon for it
            texture.mPreview.onload = function()
            {
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }
            texture.mPreview.src = url.mPreviewSrc;
        }
        xmlHttp.send("");


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="volume")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="cubemap" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        let rti = me.Sampler2Renderer(url.mSampler);

        if( assetID_to_cubemapBuferID(url.mID)!==-1 )
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 2, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/cubemap00.png";

            this.mEffect.ResizeCubemapBuffer(0, 1024, 1024 );

        }
        else
        {
            texture.image = [ new Image(), new Image(), new Image(), new Image(), new Image(), new Image() ];

            let numLoaded = 0;
            for (var i=0; i<6; i++ )
            {
                texture.image[i].mId = i;
                texture.image[i].crossOrigin = '';
                texture.image[i].onload = function()
                {
                    var id = this.mId;
                    numLoaded++;
                    if( numLoaded===6 )
                    {
                        texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.CUBEMAP, texture.image, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                        texture.loaded = true;
                        if (me.mTextureCallbackFun !== null)
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, texture.image[0], true, 2, 1, -1.0, me.mID);
                    }
                }

                if( i === 0) 
                {
                    texture.image[i].src = url.mSrc;
                } 
                else 
                {
                    let n = url.mSrc.lastIndexOf(".");
                    texture.image[i].src = url.mSrc.substring(0, n) + "_" + i + url.mSrc.substring(n, url.mSrc.length);
                }
            }
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="cubemap")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="webcam" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        texture.video = document.createElement('video');
    	texture.video.width = 320;
    	texture.video.height = 240;
    	texture.video.autoplay = true;
    	texture.video.loop = true;
        texture.mForceMuted = this.mForceMuted;
        texture.mImage = null;

        let rti = me.Sampler2Renderer(url.mSampler);

        var loadImageInsteadOfWebCam = function()
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.mImage, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 7, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/webcam.png";
        }
        
        loadImageInsteadOfWebCam();

        if( typeof navigator.getUserMedia !== "undefined"  && texture.mForceMuted===false )
        {
            texture.video.addEventListener("canplay", function (e)
            {
				try
				{
                    texture.mImage = null;
                    if( texture.globject != null )
                        renderer.DestroyTexture( texture.globject );
					texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
					texture.loaded = true;
                }
                catch(e)
                {
                    loadImageInsteadOfWebCam();
	                alert( 'Your browser can not transfer webcam data to the GPU.');
                }
            } );

            navigator.mediaDevices.getUserMedia( 
                                { "video": { width: 1280, height: 720 }, "audio": false } )
                                .then( function(stream)
                                       {
                                            texture.video.srcObject = stream;
    	                               } )
                                .catch( function(error)
                                        {
                                            loadImageInsteadOfWebCam();
    		                                alert( 'Unable to capture WebCam. Please reload the page.' );
    	                                } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="mic" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mForceMuted = this.mForceMuted;
        texture.mAnalyser = null;
        let num = 512;
        texture.mFreqData = new Uint8Array( num );
        texture.mWaveData = new Uint8Array( num );

        if( wa === null || typeof navigator.getUserMedia === "undefined" )
        {
            if( !texture.mForceMuted ) alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.mForceMuted = true; 
        }

        if( texture.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, num, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)
            texture.loaded = true;
        }
        else
        {
        navigator.getUserMedia( { "audio": true },
                                function(stream)
                                {
                                  texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, null)
                                  texture.mic = wa.createMediaStreamSource(stream);
                                  texture.mAnalyser = wa.createAnalyser();
                                  texture.mic.connect( texture.mAnalyser );
                                  texture.loaded = true;
    	                        },
                                function(error)
                                {
    		                        alert( 'Unable open Mic. Please reload the page.' );
    	                        } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="video" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.video = document.createElement('video');
    	texture.video.loop = true;
        texture.video.preload = "auto";
        texture.video.mPaused = this.mForcePaused;
        texture.video.mMuted = true;//this.mForceMuted;
    	texture.video.muted  = true;//this.mForceMuted;
        if( this.mForceMuted===true )
            texture.video.volume = 0;
    	texture.video.autoplay = false;
        texture.video.hasFalled = false;
        
        let rti = me.Sampler2Renderer(url.mSampler);

        texture.video.addEventListener("canplay", function (e)
        {
            texture.video.play().then( function()
                                       {
                                           texture.video.mPaused = false;

                                           texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                                           texture.loaded = true;
            
                                           if( me.mTextureCallbackFun!=null )
                                               me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.video, true, 3, 1, -1.0, me.mID );
                                        } )
                               .catch( function(error)
                                       {
                                           console.log( error );
                                       }
                                );
        } );

        texture.video.addEventListener( "error", function(e)
        {
               if( texture.video.hasFalled===true ) { alert("Error: cannot load video" ); return; }
               let str = texture.video.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".mp4";
               texture.video.src = str;
               texture.video.hasFalled = true;
        } );

        texture.video.src = url.mSrc;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="music" || url.mType==="musicstream" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.audio = document.createElement('audio');
    	texture.audio.loop = true;
        texture.audio.mMuted = this.mForceMuted;
        texture.audio.mForceMuted = this.mForceMuted;
        texture.audio.muted = this.mForceMuted;
        if( this.mForceMuted===true )
            texture.audio.volume = 0;
        texture.audio.autoplay = false;
        texture.audio.hasFalled = false;
        texture.audio.mPaused = false;
        texture.audio.mSound = {};

        if( this.mForceMuted===false )
        {
            if(url.mType==="musicstream" && SC === null)
            {
                alert( "Shadertoy: Soundcloud could not be reached" );
                texture.audio.mForceMuted = true;
            }
            }

        if( wa === null && this.mForceMuted===false )
        {
            alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.audio.mForceMuted = true;
        }

        if( texture.audio.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null);
            let num = 512;
            texture.audio.mSound.mFreqData = new Uint8Array( num );
            texture.audio.mSound.mWaveData = new Uint8Array( num );
            texture.loaded = true;
        }

        texture.audio.addEventListener( "canplay", function()
        {
            if( texture===null || texture.audio===null ) return;
            if( this.mForceMuted  ) return;
            if( texture.loaded === true ) return;

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)

            texture.audio.mSound.mSource   = wa.createMediaElementSource( texture.audio );
            texture.audio.mSound.mAnalyser = wa.createAnalyser();
            texture.audio.mSound.mGain     = wa.createGain();

            texture.audio.mSound.mSource.connect(   texture.audio.mSound.mAnalyser );
            texture.audio.mSound.mAnalyser.connect( texture.audio.mSound.mGain );
            texture.audio.mSound.mGain.connect(me.mGainNode);

            texture.audio.mSound.mFreqData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );
            texture.audio.mSound.mWaveData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );

            if( texture.audio.mPaused )
            {
                texture.audio.pause();
            }
            else
            {
                texture.audio.play().then( function() {} ).catch( function(e){console.log("error " + e);} );
            }
            texture.loaded = true;
        } );

        texture.audio.addEventListener( "error", function(e)
        {
               if( this.mForceMuted  ) return;

               if( texture.audio.hasFalled===true ) { return; }
               let str = texture.audio.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".ogg";
               texture.audio.src = str;
               texture.audio.hasFalled = true;
        } );

        if( !texture.audio.mForceMuted )
        {
            if(url.mType==="musicstream")
            {
                SC.resolve(url.mSrc, 
                    function(song) 
                    {
                        if( song.streamable===true )
                        {
                            texture.audio.crossOrigin = 'anonymous';
                            texture.audio.src = song.stream_url;
                            texture.audio.soundcloudInfo = song;
                        }
                        else
                        {
                            alert('Shadertoy: Soundcloud 3 - This track cannot be streamed' );
                        }
                    },
                    function(error)
                    {
                        if (me.mTextureCallbackFun!==null)
                        {
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
                        }
                    } );
            } 
            else
            {
                texture.audio.src = url.mSrc;
            }
        }

        if (me.mTextureCallbackFun!==null)
        {
            if (url.mType === "music")            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
            else if (url.mType === "musicstream") me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null, info: texture.audio.soundcloudInfo}, false, 8, 0, -1.0, me.mID);
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="keyboard" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = true;

        texture.keyboard = {};

        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {mImage: keyboard.mIcon, mData: keyboard.mData}, false, 6, 1, -1.0, me.mID );

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="buffer" )
    {
        texture = {};
        texture.mInfo = url;

        texture.image = new Image();
        texture.image.onload = function()
        {
            if( me.mTextureCallbackFun!==null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {texture: texture.image, data:null}, true, 9, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;
        texture.id = assetID_to_bufferID( url.mID );
        texture.loaded = true;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;

        this.mEffect.ResizeBuffer(texture.id, this.mEffect.mXres, this.mEffect.mYres, false );

        this.SetSamplerFilter(slot, url.mSampler.filter, buffers, cubeBuffers, true);
        this.SetSamplerVFlip(slot, url.mSampler.vflip);
        this.SetSamplerWrap(slot, url.mSampler.wrap, buffers);

        this.MakeHeader();
        return returnValue;
    }
    else
    {
        alert( "input type error" );
        return { mFailed: true };
    }

    return { mFailed: true };
}

EffectPass.prototype.Paint_Image = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];

    //------------------------
    
    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];
    let texIsLoaded = [0, 0, 0, 0 ];
    let texID = [ null, null, null, null];

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
            texIsLoaded[i] = 1;
            resos[3*i+0] = 256;
            resos[3*i+1] = 3;
            resos[3*i+2] = 1;
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;

                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                }
            }
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {

                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                texIsLoaded[i] = 0;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    times[i] = 10.0 + time;
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            let id = inp.id;
            if( inp.loaded===true  )
            {
                texID[i] = buffers[id].mTexture[ buffers[id].mLastRenderDone ];
                texIsLoaded[i] = 1;
                resos[3*i+0] = xres;
                resos[3*i+1] = yres;
                resos[3*i+2] = 1;
                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID[i], filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    let prog = this.mProgram;

    //if( vrData!=null && this.mSupportsVR ) prog = this.mProgramVR;

    this.mRenderer.AttachShader(prog);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F("iFrameRate", fps);

    this.mRenderer.SetShaderConstant1F(  "iCh0.time", times[0] );
    this.mRenderer.SetShaderConstant1F(  "iCh1.time", times[1] );
    this.mRenderer.SetShaderConstant1F(  "iCh2.time", times[2] );
    this.mRenderer.SetShaderConstant1F(  "iCh3.time", times[3] );
    this.mRenderer.SetShaderConstant3F(  "iCh0.size", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iCh1.size", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iCh2.size", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iCh3.size", resos[9], resos[10], resos[11] );
    this.mRenderer.SetShaderConstant1I(  "iCh0.loaded", texIsLoaded[0] );
    this.mRenderer.SetShaderConstant1I(  "iCh1.loaded", texIsLoaded[1] );
    this.mRenderer.SetShaderConstant1I(  "iCh2.loaded", texIsLoaded[2] );
    this.mRenderer.SetShaderConstant1I(  "iCh3.loaded", texIsLoaded[3] );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    if( (vrData !== null) && this.mSupportsVR )
    {
        for (let i=0; i<2; i++ )
        {
            let ei = (i===0) ? vrData.mLeftEye : vrData.mRightEye;

            let vp = [i * xres / 2, 0, xres / 2, yres];

            this.mRenderer.SetViewport(vp);

            let fov = ei.mProjection;
            let corA = [ -fov[2], -fov[1], -1.0 ];
            let corB = [  fov[3], -fov[1], -1.0 ];
            let corC = [  fov[3],  fov[0], -1.0 ];
            let corD = [ -fov[2],  fov[0], -1.0 ];
            let apex = [ 0.0, 0.0, 0.0 ];

            let ma = invertFast( ei.mCamera );
            corA = matMulpoint( ma, corA ); 
            corB = matMulpoint( ma, corB ); 
            corC = matMulpoint( ma, corC ); 
            corD = matMulpoint( ma, corD ); 
            apex = matMulpoint( ma, apex ); 

            let corners = [ corA[0], corA[1], corA[2], 
                            corB[0], corB[1], corB[2], 
                            corC[0], corC[1], corC[2], 
                            corD[0], corD[1], corD[2],
                            apex[0], apex[1], apex[2]];

            this.mRenderer.SetShaderConstant3FV("unCorners", corners);
            this.mRenderer.SetShaderConstant4FV("unViewport", vp);

            this.mRenderer.DrawUnitQuad_XY(l1);
        }
    }
    else 
    {
        this.mRenderer.SetViewport([0, 0, xres, yres]);
        this.mRenderer.DrawFullScreenTriangle_XY( l1 );
    }

    this.mRenderer.DettachTextures();
}

EffectPass.prototype.iRenderSound = function(d, callback )
{
    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds() ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    this.mRenderer.SetRenderTarget(this.mRenderFBO);

    this.mRenderer.SetViewport([0, 0, this.mTextureDimensions, this.mTextureDimensions]);
    this.mRenderer.AttachShader(this.mProgram);
    this.mRenderer.SetBlend( false );

    let texID = [null, null, null, null];
    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
    }

    this.mRenderer.AttachTextures(4, texID[0], texID[1], texID[2], texID[3]);

    let l2 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iTimeOffset");
    let l3 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iSampleOffset");
    this.mRenderer.SetShaderConstant4FV("iDate", dates);
    this.mRenderer.SetShaderConstant3FV("iChannelResolution", resos);
    this.mRenderer.SetShaderConstant1F("iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit("iChannel0", 0);
    this.mRenderer.SetShaderTextureUnit("iChannel1", 1);
    this.mRenderer.SetShaderTextureUnit("iChannel2", 2);
    this.mRenderer.SetShaderTextureUnit("iChannel3", 3);

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    //--------------------------------
    let numSamples = this.mTmpBufferSamples;
    let numBlocks = this.mPlaySamples / numSamples;
    for (let j=0; j<numBlocks; j++ )
    {
        let off = j*numSamples;
        
        this.mRenderer.SetShaderConstant1F_Pos(l2, off / this.mSampleRate);
        this.mRenderer.SetShaderConstant1I_Pos(l3, off );
        this.mRenderer.DrawUnitQuad_XY(l1);

        this.mRenderer.GetPixelData(this.mData, 0, this.mTextureDimensions, this.mTextureDimensions);

        callback( off, this.mData, numSamples );
    }

    this.mRenderer.DetachShader();
    this.mRenderer.DettachTextures();
    this.mRenderer.SetRenderTarget(null);
}

EffectPass.prototype.Paint_Sound = function( wa, d )
{
    let bufL = this.mBuffer.getChannelData(0); // Float32Array
    let bufR = this.mBuffer.getChannelData(1); // Float32Array

    this.iRenderSound( d, function(off, data, numSamples)
                         {
                            for( let i=0; i<numSamples; i++ )
                            {
                                bufL[off+i] = -1.0 + 2.0*(data[4*i+0]+256.0*data[4*i+1])/65535.0;
                                bufR[off+i] = -1.0 + 2.0*(data[4*i+2]+256.0*data[4*i+3])/65535.0;
                            }
                         }
                     );
}

EffectPass.prototype.SetUniforms = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    //------------------------
    
    let texID = [ null, null, null, null];

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
        }
        else if( inp.mInfo.mType=="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
    
                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                }
            }

        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
           if( inp.loaded===true )
           { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                times[i] = 10.0 + time;
            }

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = buffers[inp.id].mTexture[ buffers[inp.id].mLastRenderDone ];
                resos[3*i+0] = buffers[inp.id].mResolution[0];
                resos[3*i+1] = buffers[inp.id].mResolution[1];
                resos[3*i+2] = 1;
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    this.mRenderer.AttachShader(this.mProgram);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F(  "iFrameRate", fps );

    this.mRenderer.SetShaderConstant1F(  "iChannel[0].time",       times[0] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[1].time",       times[1] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[2].time",       times[2] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[3].time",       times[3] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[0].resolution", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[1].resolution", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[2].resolution", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[3].resolution", resos[9], resos[10], resos[11] );
}

EffectPass.prototype.ProcessInputs = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
        }
        else if( inp.mInfo.mType==="volume" )
        {
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );
                }
                else if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                if( inp.audio.mForceMuted === true )
                {
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                let id = inp.id;
                let texID = buffers[id].mTexture[ buffers[id].mLastRenderDone ];

                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID, filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
				let id = inp.id;
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }
}

EffectPass.prototype.Paint_Cubemap = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face )
{
    this.ProcessInputs(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
    this.SetUniforms(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    let vp = [0, 0, xres, yres];

    this.mRenderer.SetViewport(vp);

    let corA = [-1.0, -1.0, -1.0];
    let corB = [ 1.0, -1.0, -1.0];
    let corC = [ 1.0,  1.0, -1.0];
    let corD = [-1.0,  1.0, -1.0];
    let apex = [ 0.0,  0.0,  0.0];

         if( face===0 ) { corA=[ 1.0,  1.0,  1.0]; corB=[ 1.0,  1.0, -1.0]; corC=[ 1.0, -1.0, -1.0]; corD=[ 1.0, -1.0,  1.0]; }
    else if( face===1 ) { corA=[-1.0,  1.0, -1.0]; corB=[-1.0,  1.0,  1.0]; corC=[-1.0, -1.0,  1.0]; corD=[-1.0, -1.0, -1.0]; }
    else if( face===2 ) { corA=[-1.0,  1.0, -1.0]; corB=[ 1.0,  1.0, -1.0]; corC=[ 1.0,  1.0,  1.0]; corD=[-1.0,  1.0,  1.0]; }
    else if( face===3 ) { corA=[-1.0, -1.0,  1.0]; corB=[ 1.0, -1.0,  1.0]; corC=[ 1.0, -1.0, -1.0]; corD=[-1.0, -1.0, -1.0]; }
    else if( face===4 ) { corA=[-1.0,  1.0,  1.0]; corB=[ 1.0,  1.0,  1.0]; corC=[ 1.0, -1.0,  1.0]; corD=[-1.0, -1.0,  1.0]; }
    else if( face===5 ) { corA=[ 1.0,  1.0, -1.0]; corB=[-1.0,  1.0, -1.0]; corC=[-1.0, -1.0, -1.0]; corD=[ 1.0, -1.0, -1.0]; }

    let corners = [ corA[0], corA[1], corA[2], 
                    corB[0], corB[1], corB[2], 
                    corC[0], corC[1], corC[2], 
                    corD[0], corD[1], corD[2],
                    apex[0], apex[1], apex[2]];

    this.mRenderer.SetShaderConstant3FV("unCorners", corners);
    this.mRenderer.SetShaderConstant4FV("unViewport", vp);

    this.mRenderer.DrawUnitQuad_XY(l1);

    this.mRenderer.DettachTextures();
}

EffectPass.prototype.Paint = function( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, bufferNeedsMimaps, buffers, cubeBuffers, keyboard, effect )
{
    if( this.mType==="sound" )
    {
        if (this.mSoundShaderCompiled === true)
        {
            // make sure all textures are loaded
            for (let i=0; i<this.mInputs.length; i++ )
            {
                let inp = this.mInputs[i];
                if (inp === null) continue;

                if (inp.mInfo.mType === "texture" && !inp.loaded) return;
                if (inp.mInfo.mType === "cubemap" && !inp.loaded) return;
            }

            this.Paint_Sound(wa, da);
            this.mSoundShaderCompiled = false;
        }
        if (this.mFrame === 0)
        {
            if (this.mPlaying===true)
            {
                this.mPlayNode.disconnect();
                this.mPlayNode.stop();
                this.mPlayNode = null;
            }
            this.mPlaying = true;

            this.mPlayNode = wa.createBufferSource();
            this.mPlayNode.buffer = this.mBuffer;
            this.mPlayNode.connect(this.mGainNode);
            this.mPlayNode.start(0);
        }
        this.mFrame++;
    }
    else if( this.mType==="image" )
    {
        this.mRenderer.SetRenderTarget( null );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );
        this.mFrame++;
    }
    else if( this.mType==="common" )
    {
    }
    else if( this.mType==="buffer" )
    {
        this.mEffect.ResizeBuffer(bufferID, this.mEffect.mXres, this.mEffect.mYres, false );

        let buffer = buffers[bufferID];

        let dstID = 1 - buffer.mLastRenderDone;

        this.mRenderer.SetRenderTarget( buffer.mTarget[dstID] );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }

        // make thumbnail
        //if( this.mTextureCallbackFun != null )
        /*
        {
            this.mRenderer.SetRenderTarget( buffer.mThumbnailRenderTarget );
            let v = [0, 0, buffer.mThumbnailRes[0], buffer.mThumbnailRes[1]];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            this.mRenderer.SetShaderConstant4FV("v", v);
            this.mRenderer.AttachTextures(1, buffer.mTexture[dstID], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);
            this.mRenderer.DettachTextures();
            this.mRenderer.DetachShader();
            this.mRenderer.GetPixelData( new Uint8Array(buffer.mThumbnailBuffer.data.buffer), buffer.mThumbnailRes[0], buffer.mThumbnailRes[1] );
            this.mRenderer.SetRenderTarget(null);
        }
        */
        buffers[bufferID].mLastRenderDone = 1 - buffers[bufferID].mLastRenderDone;
        this.mFrame++;
    }
    else if( this.mType==="cubemap" )
    {
        this.mEffect.ResizeCubemapBuffer(bufferID, 1024, 1024, false );

        let buffer = cubeBuffers[bufferID];

        xres = buffer.mResolution[0];
        yres = buffer.mResolution[1];
        let dstID = 1 - buffer.mLastRenderDone;
        for( let face=0; face<6; face++ )
        {
            this.mRenderer.SetRenderTargetCubeMap( buffer.mTarget[dstID], face );
            this.Paint_Cubemap( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
        }
        this.mRenderer.SetRenderTargetCubeMap( null, 0 );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }
        cubeBuffers[bufferID].mLastRenderDone = 1 - cubeBuffers[bufferID].mLastRenderDone;

        this.mFrame++;
    }
}

EffectPass.prototype.StopOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;
    this.mPlayNode.disconnect();
}

EffectPass.prototype.ResumeOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;

    wa.resume()
    this.mPlayNode.connect( this.mGainNode );
}

EffectPass.prototype.StopOutput_Image = function( wa )
{
}

EffectPass.prototype.ResumeOutput_Image = function( wa )
{
}

EffectPass.prototype.StopOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.StopInput(j);

    if( this.mType==="sound" )
         this.StopOutput_Sound( wa );
    else
         this.StopOutput_Image( wa );
}

EffectPass.prototype.ResumeOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.ResumeInput(j);

    if( this.mType==="sound" )
         this.ResumeOutput_Sound( wa );
    else
         this.ResumeOutput_Image( wa );
}

EffectPass.prototype.GetCompilationTime = function()
{
    return this.mCompilationTime;
}

//============================================================================================================
function Screenshots()
{
    // private
    let mTexture = null;
    let mTarget = null;
    let mXres = 0;
    let mYres = 0;
    let mCubemapToEquirectProgram;
    let mRenderer = null;

    // public
    var me = {};

    me.Initialize = function(renderer)
    {
        mRenderer = renderer;
        let caps = mRenderer.GetCaps();
        let is20 = caps.mIsGL20;

        let vsSourceC, fsSourceC;
        if( is20 )
        {
            vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; out vec4 outColor; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); outColor = texture(t, rd); }";
        }
        else
        {
            vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); gl_FragColor = texture(t, rd); }";
        }

        let compileShader = function (worked, info)
        {
            if (worked === false)
            {
                console.log("Failed to compile cubemap resample shader (" + errorType + "): " + log);
            }
            else
            {
                mCubemapToEquirectProgram = info;
            }
        }
        mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, compileShader);

        return true;
    };

    me.Allocate = function( xres, yres )
    {
        if( xres>mXres || yres>mYres )
        {
            let texture = mRenderer.CreateTexture(mRenderer.TEXTYPE.T2D, xres, yres, mRenderer.TEXFMT.C4F32, mRenderer.FILTER.NONE, mRenderer.TEXWRP.CLAMP, null);
            let target = mRenderer.CreateRenderTarget( texture, null, null, null, null, false);

            if( mXres!==0 )
            {
                mRenderer.DestroyTexture(mTexture);
                mRenderer.DestroyRenderTarget(mTarget);
            }

            mTexture = texture;
            mTarget = target;
            mXres = xres;
            mYres = yres;
        }
    };

    me.GetProgram = function()
    {
        return mCubemapToEquirectProgram;
    };
    me.GetTarget = function()
    {
        return mTarget;
    };

    return me;
};

//============================================================================================================

function Effect(vr, ac, canvas, callback, obj, forceMuted, forcePaused, resizeCallback, crashCallback )
{
    let xres = canvas.width;
    let yres = canvas.height;

    let me = this;
    this.mCanvas = canvas;
    this.mCreated = false;
    this.mRenderer = null;
    this.mAudioContext = ac;
    this.mGLContext = null;
    this.mWebVR = vr;
    this.mRenderingStereo = false;
    this.mXres = xres;
    this.mYres = yres;
    this.mForceMuted = forceMuted;
    if( ac===null ) this.mForceMuted = true;
    this.mForcePaused = forcePaused;
    this.mGainNode = null;
    this.mPasses = [];
    this.mFrame = 0;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mMaxBuffers = 4;
    this.mMaxCubeBuffers = 1;
    this.mMaxPasses = this.mMaxBuffers + 1 + 1 + 1 + 1; // some day decouple passes from buffers (4 buffers + common + Imagen + sound + cubemap)
    this.mBuffers = [];
    this.mCubeBuffers = [];
    this.mScreenshotSytem = null;
    this.mCompilationTime = 0;
    this.mIsLowEnd = piIsMobile();

    this.mGLContext = piCreateGlContext(canvas, false, false, true, false); // need preserve-buffe to true in order to capture screenshots
    if (this.mGLContext === null)
    {
        return;
    }

    canvas.addEventListener("webglcontextlost", function (event)
        {
            event.preventDefault();
            crashCallback();
        }, false);

    this.mRenderer = piRenderer();
    if (!this.mRenderer.Initialize(this.mGLContext))
        return;

    this.mScreenshotSytem = Screenshots();
    if (!this.mScreenshotSytem.Initialize(this.mRenderer))
        return;

    var caps = this.mRenderer.GetCaps();
    this.mIs20 = caps.mIsGL20;
    this.mShaderTextureLOD = caps.mShaderTextureLOD;
    //-------------
    if( ac!==null )
    {   
        this.mGainNode = ac.createGain();
        if( !forceMuted )
        {
            this.mGainNode.connect( ac.destination);
        }
        if (this.mForceMuted )
            this.mGainNode.gain.value = 0.0;
        else
            this.mGainNode.gain.value = 1.0;
    }

    //-------------
    let vsSourceC, fsSourceC;
    if( this.mIs20 )
    {
        vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { outColor = textureLod(t, gl_FragCoord.xy / v.zw, 0.0); }";
    }
    else
    {
        vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; void main() { gl_FragColor = texture2D(t, gl_FragCoord.xy / v.zw, -100.0); }";
    }

    this.mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, function(worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to copy buffers : " + info.mErrorStr);
            else me.mProgramCopy = info;
        });

    let vsSourceD, fsSourceD;
    if( this.mIs20 )
    {
        vsSourceD = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { vec2 uv = gl_FragCoord.xy / v.zw; outColor = texture(t, vec2(uv.x,1.0-uv.y)); }";
    }
    else
    {
        vsSourceD = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; void main() { vec2 uv = gl_FragCoord.xy / v.zw; gl_FragColor = texture2D(t, vec2(uv.x,1.0-uv.y)); }";
    }

    this.mRenderer.CreateShader(vsSourceD, fsSourceD, false, true, function (worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to downscale buffers : " + info.mErrorStr);
            else me.mProgramDownscale = info;
        });


    // set all buffers and cubemaps to null
    for( let i=0; i<this.mMaxBuffers; i++ )
    {
        this.mBuffers[i] = { mTexture: [null, null], 
                             mTarget:  [null, null], 
                             mResolution: [0, 0],
                             mLastRenderDone: 0,
                             mThumbnailRenderTarget: null,
                             mThumbnailTexture: null,
                             mThumbnailBuffer:  null,
                             mThumbnailRes: [0, 0] };
    }

    for( let i=0; i<this.mMaxCubeBuffers; i++ )
    {
        this.mCubeBuffers[i] = { mTexture: [null, null], 
                                mTarget:  [null, null], 
                                mResolution: [0, 0],
                                mLastRenderDone: 0,
                                mThumbnailRenderTarget: null,
                                mThumbnailTexture: null,
                                mThumbnailBuffer:  null,
                                mThumbnailRes: [0, 0] };
    }

    //-------

    let keyboardData = new Uint8Array( 256*3 );
    for (let j=0; j<(256*3); j++ ) { keyboardData[j] = 0; }
    let kayboardTexture = this.mRenderer.CreateTexture( this.mRenderer.TEXTYPE.T2D, 256, 3, this.mRenderer.TEXFMT.C1I8, this.mRenderer.FILTER.NONE, this.mRenderer.TEXWRP.CLAMP, null);
    let keyboardImage = new Image();
    if( callback!==null )
        keyboardImage.src = "/img/keyboard.png"; // don't load PNG if no UI 
    this.mKeyboard = { mData: keyboardData, mTexture: kayboardTexture, mIcon: keyboardImage };

    let iResize = function( xres, yres )
    {
        me.mCanvas.width = xres;
        me.mCanvas.height = yres;
        me.mXres = xres;
        me.mYres = yres;
        me.ResizeBuffers(xres, yres);
        resizeCallback(xres, yres);
    };

    let bestAttemptFallback = function()
    {
        let devicePixelRatio = window.devicePixelRatio || 1;
        let xres = Math.round(me.mCanvas.offsetWidth  * devicePixelRatio) | 0;
        let yres = Math.round(me.mCanvas.offsetHeight * devicePixelRatio) | 0;
        iResize(xres, yres);
    };

    if(!window.ResizeObserver)
    {
        console.log("WARNING: This browser doesn't support ResizeObserver.");
        bestAttemptFallback();
        window.addEventListener("resize", bestAttemptFallback);
    }
    else
    {
        this.mRO = new ResizeObserver( function(entries, observer)
        {
            var entry = entries[0];
            if (!entry['devicePixelContentBoxSize'])
            {
                observer.unobserve(me.mCanvas);
                console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (2)");
                bestAttemptFallback();
                window.addEventListener("resize", bestAttemptFallback);
            }
            else
            {
                let box = entry.devicePixelContentBoxSize[0];
                let xres = box.inlineSize;
                let yres = box.blockSize;
                iResize(xres, yres);
            }
        });
        try
        {
            this.mRO.observe(this.mCanvas, { box: ["device-pixel-content-box"] });
            //this.mRO.observe(this.mCanvas);
        }
        catch (e)
        {
            console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (1)");
            bestAttemptFallback();
            window.addEventListener("resize", bestAttemptFallback);
        }
    }

    this.mCreated = true;
}

Effect.prototype.ResizeCubemapBuffer = function(i, xres, yres )
{
    let oldXres = this.mCubeBuffers[i].mResolution[0];
    let oldYres = this.mCubeBuffers[i].mResolution[1];

    if( this.mCubeBuffers[i].mTexture[0]===null || oldXres !== xres || oldYres !== yres )
    {
        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);
        let target1 = this.mRenderer.CreateRenderTargetCubeMap( texture1, null, false);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target2 = this.mRenderer.CreateRenderTargetCubeMap( texture2, null, false);

        // Store new buffers
        this.mCubeBuffers[i].mTexture = [texture1,texture2], 
        this.mCubeBuffers[i].mTarget =  [target1, target2 ], 
        this.mCubeBuffers[i].mLastRenderDone = 0;
        this.mCubeBuffers[i].mResolution[0] = xres;
        this.mCubeBuffers[i].mResolution[1] = yres;
    }
}

Effect.prototype.ResizeBuffer = function( i, xres, yres, skipIfNotExists )
{
    if( skipIfNotExists && this.mBuffers[i].mTexture[0]===null ) return;

    let oldXres = this.mBuffers[i].mResolution[0];
    let oldYres = this.mBuffers[i].mResolution[1];

    if( oldXres !== xres || oldYres !== yres )
    {
        let needCopy = (this.mBuffers[i].mTexture[0]!==null);

        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[0].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[0].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[1].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[1].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target1 = this.mRenderer.CreateRenderTarget( texture1, null, null, null, null, false);
        let target2 = this.mRenderer.CreateRenderTarget( texture2, null, null, null, null, false);

        if( needCopy )
        {
            let v = [0, 0, Math.min(xres, oldXres), Math.min(yres, oldYres)];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            let vOld = [0, 0, oldXres, oldYres];
            this.mRenderer.SetShaderConstant4FV("v", vOld);

            // Copy old buffers 1 to new buffer
            this.mRenderer.SetRenderTarget(target1);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[0], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Copy old buffers 2 to new buffer
            this.mRenderer.SetRenderTarget(target2);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[1], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Deallocate old memory
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[0]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[0]);
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[1]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[1]);
            //this.mRenderer.DestroyTexture(this.mBuffers[i].thumbnailTexture);
        }

        // Store new buffers
        this.mBuffers[i].mTexture = [texture1,texture2], 
        this.mBuffers[i].mTarget =  [target1, target2 ], 
        this.mBuffers[i].mLastRenderDone = 0;
        this.mBuffers[i].mResolution[0] = xres;
        this.mBuffers[i].mResolution[1] = yres;
    }
}

Effect.prototype.saveScreenshot = function(passid)
{
    let pass = this.mPasses[passid];

    if( pass.mType === "buffer" )
    {
        let bufferID = assetID_to_bufferID( this.mPasses[passid].mOutputs[0] );

        let texture = this.mBuffers[bufferID].mTarget[ this.mBuffers[bufferID].mLastRenderDone ];

        let numComponents = 3;
        let width = texture.mTex0.mXres;
        let height = texture.mTex0.mYres;
        let type = "Float"; // Other options Float, Half, Uint
        let bytes = new Float32Array(width * height * 4 );//numComponents);
        this.mRenderer.GetPixelDataRenderTarget( texture, bytes, width, height );
        let blob = piExportToEXR(width, height, numComponents, type, bytes);

        // Offer download automatically to the user
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "cubemap" )
    {
        let xres = 4096;
        let yres = 2048;
        this.mScreenshotSytem.Allocate( xres, yres );

        let cubeBuffer = this.mCubeBuffers[0];

        let target = this.mScreenshotSytem.GetTarget();
        this.mRenderer.SetRenderTarget( target );

        let program = this.mScreenshotSytem.GetProgram();

        this.mRenderer.AttachShader(program);
        let l1 = this.mRenderer.GetAttribLocation(program, "pos");
        this.mRenderer.SetViewport( [0, 0, xres, yres] );
        this.mRenderer.AttachTextures(1, cubeBuffer.mTexture[ cubeBuffer.mLastRenderDone ], null, null, null);
        this.mRenderer.DrawUnitQuad_XY(l1);
        this.mRenderer.DettachTextures();
        this.mRenderer.SetRenderTarget( null );

        let data = new Float32Array(xres*yres*4);
        this.mRenderer.GetPixelDataRenderTarget( target, data, xres, yres );

        let blob = piExportToEXR(xres, yres, 3, "Float", data );
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "sound" )
    {
        let offset = 0;
        const bits = 16;
        const numChannels = 2;
        let words = new Int16Array(60*pass.mSampleRate*numChannels );

        pass.iRenderSound( new Date(), function(off, data, numSamples)
                                         {
                                            for( let i=0; i<numSamples; i++ )
                                            {
                                                words[offset++] = (data[4*i+0]+256.0*data[4*i+1]) - 32767;
                                                words[offset++] = (data[4*i+2]+256.0*data[4*i+3]) - 32767;
                                            }
                                         }
                                     );

        let blob = piExportToWAV( 60*pass.mSampleRate, pass.mSampleRate, bits, numChannels, words);

        piTriggerDownload("sound.wav", blob);
    }    
}

Effect.prototype.ResizeBuffers = function(xres, yres)
{
    for (let i=0; i<this.mMaxBuffers; i++ )
    {
        this.ResizeBuffer(i, xres, yres, true);
    }
}

Effect.prototype.IsEnabledVR = function ()
{
    if (this.mRenderingStereo) return true;
    return false;
}

Effect.prototype.EnableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( this.mRenderingStereo ) return;

    this.mRenderingStereo = true;
    this.mWebVR.Enable();
}

Effect.prototype.DisableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( !this.mRenderingStereo ) return;

    this.mRenderingStereo = false;
    this.mWebVR.Disable();
}

Effect.prototype.GetTexture = function( passid, slot ) { return this.mPasses[passid].GetTexture( slot ); }
Effect.prototype.NewTexture = function (passid, slot, url) { return this.mPasses[passid].NewTexture( this.mAudioContext, slot, url, this.mBuffers, this.mCubeBuffers, this.mKeyboard ); }
Effect.prototype.SetOutputs = function( passid, slot, url ) { this.mPasses[passid].SetOutputs( slot, url ); }
Effect.prototype.SetOutputsByBufferID = function( passid, slot, id ) { this.mPasses[passid].SetOutputsByBufferID( slot, id ); }
Effect.prototype.GetAcceptsLinear = function (passid, slot) { return this.mPasses[passid].GetAcceptsLinear(slot); }
Effect.prototype.GetAcceptsMipmapping = function (passid, slot) { return this.mPasses[passid].GetAcceptsMipmapping(slot); }
Effect.prototype.GetAcceptsWrapRepeat = function (passid, slot) { return this.mPasses[passid].GetAcceptsWrapRepeat(slot); }
Effect.prototype.GetAcceptsVFlip = function (passid, slot) { return this.mPasses[passid].GetAcceptsVFlip(slot); }
Effect.prototype.SetSamplerFilter = function (passid, slot, str) { this.mPasses[passid].SetSamplerFilter(slot, str, this.mBuffers, this.mCubeBuffers); }
Effect.prototype.GetTranslatedShaderSource = function (passid) { return this.mPasses[passid].GetTranslatedShaderSource(); }
Effect.prototype.GetSamplerFilter = function (passid, slot) { return this.mPasses[passid].GetSamplerFilter(slot); }
Effect.prototype.SetSamplerWrap = function (passid, slot, str) { this.mPasses[passid].SetSamplerWrap(slot, str, this.mBuffers); }
Effect.prototype.GetSamplerWrap = function (passid, slot) { return this.mPasses[passid].GetSamplerWrap(slot); }
Effect.prototype.SetSamplerVFlip = function (passid, slot, str) { this.mPasses[passid].SetSamplerVFlip(slot, str); }
Effect.prototype.GetSamplerVFlip = function (passid, slot) { return this.mPasses[passid].GetSamplerVFlip(slot); }

Effect.prototype.GetHeaderSize = function (passid)
{
    return this.mPasses[passid].mHeaderLength + 
           this.mRenderer.GetShaderHeaderLines(1);
}

Effect.prototype.ToggleVolume = function()
{
    this.mForceMuted = !this.mForceMuted;

    // outp
    if (this.mForceMuted)
        this.mGainNode.gain.value = 0.0;
    else
        this.mGainNode.gain.value = 1.0;

    // inp
    let num = this.mPasses.length;
    for( let j=0; j<num; j++ )
    {
        for( let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            if( this.mForceMuted )
                this.mPasses[j].MuteInput( this.mAudioContext, i );
            else
                this.mPasses[j].UnMuteInput( this.mAudioContext, i );
        }
    }

    return this.mForceMuted;
}

Effect.prototype.SetKeyDown = function( passid, k )
{
    if( this.mKeyboard.mData[ k + 0*256 ] == 255 ) return;

    this.mKeyboard.mData[ k + 0*256 ] = 255;
    this.mKeyboard.mData[ k + 1*256 ] = 255;
    this.mKeyboard.mData[ k + 2*256 ] = 255 - this.mKeyboard.mData[ k + 2*256 ];
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }
}

Effect.prototype.SetKeyUp = function( passid, k )
{
    this.mKeyboard.mData[ k + 0*256 ] = 0;
    this.mKeyboard.mData[ k + 1*256 ] = 0;
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }
}

Effect.prototype.StopOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].StopOutput( wa );
    }
}

Effect.prototype.ResumeOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].ResumeOutput( wa );
    }
}

Effect.prototype.PauseInput = function( passid, id )
{
    return this.mPasses[passid].TooglePauseInput( this.mAudioContext, id );
}

Effect.prototype.ToggleMuteInput = function( passid, id )
{
    return this.mPasses[passid].ToggleMuteInput( this.mAudioContext, id );
}

Effect.prototype.RewindInput = function( passid, id )
{
    this.mPasses[passid].RewindInput( this.mAudioContext, id );
}

Effect.prototype.UpdateInputs = function( passid, forceUpdate )
{
   this.mPasses[passid].UpdateInputs( this.mAudioContext, forceUpdate, this.mKeyboard );
}

Effect.prototype.ResetTime = function()
{
    this.mFrame = 0;
    this.mAudioContext.resume()

    let num = this.mPasses.length;
    for( let i=0; i<num; i++ )
    {
        this.mPasses[i].mFrame = 0;
        for( let j=0; j<this.mPasses[i].mInputs.length; j++ )
            this.mPasses[i].RewindInput(this.mAudioContext, j)
    }
}

Effect.prototype.RequestAnimationFrame = function (id)
{
    if (this.mRenderingStereo && this.mWebVR.IsPresenting())
    {
        this.mWebVR.RequestAnimationFrame(id);
    }
    else
    {
        requestAnimFrame(id);
    }
}

Effect.prototype.Paint = function(time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, isPaused)
{
    let wa = this.mAudioContext;
    let da = new Date();
    let vrData = null; if (this.mRenderingStereo) vrData = this.mWebVR.GetData();
    let xres = this.mXres / 1;
    let yres = this.mYres / 1;

    if( this.mFrame===0 )
    {
        for( let i=0; i<this.mMaxBuffers; i++ )
        {
            if( this.mBuffers[i].mTexture[0]!==null )
            {
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[0] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[1] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
				
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[0] );
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[1] );
            }
        }
        for( let i=0; i<this.mMaxCubeBuffers; i++ )
        {
            if( this.mCubeBuffers[i].mTexture[0]!==null )
            {
                for( let face=0; face<6; face++ )
                {
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[0], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[1], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
					this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[0] );
				    this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[1] );
                }
            }
        }
    }

    let num = this.mPasses.length;

    // render sound first
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "sound" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "buffer" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;
        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="buffer" && inp.id === bufferID && inp.mInfo.mSampler.filter === "mipmap")
                {
                    needMipMaps = true;
                    break;
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render cubemap buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "cubemap" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = 0;//assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;

        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="cubemap" )
                {
                    if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0 && inp.mInfo.mSampler.filter === "mipmap" )
                    {
                        needMipMaps = true;
                        break;
                    }
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render image last
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "image" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }   

    // erase keypresses
    for (let k=0; k<256; k++ )
    {
       this.mKeyboard.mData[ k + 1*256 ] = 0;
    }
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    if( this.mRenderingStereo ) this.mWebVR.Finish();

    this.mFrame++;
}

Effect.prototype.NewShader = function( passid, preventCache, onResolve )
{
    let commonSourceCodes = [];
    for (let i=0; i<this.mPasses.length; i++ )
    {
        if( this.mPasses[i].mType==="common")
        {
            commonSourceCodes.push(this.mPasses[i].mSource);
        }
    }

    this.mPasses[passid].NewShader(commonSourceCodes, preventCache, onResolve );
}

Effect.prototype.GetNumPasses = function()
{
    return this.mPasses.length;
}

Effect.prototype.GetNumOfType = function(passtype)
{
    let id = 0;
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType===passtype )
        {
            id++;
        }
    }
    return id;
}

Effect.prototype.GetPassType = function( id ) { return this.mPasses[id].mType; }
Effect.prototype.GetPassName = function( id ) { return this.mPasses[id].mName; }
Effect.prototype.GetCode = function( id ) { return this.mPasses[id].mSource; }
Effect.prototype.SetCode = function( id, source ) { this.mPasses[id].SetCode(source); }
Effect.prototype.GetError = function (id) { return this.mPasses[id].mError; }
Effect.prototype.GetErrorStr = function (id) { return this.mPasses[id].mErrorStr; }
Effect.prototype.GetErrorGlobal = function()
{
    for (let i = 0; i < this.mPasses.length; i++)
    {
        if (this.mPasses[i].mError)
        {
            return true;
        }
    }
    return false;
}

Effect.prototype.Load = function (jobj )
{
    if (jobj.ver !== "0.1")
    {
        console.log("Wrong Format");
        return false;
    }

    let numPasses = jobj.renderpass.length;

    if( numPasses<1 || numPasses>this.mMaxPasses )
    {
        console.log("Corrupted Shader - " + numPasses);
        return false;
    }

    this.mPasses = [];
    for (let j = 0; j < numPasses; j++)
    {
        let rpass = jobj.renderpass[j];

        // skip sound passes if in thumbnail mode
        if( this.mForceMuted && rpass.type === "sound" ) continue;

        let wpass = new EffectPass(this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                   this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode,
                                   this.mProgramDownscale, j, this);

        wpass.Create(rpass.type, this.mAudioContext);

        let numInputs = rpass.inputs.length;

        for (let i = 0; i < 4; i++)
        {
            wpass.NewTexture(this.mAudioContext, i, null, null, null);
        }
        for (let i = 0; i < numInputs; i++)
        {
            let lid  = rpass.inputs[i].channel;
            let styp = rpass.inputs[i].type;
            let sid  = rpass.inputs[i].id;
            let ssrc = rpass.inputs[i].filepath;
            let psrc = rpass.inputs[i].previewfilepath;
            let samp = rpass.inputs[i].sampler;

            wpass.NewTexture(this.mAudioContext, lid, { mType: styp, mID: sid, mSrc: ssrc, mSampler: samp, mPreviewSrc: psrc }, this.mBuffers, this.mCubeBuffers, this.mKeyboard);
        }

        for (let i = 0; i < 4; i++)
        {
            wpass.SetOutputs(i, null);
        }

        let numOutputs = rpass.outputs.length;
        for (let i = 0; i < numOutputs; i++)
        {
            let outputID = rpass.outputs[i].id;
            let outputCH = rpass.outputs[i].channel;
            wpass.SetOutputs(outputCH, outputID);
        }

        // create some hardcoded names. This should come from the DB
        let rpassName = "";
        if (rpass.type === "common" ) rpassName = "Common";
        if (rpass.type === "sound"  ) rpassName = "Sound";
        if (rpass.type === "image"  ) rpassName = "Image";
        if (rpass.type === "buffer") rpassName = "Buffer " + String.fromCharCode(65 + assetID_to_bufferID(wpass.mOutputs[0]));
        if (rpass.type === "cubemap") rpassName = "Cube A";// " + String.fromCharCode(65 + assetID_to_bufferID(this.mPasses[j].mOutputs[0]));
        wpass.SetName(rpassName);
        wpass.SetCode(rpass.code);

        this.mPasses.push(wpass);
    }
    return true;
}

Effect.prototype.CompileSome = function ( passes, preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    for (let j = 0; j < passes.length; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(passes[j], preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < me.mPasses.length; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.Compile = function (preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(j, preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < numPasses; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.GetCompilationTime = function( id )
{
    return this.mPasses[id].GetCompilationTime()/1000.0;
}
Effect.prototype.GetTotalCompilationTime = function()
{
    return this.mCompilationTime/1000.0;
}

Effect.prototype.DestroyPass = function( id )
{
   this.mPasses[id].Destroy( this.mAudioContext );
   this.mPasses.splice(id, 1);
}

Effect.prototype.AddPass = function( passType, passName, onResolve )
{
    let shaderStr = null;

    if( passType==="sound"   ) shaderStr = "vec2 mainSound( int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n}";
    if( passType==="buffer"  ) shaderStr = "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}";
    if( passType==="common"  ) shaderStr = "vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}";
    if( passType==="cubemap" ) shaderStr = "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rayDir;\n\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}";

    let id = this.GetNumPasses();
    this.mPasses[id] = new EffectPass( this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                       this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode, 
                                       this.mProgramDownscale, id, this );

    this.mPasses[id].Create( passType, this.mAudioContext );
    this.mPasses[id].SetName( passName );
    this.mPasses[id].SetCode( shaderStr );
    this.NewShader(id, false, function ()
    {
        onResolve();
    });

    return { mId : id, mShader : shaderStr };
}

// this should be removed once we have MultiPass 2.0 and passes render to arbitrary buffers
Effect.prototype.IsBufferPassUsed = function( bufferID )
{
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType !== "buffer" ) continue;
        if( this.mPasses[j].mOutputs[0] === bufferID_to_assetID(bufferID) ) return true;
    }
    return false;
}

Effect.prototype.Save = function()
{
    var result = {};

    result.ver = "0.1";

    result.renderpass = [];

    let numPasses = this.mPasses.length;
    for (let j=0; j<numPasses; j++ )
    {
        result.renderpass[j] = {};

        result.renderpass[j].outputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            let outputID = this.mPasses[j].mOutputs[i];
            if( outputID===null ) continue;
            result.renderpass[j].outputs.push( { channel: i, id: outputID } );
        }
        result.renderpass[j].inputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            if( this.mPasses[j].mInputs[i]===null ) continue;
            result.renderpass[j].inputs.push( {channel: i,
                                               type    : this.mPasses[j].mInputs[i].mInfo.mType,
                                               id      : this.mPasses[j].mInputs[i].mInfo.mID,
                                               filepath: this.mPasses[j].mInputs[i].mInfo.mSrc,
                                               sampler : this.mPasses[j].mInputs[i].mInfo.mSampler });
        }

        result.renderpass[j].code = this.mPasses[j].mSource;
        result.renderpass[j].name = this.mPasses[j].mName
        result.renderpass[j].description = "";
        result.renderpass[j].type = this.mPasses[j].mType;
    }

    result.flags = this.calcFlags();

    return result;
}

Effect.prototype.calcFlags = function ()
{
    let flagVR = false;
    let flagWebcam = false;
    let flagSoundInput = false;
    let flagSoundOutput = false;
    let flagKeyboard = false;
    let flagMultipass = false;
    let flagMusicStream = false;

    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        let pass = this.mPasses[j];

        if (pass.mType === "sound") flagSoundOutput = true;
        if (pass.mType === "buffer") flagMultipass = true;

        for (let i = 0; i < 4; i++)
        {
            if (pass.mInputs[i] === null) continue;

            if (pass.mInputs[i].mInfo.mType === "webcam") flagWebcam = true;
            else if (pass.mInputs[i].mInfo.mType === "keyboard") flagKeyboard = true;
            else if (pass.mInputs[i].mInfo.mType === "mic") flagSoundInput = true;
            else if (pass.mInputs[i].mInfo.mType === "musicstream") flagMusicStream = true;
        }

        let n1 = pass.mSource.indexOf("mainVR(");
        let n2 = pass.mSource.indexOf("mainVR (");
        if (n1 > 0 || n2 > 0) flagVR = true;
    }

    return {
        mFlagVR: flagVR,
        mFlagWebcam: flagWebcam,
        mFlagSoundInput: flagSoundInput,
        mFlagSoundOutput: flagSoundOutput,
        mFlagKeyboard: flagKeyboard,
        mFlagMultipass: flagMultipass,
        mFlagMusicStream: flagMusicStream
    };
}</script>
    <script>"use strict"

const kMaxCompileTime = 10.0;

function iReportCrash(shaderID)
{
    let req = new XMLHttpRequest();
    req.onload = function ()
    {
        let jsn = req.response;
        if (jsn === null) return;
        if (jsn.result === 0)
        {
            // yep
        }
    };
    req.open("POST", "/shadertoy", true);
    req.responseType = "json";
    req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    req.send( "s=" + shaderID + "&r=2" );
}
</script>
    <script>"use strict"

var gActive = -1;
var mShaders = [];
var gNumCanvases = 0;

function myrefresh( id, slot, img, forceFrame, gui, guiID, renderID, time )
{
    if( mShaders[id].mReady===false ) return;
    if( forceFrame )
    {
        if (mShaders[id].mScreenshot === false)
        {
            mShaders[id].gEffect.Paint(mShaders[id].mTime / 1000.0, 1.0 / 60.0, 60.0, 0, 0, 0, 0, false);
        }
    }
}

function startRendering()
{
    if( gActive<0 ) return;
    if( mShaders[gActive].mReady===false ) return;
    if( mShaders[gActive].mScreenshot===true ) return;

    let time = getRealTime();

    mShaders[gActive].mFPS.Count( time );
    mShaders[gActive].mTime = mShaders[gActive].mTime0 + (time - mShaders[gActive].mTo);
    let dtime = 1000.0/60.0;
    mShaders[gActive].gEffect.Paint( mShaders[gActive].mTime/1000.0, dtime/1000.0, mShaders[gActive].mFPS.GetFPS(), 0,0,0,0, false);

    requestAnimFrame( startRendering );
}

function iLoadAndCompile(jsn, i )
{
    var shaderObj = jsn[i];
    if (shaderObj === null) return;

    var resizeCB = function (xres, yres) { myrefresh(i, 0, null, true, false, 0, -1.0) };
    var crashCB = function () { alert('crash');/*iReportCrash(gShaderIDs[i])*/ };
    mShaders[i].gEffect = new Effect(null, null, mShaders[i].mPreview.mCanvas, myrefresh, i, true, true, resizeCB, crashCB);

    if (!mShaders[i].gEffect.Load(shaderObj)) return;

    mShaders[i].gEffect.Compile(false, function (worked)
    {
        if (worked === true)
        {
            previewShowRender(mShaders[i].mPreview);

            mShaders[i].mScreenshot = false;
            mShaders[i].mReady = true;
            mShaders[i].mTime = 10.0 * 1000.0;
            mShaders[i].mTime0 = 0.0;
            mShaders[i].mTo = 0.0;
            mShaders[i].mFPS = piCreateFPSCounter();
            mShaders[i].mPreview.mCanvas.addEventListener("mouseout", function (ev) { gActive = -1; }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseover", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.add('isVisible'); }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseout", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.remove('isVisible'); }, true);
            mShaders[i].mPreview.mCanvas.addEventListener("mouseover", function (ev)
            {
                let ele = piGetSourceElement(ev);
                if (ele.mId === undefined) return;

                gActive = ele.mId;
                if (!mShaders[gActive].mReady) return;
                let time = getRealTime();
                mShaders[gActive].mTo = time;
                mShaders[gActive].mTime0 = mShaders[gActive].mTime;
                mShaders[gActive].mFPS.Reset(time);

                startRendering();
            }, true);


            /*
            let compilationTime = mShaders[i].gEffect.GetTotalCompilationTime();
            if (compilationTime > kMaxCompileTime)
            {
                iReportCrash(mShaders[i].mShaderID);
            }*/

            myrefresh(i, null, null, true, false, 0, -1.0);
        }
        else
        {
            mShaders[i].mReady = false;
            previewShowError(mShaders[i].mPreview);
        }
    });
};


function iProcessShader( jsn, i )
{
    var shaderObj = jsn[i];
    if( shaderObj===null ) return;

    if ((shaderObj.info.usePreview === 0 && !gUseScreenshots) || (mShaders[i].mPreviewReady !== 1))
    {
        iLoadAndCompile(jsn, i);
    }
    else
    {
        mShaders[i].mScreenshot = true;
        if( shaderObj.info.usePreview === 1 )
            previewShowScreenshot(mShaders[i].mPreview, 1); // comp
        else if (gUseScreenshots)
            previewShowScreenshot(mShaders[i].mPreview, 2); // sett
    }

    if( i<(jsn.length-1) ) setTimeout( function(){iProcessShader(jsn,i+1);}, 10 );
}

function iInitUI(numCanvases, uiCallback, windowTitle)
{
    gNumCanvases = numCanvases;
    document.getElementById("mySearch").focus();

    //-----------------------------------------------------------------
    // window
    //-----------------------------------------------------------------
    if (windowTitle !== null) {
        document.title = windowTitle;
    }

    //-----------------------------------------------------------------
    // ui
    //-----------------------------------------------------------------
    var num = Math.min(gShaders.length, gNumCanvases);

    //var base = document.getElementsByClassName( "searchResult" );

    for (let i = 0; i < gNumCanvases; i++)
    {
        let pv = createPreview(i);

        if (i >= num) {
            previewHide(pv);
            continue;
        }

        let shaderID = gShaders[i].info.id;
        
        if (pv.mUI !== null && uiCallback !== null) {
            pv.mUI.addEventListener('click', function (ev) {
                uiCallback(shaderID);
                ev.preventDefault();
            }, false);
        }
        
        previewShowLoading(pv);
        
        mShaders[i] = {};
        mShaders[i].mShaderID = shaderID;
        mShaders[i].mPreview = pv;
        mShaders[i].mScreenshot = false;
        mShaders[i].mPreview.mLink.href = "/view/" + shaderID;
        mShaders[i].mPreviewReady = 0;
        mShaders[i].mReady = false;
        mShaders[i].gEffect = null;

        previewLoadScreenshot(mShaders[i].mPreview,
            function () { mShaders[i].mPreviewReady = 1; if (mShaders[i].mReady === false) previewShowScreenshot(mShaders[i].mPreview, 0); },
            function () { mShaders[i].mPreviewReady = 2; },
            shaderID);
    }

    if (num <= 0) {
        return;
    }
}

function iInitShaders(jsn)
{
    for (let i = 0; i < jsn.length; i++)
    {
        let shaderObj = jsn[i];
        if (shaderObj === null) continue;
        let inf = shaderObj.info;
        mShaders[i].mPreview.mTextA.textContent = inf.name;
        mShaders[i].mPreview.mTextB.innerHTML = "<a class='user' href='/user/" + htmlEntities(inf.username) + "'>" + htmlEntities(inf.username) + "</a>";
        mShaders[i].mPreview.mTextC.innerHTML = "<img src='/img/themes/" + gThemeName + "/views.png' class='viewsIcon'></img>" + inf.viewed + "    &nbsp;&nbsp;  <img src='/img/themes/" + gThemeName + "/likes.png' class='likesIcon'></img>" + inf.likes;
    }

    setTimeout(function () { iProcessShader(jsn, 0); }, 10);
}

function resultsInitStatic(numCanvases, uiCallback, windowTitle)
{
    iInitUI(numCanvases, uiCallback, windowTitle);

    iInitShaders(gShaders);
}

function resultsInit(numCanvases, uiCallback, windowTitle)
{	
    iInitUI(numCanvases, uiCallback, windowTitle);

    var num = Math.min(gShaderIDs.length, gNumCanvases);

    var mHttpReq = new XMLHttpRequest();

    mHttpReq.abort();

    var str = "{ \"shaders\" : [";
    for( let i=0; i<num; i++ )
    {
         str += "\"" + gShaderIDs[i] + "\"";
         if( i!==(num-1) ) str += ", ";
    }
    str += "] }";

    str = "s=" + encodeURIComponent( str ) + "&nt=0&nl=0&np=0";

    mHttpReq.open( "POST", "/shadertoy", true );
    mHttpReq.responseType = "json";
    mHttpReq.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    mHttpReq.onload = function ()
    {
        let jsn = this.response;
        if( jsn===null )
        {
            console.log( "Could not load shaders" );
            return;
        }

        iInitShaders(jsn);
    }
    mHttpReq.send( str );
}</script>
    <style>
    .shaderPreview
    {
    display: block;
    background-color: #000000;
    background-image: url("/img/loading.gif");
    background-repeat: no-repeat;
    background-position: center;
    padding: 0px;
    margin: 0px;
    border: 0px solid #000000;
    border-radius: 8px;
    width:100%;
    height:100%;
    position: absolute;
    overflow:hidden;
    }

    .previewInfo
    {
    width: 100%;
    left: 0px;
    top: 2px;
    position: relative;
    visibility: hidden;
    }

    .previewCanvas
    {
    left: 0px;
    top: 0px;
    padding: 0px;
    margin: 0px;
    position: absolute;
    cursor: pointer;
    width:100%;
    height:100%;
    border-radius: 8px;
    border: 0px solid #000000;
    backgroundColor: transparent;
visibility: hidden;
opacity:0;
transition: opacity 1.0s ease;
    }

    .previewText
    {
        text-overflow: ellipsis;
    white-space: nowrap;
    padding-right: 1px;
    }

    .previewTextUser
    {
    text-overflow: ellipsis;
    white-space: nowrap;
    padding-left: 3px;
    }

    .previewStats
    {
    padding-right: 1px;
    right: 0px;
    top: 0px;
    position: absolute;
    }

    .previewErrorContainer
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    visibility:hidden;
    }

    .previewErrorMessage
    {
    top:50%;
    position:absolute;
    width:100%;
    text-align:center;
    padding:0;
    margin:auto;
    color:#ff0000;
    font-size:2em;
    font-style:italic;
    }

    .previewNoGLContainter
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    position:absolute;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    pointer-events:none;
    visibility:hidden;
    font-size:2em;
    }

    .previewNoGLMessage
    {
    width:86%;
    height:90%;
    padding-left:7%;
    padding-right:7%;
    padding-top:10%;
    padding-bottom:0px;
    color:#ff0000;
    position:absolute;
    visibility:hidden;
    }

    .previewThumbnailContainer
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    visibility:hidden;
    border-radius:8px;
    border:0px solid #000000;
    }

    .previewThumbnailImage
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    border-radius:8px;
    border:0px solid #000000;
opacity: 0.0;
transition: opacity 1.0s ease;
    }

    .previewThumbnailIcon
    {
    width:64px;
    height:32px;
    left:0px;
    top:0px;
    padding:0px;
    padding-top:12px;
    margin:0px;
    position:absolute;
    color:#ffffff;
    background-color:#ff8020;
    font-weight:bold;
    border-radius:0px 0px 8px 0px;
    text-align:center;
    //visibility:hidden;
    }


    .previewUIContainter
    {
    display: block;
    right:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    //cursor:pointer;
    //pointer-events:none;
    //visibility:hidden;
    }
</style>

<script>
    function previewHide(me)
    {
    me.mBase.style.visibility = "hidden";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";
    }

    function previewShowRender(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "visible";
me.mCanvas.style.opacity = 1.0;
    me.mCanvas.style.borderRadius ="8px;";
//  me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    }

    function previewShowScreenshot(me, message)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "visible";
me.mThumbnailImg.style.opacity = 1.0;
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    me.mThumbnailWar1.style.visibility = (message===1)?"visible":"hidden";
    me.mThumbnailWar2.style.visibility = (message===2)?"visible":"hidden";
    }

    function previewShowLoading(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";

    me.mLink.style.visibility = "visible";
    me.mBase.style.backgroundColor = "#ff0000;"
    me.mCont.style.visibility = "visible";
    }

    function previewShowNoWebGL(me, shaderID)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "visible";
    me.mError.style.visibility = "visible";
    me.mThumbnailImgNoWebGL.onerror = function(ev) 
                                      { 
                                            me.mThumbnailImgNoWebGL.style.visibility="hidden"; 
                                            me.mMessageNoWebGL.style.visibility="visible"; 
                                      };
    me.mThumbnailImgNoWebGL.src = "/media/shaders/" + shaderID + ".jpg";
    }

    function previewShowError(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "visible";
    me.mCont.style.visibility = "visible";
    }

    function previewLoadScreenshot( me, cbSuccess, cbError, shaderID )
    {
    var url = "/media/shaders/" + shaderID + ".jpg";
    me.mThumbnailImg.onload = cbSuccess;
    me.mThumbnailImg.onerror = function(ev) { cbError(); };
    me.mThumbnailImg.src = url;
    }
        
    function createPreview(id)
    {
        var bar = document.getElementById( "Preview_"+id+"_Canvas" );
        bar.width = bar.offsetWidth;
        bar.height = bar.offsetHeight;
        bar.mId = id;

        return { mBase: document.getElementById( "Preview_"+id+"_Container" ),
        mLink: document.getElementById( "Preview_"+id+"_Link" ),
        mCanvas: bar,
        mCont: document.getElementById( "Preview_"+id+"_Info" ),
        mTextA: document.getElementById( "Preview_"+id+"_Text" ),
        mTextB: document.getElementById( "Preview_"+id+"_TextUser" ),
        mTextC: document.getElementById( "Preview_"+id+"_Stats" ),
        mNoWebGL: document.getElementById( "Preview_"+id+"_NoWebGL" ),
        mError: document.getElementById( "Preview_"+id+"_Error" ),
        mCanvas2D: document.getElementById( "Preview_"+id+"_Thumnail" ),
        mThumbnailImg: document.getElementById( "Preview_"+id+"_ThumnailImage" ),
        mThumbnailWar1: document.getElementById( "Preview_"+id+"_ThumnailWarning1" ),
        mThumbnailWar2: document.getElementById( "Preview_"+id+"_ThumnailWarning2" ),
        mThumbnailImgNoWebGL: document.getElementById( "Preview_"+id+"_ThumnailImageNoWebGL" ),
        mMessageNoWebGL: document.getElementById( "Preview_"+id+"_MessageNoWebGL"),
        mUI: document.getElementById( "Preview_"+id+"_UI" )
        };
    }
</script>

    <style>

    div#shaderGrid
    {
        width:100%;
        padding:0px;
        margin:0px;
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        grid-template-rows: repeat(3, 1fr);
        grid-column-gap: 64px;
        grid-row-gap: 24px;
    }
    .searchResult
    {
        margin: 0px;
        padding: 0px;
        width: 100%;
    }
    .searchResultContainer
    {
        width: 100%;
        padding-bottom:56.25%;
        height: 0;
        position: relative;
    }
    .navigation
    {
        display:flex;
        align-items:center;
    }
    div#navBottom
    {
        display:none;
        justify-content:center;
    }
    a.pageButtons, .pageButtonsCurrent
    {
        border-style: solid;
        border-width: 1px;
        border-color: #808080;
        text-align: center;
        vertical-align: middle;
        margin-left: 12px;
        display: inline-block;
        border-radius: 4px;
		font-weight:bold;
        cursor: pointer;
        padding-bottom:5px;
        padding-top:4px;
        padding-left: 8px;
        padding-right: 8px;
        margin:8px;
    }
    a.pageButtons
    {
        text-decoration: none;
        -moz-transition:    background-color 0.15s linear, color 0.15s linear;
        -webkit-transition: background-color 0.15s linear, color 0.15s linear;
        transition:         background-color 0.15s linear, color 0.15s linear;
    }
    a.pageButtons:hover
    {
      background-color:#808080;
      color : #ff8020;
    }
    .pageButtonsCurrent
    {
        background-color: #808080;
        color:#000000;
    }
    div#controls
    {
        width:100%;
        padding-top:16px;
        padding-bottom:16px;
        display:flex;
        justify-content:space-between; 
        flex-wrap:wrap;
    }
    div#controls > div
    {
        display:inline-flex;
    }
    .controlOptions
    {
        display:inline-block;
    }

    /* ----------------------- media resolutions ------------------------ */

    @media screen and (max-width:799px) 
    {
        div#shaderGrid  { grid-template-columns: 1fr; grid-template-rows: repeat(12, 1fr); grid-column-gap: 0px; grid-row-gap: 16px; }
        div#controls
        {
            width:100%;
            display:flex;
            justify-content:flex-start; 
            flex-wrap:wrap;
        }
        div#controls > div
        {
            display:inline-flex;
            width:100%;
            margin-left: 0px;
            margin-right: 0px;
            padding-bottom:16px;
        }
        div#navBottom
        {
            display: flex;
        }
    }
    
    </style>
    <script>
    var gShaders=[{"ver":"0.1","info":{"id":"lsKGDW","date":"1455757091","viewed":21995,"name":"oilArt","username":"and","description":"Image encoded in mp3 audio stream.\nOriginal painting by Leonid Afremov.\nSpecial thanks to Inna Cherneykina for \"brush\" choreography.","likes":363,"published":1,"flags":96,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ oilArt - Image\n\/\/\n\/\/ Final shader in the pipeline. Draw thumbnail when resolution is too small\n\/\/ or when in sort of preview mode. Fit image to avoid cropping.\n\/\/ Increase sharpness and additionally refine edges without introducing ringing.\n\/\/ Render decoder's internal state for debugging.\n\/\/ \n\/\/ Created by Dmitry Andreev - and'2016\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define DO_SHARPEN       1\n#define DO_OILIFY        1\n\n#define DEBUG_DECODER    0\n#define DEBUG_SAMPLERATE 0\n\n\/\/\n\nvoid drawThumbnail(out vec4 fragColor, in vec2 fragCoord)\n{\n    \/\/ 3rd order 2D polynomial.\n\n    vec3 c0  = vec3(  0.94,  0.70,  0.43);\n    vec3 c1  = vec3(  0.41,  0.52, -0.06);\n    vec3 c2  = vec3( -1.39, -0.94,  2.21);\n    vec3 c3  = vec3(  0.78,  0.51, -1.62);\n    vec3 c4  = vec3( -0.75, -0.96, -0.79);\n    vec3 c5  = vec3(  6.46, 10.74,  1.49);\n    vec3 c6  = vec3(-11.55,-21.27, -0.07);\n    vec3 c7  = vec3(  5.77, 11.48, -0.64);\n    vec3 c8  = vec3(  1.14,  1.16,  3.35);\n    vec3 c9  = vec3(-11.94,-22.10,-14.41);\n    vec3 c10 = vec3( 23.46, 48.26, 21.20);\n    vec3 c11 = vec3(-12.36,-27.09,-10.25);\n    vec3 c12 = vec3( -0.70, -0.62, -2.90);\n    vec3 c13 = vec3(  5.93, 12.16, 14.62);\n    vec3 c14 = vec3(-11.05,-26.58,-24.21);\n    vec3 c15 = vec3(  5.60, 14.77, 12.52);\n\n    vec2  t = floor(fragCoord \/ 12.0) * 12.0 \/ iResolution.xy;\n    float x = t.x;\n    float y = 1.0 - t.y;\n\n    vec3 f = vec3(\n           ( c0 + ( c1 + ( c2 +  c3*x)*x)*x) +\n        y*(( c4 + ( c5 + ( c6 +  c7*x)*x)*x) +\n        y*(( c8 + ( c9 + (c10 + c11*x)*x)*x) +\n        y*( c12 + (c13 + (c14 + c15*x)*x)*x))));\n\n    vec3 clr = smoothstep(0.0, 1.0, f*f*f*f);\n\n    \/\/ Playback triangle.\n\n    vec2 tc = fragCoord \/ iResolution.xy;\n    vec2 p = 1.5 * (tc - 0.5) * vec2(1.0, iResolution.y \/ iResolution.x);\n    float d = length( p );\n\n    clr = mix(clr, vec3(0), 0.6 * clamp(23.0 - 128.0 * d, 0.0, 1.0));\n    clr = mix(clr, vec3(1), clamp(3.0 - 128.0 * abs(0.5 - d * 3.0), 0.0, 1.0));\n\n    p *= 1.5;\n    p += vec2(0.06, 0);\n\n    float m = dot(p, vec2(2.0, 0.0));\n    m = min(m, dot(p + vec2(0.0, 0.15), vec2(-0.8, 1.0)));\n    m = min(m, dot(p + vec2(0.0,-0.15), vec2(-0.8,-1.0)));\n    m = max(m, 0.0);\n\n    fragColor.rgb = mix(clr, vec3(1.0), vec3(m * 200.0));\n}\n\nvoid oilify3(inout vec2 h[16], float d, vec2 tc, vec2 tc_max)\n{\n    vec3 c = texture(iChannel1, min(tc \/ iResolution.xy, tc_max)).rgb;\n\n    float luma = dot(c, vec3(0.33));\n    float L = floor(0.5 + luma * 15.0 + d);\n\n    #define H(n) h[n] += L == float(n) ? vec2(luma, 1) : vec2(0);\n\n    H(0)H(1)H(2)H(3)H(4)H(5)H(6)H(7)\n    H(8)H(9)H(10)H(11)H(12)H(13)H(14)H(15)\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (iResolution.x < 500.0 || iResolution.y < 280.0)\n    {\n        drawThumbnail(fragColor, fragCoord);\n        return;\n    }\n\n    \/\/ Fit image to touch screen from inside.\n\n    vec2 img_res = vec2(496, 279);\n    vec2 res = iResolution.xy \/ img_res;\n    vec2 img_size = img_res * min(res.x, res.y);\n    vec2 img_org = 0.5 * (iResolution.xy - img_size);\n    vec2 tc = (fragCoord - img_org) \/ img_size;\n\n    fragColor = texture(iChannel1, tc * img_res \/ iResolution.xy);\n\n    #if DO_SHARPEN\n    {\n        \/\/ Regular high-pass filter to recover some sharpness.\n\n        fragColor *= 8.0;\n        fragColor -= texture(iChannel1, min((tc * img_res + vec2( 1,0)) \/ iResolution.xy, vec2(img_res) \/ iChannelResolution[1].xy));\n        fragColor -= texture(iChannel1, min((tc * img_res + vec2(-1,0)) \/ iResolution.xy, vec2(img_res) \/ iChannelResolution[1].xy));\n        fragColor -= texture(iChannel1, min((tc * img_res + vec2(0, 1)) \/ iResolution.xy, vec2(img_res) \/ iChannelResolution[1].xy));\n        fragColor -= texture(iChannel1, min((tc * img_res + vec2(0,-1)) \/ iResolution.xy, vec2(img_res) \/ iChannelResolution[1].xy));\n        fragColor *= 0.25;\n    }\n    #endif\n\n    #if DO_OILIFY\n    {\n        \/\/ Additinal edge sharpening assuming it is a painting.\n        \/\/ Effect similar to GIMP's Oilify.\n        \/\/ Calculate 16 bin histogram for 3x3 neighborhood\n        \/\/ and pick averaged color of bin that had most pixels.\n\n        vec2 h[16];\n\n        for (int i = 0; i < 16; i++) h[i] = vec2(0);\n\n        \/\/ Add some noise to hide low bin count.\n\n        float d = 0.5 * texture(iChannel2, 0.95 * fragCoord \/ iChannelResolution[2].xy).x;\n\n        for (int y = -1; y <= 1; y++)\n        {\n            oilify3(h, d, tc * img_res + vec2(-1, y), img_res \/ iChannelResolution[1].xy);\n            oilify3(h, d, tc * img_res + vec2( 0, y), img_res \/ iChannelResolution[1].xy);\n            oilify3(h, d, tc * img_res + vec2( 1, y), img_res \/ iChannelResolution[1].xy);\n        }\n\n        vec2 q = vec2(0);\n\n        #define Q(n) q = h[n].y > q.y ? h[n] : q;\n\n        Q(0)Q(1)Q(2)Q(3)\n        Q(4)Q(5)Q(6)Q(7)\n        Q(8)Q(9)Q(10)Q(11)\n        Q(12)Q(13)Q(14)Q(15)\n\n        vec4 org = texture(iChannel1, tc * img_res \/ iResolution.xy);\n        float luma = dot(org.rgb, vec3(0.33));\n        vec3 clr = org.rgb - luma + q.x \/ q.y;\n\n        fragColor.rgb = mix(fragColor.rgb, clr.rgb, 0.3);\n\n        float emb =\n            texture(iChannel2, 0.95 * (fragCoord + vec2(0.5, -0.5)) \/ iChannelResolution[2].xy).x -\n            texture(iChannel2, 0.95 * (fragCoord - vec2(0.5, -0.5)) \/ iChannelResolution[2].xy).x;\n\n        fragColor.rgb *= 0.95 + 0.20 * d + 0.1 * emb;\n    }\n    #endif\n\n    \/\/ Add black bars around the image when needed.\n\n    fragColor = any(greaterThan(abs(tc - 0.5), vec2(0.5))) ? vec4(0) : fragColor;\n\n    #if DEBUG_DECODER\n    {\n        fragColor = texture(iChannel0, fragCoord.xy \/ iResolution.xy);\n        if (all(equal(fragColor, vec4(0)))) fragColor = vec4(0.5,0,0,0);\n    }\n    #endif\n\n    #if DEBUG_SAMPLERATE\n    {\n        if (fragCoord.x > iResolution.x - 5.0)\n        {\n            float n = texture(iChannel0, vec2(0.5, 1.5) \/ iChannelResolution[0].xy).w;\n            fragColor.xyz = mix(fragColor.xyz, vec3(1,0,0), 0.5 * float(fragCoord.y < n * 20.0));\n            fragColor.xyz = mix(fragColor.xyz, vec3(1,0,0), pow(fract(fragCoord.y \/ 20.0), 8.0));\n        }\n    }\n    #endif\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dfGD4","filepath":"https:\/\/soundcloud.com\/user-470401467\/st-image-2e","previewfilepath":"https:\/\/soundcloud.com\/user-470401467\/st-image-2e","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ oilArt - Buf A\/B\n\/\/\n\/\/ Main audio decoder.\n\/\/ Buf B is redundant and runs the same code as Buf A but reads slightly delayed\n\/\/ audio stream to increase reliability when FPS drops or high sample rate is used.\n\/\/\n\/\/ Audio stream is made up of 160 samples long packets that come in buckets of 6\n\/\/ packets in a row needed to have stable frequency content within ~1000 sample wide\n\/\/ window to minimize frequency masking during mp3 compression. Though SoundCloud\n\/\/ is streaming 128 kBps mp3 @ 44.1 kHz, in reality its closer to FM radio quality\n\/\/ with 32 kHz sample rate. Thus out of 80 available frequency bands only 61 are used.\n\/\/ \n\/\/ Shadertoy reads content of web audio analyzer node and clamps input buffer to 512.\n\/\/ Having 6x packet redundancy helps to remedy that as well. Additionally, some\n\/\/ browsers like Firefox do some funky stuff to that buffer applying some pinching\n\/\/ effect around some buffer boundaries once in a while making some packets unusable.\n\/\/\n\/\/ Out of 61 frequency bands fundamental (carrier) is used for packet location,\n\/\/ 4 bands are used to encode block location within the image using quantized phase,\n\/\/ Then 48 DCT luminance coefficients are interleaved with 8 chrominance coefficients\n\/\/ representing final 496x280 image plane that gets processed further.\n\/\/\n\/\/ Currently, Shadertoy doesn't provide any access to current web audio sample rate.\n\/\/ iSampleRate doesn't work correctly. To solve that a pilot tone is provided\n\/\/ in the beginning of the stream, its period is measured and standard sample rates\n\/\/ are deduced. Supported rates are 44.1, 48, 88.2, 96 kHz.\n\/\/\n\/\/ The best case is 44.1 kHz @ 60 fps. When fps drops or sample rate increased then\n\/\/ we will receive fewer packets and more sparsely. That takes more stream runs\n\/\/ for image to form. Meanwhile, missing block reconstruction is performed.\n\/\/\n\/\/ Created by Dmitry Andreev - and'2016\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define PI 3.14159265\n\n#define BUFFER_SIZE 500\n#define PACKET_SIZE 160\n#define RESAMPLE_WINDOW_RADIUS 7\n\n#define DO_MINIMIZE_ERROR 1\n\n\/\/ Fourier transform utilities.\n\nstruct FFTBand\n{\n    vec2 di;\n    vec2 df;\n    vec2 f;\n};\n\nFFTBand FFTBand_create(const float n, const int fft_size)\n{\n    FFTBand band;\n\n    float fi = (float(n) \/ float(fft_size \/ 2)) * float(fft_size) * 0.5;\n    float angle = 2.0 * PI * fi \/ float(fft_size);\n\n    band.di = vec2(cos(angle), sin(angle));\n    band.df = vec2(1.0 \/ float(fft_size), 0.0);\n    band.f  = vec2(0.0, 0.0);\n\n    return band;\n}\n\nvoid FFTBand_update(inout FFTBand band, float value)\n{\n    band.f += band.df * value;\n    band.df = vec2(\n        band.df.x * band.di.x - band.df.y * band.di.y,\n        band.df.y * band.di.x + band.df.x * band.di.y\n        );\n}\n\nfloat FFTBand_amplitude(FFTBand band)\n{\n    return length(band.f);\n}\n\nfloat FFTBand_angle(FFTBand band)\n{\n    return degrees(atan(band.f.y, band.f.x));\n}\n\n\/\/ Additional helpers.\n\nfloat decodePhase(float x)\n{\n    return mod(111.0 - x, 360.0) - 20.0;\n}\n\nfloat angDiff(float a, float b)\n{\n    return mod(a - b + 180.0, 360.0) - 180.0;\n}\n\nfloat windowedSinc(float x, float radius)\n{\n    float w = abs(x) < 0.001 ? 1.0 : sin(PI * x) \/ (PI * x);\n\n    \/\/ Zero-phase Hamming window\n    w *= 0.54 + 0.46 * cos(PI * x \/ radius);\n\n    return w;\n}\n\nvec4 loadSelf(int x, int y)\n{\n    return textureLod(iChannel1, (vec2(x, y) + 0.5) \/ iChannelResolution[1].xy, 0.0);\n}\n\n\/\/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    \/\/ Discard everything outside of working area\n    \/\/ to increase performance.\n\n    if (any(greaterThan(fragCoord, vec2(500, 280-60)))) discard;\n\n    vec2 pos = floor(fragCoord);\n    vec2 last_pos = pos;\n    bool is_expecting_data  = iChannelTime[0] > 1.5;\n    bool is_expecting_pilot = iChannelTime[0] > 1.1 && iChannelTime[0] < 1.5;\n\n    \/\/ Propagate decoded data down the pipeline during reduction.\n\n    last_pos.y -=\n           (56.0 <= pos.y && pos.y < 56.0 + 16.0)\n        || (40.0 <= pos.y && pos.y < 40.0 + 16.0)\n        || (24.0 <= pos.y && pos.y < 24.0 + 16.0)\n        ?\n        16.0 : 0.0;\n\n    vec4 last_color = loadSelf(int(last_pos.x), int(last_pos.y));\n\n    fragColor = last_color;\n\n    \/\/ Read detected sample rate.\n\n    float sample_rate_index = floor(0.5 + loadSelf(0, 1).w);\n    float sample_rate_khz = 44.1;\n\n    sample_rate_khz = sample_rate_index == 2.0 ? 48.0 : sample_rate_khz;\n    sample_rate_khz = sample_rate_index == 3.0 ? 88.2 : sample_rate_khz;\n    sample_rate_khz = sample_rate_index == 4.0 ? 96.0 : sample_rate_khz;\n\n    \/\/ Downsample incoming sound wave by reconstructing\n    \/\/ continuous signal using windowed Sinc kernel\n    \/\/ and resampling @ 44.1 kHz.\n    \/\/ Supported rates are 44.1, 48, 88.2, 96 kHz.\n\n    if (pos.y == 0.0\n        \/\/ Bypass FFT during pilot and inject wave directly into phase channel.\n        || (pos.y == 8.0 && is_expecting_pilot)\n        )\n    {\n        float k = pos.x;\n\n        \/\/ Do not resample during pilot as sample rate not yet known.\n\n        if (is_expecting_data)\n        {\n            k *= sample_rate_khz \/ 44.1;\n        }\n\n        \/\/ Windowed Sinc reconstruction and resampling.\n\n        float v = 0.0;\n        float total_weight = 0.0;\n        float f = fract(k);\n\n        for (int n = -RESAMPLE_WINDOW_RADIUS; n <= RESAMPLE_WINDOW_RADIUS; n++)\n        {\n            float fn = float(n);\n            float weight = windowedSinc(fn - f, float(RESAMPLE_WINDOW_RADIUS));\n\n            float source_wave =\n                texture(iChannel0, vec2((floor(k) + fn + 0.5) \/ iChannelResolution[0].x, 0.75)).x;\n\n            v += weight * source_wave;\n            total_weight += weight;\n        }\n\n        v \/= total_weight;\n\n        \/\/ Clear area outside of buffer with virtual zero.\n\n        if (k >= float(BUFFER_SIZE)) v = 128.0 \/ 255.0;\n\n        fragColor = vec4(v * 2.0 - 1.0);\n    }\n\n    \/\/ Perform Fourier transform and convert 160 samples @ 44.1 kHz\n    \/\/ into 61 complex coefficients of orthogonal bases.\n    \/\/ Though SoundCloud is streaming 128 kBps MP3 @ 44.1 kHz\n    \/\/ in reality audio is cutoff at around 16.something kHz.\n    \/\/ Encoder is aware of that and only 61 out of 80 bases are used.\n\n    if (8.0 <= pos.y && pos.y < 8.0 + 16.0)\n    {\n        int i = int(pos.x);\n        int line_index = int(pos.y - 8.0);\n\n        \/\/  0     : fundamental.xy, dcY.xy\n        \/\/  1     : block_pos.xy, 0, 0\n        \/\/  2..13 : 48 DCT luma   coefficients including DC\n        \/\/ 14..15 :  8 DCT chroma coefficients\n\n        FFTBand coeff[4];\n        vec4    ic = vec4(0);\n\n        if (line_index ==  0) ic = vec4( 1, 6, 0, 0);\n        if (line_index ==  1) ic = vec4( 2, 3, 4, 5);\n        if (line_index == 14) ic = vec4( 6, 7,14,15) + 6.0;\n        if (line_index == 15) ic = vec4(22,23,30,31) + 6.0;\n\n        if (2 <= line_index && line_index <= 13)\n        {\n            float icoeff4 = float(line_index - 2);\n            vec4  idx = icoeff4 * 4.0 + vec4(0, 1, 2, 3);\n\n            \/\/ Chrominance coefficients are interleaved with\n            \/\/ luminance for safe failure.\n            \/\/ Build indexes jumping over chroma when needed.\n\n            ic = mix(idx + 8.0, mod(idx, vec4(6)) + 8.0 * floor(idx \/ vec4(6.0)), vec4(lessThan(idx, vec4(24)))) + 6.0;\n        }\n\n        coeff[0] = FFTBand_create(ic.x, PACKET_SIZE);\n        coeff[1] = FFTBand_create(ic.y, PACKET_SIZE);\n        coeff[2] = FFTBand_create(ic.z, PACKET_SIZE);\n        coeff[3] = FFTBand_create(ic.w, PACKET_SIZE);\n\n        for (int k = 0; k < PACKET_SIZE; k++)\n        {\n            float v = loadSelf(i + k, 0).w;\n\n            FFTBand_update(coeff[0], v);\n            FFTBand_update(coeff[1], v);\n            FFTBand_update(coeff[2], v);\n            FFTBand_update(coeff[3], v);\n        }\n\n        float cf[4];\n\n        for (int k = 0; k < 4; k++)\n        {\n            \/\/ Coefficient sign is encoded in phase.\n\n            float s = FFTBand_angle(coeff[k]) >= 0.0 ? 1.0 : -1.0;\n            cf[k] = s * FFTBand_amplitude(coeff[k]) * 127.0;\n        }\n\n        if (line_index == 2)\n        {\n            \/\/ DC coefficient is encoded with reduced amplitude\n            \/\/ to minimize frequency masking during mp3 encoding\n            \/\/ and interfering with meta data.\n\n            cf[0] *= 2.0;\n        }\n\n        fragColor = vec4(cf[0], cf[1], cf[2], cf[3]);\n\n        if (line_index == 0)\n        {\n            \/\/ Store fundamental and DC components as raw complex numbers\n            \/\/ required by packet locator.\n\n            fragColor = vec4(coeff[0].f.xy, coeff[1].f.xy);\n        }\n\n        if (line_index == 1)\n        {\n            \/\/ Decode metadata.\n            \/\/ Amplitude of a low frequency signal may be altered\n            \/\/ by mp3 compression quite a lot and is unreliable.\n            \/\/ However constant amplitude is less prone to that.\n            \/\/ Use quantized phase instead to encode\n            \/\/ low and high parts of block positions.\n\n            vec4 phi = vec4(\n                decodePhase(FFTBand_angle(coeff[0])),\n                decodePhase(FFTBand_angle(coeff[1])),\n                decodePhase(FFTBand_angle(coeff[2])),\n                decodePhase(FFTBand_angle(coeff[3]))\n                );\n            vec4 amp = vec4(\n                FFTBand_amplitude(coeff[0]),\n                FFTBand_amplitude(coeff[1]),\n                FFTBand_amplitude(coeff[2]),\n                FFTBand_amplitude(coeff[3])\n                );\n\n            ivec4 op = ivec4(0.425 + (phi \/ 45.0));\n            vec2  fp = vec2(op.xz * 8 + op.yw) \/ 64.0;\n\n            \/\/ Amplitudes must be in expected range.\n\n            const vec4 lvl = vec4(3.7 \/ 127.0);\n            const vec4 th  = vec4(0.3 \/ 127.0);\n\n            bool is_amp_ok = all(lessThan(abs(amp - lvl), th));\n            fp = is_amp_ok ? fp : vec2(1000);\n\n            fragColor = vec4(fp.xy, 0, 0);\n        }\n\n        if (i >= BUFFER_SIZE - PACKET_SIZE) fragColor = vec4(0);\n    }\n\n    \/\/ Locate packets in processed data.\n\n    if (pos.y == 72.0)\n    {\n        int i = int(pos.x);\n\n        fragColor = vec4(0);\n\n        vec4 prev = loadSelf(i - 1, 8);\n        vec4 curr = loadSelf(i    , 8);\n        vec4 next = loadSelf(i + 1, 8);\n\n        \/\/ Check if we are above expected noise level.\n\n        bool has_carrier = length(curr.xy) > (100.0 \/ 32767.0);\n        bool has_dc =\n               length(curr.zw) > (120.0 \/ 32767.0)\n            && length(prev.zw) > (120.0 \/ 32767.0)\n            && length(next.zw) > (120.0 \/ 32767.0);\n\n        \/\/ Use fundamental frequency for coarse synchronisation.\n        \/\/ It is the lowerest frequency in the stream\n        \/\/ and phase shifts may occur after mp3 compression.\n\n        if (prev.x * curr.x <= 0.0 \/\/ carrier phase crosses 90 degree point\n            && ((prev.x <= curr.x  \/\/ it's rising\n                 && curr.x >= 0.0) \/\/ and it's 90 but not -90 degrees.\n                || is_expecting_pilot)\n            )\n        {\n            if (has_carrier)\n            {\n                bool  is_valid = true;\n                float max_err = 16.0;\n\n                \/\/ Use phase of DC wave for location refinement.\n\n                float m = has_dc ? 99.0    : 45.0;\n                vec2  p = has_dc ? prev.zw : prev.xy;\n                vec2  c = has_dc ? curr.zw : curr.xy;\n                vec2  n = has_dc ? next.zw : next.xy;\n\n                float l2 = degrees(atan(p.y, p.x));\n                float c2 = degrees(atan(c.y, c.x));\n                float r2 = degrees(atan(n.y, n.x));\n\n                float l2_0 = abs(angDiff(l2, 90.0));\n                float c2_0 = abs(angDiff(c2, 90.0));\n                float r2_0 = abs(angDiff(r2, 90.0));\n                float l2_1 = abs(angDiff(l2,-90.0));\n                float c2_1 = abs(angDiff(c2,-90.0));\n                float r2_1 = abs(angDiff(r2,-90.0));\n\n                m = min(min(m, min(l2_0, l2_1)), min(min(c2_0, c2_1), min(r2_0, r2_1)));\n\n                int delta = 0;\n\n                if (m == l2_0 || m == l2_1) delta = -1;\n                if (m == r2_0 || m == r2_1) delta = +1;\n\n                if (has_dc)\n                {\n                    is_valid = m < max_err;\n                }\n                else\n                {\n                    \/\/ Even though DC is bellow threshold and can't be used for refinement,\n                    \/\/ it can still be used for error estimation.\n\n                    c = (delta == -1 ? prev : delta == 1 ? next : curr).zw;\n\n                    c2 = degrees(atan(c.y, c.x));\n                    c2_0 = abs(angDiff(c2, 90.0));\n                    c2_1 = abs(angDiff(c2,-90.0));\n\n                    \/\/ Overestimate by 20% so that block that has_dc can override it.\n                    m = min(c2_0, c2_1) * 1.2;\n                }\n\n                float err = 0.001 + m;\n\n                if (is_expecting_data)\n                {\n                    \/\/ Additional validation to account for resampling.\n\n                    is_valid = is_valid && (\n                        pos.x > float(RESAMPLE_WINDOW_RADIUS + 1)\n                        && pos.x < (float(BUFFER_SIZE) - float(PACKET_SIZE) * sample_rate_khz \/ 44.1\n                            - float(RESAMPLE_WINDOW_RADIUS + 1))\n                        );\n                }\n\n                fragColor = is_valid ? vec4(10.0 + float(delta), err, 0, 0) : fragColor;\n            }\n\n            if (is_expecting_pilot && pos.x < float(BUFFER_SIZE - PACKET_SIZE))\n            {\n                fragColor = vec4(10, 0, 0, 0);\n            }\n        }\n    }\n\n    \/\/ Transform location array into array of packet locations\n    \/\/ by reduction over multiple frames.\n\n    int px = 0;\n    int py = 74;\n\n    if (pos.y == 74.0) py = 73, px = int(pos.x);\n    if (pos.y == 73.0) py = 72, px = int(pos.x);\n\n    vec2 bp[8];\n    {\n        \/\/ bp[] is not really an array. Can't write to it in a loop. Unroll.\n        #define IBP(k)IBP1(k)IBP2(k)IBP3(k)\n        #define IBP1(k) bp[k] = loadSelf(px * 8 + k, py).xy;\n        #define IBP2(k) bp[k].x = floor(bp[k].x);\n        \/\/ Location array stores relative deltas that we need\n        \/\/ to convert to absolute positions for later stages.\n        #define IBP3(k) bp[k].x += pos.y == 73.0 && bp[k].x > 0.0 ? float(px * 8 + k) : 0.0;\n\n        IBP(0)IBP(1)IBP(2)IBP(3)IBP(4)IBP(5)IBP(6)IBP(7)\n    }\n\n    if (pos.y == 73.0 || pos.y == 74.0)\n    {\n        \/\/ Blocks are sparse enough that we don't worry about collisions.\n        \/\/ Just grab a single location. This could be improved.\n\n        vec2 p = vec2(0.0, 1000.0);\n        float cnt = 0.0;\n\n        for (int k = 0; k < 8; k++)\n        {\n            p = bp[k].x > 0.0 ? bp[k] : p;\n            cnt += bp[k].x > 0.0 ? 1.0 : 0.0;\n        }\n\n        \/\/ If we have more than one block per bin then something went wrong.\n        \/\/ Packets can't be that close. Reject everything.\n        p = cnt > 1.0 ? vec2(0.0, 1000.0) : p;\n\n        fragColor = vec4(p, 0, 0);\n    }\n\n    \/\/ Copy located packets into corresponding image blocks.\n\n    if (is_expecting_data)\n    {\n        vec2 cpos = ((pos - vec2(0, 140-60)) \/ 4.0);\n        cpos.y = 34.0 - cpos.y;\n        vec2 lpos = fract(cpos) * 4.0;\n        cpos = floor(cpos);\n\n        int icoeff = int(lpos.x + 4.0 * lpos.y);\n\n        if (all(lessThan(cpos, vec2(64, 35))))\n        {\n        #if DO_MINIMIZE_ERROR\n            ivec2 cp = ivec2(cpos.xy * 4.0);\n            float old_err = loadSelf(cp.x, 140-60 + 140 - 4 - (cp.y + 3)).x;\n            float err = old_err > 0.0 ? min(old_err, 100.0) : 100.0;\n        #endif\n\n            for (int k = 0; k < 8; k++)\n            {\n                if (all(greaterThan(bp[k], vec2(0))))\n                {\n                    int i = int(bp[k].x - 10.0);\n                    vec2 bpos = floor(64.0 * loadSelf(i, 57).xy);\n\n                    if (all(equal(bpos, cpos)))\n                    {\n                    #if DO_MINIMIZE_ERROR\n                        \/\/ Generally it is true that the less the phase error\n                        \/\/ of fundamental and DC waves the better the quality.\n                        \/\/ We keep track of the error in current block\n                        \/\/ and only accept new data when the error is smaller.\n\n                        float new_err = bp[k].y;\n\n                        if (new_err < err)\n                        {\n                            err = new_err;\n                            fragColor = icoeff < 12 ? loadSelf(i, 58 + icoeff) : vec4(err);\n                        }\n                    #else\n\n                        fragColor = icoeff < 12 ? loadSelf(i, 58 + icoeff) : vec4(0);\n                    #endif                        \n                    }\n                }\n            }\n        }\n    }\n\n    \/\/ Predict chroma blocks that have not been received yet.\n    \/\/ Chroma components are 1\/8th size of the luminance and\n    \/\/ get bilinearly interpolated to full resolution in the\n    \/\/ next stage when combined with reconstructed luminance.\n    \/\/ This is needed to minimize desaturated bleeding.\n\n    if (255.0 <= pos.x && pos.x < 335.0\n        && pos.y >= 145.0 - 60.0\n        && last_color.w < 0.5\n        )\n    {\n        int x = int(pos.x);\n        int y = int(pos.y);\n\n        vec3 l = loadSelf(x-1, y).rgb;\n        vec3 r = loadSelf(x+1, y).rgb;\n        vec3 t = loadSelf(x, y+1).rgb;\n        vec3 b = loadSelf(x, y-1).rgb;\n\n        fragColor = vec4((l + r + t + b) \/ 4.0, 0);\n    }\n\n    \/\/ Decode chrominance in-place.\n    \/\/ CgCo components are coded at 1\/8th size of luminance\n    \/\/ and represented by 8 DCT coefficients total.\n    \/\/ To take advantage of hardware filtering and simplify\n    \/\/ final reconstruction, perform IDCT in-place.\n\n    if (is_expecting_data)\n    {\n        vec2 cpos = ((pos.yx - vec2(150-60, 260)) \/ 2.0);\n        vec2 lpos = fract(cpos) * 2.0;\n        cpos = floor(cpos);\n\n        if (all(lessThan(cpos, vec2(64, 35))))\n        {\n            for (int k = 0; k < 8; k++)\n            {\n                if (all(greaterThan(bp[k], vec2(0))))\n                {\n                    int i = int(bp[k].x - 10.0);\n                    vec2 bpos = floor(64.0 * loadSelf(i, 57).xy);\n\n                    if (all(equal(bpos, cpos)))\n                    {\n                        vec4 a = 0.25 * loadSelf(i, 58 + 12) \/ vec4(1,1,2,2);\n                        vec4 b = 0.25 * loadSelf(i, 58 + 13) \/ vec4(3,3,4,4);\n                        \n                        vec2 val = vec2(0);\n                        \n                        val = all(equal(lpos, vec2(0,0))) ? a.xy + a.zw + b.xy + b.zw : val;\n                        val = all(equal(lpos, vec2(1,0))) ? a.xy - a.zw + b.xy - b.zw : val;\n                        val = all(equal(lpos, vec2(0,1))) ? a.xy + a.zw - b.xy - b.zw : val;\n                        val = all(equal(lpos, vec2(1,1))) ? a.xy - a.zw - b.xy + b.zw : val;\n\n                        fragColor = vec4(-val.x + val.y, val.x, -val.x - val.y, 1);\n                    }\n                }\n            }\n        }\n    }\n\n    \/\/ Detect sample rate by checking period of pure sine wave\n    \/\/ at the beginning of stream.\n\n    if (pos.y == 1.0)\n    {\n        float sample_rate_index = last_color.w;\n\n        if (is_expecting_pilot)\n        {\n            float f = 0.0;\n            float first_sync  = 0.0;\n            float second_sync = 0.0;\n\n            for (int k = 0; k < 8; k++)\n            {\n                bool sync = bp[k].x > 0.0;\n\n                first_sync  = sync && f == 0.0 ? bp[k].x : first_sync;\n                second_sync = sync && f == 1.0 ? bp[k].x : second_sync;\n\n                f += sync ? 1.0 : 0.0;\n            }\n\n            if (first_sync > 0.0 && second_sync > 0.0)\n            {\n                \/\/ We are measuring half period actually.\n                float size = 2.0 * (second_sync - first_sync);\n                float id = 0.0;\n\n                id = abs(size - 348.0) < 10.0 ? 4.0 : id; \/\/ 96.0\n                id = abs(size - 320.0) < 10.0 ? 3.0 : id; \/\/ 88.2\n                id = abs(size - 174.0) <  5.0 ? 2.0 : id; \/\/ 48.0\n                id = abs(size - 160.0) <  5.0 ? 1.0 : id; \/\/ 44.1\n\n                sample_rate_index = id > 0.0 ? id : sample_rate_index;\n            }\n        }\n\n        fragColor.w = sample_rate_index;\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"lsfGD4","filepath":"https:\/\/soundcloud.com\/user-470401467\/st-image-2e-3","previewfilepath":"https:\/\/soundcloud.com\/user-470401467\/st-image-2e-3","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/\/ oilArt - Buf A\/B\n\/\/\n\/\/ Main audio decoder.\n\/\/ Buf B is redundant and runs the same code as Buf A but reads slightly delayed\n\/\/ audio stream to increase reliability when FPS drops or high sample rate is used.\n\/\/\n\/\/ Audio stream is made up of 160 samples long packets that come in buckets of 6\n\/\/ packets in a row needed to have stable frequency content within ~1000 sample wide\n\/\/ window to minimize frequency masking during mp3 compression. Though SoundCloud\n\/\/ is streaming 128 kBps mp3 @ 44.1 kHz, in reality its closer to FM radio quality\n\/\/ with 32 kHz sample rate. Thus out of 80 available frequency bands only 61 are used.\n\/\/ \n\/\/ Shadertoy reads content of web audio analyzer node and clamps input buffer to 512.\n\/\/ Having 6x packet redundancy helps to remedy that as well. Additionally, some\n\/\/ browsers like Firefox do some funky stuff to that buffer applying some pinching\n\/\/ effect around some buffer boundaries once in a while making some packets unusable.\n\/\/\n\/\/ Out of 61 frequency bands fundamental (carrier) is used for packet location,\n\/\/ 4 bands are used to encode block location within the image using quantized phase,\n\/\/ Then 48 DCT luminance coefficients are interleaved with 8 chrominance coefficients\n\/\/ representing final 496x280 image plane that gets processed further.\n\/\/\n\/\/ Currently, Shadertoy doesn't provide any access to current web audio sample rate.\n\/\/ iSampleRate doesn't work correctly. To solve that a pilot tone is provided\n\/\/ in the beginning of the stream, its period is measured and standard sample rates\n\/\/ are deduced. Supported rates are 44.1, 48, 88.2, 96 kHz.\n\/\/\n\/\/ The best case is 44.1 kHz @ 60 fps. When fps drops or sample rate increased then\n\/\/ we will receive fewer packets and more sparsely. That takes more stream runs\n\/\/ for image to form. Meanwhile, missing block reconstruction is performed.\n\/\/\n\/\/ Created by Dmitry Andreev - and'2016\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define PI 3.14159265\n\n#define BUFFER_SIZE 500\n#define PACKET_SIZE 160\n#define RESAMPLE_WINDOW_RADIUS 7\n\n#define DO_MINIMIZE_ERROR 1\n\n\/\/ Fourier transform utilities.\n\nstruct FFTBand\n{\n    vec2 di;\n    vec2 df;\n    vec2 f;\n};\n\nFFTBand FFTBand_create(const float n, const int fft_size)\n{\n    FFTBand band;\n\n    float fi = (float(n) \/ float(fft_size \/ 2)) * float(fft_size) * 0.5;\n    float angle = 2.0 * PI * fi \/ float(fft_size);\n\n    band.di = vec2(cos(angle), sin(angle));\n    band.df = vec2(1.0 \/ float(fft_size), 0.0);\n    band.f  = vec2(0.0, 0.0);\n\n    return band;\n}\n\nvoid FFTBand_update(inout FFTBand band, float value)\n{\n    band.f += band.df * value;\n    band.df = vec2(\n        band.df.x * band.di.x - band.df.y * band.di.y,\n        band.df.y * band.di.x + band.df.x * band.di.y\n        );\n}\n\nfloat FFTBand_amplitude(FFTBand band)\n{\n    return length(band.f);\n}\n\nfloat FFTBand_angle(FFTBand band)\n{\n    return degrees(atan(band.f.y, band.f.x));\n}\n\n\/\/ Additional helpers.\n\nfloat decodePhase(float x)\n{\n    return mod(111.0 - x, 360.0) - 20.0;\n}\n\nfloat angDiff(float a, float b)\n{\n    return mod(a - b + 180.0, 360.0) - 180.0;\n}\n\nfloat windowedSinc(float x, float radius)\n{\n    float w = abs(x) < 0.001 ? 1.0 : sin(PI * x) \/ (PI * x);\n\n    \/\/ Zero-phase Hamming window\n    w *= 0.54 + 0.46 * cos(PI * x \/ radius);\n\n    return w;\n}\n\nvec4 loadSelf(int x, int y)\n{\n    return textureLod(iChannel1, (vec2(x, y) + 0.5) \/ iChannelResolution[1].xy, 0.0);\n}\n\n\/\/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    \/\/ Discard everything outside of working area\n    \/\/ to increase performance.\n\n    if (any(greaterThan(fragCoord, vec2(500, 280-60)))) discard;\n\n    vec2 pos = floor(fragCoord);\n    vec2 last_pos = pos;\n    bool is_expecting_data  = iChannelTime[0] > 1.5;\n    bool is_expecting_pilot = iChannelTime[0] > 1.1 && iChannelTime[0] < 1.5;\n\n    \/\/ Propagate decoded data down the pipeline during reduction.\n\n    last_pos.y -=\n           (56.0 <= pos.y && pos.y < 56.0 + 16.0)\n        || (40.0 <= pos.y && pos.y < 40.0 + 16.0)\n        || (24.0 <= pos.y && pos.y < 24.0 + 16.0)\n        ?\n        16.0 : 0.0;\n\n    vec4 last_color = loadSelf(int(last_pos.x), int(last_pos.y));\n\n    fragColor = last_color;\n\n    \/\/ Read detected sample rate.\n\n    float sample_rate_index = floor(0.5 + loadSelf(0, 1).w);\n    float sample_rate_khz = 44.1;\n\n    sample_rate_khz = sample_rate_index == 2.0 ? 48.0 : sample_rate_khz;\n    sample_rate_khz = sample_rate_index == 3.0 ? 88.2 : sample_rate_khz;\n    sample_rate_khz = sample_rate_index == 4.0 ? 96.0 : sample_rate_khz;\n\n    \/\/ Downsample incoming sound wave by reconstructing\n    \/\/ continuous signal using windowed Sinc kernel\n    \/\/ and resampling @ 44.1 kHz.\n    \/\/ Supported rates are 44.1, 48, 88.2, 96 kHz.\n\n    if (pos.y == 0.0\n        \/\/ Bypass FFT during pilot and inject wave directly into phase channel.\n        || (pos.y == 8.0 && is_expecting_pilot)\n        )\n    {\n        float k = pos.x;\n\n        \/\/ Do not resample during pilot as sample rate not yet known.\n\n        if (is_expecting_data)\n        {\n            k *= sample_rate_khz \/ 44.1;\n        }\n\n        \/\/ Windowed Sinc reconstruction and resampling.\n\n        float v = 0.0;\n        float total_weight = 0.0;\n        float f = fract(k);\n\n        for (int n = -RESAMPLE_WINDOW_RADIUS; n <= RESAMPLE_WINDOW_RADIUS; n++)\n        {\n            float fn = float(n);\n            float weight = windowedSinc(fn - f, float(RESAMPLE_WINDOW_RADIUS));\n\n            float source_wave =\n                texture(iChannel0, vec2((floor(k) + fn + 0.5) \/ iChannelResolution[0].x, 0.75)).x;\n\n            v += weight * source_wave;\n            total_weight += weight;\n        }\n\n        v \/= total_weight;\n\n        \/\/ Clear area outside of buffer with virtual zero.\n\n        if (k >= float(BUFFER_SIZE)) v = 128.0 \/ 255.0;\n\n        fragColor = vec4(v * 2.0 - 1.0);\n    }\n\n    \/\/ Perform Fourier transform and convert 160 samples @ 44.1 kHz\n    \/\/ into 61 complex coefficients of orthogonal bases.\n    \/\/ Though SoundCloud is streaming 128 kBps MP3 @ 44.1 kHz\n    \/\/ in reality audio is cutoff at around 16.something kHz.\n    \/\/ Encoder is aware of that and only 61 out of 80 bases are used.\n\n    if (8.0 <= pos.y && pos.y < 8.0 + 16.0)\n    {\n        int i = int(pos.x);\n        int line_index = int(pos.y - 8.0);\n\n        \/\/  0     : fundamental.xy, dcY.xy\n        \/\/  1     : block_pos.xy, 0, 0\n        \/\/  2..13 : 48 DCT luma   coefficients including DC\n        \/\/ 14..15 :  8 DCT chroma coefficients\n\n        FFTBand coeff[4];\n        vec4    ic = vec4(0);\n\n        if (line_index ==  0) ic = vec4( 1, 6, 0, 0);\n        if (line_index ==  1) ic = vec4( 2, 3, 4, 5);\n        if (line_index == 14) ic = vec4( 6, 7,14,15) + 6.0;\n        if (line_index == 15) ic = vec4(22,23,30,31) + 6.0;\n\n        if (2 <= line_index && line_index <= 13)\n        {\n            float icoeff4 = float(line_index - 2);\n            vec4  idx = icoeff4 * 4.0 + vec4(0, 1, 2, 3);\n\n            \/\/ Chrominance coefficients are interleaved with\n            \/\/ luminance for safe failure.\n            \/\/ Build indexes jumping over chroma when needed.\n\n            ic = mix(idx + 8.0, mod(idx, vec4(6)) + 8.0 * floor(idx \/ vec4(6.0)), vec4(lessThan(idx, vec4(24)))) + 6.0;\n        }\n\n        coeff[0] = FFTBand_create(ic.x, PACKET_SIZE);\n        coeff[1] = FFTBand_create(ic.y, PACKET_SIZE);\n        coeff[2] = FFTBand_create(ic.z, PACKET_SIZE);\n        coeff[3] = FFTBand_create(ic.w, PACKET_SIZE);\n\n        for (int k = 0; k < PACKET_SIZE; k++)\n        {\n            float v = loadSelf(i + k, 0).w;\n\n            FFTBand_update(coeff[0], v);\n            FFTBand_update(coeff[1], v);\n            FFTBand_update(coeff[2], v);\n            FFTBand_update(coeff[3], v);\n        }\n\n        float cf[4];\n\n        for (int k = 0; k < 4; k++)\n        {\n            \/\/ Coefficient sign is encoded in phase.\n\n            float s = FFTBand_angle(coeff[k]) >= 0.0 ? 1.0 : -1.0;\n            cf[k] = s * FFTBand_amplitude(coeff[k]) * 127.0;\n        }\n\n        if (line_index == 2)\n        {\n            \/\/ DC coefficient is encoded with reduced amplitude\n            \/\/ to minimize frequency masking during mp3 encoding\n            \/\/ and interfering with meta data.\n\n            cf[0] *= 2.0;\n        }\n\n        fragColor = vec4(cf[0], cf[1], cf[2], cf[3]);\n\n        if (line_index == 0)\n        {\n            \/\/ Store fundamental and DC components as raw complex numbers\n            \/\/ required by packet locator.\n\n            fragColor = vec4(coeff[0].f.xy, coeff[1].f.xy);\n        }\n\n        if (line_index == 1)\n        {\n            \/\/ Decode metadata.\n            \/\/ Amplitude of a low frequency signal may be altered\n            \/\/ by mp3 compression quite a lot and is unreliable.\n            \/\/ However constant amplitude is less prone to that.\n            \/\/ Use quantized phase instead to encode\n            \/\/ low and high parts of block positions.\n\n            vec4 phi = vec4(\n                decodePhase(FFTBand_angle(coeff[0])),\n                decodePhase(FFTBand_angle(coeff[1])),\n                decodePhase(FFTBand_angle(coeff[2])),\n                decodePhase(FFTBand_angle(coeff[3]))\n                );\n            vec4 amp = vec4(\n                FFTBand_amplitude(coeff[0]),\n                FFTBand_amplitude(coeff[1]),\n                FFTBand_amplitude(coeff[2]),\n                FFTBand_amplitude(coeff[3])\n                );\n\n            ivec4 op = ivec4(0.425 + (phi \/ 45.0));\n            vec2  fp = vec2(op.xz * 8 + op.yw) \/ 64.0;\n\n            \/\/ Amplitudes must be in expected range.\n\n            const vec4 lvl = vec4(3.7 \/ 127.0);\n            const vec4 th  = vec4(0.3 \/ 127.0);\n\n            bool is_amp_ok = all(lessThan(abs(amp - lvl), th));\n            fp = is_amp_ok ? fp : vec2(1000);\n\n            fragColor = vec4(fp.xy, 0, 0);\n        }\n\n        if (i >= BUFFER_SIZE - PACKET_SIZE) fragColor = vec4(0);\n    }\n\n    \/\/ Locate packets in processed data.\n\n    if (pos.y == 72.0)\n    {\n        int i = int(pos.x);\n\n        fragColor = vec4(0);\n\n        vec4 prev = loadSelf(i - 1, 8);\n        vec4 curr = loadSelf(i    , 8);\n        vec4 next = loadSelf(i + 1, 8);\n\n        \/\/ Check if we are above expected noise level.\n\n        bool has_carrier = length(curr.xy) > (100.0 \/ 32767.0);\n        bool has_dc =\n               length(curr.zw) > (120.0 \/ 32767.0)\n            && length(prev.zw) > (120.0 \/ 32767.0)\n            && length(next.zw) > (120.0 \/ 32767.0);\n\n        \/\/ Use fundamental frequency for coarse synchronisation.\n        \/\/ It is the lowerest frequency in the stream\n        \/\/ and phase shifts may occur after mp3 compression.\n\n        if (prev.x * curr.x <= 0.0 \/\/ carrier phase crosses 90 degree point\n            && ((prev.x <= curr.x  \/\/ it's rising\n                 && curr.x >= 0.0) \/\/ and it's 90 but not -90 degrees.\n                || is_expecting_pilot)\n            )\n        {\n            if (has_carrier)\n            {\n                bool  is_valid = true;\n                float max_err = 16.0;\n\n                \/\/ Use phase of DC wave for location refinement.\n\n                float m = has_dc ? 99.0    : 45.0;\n                vec2  p = has_dc ? prev.zw : prev.xy;\n                vec2  c = has_dc ? curr.zw : curr.xy;\n                vec2  n = has_dc ? next.zw : next.xy;\n\n                float l2 = degrees(atan(p.y, p.x));\n                float c2 = degrees(atan(c.y, c.x));\n                float r2 = degrees(atan(n.y, n.x));\n\n                float l2_0 = abs(angDiff(l2, 90.0));\n                float c2_0 = abs(angDiff(c2, 90.0));\n                float r2_0 = abs(angDiff(r2, 90.0));\n                float l2_1 = abs(angDiff(l2,-90.0));\n                float c2_1 = abs(angDiff(c2,-90.0));\n                float r2_1 = abs(angDiff(r2,-90.0));\n\n                m = min(min(m, min(l2_0, l2_1)), min(min(c2_0, c2_1), min(r2_0, r2_1)));\n\n                int delta = 0;\n\n                if (m == l2_0 || m == l2_1) delta = -1;\n                if (m == r2_0 || m == r2_1) delta = +1;\n\n                if (has_dc)\n                {\n                    is_valid = m < max_err;\n                }\n                else\n                {\n                    \/\/ Even though DC is bellow threshold and can't be used for refinement,\n                    \/\/ it can still be used for error estimation.\n\n                    c = (delta == -1 ? prev : delta == 1 ? next : curr).zw;\n\n                    c2 = degrees(atan(c.y, c.x));\n                    c2_0 = abs(angDiff(c2, 90.0));\n                    c2_1 = abs(angDiff(c2,-90.0));\n\n                    \/\/ Overestimate by 20% so that block that has_dc can override it.\n                    m = min(c2_0, c2_1) * 1.2;\n                }\n\n                float err = 0.001 + m;\n\n                if (is_expecting_data)\n                {\n                    \/\/ Additional validation to account for resampling.\n\n                    is_valid = is_valid && (\n                        pos.x > float(RESAMPLE_WINDOW_RADIUS + 1)\n                        && pos.x < (float(BUFFER_SIZE) - float(PACKET_SIZE) * sample_rate_khz \/ 44.1\n                            - float(RESAMPLE_WINDOW_RADIUS + 1))\n                        );\n                }\n\n                fragColor = is_valid ? vec4(10.0 + float(delta), err, 0, 0) : fragColor;\n            }\n\n            if (is_expecting_pilot && pos.x < float(BUFFER_SIZE - PACKET_SIZE))\n            {\n                fragColor = vec4(10, 0, 0, 0);\n            }\n        }\n    }\n\n    \/\/ Transform location array into array of packet locations\n    \/\/ by reduction over multiple frames.\n\n    int px = 0;\n    int py = 74;\n\n    if (pos.y == 74.0) py = 73, px = int(pos.x);\n    if (pos.y == 73.0) py = 72, px = int(pos.x);\n\n    vec2 bp[8];\n    {\n        \/\/ bp[] is not really an array. Can't write to it in a loop. Unroll.\n        #define IBP(k)IBP1(k)IBP2(k)IBP3(k)\n        #define IBP1(k) bp[k] = loadSelf(px * 8 + k, py).xy;\n        #define IBP2(k) bp[k].x = floor(bp[k].x);\n        \/\/ Location array stores relative deltas that we need\n        \/\/ to convert to absolute positions for later stages.\n        #define IBP3(k) bp[k].x += pos.y == 73.0 && bp[k].x > 0.0 ? float(px * 8 + k) : 0.0;\n\n        IBP(0)IBP(1)IBP(2)IBP(3)IBP(4)IBP(5)IBP(6)IBP(7)\n    }\n\n    if (pos.y == 73.0 || pos.y == 74.0)\n    {\n        \/\/ Blocks are sparse enough that we don't worry about collisions.\n        \/\/ Just grab a single location. This could be improved.\n\n        vec2 p = vec2(0.0, 1000.0);\n        float cnt = 0.0;\n\n        for (int k = 0; k < 8; k++)\n        {\n            p = bp[k].x > 0.0 ? bp[k] : p;\n            cnt += bp[k].x > 0.0 ? 1.0 : 0.0;\n        }\n\n        \/\/ If we have more than one block per bin then something went wrong.\n        \/\/ Packets can't be that close. Reject everything.\n        p = cnt > 1.0 ? vec2(0.0, 1000.0) : p;\n\n        fragColor = vec4(p, 0, 0);\n    }\n\n    \/\/ Copy located packets into corresponding image blocks.\n\n    if (is_expecting_data)\n    {\n        vec2 cpos = ((pos - vec2(0, 140-60)) \/ 4.0);\n        cpos.y = 34.0 - cpos.y;\n        vec2 lpos = fract(cpos) * 4.0;\n        cpos = floor(cpos);\n\n        int icoeff = int(lpos.x + 4.0 * lpos.y);\n\n        if (all(lessThan(cpos, vec2(64, 35))))\n        {\n        #if DO_MINIMIZE_ERROR\n            ivec2 cp = ivec2(cpos.xy * 4.0);\n            float old_err = loadSelf(cp.x, 140-60 + 140 - 4 - (cp.y + 3)).x;\n            float err = old_err > 0.0 ? min(old_err, 100.0) : 100.0;\n        #endif\n\n            for (int k = 0; k < 8; k++)\n            {\n                if (all(greaterThan(bp[k], vec2(0))))\n                {\n                    int i = int(bp[k].x - 10.0);\n                    vec2 bpos = floor(64.0 * loadSelf(i, 57).xy);\n\n                    if (all(equal(bpos, cpos)))\n                    {\n                    #if DO_MINIMIZE_ERROR\n                        \/\/ Generally it is true that the less the phase error\n                        \/\/ of fundamental and DC waves the better the quality.\n                        \/\/ We keep track of the error in current block\n                        \/\/ and only accept new data when the error is smaller.\n\n                        float new_err = bp[k].y;\n\n                        if (new_err < err)\n                        {\n                            err = new_err;\n                            fragColor = icoeff < 12 ? loadSelf(i, 58 + icoeff) : vec4(err);\n                        }\n                    #else\n\n                        fragColor = icoeff < 12 ? loadSelf(i, 58 + icoeff) : vec4(0);\n                    #endif                        \n                    }\n                }\n            }\n        }\n    }\n\n    \/\/ Predict chroma blocks that have not been received yet.\n    \/\/ Chroma components are 1\/8th size of the luminance and\n    \/\/ get bilinearly interpolated to full resolution in the\n    \/\/ next stage when combined with reconstructed luminance.\n    \/\/ This is needed to minimize desaturated bleeding.\n\n    if (255.0 <= pos.x && pos.x < 335.0\n        && pos.y >= 145.0 - 60.0\n        && last_color.w < 0.5\n        )\n    {\n        int x = int(pos.x);\n        int y = int(pos.y);\n\n        vec3 l = loadSelf(x-1, y).rgb;\n        vec3 r = loadSelf(x+1, y).rgb;\n        vec3 t = loadSelf(x, y+1).rgb;\n        vec3 b = loadSelf(x, y-1).rgb;\n\n        fragColor = vec4((l + r + t + b) \/ 4.0, 0);\n    }\n\n    \/\/ Decode chrominance in-place.\n    \/\/ CgCo components are coded at 1\/8th size of luminance\n    \/\/ and represented by 8 DCT coefficients total.\n    \/\/ To take advantage of hardware filtering and simplify\n    \/\/ final reconstruction, perform IDCT in-place.\n\n    if (is_expecting_data)\n    {\n        vec2 cpos = ((pos.yx - vec2(150-60, 260)) \/ 2.0);\n        vec2 lpos = fract(cpos) * 2.0;\n        cpos = floor(cpos);\n\n        if (all(lessThan(cpos, vec2(64, 35))))\n        {\n            for (int k = 0; k < 8; k++)\n            {\n                if (all(greaterThan(bp[k], vec2(0))))\n                {\n                    int i = int(bp[k].x - 10.0);\n                    vec2 bpos = floor(64.0 * loadSelf(i, 57).xy);\n\n                    if (all(equal(bpos, cpos)))\n                    {\n                        vec4 a = 0.25 * loadSelf(i, 58 + 12) \/ vec4(1,1,2,2);\n                        vec4 b = 0.25 * loadSelf(i, 58 + 13) \/ vec4(3,3,4,4);\n                        \n                        vec2 val = vec2(0);\n                        \n                        val = all(equal(lpos, vec2(0,0))) ? a.xy + a.zw + b.xy + b.zw : val;\n                        val = all(equal(lpos, vec2(1,0))) ? a.xy - a.zw + b.xy - b.zw : val;\n                        val = all(equal(lpos, vec2(0,1))) ? a.xy + a.zw - b.xy - b.zw : val;\n                        val = all(equal(lpos, vec2(1,1))) ? a.xy - a.zw - b.xy + b.zw : val;\n\n                        fragColor = vec4(-val.x + val.y, val.x, -val.x - val.y, 1);\n                    }\n                }\n            }\n        }\n    }\n\n    \/\/ Detect sample rate by checking period of pure sine wave\n    \/\/ at the beginning of stream.\n\n    if (pos.y == 1.0)\n    {\n        float sample_rate_index = last_color.w;\n\n        if (is_expecting_pilot)\n        {\n            float f = 0.0;\n            float first_sync  = 0.0;\n            float second_sync = 0.0;\n\n            for (int k = 0; k < 8; k++)\n            {\n                bool sync = bp[k].x > 0.0;\n\n                first_sync  = sync && f == 0.0 ? bp[k].x : first_sync;\n                second_sync = sync && f == 1.0 ? bp[k].x : second_sync;\n\n                f += sync ? 1.0 : 0.0;\n            }\n\n            if (first_sync > 0.0 && second_sync > 0.0)\n            {\n                \/\/ We are measuring half period actually.\n                float size = 2.0 * (second_sync - first_sync);\n                float id = 0.0;\n\n                id = abs(size - 348.0) < 10.0 ? 4.0 : id; \/\/ 96.0\n                id = abs(size - 320.0) < 10.0 ? 3.0 : id; \/\/ 88.2\n                id = abs(size - 174.0) <  5.0 ? 2.0 : id; \/\/ 48.0\n                id = abs(size - 160.0) <  5.0 ? 1.0 : id; \/\/ 44.1\n\n                sample_rate_index = id > 0.0 ? id : sample_rate_index;\n            }\n        }\n\n        fragColor.w = sample_rate_index;\n    }\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\/\/ oilArt - Buf C\n\/\/\n\/\/ Take DCT luminance coefficients from decoders that correspond to blocks with\n\/\/ smaller error, perform standard JPEG-like de-zigzagging and apply\n\/\/ Inverse Discrete Cosine Transform (IDCT) to get reconstructed luminance.\n\/\/ Then add interpolated chrominance that was reconstructed by corresponding\n\/\/ decoder to build final 496x280 image.\n\/\/\n\/\/ Perform continious reconstruction (fill-in) of missing blocks in a stylized way\n\/\/ by scattering exising blocks around. And play brush-like revealing effect\n\/\/ on newly arrived blocks.\n\/\/\n\/\/ Created by Dmitry Andreev - and'2016\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define STYLIZED_FILLIN    1\n#define DO_FILLIN_MISSING  1\n#define DO_PAINING_EFFECT  1\n#define DO_DUAL_DECODING   1\n\n#define PI 3.14159265\n\nvec4 loadA(int x, int y)\n{\n    return textureLod(iChannel0, (vec2(x, y) + 0.5) \/ iChannelResolution[0].xy, 0.0);\n}\n\nvec4 loadB(int x, int y)\n{\n    return textureLod(iChannel1, (vec2(x, y) + 0.5) \/ iChannelResolution[1].xy, 0.0);\n}\n\nvec4 sampleSelf(vec2 pos)\n{\n    return textureLod(iChannel2, pos \/ iChannelResolution[2].xy, 0.0);\n}\n\nvec4 dct(vec2 cpos, vec4 x, vec4 y)\n{\n    vec4 wx = 2.0 * cos(PI * x * float(cpos.x * 2.0 + 1.0) \/ 16.0);\n    vec4 wy = 2.0 * cos(PI * y * float(cpos.y * 2.0 + 1.0) \/ 16.0);\n\n    const float a = 0.17677669; \/\/ sqrt(1.0 \/ (4.0 * 8.0));\n    const float b = 0.25;       \/\/ sqrt(1.0 \/ (2.0 * 8.0));\n\n    wx.x *= x.x == 0.0 ? a : b;\n    wx.y *= x.y == 0.0 ? a : b;\n    wx.z *= x.z == 0.0 ? a : b;\n    wx.w *= x.w == 0.0 ? a : b;\n\n    wy.x *= y.x == 0.0 ? a : b;\n    wy.y *= y.y == 0.0 ? a : b;\n    wy.z *= y.z == 0.0 ? a : b;\n    wy.w *= y.w == 0.0 ? a : b;\n\n    return wx * wy;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (any(greaterThan(fragCoord, vec2(500, 280)))) discard;\n\n    vec2 bpos = floor(fragCoord \/ 8.0);\n    vec2 cpos = fract(floor(fragCoord) \/ 8.0) * 8.0;\n    cpos.y = 7.0 - cpos.y;\n\n    vec4 old = sampleSelf(bpos * 8.0 + 0.5);\n\n    int cx = int(bpos.x * 4.0);\n    int cy = int(bpos.y * 4.0) + 140-60;\n\n    vec4 chroma = vec4(0);\n    vec4 val4 = vec4(0);\n    vec4 c[12];\n\n    bool is_best_A = true;\n    float blockA = loadA(cx+0, cy-3).x;\n    float blockB = loadB(cx+0, cy-3).x;\n\n#if DO_DUAL_DECODING\n    \/\/ Take the best result of two decoders.\n\n    if (blockA > 0.0 && blockB > 0.0)\n    {\n        is_best_A = blockA <= blockB;\n    }\n    else if (blockA > 0.0)\n    {\n        is_best_A = true;\n    }\n    else\n    {\n        is_best_A = false;\n    }\n#else\n    is_best_A = true;\n#endif\n\n    if (is_best_A)\n    {\n        chroma = texture(iChannel0, (vec2(260+70, 150-60) + vec2(-1,1) * fragCoord.yx \/ 4.0) \/ iChannelResolution[0].xy);\n    }\n#if DO_DUAL_DECODING\n    else\n    {\n        chroma = texture(iChannel1, (vec2(260+70, 150-60) + vec2(-1,1) * fragCoord.yx \/ 4.0) \/ iChannelResolution[1].xy);\n    }\n\n    #define C(x,y) (is_best_A ? loadA(cx+x, cy+y) : loadB(cx+x, cy+y))\n#else\n    #define C(x,y) (loadA(cx+x, cy+y))\n#endif\n\n    \/\/ 8x8 IDCT of luminance with standard Jpeg zigzag.\n\n    val4 += C(0, 0) * dct(cpos, vec4(0,1,0,0), vec4(0,0,1,2));\n    val4 += C(1, 0) * dct(cpos, vec4(1,2,3,2), vec4(1,0,0,1));\n    val4 += C(2, 0) * dct(cpos, vec4(1,0,0,1), vec4(2,3,4,3));\n    val4 += C(3, 0) * dct(cpos, vec4(2,3,4,5), vec4(2,1,0,0));\n    val4 += C(0,-1) * dct(cpos, vec4(4,3,2,1), vec4(1,2,3,4));\n    val4 += C(1,-1) * dct(cpos, vec4(0,0,1,2), vec4(5,6,5,4));\n    val4 += C(2,-1) * dct(cpos, vec4(3,4,5,6), vec4(3,2,1,0));\n    val4 += C(3,-1) * dct(cpos, vec4(7,6,5,4), vec4(0,1,2,3));\n    val4 += C(0,-2) * dct(cpos, vec4(3,2,1,0), vec4(4,5,6,7));\n    val4 += C(1,-2) * dct(cpos, vec4(1,2,3,4), vec4(7,6,5,4));\n    val4 += C(2,-2) * dct(cpos, vec4(5,6,7,7), vec4(3,2,1,2));\n    val4 += C(3,-2) * dct(cpos, vec4(6,5,4,3), vec4(3,4,5,6));\n\n    float val = 0.5 + dot(val4, vec4(0.135));\n\n    fragColor = vec4(clamp(val + chroma * 0.55, 0.0, 1.0));\n\n#if DO_PAINING_EFFECT\n    \/\/ Simple brush-like strokes in empty areas.\n\n    vec2 offs = vec2(\n        cos((fragCoord.x + fragCoord.y) * 0.05) * 3.0 + 0.0 -\n        cos((fragCoord.x + fragCoord.y) * 3.47) * 0.5,\n        sin((fragCoord.x - fragCoord.y) * 0.05) * 3.0 + 3.0 -\n        sin((fragCoord.x - fragCoord.y) * 3.47) * 0.5\n        );\n\n    float noise = textureLod(iChannel3, (floor(fragCoord) + 0.5) \/ iChannelResolution[3].xy, 0.0).x;\n    vec4 prev = sampleSelf(fragCoord + offs * (0.1 + 0.9 * noise));\n\n    fragColor.rgb = mix(prev.rgb, fragColor.rgb, old.a * old.a);\n#endif\n\n    fragColor.rgb = clamp(fragColor.rgb, 0.0, 1.0);\n\n#if DO_FILLIN_MISSING || DO_PAINING_EFFECT\n    float block = is_best_A ? blockA : blockB;\n\n    fragColor.a = old.a;\n\n    if (block <= 0.0001)\n    {\n    #if STYLIZED_FILLIN\n        vec2 noise2 = texture(iChannel3, (floor(fragCoord * 1.9) + 0.5) \/ iChannelResolution[3].xy).xy;\n        fragCoord += (noise2 * 2.0 - 1.0) * 2.5;\n        fragCoord = min(fragCoord, vec2(498, 278));\n    #endif\n\n        \/\/ Diffuse surrounding if block doesn't exist.\n\n        fragCoord = min(fragCoord, vec2(498, 278));\n\n        vec3 c  = sampleSelf(fragCoord).rgb;\n        vec3 v0 = sampleSelf(fragCoord + vec2(-1, 0)).rgb;\n        vec3 v1 = sampleSelf(fragCoord + vec2( 1, 0)).rgb;\n        vec3 v2 = sampleSelf(fragCoord + vec2( 0,-1)).rgb;\n        vec3 v3 = sampleSelf(fragCoord + vec2( 0, 1)).rgb;\n\n        vec3 avg = (v0 + v1 + v2 + v3) * 0.25;\n        float wx = abs(v0.g - v1.g);\n        float wy = abs(v2.g - v3.g);\n\n        \/\/ Make it less uniform by using horizontal and vertical gradients.\n    #if DO_FILLIN_MISSING\n        fragColor.xyz = wx > wy ?\n              mix(avg, (v0 + v1) * 0.5, 0.75)\n            : mix(avg, (v2 + v3) * 0.5, 0.75);\n\n        fragColor.rgb = mix(fragColor.rgb, (v3 * 8.0 + v2 * 6.0 + v0 + v1) \/ 16.0, 0.5);\n    #endif\n    }\n    else\n    {\n        \/\/ Advance time of existing block for painting effect.\n        fragColor.a = min(1.0, old.a + (1.0 \/ 45.0));\n    }\n#endif\n\n    \/\/ Initialize with paper color.\n    fragColor = iFrame == 0 ? vec4(0.815, 0.815, 0.815, 0) : fragColor;\n}\n","name":"Buffer C","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"XsfGzH","date":"1362167366","viewed":21976,"name":"Star Nursery","username":"Dave_Hoskins","description":"Reminded me of Hubble Star-Nursery images, well, a little bit anyway.\n\nJust sit and watch it full screen for a while, and feel the interstellar beginnings wash over you! :) ","likes":271,"published":3,"flags":64,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"\/media\/a\/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"\/media\/ap\/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xds3Rn","filepath":"https:\/\/soundcloud.com\/bumani\/berlin-cocktail-bar-transit","previewfilepath":"https:\/\/soundcloud.com\/bumani\/berlin-cocktail-bar-transit","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"\/media\/a\/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"\/media\/ap\/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":3,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Built from the basics of'Clouds' Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ Edited by Dave Hoskins into \"Star Nursery\"\n\/\/ V.1.1 Some speed up in the ray-marching loop.\n\n\/\/#define USE_3D_TEXTURE\n\n\nmat3 m = mat3( 0.30,  0.90,  0.60,\n              -0.90,  0.36, -0.48,\n              -0.60, -0.48,  0.34 );\n#define time (iTime+46.0)\n\n\/\/----------------------------------------------------------------------\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\nfloat hash2( vec2 p )\n{\n    return fract(sin(p.x+1131.1*p.y)*3751.5453);\n}\n\/\/----------------------------------------------------------------------\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n\n    float res = mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n\n    return res;\n}\n\n\/\/----------------------------------------------------------------------\nfloat noise( in vec3 x )\n{\n    #ifdef USE_3D_TEXTURE\n\n    \/\/ 3D texture\n    return texture(iChannel2, x*.032, 0.0).x*1.06;\n    \n\t#else\n    \n    \/\/ Use 2D texture...\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv+ 0.5)\/256.0, -99.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n    \n    \n    #endif\n}\n\n\/\/----------------------------------------------------------------------\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 1.600*noise( p ); p = m*p*2.02;\n    f += 0.3500*noise( p ); p = m*p*2.33;\n    f += 0.2250*noise( p ); p = m*p*2.03;\n    f += 0.0825*noise( p ); p = m*p*2.01;\n    return f;\n}\n\n\/\/----------------------------------------------------------------------\nvec4 map( in vec3 p )\n{\n\tfloat d = 0.01- p.y;\n\n\tfloat f= fbm( p*1.0 - vec3(.4,0.3,-0.3)*time);\n\td += 4.0 * f;\n\n\td = clamp( d, 0.0, 1.0 );\n\t\n\tvec4 res = vec4( d );\n\tres.w = pow(res.y, .1);\n\n\tres.xyz = mix( .7*vec3(1.0,0.4,0.2), vec3(0.2,0.0,0.2), res.y * 1.);\n\tres.xyz = res.xyz + pow(abs(.95-f), 26.0) * 1.85;\n\treturn res;\n}\n\n\n\/\/----------------------------------------------------------------------\nvec3 sundir = vec3(1.0,0.4,0.0);\nvec4 raymarch( in vec3 ro, in vec3 rd, in vec2 uv)\n{\n\tvec4 sum = vec4(0, 0, 0, 0);\n\n\t\/\/float t = texture(iChannel3, rd.xy*3131.).x*.2;\n    float t = hash2(uv*11.*rd.xy)*.1;\n\tvec3 pos = vec3(0.0, 0.0, 0.0);\n\tfor(int i=0; i<130; i++)\n\t{\n\t\tif (sum.a > 0.8 || pos.y > 9.0 || pos.y < -2.0) continue;\n\t\tpos = ro + t*rd;\n\n\t\tvec4 col = map( pos );\n\t\t\n\t\t\/\/ Accumulate the alpha with the colour...\n\t\tcol.a *= 0.08;\n\t\tcol.rgb *= col.a;\n\n\t\tsum = sum + col*(1.0 - sum.a);\t\n    \tt += max(0.1,0.02*t);\n\t}\n\tsum.xyz \/= (0.003+sum.w);\n\n\treturn clamp( sum, 0.0, 1.0 );\n}\n\n\/\/----------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy \/ iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x\/ iResolution.y;\n    vec2 mo = (-1.0 + 2.0 + iMouse.xy) \/ iResolution.xy;\n    \n    \/\/ Camera code...\n    vec3 ro = 5.6*normalize(vec3(cos(2.75-3.0*mo.x), .4-1.3*(mo.y-2.4), sin(2.75-2.0*mo.x)));\n\tvec3 ta = vec3(.0, 5.6, 2.4);\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n\t\/\/ Ray march into the clouds adding up colour...\n    vec4 res = raymarch( ro, rd, fragCoord );\n\t\n\n\tfloat sun = clamp( dot(sundir,rd), 0.0, 2.0 );\n\tvec3 col = mix(vec3(.3,0.0,0.05), vec3(0.2,0.2,0.3), sqrt(max(rd.y, 0.001)));\n\tcol += .4*vec3(.4,.2,0.67)*sun;\n\tcol = clamp(col, 0.0, 1.0);\n\tcol += 0.43*vec3(.4,0.4,0.2)*pow( sun, 21.0 );\n\t\n\t\/\/ Do the stars...\n\tfloat v = 1.0\/( 2. * ( 1. + rd.z ) );\n\tvec2 xy = vec2(rd.y * v, rd.x * v);\n    rd.z += time*.002;\n    float s = noise(rd.xz*134.0);\n\ts += noise(rd.xz*370.);\n\ts += noise(rd.xz*870.);\n\ts = pow(s,19.0) * 0.00000001 * max(rd.y, 0.0);\n\tif (s > 0.0)\n\t{\n\t\tvec3 backStars = vec3((1.0-sin(xy.x*20.0+time*13.0*rd.x+xy.y*30.0))*.5*s,s, s); \n\t\tcol += backStars;\n\t}\n\n\t\/\/ Mix in the clouds...\n\tcol = mix( col, res.xyz, res.w*1.3);\n\t\n\t#define CONTRAST 1.1\n\t#define SATURATION 1.15\n\t#define BRIGHTNESS 1.03\n\tcol = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), col*BRIGHTNESS)), col*BRIGHTNESS, SATURATION), CONTRAST);\n    \n    fragColor = vec4( col, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4ljGD1","date":"1428650127","viewed":21825,"name":"Waves Remix","username":"ADOB","description":"simple audio visualizer (also pretty without audio) based upon \"waves\" by bonniem, with added travelling pulse effect, color cycling, and of course, the requested audio sensitivity. Each wave is particularly responsive to a specific range of frequencies.","likes":157,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4sXGRr","filepath":"\/media\/a\/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"\/media\/ap\/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"float squared(float value) { return value * value; }\n\nfloat getAmp(float frequency) { return texture(iChannel0, vec2(frequency \/ 512.0, 0)).x; }\n\nfloat getWeight(float f) {\n    return (+ getAmp(f-2.0) + getAmp(f-1.0) + getAmp(f+2.0) + getAmp(f+1.0) + getAmp(f)) \/ 5.0; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 uvTrue = fragCoord.xy \/ iResolution.xy;\n    vec2 uv = -1.0 + 2.0 * uvTrue;\n    \n\tfloat lineIntensity;\n    float glowWidth;\n    vec3 color = vec3(0.0);\n    \n\tfor(float i = 0.0; i < 5.0; i++) {\n        \n\t\tuv.y += (0.2 * sin(uv.x + i\/7.0 - iTime * 0.6));\n        float Y = uv.y + getWeight(squared(i) * 20.0) *\n            (texture(iChannel0, vec2(uvTrue.x, 1)).x - 0.5);\n        lineIntensity = 0.4 + squared(1.6 * abs(mod(uvTrue.x + i \/ 1.3 + iTime,2.0) - 1.0));\n\t\tglowWidth = abs(lineIntensity \/ (150.0 * Y));\n\t\tcolor += vec3(glowWidth * (2.0 + sin(iTime * 0.13)),\n                      glowWidth * (2.0 - sin(iTime * 0.23)),\n                      glowWidth * (2.0 - cos(iTime * 0.19)));\n\t}\t\n\t\n\tfragColor = vec4(color, 1.0);\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"WlcyD7","date":"1609185361","viewed":21723,"name":"TIE Fighters","username":"dean_the_coder","description":"It was a fine line between creating a scene with\nTIE Fighters or X-Wings. TIE Fighters won.\n\nScene duration: 40 secs","likes":70,"published":3,"flags":0,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ 'TIE Fighters' dean_the_coder (Twitter: @deanthecoder)\n\/\/ https:\/\/www.shadertoy.com\/view\/WlcyD7\n\/\/\n\/\/ Processed by 'GLSL Shader Shrinker'\n\/\/ (https:\/\/github.com\/deanthecoder\/GLSLShaderShrinker)\n\/\/\n\/\/ It was a fine line between creating a scene with\n\/\/ TIE Fighters or X-Wings. TIE Fighters won.\n\/\/ I'm quite happy with the modelling in this one,\n\/\/ but definitely want to practice terrains some more.\n\/\/\n\/\/ I've switched to using hash functions which don't\n\/\/ rely on trig functions. Hopefully that will reduce\n\/\/ differences on different platforms...\n\/\/\n\/\/ Tricks to get the performance:\n\/\/  - The TIE SDF code bails early if the raymarching point\n\/\/    is 'too far away', so no time wasted calculating the SDF\n\/\/    of all the fine details when not necessary.\n\/\/    See sdTie()\n\/\/  - Shadows are only cast by the TIEs (See calcShadow())\n\/\/    so I don't have to render the entire scene too many times.\n\/\/  - The ray is only reflected if it hits glass or metal, and then\n\/\/    marched only if it points down. (So we don't reflect the sky.)\n\/\/  - I have two normal-calculating functions. One for the TIEs,\n\/\/    and one for the terrain. Once the ray has hit an object,\n\/\/    the relevant 'normal' code is called.\n\/\/  - The high frequency noise is added to the terrain during the\n\/\/    color look-up phase. Only the low frequency noise is added to\n\/\/    the SDF.\n\/\/\n\/\/ Things I _could_ do:\n\/\/  - Split the TIE modelling into two functions, one for just\n\/\/    the wings and cockpit, and another which extends it to\n\/\/    include the finer details.\n\/\/    The 'simple' version could be used to generate the shadows.\n\/\/\n\/\/ Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n\/\/ and a bunch of others for sharing their knowledge!\n\n\/\/ License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat T, g;\nstruct Hit {\n\tfloat d;\n\tint id;\n\tvec3 uv;\n};\n\n\/\/ Thanks Dave Hoskins - https:\/\/www.shadertoy.com\/view\/4djSRW\nvec4 hash44(vec4 p4) {\n\tp4 = fract(p4 * vec4(.1031, .103, .0973, .1099));\n\tp4 += dot(p4, p4.wzxy + 33.33);\n\treturn fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\n\/\/ Thanks Shane - https:\/\/www.shadertoy.com\/view\/lstGRB\nfloat n31(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(hash44(h), hash44(h + s.x), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nvoid minH(inout Hit a, Hit b) { if (b.d < a.d) a = b; }\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvec2 opModPolar(vec2 p, float n, float o) {\n\tfloat angle = 3.141 \/ n,\n\t      a = mod(atan(p.y, p.x) + angle + o, 2. * angle) - angle;\n\treturn length(p) * vec2(cos(a), sin(a));\n}\n\nfloat sdHex(vec3 p, vec2 h) {\n\tconst vec3 k = vec3(-.866, .5, .577);\n\tp = abs(p);\n\tp.xy -= 2. * min(dot(k.xy, p.xy), 0.) * k.xy;\n\tvec2 d = vec2(length(p.xy - vec2(clamp(p.x, -k.z * h.x, k.z * h.x), h.x)) * sign(p.y - h.x), p.z - h.y);\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat sdPlane(vec3 p, vec3 n) { return dot(p, n); }\n\nfloat dot2(vec3 a) { return dot(a, a); }\n\nfloat sdTri(vec3 p, vec3 a, vec3 b, vec3 c) {\n\tvec3 ba = b - a,\n\t     pa = p - a,\n\t     cb = c - b,\n\t     pb = p - b,\n\t     ac = a - c,\n\t     pc = p - c,\n\t     n = cross(ba, ac);\n\treturn sqrt((sign(dot(cross(ba, n), pa)) + sign(dot(cross(cb, n), pb)) + sign(dot(cross(ac, n), pc)) < 2.) ? min(min(dot2(ba * clamp(dot(ba, pa) \/ dot2(ba), 0., 1.) - pa), dot2(cb * clamp(dot(cb, pb) \/ dot2(cb), 0., 1.) - pb)), dot2(ac * clamp(dot(ac, pc) \/ dot2(ac), 0., 1.) - pc)) : dot(n, pa) * dot(n, pa) \/ dot2(n));\n}\n\nfloat sdCyl(vec3 p, vec2 hr) {\n\tvec2 d = abs(vec2(length(p.xy), p.z)) - hr;\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t     r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nHit sdWings(vec3 p) {\n\tp.xy = abs(p.xy);\n\tp.z = abs(p.z) - 2.3;\n\treturn Hit(min(sdTri(p, vec3(0), vec3(2, 3, 0), vec3(-2, 3, 0)), sdTri(p, vec3(0), vec3(3.3, 0, 0), vec3(2, 3, 0))) - .03, 2, p);\n}\n\nHit sdTie(vec3 p) {\n\tp = p.zyx - vec3(10, 0, 0);\n\n\t\/\/ Wings.\n\tHit h = sdWings(p);\n\tif (h.d > 2.5) return h; \/\/ Bail early - Point is too far away.\n\t\/\/ Wing ribs.\n\tvec3 op = p;\n\tp.xy = abs(p.xy);\n\tp.z = abs(p.z) - 2.3;\n\tfloat f,\n\t      d = 0.;\n\tif ((f = abs(p.y)) < .1) d = .03 + step(f, .025) * .02;\n\telse if ((f = abs(p.y - p.x * 1.5)) < .15) d = .03 + step(f, .025) * .02;\n\telse if (abs(p.y - 3.) < .1) d = .03;\n\telse if (abs(p.x - 3.3 + p.y * .43) < .1) d = .03;\n\n\tif (d > 0.) {\n\t\th.d -= d;\n\t\th.id = 1;\n\t}\n\n\t\/\/ Wing center hexes.\n\td = min(sdHex(p, vec2(.7, .06)), sdHex(p, vec2(.5, .12)));\n\n\t\/\/ Crossbar.\n\td = min(d, sdCyl(op, vec2(mix(.21, .23, step(p.y, .04)), 2.3))); \/\/ Main bar\n\tp.z = abs(p.z + .8) - .5;\n\tf = sdCyl(p, vec2(mix(.21, .33, (p.z + .33) \/ .48), .24));\n\tp.x -= .25;\n\tp.z += .02;\n\td = min(d, max(f, -sdBox(p, vec3(.1, .4, .08)))); \/\/ Join to wing\/cockpit.\n\tp = op;\n\tp.yz = abs(p.yz);\n\tminH(h, Hit(min(d, sdTri(p, vec3(0), vec3(0, .8, 0), vec3(0, 0, 2)) - .05), 1, p)); \/\/ Triangle cockpit supports.\n\t\/\/ Cockpit - Sphere.\n\tf = step(.75, p.y);\n\tminH(h, Hit(length(op) - .9 - .02 * (f + step(p.y, .03) + f * step(p.z, .1)), 6, p));\n\n\t\/\/ Cockpit - Glass.\n\tp = op;\n\tp.x += .27;\n\tp.yz = opModPolar(p.yz, 8., .4);\n\tminH(h, Hit(max(length(p) - .7, sdPlane(p + vec3(.77, 0, 0), vec3(vec2(-1, 0) * rot(.5), 0))), 3, p));\n\n\t\/\/ Cockpit - Window frame.\n\tminH(h, Hit(max(length(p) - .71, .45 - length(p.yz)), 5, p));\n\n\t\/\/ Gunz.\n\tp = op;\n\tp.x += .7;\n\tp.y += .6;\n\tp.z = abs(p.z) - .2;\n\tminH(h, Hit(sdCyl(p.zyx, vec2(.05, .2)), 7, p));\n\treturn h;\n}\n\n\/\/ Position of the lead TIE.\nvec3 tiePos(vec3 p, float t) {\n\tfloat x = cos(t * .7);\n\tp += vec3(x, cos(t), sin(t * 1.1));\n\tp.xy *= rot(x * -.1);\n\treturn p;\n}\n\nHit sdTies(vec3 p) {\n\tvec3 op = p;\n\n\t\/\/ Front tie.\n\tp = tiePos(p, T);\n\tHit h = sdTie(p);\n\tif (sin(T) - step(T, 0.) * 10. > -.7) {\n\t\t\/\/ Weapon fire.\n\t\tp.x = abs(p.x) - .2;\n\t\tp.y += .6;\n\t\tp.z = mod(p.z + T * 50., 8.) - 4.;\n\t\tfloat x = max(sdCyl(p, vec2(.03, 1)), op.z - 8.);\n\t\tminH(h, Hit(x, 9, p));\n\t\tg += .001 \/ (.01 + x * x);\n\t}\n\n\t\/\/ Rear tie.\n\tif (h.d > .0015) {\n\t\tfloat x = -cos(T);\n\t\tp = op + vec3(14, -4. - .5 * cos(T * .5), -20. + 4. * sin(T * .6));\n\t\tp.xy *= rot(x * -.1);\n\t\tminH(h, sdTie(p));\n\t}\n\n\treturn h;\n}\n\nHit sdTerrain(vec3 p) {\n\tp.z -= T * 7e2; \/\/ Number controls the terrain speed.\n\tvec2 d = sin(p.xz * vec2(.01476, .01345)) * 10. + sin(p.xz * vec2(.05212, .04512)) * 2.;\n\treturn Hit(abs(p.y - d.x + d.y + 25.), 4, p);\n}\n\nHit map(vec3 p) {\n\tHit h = sdTerrain(p);\n\tminH(h, sdTies(p));\n\treturn h;\n}\n\nvec3 calcN(vec3 p, float t) {\n\tfloat h = t * .2;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3((((i + 3) >> 1) & 1), (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * sdTies(p + e * h).d;\n\t}\n\n\treturn normalize(n);\n}\n\n\/\/ Terrian normal.\n\/\/ (Special case, but faster than using the SDF for the entire scene.)\nvec3 calcTN(vec3 p, float t) {\n\tfloat h = t * 2.;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3((((i + 3) >> 1) & 1), (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * sdTerrain(p + e * h).d;\n\t}\n\n\treturn normalize(n);\n}\n\n\/\/ Note: For performance, shadows are only cast by tie fighters.\nfloat calcShadow(vec3 p, vec3 ld) {\n\t\/\/ Thanks iq.\n\tfloat s = 1.,\n\t      t = 1.;\n\tfor (float i = 0.; i < 30.; i++) {\n\t\tfloat h = sdTies(p + ld * t).d;\n\t\ts = min(s, 30. * h \/ t);\n\t\tt += h;\n\t\tif (s < .001 || t > 1e2) break;\n\t}\n\n\treturn clamp(s, 0., 1.);\n}\n\n\/\/ Note: For performance, occlusion only applied to tie fighters.\nfloat ao(vec3 p, vec3 n, float h) { return clamp(sdTies(p + h * n).d \/ h, 0., 1.); }\n\n\/\/ Sub-surface scattering (Applied to the snow).\n#define SSS(h)\tclamp(sdTerrain(p + ld * h).d \/ h, 0., 1.)\n\n\/**********************************************************************************\/\nvec3 vignette(vec3 c, vec2 fc) {\n\tvec2 q = fc.xy \/ iResolution.xy;\n\tc *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn c;\n}\n\nvec3 lights(vec3 p, vec3 rd, float d, Hit h) {\n\tfloat am, ldt, l, spe,\n\t      sped = 4.;\n\tvec3 c, n, lig,\n\t     ld = normalize(vec3(30, 50, -40) - p);\n\tif (h.id == 4) {\n\t\t\/\/ Snow\n\t\tc = vec3(1.2 + SSS(1.) * .44);\n\t\tn = normalize(calcTN(p, d) + n31(h.uv) * .1);\n\t\tam = mix(.3, .9, sdTerrain(p + n).d);\n\t\tsped = .4;\n\t}\n\telse {\n\t\tn = calcN(p, d);\n\t\tam = mix(ao(p, n, .5), ao(p, n, 1.2), .75);\n\t\tif (h.id == 1 || h.id == 6) {\n\t\t\t\/\/ Metal\n\t\t\tc = vec3(.3 - n31(h.uv * 18.7) * .1);\n\t\t\tsped = .5;\n\t\t\tif (h.id == 6) c *= 1. - .8 * step(abs(atan(h.uv.y, h.uv.z) - .8), .01); \/\/ Cockpit.\n\t\t}\n\t\telse if (h.id == 2) {\n\t\t\t\/\/ Black wing area.\n\t\t\tif (h.uv.x < h.uv.y * .7) h.uv.y = 0.;\n\t\t\tc = vec3(.005 + .045 * pow(abs(sin((h.uv.x - h.uv.y) * 12.)), 20.));\n\t\t\tsped = .2;\n\t\t}\n\t\telse if (h.id == 7) {\n\t\t\t\/\/ Gunz.\n\t\t\tc = vec3(.02);\n\t\t\tsped = .2;\n\t\t}\n\t\telse if (h.id == 3) c = vec3(.05); \/\/ Cockpit glass.\n\t\telse if (h.id == 5) c = vec3(.1); \/\/ Glass surround.\n\t\telse c = vec3(.3, 1, .3); \/\/ Fire!\n\t}\n\n\t\/\/ Primary light.\n\tldt = dot(ld, n);\n\tl = max(0., .2 + .8 * ldt) + max(0., .2 - .8 * ldt) * .3;\n\tspe = smoothstep(0., 1., pow(max(0., dot(rd, reflect(ld, n))), 50.)) * sped;\n\n\t\/\/ Combine.\n\tlig = l * am * mix(.4, 1., calcShadow(p, ld)) * vec3(2, 1.8, 1.7) + clamp(n.y, .05, 1.) * vec3(.9, .95, 1); \/\/ Sky light.\n\treturn c * lig + spe;\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n\t\/\/ Raymarch.\n\tvec3 p, c;\n\tfloat gg,\n\t      d = .01;\n\tHit h;\n\tfor (float i = 0.; i < 120.; i++) {\n\t\tp = ro + rd * d;\n\t\th = map(p);\n\t\tif (abs(h.d) < .0015 || d > 6e2) break;\n\t\td += h.d; \/\/ No hit, so keep marching.\n\t}\n\n\tgg = g; \/\/ Cache the 'glow'.\n\tif (d > 6e2) c = vec3(.85, .9, 1);\n\telse c = mix(lights(p, rd, d, h), vec3(1), smoothstep(2e2, 540., d));\n\n\tc += gg * vec3(0, 1, 0);\n\tif (h.id == 3 || h.id == 1) {\n\t\t\/\/ Reflections applied to cockpit glass and tie metal.\n\t\trd = reflect(rd, calcN(p, d));\n\t\tfloat alpha = (h.id == 3 ? .4 : .2) * smoothstep(0., 1., -rd.y);\n\t\tif (alpha < .001) return c; \/\/ Only reflect downwards.\n\t\td = .01;\n\t\tro = p;\n\t\tfor (float i = 0.; i < 40.; i++) {\n\t\t\tp = ro + rd * d;\n\t\t\th = sdTerrain(p);\n\t\t\tif (abs(h.d) < .0015 || d > 3e2) break;\n\t\t\td += h.d; \/\/ No hit, so keep marching.\n\t\t}\n\n\t\t\/\/ Combine a % of the reflected color.\n\t\tc = mix(c, d > 3e2 ? vec3(1) : lights(p, rd, d, h), alpha);\n\t}\n\n\treturn c;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tT = mod(iTime, 40.) - 4.;\n\tg = 0.;\n\tfloat t = smoothstep(0., 5., T);\n\tvec3 lookAt = mix(vec3(0, 0, 6) - tiePos(vec3(0), T - .2), vec3(2.5, 0, 0), t),\n\t     ro = mix(lookAt - vec3(0, 0, 1), vec3(4. + cos(T), sin(T) * .2, -8. + cos(T * .2) * 6.), t);\n\tfragColor = vec4(vignette(pow(march(ro, getRayDir(ro, lookAt, (fc - .5 * iResolution.xy) \/ iResolution.y)), vec3(.45)), fc), 0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"Xs2fWD","date":"1500929190","viewed":21643,"name":"[SH17B] Pixel Shader Dungeon","username":"knarkowicz","description":"Greetings adventurer!\nControls: arrow keys\nTIPs:\n-Attack by walking into enemies\n-Walk into a wall to skip a turn\n-Time movement to attack first\n-Lure enemies into traps\nBased on \"Pixel Dungeon\" (http:\/\/pixeldungeon.watabou.ru\/)","likes":211,"published":3,"flags":112,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"\/media\/a\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"\/media\/ap\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"\/media\/previz\/buffer03.png","previewfilepath":"\/media\/previz\/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Based on \"Pixel Dungeon\" (http:\/\/pixeldungeon.watabou.ru\/)\n\nconst float TICK_NUM\t\t\t= 10.;\nconst float TILE_FLOOR\t\t\t= 1.;\nconst float TILE_DOOR_OPEN\t\t= 2.;\nconst float TILE_STAIRS_DOWN\t= 3.;\nconst float TILE_TRAP\t\t\t= 4.;\nconst float TILE_TRAP_OFF\t\t= 5.;\nconst float TILE_WALL\t\t\t= 6.;\nconst float TILE_WALL_HOLE\t\t= 7.;\nconst float TILE_DOOR_LOCKED\t= 8.;\nconst float TILE_STAIRS_UP\t\t= 9.;\nconst float ITEM_KEY\t\t\t= 1.;\nconst float ITEM_POTION\t\t\t= 2.;\nconst float ITEM_SPAWNER\t\t= 3.;\nconst float LOG_ID_DMG\t\t\t= 1.;\nconst float LOG_ID_XP\t\t\t= 2.;\nconst float LOG_ID_LEVEL_UP\t\t= 3.;\nconst float STATE_START\t\t\t= 0.;\nconst float STATE_GAME\t\t\t= 1.;\nconst float STATE_NEXT_LEVEL\t= 2.;\nconst float STATE_GAME_OVER\t\t= 3.;\n\nconst vec2  REF_RES\t            = vec2( 200. );\n\nconst int   ENEMY_NUM\t\t\t= 3;\nconst int   LOG_NUM\t\t\t\t= 4;\n\nstruct GameState\n{\n    \/\/ 0   \n    float\ttick;\n    float \thp;\n    float \tlevel;\n    float \txp;\n    float \tkeyNum;\n    \n\t\/\/ 1\n    vec2 \tplayerPos;\n    float   playerFrame;\n    float   playerDir;\n    vec2\tbodyPos;\n    float   bodyId;\n    \n    \/\/ 2\n    float \tstate;\n    float   keyLock;\n    float \tstateTime;\n    vec2\tdespawnPos;\n    float   despawnId;\n\n    \/\/ 3\n    vec2\tenemyPos[ ENEMY_NUM ];\n    float \tenemyFrame[ ENEMY_NUM ];\n    float \tenemyDir[ ENEMY_NUM ];\n    float \tenemyHP[ ENEMY_NUM ];\n    float \tenemyId[ ENEMY_NUM ];\n    vec2    enemySpawnPos[ ENEMY_NUM ];\n    \n    \/\/ 4\n    vec2\tlogPos[ LOG_NUM ];\n    float   logLife[ LOG_NUM ];\n    float   logId[ LOG_NUM ];\n    float   logVal[ LOG_NUM ];\n};\n\nvec4 LoadValue( int x, int y )\n{\n    return texelFetch( iChannel0, ivec2( x, y ), 0 );\n}    \n\nfloat PackXY( float a, float b )\n{\n    return floor( a ) + floor( b ) \/ 256.;\n}\n\nfloat PackXY( vec2 v )\n{\n    return PackXY( v.x, v.y );\n}\n\nfloat UnpackX( float a )\n{\n    return floor( a );\n}\n\nfloat UnpackY( float a )\n{\n    return fract( a ) * 256.;\n}\n\nvec2 UnpackXY( float a )\n{\n    return vec2( UnpackX( a ), UnpackY( a ) );\n}\n\nvoid LoadState( out GameState s )\n{\n    vec4 data;\n\n    data = LoadValue( 0, 0 );\n    s.tick \t\t= data.x;\n    s.hp    \t= UnpackX( data.y );\n    s.level    \t= UnpackY( data.y );\n    s.xp        = data.z;\n    s.keyNum    = data.w;\n    \n    data = LoadValue( 1, 0 );\n    s.playerPos   = UnpackXY( data.x );\n    s.playerFrame = UnpackX( data.y );\n    s.playerDir   = UnpackY( data.y );\n    s.bodyPos\t  = UnpackXY( data.z );\n    s.bodyId      = data.w;\n    \n    data = LoadValue( 2, 0 );\n    s.state      = UnpackX( data.x );\n    s.keyLock    = UnpackY( data.x );\n    s.stateTime  = data.y;\n    s.despawnPos = UnpackXY( data.z );\n    s.despawnId  = data.w;\n\n    for ( int i = 0; i < ENEMY_NUM; ++i )\n    {\n        data = LoadValue( 3, i );\n        s.enemyPos[ i ]      = UnpackXY( data.x );\n        s.enemyFrame[ i ]    = UnpackX( data.y );\n        s.enemyDir[ i ]      = UnpackY( data.y );\n        s.enemyHP[ i ]       = UnpackX( data.z );\n        s.enemyId[ i ]       = UnpackY( data.z );\n        s.enemySpawnPos[ i ] = UnpackXY( data.w );\n    }\n    \n    for ( int i = 0; i < LOG_NUM; ++i )\n    {\n\t\tdata = LoadValue( 4, i );\n    \ts.logPos[ i ]  = data.xy;\n        s.logLife[ i ] = data.z;\n        s.logId[ i ]   = UnpackX( data.w );\n        s.logVal[ i ]  = UnpackY( data.w );\n    }    \n}\n\nfloat saturate( float x )\n{\n    return clamp( x, 0., 1. );\n}\n\nfloat Smooth( float x )\n{\n\treturn smoothstep( 0., 1., saturate( x ) );   \n}\n\nvoid SpriteKey( inout vec3 color, vec2 p )\n{\n    p -= vec2( 5., 2. );\n    p = p.x < 0. ? vec2( 0. ) : p;    \n    \n    int v = 0;\n\tv = p.y == 11. ? ( p.x < 8. ? 139824 : 0 ) : v;\n\tv = p.y == 10. ? ( p.x < 8. ? 2232611 : 0 ) : v;\n\tv = p.y == 9. ? ( p.x < 8. ? 1179666 : 0 ) : v;\n\tv = p.y == 8. ? ( p.x < 8. ? 1245202 : 0 ) : v;\n\tv = p.y == 7. ? ( p.x < 8. ? 1192482 : 0 ) : v;\n\tv = p.y == 6. ? ( p.x < 8. ? 74256 : 0 ) : v;\n\tv = p.y == 5. ? ( p.x < 8. ? 4608 : 0 ) : v;\n\tv = p.y == 4. ? ( p.x < 8. ? 4608 : 0 ) : v;\n\tv = p.y == 3. ? ( p.x < 8. ? 4608 : 0 ) : v;\n\tv = p.y == 2. ? ( p.x < 8. ? 2232832 : 0 ) : v;\n\tv = p.y == 1. ? ( p.x < 8. ? 135680 : 0 ) : v;\n\tv = p.y == 0. ? ( p.x < 8. ? 2232832 : 0 ) : v;\n    float i = float( ( v >> int( 4. * p.x ) ) & 15 );\n    color = i == 1. ? vec3( 0.45 ) : color;\n    color = i == 2. ? vec3( 0.83 ) : color;\n    color = i == 3. ? vec3( 0.95 ) : color;\n}\n\nvec2 FrameOffset( float frame, float tick )\n{\n    vec2 ret = vec2( 0. );\n    ret.x = frame == 1. ? 1. : ( frame == 2. ? -1. : 0. );\n    ret.y = frame == 3. ? 1. : ( frame == 4. ? -1. : 0. );\n    return floor( 16. * ret * ( tick \/ TICK_NUM ) );\n}\n\nfloat EnemyHP( float id )\n{\n    return 8. + id * 15.;\n}\n\nfloat MaxXP( float level )\n{\n\treturn 10. + level * 5.;\t   \n}\n\nfloat MaxHP( float level )\n{\n\treturn 21. + level * 3.;\t   \n}\n\nfloat TextSDF( vec2 p, float glyph )\n{\n    p = abs( p.x - .5 ) > .5 || abs( p.y - .5 ) > .5 ? vec2( 0. ) : p;\n    return texture( iChannel3, p \/ 16. + fract( vec2( glyph, 15. - floor( glyph \/ 16. ) ) \/ 16. ) ).w - 127. \/ 255.;\n}\n\nvoid PrintChar( inout float sdf, inout vec2 p, float c )\n{\n    p.x -= 4.;\n    sdf = min( sdf, TextSDF( p * .1, c ) );\n}\n\nvoid PrintVal( inout float sdf, inout vec2 p, float val )\n{\n    if ( val > 9. )\n    {\n        p.x -= 4.;\n        float d = floor( val * 0.1 );\n        sdf = min( sdf, TextSDF( p * .1, 48. + d ) );\n        val -= d * 10.;\n    }\n    \n    p.x -= 4.;\n\tsdf = min( sdf, TextSDF( p * .1, 48. + val ) );\n}\n\nvoid RastText( inout vec3 color, float t, float l, vec3 textColor )\n{\n    float alpha = Smooth( 1. - ( 2. * l - 1. ) );\n    color = mix( color, vec3( 0. ), saturate( exp( -t * 20. ) ) * alpha );\n    color = mix( color, textColor, Smooth( -t * 100. ) * alpha );    \n}\n\nvoid DrawText( inout vec3 color, vec2 edge, vec2 center, vec2 world, in GameState s )\n{\n    \/\/ xp\n    if ( s.logPos[ 0 ].x > 0. )\n    {\n        float t = 1e4;\n        \n        vec2 p = world;\n        p -= s.logPos[ 0 ] * 16.;\n        p.x += 8.;\n        p.y -= s.logLife[ 0 ] * 16.;\n        PrintChar( t, p, 43. );\n        PrintVal( t, p, s.logVal[ 0 ] );\n        PrintChar( t, p, 69. );\n        PrintChar( t, p, 88. );\n        PrintChar( t, p, 80. );\n        \n\t\tif ( s.logId[ 0 ] > 0. )\n        {\n            p = world;\n            p -= s.logPos[ 0 ] * 16.;\n            p.x += 16.;\n            p.y -= s.logLife[ 0 ] * 16. - 8.;\n           \tPrintChar( t, p, 76. );\n            PrintChar( t, p, 69. );\n            PrintChar( t, p, 86. );\n            PrintChar( t, p, 69. );\n            PrintChar( t, p, 76. );\n            PrintChar( t, p, 32. );\n            PrintChar( t, p, 85. );\n            PrintChar( t, p, 80. );\n            PrintChar( t, p, 33. );\n        }\n        \n        RastText( color, t, s.logLife[ 0 ], vec3( 1., 1., 0. ) );\n    }    \n    \n    \/\/ heal\n    if ( s.logPos[ 1 ].x > 0. )\n    {\n        float t = 1e4; \n        vec2 p = world;\n        p -= s.logPos[ 1 ] * 16.;\n        p.x += 8.;\n        p.y -= s.logLife[ 1 ] * 16.;      \n        PrintChar( t, p, 43. );\n        PrintVal( t, p, s.logVal[ 1 ] );\n        PrintChar( t, p, 72. );\n        PrintChar( t, p, 80. );\n        RastText( color, t, s.logLife[ 1 ], vec3( 0., 1., 0. ) ); \n    }\n    \n    \/\/ dmg\n    for ( int i = 2; i < LOG_NUM; ++i )\n    {\n\t\tfloat t = 1e4;        \n        \n        if ( s.logPos[ i ].x > 0. )\n        {\n            vec2 p = world;\n            p -= s.logPos[ i ] * 16.;\n            p.y -= s.logLife[ i ] * 16.;        \n            PrintVal( t, p, s.logVal[ i ] );\n        }\n        \n        RastText( color, t, s.logLife[ i ], vec3( 1., 0., 0. ) );     \n    }\n    \n    \/\/ game over\n    if ( s.state == STATE_GAME_OVER )\n    {      \n        float alpha = Smooth( ( s.stateTime - 0.33 ) * 4. );\n        \n        color = mix( color, color.yyy * .5, alpha );\n        \n        float t = 1e4; \n        \n        vec2 p = .25 * center;\n        p.x += 24.;\n        p.y += 6.;\n        PrintChar( t, p, 89. );\n        PrintChar( t, p, 79. );\n        PrintChar( t, p, 85. );\n        p.x -= 4.;\n        PrintChar( t, p, 68. );\n        PrintChar( t, p, 73. );\n        PrintChar( t, p, 69. );\n        PrintChar( t, p, 68. );\n        \n        RastText( color, t, 1. - alpha, vec3( 1., 0., 0. ) );     \n    }\n    \n    \/\/ level\n    vec2 p = edge + vec2( 2.2, 20.8 );\n    float t = 1e4;\n    PrintChar( t, p, 48. + s.level + 1. );\n    color = mix( color, vec3( 1. ), Smooth( -t * 100. ) ); \n}\n\nfloat Rectangle( vec2 p, vec2 b )\n{\n    vec2 d = abs( p ) - b;\n    return min( max( d.x, d.y ), 0. ) + length( max( d, 0. ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    GameState s;\n    LoadState( s );    \n    \n    vec2 playerPos = s.playerPos * 16. + FrameOffset( s.playerFrame, s.tick ); \n    \n    vec2 resMult\t= floor( iResolution.xy \/ REF_RES );\n    float resRcp    = 1. \/ max( min( resMult.x, resMult.y ), 1. );\n    vec2 screenSize = floor( iResolution.xy * resRcp );\n    vec2 pixel      = floor( fragCoord.xy * resRcp );\n\tvec2 camera     = clamp( playerPos - floor( screenSize \/ 2. ), vec2( -32. ), vec2( 32. * 16. + 32. ) - screenSize );\n    vec2 world      = pixel + camera;\n    vec2 tile\t\t= floor( world \/ 16. );\n    vec2 worldMod16 = floor( mod( world, 16. ) );\n    vec4 map\t\t= texelFetch( iChannel1, ivec2( tile ), 0 );\n    vec2 edgeFlt\t= fragCoord.xy * resRcp - vec2( 0., screenSize.y );\n    vec2 centerFlt\t= fragCoord.xy * resRcp - screenSize \/ 2.;\n    vec2 worldFlt\t= fragCoord.xy * resRcp - vec2( 0., 16. ) + camera;\n    float fog\t\t= texture( iChannel1, ( tile + worldMod16 \/ 16. ) \/ iChannelResolution[ 0 ].xy ).w;\n    float tick2     = s.tick > TICK_NUM \/ 2. ? 1. : 0.;\n    \n    vec3 color = texelFetch( iChannel2, ivec2( fragCoord ), 0 ).xyz;\n    \n    color *= fog;    \n    float light = length( playerPos + 8. - world );\n\tcolor *= vec3( Smooth( ( 4. * 16. - light ) * .05 ) * .8 + .2 );\n    \n    for ( int i = 0; i < ENEMY_NUM; ++i )\n    {\n        float maxHP = EnemyHP( s.enemyId[ i ] );\n\t\tvec2 enemy = world - s.enemyPos[ i ] * 16. + FrameOffset( s.enemyFrame[ i ], s.tick );        \n        if ( s.enemyPos[ i ].x > 0.\n             && s.enemyHP[ i ] < maxHP\n             && enemy.x >= 0. && enemy.x < 16. && enemy.y - 16. >= 0. && enemy.y - 16. < 2. )\n        {\n            color = enemy.x < 16. * s.enemyHP[ i ] \/ maxHP ? vec3( 0., 1., 0. ) : vec3( 1., 0., 0. );\n        }\n    }\n    \n\tif ( pixel.x >= screenSize.x - 8. - 16. * s.keyNum && pixel.x < screenSize.x - 8. )\n    {\n        SpriteKey( color, vec2( mod( pixel.x - 8., 16. ), pixel.y - screenSize.y + 24. ) );\n    }\n    \n    if ( pixel.y >= screenSize.y - 9. && pixel.x < 4. * MaxHP( s.level ) + 7. + pixel.y - screenSize.y )\n    {\n       \tcolor = vec3( .33, .35, .31 );\n    }\n    if ( pixel.y >= screenSize.y - 8. && pixel.x < 4. * MaxHP( s.level ) + 6. + pixel.y - screenSize.y )\n    {\n       \tcolor = vec3( .64, .65, .58 );\n    }\n    if ( pixel.y >= screenSize.y - 7. && pixel.x < 4. * MaxHP( s.level ) + 5. + pixel.y - screenSize.y )\n    {\n       \tcolor = vec3( .24, .25, .22 );\n    }    \n    if ( pixel.y >= screenSize.y - 3. )\n    {\n  \t\tcolor = vec3( .33, .35, .31 );\n    }\n    if ( pixel.y >= screenSize.y - 2. )\n    {\n  \t\tcolor = vec3( .48, .5, .45 );\n    }    \n    if ( pixel.y >= screenSize.y - 1. )\n    {\n        color = vec3( .24, .25, .22 );\n    }\n    \n    float rect = floor( Rectangle( pixel - vec2( 6., screenSize.y - 16. ), vec2( 5. ) ) );\n    color = rect == 0. ? vec3( .64, .65, .58 ) : color;\n    color = rect == 1. ? vec3( .33, .35, .31 ) : color;\n    color = rect <  0. ? vec3( .24, .25, .22 ) : color;\n    \n    float xpBar = s.xp \/ MaxXP( s.level );\n    if ( pixel.y >= screenSize.y - 1. && pixel.x < screenSize.x * xpBar )\n    {\n        color = mix( vec3( 1., .8, .4 ), vec3( 1. ), pixel.x \/ screenSize.x );\n    } \n    \n    if ( pixel.y >= screenSize.y - 7. && pixel.y < screenSize.y - 3. && pixel.x < 4. * s.hp + 5. + pixel.y - screenSize.y )\n    {\n       color = mix( vec3( .65, .22, .29 ), vec3( .9, .4, .36 ), ( pixel.y - screenSize.y + 5. ) \/ 3. );\n    }\n    \n    if ( pixel.x == 0. && pixel.y >= screenSize.y - 9. && pixel.y < screenSize.y - 2. )\n    {\n       \tcolor = vec3( .33, .35, .31 );\n    }\n    \n    DrawText( color, edgeFlt, centerFlt, worldFlt, s );\n    \n\tfragColor = vec4( color, 1. );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"\/presets\/tex00.jpg","previewfilepath":"\/presets\/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ gameplay loop\n\n\/\/#define EASY_MODE\n\/\/#define KEY_AUTOREPEAT\n\nconst float TICK_NUM\t\t\t= 10.;\nconst float TILE_FLOOR\t\t\t= 1.;\nconst float TILE_DOOR_OPEN\t\t= 2.;\nconst float TILE_STAIRS_DOWN\t= 3.;\nconst float TILE_TRAP\t\t\t= 4.;\nconst float TILE_TRAP_OFF\t\t= 5.;\nconst float TILE_WALL\t\t\t= 6.;\nconst float TILE_WALL_HOLE\t\t= 7.;\nconst float TILE_DOOR_LOCKED\t= 8.;\nconst float TILE_STAIRS_UP\t\t= 9.;\nconst float ITEM_KEY\t\t\t= 1.;\nconst float ITEM_FOOD\t\t\t= 2.;\nconst float ITEM_POTION\t\t\t= 3.;\nconst float ITEM_SPAWNER\t\t= 4.;\nconst float ITEM_SPAWNER_2\t\t= 5.;\nconst float STATE_START\t\t\t= 0.;\nconst float STATE_GAME\t\t\t= 1.;\nconst float STATE_NEXT_LEVEL\t= 2.;\nconst float STATE_GAME_OVER\t\t= 3.;\n\nconst float KEY_LEFT  \t\t\t= 37.5f \/ 256.0f;\nconst float KEY_UP    \t\t\t= 38.5f \/ 256.0f;\nconst float KEY_RIGHT \t\t\t= 39.5f \/ 256.0f;\nconst float KEY_DOWN  \t\t\t= 40.5f \/ 256.0f;\n\nconst int   ENEMY_NUM\t\t\t= 3;\nconst int   LOG_NUM\t\t\t\t= 4;\n\nstruct GameState\n{\n    \/\/ 0   \n    float\ttick;\n    float \thp;\n    float \tlevel;\n    float \txp;\n    float \tkeyNum;\n    \n\t\/\/ 1\n    vec2 \tplayerPos;\n    float   playerFrame;\n    float   playerDir;\n    vec2\tbodyPos;\n    float   bodyId;\n    \n    \/\/ 2\n    float \tstate;\n    float   keyLock;\n    float \tstateTime;\n    vec2\tdespawnPos;\n    float   despawnId;\n\n    \/\/ 3\n    vec2\tenemyPos[ ENEMY_NUM ];\n    float \tenemyFrame[ ENEMY_NUM ];\n    float \tenemyDir[ ENEMY_NUM ];\n    float \tenemyHP[ ENEMY_NUM ];\n    float \tenemyId[ ENEMY_NUM ];\n    vec2    enemySpawnPos[ ENEMY_NUM ];\n    \n    \/\/ 4\n    vec2\tlogPos[ LOG_NUM ];\n    float   logLife[ LOG_NUM ];\n    float   logId[ LOG_NUM ];\n    float   logVal[ LOG_NUM ];\n};\n\nvec4 LoadValue( int x, int y )\n{\n    return texelFetch( iChannel0, ivec2( x, y ), 0 );\n}    \n\nfloat PackXY( float a, float b )\n{\n    return floor( a ) + floor( b ) \/ 256.;\n}\n\nfloat PackXY( vec2 v )\n{\n    return PackXY( v.x, v.y );\n}\n\nfloat UnpackX( float a )\n{\n    return floor( a );\n}\n\nfloat UnpackY( float a )\n{\n    return fract( a ) * 256.;\n}\n\nvec2 UnpackXY( float a )\n{\n    return vec2( UnpackX( a ), UnpackY( a ) );\n}\n\nvoid LoadState( out GameState s )\n{\n    vec4 data;\n\n    data = LoadValue( 0, 0 );\n    s.tick \t\t= data.x;\n    s.hp    \t= UnpackX( data.y );\n    s.level    \t= UnpackY( data.y );\n    s.xp        = data.z;\n    s.keyNum    = data.w;\n    \n    data = LoadValue( 1, 0 );\n    s.playerPos   = UnpackXY( data.x );\n    s.playerFrame = UnpackX( data.y );\n    s.playerDir   = UnpackY( data.y );\n    s.bodyPos\t  = UnpackXY( data.z );\n    s.bodyId      = data.w;\n    \n    data = LoadValue( 2, 0 );\n    s.state      = UnpackX( data.x );\n    s.keyLock    = UnpackY( data.x );\n    s.stateTime  = data.y;\n    s.despawnPos = UnpackXY( data.z );\n    s.despawnId  = data.w;\n\n    for ( int i = 0; i < ENEMY_NUM; ++i )\n    {\n        data = LoadValue( 3, i );\n        s.enemyPos[ i ]      = UnpackXY( data.x );\n        s.enemyFrame[ i ]    = UnpackX( data.y );\n        s.enemyDir[ i ]      = UnpackY( data.y );\n        s.enemyHP[ i ]       = UnpackX( data.z );\n        s.enemyId[ i ]       = UnpackY( data.z );\n        s.enemySpawnPos[ i ] = UnpackXY( data.w );\n    }\n    \n    for ( int i = 0; i < LOG_NUM; ++i )\n    {\n\t\tdata = LoadValue( 4, i );\n    \ts.logPos[ i ]  = data.xy;\n        s.logLife[ i ] = data.z;\n        s.logId[ i ]   = UnpackX( data.w );\n        s.logVal[ i ]  = UnpackY( data.w );\n    }    \n}\n\nvoid StoreValue( vec2 re, vec4 va, inout vec4 fragColor, vec2 fragCoord )\n{\n    fragCoord = floor( fragCoord );\n    fragColor = ( fragCoord.x == re.x && fragCoord.y == re.y ) ? va : fragColor;\n}\n\nvec4 SaveState( in GameState s, in vec2 fragCoord, bool reset )\n{\n    vec4 ret = vec4( 0. );\n    StoreValue( vec2( 0., 0. ), vec4( s.tick, PackXY( s.hp, s.level ), s.xp, s.keyNum ), ret, fragCoord );\n    StoreValue( vec2( 1., 0. ), vec4( PackXY( s.playerPos ), PackXY( s.playerFrame, s.playerDir ), PackXY( s.bodyPos ), s.bodyId ), ret, fragCoord );\n    StoreValue( vec2( 2., 0. ), vec4( PackXY( s.state, s.keyLock ), s.stateTime, PackXY( s.despawnPos ), s.despawnId ), ret, fragCoord );\n\n    for ( int i = 0; i < ENEMY_NUM; ++i )\n    {\n        StoreValue( vec2( 3., float( i ) ), \n                   vec4( PackXY( s.enemyPos[ i ] ), \n                         PackXY( s.enemyFrame[ i ], s.enemyDir[ i ] ), \n                         PackXY( s.enemyHP[ i ], s.enemyId[ i ] ),\n                         PackXY( s.enemySpawnPos[ i ] ) ), ret, fragCoord );\n    }\n    \n    for ( int i = 0; i < LOG_NUM; ++i )\n    {\n        StoreValue( vec2( 4., float( i ) ), vec4( s.logPos[ i ], s.logLife[ i ], PackXY( s.logId[ i ], s.logVal[ i ] ) ), ret, fragCoord );\n    }\n\n\tif ( reset )    \n    {\n        ret = vec4( 0. );\n\t\tStoreValue( vec2( 0., 0. ), vec4( 0., 21., 0., 0. ), ret, fragCoord );        \n        StoreValue( vec2( 1., 0. ), vec4( PackXY( 3., 2. ), 0., 0., 0. ), ret, fragCoord );\n        StoreValue( vec2( 2., 0. ), vec4( s.state, 0., 0., 0. ), ret, fragCoord );\n    }\n    \n    return ret;\n}\n\nvoid LogDmg( inout GameState s, vec2 pos, float val )\n{\n    float maxLife = -1.;\n    if ( s.logPos[ 2 ].x > 0. && s.logPos[ 3 ].x > 0. )\n    {\n        maxLife = max( s.logLife[ 2 ], s.logLife[ 3 ] );\n    }\n    \n    for ( int i = 2; i < LOG_NUM; ++i )\n    {\n        if ( s.logPos[ i ].x <= 0. || maxLife == s.logLife[ i ] )\n        {\n            s.logPos[ i ]  = pos;\n            s.logLife[ i ] = 0.;\n            s.logId[ i ]   = 0.;\n            s.logVal[ i ]  = val;            \n            break;\n        }\n    }   \n}\n\nvoid LogXP( inout GameState s, vec2 pos, float val )\n{\n    s.logPos[ 0 ]  = pos;\n    s.logLife[ 0 ] = 0.;\n    s.logId[ 0 ]   = 0.;\n\ts.logVal[ 0 ]  = val;\n}\n\nvoid LogHeal( inout GameState s, vec2 pos, float val )\n{\n    s.logPos[ 1 ]  = pos;\n    s.logLife[ 1 ] = 0.;\n    s.logId[ 1 ]   = 0.;\n\ts.logVal[ 1 ]  = val;\n}\n\nvoid LogLevelUp( inout GameState s, vec2 pos )\n{\n    s.logPos[ 0 ]  = pos;\n    s.logLife[ 0 ] = 0.;\n    s.logId[ 0 ]   = 1.;\n}\n\nfloat Rand( vec2 n )\n{\n\treturn fract( sin( dot( n.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\n}\n\nfloat MaxXP( float level )\n{\n\treturn 10. + level * 5.;\t   \n}\n\nfloat MaxHP( float level )\n{\n\treturn 21. + level * 3.;\t   \n}\n\nfloat EnemyDmg( float id )\n{    \n    float dmg = 1. + 2. * id + floor( ( 4. + 2. * id ) * Rand( vec2( iTime, iTime ) ) );\n#ifdef EASY_MODE\n    dmg = floor( dmg * .5 );\n#endif\n    return dmg;\n}\n\nfloat EnemyHP( float id )\n{\n    return 8. + id * 15.;\n}\n\nfloat EnemyXP( float id )\n{\n    return 3. + id * 5.;\n}\n\nfloat TrapDmg( bool player )\n{\n    float dmg = 10. + floor( 8. * Rand( vec2( iTime, iTime ) ) );\n#ifdef EASY_MODE\n    if ( player )\n    \tdmg = floor( dmg * .5 );\n#endif    \n    return dmg;\n}\n\nfloat PlayerDmg( inout GameState s )\n{\n    return s.level + 1. + floor( 4. * Rand( vec2( iTime + 11.1, iTime + 11.1 ) ) );\n}\n\nvoid UpdateEnemies( inout GameState s )\n{\n    for ( int i = 0; i < ENEMY_NUM; ++i )\n    {\n    \tif ( s.tick == 0. )\n    \t{\n            s.enemyFrame[ i ] = 0.;\n        }\n        \n       \tif ( s.enemyPos[ i ].x > 0. && s.enemyHP[ i ] <= 0. )\n        {\n            float xp = EnemyXP( s.enemyId[ i ] );\n            s.xp += xp;\n            s.bodyPos = s.enemyPos[ i ];\n            s.bodyId  = s.enemyId[ i ] + 1.;\n            s.enemyPos[ i ] = vec2( 0., 0. );\n            LogXP( s, s.playerPos, xp );\n        }        \n\n        vec4 map = texelFetch( iChannel1, ivec2( s.enemyPos[ i ] ), 0 );\n        if ( map.x == TILE_TRAP && s.tick == 1. )\n        {\n            float dmg = TrapDmg( false );\n            s.enemyHP[ i ] -= dmg;\n            LogDmg( s, s.enemyPos[ i ], dmg );\n        }        \n        \n        vec2 move = vec2( 0., 0. );\n    \tvec2 toPlayer = s.playerPos - s.enemyPos[ i ];\n        vec2 moveX = vec2( sign( toPlayer.x ), 0. );\n        vec2 moveY = vec2( 0., sign( toPlayer.y ) );\n        vec4 mapX  = texelFetch( iChannel1, ivec2( s.enemyPos[ i ] + moveX ), 0 );\n        vec4 mapY  = texelFetch( iChannel1, ivec2( s.enemyPos[ i ] + moveY ), 0 );\n        \n        if ( mapX.x >= TILE_WALL )\n        {\n            moveX = vec2( 0. );\n        }\n\n        if ( mapY.x >= TILE_WALL )\n        {\n            moveY = vec2( 0. );\n        }             \n        \n        for ( int j = 0; j < ENEMY_NUM; ++j )\n        {\n            if ( j != i && s.enemyPos[ j ] == s.enemyPos[ i ] + moveX )\n            {\n                moveX = vec2( 0. );\n            }\n            if ( j != i && s.enemyPos[ j ] == s.enemyPos[ i ] + moveY )\n            {\n                moveY = vec2( 0. );\n            }\n        }\n\n        move = moveX.x != 0. ? moveX : moveY;\n        if ( moveX.x != 0. && moveY.y != 0. )\n        {\n            move = abs( toPlayer.x ) > abs( toPlayer.y ) ? moveX : moveY;\n        }\n        \n        if ( s.tick == TICK_NUM )\n        {\n        \tif ( s.enemyPos[ i ] + move == s.playerPos )\n            {\n                float dmg = EnemyDmg( s.enemyId[ i ] );\n                s.hp -= dmg;\n                s.enemyFrame[ i ] = 5.;\n                LogDmg( s, s.playerPos, dmg );\n            }\n\t\t\telse\n            {\n\t\t\t\ts.enemyPos[ i ] += move;\n                s.enemyFrame[ i ] = move.x == 1. ? 1. : ( move.x == -1. ? 2. : ( move.y == 1. ? 3. : ( move.y == -1. ? 4. : 0. ) ) );\n                s.enemyDir[ i ] = move.x > 0. ? 0. : ( move.x < 0. ? 1. : s.enemyDir[ i ] );\n            }\n        }\n    }    \n}\n\nvoid CheckSpawnPos( inout vec2 spawnPos, inout float spawnId, vec2 tile )\n{\n\tvec4 map = texelFetch( iChannel1, ivec2( tile ), 0 );\n    if ( map.y == ITEM_SPAWNER || map.y == ITEM_SPAWNER_2 )\n    {\n        spawnPos = tile;\n        spawnId  = map.y == ITEM_SPAWNER ? 0. : 1.;\n    } \n}\n\nvoid SpawnEnemies( inout GameState s, vec2 playerMove )\n{    \n    \/\/ despawn out of range\n    s.despawnPos = vec2( 0. );\n    for ( int i = 0; i < ENEMY_NUM; ++i )\n    {\n        if ( s.tick == 1. && s.enemyPos[ i ].x > 0. && length( s.playerPos - s.enemyPos[ i ] ) > 5. )\n        {\n            s.despawnPos    = s.enemySpawnPos[ i ];\n            s.despawnId     = s.enemyId[ i ];\n            s.enemyPos[ i ] = vec2( 0. );\n            break;\n        }\n    }    \n    \n    vec2 spawnPos = vec2( 0., 0. );\n    float spawnId = 0.;\n    CheckSpawnPos( spawnPos, spawnId, s.playerPos + playerMove * 4. );\n    CheckSpawnPos( spawnPos, spawnId, s.playerPos + playerMove * 3. - playerMove.yx * 1. );\n    CheckSpawnPos( spawnPos, spawnId, s.playerPos + playerMove * 3. + playerMove.yx * 1. );\n    CheckSpawnPos( spawnPos, spawnId, s.playerPos + playerMove * 2. - playerMove.yx * 2. );\n    CheckSpawnPos( spawnPos, spawnId, s.playerPos + playerMove * 2. + playerMove.yx * 2. );\n    CheckSpawnPos( spawnPos, spawnId, s.playerPos + playerMove * 1. - playerMove.yx * 3. );\n    CheckSpawnPos( spawnPos, spawnId, s.playerPos + playerMove * 1. + playerMove.yx * 3. );\n    CheckSpawnPos( spawnPos, spawnId, s.playerPos + playerMove * 0. - playerMove.yx * 4. );\n    CheckSpawnPos( spawnPos, spawnId, s.playerPos + playerMove * 0. + playerMove.yx * 4. );    \n    \n    if ( spawnPos.x > 0. )\n    {\n        for ( int i = 0; i < ENEMY_NUM; ++i )\n        {        \n            if ( s.enemyPos[ i ].x <= 0. )\n            {\n                s.enemyId[ i ]       = spawnId;\n                s.enemyPos[ i ]      = spawnPos;\n                s.enemyHP[ i ]       = EnemyHP( spawnId );\n                s.enemySpawnPos[ i ] = spawnPos;\n                break;\n            }\n        }    \n    }\n}\n\nvoid UpdateLog( inout GameState s )\n{\n    for ( int i = 0; i < LOG_NUM; ++i )\n    {\n        s.logLife[ i ] += iTimeDelta;\n        if ( s.logLife[ i ] > 1. )\n        {\n            s.logPos[ i ] = vec2( 0. );\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ don't compute gameplay outside of the data area\n    if ( fragCoord.x >= 8. || fragCoord.y >= 8. ) \n    {\n\t\tdiscard;    \n    }\n\n    \/\/ keys\n    bool keyLeft  \t= texture( iChannel2, vec2( KEY_LEFT, .25 ) ).x > .5;\n    bool keyRight \t= texture( iChannel2, vec2( KEY_RIGHT, .25 ) ).x > .5;\n    bool keyUp  \t= texture( iChannel2, vec2( KEY_UP, .25 ) ).x > .5;\n    bool keyDown \t= texture( iChannel2, vec2( KEY_DOWN, .25 ) ).x > .5;    \n    \n    GameState s;\n    LoadState( s );\n    \n    s.tick = max( floor( s.tick - 1. ), 0. );    \n    \n    bool reset = false;\n    if ( iFrame < 1 || s.state == STATE_START )\n    {\n        reset   = true;\n        s.state = STATE_GAME;\n    }\n    else if ( s.state == STATE_GAME )\n    {\n        if ( s.hp <= 0. )\n        {\n            s.state \t= STATE_GAME_OVER;\n\t\t\ts.stateTime = 0.;\n        }\n    }\n    else if ( s.state == STATE_NEXT_LEVEL )\n    {\n        s.state = STATE_GAME;\n        s.playerPos = vec2( 3., 2. );\n    \tfor ( int i = 0; i < ENEMY_NUM; ++i )\n    \t{           \n            s.enemyPos[ i ] = vec2( 0. );\n    \t}\n    }\n    else if ( s.state == STATE_GAME_OVER )\n    {\n        s.stateTime += .33 * iTimeDelta;\n        if ( s.stateTime >= 1. )\n        {\n            s.state = STATE_START;\n        }\n    }\n\n    \n    \/\/ level up\n    if ( s.xp >= MaxXP( s.level ) )\n    {\n        s.xp -= MaxXP( s.level );\n        s.level = min( s.level + 1., 9. );\n        s.hp\t= MaxHP( s.level );\n        LogLevelUp( s, s.playerPos );\n    }\n    \n    \n#ifdef KEY_AUTOREPEAT    \n    s.keyLock = 0.;\n#else\n    s.keyLock = keyLeft || keyRight || keyDown || keyUp ? s.keyLock : 0.;    \n#endif\n\n    vec2 move = vec2( 0., 0. );\n    if ( s.state == STATE_GAME && s.tick == 0. && s.keyLock == 0. )\n    {\n        s.playerFrame = 0.;\n        if ( keyLeft )\n        {\n            move.x = -1.;\n            s.playerDir = 1.;\n        }   \n        else if ( keyRight )\n        {\n            move.x = 1.;\n            s.playerDir = 0.;\n        }   \n        else if ( keyDown )\n        {\n            move.y = -1.;\n        }\n        else if ( keyUp )\n        {\n            move.y = 1.;\n        }             \n    }\n  \n    vec4 map = texelFetch( iChannel1, ivec2( s.playerPos + move ), 0 );\n    if ( abs( move.x + move.y ) > 0. && map.x < TILE_WALL )\n    {\n        bool enemy = false;\n        for ( int i = 0; i < ENEMY_NUM; ++i )\n        {\n            if ( s.enemyPos[ i ] == s.playerPos + move )        \n            {\n                float dmg = PlayerDmg( s );\n                s.playerFrame = 6.;\n                s.enemyHP[ i ] -= dmg;\n                LogDmg( s, s.enemyPos[ i ], dmg );\n            }\n        }\n        \n        if ( s.playerFrame != 6. )\n        {\n    \t\ts.playerPos += move;\n            s.playerFrame = keyLeft ? 1. : ( keyRight ? 2. : ( keyDown ? 3. : 4. ) );\n        \n        \tif ( map.y == ITEM_KEY )\n        \t{\n            \ts.keyNum += 1.;\n        \t}        \n            \n        \tif ( map.y == ITEM_FOOD || map.y == ITEM_POTION )\n        \t{\n                float heal = map.y == ITEM_FOOD ? 5. : 50.;\n                heal = min( heal, MaxHP( s.level ) - s.hp );\n            \ts.hp += heal;\n                LogHeal( s, s.playerPos, heal );\n        \t}      \n            \n            if ( map.x == TILE_TRAP )\n            {\n                float dmg = TrapDmg( true );\n                s.hp -= dmg;\n                LogDmg( s, s.playerPos, dmg );\n            }  \n        }\n        \n        s.tick    = TICK_NUM;\n        s.keyLock = 1.;\n    }\n    else if ( map.x == TILE_DOOR_LOCKED && s.keyNum > 0. )\n    {\n        s.playerFrame = keyLeft ? 1. : ( keyRight ? 2. : ( keyDown ? 3. : 4. ) );\n        s.keyNum -= 1.;\n        s.playerPos += move;\n        s.tick    = TICK_NUM;\n        s.keyLock = 1.;\n    }\n    else if ( map.x >= TILE_WALL )\n    {\n     \t\/\/ wait\n        s.playerFrame = 5.;\n        s.tick        = TICK_NUM;\n        s.keyLock     = 1.;\n    }    \n\n    UpdateEnemies( s );\n    SpawnEnemies( s, move ); \n\tUpdateLog( s );\n    \n\t\/\/ next level\n    if ( map.x == TILE_STAIRS_DOWN )\n    {     \n        s.state = STATE_NEXT_LEVEL;\n    }\n    \n    fragColor = SaveState( s, fragCoord, reset );\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/\/ map\n\nconst float TICK_NUM\t\t\t= 10.;\nconst float TILE_FLOOR\t\t\t= 1.;\nconst float TILE_DOOR_OPEN\t\t= 2.;\nconst float TILE_STAIRS_DOWN\t= 3.;\nconst float TILE_TRAP\t\t\t= 4.;\nconst float TILE_TRAP_OFF\t\t= 5.;\nconst float TILE_WALL\t\t\t= 6.;\nconst float TILE_WALL_HOLE\t\t= 7.;\nconst float TILE_DOOR_LOCKED\t= 8.;\nconst float TILE_STAIRS_UP\t\t= 9.;\nconst float ITEM_KEY\t\t\t= 1.;\nconst float ITEM_FOOD\t\t\t= 2.;\nconst float ITEM_POTION\t\t\t= 3.;\nconst float ITEM_SPAWNER\t\t= 4.;\nconst float ITEM_SPAWNER_2\t\t= 5.;\nconst float STATE_START\t\t\t= 0.;\nconst float STATE_GAME\t\t\t= 1.;\nconst float STATE_NEXT_LEVEL\t= 2.;\nconst float STATE_GAME_OVER\t\t= 3.;\n\nconst int   ENEMY_NUM\t\t\t= 3;\nconst int   LOG_NUM\t\t\t\t= 4;\n\nstruct GameState\n{\n    \/\/ 0   \n    float\ttick;\n    float \thp;\n    float \tlevel;\n    float \txp;\n    float \tkeyNum;\n    \n\t\/\/ 1\n    vec2 \tplayerPos;\n    float   playerFrame;\n    float   playerDir;\n    vec2\tbodyPos;\n    float   bodyId;\n    \n    \/\/ 2\n    float \tstate;\n    float   keyLock;\n    float \tstateTime;\n    vec2\tdespawnPos;\n    float   despawnId;\n\n    \/\/ 3\n    vec2\tenemyPos[ ENEMY_NUM ];\n    float \tenemyFrame[ ENEMY_NUM ];\n    float \tenemyDir[ ENEMY_NUM ];\n    float \tenemyHP[ ENEMY_NUM ];\n    float \tenemyId[ ENEMY_NUM ];\n    vec2    enemySpawnPos[ ENEMY_NUM ];\n    \n    \/\/ 4\n    vec2\tlogPos[ LOG_NUM ];\n    float   logLife[ LOG_NUM ];\n    float   logId[ LOG_NUM ];\n    float   logVal[ LOG_NUM ];\n};\n\nvec4 LoadValue( int x, int y )\n{\n    return texelFetch( iChannel0, ivec2( x, y ), 0 );\n}    \n\nfloat PackXY( float a, float b )\n{\n    return floor( a ) + floor( b ) \/ 256.;\n}\n\nfloat PackXY( vec2 v )\n{\n    return PackXY( v.x, v.y );\n}\n\nfloat UnpackX( float a )\n{\n    return floor( a );\n}\n\nfloat UnpackY( float a )\n{\n    return fract( a ) * 256.;\n}\n\nvec2 UnpackXY( float a )\n{\n    return vec2( UnpackX( a ), UnpackY( a ) );\n}\n\nvoid LoadState( out GameState s )\n{\n    vec4 data;\n\n    data = LoadValue( 0, 0 );\n    s.tick \t\t= data.x;\n    s.hp    \t= UnpackX( data.y );\n    s.level    \t= UnpackY( data.y );\n    s.xp        = data.z;\n    s.keyNum    = data.w;\n    \n    data = LoadValue( 1, 0 );\n    s.playerPos   = UnpackXY( data.x );\n    s.playerFrame = UnpackX( data.y );\n    s.playerDir   = UnpackY( data.y );\n    s.bodyPos\t  = UnpackXY( data.z );\n    s.bodyId      = data.w;\n    \n    data = LoadValue( 2, 0 );\n    s.state      = UnpackX( data.x );\n    s.keyLock    = UnpackY( data.x );\n    s.stateTime  = data.y;\n    s.despawnPos = UnpackXY( data.z );\n    s.despawnId  = data.w;\n\n    for ( int i = 0; i < ENEMY_NUM; ++i )\n    {\n        data = LoadValue( 3, i );\n        s.enemyPos[ i ]      = UnpackXY( data.x );\n        s.enemyFrame[ i ]    = UnpackX( data.y );\n        s.enemyDir[ i ]      = UnpackY( data.y );\n        s.enemyHP[ i ]       = UnpackX( data.z );\n        s.enemyId[ i ]       = UnpackY( data.z );\n        s.enemySpawnPos[ i ] = UnpackXY( data.w );\n    }\n    \n    for ( int i = 0; i < LOG_NUM; ++i )\n    {\n\t\tdata = LoadValue( 4, i );\n    \ts.logPos[ i ]  = data.xy;\n        s.logLife[ i ] = data.z;\n        s.logId[ i ]   = UnpackX( data.w );\n        s.logVal[ i ]  = UnpackY( data.w );\n    }    \n}\n\nvec4 Map( vec2 p )\n{\n    int v = 0;\n\tv = p.y == 31. ? ( p.x < 8. ? 842150450 : ( p.x < 16. ? 573710370 : ( p.x < 24. ? 8754 : 589443584 ) ) ) : v;\n\tv = p.y == 30. ? ( p.x < 8. ? 286331154 : ( p.x < 16. ? 286335521 : ( p.x < 24. ? 589308177 : 554766882 ) ) ) : v;\n\tv = p.y == 29. ? ( p.x < 8. ? 286331154 : ( p.x < 16. ? 572592401 : ( p.x < 24. ? 287318289 : 554766609 ) ) ) : v;\n\tv = p.y == 28. ? ( p.x < 8. ? 572662306 : ( p.x < 16. ? 539042338 : ( p.x < 24. ? 555753745 : 554766882 ) ) ) : v;\n\tv = p.y == 27. ? ( p.x < 8. ? 0 : ( p.x < 16. ? 590422016 : ( p.x < 24. ? 555754002 : 572662272 ) ) ) : v;\n\tv = p.y == 26. ? ( p.x < 8. ? 589505314 : ( p.x < 16. ? 554770432 : ( p.x < 24. ? 555745810 : 0 ) ) ) : v;\n\tv = p.y == 25. ? ( p.x < 8. ? 554766610 : ( p.x < 16. ? 554770432 : ( p.x < 24. ? 555889170 : 589443634 ) ) ) : v;\n\tv = p.y == 24. ? ( p.x < 8. ? 554766610 : ( p.x < 16. ? 286334976 : ( p.x < 24. ? 286331153 : 554766609 ) ) ) : v;\n\tv = p.y == 23. ? ( p.x < 8. ? 555884834 : ( p.x < 16. ? 554770995 : ( p.x < 24. ? 555885073 : 554836514 ) ) ) : v;\n\tv = p.y == 22. ? ( p.x < 8. ? 287318304 : ( p.x < 16. ? 554770705 : ( p.x < 24. ? 555889169 : 554827776 ) ) ) : v;\n\tv = p.y == 21. ? ( p.x < 8. ? 572530976 : ( p.x < 16. ? 286335266 : ( p.x < 24. ? 555946257 : 555885106 ) ) ) : v;\n\tv = p.y == 20. ? ( p.x < 8. ? 143666 : ( p.x < 16. ? 572727584 : ( p.x < 24. ? 286331425 : 554832145 ) ) ) : v;\n\tv = p.y == 19. ? ( p.x < 8. ? 135442 : ( p.x < 16. ? 539037984 : ( p.x < 24. ? 571613713 : 554766882 ) ) ) : v;\n\tv = p.y == 18. ? ( p.x < 8. ? 135442 : ( p.x < 16. ? 539042336 : ( p.x < 24. ? 34734609 : 554832384 ) ) ) : v;\n\tv = p.y == 17. ? ( p.x < 8. ? 570560786 : ( p.x < 16. ? 539042355 : ( p.x < 24. ? 856896017 : 572662274 ) ) ) : v;\n\tv = p.y == 16. ? ( p.x < 8. ? 305279266 : ( p.x < 16. ? 539042065 : ( p.x < 24. ? 286331409 : 2 ) ) ) : v;\n\tv = p.y == 15. ? ( p.x < 8. ? 286331168 : ( p.x < 16. ? 857809169 : ( p.x < 24. ? 286331427 : 143922 ) ) ) : v;\n\tv = p.y == 14. ? ( p.x < 8. ? 304226592 : ( p.x < 16. ? 286331153 : ( p.x < 24. ? 286331153 : 590483729 ) ) ) : v;\n\tv = p.y == 13. ? ( p.x < 8. ? 570433824 : ( p.x < 16. ? 572596770 : ( p.x < 24. ? 286331426 : 554832418 ) ) ) : v;\n\tv = p.y == 12. ? ( p.x < 8. ? 8480 : ( p.x < 16. ? 287383552 : ( p.x < 24. ? 286331394 : 554832386 ) ) ) : v;\n\tv = p.y == 11. ? ( p.x < 8. ? 840966450 : ( p.x < 16. ? 287383586 : ( p.x < 24. ? 571613698 : 554766850 ) ) ) : v;\n\tv = p.y == 10. ? ( p.x < 8. ? 287318290 : ( p.x < 16. ? 286335009 : ( p.x < 24. ? 34734082 : 572658176 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 8. ? 287318290 : ( p.x < 16. ? 572596257 : ( p.x < 24. ? 34746882 : 135680 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 8. ? 304095506 : ( p.x < 16. ? 2171682 : ( p.x < 24. ? 571544064 : 36835891 ) ) ) : v;\n\tv = p.y == 7. ? ( p.x < 8. ? 301998354 : ( p.x < 16. ? 2167057 : ( p.x < 24. ? 286331392 : 34672913 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 8. ? 570434082 : ( p.x < 16. ? 2171426 : ( p.x < 24. ? 304226816 : 34742818 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 8. ? 0 : ( p.x < 16. ? 2170880 : ( p.x < 24. ? 301989888 : 34738450 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 8. ? 36844082 : ( p.x < 16. ? 36778496 : ( p.x < 24. ? 302134048 : 34672914 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 8. ? 571543826 : ( p.x < 16. ? 571544099 : ( p.x < 24. ? 302125346 : 34738449 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 8. ? 286331154 : ( p.x < 16. ? 286331153 : ( p.x < 24. ? 302125329 : 34746930 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 8. ? 571543826 : ( p.x < 16. ? 571544098 : ( p.x < 24. ? 302125346 : 34672913 ) ) ) : v;\n\tv = p.y == 0. ? ( p.x < 8. ? 35791394 : ( p.x < 16. ? 35791360 : ( p.x < 24. ? 570565152 : 35791394 ) ) ) : v;\n    float t = float( ( v >> int( 4. * p.x ) ) & 15 );\n    t = t == 2. ? 6. : t;\n    t = t == 3. ? 7. : t;\n    t = p.x == 15. && p.y == 30. ? 2. : t;\n    t = p.x == 9. && p.y == 29. ? 2. : t;\n    t = p.x == 11. && p.y == 29. ? 2. : t;\n    t = p.x == 12. && p.y == 27. ? 2. : t;\n    t = p.x == 17. && p.y == 27. ? 2. : t;\n    t = p.x == 17. && p.y == 25. ? 2. : t;\n    t = p.x == 15. && p.y == 24. ? 2. : t;\n    t = p.x == 18. && p.y == 24. ? 2. : t;\n    t = p.x == 21. && p.y == 24. ? 2. : t;\n    t = p.x == 23. && p.y == 24. ? 2. : t;\n    t = p.x == 28. && p.y == 24. ? 2. : t;\n    t = p.x == 2. && p.y == 23. ? 2. : t;\n    t = p.x == 6. && p.y == 23. ? 2. : t;\n    t = p.x == 15. && p.y == 21. ? 2. : t;\n    t = p.x == 18. && p.y == 21. ? 2. : t;\n    t = p.x == 30. && p.y == 21. ? 2. : t;\n    t = p.x == 16. && p.y == 20. ? 2. : t;\n    t = p.x == 23. && p.y == 20. ? 2. : t;\n    t = p.x == 11. && p.y == 19. ? 2. : t;\n    t = p.x == 21. && p.y == 19. ? 2. : t;\n    t = p.x == 28. && p.y == 19. ? 2. : t;\n    t = p.x == 2. && p.y == 16. ? 2. : t;\n    t = p.x == 6. && p.y == 15. ? 2. : t;\n    t = p.x == 12. && p.y == 15. ? 2. : t;\n    t = p.x == 11. && p.y == 14. ? 2. : t;\n    t = p.x == 24. && p.y == 14. ? 2. : t;\n    t = p.x == 2. && p.y == 11. ? 2. : t;\n    t = p.x == 21. && p.y == 11. ? 2. : t;\n    t = p.x == 28. && p.y == 11. ? 2. : t;\n    t = p.x == 13. && p.y == 10. ? 2. : t;\n    t = p.x == 21. && p.y == 9. ? 2. : t;\n    t = p.x == 7. && p.y == 8. ? 2. : t;\n    t = p.x == 27. && p.y == 8. ? 2. : t;\n    t = p.x == 22. && p.y == 7. ? 2. : t;\n    t = p.x == 28. && p.y == 4. ? 2. : t;\n    t = p.x == 24. && p.y == 3. ? 2. : t;\n    t = p.x == 10. && p.y == 2. ? 2. : t;\n    t = p.x == 14. && p.y == 2. ? 2. : t;\n    t = p.x == 17. && p.y == 2. ? 2. : t;\n    t = p.x == 26. && p.y == 29. ? 8. : t;\n    t = p.x == 22. && p.y == 25. ? 8. : t;\n    t = p.x == 21. && p.y == 17. ? 8. : t;\n    t = p.x == 13. && p.y == 14. ? 8. : t;\n    t = p.x == 18. && p.y == 14. ? 8. : t;\n    t = p.x == 12. && p.y == 4. ? 8. : t;\n    t = p.x == 6. && p.y == 2. ? 8. : t;\n    t = p.x == 17. && p.y == 29. ? 4. : t;\n    t = p.x == 4. && p.y == 24. ? 4. : t;\n    t = p.x == 16. && p.y == 23. ? 4. : t;\n    t = p.x == 29. && p.y == 23. ? 4. : t;\n    t = p.x == 2. && p.y == 18. ? 4. : t;\n    t = p.x == 17. && p.y == 17. ? 4. : t;\n    t = p.x == 8. && p.y == 15. ? 4. : t;\n    t = p.x == 9. && p.y == 15. ? 4. : t;\n    t = p.x == 21. && p.y == 15. ? 4. : t;\n    t = p.x == 20. && p.y == 14. ? 4. : t;\n    t = p.x == 22. && p.y == 14. ? 4. : t;\n    t = p.x == 21. && p.y == 13. ? 4. : t;\n    t = p.x == 29. && p.y == 12. ? 4. : t;\n    t = p.x == 14. && p.y == 11. ? 4. : t;\n    t = p.x == 26. && p.y == 4. ? 4. : t;\n    t = p.x == 12. && p.y == 2. ? 4. : t;\n    t = p.x == 2. && p.y == 2. ? 9. : t;\n    t = p.x == 29. && p.y == 29. ? 3. : t;\n    float i = 0.;\n    i = p.x == 1. && p.y == 30. ? 1. : i;\n    i = p.x == 1. && p.y == 24. ? 1. : i;\n    i = p.x == 17. && p.y == 16. ? 1. : i;\n    i = p.x == 1. && p.y == 7. ? 1. : i;\n    i = p.x == 25. && p.y == 5. ? 1. : i;\n    i = p.x == 1. && p.y == 3. ? 1. : i;\n    i = p.x == 19. && p.y == 3. ? 1. : i;\n    i = p.x == 8. && p.y == 30. ? 2. : i;\n    i = p.x == 18. && p.y == 30. ? 2. : i;\n    i = p.x == 27. && p.y == 28. ? 2. : i;\n    i = p.x == 13. && p.y == 26. ? 2. : i;\n    i = p.x == 14. && p.y == 26. ? 2. : i;\n    i = p.x == 6. && p.y == 25. ? 2. : i;\n    i = p.x == 13. && p.y == 25. ? 2. : i;\n    i = p.x == 14. && p.y == 25. ? 2. : i;\n    i = p.x == 10. && p.y == 22. ? 2. : i;\n    i = p.x == 19. && p.y == 21. ? 2. : i;\n    i = p.x == 3. && p.y == 19. ? 2. : i;\n    i = p.x == 17. && p.y == 19. ? 2. : i;\n    i = p.x == 30. && p.y == 18. ? 2. : i;\n    i = p.x == 10. && p.y == 16. ? 2. : i;\n    i = p.x == 23. && p.y == 16. ? 2. : i;\n    i = p.x == 27. && p.y == 14. ? 2. : i;\n    i = p.x == 14. && p.y == 12. ? 2. : i;\n    i = p.x == 19. && p.y == 12. ? 2. : i;\n    i = p.x == 23. && p.y == 12. ? 2. : i;\n    i = p.x == 1. && p.y == 10. ? 2. : i;\n    i = p.x == 11. && p.y == 3. ? 2. : i;\n    i = p.x == 13. && p.y == 3. ? 2. : i;\n    i = p.x == 27. && p.y == 3. ? 2. : i;\n    i = p.x == 23. && p.y == 1. ? 2. : i;\n    i = p.x == 1. && p.y == 29. ? 3. : i;\n    i = p.x == 8. && p.y == 10. ? 3. : i;\n    i = p.x == 19. && p.y == 7. ? 3. : i;\n    i = p.x == 3. && p.y == 30. ? 4. : i;\n    i = p.x == 12. && p.y == 30. ? 4. : i;\n    i = p.x == 2. && p.y == 25. ? 4. : i;\n    i = p.x == 20. && p.y == 24. ? 4. : i;\n    i = p.x == 22. && p.y == 24. ? 4. : i;\n    i = p.x == 6. && p.y == 22. ? 4. : i;\n    i = p.x == 12. && p.y == 21. ? 4. : i;\n    i = p.x == 19. && p.y == 20. ? 4. : i;\n    i = p.x == 27. && p.y == 20. ? 4. : i;\n    i = p.x == 12. && p.y == 19. ? 4. : i;\n    i = p.x == 1. && p.y == 17. ? 4. : i;\n    i = p.x == 19. && p.y == 16. ? 4. : i;\n    i = p.x == 17. && p.y == 14. ? 4. : i;\n    i = p.x == 15. && p.y == 10. ? 4. : i;\n    i = p.x == 12. && p.y == 9. ? 4. : i;\n    i = p.x == 7. && p.y == 7. ? 4. : i;\n    i = p.x == 20. && p.y == 7. ? 4. : i;\n    i = p.x == 9. && p.y == 2. ? 4. : i;\n    i = p.x == 19. && p.y == 2. ? 4. : i;\n    i = p.x == 10. && p.y == 29. ? 5. : i;\n    i = p.x == 22. && p.y == 29. ? 5. : i;\n    i = p.x == 25. && p.y == 29. ? 5. : i;\n    i = p.x == 13. && p.y == 24. ? 5. : i;\n    i = p.x == 30. && p.y == 24. ? 5. : i;\n    i = p.x == 16. && p.y == 16. ? 5. : i;\n    i = p.x == 30. && p.y == 11. ? 5. : i;\n    i = p.x == 6. && p.y == 10. ? 5. : i;\n    i = p.x == 1. && p.y == 8. ? 5. : i;\n    i = p.x == 21. && p.y == 7. ? 5. : i;\n    i = p.x == 26. && p.y == 5. ? 5. : i;\n    return p.x < 0. || p.y < 0. || p.x > 31. || p.y > 31. ? vec4( 0. ) : vec4( t, i, 0., 0. );\n}\n\nfloat Rand( vec2 n )\n{\n\treturn fract( sin( dot( n.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ don't compute map outside of map area\n    if ( fragCoord.x >= 40. || fragCoord.y >= 40. ) \n    {\n\t\tdiscard;    \n    }    \n    \n    vec2 tile = floor( fragCoord );\n    \n    vec4 map = texelFetch( iChannel1, ivec2( tile ), 0 );\n    \n    GameState s;\n    LoadState( s );    \n    \n    \/\/ create map\n\tif ( s.state == STATE_START || s.state == STATE_NEXT_LEVEL || iFrame < 1 )\n    {\n        map = Map( tile );\n    }   \n    \n    if ( tile == s.playerPos )\n    {\n     \tif ( s.tick == 1. && ( map.y == ITEM_KEY || map.y == ITEM_FOOD || map.y == ITEM_POTION ) )\n        {\n            \/\/ pickup item\n\t\t\tmap.y = 0.;\n        }\n     \tif ( map.x == TILE_DOOR_LOCKED && s.tick == TICK_NUM )\n        {\n\t\t\tmap.x = TILE_DOOR_OPEN;\n        }    \n     \tif ( map.x == TILE_TRAP && s.tick == 1. )\n        {\n\t\t\tmap.x = TILE_TRAP_OFF;\n        }           \n    }\n    \n    for ( int i = 0; i < ENEMY_NUM; ++i )\n    {\n        if ( tile == s.enemyPos[ i ] && map.x == TILE_TRAP && s.tick == 1. )\n        {\n            map.x = TILE_TRAP_OFF;\n        }\n    }\n    \n    if ( tile == s.bodyPos && map.x == TILE_TRAP )\n    {\n\t\tmap.x = TILE_TRAP_OFF;\n    }\n    \n    \/\/ fog of war\n    if ( s.state == STATE_GAME && length( s.playerPos - tile ) < 5. )\n    {    \n        map.w = 1.;\n    }\n    \n    if ( s.state == STATE_GAME && tile == s.bodyPos )\n    {\n        map.z = s.bodyId;\n    }\n\n    if ( tile == s.playerPos && s.hp <= 0. )\n    {\n        map.z = 2.;\n    }\n    \n    for ( int i = 0; i < ENEMY_NUM; ++i )\n    {\n        if ( s.state == STATE_GAME && s.enemyPos[ i ].x > 0. && tile == s.enemySpawnPos[ i ] )\n        {\n            map.y = 0.;\n        }\n    }\n    \n    if ( s.state == STATE_GAME && s.despawnPos.x > 0. && tile == s.despawnPos )\n    {\n        map.y = s.despawnId > 0. ? ITEM_SPAWNER_2 : ITEM_SPAWNER;\n    }\n\n \tfragColor = map;\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\/\/ background\n\nconst float TICK_NUM\t\t\t= 10.;\nconst float TILE_FLOOR\t\t\t= 1.;\nconst float TILE_DOOR_OPEN\t\t= 2.;\nconst float TILE_STAIRS_DOWN\t= 3.;\nconst float TILE_TRAP\t\t\t= 4.;\nconst float TILE_TRAP_OFF\t\t= 5.;\nconst float TILE_WALL\t\t\t= 6.;\nconst float TILE_WALL_HOLE\t\t= 7.;\nconst float TILE_DOOR_LOCKED\t= 8.;\nconst float TILE_STAIRS_UP\t\t= 9.;\nconst float ITEM_KEY\t\t\t= 1.;\nconst float ITEM_FOOD\t\t\t= 2.;\nconst float ITEM_POTION\t\t\t= 3.;\nconst float ITEM_SPAWNER\t\t= 3.;\nconst float STATE_START\t\t\t= 0.;\nconst float STATE_GAME\t\t\t= 1.;\nconst float STATE_NEXT_LEVEL\t= 2.;\nconst float STATE_GAME_OVER\t\t= 3.;\n\nconst vec2  REF_RES\t            = vec2( 200. );\n\nconst int   ENEMY_NUM\t\t\t= 3;\nconst int   LOG_NUM\t\t\t\t= 4;\n\nstruct GameState\n{\n    \/\/ 0   \n    float\ttick;\n    float \thp;\n    float \tlevel;\n    float \txp;\n    float \tkeyNum;\n    \n\t\/\/ 1\n    vec2 \tplayerPos;\n    float   playerFrame;\n    float   playerDir;\n    vec2\tbodyPos;\n    float   bodyId;\n    \n    \/\/ 2\n    float \tstate;\n    float   keyLock;\n    float \tstateTime;\n    vec2\tdespawnPos;\n    float   despawnId;\n\n    \/\/ 3\n    vec2\tenemyPos[ ENEMY_NUM ];\n    float \tenemyFrame[ ENEMY_NUM ];\n    float \tenemyDir[ ENEMY_NUM ];\n    float \tenemyHP[ ENEMY_NUM ];\n    float \tenemyId[ ENEMY_NUM ];\n    vec2    enemySpawnPos[ ENEMY_NUM ];\n    \n    \/\/ 4\n    vec2\tlogPos[ LOG_NUM ];\n    float   logLife[ LOG_NUM ];\n    float   logId[ LOG_NUM ];\n    float   logVal[ LOG_NUM ];\n};\n\nvec4 LoadValue( int x, int y )\n{\n    return texelFetch( iChannel0, ivec2( x, y ), 0 );\n}    \n\nfloat PackXY( float a, float b )\n{\n    return floor( a ) + floor( b ) \/ 256.;\n}\n\nfloat PackXY( vec2 v )\n{\n    return PackXY( v.x, v.y );\n}\n\nfloat UnpackX( float a )\n{\n    return floor( a );\n}\n\nfloat UnpackY( float a )\n{\n    return fract( a ) * 256.;\n}\n\nvec2 UnpackXY( float a )\n{\n    return vec2( UnpackX( a ), UnpackY( a ) );\n}\n\nvoid LoadState( out GameState s )\n{\n    vec4 data;\n\n    data = LoadValue( 0, 0 );\n    s.tick \t\t= data.x;\n    s.hp    \t= UnpackX( data.y );\n    s.level    \t= UnpackY( data.y );\n    s.xp        = data.z;\n    s.keyNum    = data.w;\n    \n    data = LoadValue( 1, 0 );\n    s.playerPos   = UnpackXY( data.x );\n    s.playerFrame = UnpackX( data.y );\n    s.playerDir   = UnpackY( data.y );\n    s.bodyPos\t  = UnpackXY( data.z );\n    s.bodyId      = data.w;\n    \n    data = LoadValue( 2, 0 );\n    s.state      = UnpackX( data.x );\n    s.keyLock    = UnpackY( data.x );\n    s.stateTime  = data.y;\n    s.despawnPos = UnpackXY( data.z );\n    s.despawnId  = data.w;\n\n    for ( int i = 0; i < ENEMY_NUM; ++i )\n    {\n        data = LoadValue( 3, i );\n        s.enemyPos[ i ]      = UnpackXY( data.x );\n        s.enemyFrame[ i ]    = UnpackX( data.y );\n        s.enemyDir[ i ]      = UnpackY( data.y );\n        s.enemyHP[ i ]       = UnpackX( data.z );\n        s.enemyId[ i ]       = UnpackY( data.z );\n        s.enemySpawnPos[ i ] = UnpackXY( data.w );\n    }\n    \n    for ( int i = 0; i < LOG_NUM; ++i )\n    {\n\t\tdata = LoadValue( 4, i );\n    \ts.logPos[ i ]  = data.xy;\n        s.logLife[ i ] = data.z;\n        s.logId[ i ]   = UnpackX( data.w );\n        s.logVal[ i ]  = UnpackY( data.w );\n    }    \n}\n\nfloat saturate( float x )\n{\n    return clamp( x, 0., 1. );\n}\n\nfloat Smooth( float x )\n{\n\treturn smoothstep( 0., 1., saturate( x ) );   \n}\n\nvoid SpriteEarth( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 15. ? ( p.x < 8. ? 17961233 : ( p.x < 16. ? 536941073 : 0 ) ) : v;\n\tv = p.y == 14. ? ( p.x < 8. ? 18944274 : ( p.x < 16. ? 269549841 : 0 ) ) : v;\n\tv = p.y == 13. ? ( p.x < 8. ? 269553937 : ( p.x < 16. ? 554766353 : 0 ) ) : v;\n\tv = p.y == 12. ? ( p.x < 8. ? 1118481 : ( p.x < 16. ? 572662032 : 0 ) ) : v;\n\tv = p.y == 11. ? ( p.x < 8. ? 554766609 : ( p.x < 16. ? 555815424 : 0 ) ) : v;\n\tv = p.y == 10. ? ( p.x < 8. ? 572662049 : ( p.x < 16. ? 286261777 : 0 ) ) : v;\n\tv = p.y == 9. ? ( p.x < 8. ? 16781602 : ( p.x < 16. ? 268440097 : 0 ) ) : v;\n\tv = p.y == 8. ? ( p.x < 8. ? 4385 : ( p.x < 16. ? 536875298 : 0 ) ) : v;\n\tv = p.y == 7. ? ( p.x < 8. ? 303108641 : ( p.x < 16. ? 286265617 : 0 ) ) : v;\n\tv = p.y == 6. ? ( p.x < 8. ? 35790865 : ( p.x < 16. ? 304152593 : 0 ) ) : v;\n\tv = p.y == 5. ? ( p.x < 8. ? 16843025 : ( p.x < 16. ? 286327056 : 0 ) ) : v;\n\tv = p.y == 4. ? ( p.x < 8. ? 16781841 : ( p.x < 16. ? 286261521 : 0 ) ) : v;\n\tv = p.y == 3. ? ( p.x < 8. ? 285352193 : ( p.x < 16. ? 287310081 : 0 ) ) : v;\n\tv = p.y == 2. ? ( p.x < 8. ? 70162 : ( p.x < 16. ? 269484049 : 0 ) ) : v;\n\tv = p.y == 1. ? ( p.x < 8. ? 4625 : ( p.x < 16. ? 269488417 : 0 ) ) : v;\n\tv = p.y == 0. ? ( p.x < 8. ? 529 : ( p.x < 16. ? 268505361 : 0 ) ) : v;\n    float i = float( ( v >> int( 4. * p.x ) ) & 15 );\n    color = vec3( 0.16, 0.14, 0.14 );\n    color = i == 1. ? vec3( 0.17, 0.16, 0.15 ) : color;\n    color = i == 2. ? vec3( 0.19, 0.17, 0.16 ) : color;\n}\n\nvoid SpriteEarth2( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 13. ? 0 : v;\n\tv = p.y == 12. ? ( p.x < 8. ? 0 : ( p.x < 16. ? 8960 : 0 ) ) : v;\n\tv = p.y == 11. ? ( p.x < 8. ? 0 : ( p.x < 16. ? 69920 : 0 ) ) : v;\n\tv = p.y == 10. ? ( p.x < 8. ? 16 : 0 ) : v;\n\tv = p.y == 9. ? 0 : v;\n\tv = p.y == 8. ? ( p.x < 8. ? 3342336 : 0 ) : v;\n\tv = p.y == 7. ? ( p.x < 8. ? 35794944 : ( p.x < 16. ? 65536 : 0 ) ) : v;\n\tv = p.y == 6. ? ( p.x < 8. ? 17899520 : 0 ) : v;\n\tv = p.y == 5. ? 0 : v;\n\tv = p.y == 4. ? 0 : v;\n\tv = p.y == 3. ? ( p.x < 8. ? 0 : ( p.x < 16. ? 1 : 0 ) ) : v;\n\tv = p.y == 2. ? 0 : v;\n\tv = p.y == 1. ? ( p.x < 8. ? 8192 : ( p.x < 16. ? 12288 : 0 ) ) : v;\n\tv = p.y == 0. ? ( p.x < 8. ? 0 : ( p.x < 16. ? 70144 : 0 ) ) : v;\n    float i = float( ( v >> int( 4. * p.x ) ) & 15 );\n    color = i == 1. ? vec3( 0.42, 0.4, 0.38 ) : color;\n    color = i == 2. ? vec3( 0.55, 0.53, 0.51 ) : color;\n    color = i == 3. ? vec3( 0.72, 0.69, 0.65 ) : color;\n}\n\nvoid SpriteWater( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 15. ? ( p.x < 8. ? 286404882 : ( p.x < 16. ? 842142226 : 0 ) ) : v;\n\tv = p.y == 14. ? ( p.x < 8. ? 286261795 : ( p.x < 16. ? 286405169 : 0 ) ) : v;\n\tv = p.y == 13. ? ( p.x < 8. ? 269553970 : ( p.x < 16. ? 286339873 : 0 ) ) : v;\n\tv = p.y == 12. ? ( p.x < 8. ? 17965330 : ( p.x < 16. ? 554840865 : 0 ) ) : v;\n\tv = p.y == 11. ? ( p.x < 8. ? 1179665 : ( p.x < 16. ? 322122513 : 0 ) ) : v;\n\tv = p.y == 10. ? ( p.x < 8. ? 19988481 : ( p.x < 16. ? 858923265 : 0 ) ) : v;\n\tv = p.y == 9. ? ( p.x < 8. ? 303108385 : ( p.x < 16. ? 303116817 : 0 ) ) : v;\n\tv = p.y == 8. ? ( p.x < 8. ? 273 : ( p.x < 16. ? 287449616 : 0 ) ) : v;\n\tv = p.y == 7. ? ( p.x < 8. ? 17826065 : ( p.x < 16. ? 303112464 : 0 ) ) : v;\n\tv = p.y == 6. ? ( p.x < 8. ? 285212945 : ( p.x < 16. ? 285212945 : 0 ) ) : v;\n\tv = p.y == 5. ? ( p.x < 8. ? 16777233 : ( p.x < 16. ? 553648400 : 0 ) ) : v;\n\tv = p.y == 4. ? ( p.x < 8. ? 17825793 : ( p.x < 16. ? 287375360 : 0 ) ) : v;\n\tv = p.y == 3. ? ( p.x < 8. ? 268435457 : ( p.x < 16. ? 571613184 : 0 ) ) : v;\n\tv = p.y == 2. ? ( p.x < 8. ? 268439826 : ( p.x < 16. ? 822153489 : 0 ) ) : v;\n\tv = p.y == 1. ? ( p.x < 8. ? 268439827 : ( p.x < 16. ? 805380369 : 0 ) ) : v;\n\tv = p.y == 0. ? ( p.x < 8. ? 286339345 : ( p.x < 16. ? 841158944 : 0 ) ) : v;\n    float i = float( ( v >> int( 4. * p.x ) ) & 15 );\n    color = vec3( 0.21, 0.38, 0.29 );\n    color = i == 1. ? vec3( 0.24, 0.41, 0.33 ) : color;\n    color = i == 2. ? vec3( 0.27, 0.44, 0.36 ) : color;\n    color = i == 3. ? vec3( 0.3, 0.47, 0.37 ) : color;\n}\n\nvoid SpriteFloor( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 15. ? ( p.x < 4. ? 33555717 : ( p.x < 8. ? 84149251 : ( p.x < 12. ? 67371267 : 67437569 ) ) ) : v;\n\tv = p.y == 14. ? ( p.x < 4. ? 16844037 : ( p.x < 8. ? 16777216 : ( p.x < 12. ? 65793 : 50594817 ) ) ) : v;\n\tv = p.y == 13. ? ( p.x < 4. ? 33620997 : ( p.x < 8. ? 197893 : ( p.x < 12. ? 33752323 : 50660608 ) ) ) : v;\n\tv = p.y == 12. ? ( p.x < 4. ? 67109893 : ( p.x < 8. ? 328709 : ( p.x < 12. ? 67306756 : 84149504 ) ) ) : v;\n\tv = p.y == 11. ? ( p.x < 4. ? 83886851 : ( p.x < 8. ? 263428 : ( p.x < 12. ? 50660099 : 84214272 ) ) ) : v;\n\tv = p.y == 10. ? ( p.x < 4. ? 83886337 : ( p.x < 8. ? 17040644 : ( p.x < 12. ? 65537 : 16843009 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 50397957 : ( p.x < 8. ? 328965 : ( p.x < 12. ? 84215042 : 67371266 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 83952645 : ( p.x < 8. ? 17106181 : ( p.x < 12. ? 84149508 : 67436547 ) ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 33620485 : ( p.x < 8. ? 16909317 : ( p.x < 12. ? 84214788 : 67240197 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 16842752 : ( p.x < 8. ? 257 : ( p.x < 12. ? 84149508 : 65540 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 50594305 : ( p.x < 8. ? 132101 : ( p.x < 12. ? 67372293 : 67371269 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 67437825 : ( p.x < 8. ? 17040645 : ( p.x < 12. ? 50595075 : 67371010 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 67371777 : ( p.x < 8. ? 16974852 : ( p.x < 12. ? 65792 : 84213760 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 16777216 : ( p.x < 8. ? 16843009 : ( p.x < 12. ? 50528256 : 65537 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 33620485 : ( p.x < 8. ? 67437828 : ( p.x < 12. ? 84148226 : 67437312 ) ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 83952645 : ( p.x < 8. ? 84214532 : ( p.x < 12. ? 84148484 : 84215040 ) ) ) : v;\n    float i = float( ( v >> int( 8.0 * p.x ) ) & 255 );\n    color = vec3( 0.21, 0.2, 0.19 );\n    color = i == 1. ? vec3( 0.23, 0.23, 0.21 ) : color;\n    color = i == 2. ? vec3( 0.27, 0.27, 0.25 ) : color;\n    color = i == 3. ? vec3( 0.3, 0.29, 0.28 ) : color;\n    color = i == 4. ? vec3( 0.31, 0.31, 0.29 ) : color;\n    color = i == 5. ? vec3( 0.33, 0.32, 0.31 ) : color;\n}\n\nvoid SpriteWood( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 15. ? ( p.x < 8. ? 17830178 : ( p.x < 16. ? 286401058 : 0 ) ) : v;\n\tv = p.y == 14. ? 0 : v;\n\tv = p.y == 13. ? ( p.x < 8. ? 303182643 : ( p.x < 16. ? 806424850 : 0 ) ) : v;\n\tv = p.y == 12. ? 0 : v;\n\tv = p.y == 11. ? ( p.x < 8. ? 807481906 : ( p.x < 16. ? 858993459 : 0 ) ) : v;\n\tv = p.y == 10. ? ( p.x < 8. ? 537989394 : ( p.x < 16. ? 304222738 : 0 ) ) : v;\n\tv = p.y == 9. ? 0 : v;\n\tv = p.y == 8. ? ( p.x < 8. ? 572732211 : ( p.x < 16. ? 34677025 : 0 ) ) : v;\n\tv = p.y == 7. ? ( p.x < 8. ? 554832402 : ( p.x < 16. ? 19013905 : 0 ) ) : v;\n\tv = p.y == 6. ? 0 : v;\n\tv = p.y == 5. ? ( p.x < 8. ? 288568115 : ( p.x < 16. ? 858993410 : 0 ) ) : v;\n\tv = p.y == 4. ? ( p.x < 8. ? 286331426 : ( p.x < 16. ? 286331137 : 0 ) ) : v;\n\tv = p.y == 3. ? 0 : v;\n\tv = p.y == 2. ? ( p.x < 8. ? 572732208 : ( p.x < 16. ? 303174161 : 0 ) ) : v;\n\tv = p.y == 1. ? 0 : v;\n\tv = p.y == 0. ? ( p.x < 8. ? 34677011 : ( p.x < 16. ? 858993459 : 0 ) ) : v;\n    float i = float( ( v >> int( 4. * p.x ) ) & 15 );\n    color = vec3( 0.25, 0.18, 0.098 );\n    color = i == 1. ? vec3( 0.31, 0.23, 0.11 ) : color;\n    color = i == 2. ? vec3( 0.35, 0.26, 0.12 ) : color;\n    color = i == 3. ? vec3( 0.4, 0.29, 0.12 ) : color;\n}\n\nvoid SpriteWall( inout vec3 color, vec2 p )\n{    \n    int v = 0;\n\tv = p.y == 15. ? ( p.x < 4. ? 100927239 : ( p.x < 8. ? 17106437 : ( p.x < 12. ? 67372806 : 328452 ) ) ) : v;\n\tv = p.y == 14. ? ( p.x < 4. ? 117901063 : ( p.x < 8. ? 17171974 : ( p.x < 12. ? 101123847 : 393991 ) ) ) : v;\n\tv = p.y == 13. ? ( p.x < 4. ? 84280838 : ( p.x < 8. ? 329222 : ( p.x < 12. ? 84281094 : 329221 ) ) ) : v;\n\tv = p.y == 12. ? ( p.x < 4. ? 1 : ( p.x < 8. ? 65537 : ( p.x < 12. ? 256 : 16777472 ) ) ) : v;\n\tv = p.y == 11. ? ( p.x < 4. ? 17105926 : ( p.x < 8. ? 117703683 : ( p.x < 12. ? 17171975 : 117901062 ) ) ) : v;\n\tv = p.y == 10. ? ( p.x < 4. ? 17172231 : ( p.x < 8. ? 117835526 : ( p.x < 12. ? 460295 : 117901063 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 329222 : ( p.x < 8. ? 84346629 : ( p.x < 12. ? 17106437 : 84281093 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 16842753 : ( p.x < 8. ? 16843009 : ( p.x < 12. ? 16777473 : 65536 ) ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 67372036 : ( p.x < 8. ? 101058052 : ( p.x < 12. ? 67372545 : 100664836 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 117900038 : ( p.x < 8. ? 101058311 : ( p.x < 12. ? 67503872 : 100730374 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 84280839 : ( p.x < 8. ? 84215046 : ( p.x < 12. ? 84280577 : 83887366 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 65793 : ( p.x < 8. ? 16777473 : ( p.x < 12. ? 257 : 0 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 84281095 : ( p.x < 8. ? 117703424 : ( p.x < 12. ? 33818119 : 117900032 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 117835270 : ( p.x < 8. ? 117901057 : ( p.x < 12. ? 117900806 : 101122817 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 84280583 : ( p.x < 8. ? 101123328 : ( p.x < 12. ? 84215046 : 101123584 ) ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 16842753 : ( p.x < 8. ? 16842752 : ( p.x < 12. ? 16777472 : 16843008 ) ) ) : v;\n    float i = float( ( v >> int( 8.0 * p.x ) ) & 255 );\n    color = vec3( 0.33 );\n    color = i == 1. ? vec3( 0.38 ) : color;\n    color = i == 2. ? vec3( 0.5, 0.6, 0.56 ) : color;\n    color = i == 3. ? vec3( 0.55, 0.65, 0.6 ) : color;\n    color = i == 4. ? vec3( 0.61, 0.71, 0.66 ) : color;\n    color = i == 5. ? vec3( 0.67 ) : color;\n    color = i == 6. ? vec3( 0.75 ) : color;\n    color = i == 7. ? vec3( 0.85 ) : color;\n}\n\nvoid SpriteWallHole( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 15. ? ( p.x < 4. ? 100992775 : ( p.x < 8. ? 50660869 : ( p.x < 12. ? 84215558 : 33883141 ) ) ) : v;\n\tv = p.y == 14. ? ( p.x < 4. ? 117901063 : ( p.x < 8. ? 33817606 : ( p.x < 12. ? 100992261 : 33948679 ) ) ) : v;\n\tv = p.y == 13. ? ( p.x < 4. ? 84280838 : ( p.x < 8. ? 117901060 : ( p.x < 12. ? 67569415 : 33883653 ) ) ) : v;\n\tv = p.y == 12. ? ( p.x < 4. ? 33686019 : ( p.x < 8. ? 101058054 : ( p.x < 12. ? 101058054 : 50463490 ) ) ) : v;\n\tv = p.y == 11. ? ( p.x < 4. ? 100926726 : ( p.x < 8. ? 101058054 : ( p.x < 12. ? 101058054 : 117900550 ) ) ) : v;\n\tv = p.y == 10. ? ( p.x < 4. ? 100927239 : ( p.x < 8. ? 67078 : ( p.x < 12. ? 101056768 : 117900550 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 100926982 : ( p.x < 8. ? 518 : ( p.x < 12. ? 100794368 : 84280582 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 100794883 : ( p.x < 8. ? 16777734 : ( p.x < 12. ? 100794369 : 33751558 ) ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 100926725 : ( p.x < 8. ? 16843014 : ( p.x < 12. ? 100729089 : 100795398 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 100992006 : ( p.x < 8. ? 33620998 : ( p.x < 12. ? 100925698 : 100860934 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 100926983 : ( p.x < 8. ? 67372550 : ( p.x < 12. ? 101057540 : 84018182 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 16909059 : ( p.x < 8. ? 67503622 : ( p.x < 12. ? 101057542 : 33686017 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 67372807 : ( p.x < 8. ? 67503617 : ( p.x < 12. ? 33949190 : 117900034 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 84280838 : ( p.x < 8. ? 50529026 : ( p.x < 12. ? 84083202 : 101123074 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 84280583 : ( p.x < 8. ? 50594818 : ( p.x < 12. ? 67371779 : 101123586 ) ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 50528771 : ( p.x < 8. ? 33686018 : ( p.x < 12. ? 50463234 : 50529026 ) ) ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = vec3( 0.059, 0.059, 0.035 );\n    color = i == 1. ? vec3( 0.18, 0.19, 0.16 ) : color;\n    color = i == 2. ? vec3( 0.28, 0.29, 0.29 ) : color;\n    color = i == 3. ? vec3( 0.4, 0.44, 0.42 ) : color;\n    color = i == 4. ? vec3( 0.54, 0.58, 0.56 ) : color;\n    color = i == 5. ? vec3( 0.64, 0.69, 0.67 ) : color;\n    color = i == 6. ? vec3( 0.75 ) : color;\n    color = i == 7. ? vec3( 0.88 ) : color;\n}\n\nvoid SpriteDoorClosed( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 15. ? ( p.x < 4. ? 117769991 : ( p.x < 8. ? 50661125 : ( p.x < 12. ? 84215559 : 50660613 ) ) ) : v;\n\tv = p.y == 14. ? ( p.x < 4. ? 16844551 : ( p.x < 8. ? 16843009 : ( p.x < 12. ? 16843009 : 50790657 ) ) ) : v;\n\tv = p.y == 13. ? ( p.x < 4. ? 67176199 : ( p.x < 8. ? 33686018 : ( p.x < 12. ? 33686018 : 50659586 ) ) ) : v;\n\tv = p.y == 12. ? ( p.x < 4. ? 67175171 : ( p.x < 8. ? 16843010 : ( p.x < 12. ? 33620225 : 50528514 ) ) ) : v;\n\tv = p.y == 11. ? ( p.x < 4. ? 16844039 : ( p.x < 8. ? 258 : ( p.x < 12. ? 33619968 : 117899522 ) ) ) : v;\n\tv = p.y == 10. ? ( p.x < 4. ? 16844295 : ( p.x < 8. ? 258 : ( p.x < 12. ? 33619968 : 117899522 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 16844295 : ( p.x < 8. ? 16843010 : ( p.x < 12. ? 33620225 : 84345090 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 33620739 : ( p.x < 8. ? 33686018 : ( p.x < 12. ? 33817090 : 50528514 ) ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 33621253 : ( p.x < 8. ? 33686018 : ( p.x < 12. ? 16908802 : 100925697 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 33621255 : ( p.x < 8. ? 33817090 : ( p.x < 12. ? 16909314 : 117702913 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 16844295 : ( p.x < 8. ? 33686018 : ( p.x < 12. ? 33686018 : 84148482 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 16843779 : ( p.x < 8. ? 33686018 : ( p.x < 12. ? 33686018 : 50528514 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 16844295 : ( p.x < 8. ? 33686018 : ( p.x < 12. ? 33686018 : 117899522 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 67176199 : ( p.x < 8. ? 33686018 : ( p.x < 12. ? 33686018 : 117899522 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 67175687 : ( p.x < 8. ? 33686018 : ( p.x < 12. ? 33686018 : 117899522 ) ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 16843523 : ( p.x < 8. ? 16843009 : ( p.x < 12. ? 16843009 : 50528513 ) ) ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = vec3( 0 );\n    color = i == 1. ? vec3( 0.19, 0.14, 0.14 ) : color;\n    color = i == 2. ? vec3( 0.4, 0.26, 0.098 ) : color;\n    color = i == 3. ? vec3( 0.35 ) : color;\n    color = i == 4. ? vec3( 0.53, 0.38, 0.19 ) : color;\n    color = i == 5. ? vec3( 0.59, 0.67, 0.64 ) : color;\n    color = i == 6. ? vec3( 0.8, 0.64, 0.49 ) : color;\n    color = i == 7. ? vec3( 0.8 ) : color;\n}\n\nvoid SpriteDoorOpen( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 15. ? ( p.x < 4. ? 100927239 : ( p.x < 8. ? 33818116 : ( p.x < 12. ? 67372806 : 33817604 ) ) ) : v;\n\tv = p.y == 14. ? ( p.x < 4. ? 16844551 : ( p.x < 8. ? 16843009 : ( p.x < 12. ? 16843009 : 33947905 ) ) ) : v;\n\tv = p.y == 13. ? ( p.x < 4. ? 67078 : ( p.x < 8. ? 0 : ( p.x < 12. ? 0 : 33816832 ) ) ) : v;\n\tv = p.y == 12. ? ( p.x < 4. ? 66050 : ( p.x < 8. ? 0 : ( p.x < 12. ? 0 : 33685760 ) ) ) : v;\n\tv = p.y == 11. ? ( p.x < 4. ? 66566 : ( p.x < 8. ? 0 : ( p.x < 12. ? 0 : 117899520 ) ) ) : v;\n\tv = p.y == 10. ? ( p.x < 4. ? 66823 : ( p.x < 8. ? 0 : ( p.x < 12. ? 0 : 117899520 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 66822 : ( p.x < 8. ? 0 : ( p.x < 12. ? 0 : 67502336 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 66050 : ( p.x < 8. ? 0 : ( p.x < 12. ? 0 : 33685760 ) ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 66564 : ( p.x < 8. ? 0 : ( p.x < 12. ? 0 : 84082944 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 66566 : ( p.x < 8. ? 0 : ( p.x < 12. ? 0 : 100860160 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 66823 : ( p.x < 8. ? 0 : ( p.x < 12. ? 0 : 67305728 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 66306 : ( p.x < 8. ? 0 : ( p.x < 12. ? 0 : 33685760 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 66823 : ( p.x < 8. ? 0 : ( p.x < 12. ? 0 : 117899520 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 67078 : ( p.x < 8. ? 0 : ( p.x < 12. ? 0 : 101122304 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 66567 : ( p.x < 8. ? 0 : ( p.x < 12. ? 0 : 101122304 ) ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 66050 : ( p.x < 8. ? 0 : ( p.x < 12. ? 0 : 33685760 ) ) ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = i == 1. ? vec3( 0.15, 0.15, 0.14 ) : color;\n    color = i == 2. ? vec3( 0.35 ) : color;\n    color = i == 3. ? vec3( 0.53, 0.37, 0.21 ) : color;\n    color = i == 4. ? vec3( 0.59, 0.67, 0.64 ) : color;\n    color = i == 5. ? vec3( 0.8, 0.64, 0.49 ) : color;\n    color = i == 6. ? vec3( 0.75 ) : color;\n    color = i == 7. ? vec3( 0.85 ) : color;\n}\n\nvoid SpriteDoorLocked( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 15. ? ( p.x < 4. ? 117769991 : ( p.x < 8. ? 50661125 : ( p.x < 12. ? 84215559 : 50660613 ) ) ) : v;\n\tv = p.y == 14. ? ( p.x < 4. ? 16844551 : ( p.x < 8. ? 16843009 : ( p.x < 12. ? 16843009 : 50790657 ) ) ) : v;\n\tv = p.y == 13. ? ( p.x < 4. ? 67176199 : ( p.x < 8. ? 33685762 : ( p.x < 12. ? 33686017 : 50659586 ) ) ) : v;\n\tv = p.y == 12. ? ( p.x < 4. ? 67175171 : ( p.x < 8. ? 16843010 : ( p.x < 12. ? 33620225 : 50528514 ) ) ) : v;\n\tv = p.y == 11. ? ( p.x < 4. ? 16844039 : ( p.x < 8. ? 258 : ( p.x < 12. ? 33619968 : 117899522 ) ) ) : v;\n\tv = p.y == 10. ? ( p.x < 4. ? 16844295 : ( p.x < 8. ? 84214017 : ( p.x < 12. ? 16843525 : 117899522 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 16844295 : ( p.x < 8. ? 50529537 : ( p.x < 12. ? 16974595 : 84345090 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 33620739 : ( p.x < 8. ? 16974594 : ( p.x < 12. ? 16974593 : 50528513 ) ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 33621253 : ( p.x < 8. ? 84215045 : ( p.x < 12. ? 84215045 : 100925697 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 33621255 : ( p.x < 8. ? 50529029 : ( p.x < 12. ? 50529027 : 117702913 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 16844295 : ( p.x < 8. ? 197381 : ( p.x < 12. ? 50529024 : 84148481 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 16843779 : ( p.x < 8. ? 197381 : ( p.x < 12. ? 50529024 : 50528513 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 16844295 : ( p.x < 8. ? 50529029 : ( p.x < 12. ? 50529027 : 117899521 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 33621767 : ( p.x < 8. ? 50529027 : ( p.x < 12. ? 50529027 : 117899521 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 33621255 : ( p.x < 8. ? 16843009 : ( p.x < 12. ? 16843265 : 117899521 ) ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 16843523 : ( p.x < 8. ? 16843009 : ( p.x < 12. ? 16843009 : 50528513 ) ) ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = vec3( 0.024, 0.0078, 0 );\n    color = i == 1. ? vec3( 0.19, 0.13, 0.11 ) : color;\n    color = i == 2. ? vec3( 0.38, 0.25, 0.094 ) : color;\n    color = i == 3. ? vec3( 0.42, 0.39, 0.38 ) : color;\n    color = i == 4. ? vec3( 0.53, 0.38, 0.2 ) : color;\n    color = i == 5. ? vec3( 0.59, 0.62, 0.56 ) : color;\n    color = i == 6. ? vec3( 0.8, 0.64, 0.49 ) : color;\n    color = i == 7. ? vec3( 0.8 ) : color;\n}\n\nvoid SpriteStairsDown( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 15. ? ( p.x < 4. ? 50529284 : ( p.x < 8. ? 67306243 : ( p.x < 12. ? 67372036 : 50594820 ) ) ) : v;\n\tv = p.y == 14. ? ( p.x < 4. ? 117901060 : ( p.x < 8. ? 117835271 : ( p.x < 12. ? 101123847 : 50726407 ) ) ) : v;\n\tv = p.y == 13. ? ( p.x < 4. ? 33751553 : ( p.x < 8. ? 33751555 : ( p.x < 12. ? 33620483 : 50791170 ) ) ) : v;\n\tv = p.y == 12. ? ( p.x < 4. ? 50529028 : ( p.x < 8. ? 16908548 : ( p.x < 12. ? 16843265 : 67568129 ) ) ) : v;\n\tv = p.y == 11. ? ( p.x < 4. ? 117835523 : ( p.x < 8. ? 16843011 : ( p.x < 12. ? 16842753 : 67567873 ) ) ) : v;\n\tv = p.y == 10. ? ( p.x < 4. ? 117835524 : ( p.x < 8. ? 50463235 : ( p.x < 12. ? 65539 : 67567873 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 101123844 : ( p.x < 8. ? 84215044 : ( p.x < 12. ? 2 : 50790400 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 117901060 : ( p.x < 8. ? 84280580 : ( p.x < 12. ? 33620482 : 50790401 ) ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 117900804 : ( p.x < 8. ? 84215044 : ( p.x < 12. ? 84149250 : 50724866 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 117900803 : ( p.x < 8. ? 84215044 : ( p.x < 12. ? 84149506 : 50790657 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 101123844 : ( p.x < 8. ? 84215044 : ( p.x < 12. ? 67372034 : 50725890 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 101123844 : ( p.x < 8. ? 100992260 : ( p.x < 12. ? 67372035 : 50725377 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 101123844 : ( p.x < 8. ? 84215043 : ( p.x < 12. ? 67437570 : 67568129 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 67306243 : ( p.x < 8. ? 50529028 : ( p.x < 12. ? 16908546 : 50790658 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 101123588 : ( p.x < 8. ? 117901062 : ( p.x < 12. ? 117835270 : 50792199 ) ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 67371780 : ( p.x < 8. ? 67371779 : ( p.x < 12. ? 67306499 : 67372035 ) ) ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = vec3( 0.13 );\n    color = i == 1. ? vec3( 0.2 ) : color;\n    color = i == 2. ? vec3( 0.26 ) : color;\n    color = i == 3. ? vec3( 0.31 ) : color;\n    color = i == 4. ? vec3( 0.35 ) : color;\n    color = i == 5. ? vec3( 0.44 ) : color;\n    color = i == 6. ? vec3( 0.51 ) : color;\n    color = i == 7. ? vec3( 0.56 ) : color;\n}\n\nvoid SpriteStairsUp( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 15. ? ( p.x < 4. ? 50529284 : ( p.x < 8. ? 84215045 : ( p.x < 12. ? 84214533 : 84215043 ) ) ) : v;\n\tv = p.y == 14. ? ( p.x < 4. ? 67569412 : ( p.x < 8. ? 50463234 : ( p.x < 12. ? 33751811 : 84215043 ) ) ) : v;\n\tv = p.y == 13. ? ( p.x < 4. ? 50791940 : ( p.x < 8. ? 50594820 : ( p.x < 12. ? 67437829 : 84215042 ) ) ) : v;\n\tv = p.y == 12. ? ( p.x < 4. ? 50726404 : ( p.x < 8. ? 50791943 : ( p.x < 12. ? 84215045 : 84215042 ) ) ) : v;\n\tv = p.y == 11. ? ( p.x < 4. ? 67503875 : ( p.x < 8. ? 50726662 : ( p.x < 12. ? 67371780 : 84214786 ) ) ) : v;\n\tv = p.y == 10. ? ( p.x < 4. ? 67503876 : ( p.x < 8. ? 67503878 : ( p.x < 12. ? 50791943 : 50529027 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 50792196 : ( p.x < 8. ? 50792199 : ( p.x < 12. ? 67569414 : 50594819 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 16843009 : ( p.x < 8. ? 67569415 : ( p.x < 12. ? 67503878 : 50791942 ) ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 17105665 : ( p.x < 8. ? 67503623 : ( p.x < 12. ? 67569158 : 50726663 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 17105664 : ( p.x < 8. ? 65793 : ( p.x < 12. ? 67503878 : 50791942 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 50529025 : ( p.x < 8. ? 16974597 : 50726663 ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 50529025 : ( p.x < 8. ? 16974595 : ( p.x < 12. ? 257 : 50726406 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 50529025 : ( p.x < 8. ? 50529027 : ( p.x < 12. ? 197379 : 67569158 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 50397440 : ( p.x < 8. ? 50529027 : ( p.x < 12. ? 196865 : 65536 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 16974080 : ( p.x < 8. ? 16974593 : ( p.x < 12. ? 50397441 : 197377 ) ) ) : v;\n\tv = p.y == 0. ? 0 : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = vec3( 0.12 );\n    color = i == 1. ? vec3( 0.17 ) : color;\n    color = i == 2. ? vec3( 0.21, 0.2, 0.19 ) : color;\n    color = i == 3. ? vec3( 0.23, 0.23, 0.22 ) : color;\n    color = i == 4. ? vec3( 0.26, 0.26, 0.25 ) : color;\n    color = i == 5. ? vec3( 0.31, 0.31, 0.29 ) : color;\n    color = i == 6. ? vec3( 0.5 ) : color;\n    color = i == 7. ? vec3( 0.53 ) : color;\n}\n\nvoid SpriteKey( inout vec3 color, vec2 p )\n{\n    p -= vec2( 5., 2. );\n    p = p.x < 0. ? vec2( 0. ) : p;    \n    \n    int v = 0;\n\tv = p.y == 11. ? ( p.x < 8. ? 139824 : 0 ) : v;\n\tv = p.y == 10. ? ( p.x < 8. ? 2232611 : 0 ) : v;\n\tv = p.y == 9. ? ( p.x < 8. ? 1179666 : 0 ) : v;\n\tv = p.y == 8. ? ( p.x < 8. ? 1245202 : 0 ) : v;\n\tv = p.y == 7. ? ( p.x < 8. ? 1192482 : 0 ) : v;\n\tv = p.y == 6. ? ( p.x < 8. ? 74256 : 0 ) : v;\n\tv = p.y == 5. ? ( p.x < 8. ? 4608 : 0 ) : v;\n\tv = p.y == 4. ? ( p.x < 8. ? 4608 : 0 ) : v;\n\tv = p.y == 3. ? ( p.x < 8. ? 4608 : 0 ) : v;\n\tv = p.y == 2. ? ( p.x < 8. ? 2232832 : 0 ) : v;\n\tv = p.y == 1. ? ( p.x < 8. ? 135680 : 0 ) : v;\n\tv = p.y == 0. ? ( p.x < 8. ? 2232832 : 0 ) : v;\n    float i = float( ( v >> int( 4. * p.x ) ) & 15 );\n    color = i == 1. ? vec3( 0.45 ) : color;\n    color = i == 2. ? vec3( 0.83 ) : color;\n    color = i == 3. ? vec3( 0.95 ) : color;\n}\n\nvoid SpriteFood( inout vec3 color, vec2 p )\n{\n    p -= vec2( 4., 4. );\n    p = p.x < 0. ? vec2( 0. ) : p;\n    \n    int v = 0;\n\tv = p.y == 7. ? ( p.x < 8. ? 3355392 : 0 ) : v;\n\tv = p.y == 6. ? ( p.x < 8. ? 52498736 : 0 ) : v;\n\tv = p.y == 5. ? ( p.x < 8. ? 839979795 : 0 ) : v;\n\tv = p.y == 4. ? ( p.x < 8. ? 839979283 : 0 ) : v;\n\tv = p.y == 3. ? ( p.x < 8. ? 839979283 : 0 ) : v;\n\tv = p.y == 2. ? ( p.x < 8. ? 841027875 : 0 ) : v;\n\tv = p.y == 1. ? ( p.x < 8. ? 52568624 : 0 ) : v;\n\tv = p.y == 0. ? ( p.x < 8. ? 3355392 : 0 ) : v;\n    float i = float( ( v >> int( 4. * p.x ) ) & 15 );\n    color = i == 1. ? vec3( 0.24 ) : color;\n    color = i == 2. ? vec3( 0.29, 0.74, 0.79 ) : color;\n    color = i == 3. ? vec3( 0.91 ) : color;\n}\n\nvoid SpritePotion( inout vec3 color, vec2 p )\n{\n    p -= vec2( 4., 2. );\n    p = p.x < 0. ? vec2( 0. ) : p;\n    \n    int v = 0;\n\tv = p.y == 11. ? ( p.x < 4. ? 50331648 : ( p.x < 8. ? 4 : 0 ) ) : v;\n\tv = p.y == 10. ? ( p.x < 4. ? 84280832 : ( p.x < 8. ? 394757 : 0 ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 50724864 : ( p.x < 8. ? 1540 : 0 ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 17170432 : ( p.x < 8. ? 1537 : 0 ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 17170432 : ( p.x < 8. ? 1537 : 0 ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 16844288 : ( p.x < 8. ? 393473 : 0 ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 16843014 : ( p.x < 8. ? 100729089 : 0 ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 33686022 : ( p.x < 8. ? 100796162 : 0 ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 33686022 : ( p.x < 8. ? 100796162 : 0 ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 33686022 : ( p.x < 8. ? 100794882 : 0 ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 33687040 : ( p.x < 8. ? 393730 : 0 ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 101056512 : ( p.x < 8. ? 1542 : 0 ) ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = i == 1. ? vec3( 0.24 ) : color;\n    color = i == 2. ? vec3( 0.91, 0, 0.12 ) : color;\n    color = i == 3. ? vec3( 0.6, 0.38, 0.2 ) : color;\n    color = i == 4. ? vec3( 0.71, 0.49, 0.31 ) : color;\n    color = i == 5. ? vec3( 0.83, 0.76, 0.71 ) : color;\n    color = i == 6. ? vec3( 0.85 ) : color;\n    color = i == 7. ? vec3( 1 ) : color;\n}\n\nvoid SpriteRatDead( inout vec3 color, vec2 p )\n{\n    p -= vec2( 2., 1. );\n    p = p.x < 0. ? vec2( 9. ) : p;  \n    \n    int v = 0;\n\tv = p.y == 8. ? ( p.x < 4. ? 33685504 : ( p.x < 8. ? 5 : 0 ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 67371520 : ( p.x < 8. ? 1 : ( p.x < 12. ? 131586 : 0 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 67371522 : ( p.x < 8. ? 50397442 : ( p.x < 12. ? 84149252 : 0 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 67372034 : ( p.x < 8. ? 67240452 : ( p.x < 12. ? 33817604 : 0 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 67371521 : ( p.x < 8. ? 50594308 : ( p.x < 12. ? 16843268 : 0 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 67372033 : ( p.x < 8. ? 67372036 : ( p.x < 12. ? 84149250 : 0 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 67371264 : ( p.x < 8. ? 67371524 : ( p.x < 12. ? 50594818 : 0 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 16844289 : ( p.x < 8. ? 67240450 : ( p.x < 12. ? 16908804 : 0 ) ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 257 : ( p.x < 8. ? 16843009 : ( p.x < 12. ? 100729089 : 460551 ) ) ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = i == 1. ? vec3( 0.16, 0.11, 0.071 ) : color;\n    color = i == 2. ? vec3( 0.33, 0.26, 0.18 ) : color;\n    color = i == 3. ? vec3( 0.58, 0.25, 0.24 ) : color;\n    color = i == 4. ? vec3( 0.51, 0.44, 0.35 ) : color;\n    color = i == 5. ? vec3( 0.81, 0.31, 0.33 ) : color;\n    color = i == 6. ? vec3( 0.8, 0.49, 0.51 ) : color;\n    color = i == 7. ? vec3( 0.93, 0.58, 0.6 ) : color;\n}\n\nvoid SpriteSkeletonDead( inout vec3 color, vec2 p )\n{\n    p -= vec2( 4., 1. );\n    p = p.x < 0. ? vec2( 0. ) : p;    \n    \n    int v = 0;\n\tv = p.y == 6. ? ( p.x < 4. ? 84215040 : ( p.x < 8. ? 328965 : 0 ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 101058053 : ( p.x < 8. ? 84280838 : 0 ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 67372547 : ( p.x < 8. ? 33817604 : 0 ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 17171971 : ( p.x < 8. ? 83953158 : 0 ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 101057024 : ( p.x < 8. ? 84280326 : 0 ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 50462720 : ( p.x < 8. ? 197893 : 0 ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 33554432 : ( p.x < 8. ? 131072 : 0 ) ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = i == 1. ? vec3( 0 ) : color;\n    color = i == 2. ? vec3( 0.49 ) : color;\n    color = i == 3. ? vec3( 0.64 ) : color;\n    color = i == 4. ? vec3( 0.7 ) : color;\n    color = i == 5. ? vec3( 0.81 ) : color;\n    color = i == 6. ? vec3( 0.9 ) : color;\n}\n\nvoid SpriteTrap( inout vec3 color, vec2 p, float pulse )\n{\n    int v = 0;\n\tv = p.y == 15. ? 0 : v;\n\tv = p.y == 14. ? 0 : v;\n\tv = p.y == 13. ? ( p.x < 4. ? 33554432 : ( p.x < 8. ? 16777218 : ( p.x < 12. ? 33554434 : 1 ) ) ) : v;\n\tv = p.y == 12. ? ( p.x < 4. ? 117506048 : ( p.x < 8. ? 84017157 : ( p.x < 12. ? 84017157 : 5 ) ) ) : v;\n\tv = p.y == 11. ? ( p.x < 4. ? 117440512 : ( p.x < 8. ? 83887621 : ( p.x < 12. ? 83887621 : 1543 ) ) ) : v;\n\tv = p.y == 10. ? ( p.x < 4. ? 100663296 : ( p.x < 8. ? 67108870 : ( p.x < 12. ? 67108868 : 4 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 33554432 : ( p.x < 8. ? 16777218 : ( p.x < 12. ? 33554434 : 2 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 83951616 : ( p.x < 8. ? 84017157 : ( p.x < 12. ? 117571589 : 517 ) ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 83886080 : ( p.x < 8. ? 83887623 : ( p.x < 12. ? 117638661 : 1029 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 67108864 : ( p.x < 8. ? 67108868 : ( p.x < 12. ? 100664070 : 6 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 33554432 : ( p.x < 8. ? 16777218 : ( p.x < 12. ? 33554434 : 2 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 117571584 : ( p.x < 8. ? 117571589 : ( p.x < 12. ? 84017157 : 5 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 83886080 : ( p.x < 8. ? 83887621 : ( p.x < 12. ? 84018181 : 1031 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 67108864 : ( p.x < 8. ? 67108868 : ( p.x < 12. ? 100663300 : 516 ) ) ) : v;\n\tv = p.y == 1. ? 0 : v;\n\tv = p.y == 0. ? 0 : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = i == 1. ? vec3( 0.13, 0.13, 0.12 ) : color;\n    color = i == 2. ? vec3( 0.21, 0.2, 0.19 ) : color;\n    color = i == 3. ? vec3( 0.33, 0.32, 0.31 ) : color;\n    color = i == 4. ? vec3( 0.37, 0.37, 0.36 ) : color;\n    color = i == 5. ? pulse * vec3( 0.93, 0.35, 0 ) : color;\n    color = i == 6. ? vec3( 0.44, 0.43, 0.42 ) : color;\n    color = i == 7. ? pulse * vec3( 1, 0.47, 0.051 ) : color;\n}\n\nvoid SpriteMoss( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 15. ? 0 : v;\n\tv = p.y == 14. ? 0 : v;\n\tv = p.y == 13. ? 0 : v;\n\tv = p.y == 12. ? ( p.x < 8. ? 318767104 : ( p.x < 16. ? 3145731 : 0 ) ) : v;\n\tv = p.y == 11. ? ( p.x < 8. ? 318767360 : ( p.x < 16. ? 52428851 : 0 ) ) : v;\n\tv = p.y == 10. ? ( p.x < 8. ? 321912832 : ( p.x < 16. ? 1114129 : 0 ) ) : v;\n\tv = p.y == 9. ? ( p.x < 8. ? 322109440 : ( p.x < 16. ? 51523586 : 0 ) ) : v;\n\tv = p.y == 8. ? ( p.x < 8. ? 322109440 : ( p.x < 16. ? 51589120 : 0 ) ) : v;\n\tv = p.y == 7. ? ( p.x < 8. ? 305135616 : ( p.x < 16. ? 34799667 : 0 ) ) : v;\n\tv = p.y == 6. ? ( p.x < 8. ? 285212672 : ( p.x < 16. ? 819 : 0 ) ) : v;\n\tv = p.y == 5. ? ( p.x < 8. ? 0 : ( p.x < 16. ? 819 : 0 ) ) : v;\n\tv = p.y == 4. ? ( p.x < 8. ? 196608 : 0 ) : v;\n\tv = p.y == 3. ? ( p.x < 8. ? 3354624 : ( p.x < 16. ? 256 : 0 ) ) : v;\n\tv = p.y == 2. ? ( p.x < 8. ? 1118464 : 0 ) : v;\n\tv = p.y == 1. ? ( p.x < 8. ? 204800 : 0 ) : v;\n\tv = p.y == 0. ? 0 : v;\n    float i = float( ( v >> int( 4. * p.x ) ) & 15 );\n    color = i == 1. ? vec3( 0.37, 0.39, 0.14 ) : color;\n    color = i == 2. ? vec3( 0.39, 0.41, 0.16 ) : color;\n    color = i == 3. ? vec3( 0.41, 0.42, 0.18 ) : color;\n}\n\nvec2 FrameOffset( float frame, float tick )\n{\n    vec2 ret = vec2( 0. );\n    ret.x = frame == 1. ? 1. : ( frame == 2. ? -1. : 0. );\n    ret.y = frame == 3. ? 1. : ( frame == 4. ? -1. : 0. );\n    return floor( 16. * ret * ( tick \/ TICK_NUM ) );\n}\n\nfloat Rand( vec2 n )\n{\n\treturn fract( sin( dot( n.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\n}\n\nfloat WaterSDF( vec2 p )\n{\n    float ret = length( p - vec2( 16., 16. ) ) - 16.;\n    ret = min( ret, length( p - vec2( 20., 60. ) ) - 16. );\n    ret = min( ret, length( p - vec2( 18., 38. ) ) - 12. );\n    \n    ret = min( ret, length( p - vec2( 286., 20. ) ) - 36. );\n    \n    ret = min( ret, length( p - vec2( 20., 120. ) ) - 16. );\n    ret = min( ret, length( p - vec2( 20., 160. ) ) - 16. );\n    \n    ret = min( ret, length( p - vec2( 16., 400. ) ) - 20. );\n    \n    ret = min( ret, length( p - vec2( 470., 30. ) ) - 20. );\n    ret = min( ret, length( p - vec2( 480., 80. ) ) - 20. );\n    ret = min( ret, length( p - vec2( 430., 10. ) ) - 20. );\n    \n    ret = min( ret, length( p - vec2( 415., 320. ) ) - 30. );\n    \n    ret = min( ret, length( p - vec2( 130., 320. ) ) - 40. );\n    \n\tret = min( ret, length( p - vec2( 300., 100. ) ) - 50. );    \n    \n    ret = min( ret, length( p - vec2( 80., 480. ) ) - 50. ); \n    \n    ret = min( ret, length( p - vec2( 80., 224. ) ) - 50. ); \n    \n    ret = min( ret, length( p - vec2( 200., 360. ) ) - 50. ); \n    \n    ret += sin( p.y * .75 ) * 1.;    \n    return floor( ret );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    GameState s;\n    LoadState( s );    \n    \n    vec2 playerPos = s.playerPos * 16. + FrameOffset( s.playerFrame, s.tick ); \n    \n    vec2 resMult\t= floor( iResolution.xy \/ REF_RES );\n    float resRcp    = 1. \/ max( min( resMult.x, resMult.y ), 1. );\n    vec2 screenSize = floor( iResolution.xy * resRcp );\n    vec2 pixel      = floor( fragCoord.xy * resRcp );\n    vec2 camera     = clamp( playerPos - floor( screenSize \/ 2. ), vec2( -32. ), vec2( 32. * 16. + 32. ) - screenSize );\n    vec2 world      = pixel + camera;\n    vec2 tile\t\t= floor( world \/ 16. );\n    vec2 worldMod16 = floor( mod( world, 16. ) );\n    vec4 map\t\t= texelFetch( iChannel1, ivec2( tile ), 0 );\n    \n    vec3 color = vec3( 0. );\n    SpriteEarth( color, worldMod16 );\n    if ( Rand( tile \/ 32. ) > .8 )\n    {\n    \tSpriteEarth2( color, worldMod16 );\n    }\n\n    float waterSDF = WaterSDF( world );\n    if ( map.x != 0. )\n    {\n\t\tSpriteFloor( color, worldMod16 );\n        \n \t\tvec3 water;\n        SpriteWater( water, floor( mod( floor( world + vec2( 0., float( iFrame ) * .2 ) ), 16. ) ) );\n        \n        float alpha = waterSDF >= 0. ? 0. : 1.;\n        alpha = waterSDF == -1. ? 0.25 : alpha;\n        alpha = waterSDF == -2. ? 0.5 : alpha;\n        \n    \tcolor = mix( color, water, alpha );\n    }\n    \n    \/\/ decoration\n    if ( map.x == TILE_FLOOR && waterSDF >= 0. )\n    {\n\t\tif ( Rand( tile \/ 32. - 3.15 ) > .8 )\n    \t{\n       \t\t SpriteMoss( color, worldMod16 );\n        } \n        else if ( Rand( tile \/ 32. - 7.19 ) > .9 )\n        {\n            SpriteEarth2( color, worldMod16 );\n        }\n        else if ( Rand( tile \/ 32. - 13.19 ) > .95 )\n        {\n            SpriteTrap( color, worldMod16, 0. );\n        }   \n    }\n    \n    if ( map.x == TILE_STAIRS_UP )\n    {\n        SpriteStairsUp( color, worldMod16 );\n    }\n    if ( map.x == TILE_STAIRS_DOWN )\n    {\n        SpriteStairsDown( color, worldMod16 );\n    }     \n    \n    if ( map.x == TILE_WALL )\n    {\n    \tSpriteWall( color, worldMod16 );\n    }\n    if ( map.x == TILE_WALL_HOLE )\n    {\n    \tSpriteWallHole( color, worldMod16 );\n    }       \n    if ( map.x == TILE_DOOR_LOCKED )\n    {\n        SpriteDoorLocked( color, worldMod16 );\n    }\n    if ( map.x == TILE_DOOR_OPEN )\n    {\n        bool open = s.playerPos == tile || map.z > 0.;\n\t\tfor ( int i = 0; i < ENEMY_NUM; ++i )        \n        {\n            if ( tile == s.enemyPos[ i ] )\n            {\n                open = true;\n            }\n        }\n\n        if ( open )\n        {\n        \tSpriteDoorOpen( color, worldMod16 );\n        }\n        else\n        {\n            SpriteDoorClosed( color, worldMod16 );\n        }\n    }\n    if ( map.x == TILE_TRAP || map.x == TILE_TRAP_OFF )\n    {\n        SpriteTrap( color, worldMod16, map.x == TILE_TRAP ? sin( iTime * 2. ) * .25 + .75 : 0. );\n    }\n\n    if ( map.y == ITEM_KEY )\n    {\n        SpriteKey( color, worldMod16 );\n    }\n    if ( map.y == ITEM_FOOD )\n    {\n        SpriteFood( color, worldMod16 );\n    }\n    if ( map.y == ITEM_POTION )\n    {\n        SpritePotion( color, worldMod16 );\n    }\n    \n    if ( map.z == 1. )\n    {\n        SpriteRatDead( color, worldMod16 );\n    }\n    \n    if ( map.z == 2. )\n    {\n        SpriteSkeletonDead( color, worldMod16 );\n    }\n    \n\tfragColor = vec4( color, 1. );\n}","name":"Buf C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"MssXDB","filepath":"https:\/\/soundcloud.com\/space_lion\/diablo-ost-matt-uelmen-into-town","previewfilepath":"https:\/\/soundcloud.com\/space_lion\/diablo-ost-matt-uelmen-into-town","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\/\/ items and enemies\n\nconst float TICK_NUM\t\t\t= 10.;\nconst float TILE_FLOOR\t\t\t= 1.;\nconst float TILE_DOOR_OPEN\t\t= 2.;\nconst float TILE_STAIRS_DOWN\t= 3.;\nconst float TILE_TRAP\t\t\t= 4.;\nconst float TILE_TRAP_OFF\t\t= 5.;\nconst float TILE_WALL\t\t\t= 6.;\nconst float TILE_WALL_HOLE\t\t= 7.;\nconst float TILE_DOOR_LOCKED\t= 8.;\nconst float TILE_STAIRS_UP\t\t= 9.;\nconst float ITEM_KEY\t\t\t= 1.;\nconst float ITEM_POTION\t\t\t= 2.;\nconst float ITEM_SPAWNER\t\t= 3.;\nconst float LOG_ID_DMG\t\t\t= 1.;\nconst float LOG_ID_XP\t\t\t= 2.;\nconst float LOG_ID_LEVEL_UP\t\t= 3.;\nconst float STATE_START\t\t\t= 0.;\nconst float STATE_GAME\t\t\t= 1.;\nconst float STATE_NEXT_LEVEL\t= 2.;\nconst float STATE_GAME_OVER\t\t= 3.;\n\nconst vec2  REF_RES\t            = vec2( 200. );\n\nconst int   ENEMY_NUM\t\t\t= 3;\nconst int   LOG_NUM\t\t\t\t= 4;\n\nstruct GameState\n{\n    \/\/ 0   \n    float\ttick;\n    float \thp;\n    float \tlevel;\n    float \txp;\n    float \tkeyNum;\n    \n\t\/\/ 1\n    vec2 \tplayerPos;\n    float   playerFrame;\n    float   playerDir;\n    vec2\tbodyPos;\n    float   bodyId;\n    \n    \/\/ 2\n    float \tstate;\n    float   keyLock;\n    float \tstateTime;\n    vec2\tdespawnPos;\n    float   despawnId;\n\n    \/\/ 3\n    vec2\tenemyPos[ ENEMY_NUM ];\n    float \tenemyFrame[ ENEMY_NUM ];\n    float \tenemyDir[ ENEMY_NUM ];\n    float \tenemyHP[ ENEMY_NUM ];\n    float \tenemyId[ ENEMY_NUM ];\n    vec2    enemySpawnPos[ ENEMY_NUM ];\n    \n    \/\/ 4\n    vec2\tlogPos[ LOG_NUM ];\n    float   logLife[ LOG_NUM ];\n    float   logId[ LOG_NUM ];\n    float   logVal[ LOG_NUM ];\n};\n\nvec4 LoadValue( int x, int y )\n{\n    return texelFetch( iChannel0, ivec2( x, y ), 0 );\n}    \n\nfloat PackXY( float a, float b )\n{\n    return floor( a ) + floor( b ) \/ 256.;\n}\n\nfloat PackXY( vec2 v )\n{\n    return PackXY( v.x, v.y );\n}\n\nfloat UnpackX( float a )\n{\n    return floor( a );\n}\n\nfloat UnpackY( float a )\n{\n    return fract( a ) * 256.;\n}\n\nvec2 UnpackXY( float a )\n{\n    return vec2( UnpackX( a ), UnpackY( a ) );\n}\n\nvoid LoadState( out GameState s )\n{\n    vec4 data;\n\n    data = LoadValue( 0, 0 );\n    s.tick \t\t= data.x;\n    s.hp    \t= UnpackX( data.y );\n    s.level    \t= UnpackY( data.y );\n    s.xp        = data.z;\n    s.keyNum    = data.w;\n    \n    data = LoadValue( 1, 0 );\n    s.playerPos   = UnpackXY( data.x );\n    s.playerFrame = UnpackX( data.y );\n    s.playerDir   = UnpackY( data.y );\n    s.bodyPos\t  = UnpackXY( data.z );\n    s.bodyId      = data.w;\n    \n    data = LoadValue( 2, 0 );\n    s.state      = UnpackX( data.x );\n    s.keyLock    = UnpackY( data.x );\n    s.stateTime  = data.y;\n    s.despawnPos = UnpackXY( data.z );\n    s.despawnId  = data.w;\n\n    for ( int i = 0; i < ENEMY_NUM; ++i )\n    {\n        data = LoadValue( 3, i );\n        s.enemyPos[ i ]      = UnpackXY( data.x );\n        s.enemyFrame[ i ]    = UnpackX( data.y );\n        s.enemyDir[ i ]      = UnpackY( data.y );\n        s.enemyHP[ i ]       = UnpackX( data.z );\n        s.enemyId[ i ]       = UnpackY( data.z );\n        s.enemySpawnPos[ i ] = UnpackXY( data.w );\n    }\n    \n    for ( int i = 0; i < LOG_NUM; ++i )\n    {\n\t\tdata = LoadValue( 4, i );\n    \ts.logPos[ i ]  = data.xy;\n        s.logLife[ i ] = data.z;\n        s.logId[ i ]   = UnpackX( data.w );\n        s.logVal[ i ]  = UnpackY( data.w );\n    }    \n}\n\nfloat saturate( float x )\n{\n    return clamp( x, 0., 1. );\n}\n\nfloat Smooth( float x )\n{\n\treturn smoothstep( 0., 1., saturate( x ) );   \n}\n\nvoid SpriteRat( inout vec3 color, vec2 p )\n{\n\tp -= vec2( 0., 1. );    \n    \n    int v = 0;\n\tv = p.y == 11. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 33554946 : ( p.x < 12. ? 131586 : 0 ) ) ) : v;\n\tv = p.y == 10. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 67241730 : ( p.x < 12. ? 33817604 : 0 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 67371520 : ( p.x < 12. ? 33948678 : 0 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 67371520 : ( p.x < 12. ? 67372036 : 2 ) ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 67372034 : ( p.x < 12. ? 67372036 : 2 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 67372034 : ( p.x < 12. ? 16843010 : 5 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 33554432 : ( p.x < 8. ? 67372036 : ( p.x < 12. ? 66052 : 0 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 33554432 : ( p.x < 8. ? 67372036 : ( p.x < 12. ? 197635 : 0 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 16777216 : ( p.x < 8. ? 33686532 : ( p.x < 12. ? 33817604 : 0 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 16777216 : ( p.x < 8. ? 67372034 : ( p.x < 12. ? 33817602 : 0 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 16777216 : ( p.x < 8. ? 67371522 : ( p.x < 12. ? 16909313 : 0 ) ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 117901063 : ( p.x < 8. ? 50397441 : ( p.x < 12. ? 83951877 : 0 ) ) ) : v;\n    float i = float( ( v >> int( 8.0 * p.x ) ) & 255 );\n    color = i == 1. ? vec3( 0.16, 0.11, 0.071 ) : color;\n    color = i == 2. ? vec3( 0.33, 0.26, 0.18 ) : color;\n    color = i == 3. ? vec3( 0.58, 0.25, 0.24 ) : color;\n    color = i == 4. ? vec3( 0.51, 0.44, 0.35 ) : color;\n    color = i == 5. ? vec3( 0.81, 0.31, 0.33 ) : color;\n    color = i == 6. ? vec3( 1, 0.4, 0.3 ) : color;\n    color = i == 7. ? vec3( 0.86, 0.53, 0.55 ) : color;\n}\n\nvoid SpriteRatAttack( inout vec3 color, vec2 p )\n{\n\tp -= vec2( 0., 1. );    \n    \n    int v = 0;\n\tv = p.y == 10. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 33685504 : ( p.x < 12. ? 33686016 : 2 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 117571584 : ( p.x < 12. ? 67372034 : 516 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 67240448 : ( p.x < 12. ? 67503108 : 518 ) ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 67372034 : ( p.x < 12. ? 67372036 : 132100 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 67372034 : ( p.x < 12. ? 67372036 : 132100 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 33554432 : ( p.x < 8. ? 67372036 : ( p.x < 12. ? 83952644 : 393477 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 33554432 : ( p.x < 8. ? 67372036 : ( p.x < 12. ? 50397953 : 0 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 16777216 : ( p.x < 8. ? 33686532 : ( p.x < 12. ? 33817604 : 0 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 16777216 : ( p.x < 8. ? 67372034 : ( p.x < 12. ? 33817602 : 0 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 16777216 : ( p.x < 8. ? 67371522 : ( p.x < 12. ? 16909313 : 0 ) ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 117901063 : ( p.x < 8. ? 50397441 : ( p.x < 12. ? 100729094 : 0 ) ) ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = i == 1. ? vec3( 0.16, 0.11, 0.071 ) : color;\n    color = i == 2. ? vec3( 0.33, 0.26, 0.18 ) : color;\n    color = i == 3. ? vec3( 0.58, 0.25, 0.24 ) : color;\n    color = i == 4. ? vec3( 0.51, 0.44, 0.35 ) : color;\n    color = i == 5. ? vec3( 1, 0.09, 0.09 ) : color;\n    color = i == 6. ? vec3( 0.9, 0.36, 0.31 ) : color;\n    color = i == 7. ? vec3( 0.86, 0.53, 0.55 ) : color;\n}\n\nvoid SpriteRatWalk( inout vec3 color, vec2 p )\n{\n    p -= vec2( 0., 1. );\n    \n    int v = 0;\n\tv = p.y == 12. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 33554946 : ( p.x < 12. ? 131586 : 0 ) ) ) : v;\n\tv = p.y == 11. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 67241730 : ( p.x < 12. ? 33817604 : 0 ) ) ) : v;\n\tv = p.y == 10. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 67371520 : ( p.x < 12. ? 33948678 : 0 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 67371520 : ( p.x < 12. ? 67372036 : 2 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 67372034 : ( p.x < 12. ? 67372036 : 2 ) ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 67372034 : ( p.x < 12. ? 16843010 : 5 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 33554432 : ( p.x < 8. ? 67372036 : ( p.x < 12. ? 66052 : 0 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 33554432 : ( p.x < 8. ? 67372036 : ( p.x < 12. ? 197635 : 0 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 16777216 : ( p.x < 8. ? 33686532 : ( p.x < 12. ? 33817604 : 0 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 16777216 : ( p.x < 8. ? 67372034 : ( p.x < 12. ? 33817602 : 0 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 16777216 : ( p.x < 8. ? 67371522 : ( p.x < 12. ? 16909313 : 0 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 117440512 : ( p.x < 8. ? 16974081 : ( p.x < 12. ? 65793 : 0 ) ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 460551 : ( p.x < 8. ? 83886080 : ( p.x < 12. ? 327680 : 0 ) ) ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = i == 1. ? vec3( 0.16, 0.11, 0.071 ) : color;\n    color = i == 2. ? vec3( 0.33, 0.26, 0.18 ) : color;\n    color = i == 3. ? vec3( 0.58, 0.25, 0.24 ) : color;\n    color = i == 4. ? vec3( 0.51, 0.44, 0.35 ) : color;\n    color = i == 5. ? vec3( 0.81, 0.31, 0.33 ) : color;\n    color = i == 6. ? vec3( 1, 0.4, 0.3 ) : color;\n    color = i == 7. ? vec3( 0.86, 0.53, 0.55 ) : color;\n}\n\nvoid SpriteSkeleton( inout vec3 color, vec2 p )\n{\n    p -= vec2( 4., 1. );\n    p = p.x < 0. ? vec2( 8. ) : p;        \n    \n    int v = 0;\n\tv = p.y == 13. ? ( p.x < 4. ? 101056512 : ( p.x < 8. ? 101058054 : 0 ) ) : v;\n\tv = p.y == 12. ? ( p.x < 4. ? 117900800 : ( p.x < 8. ? 117901063 : ( p.x < 12. ? 6 : 0 ) ) ) : v;\n\tv = p.y == 11. ? ( p.x < 4. ? 67568384 : ( p.x < 8. ? 67372036 : ( p.x < 12. ? 2 : 0 ) ) ) : v;\n\tv = p.y == 10. ? ( p.x < 4. ? 117900032 : ( p.x < 8. ? 17237761 : ( p.x < 12. ? 6 : 0 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 117571584 : ( p.x < 8. ? 117704455 : ( p.x < 12. ? 6 : 0 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 33554432 : ( p.x < 8. ? 50726403 : 0 ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 33554434 : 0 ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 117835264 : ( p.x < 8. ? 101123847 : 0 ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 67108870 : ( p.x < 8. ? 328965 : ( p.x < 12. ? 2 : 0 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 1539 : ( p.x < 8. ? 33554944 : ( p.x < 12. ? 2 : 0 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 101057282 : ( p.x < 8. ? 101058054 : ( p.x < 12. ? 2 : 0 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 196608 : ( p.x < 8. ? 393216 : 0 ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 1536 : ( p.x < 8. ? 393216 : 0 ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 771 : ( p.x < 8. ? 50528256 : 0 ) ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = i == 1. ? vec3( 0 ) : color;\n    color = i == 2. ? vec3( 0.49 ) : color;\n    color = i == 3. ? vec3( 0.64 ) : color;\n    color = i == 4. ? vec3( 0.7 ) : color;\n    color = i == 5. ? vec3( 0.8 ) : color;\n    color = i == 6. ? vec3( 0.81 ) : color;\n    color = i == 7. ? vec3( 0.9 ) : color;\n}\n\nvoid SpriteSkeletonWalk( inout vec3 color, vec2 p )\n{\n    p -= vec2( 4., 1. );\n    p = p.x < 0. ? vec2( 8. ) : p;     \n    \n    int v = 0;\n\tv = p.y == 13. ? ( p.x < 4. ? 101056512 : ( p.x < 8. ? 101058054 : 0 ) ) : v;\n\tv = p.y == 12. ? ( p.x < 4. ? 117900800 : ( p.x < 8. ? 117901063 : ( p.x < 12. ? 6 : 0 ) ) ) : v;\n\tv = p.y == 11. ? ( p.x < 4. ? 67568384 : ( p.x < 8. ? 67372036 : ( p.x < 12. ? 2 : 0 ) ) ) : v;\n\tv = p.y == 10. ? ( p.x < 4. ? 117900032 : ( p.x < 8. ? 17237761 : ( p.x < 12. ? 6 : 0 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 117571584 : ( p.x < 8. ? 117704455 : ( p.x < 12. ? 6 : 0 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 33554432 : ( p.x < 8. ? 50726403 : 0 ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 33554434 : 0 ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 117835264 : ( p.x < 8. ? 101123847 : 0 ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 67108870 : ( p.x < 8. ? 328965 : ( p.x < 12. ? 2 : 0 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 393984 : ( p.x < 8. ? 33554944 : ( p.x < 12. ? 2 : 0 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 100860416 : ( p.x < 8. ? 101058054 : ( p.x < 12. ? 2 : 0 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 196608 : ( p.x < 8. ? 100990976 : 0 ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 1536 : ( p.x < 8. ? 393984 : 0 ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 197376 : 0 ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = i == 1. ? vec3( 0 ) : color;\n    color = i == 2. ? vec3( 0.49 ) : color;\n    color = i == 3. ? vec3( 0.64 ) : color;\n    color = i == 4. ? vec3( 0.7 ) : color;\n    color = i == 5. ? vec3( 0.8 ) : color;\n    color = i == 6. ? vec3( 0.81 ) : color;\n    color = i == 7. ? vec3( 0.9 ) : color;\n}\n\nvoid SpriteSkeletonAttack( inout vec3 color, vec2 p )\n{\n    p -= vec2( 4., 1. );\n    p = p.x < 0. ? vec2( 10. ) : p;    \n    \n    int v = 0;\n\tv = p.y == 13. ? ( p.x < 4. ? 100663296 : ( p.x < 8. ? 101058054 : ( p.x < 12. ? 6 : 0 ) ) ) : v;\n\tv = p.y == 12. ? ( p.x < 4. ? 117833728 : ( p.x < 8. ? 117901063 : ( p.x < 12. ? 1543 : 0 ) ) ) : v;\n\tv = p.y == 11. ? ( p.x < 4. ? 117637120 : ( p.x < 8. ? 67372036 : ( p.x < 12. ? 516 : 0 ) ) ) : v;\n\tv = p.y == 10. ? ( p.x < 4. ? 117637120 : ( p.x < 8. ? 117899527 : ( p.x < 12. ? 1537 : 0 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 33554432 : ( p.x < 8. ? 67569415 : ( p.x < 12. ? 1543 : 0 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 101057794 : ( p.x < 12. ? 3 : 0 ) ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 512 : ( p.x < 12. ? 2 : 0 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 101058048 : ( p.x < 8. ? 100861446 : 0 ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 84213760 : ( p.x < 8. ? 50464005 : ( p.x < 12. ? 2 : 0 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 33554944 : ( p.x < 12. ? 2 : 0 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 101056512 : ( p.x < 8. ? 101058054 : 0 ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 196608 : ( p.x < 8. ? 393216 : 0 ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 1536 : ( p.x < 8. ? 393216 : 0 ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 771 : ( p.x < 8. ? 50528256 : 0 ) ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = i == 1. ? vec3( 0 ) : color;\n    color = i == 2. ? vec3( 0.49 ) : color;\n    color = i == 3. ? vec3( 0.64 ) : color;\n    color = i == 4. ? vec3( 0.7 ) : color;\n    color = i == 5. ? vec3( 0.8 ) : color;\n    color = i == 6. ? vec3( 0.81 ) : color;\n    color = i == 7. ? vec3( 0.9 ) : color;\n}\n\nvoid SpriteWarriorHead( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 7. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 33686016 : ( p.x < 12. ? 2 : 0 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 33685504 : ( p.x < 8. ? 67372034 : ( p.x < 12. ? 516 : 0 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 67371520 : ( p.x < 8. ? 67372036 : ( p.x < 12. ? 132100 : 0 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 67239936 : ( p.x < 8. ? 117901062 : ( p.x < 12. ? 132103 : 0 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 84148736 : ( p.x < 8. ? 84214021 : ( p.x < 12. ? 769 : 0 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 84148992 : ( p.x < 8. ? 101057798 : ( p.x < 12. ? 1029 : 0 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 67239936 : ( p.x < 8. ? 67372038 : ( p.x < 12. ? 1028 : 0 ) ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 67239936 : ( p.x < 8. ? 33686020 : ( p.x < 12. ? 514 : 0 ) ) ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = i == 1. ? vec3( 0 ) : color;\n    color = i == 2. ? vec3( 0.64, 0.2, 0.047 ) : color;\n    color = i == 3. ? vec3( 0.52, 0.35, 0.22 ) : color;\n    color = i == 4. ? vec3( 0.77, 0.47, 0.29 ) : color;\n    color = i == 5. ? vec3( 0.72, 0.59, 0.47 ) : color;\n    color = i == 6. ? vec3( 0.86, 0.71, 0.59 ) : color;\n    color = i == 7. ? vec3( 1, 0.85, 0.75 ) : color;\n}\n\nvoid SpriteWarriorStand( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 6. ? ( p.x < 4. ? 101057536 : ( p.x < 8. ? 33620485 : ( p.x < 12. ? 770 : 0 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 16908802 : ( p.x < 8. ? 117901061 : ( p.x < 12. ? 261 : 0 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 17040897 : ( p.x < 8. ? 33686018 : ( p.x < 12. ? 258 : 0 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 33620736 : ( p.x < 8. ? 117901061 : ( p.x < 12. ? 770 : 0 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 33619968 : ( p.x < 8. ? 33685761 : ( p.x < 12. ? 1 : 0 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 16908544 : ( p.x < 8. ? 33619968 : ( p.x < 12. ? 1 : 0 ) ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 16843008 : ( p.x < 8. ? 16842752 : ( p.x < 12. ? 1 : 0 ) ) ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = i == 1. ? vec3( 0.09, 0.11, 0.18 ) : color;\n    color = i == 2. ? vec3( 0.28, 0.35, 0.45 ) : color;\n    color = i == 3. ? vec3( 1, 0.36, 0.043 ) : color;\n    color = i == 4. ? vec3( 1, 0.65, 0.25 ) : color;\n    color = i == 5. ? vec3( 0.54, 0.67, 0.73 ) : color;\n    color = i == 6. ? vec3( 1, 0.85, 0.56 ) : color;\n    color = i == 7. ? vec3( 0.91, 1, 1 ) : color;\n}\n\nvoid SpriteWarriorWalk( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 6. ? ( p.x < 4. ? 101057536 : ( p.x < 8. ? 33620485 : ( p.x < 12. ? 770 : 0 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 33620481 : ( p.x < 8. ? 117901061 : ( p.x < 12. ? 261 : 0 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 67371521 : ( p.x < 8. ? 33686018 : ( p.x < 12. ? 257 : 0 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 33751296 : ( p.x < 8. ? 33687301 : ( p.x < 12. ? 1797 : 0 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 33619968 : ( p.x < 8. ? 33620225 : ( p.x < 12. ? 1 : 0 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 16842752 : ( p.x < 8. ? 16842752 : 0 ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 16842752 : 0 ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = i == 1. ? vec3( 0.09, 0.11, 0.18 ) : color;\n    color = i == 2. ? vec3( 0.29, 0.34, 0.45 ) : color;\n    color = i == 3. ? vec3( 1, 0.36, 0.043 ) : color;\n    color = i == 4. ? vec3( 1, 0.62, 0.23 ) : color;\n    color = i == 5. ? vec3( 0.54, 0.67, 0.73 ) : color;\n    color = i == 6. ? vec3( 1, 0.91, 0.62 ) : color;\n    color = i == 7. ? vec3( 0.87, 1, 1 ) : color;\n}\n\nvoid SpriteWarriorAttack( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 6. ? ( p.x < 4. ? 101057536 : ( p.x < 8. ? 16910085 : ( p.x < 12. ? 1026 : 0 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 33687298 : ( p.x < 8. ? 117901061 : ( p.x < 12. ? 67503367 : 0 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 16844292 : ( p.x < 8. ? 33686018 : ( p.x < 12. ? 50528770 : 0 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 16777987 : ( p.x < 8. ? 117901058 : ( p.x < 12. ? 261 : 0 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 16777216 : ( p.x < 8. ? 33620226 : ( p.x < 12. ? 263 : 0 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 33619968 : ( p.x < 8. ? 16777217 : ( p.x < 12. ? 258 : 0 ) ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 16842752 : ( p.x < 8. ? 16777217 : ( p.x < 12. ? 257 : 0 ) ) ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = i == 1. ? vec3( 0.09, 0.11, 0.18 ) : color;\n    color = i == 2. ? vec3( 0.28, 0.35, 0.45 ) : color;\n    color = i == 3. ? vec3( 1, 0.36, 0.043 ) : color;\n    color = i == 4. ? vec3( 1, 0.65, 0.25 ) : color;\n    color = i == 5. ? vec3( 0.54, 0.67, 0.73 ) : color;\n    color = i == 6. ? vec3( 1, 0.85, 0.56 ) : color;\n    color = i == 7. ? vec3( 0.91, 1, 1 ) : color;\n}\n\nvec2 FrameOffset( float frame, float tick )\n{\n    vec2 ret = vec2( 0. );\n    ret.x = frame == 1. ? 1. : ( frame == 2. ? -1. : 0. );\n    ret.y = frame == 3. ? 1. : ( frame == 4. ? -1. : 0. );\n    return floor( 16. * ret * ( tick \/ TICK_NUM ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    GameState s;\n    LoadState( s );    \n    \n    vec2 playerPos = s.playerPos * 16. + FrameOffset( s.playerFrame, s.tick ); \n    \n    vec2 resMult\t= floor( iResolution.xy \/ REF_RES );\n    float resRcp    = 1. \/ max( min( resMult.x, resMult.y ), 1. );\n    vec2 screenSize = floor( iResolution.xy * resRcp );\n    vec2 pixel      = floor( fragCoord.xy * resRcp );\n\tvec2 camera     = clamp( playerPos - floor( screenSize \/ 2. ), vec2( -32. ), vec2( 32. * 16. + 32. ) - screenSize );\n    vec2 world      = pixel + camera;\n    vec2 tile\t\t= floor( world \/ 16. );\n    vec2 worldMod16 = floor( mod( world, 16. ) );\n    vec4 map\t\t= texelFetch( iChannel1, ivec2( tile ), 0 );\n    float tick2     = s.tick > TICK_NUM \/ 2. ? 1. : 0.;\n    \n    vec3 color = texelFetch( iChannel2, ivec2( fragCoord ), 0 ).xyz;\n    \n    vec2 warrior = world - playerPos;\n    warrior.x = s.playerDir > 0. ? 13. - warrior.x : warrior.x - 2.;\n    warrior.y -= 1.;\n    if ( warrior.x >= 0. && warrior.y >= 0. && warrior.x < 16. && warrior.y < 16. \n         && s.hp > 0. )\n    {\n        float walk = s.playerFrame > 0. && tick2 == 1. ? 1. : 0.;\n        if ( warrior.x >= 1. - walk )\n        {\n        \tSpriteWarriorHead( color, warrior - vec2( 1. - walk, 7. ) );   \n        }\n\n        if ( s.playerFrame == 6. && tick2 == 1. )\n        {\n            SpriteWarriorAttack( color, warrior );\n        }        \n        else if ( walk == 1. )\n        {\n\t\t\tSpriteWarriorWalk( color, warrior );\n        }\n        else if ( warrior.x >= 1. )\n        {\n\t\t\tSpriteWarriorStand( color, warrior - vec2( 1., 0. ) );\n        }\n    }\n    \n    for ( int i = 0; i < ENEMY_NUM; ++i )\n    {\n    \tvec3 enemyColor = color;\n        \n        vec2 enemy = world - s.enemyPos[ i ] * 16. + FrameOffset( s.enemyFrame[ i ], s.tick );\n\t\tenemy.x = s.enemyDir[ i ] > 0. ? 15. - enemy.x : enemy.x;\n        if ( enemy.x >= 0. && enemy.y >= 0. && enemy.x < 16. && enemy.y < 16. && s.enemyPos[ i ].x > 0. )\n    \t{\n            if ( s.enemyFrame[ i ] == 5. && tick2 == 1. )\n            {\n                if ( s.enemyId[ i ] == 0. )\n                \tSpriteRatAttack( enemyColor, enemy );\n                else\n                    SpriteSkeletonAttack( enemyColor, enemy );\n            }\n            else if ( s.enemyFrame[ i ] > 0. && tick2 == 1. )\n            {\n                if ( s.enemyId[ i ] == 0. )\n                \tSpriteRatWalk( enemyColor, enemy );\n                else\n                \tSpriteSkeletonWalk( enemyColor, enemy );\n            }\n            else\n            {\n                if ( s.enemyId[ i ] == 0. )\n        \t\t\tSpriteRat( enemyColor, enemy );\n                else\n                    SpriteSkeleton( enemyColor, enemy );\n\t\t\t}\n        }\n        \n        \/\/ fog of war\n        float dist = length( playerPos - s.enemyPos[ i ] * 16. );\n\t\tcolor = mix( color, enemyColor, saturate( ( 64. + 16. - dist ) \/ 32. ) );\n    }\n    \n\tfragColor = vec4( color, 1. );\n}","name":"Buf D","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"4dfXDn","date":"1439840550","viewed":21547,"name":"2d signed distance functions","username":"Maarten","description":"test stuff for signed distance fields, just a playground\nupdate: added early out in shadow, made min step larger (1 instead of 0.5), made step equal to distance instead of half distance\nthis allows fewer steps without light bleeding","likes":444,"published":1,"flags":0,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/**\n\n\tHi all,\n\n\tThis is just my playground for a bunch of 2D stuff:\n\n\tSome distance functions and blend functions\n\tCone marched 2D Soft shadows\n\tUse the mouse to control the 3rd light\n\n*\/\n\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Combine distance field functions \/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\nfloat smoothMerge(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5*(d2 - d1)\/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0-h);\n}\n\n\nfloat merge(float d1, float d2)\n{\n\treturn min(d1, d2);\n}\n\n\nfloat mergeExclude(float d1, float d2)\n{\n\treturn min(max(-d1, d2), max(-d2, d1));\n}\n\n\nfloat substract(float d1, float d2)\n{\n\treturn max(-d1, d2);\n}\n\n\nfloat intersect(float d1, float d2)\n{\n\treturn max(d1, d2);\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Rotation and translation \/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\nvec2 rotateCCW(vec2 p, float a)\n{\n\tmat2 m = mat2(cos(a), sin(a), -sin(a), cos(a));\n\treturn p * m;\t\n}\n\n\nvec2 rotateCW(vec2 p, float a)\n{\n\tmat2 m = mat2(cos(a), -sin(a), sin(a), cos(a));\n\treturn p * m;\n}\n\n\nvec2 translate(vec2 p, vec2 t)\n{\n\treturn p - t;\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Distance field functions \/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\nfloat pie(vec2 p, float angle)\n{\n\tangle = radians(angle) \/ 2.0;\n\tvec2 n = vec2(cos(angle), sin(angle));\n\treturn abs(p).x * n.x + p.y*n.y;\n}\n\n\nfloat circleDist(vec2 p, float radius)\n{\n\treturn length(p) - radius;\n}\n\n\nfloat triangleDist(vec2 p, float radius)\n{\n\treturn max(\tabs(p).x * 0.866025 + \n\t\t\t   \tp.y * 0.5, -p.y) \n\t\t\t\t-radius * 0.5;\n}\n\n\nfloat triangleDist(vec2 p, float width, float height)\n{\n\tvec2 n = normalize(vec2(height, width \/ 2.0));\n\treturn max(\tabs(p).x*n.x + p.y*n.y - (height*n.y), -p.y);\n}\n\n\nfloat semiCircleDist(vec2 p, float radius, float angle, float width)\n{\n\twidth \/= 2.0;\n\tradius -= width;\n\treturn substract(pie(p, angle), \n\t\t\t\t\t abs(circleDist(p, radius)) - width);\n}\n\n\nfloat boxDist(vec2 p, vec2 size, float radius)\n{\n\tsize -= vec2(radius);\n\tvec2 d = abs(p) - size;\n  \treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n}\n\n\nfloat lineDist(vec2 p, vec2 start, vec2 end, float width)\n{\n\tvec2 dir = start - end;\n\tfloat lngth = length(dir);\n\tdir \/= lngth;\n\tvec2 proj = max(0.0, min(lngth, dot((start - p), dir))) * dir;\n\treturn length( (start - p) - proj ) - (width \/ 2.0);\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Masks for drawing \/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\nfloat fillMask(float dist)\n{\n\treturn clamp(-dist, 0.0, 1.0);\n}\n\n\nfloat innerBorderMask(float dist, float width)\n{\n\t\/\/dist += 1.0;\n\tfloat alpha1 = clamp(dist + width, 0.0, 1.0);\n\tfloat alpha2 = clamp(dist, 0.0, 1.0);\n\treturn alpha1 - alpha2;\n}\n\n\nfloat outerBorderMask(float dist, float width)\n{\n\t\/\/dist += 1.0;\n\tfloat alpha1 = clamp(dist, 0.0, 1.0);\n\tfloat alpha2 = clamp(dist - width, 0.0, 1.0);\n\treturn alpha1 - alpha2;\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ The scene \/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\nfloat sceneDist(vec2 p)\n{\n\tfloat c = circleDist(\t\ttranslate(p, vec2(100, 250)), 40.0);\n\tfloat b1 =  boxDist(\t\ttranslate(p, vec2(200, 250)), vec2(40, 40), \t0.0);\n\tfloat b2 =  boxDist(\t\ttranslate(p, vec2(300, 250)), vec2(40, 40), \t10.0);\n\tfloat l = lineDist(\t\t\tp, \t\t\t vec2(370, 220),  vec2(430, 280),\t10.0);\n\tfloat t1 = triangleDist(\ttranslate(p, vec2(500, 210)), 80.0, \t\t\t80.0);\n\tfloat t2 = triangleDist(\trotateCW(translate(p, vec2(600, 250)), iTime), 40.0);\n\t\n\tfloat m = \tmerge(c, b1);\n\tm = \t\tmerge(m, b2);\n\tm = \t\tmerge(m, l);\n\tm = \t\tmerge(m, t1);\n\tm = \t\tmerge(m, t2);\n\t\n\tfloat b3 = boxDist(\t\ttranslate(p, vec2(100, sin(iTime * 3.0 + 1.0) * 40.0 + 100.0)), \n\t\t\t\t\t   \t\tvec2(40, 15), \t0.0);\n\tfloat c2 = circleDist(\ttranslate(p, vec2(100, 100)),\t30.0);\n\tfloat s = substract(b3, c2);\n\t\n\tfloat b4 = boxDist(\t\ttranslate(p, vec2(200, sin(iTime * 3.0 + 2.0) * 40.0 + 100.0)), \n\t\t\t\t\t   \t\tvec2(40, 15), \t0.0);\n\tfloat c3 = circleDist(\ttranslate(p, vec2(200, 100)), \t30.0);\n\tfloat i = intersect(b4, c3);\n\t\n\tfloat b5 = boxDist(\t\ttranslate(p, vec2(300, sin(iTime * 3.0 + 3.0) * 40.0 + 100.0)), \n\t\t\t\t\t   \t\tvec2(40, 15), \t0.0);\n\tfloat c4 = circleDist(\ttranslate(p, vec2(300, 100)), \t30.0);\n\tfloat a = merge(b5, c4);\n\t\n\tfloat b6 = boxDist(\t\ttranslate(p, vec2(400, 100)),\tvec2(40, 15), \t0.0);\n\tfloat c5 = circleDist(\ttranslate(p, vec2(400, 100)), \t30.0);\n\tfloat sm = smoothMerge(b6, c5, 10.0);\n\t\n\tfloat sc = semiCircleDist(translate(p, vec2(500,100)), 40.0, 90.0, 10.0);\n    \n    float b7 = boxDist(\t\ttranslate(p, vec2(600, sin(iTime * 3.0 + 3.0) * 40.0 + 100.0)), \n\t\t\t\t\t   \t\tvec2(40, 15), \t0.0);\n\tfloat c6 = circleDist(\ttranslate(p, vec2(600, 100)), \t30.0);\n\tfloat e = mergeExclude(b7, c6);\n    \n\tm = merge(m, s);\n\tm = merge(m, i);\n\tm = merge(m, a);\n\tm = merge(m, sm);\n\tm = merge(m, sc);\n    m = merge(m, e);\n\t\n\treturn m;\n}\n\n\nfloat sceneSmooth(vec2 p, float r)\n{\n\tfloat accum = sceneDist(p);\n\taccum += sceneDist(p + vec2(0.0, r));\n\taccum += sceneDist(p + vec2(0.0, -r));\n\taccum += sceneDist(p + vec2(r, 0.0));\n\taccum += sceneDist(p + vec2(-r, 0.0));\n\treturn accum \/ 5.0;\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Shadow and light \/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\nfloat shadow(vec2 p, vec2 pos, float radius)\n{\n\tvec2 dir = normalize(pos - p);\n\tfloat dl = length(p - pos);\n\t\n\t\/\/ fraction of light visible, starts at one radius (second half added in the end);\n\tfloat lf = radius * dl;\n\t\n\t\/\/ distance traveled\n\tfloat dt = 0.01;\n\n\tfor (int i = 0; i < 64; ++i)\n\t{\t\t\t\t\n\t\t\/\/ distance to scene at current position\n\t\tfloat sd = sceneDist(p + dir * dt);\n\n        \/\/ early out when this ray is guaranteed to be full shadow\n        if (sd < -radius) \n            return 0.0;\n        \n\t\t\/\/ width of cone-overlap at light\n\t\t\/\/ 0 in center, so 50% overlap: add one radius outside of loop to get total coverage\n\t\t\/\/ should be '(sd \/ dt) * dl', but '*dl' outside of loop\n\t\tlf = min(lf, sd \/ dt);\n\t\t\n\t\t\/\/ move ahead\n\t\tdt += max(1.0, abs(sd));\n\t\tif (dt > dl) break;\n\t}\n\n\t\/\/ multiply by dl to get the real projected overlap (moved out of loop)\n\t\/\/ add one radius, before between -radius and + radius\n\t\/\/ normalize to 1 ( \/ 2*radius)\n\tlf = clamp((lf*dl + radius) \/ (2.0 * radius), 0.0, 1.0);\n\tlf = smoothstep(0.0, 1.0, lf);\n\treturn lf;\n}\n\n\n\nvec4 drawLight(vec2 p, vec2 pos, vec4 color, float dist, float range, float radius)\n{\n\t\/\/ distance to light\n\tfloat ld = length(p - pos);\n\t\n\t\/\/ out of range\n\tif (ld > range) return vec4(0.0);\n\t\n\t\/\/ shadow and falloff\n\tfloat shad = shadow(p, pos, radius);\n\tfloat fall = (range - ld)\/range;\n\tfall *= fall;\n\tfloat source = fillMask(circleDist(p - pos, radius));\n\treturn (shad * fall + source) * color;\n}\n\n\nfloat luminance(vec4 col)\n{\n\treturn 0.2126 * col.r + 0.7152 * col.g + 0.0722 * col.b;\n}\n\n\nvoid setLuminance(inout vec4 col, float lum)\n{\n\tlum \/= luminance(col);\n\tcol *= lum;\n}\n\n\nfloat AO(vec2 p, float dist, float radius, float intensity)\n{\n\tfloat a = clamp(dist \/ radius, 0.0, 1.0) - 1.0;\n\treturn 1.0 - (pow(abs(a), 5.0) + 1.0) * intensity + (1.0 - intensity);\n\treturn smoothstep(0.0, 1.0, dist \/ radius);\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ The program \/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy + vec2(0.5);\n\tvec2 c = iResolution.xy \/ 2.0;\n\t\n\t\/\/float dist = sceneSmooth(p, 5.0);\n\tfloat dist = sceneDist(p);\n\t\n\tvec2 light1Pos = iMouse.xy;\n\tvec4 light1Col = vec4(0.75, 1.0, 0.5, 1.0);\n\tsetLuminance(light1Col, 0.4);\n\t\n\tvec2 light2Pos = vec2(iResolution.x * (sin(iTime + 3.1415) + 1.2) \/ 2.4, 175.0);\n\tvec4 light2Col = vec4(1.0, 0.75, 0.5, 1.0);\n\tsetLuminance(light2Col, 0.5);\n\t\n\tvec2 light3Pos = vec2(iResolution.x * (sin(iTime) + 1.2) \/ 2.4, 340.0);\n\tvec4 light3Col = vec4(0.5, 0.75, 1.0, 1.0);\n\tsetLuminance(light3Col, 0.6);\n\t\n\t\/\/ gradient\n\tvec4 col = vec4(0.5, 0.5, 0.5, 1.0) * (1.0 - length(c - p)\/iResolution.x);\n\t\/\/ grid\n\tcol *= clamp(min(mod(p.y, 10.0), mod(p.x, 10.0)), 0.9, 1.0);\n\t\/\/ ambient occlusion\n\tcol *= AO(p, sceneSmooth(p, 10.0), 40.0, 0.4);\n\t\/\/col *= 1.0-AO(p, sceneDist(p), 40.0, 1.0);\n\t\/\/ light\n\tcol += drawLight(p, light1Pos, light1Col, dist, 150.0, 6.0);\n\tcol += drawLight(p, light2Pos, light2Col, dist, 200.0, 8.0);\n\tcol += drawLight(p, light3Pos, light3Col, dist, 300.0, 12.0);\n\t\/\/ shape fill\n\tcol = mix(col, vec4(1.0, 0.4, 0.0, 1.0), fillMask(dist));\n\t\/\/ shape outline\n\tcol = mix(col, vec4(0.1, 0.1, 0.1, 1.0), innerBorderMask(dist, 1.5));\n\n\tfragColor = clamp(col, 0.0, 1.0);\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"lsdGzN","date":"1448472609","viewed":21497,"name":"Will it blend","username":"nmz","description":"From left to right: RGB Lerp, HSV bledning, CIE Lch Blending, My blending function\nMouse lets you change interpolated colors, the cylinder switches between HSV and Lch over time (Lch is the smooth one).\n\nThe new blending method is at line 200.","likes":239,"published":1,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/Will it blend by nmz (twitter: @stormoid)\n\n\/*\n\tIdea from: http:\/\/www.stuartdenman.com\/improved-color-blending\/\n\n\tMost people will tell you that blending in rgb space is a bad,\n\tbut why is it so bad?\n\n\tHere's an unlisted shader to show and explain the issue: \n\thttps:\/\/www.shadertoy.com\/view\/XddGRN\n\n\n\tThis shader is about different solutions to this problem:\n\n\tThe left gradient is plain RGB Linear interpolation, showing nice\n\tbehavior when the interploated colors are close to each other\n\t(especially when close in hue) but prone to large changes in color\n\tsaturation along the gradient when the hues are further\tapart.\n\n\tThe second gradient from the left is HSV space blending, this\n\tcompletely solves the problem of avoiding low saturation colors\n\twhen the two interpolated colors are of high saturation\tbut of\n\tdifferent hues, but it creates other problems by not accounting\n\tfor human perception of lightness, resulting in gradients with \n\tpotentially large changes in percieved color \"brightness\". This \n\tmethod is also much costlier than plain rgb\tinterpolation (see \n\tbottom of comment).\n\n\tThe third gradient from the left is Lch space blending, it uses a \n\tcylindrical space with circular hues, just like HSV space, but it\n\ttakes into account human perception of color and results in\tvery\n\tnatural and smooth gradients.  The main issue with this method is \n\tthat the complete computation is quite expensive.\n\n\tThe fourth gradient is a method I developed to provide an alternative\n\tto the costly methods while improving the quality of the gradients\n\tcompared to simple rgb linear interpolation. The idea comes from\n\tobservation of the rgb colorspace's cube and where the low saturation\n\tarea is located within it.  The result is a rgb blending function that\n\tprovides decent quality gradients (you be the judge) at a very\n\tacceptable computational cost.  One thing that could be improved about\n\tthe algortihm is the behavior when the hues are very close to opposite\n\t(180 degrees apart), ideally the path would make the gradient hue\n\tshifted towards its\tside of the main diagonal, but I couldn't find a\n\tway to achieve this cheaply enough...\n\t\n\n\tComparison of the relative costs:\n\tOn Radeon HD 5670 (using GPU ShaderAnalyzer)\n\t\nFrom Left to Right:\n\t1st method (Lerp): 3 Instructions,  1 cycle\n\t2nd Method (HSV) : 34 Instructions, 7 cycles\n\t3rd Method (Lch) : 57 Instructions, 11.60 cycles\n\t4th Method (Mine): 15 Instructions, 3.20 cycles\n\n\nLch Blending documentation:\n\tColor space matrices from: http:\/\/www.brucelindbloom.com\/index.html?Eqn_RGB_XYZ_Matrix.html\n\tEquations from: https:\/\/en.wikipedia.org\/wiki\/Lab_color_space\n*\/\n\n\n\/\/Allows to scale the saturation and Value\/Lightness of the 2nd color\nconst float SAT2MUL = 1.0;\nconst float L2MUL = 1.0;\n\n\n\/\/const vec3 wref =  vec3(.950456, 1.0, 1.089058); \nconst vec3 wref =  vec3(1.0, 1.0, 1.0); \n\n#define SMOOTH_HSV\n\n#define ITR 50\n#define FAR 8.\n#define time iTime\n\nconst float fov = 1.5;\nvec2 mo;\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\n\n\/\/---------------------------------------------------------------------------------\n\/\/--------------------------------Color Functions----------------------------------\n\/\/---------------------------------------------------------------------------------\n\n#define PI 3.14159365\n#define TAU 6.28318531\n\n\nfloat sRGB(float t){ return mix(1.055*pow(t, 1.\/2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\n\/\/-----------------Lch-----------------\n\nfloat xyzF(float t){ return mix(pow(t,1.\/3.), 7.787037*t + 0.139731, step(t,0.00885645)); }\nfloat xyzR(float t){ return mix(t*t*t , 0.1284185*(t - 0.139731), step(t,0.20689655)); }\nvec3 rgb2lch(in vec3 c)\n{\n\tc  *= mat3( 0.4124, 0.3576, 0.1805,\n          \t\t0.2126, 0.7152, 0.0722,\n                0.0193, 0.1192, 0.9505);\n    c.x = xyzF(c.x\/wref.x);\n\tc.y = xyzF(c.y\/wref.y);\n\tc.z = xyzF(c.z\/wref.z);\n\tvec3 lab = vec3(max(0.,116.0*c.y - 16.0), 500.0*(c.x - c.y), 200.0*(c.y - c.z)); \n    return vec3(lab.x, length(vec2(lab.y,lab.z)), atan(lab.z, lab.y));\n}\n\nvec3 lch2rgb(in vec3 c)\n{\n    c = vec3(c.x, cos(c.z) * c.y, sin(c.z) * c.y);\n    \n    float lg = 1.\/116.*(c.x + 16.);\n    vec3 xyz = vec3(wref.x*xyzR(lg + 0.002*c.y),\n    \t\t\t\twref.y*xyzR(lg),\n    \t\t\t\twref.z*xyzR(lg - 0.005*c.z));\n    \n    vec3 rgb = xyz*mat3( 3.2406, -1.5372,-0.4986,\n          \t\t        -0.9689,  1.8758, 0.0415,\n                \t     0.0557,  -0.2040, 1.0570);\n    \n    return rgb;\n}\n\n\/\/cheaply lerp around a circle\nfloat lerpAng(in float a, in float b, in float x)\n{\n    float ang = mod(mod((a-b), TAU) + PI*3., TAU)-PI;\n    return ang*x+b;\n}\n\n\/\/Linear interpolation between two colors in Lch space\nvec3 lerpLch(in vec3 a, in vec3 b, in float x)\n{\n    float hue = lerpAng(a.z, b.z, x);\n    return vec3(mix(b.xy, a.xy, x), hue);\n}\n\n\/\/-----------------HSV-----------------\n\n\/\/HSV functions from iq (https:\/\/www.shadertoy.com\/view\/MsS3Wc)\n#ifdef SMOOTH_HSV\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); \/\/ cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n#else\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n#endif\n\n\/\/From Sam Hocevar: http:\/\/lolengine.net\/blog\/2013\/07\/27\/rgb-to-hsv-in-glsl\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 \/ 3.0, 2.0 \/ 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) \/ (6.0 * d + e)), d \/ (q.x + e), q.x);\n}\n\n\/\/Linear interpolation between two colors in normalized (0..1) HSV space\nvec3 lerpHSV(in vec3 a, in vec3 b, in float x)\n{\n    float hue = (mod(mod((b.x-a.x), 1.) + 1.5, 1.)-0.5)*x + a.x;\n    return vec3(hue, mix(a.yz, b.yz, x));\n}\n\n\/\/---------------Improved RGB--------------\n\n\/*\n\tThe idea behind this function is to avoid the low saturation area in the\n\trgb color space. This is done by getting the direction to that diagonal\n\tand displacing the interpolated\tcolor by it's inverse while scaling it\n\tby saturation error and desired lightness. \n\n\tI find it behaves very well under most circumstances, the only instance\n\twhere it doesn't behave ideally is when the hues are very close\tto 180 \n\tdegrees apart, since the method I am using to find the displacement vector\n\tdoes not compensate for non-curving motion. I tried a few things to \n\tcircumvent this problem but none were cheap and effective enough..\n*\/\n\n\/\/Changes the strength of the displacement\n#define DSP_STR 1.5\n\n\/\/Optimizaton for getting the saturation (HSV Type) of a rgb color\n#if 0\nfloat getsat(vec3 c)\n{\n    c.gb = vec2(max(c.g, c.b), min(c.g, c.b));\n\tc.rg = vec2(max(c.r, c.g), min(c.r, c.g));   \n\treturn (c.r - min(c.g, c.b)) \/ (c.r + 1e-7);\n}\n#else\n\/\/Further optimization for getting the saturation\nfloat getsat(vec3 c)\n{\n    float mi = min(min(c.x, c.y), c.z);\n    float ma = max(max(c.x, c.y), c.z);\n    return (ma - mi)\/(ma+ 1e-7);\n}\n#endif\n\n\/\/Improved rgb lerp\nvec3 iLerp(in vec3 a, in vec3 b, in float x)\n{\n    \/\/Interpolated base color (with singularity fix)\n    vec3 ic = mix(a, b, x) + vec3(1e-6,0.,0.);\n    \n    \/\/Saturation difference from ideal scenario\n    float sd = abs(getsat(ic) - mix(getsat(a), getsat(b), x));\n    \n    \/\/Displacement direction\n    vec3 dir = normalize(vec3(2.*ic.x - ic.y - ic.z, 2.*ic.y - ic.x - ic.z, 2.*ic.z - ic.y - ic.x));\n    \/\/Simple Lighntess\n    float lgt = dot(vec3(1.0), ic);\n    \n    \/\/Extra scaling factor for the displacement\n    float ff = dot(dir, normalize(ic));\n    \n    \/\/Displace the color\n    ic += DSP_STR*dir*sd*ff*lgt;\n    return clamp(ic,0.,1.);\n}\n\n\n\/\/---------------------------------------------------------------------------------\n\/\/---------------------------------------------------------------------------------\n\/\/---------------------------------------------------------------------------------\n\/\/---------------------------------------------------------------------------------\n\nfloat sbox( vec3 p, vec3 b ){\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat cyl( vec3 p, vec2 h ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat map(vec3 p)\n{\n    vec3 p2 = p;\n    p2.xz *= mm2(-time*0.4);\n    float d = max(cyl(p, vec2(1.,1.)), -sbox(p2 - vec3(1,1.,0), vec3(1.1+mo.x*0.6, 0.8 - mo.y*2.2, 1.2)));\n    return max(d, -cyl(p + vec3(0.,-2.2-mo.y*2.2,0), vec2(0.75+sin(time)*0.2,2.)));\n}\n\nvec3 shade(in vec3 pos, in vec3 rd)\n{\n    vec3 col = vec3(0);\n    vec2 plr = vec2(length(pos.xz), atan(pos.z,pos.x));\n    \n    vec3 colLch = lch2rgb(vec3(pos.y*50.+50.,plr.x*100. , plr.y));\n    vec3 colHsv = hsv2rgb(vec3(plr.y\/6.2831853, plr.x, pos.y*0.5+0.5));\n    \n    col = mix(colLch, colHsv, smoothstep(0.5,0.5, sin(time*0.5+0.1)));\n    \n    return col;\n}\n\n\/\/From eiffie: https:\/\/www.shadertoy.com\/view\/XsSXDt\nvec3 marchAA(in vec3 ro, in vec3 rd, in vec3 bgc, in float px, in mat3 cam)\n{\n    float precis = px*.1;\n    float prb = precis;\n    float t=map(ro);\n\tvec3 col = vec3(0);\n\tfloat dm=100.0,tm=0.0,df=100.0,tf=0.0,od=1000.0,d=0.;\n\tfor(int i=0;i<ITR;i++) {\n\t\td=map(ro+rd*t);\n\t\tif(df==50.0) {\n\t\t\tif(d>od) {\n\t\t\t\tif(od<px*(t-od)) {\n\t\t\t\t\tdf=od;tf=t-od;\n\t\t\t\t}\n\t\t\t}\n\t\t\tod=d;\n\t\t}\n\t\tif(d<dm){tm=t;dm=d;}\n\t\tt+=d;\n\t\tif(t>FAR || d<precis)break;\n\t}\n\tcol=bgc;\n    \n\tif(dm<px*tm)\n        col=mix(shade((ro+rd*tm) - rd*(px*(tm-dm)) ,rd),col,clamp(dm\/(px*tm),0.0,1.0));\n    \n\tfloat qq=0.0;\n\t\n    if((df==100.0 || tm==tf) && t < FAR) {\n        ro+=cam*vec3(0.5,0.5,0.)*px*tm*1.;\n        tf=tm;\n        df=dm;\n        qq=.01;\n\t}\n    return mix(shade((ro+rd*tf) - rd*(px*tf-df),rd),col,clamp(qq+df\/(px*tf),0.0,1.0));\n}\n\nmat3 rot_x(float a){float sa = sin(a); float ca = cos(a); return mat3(1.,.0,.0,    .0,ca,sa,   .0,-sa,ca);}\nmat3 rot_y(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,.0,sa,    .0,1.,.0,   -sa,.0,ca);}\nmat3 rot_z(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,sa,.0,    -sa,ca,.0,  .0,.0,1.);}\n\n\/\/2d Box\nfloat box(in vec2 p, in vec2 b) \n{\n    return length(max(abs(p)-b,0.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    float px= 2.\/(iResolution.y*fov);\n\tvec2 q = fragCoord.xy \/ iResolution.xy;\n    vec2 p = q - 0.5;\n    vec2 pp = p;\n\tp.x*=iResolution.x\/iResolution.y;\n\tmo = iMouse.xy \/ iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(0.12,0.15):mo;\n\tmo.x *= iResolution.x\/iResolution.y;\n    \n    vec3 ro = vec3(1.1,0.,5.);\n    vec3 rd = normalize(vec3(p,-1.6)); \n    float rx = 0.45;\n    float ry = time*0.4+1.1+cos(time)*0.1;\n    \n    mat3 cam = rot_x(rx)*rot_y(ry);\n   \tro *= cam;\n\trd *= cam;\n    \n    \/\/vec3 col = mix(vec3(0.9,.9,.95),vec3(0.2,0.2,0.27),(-1.-rd.y)*1.0+.8);\n    vec3 col = vec3(0.9);\n    col = marchAA(ro, rd, col, px, cam);\n    \n    \n    \/\/-------------------------2D stuff------------------------------\n    \n    vec3 col1 = vec3(0.26-time*0.0638 + mo.x*0.1, .8 + sin(time)*0.2, clamp(mo.y+0.6,0.,1.));\n    vec3 col2 = vec3(.75-time*0.0638 - mo.x*0.1, (.8 + sin(time)*0.2) * SAT2MUL, clamp(mo.y+0.6,0.,1.)*L2MUL);\n    \n    float gradient = clamp((p.y+0.42)*1.25,0.,1.);\n    \n    vec3 gradHSV = lerpHSV(col2, col1, gradient);\n    \n    col1 = hsv2rgb(col1);\n    col2 = hsv2rgb(col2);\n    gradHSV = hsv2rgb(gradHSV);\n    \n    vec3 col1Lch = rgb2lch(col1);\n    vec3 col2Lch = rgb2lch(col2);\n    \n    vec3 gradLch = lerpLch(col1Lch, col2Lch, gradient);\n    gradLch = lch2rgb(gradLch);\n    vec3 gradRGB = mix(col2, col1, gradient);\n    \n    vec3 gradDSP = iLerp(col2, col1, gradient);\n    \n    float h = clamp(mo.y,-.45,.4);\n    float h2 = clamp(mo.x,-.7,1.);\n    float b1 = smoothstep(0.01, .0, box(p - vec2(-0.67-h*0.15 + sin(-h2*1.1-1.6)*0.12,h*0.8 + h2*0.13),\n                                        vec2(0.02,0.02))-0.015);\n    col = col*(1.-smoothstep(0.,.5,b1)) + vec3(col1)*b1;\n    \n    float b2 = smoothstep(0.01, .0, box(p - vec2(-0.16-h*0. + sin(h2*1.1+1.9)*0.2, 0.15 + h*0.55 + h2*0.13),\n                                        vec2(0.02,0.02))-0.015);\n    col = col*(1.-smoothstep(0.,.5,b2)) + vec3(col2)*b2;\n    \n    float b3 = smoothstep(0.01, 0., box(p - vec2(0.18,0.0), vec2(0.06,0.4)));\n    col = col*(1.-smoothstep(0.,.5,b3)) + vec3(gradRGB)*b3;\n    \n    float b4 = smoothstep(0.01, 0., box(p - vec2(0.36,0.0), vec2(0.06,0.4)));\n    col = col*(1.-smoothstep(0.,.5,b4)) + vec3(gradHSV)*b4;\n    \n    float b5 = smoothstep(0.01, 0., box(p - vec2(0.54,0.0), vec2(0.06,0.4)));\n    col = col*(1.-smoothstep(0.,.5,b5)) + vec3(gradLch)*b5;\n    \n    float b6 = smoothstep(0.01, 0., box(p - vec2(0.73,0.0), vec2(0.06,0.4)));\n    col = col*(1.-smoothstep(0.,.5,b6)) + vec3(gradDSP)*b6;\n    \n    \n    \/\/Light and sharp vignette so that the colors don't get influenced\n    vec2 pp3 = pp*pp*pp;\n    col *= pow(smoothstep(12., .05, dot(pp3*pp3,pp3*pp3)*1000.),1000.)*0.4+0.6;\n    \n    col = sRGB(col);\n    \n    \n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"lsKcDD","date":"1522130002","viewed":21495,"name":"Soft Shadow Variation","username":"iq","description":"Testing Sebastian Aaltonen's soft shadow improvement. Go to line 54 to compare with the traditional technique for soft shadows. It's very cheap and improves shadows a lot!","likes":215,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/    \n\/\/ Testing Sebastian Aaltonen's soft shadow improvement\n\/\/\n\/\/ The technique is based on estimating a better closest point in ray\n\/\/ at each step by triangulating from the previous march step.\n\/\/\n\/\/ More info about the technique at slide 39 of this presentation:\n\/\/ https:\/\/www.dropbox.com\/s\/s9tzmyj0wqkymmz\/Claybook_Simulation_Raytracing_GDC18.pptx?dl=0\n\/\/\n\/\/ Traditional technique: https:\/\/iquilezles.org\/articles\/rmshadows\n\/\/\n\/\/ Go to lines 54 to compare both.\n\n\n\/\/ make this 1 is your machine is too slow\n#define AA 2\n\n\/\/------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\n\/\/------------------------------------------------------------------\n\nfloat map( in vec3 pos )\n{\n    vec3 qos = vec3( fract(pos.x+0.5)-0.5, pos.yz );\n    return min( sdPlane(     pos.xyz-vec3( 0.0,0.00, 0.0)),\n                sdBox(       qos.xyz-vec3( 0.0,0.25, 0.0), vec3(0.2,0.5,0.2) ) );\n}\n\n\/\/------------------------------------------------------------------\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, int technique )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; \/\/ big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n\n        \/\/ traditional technique\n        if( technique==0 )\n        {\n        \tres = min( res, 10.0*h\/t );\n        }\n        \/\/ improved technique\n        else\n        {\n            \/\/ use this if you are getting artifact on the first iteration, or unroll the\n            \/\/ first iteration out of the loop\n            \/\/float y = (i==0) ? 0.0 : h*h\/(2.0*ph); \n\n            float y = h*h\/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, 10.0*d\/max(0.0,t-y) );\n            ph = h;\n        }\n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\nfloat castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n   \n#if 1\n    \/\/ bounding volume\n    float tp1 = (0.0-ro.y)\/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.0-ro.y)\/rd.y; if( tp2>0.0 ) { if( ro.y>1.0 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n    float t = tmin;\n    for( int i=0; i<64; i++ )\n    {\n\t    float precis = 0.0005*t;\n\t    float res = map( ro+rd*t );\n        if( res<precis || t>tmax ) break;\n        t += res;\n    }\n\n    if( t>tmax ) t=-1.0;\n    return t;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.001 + 0.15*float(i)\/4.0;\n        float d = map( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );    \n}\n\nvec3 render( in vec3 ro, in vec3 rd, in int technique)\n{ \n    vec3  col = vec3(0.0);\n    float t = castRay(ro,rd);\n\n    if( t>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        \n        \/\/ material        \n\t\tvec3 mate = vec3(0.3);\n\n        \/\/ key light\n        vec3  lig = normalize( vec3(-0.1, 0.3, 0.6) );\n        vec3  hal = normalize( lig-rd );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 ) * \n                    calcSoftshadow( pos, lig, 0.01, 3.0, technique );\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tcol = mate * 4.0*dif*vec3(1.00,0.70,0.5);\n        col +=      12.0*spe*vec3(1.00,0.70,0.5);\n        \n        \/\/ ambient light\n        float occ = calcAO( pos, nor );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        col += mate*amb*occ*vec3(0.0,0.08,0.1);\n        \n        \/\/ fog\n        col *= exp( -0.0005*t*t*t );\n    }\n\n\treturn col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ camera\t\n    float an = 12.0 - sin(0.1*iTime);\n    vec3 ro = vec3( 3.0*cos(0.1*an), 1.0, -3.0*sin(0.1*an) );\n    vec3 ta = vec3( 0.0, -0.4, 0.0 );\n    \/\/ camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    int technique = (fract(iTime\/2.0)>0.5) ? 1 : 0;\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        \/\/ pixel coordinates\n        vec2 o = vec2(float(m),float(n)) \/ float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))\/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)\/iResolution.y;\n#endif\n\n        \/\/ ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        \/\/ render\t\n        vec3 col = render( ro, rd, technique);\n\n\t\t\/\/ gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot \/= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"XlSGzz","date":"1603717695","viewed":21475,"name":"yuan","username":"playertk","description":"yuan","likes":42,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 p = (2.*fragCoord.xy-iResolution.xy) \/ iResolution.y; \n\n    float a = atan(p.x,p.y);\n    float r = length(p);\n    vec2 uv = vec2(0.0,r);\n\n\tuv = (2.0 * uv) -1.0;     \n    float beamWidth = abs(5.0 \/ (40.0 * uv.y));\n\n    \n    \n    \n\n    if(abs(uv.y)>=1.0)\n    {\n    \n   \t  \/\/ fragColor=vec4(0.0,0.5,0.0,1.0);\n      \/\/  return;\n    }\n    \n\tvec3 horBeam = vec3(beamWidth);\n\t\n\t\/\/fragColor = vec4( horBeam , 1.0);\n    fragColor = vec4( 5. \/ (40. * abs(2.*length(p)-1.) ) );\n\n    \n  \n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"Mlj3WV","date":"1432723892","viewed":21340,"name":"2D LED Spectrum - Visualiser","username":"uNiversal","description":"A simple 2D LED Spectrum analyser visualisation, based on Led Spectrum Analyser by: simesgreen\n\nMade to work in Kodi shadertoy addon https:\/\/github.com\/topfs2\/visualization.shadertoy\/pull\/3","likes":64,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4sXGzn","filepath":"\/media\/a\/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"\/media\/ap\/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\/*\n2D LED Spectrum - Visualiser\nBased on Led Spectrum Analyser by: simesgreen - 27th February, 2013 https:\/\/www.shadertoy.com\/view\/Msl3zr\n2D LED Spectrum by: uNiversal - 27th May, 2015\nCreative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*\/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ create pixel coordinates\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n\n    \/\/ quantize coordinates\n    const float bands = 30.0;\n    const float segs = 40.0;\n    vec2 p;\n    p.x = floor(uv.x*bands)\/bands;\n    p.y = floor(uv.y*segs)\/segs;\n\n    \/\/ read frequency data from first row of texture\n    float fft  = texture( iChannel0, vec2(p.x,0.0) ).x;\n\n    \/\/ led color\n    vec3 color = mix(vec3(0.0, 2.0, 0.0), vec3(2.0, 0.0, 0.0), sqrt(uv.y));\n\n    \/\/ mask for bar graph\n    float mask = (p.y < fft) ? 1.0 : 0.1;\n\n    \/\/ led shape\n    vec2 d = fract((uv - p) *vec2(bands, segs)) - 0.5;\n    float led = smoothstep(0.5, 0.35, abs(d.x)) *\n                smoothstep(0.5, 0.35, abs(d.y));\n    vec3 ledColor = led*color*mask;\n\n    \/\/ output final color\n    fragColor = vec4(ledColor, 1.0);\n}\n","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"MsjSW3","date":"1416778116","viewed":21165,"name":"Ether","username":"nimitz","description":"A wild distance field in its natural habitat.","likes":494,"published":1,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Ether by nimitz 2014 (twitter: @stormoid)\n\/\/ https:\/\/www.shadertoy.com\/view\/MsjSW3\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\/\/ Contact the author for other licensing options\n\n#define t iTime\nmat2 m(float a){float c=cos(a), s=sin(a);return mat2(c,-s,s,c);}\nfloat map(vec3 p){\n    p.xz*= m(t*0.4);p.xy*= m(t*0.3);\n    vec3 q = p*2.+t;\n    return length(p+vec3(sin(t*0.7)))*log(length(p)+1.) + sin(q.x+sin(q.z+sin(q.y)))*0.5 - 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\t\n\tvec2 p = fragCoord.xy\/iResolution.y - vec2(.9,.5);\n    vec3 cl = vec3(0.);\n    float d = 2.5;\n    for(int i=0; i<=5; i++)\t{\n\t\tvec3 p = vec3(0,0,5.) + normalize(vec3(p, -1.))*d;\n        float rz = map(p);\n\t\tfloat f =  clamp((rz - map(p+.1))*0.5, -.1, 1. );\n        vec3 l = vec3(0.1,0.3,.4) + vec3(5., 2.5, 3.)*f;\n        cl = cl*l + smoothstep(2.5, .0, rz)*.7*l;\n\t\td += min(rz, 1.);\n\t}\n    fragColor = vec4(cl, 1.);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"llcyD2","date":"1534089156","viewed":21163,"name":"A quine","username":"reinder","description":"This is [url=https:\/\/www.shadertoy.com\/view\/Ml3SWj]done[\/url] [url=https:\/\/www.shadertoy.com\/view\/Mlj3zR]before[\/url] and my code is not the most [url=https:\/\/www.shadertoy.com\/view\/MlGcRz]optimised[\/url], but it is nice to write your own quine!","likes":141,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"int y;ivec2 d;uint[] c = uint[ 151](0x007a995eu,0x0083f840u,0x009a9c40u,0x006e5840u,0x0043f4dcu,    \n0x006659c0u,0x0066595eu,0x000c5661u,0x006a595au,0x007a9a66u,0x00f14938u,0x0062493fu,0x00924918u,    \n0x00fe4918u,0x00a2cb18u,0x00145f84u,0x3813813cu,0x0003d100u,0x0087f840u,0x0066bb5au,0x0085e000u,    \n0x00330604u,0x00010800u,0x00020000u,0x00624918u,0x00f2081cu,0x00024784u,0x0001e840u,0x0085e100u,    \n0x000047a1u,0x00014800u,0x00894200u,0x00214880u,0x0023e208u,0x00008208u,0x00f2081cu,0x00024784u,    \n0x0087f000u,0x0003f840u,0x00918624u,0x000ccc00u,0x00916724u,0x00a3b9d8u,0x00514514u,0x00310a24u,    \n0x00e0423cu,0x001a9080u,0x00024000u,0x00c766e3u,0x00c8d17fu,0x0052ca00u,0x0083f040u,0x0003f000u,    \n0x0000413cu,0x00000000u,0x00000000u,0x2cd9ab51u,0x0c39545eu,0x1978dd82u,0x2695ab51u,0x36af6336u,    \n0x256ad459u,0x26045076u,0xfefbefd4u,0x2d45979bu,0x1950ed9au,0x0bd9ab51u,0x1a3b571bu,0x0cdadd59u,    \n0x208262e5u,0x299d7354u,0x2c5cd846u,0x019c0a9bu,0x1165d799u,0x145766adu,0x0ad9ab51u,0x366ad456u,    \n0x1ab5158bu,0x1171b3f6u,0x2b4766adu,0x3678a8acu,0x3565a3b5u,0x007d1dadu,0x0b811d34u,0x1902702eu,    \n0x253143afu,0x0f845a11u,0x30460826u,0x00a86a45u,0x1b64f0e7u,0x2d45975eu,0x1b52dd9au,0x366ad45cu,    \n0x038acad1u,0x11ad8586u,0x35782070u,0x2dd5968eu,0x3401f476u,0x01811db4u,0x00b80048u,0x18bd9027u,    \n0x0eb80aebu,0x19027014u,0x2bad8bdbu,0x0050eb81u,0x1b6470a7u,0x01aeb62fu,0x0050eb80u,0x1b6430a7u,    \n0x01aeb62fu,0x0050eb81u,0x1b646067u,0x253143afu,0x26081a11u,0x14da0836u,0x1b622254u,0x2ad9b129u,    \n0x1b64f9c0u,0x1161575eu,0x11290d8du,0x132904adu,0x1a65850eu,0x0430e576u,0x0e5562b6u,0x1b2f608cu,    \n0x2bb172dcu,0x18c8ec51u,0x1845a673u,0x0b8ac5edu,0x2b35eb17u,0x0230e551u,0x2c79b2d4u,0x289d736bu,    \n0x17354845u,0x296c8a2cu,0x3035e189u,0x0c39546bu,0x08585502u,0x15aca79bu,0x0d50430eu,0x34160b17u,    \n0x209d72f4u,0x2e5c0204u,0x2f6409c0u,0x03580515u,0x1b185585u,0x216d4b61u,0x04201515u,0x010c4587u,    \n0x1b6c4196u,0xfefbf75eu);uint e(uint b){return c[b]>>(d.x*6+d.y)&0x1u;}uint v(int a,int b,int f)\n{int i=y-a; return i<0||i>b?0x0u:e(c[i\/5+f]>>i%5*6&0x3fu);}uint n(){int i=y-36,o=i%12;return i<0\n|| i>1810?0x0u:o==0?e(0x0u):o==1?e(0x27u):o==10?e(0x23u):o==11?e(0x16u):e(c[i\/12] >> ((9-o)*4) &\n0xfu);}void mainImage(out vec4 a,vec2 b){b.y=iResolution.y-b.y;d=ivec2(b);y=d.x\/5+(d.y\/8)*96;d%=\nivec2(5,8);a=vec4(d.y>5||b.x>480.?0x0u:v(0,35,56)+n()+v(1847,431,64));}","name":"Image","description":"","type":"image"}]}];    var gUseScreenshots = piIsMobile();
    var gThemeName = "classic";



    </script>
</head>

<!-- <body onload="resultsInit(12,null,null)"> -->
<body onload="resultsInitStatic(12,null,null)">

<!-- header =================================================================================== -->


<div id="header">

    <div id="headerBlock1">
        <a href="/" id="headerTitle">Shadertoy</a>
        <form name="formSearch" action="/results" method="get" style="display:inline-block;">
        <div  id="headerSearch">
            <input type="search" id="mySearch" name="query" placeholder="Search..." value=""/>
        </div>
        </form>
    </div>

    <div id="headerBlock2">
            <a class="headerLinks" href="/browse">Browse</a>
        <a class="headerLinks" href="/new">New</a>
        <a class="headerLinks" href="/signin">Sign In</a>
        </div>
</div>
<!-- content ================================================================================== -->

<div id="content">

  <div id="controls">
    <div>
      <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
      Sort:      </div>
      <div class="controlOptions"><div class="pageButtonsCurrent" href="/results?query=&sort=popular&filter=">Popular</div><a class="pageButtons" href="/results?query=&sort=newest&filter=">Newest</a><a class="pageButtons" href="/results?query=&sort=love&filter=">Love</a><a class="pageButtons" href="/results?query=&sort=hot&filter=">Hot</a></div>
    </div>

    <div id="controlFilter">
      <div style="display:flex;margin-right:8px;align-items:center;">Filter:</div>
      <div class="controlOptions"> <a class="pageButtons" href="/results?query=&sort=popular&filter=multipass">Multipass</a><a class="pageButtons" href="/results?query=&sort=popular&filter=soundoutput">GPU Sound</a><a class="pageButtons" href="/results?query=&sort=popular&filter=vr">VR</a><a class="pageButtons" href="/results?query=&sort=popular&filter=soundinput">Microphone</a><a class="pageButtons" href="/results?query=&sort=popular&filter=musicstream">Soundcloud</a><a class="pageButtons" href="/results?query=&sort=popular&filter=webcam">Webcam</a></div>
    </div>

    <div>
        <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
        View:</div>
        <div><a class="pageButtons" href="/slideshow?query=&sort=popular">Slideshow</a></div>
    </div>

    <div class="navigation" id="navTop" ><span style="padding-right:8px;">Results (74098):</span><div class="controlOptions"><a id="pageButtonFirst" class="pageButtons" href="results?query=&sort=popular&from=0&num=12">1</a><span>...</span><a id="pageButton"0 class="pageButtons" href="results?query=&sort=popular&from=240&num=12">21</a><a id="pageButton"1 class="pageButtons" href="results?query=&sort=popular&from=252&num=12">22</a><div id="pageButton"2 class="pageButtonsCurrent" href="results?query=&sort=popular&from=264&num=12">23</div><a id="pageButton"3 class="pageButtons" href="results?query=&sort=popular&from=276&num=12">24</a><a id="pageButton"4 class="pageButtons" href="results?query=&sort=popular&from=288&num=12">25</a><span>...</span><a id="pageButtonLast" class="pageButtons" href="results?query=&sort=popular&from=74088&num=12">6175</a></div>
</div>
  </div>


  <div id="shaderGrid">
    <div class='searchResult'><div class='searchResultContainer' id='Preview_0_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_0_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_0_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_0_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_0_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_0_Thumnail'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_0_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_0_Info'>  <span class='previewText'  id='Preview_0_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_0_TextUser'></span>  <span class='previewStats' id='Preview_0_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_1_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_1_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_1_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_1_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_1_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_1_Thumnail'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_1_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_1_Info'>  <span class='previewText'  id='Preview_1_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_1_TextUser'></span>  <span class='previewStats' id='Preview_1_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_2_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_2_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_2_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_2_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_2_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_2_Thumnail'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_2_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_2_Info'>  <span class='previewText'  id='Preview_2_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_2_TextUser'></span>  <span class='previewStats' id='Preview_2_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_3_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_3_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_3_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_3_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_3_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_3_Thumnail'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_3_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_3_Info'>  <span class='previewText'  id='Preview_3_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_3_TextUser'></span>  <span class='previewStats' id='Preview_3_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_4_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_4_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_4_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_4_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_4_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_4_Thumnail'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_4_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_4_Info'>  <span class='previewText'  id='Preview_4_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_4_TextUser'></span>  <span class='previewStats' id='Preview_4_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_5_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_5_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_5_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_5_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_5_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_5_Thumnail'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_5_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_5_Info'>  <span class='previewText'  id='Preview_5_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_5_TextUser'></span>  <span class='previewStats' id='Preview_5_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_6_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_6_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_6_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_6_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_6_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_6_Thumnail'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_6_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_6_Info'>  <span class='previewText'  id='Preview_6_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_6_TextUser'></span>  <span class='previewStats' id='Preview_6_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_7_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_7_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_7_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_7_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_7_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_7_Thumnail'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_7_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_7_Info'>  <span class='previewText'  id='Preview_7_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_7_TextUser'></span>  <span class='previewStats' id='Preview_7_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_8_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_8_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_8_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_8_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_8_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_8_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_8_Thumnail'>        <img class='previewThumbnailImage' id='Preview_8_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_8_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_8_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_8_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_8_Info'>  <span class='previewText'  id='Preview_8_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_8_TextUser'></span>  <span class='previewStats' id='Preview_8_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_9_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_9_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_9_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_9_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_9_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_9_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_9_Thumnail'>        <img class='previewThumbnailImage' id='Preview_9_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_9_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_9_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_9_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_9_Info'>  <span class='previewText'  id='Preview_9_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_9_TextUser'></span>  <span class='previewStats' id='Preview_9_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_10_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_10_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_10_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_10_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_10_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_10_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_10_Thumnail'>        <img class='previewThumbnailImage' id='Preview_10_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_10_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_10_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_10_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_10_Info'>  <span class='previewText'  id='Preview_10_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_10_TextUser'></span>  <span class='previewStats' id='Preview_10_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_11_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_11_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_11_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_11_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_11_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_11_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_11_Thumnail'>        <img class='previewThumbnailImage' id='Preview_11_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_11_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_11_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_11_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_11_Info'>  <span class='previewText'  id='Preview_11_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_11_TextUser'></span>  <span class='previewStats' id='Preview_11_Stats'></span></div></div>  </div>
  <br>
  <div class="navigation" id="navBottom" ><span style="padding-right:8px;">Results (74098):</span><div class="controlOptions"><a id="pageButtonFirst" class="pageButtons" href="results?query=&sort=popular&from=0&num=12">1</a><span>...</span><a id="pageButton"0 class="pageButtons" href="results?query=&sort=popular&from=240&num=12">21</a><a id="pageButton"1 class="pageButtons" href="results?query=&sort=popular&from=252&num=12">22</a><div id="pageButton"2 class="pageButtonsCurrent" href="results?query=&sort=popular&from=264&num=12">23</div><a id="pageButton"3 class="pageButtons" href="results?query=&sort=popular&from=276&num=12">24</a><a id="pageButton"4 class="pageButtons" href="results?query=&sort=popular&from=288&num=12">25</a><span>...</span><a id="pageButtonLast" class="pageButtons" href="results?query=&sort=popular&from=74088&num=12">6175</a></div>
</div>  <br>      
</div>

<!-- footer ================================================================================== -->

<div id="footer">
    
    <div><span style="color:#ffffff;">Community Forums</span>
      <ul>
      <li><a class="regular" href="/events">Official Events</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/147749602472741">In Facebook (english)</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/1339783682699494">In Facebook (korean)</a></li>
      <li><a class="regular" href="https://discord.gg/XtmMN6E">In Discord</a> (<a class="regular" href="https://discordapp.com/channels/578696555612209173/579531723348639754">direct link</a>)</li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Feedback and Support</span>
      <ul>
      <li><a class="regular" href="https://www.facebook.com/Shadertoy">Facebook</a></li>
      <li><a class="regular" href="https://twitter.com/shadertoy">Twitter</a></li>
      <li><a class="regular" href="https://www.patreon.com/shadertoy">Patreon</a></li>
      <li><a class="regular" href="https://trello.com/b/5hM0CjId">Roadmap</a></li>

      
      </ul>
    </div>

    <div><span style="color:#ffffff;">Shadertoy</span>
      <ul>
      <li><a class="regular" href="/store">Store</a></li>
      <li><a class="regular" href="/howto">Documentation</a></li>
      <li><a class="regular" href="/terms">Terms & Privacy</a></li>
      <li><a class="regular" href="/about">About</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Apps and Plugins</span>
      <ul>
      <li><a class="regular" href="https://itunes.apple.com/us/app/shadertoy/id717961814">Official iPhone App</a> by <a class="user" href="/user/reinder">Reinder</a></li>
      <li><a class="regular" href="https://steamcommunity.com/sharedfiles/filedetails/?id=1726697188">Screensaver</a> by <a class="user" href="/user/kosro">Kosro</a></li>
      <li><a class="regular" href="https://chrome.google.com/webstore/detail/shadertoy-unofficial-plug/ohicbclhdmkhoabobgppffepcopomhgl">Shadertoy plugin</a> by <a class="user" href="/user/patu">Patu</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Tutorials</span>
      <ul>
      <li><a class="regular" href="https://www.youtube.com/watch?v=0ifChJ0nJfM">Shader coding intro</a> by <a class="user" href="/user/iq">iq</a></li>
      <li><a class="regular" href="https://shadertoyunofficial.wordpress.com/">Shadertoy Unofficial</a> by <a class="user" href="/user/FabriceNeyret2">FabriceNeyret2</a></li>
      </ul>
    </div>

</div>

<div id="compliance" style="padding-bottom:6px;visibility:hidden;left:0;top:0px;width:100%;background-color:rgb(200,120,20,0.93);position:absolute;color:#FFFFFF">
    <div style="text-align: center; margin-top:8px">
        We use cookies to give you the best experience on our website. If you continue using Shadertoy, we'll assume that you are happy to receive all cookies on this website. 
        For more information, please review our <a class="regular" href="/terms">Terms & Privacy</a>.
    </div> 
    <div style="text-align: center;margin-top:6px">
        <button type="button" style="width:100px;font-size:inherit" onclick="acceptCompliance()">Accept</button>
    </div>
</div>

<script>
(function runCompliance() 
{
    let showCompliance = 1;
    let allcookies = document.cookie;
    let cookiearray = allcookies.split(';');
    for (var i=0; i<cookiearray.length; i++)
    {
        let name  = cookiearray[i].split('=')[0];
        let value = cookiearray[i].split('=')[1];
        if (name.trim() == "scmp") 
        {
            showCompliance = value;
            break;
        }
    }

    if (showCompliance === 1) 
    {
        var ve = document.getElementById("compliance");
        ve.style.visibility="visible";
    }
})();

function acceptCompliance()
{
    let now = new Date();
    now.setTime( now.getTime() + (5*365*24*60*60*1000) );
    document.cookie="scmp=0;expires=" + now.toUTCString() + ";";

    var ve = document.getElementById("compliance");
    ve.style.visibility="hidden";
}
</script>

</body>
</html>
