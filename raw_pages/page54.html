<!DOCTYPE HTML>
<html lang="en">
<head>

    
<script async src="https://www.googletagmanager.com/gtag/js?id=G-7SYLWGZYJ2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-7SYLWGZYJ2');
</script>

<title>Browse (55) - Shadertoy BETA</title>
<meta charset="utf-8" />
<meta name="Keywords" content="shadertoy, shader toy, quilez, inigo, jeremias, pol, fractals, demoscene, computer graphics, mathematics, rendering, demo, 3D, realtime, shader, raytracing, raymarching, webgl, glsl" />
<meta name="Description" content="Build shaders, share them, and learn from the best community." />
<meta name="Author" content="Beautypi" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<link rel="image_src" href="https://www.shadertoy.com/img/logo.png" />
<link rel="apple-touch-icon" href="/img/launch_icon_57.png"/>
<link rel="apple-touch-icon" sizes="72x72" href="/img/launch_icon_72.png"/>
<link rel="apple-touch-icon" sizes="114x114" href="/img/launch_icon_114.png"/>
<link rel="shortcut icon" href="/img/favicon.ico"/>

<style>::-webkit-scrollbar {
    height: 8px;
    width: 8px;
    background: #404040;
}

::-webkit-scrollbar-thumb
{
    background: #909090;
    border-radius: 0ex;
}

::-webkit-scrollbar-corner
{
    background: #000;
}

::-webkit-input-placeholder
{
	font-style:italic;
}
input:-moz-placeholder, textarea:-moz-placeholder
{
	font-style:italic;
}
input.placeholder-text, textarea.placeholder-text
{
	font-style:italic;
}

pre 
{
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
    white-space: -pre-wrap;
    white-space: -o-pre-wrap;
    word-wrap: break-word;
}

@font-face
{
    font-family: Lobster;
    src: url("/img/lobster.otf") format("opentype");
}

div#centerScreen
{
    left: 50%;
    top: 50%;
    position: absolute;
}

a.headerLinks:hover
{
    background-color:#505050;
    color : #ff8020;
}

body
{
    color: #000000;
    font-size:12px;
    font-style:normal;
    font-family:Tahoma,Arial;
    background-repeat: no-repeat;
    //background-attachment: fixed;
    padding:0px;
    margin:0px;
    text-align: left;
    background-color: #d0d0d0;
    background-repeat: repeat;
    user-select: text;
}

a,
a:hover,
a:visited
{
  color : inherit;
}

div#content {
    width: 95%;
    overflow: hidden;
    margin: auto;
    padding: 0px;
    min-height: calc(100vh - 80px);
    //box-sizing: border-box;
}


.notificationCount
{
 background-color:#ff0000;
 padding-left:3px;
 padding-right:1px;
 padding-top:1px;
 padding-bottom:1px;
}

div#header
{
    background-color: #404040;
    top: 0px;
    left: 0px;
    width: 100%;
    padding: 0;
    margin: 0;
    color: #ffffff;
    display: flex;
    flex-direction:row;
}

#headerBlock1
{
    width: 50%;
    display:flex;
    align-items:center;
}

a#headerTitle
{
    font-size: 2.25em;
    font-family: Lobster,Tahoma,Arial;
    text-decoration: none;
    padding-left:32px;
    padding-right:32px;
}

#headerSearch
{
    display: inline-block;
    color: #000000;
    width: 300px;
}

input[type=search]#mySearch
{
    width: 100%;
    border-radius: 6px;
    border: 1px solid black;
    padding:12px;
}

#headerBlock2
{
    width: 50%;
    margin-left: auto;
    display: flex;
    justify-content: flex-end;
}


a#headerTitle:hover
{
    color : #ff8020;
}

a.headerLinks
{
    font-weight: bold;
    padding-top: 14px;
    padding-bottom: 14px;
    padding-left: 14px;
    padding-right: 14px;
    margin:0px;
    text-decoration: none;
    transition: background-color 0.15s linear, color 0.15s linear;
}

#footer
{
    background-color: rgba(64,64,64,0.25);
    color: #000000;
    padding: 0px;
    margin: 0px;
    width: 100%;
    display: flex;
    justify-content: space-between;
    flex-wrap: wrap;
}

#footer div
{
    padding-top:10px;
    padding-bottom:0px;
    padding-left:16px;
    padding-right:16px;
}

#footer div ul
{
    margin-left:0px;
    padding-left:16px;
}

#footer div ul li
{
    padding-top:6px;
}

a.regular
{
    font-weight:bold;
    text-decoration:none
}

a.regular:hover
{
  color : #ff8020;
}

a.user
{
    font-weight:bold;
    text-decoration:none;
}

a.user:hover
{
  color : #ff8020;
  text-decoration: underline;
}

.uiButton
{
    border: none;
    outline: none;
    margin: 0px;
    padding: 0px;
    width: 22px;
    height: 22px;
    position: absolute;
    cursor: pointer;
    border-radius: 4px;
}

.uiButton:hover
{
    box-shadow: inset 0px 0px 1px 1px #808080, 0px 0px 1px 1px #808080;
}

.uiDivBUtton
{
    cursor:pointer;
}

.uiDivBUtton:hover
{
    color: #ffffff;
}


.dialog
{
    display: block;
    background-color: #e0e0e0;
    color: #000000;
    border:1px solid #000;
    padding:0px;
    margin:0px;
    text-align:left;
    border-radius: 4px;
    box-shadow:4px 4px 6px 0px rgba(0,0,0,0.5);
    overflow: hidden;
    z-index:1000;
    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;
}

.dialogHeader
{
    left:0px;
    top: 0px;
    width:100%;
    height:32px;
    position: absolute;
    background-color: #808080;
    cursor:move;
}

.dialogTitle
{
    left: 12px;
    top: 4px;
    position: absolute;
    padding: 0px;
    margin: 0px;
    color:#000000;
    font-size:1.5em;
    text-align: left;
    user-select: none;
    -moz-user-select: -moz-none;
    -webkit-user-select: none;
}

.dialogOverlay
{
    z-index:1000;

    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;

    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    width:100%;
    height:100%;
    position:absolute;

    background-color:rgba(0,0,0,.4);
}

.viewsIcon, .likesIcon
{
    border: none;
    outline: none;
    display:inline-block;
    background-repeat:no-repeat;
    top:0px;
    left:0px;
    padding:0px;
    padding-right: 2px;
    margin:0px;
    position:relative;
}

.userPictureSmall
{
    background-color:#808080;
    border: 1px solid #000000;
    width:32px;
    height:32px;
}

.dialogCloseButton
{
    right:8px;
    top: 4px;
    width:22px;
    height:22px;
    position: absolute;
    background-image: url("/img/close.png");
    cursor: pointer;
    border-radius: 4px;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContentButtons
{
     padding:0;
     border:0;
     text-align: justify;
     left: 24px;
     bottom:40px;
     position:absolute;
}

.dialogButton
{
    text-align: center;
    vertical-align: middle;
    display: inline-block;
    border-radius: 4px;
    font-weight: bold;
    cursor: pointer;
    padding-bottom:5px;
    padding-top:4px;
    padding-left: 8px;
    padding-right: 8px;
    margin-left:4px;
    margin-right:4px;
    text-decoration: none;
    color:#000000;
    width: 80px;
    -moz-transition:    background-color 0.15s linear, color 0.15s linear;
    -webkit-transition: background-color 0.15s linear, color 0.15s linear;
    transition:         background-color 0.15s linear, color 0.15s linear;
}

.dialogButton:hover
{
  background-color:#808080;
  color : #ff8020;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContent
{
    color: inherit;
    overflow: auto;
    width:100%;
    height:100%;
    left: 0px;
    top: 32px;
    position:absolute
}

.dialogContentBody
{
    color: inherit;
    width:100%;
    height:auto;
    padding-top:24px;
    padding-bottom:24px;
    padding-left:24px;
    padding-right:24px;
    text-align: left;
}

.formButton
{
    font-weight:bold;
	color:#ffffff;
	border:none;
    text-align:center;
	background-color:#808080;
    border-radius: 4px;
	padding-left:8px;
	padding-right:8px;
	padding-top:4px;
	padding-bottom:4px;
    cursor:pointer;
    min-width:80px;
    box-sizing: border-box;
}
.formInput {
    border-radius: 6px;
    border: 1px solid black;
    padding: 4px;
    border: none;
}
.formButton:hover {
    background-color: #e0e0e0;
}
.formButton:disabled
{
	color:#b0b0b0;
	background-color:#808080;
}

.formButtonSmall
{
    color:#ffffff;
    border:none;
    text-align:center;
    background-color:#808080;
    border-radius: 4px;
    padding-left:2px;
    padding-right:2px;
    padding-top:2px;
    padding-bottom:2px;
    cursor:pointer;
    min-width:40px;
}

.formButtonSmall:hover
{
    background-color: #e0e0e0;
}

.formButtonSmall:disabled
{
    color:#b0b0b0;
    background-color:#808080;
}

.formButtonSmall.disabled2,
.formButton.disabled2 { color:#b0b0b0; background-color:#808080; pointer-events: none; }

.inputForm
{
    padding-left:2%;
    padding-right:2%;
    resize: none;
    text-align: left;
    background-color:#e0e0e0;
    outline: none;
    border-radius: 4px;
    border: 1px solid #808080;
    color:inherit;
    box-sizing: border-box;
}

.inputForm:focus
{
    border: 1px solid #AFCDD8;
    background-color: #EBF2F4;
}

.transparentPannel
{
    background-color:rgba(64,64,64,0.1);
    padding:16px;
}

.comment, .commentSelf, .commentNew
{
    border-radius: 4px;
    width: 100%;
    margin-left: 0px;
    margin-right: 0px;
    margin-top: 0px;
    margin-bottom: 6px;

    padding: 14px;
    box-sizing: border-box;
    display: grid;
    grid-template-columns: 32px auto 8px;
    grid-template-rows: 1fr;
    grid-gap:8px;
}

.comment:nth-child(even)
{
    background-color: rgba(64,64,64,0.1);
}

.comment:nth-child(odd)
{
    background-color: rgba(128,128,128,0.1);
}

.commentSelf
{
    background-color: rgba(240,160,64,0.1);
}

.commentNew
{
    padding-right: 0px;
    grid-template-columns: 40px auto;
}

.commentContent
{
    vertical-align: top;
    text-align: left;
    word-break: break-all;
    word-break: break-word;
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
}


/* ----------------------- media resolutions ------------------------ */

@media screen and (max-width:799px)
{
    div#header {flex-direction:column; }
    #headerBlock1 { width:100%; }
    #headerBlock2 { width:100%; justify-content: space-around;}
    div#headerSearch {width:200px;}
    input#mySearch { width:200px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:10px; }
}

@media screen and (min-width:800px) and (max-width:1279px)
{
    body { font-size: 9px; }
    div#headerSearch {width: 250px;}
    input#mySearch { width:250px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:11px; }
}

@media screen and (min-width:1280px) and (max-width:1439px)
{
    body { font-size: 10px; }
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1440px) and (max-width:1919px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1920px) and (max-width:2559px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}

@media screen and (min-width:2560px) 
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}
body
{
    background-image: url("/img/themes/classic/background.jpg");
}
</style>

    <script>"use strict"

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piCamera
//
//==============================================================================

function piCamera()
{
    var mMatrix = setIdentity();
    var mMatrixInv = setIdentity();

    var mPosition = [0.0,0.0,0.0];
    var mXRotation = 0.0;
    var mYRotation = 0.0;

    var mPositionTarget = [0.0,0.0,0.0];
    var mXRotationTarget = 0.0;
    var mYRotationTarget = 0.0;

    var me = {};
/*
    me.Set = function( pos, dir, roll) 
             {
                 mMatrix    = setLookat( pos, add(pos,dir), [Math.sin(roll),Math.cos(roll),Math.sin(roll)] );
                 mMatrixInv = invertFast( mMatrix );
             };
*/
    me.SetPos = function(pos)
                {
                    mPosition = pos;
                    //mMatrix[ 3] = -(mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                    //mMatrix[ 7] = -(mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                    //mMatrix[11] = -(mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                };
/*
    me.GlobalMove = function(pos)
                    {
                        mMatrix[ 3] -= (mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                        mMatrix[ 7] -= (mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                        mMatrix[11] -= (mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                        mMatrixInv = invertFast(mMatrix);
                    };
*/
    me.LocalMove = function( dis )
                    {
                        dis = matMulvec( setRotationY(-mYRotation), dis);
                        mPositionTarget = sub(mPositionTarget,dis)
                    };

    me.RotateXY = function( x, y)
                  {
                    mXRotationTarget -= x;
                    mYRotationTarget -= y;
                    mXRotationTarget = Math.min( Math.max( mXRotationTarget, -Math.PI/2), Math.PI/2 );
                  };


    me.CameraExectue = function( dt )
    {
        // smooth position
        mXRotation += (mXRotationTarget-mXRotation) * 12.0*dt;
        mYRotation += (mYRotationTarget-mYRotation) * 12.0*dt;
        mPosition = add(mPosition, mul( sub(mPositionTarget, mPosition), 12.0*dt));

        // Make Camera matrix
        mMatrix = matMul( matMul(setRotationX(mXRotation), 
                                 setRotationY(mYRotation)),  
                                 setTranslation(mPosition));
        mMatrixInv = invertFast(mMatrix);

    }

    me.GetMatrix = function() { return mMatrix; };
    me.GetMatrixInverse = function() { return mMatrixInv; };
    me.SetMatrix = function( mat ) 
                    {
                        mMatrix = mat;
                        mMatrixInv = invertFast(mMatrix);

                        mPosition = getXYZ(matMulpoint(mat, [0.0,0.0,0.0]));
                        mPositionTarget = mPosition;
                    };

    me.GetPos = function() { return getXYZ(matMulpoint(mMatrixInv, [0.0,0.0,0.0])); }
    me.GetDir = function() { return getXYZ(normalize(matMulvec(mMatrixInv, [0.0,0.0,-1.0]))); }

    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piFile
//
//==============================================================================

function piFile( binaryDataArrayBuffer )
{
    // private
    //var mDataView = new DataView( binaryDataArrayBuffer, 0 );
    var mDataView = binaryDataArrayBuffer;
    var mOffset = 0;

    // public members
    var me = {};
    me.mDummy = 0;
/*
    // public functions
    me.Seek = function( off ) { mOffset = off - 3; };
    me.ReadUInt16 = function()  { var res = mDataView.getUint16( mOffset ); mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = mDataView.getUint32( mOffset ); mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = mDataView.getFloat32( mOffset ); mOffset+=4; return res; };
*/

    me.Seek = function( off ) { mOffset = off; };
    me.ReadUInt8  = function()  { var res = (new Uint8Array(mDataView,mOffset))[0]; mOffset+=1; return res; };
    me.ReadUInt16 = function()  { var res = (new Uint16Array(mDataView,mOffset))[0]; mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = (new Uint32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = (new Float32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadFloat32Array = function(n) 
                          { 
                              var src = new Float32Array(mDataView, mOffset);
                              var res = [];  for( var i=0; i<n; i++ ) { res[i] = src[i]; }
                              mOffset += 4*n;
                              return res;
                          };
    me.ReadFloat32ArrayNative = function(n) { var src = new Float32Array(mDataView, mOffset); mOffset += 4*n; return src; };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piMesh
//
//==============================================================================

function piMesh()
{
    this.mChunks = [];
    this.mPrimitiveType = 0;
    this.mVertexFormat = null;
}

/*
piMesh.prototype.normalize = function( ppos, npos )
{
    var numv = this.mVertexData.length;
    var numt = this.mIndices.length;

    for( var i=0; i<numv; i++ )
    {
        //float *v = (float*)piMesh_GetVertexData( me, i, npos );
        //v[0] = 0.0f;
        //v[1] = 0.0f;
        //v[2] = 0.0f;
        this.mVerts[8 * i + 3] = 0.0;
        this.mVerts[8 * i + 4] = 0.0;
        this.mVerts[8 * i + 5] = 0.0;
    }

    for( var i=0; i<numt; i++ )
    {
        piMeshFace *face = me->mFaceData.mIndexArray[0].mBuffer + i;

        const int ft = face->mNum;
        
        vec3 nor = vec3( 0.0f, 0.0f, 0.0f );
        for( int j=0; j<ft; j++ )
        {
            const vec3 va = *((vec3*)piMesh_GetVertexData( me, face->mIndex[ j      ], ppos ));
            const vec3 vb = *((vec3*)piMesh_GetVertexData( me, face->mIndex[(j+1)%ft], ppos ));

            nor += cross( va, vb );
        }

        for( int j=0; j<ft; j++ )
        {
            vec3 *n = (vec3*)piMesh_GetVertexData( me, face->mIndex[j], npos );
            n->x += nor.x;
            n->y += nor.y;
            n->z += nor.z;
        }
    }

    for( var i=0; i<numv; i++ )
    {
        vec3 *v = (vec3*)piMesh_GetVertexData( me, i, npos );
        *v = normalize( *v );
    }
}
*/

piMesh.prototype.createCube = function(renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([ -1.0, -1.0, -1.0,
                                       1.0, -1.0, -1.0,
                                      -1.0,  1.0, -1.0,
                                       1.0,  1.0, -1.0,
                                      -1.0, -1.0,  1.0,
                                       1.0, -1.0,  1.0,
                                      -1.0,  1.0,  1.0,
                                       1.0,  1.0,  1.0 ]),

                        mIndices : new Uint16Array([ 0, 2, 1,   1, 2, 3,   5, 1, 3,   5, 3, 7,   4, 5, 7,   4, 7, 6,   4, 6, 2,   4, 2, 0,   6, 7, 3,   6, 3, 2,   4, 0, 1,   4, 1, 5 ]),
                        mNumVertices : 8,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };

    this.mVertexFormat = { mStride:12, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}

piMesh.prototype.createCubeSharp = function (renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 1.0,
                                    -1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 0.0,

                                     1.0, 1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 0.0,

                                     1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 1.0,
                                    -1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   1.0, 1.0,
                                     1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   1.0, 0.0,

                                    -1.0, 1.0, 1.0,  -1.0, 0.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0,-1.0,  -1.0, 0.0, 0.0,   0.0, 1.0,
                                    -1.0,-1.0,-1.0,  -1.0, 0.0, 0.0,   1.0, 1.0,
                                    -1.0,-1.0, 1.0,  -1.0, 0.0, 0.0,   1.0, 0.0 ]),

                        mIndices : new Uint16Array([0,1,2, 0,2,3,   4,5,6, 4,6,7,    8,9,10,8,10,11,   12,13,14,12,14,15,   16,17,18,16,18,19,   20,21,22,20,22,23]),
                        mNumVertices : 24,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };


    this.mVertexFormat = { mStride:32, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}


piMesh.prototype.createUnitQuad = function (renderer)
{
    this.mPrimitiveType = 0;
    this.mVertexFormat = { mStride:8, mChannels: [ {mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false} ] };

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0,  1.0, 1.0,  1.0]),
                        mIndices : new Uint16Array([0, 2, 1, 1, 2, 3]),
                        mNumVertices : 4,
                        mNumFaces : 2, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };
 
    return true;
}




piMesh.prototype.destroy = function()
{
    //delete this.mVerts;   this.mVerts = null;
    //delete this.mIndices; this.mIndices = null;
}

piMesh.prototype.scale = function (x, y, z)
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] *= x;
            this.mChunks[j].mVerts[stride * i + 1] *= y;
            this.mChunks[j].mVerts[stride * i + 2] *= z;
        }
    }
}

piMesh.prototype.translate = function (x, y, z) 
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] += x;
            this.mChunks[j].mVerts[stride * i + 1] += y;
            this.mChunks[j].mVerts[stride * i + 2] += z;
        }
    }
}

piMesh.prototype.GPULoad = function (renderer)
{
    for( var i=0; i<this.mChunks.length; i++ )
    {
        var vbo = renderer.CreateVertexArray(this.mChunks[i].mVerts, renderer.BUFTYPE.STATIC );
        if (vbo == null)
            return false;

        var ibo = renderer.CreateIndexArray(this.mChunks[i].mIndices, renderer.BUFTYPE.STATIC);
        if (ibo == null)
            return false;

        this.mChunks[i].mVBO = vbo;
        this.mChunks[i].mIBO = ibo;
    }
    return true;
}

piMesh.prototype.GPURender = function (renderer, positions )//, matPrj, matCam )
{
    //renderer.SetShaderConstantMat4F("unMPrj", matPrj, false );

    var num = this.mChunks.length;
    for( var i=0; i<num; i++ )
    {
        //var mat =  matMul( matCam, this.mChunks[i].mTransform );
        //renderer.SetShaderConstantMat4F("unMMod", mat, false);

        renderer.AttachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat, positions );
        renderer.AttachIndexArray(this.mChunks[i].mIBO );
        renderer.DrawPrimitive(renderer.PRIMTYPE.TRIANGLES, this.mChunks[i].mNumFaces * 3, true, 1);
        renderer.DetachIndexArray(this.mChunks[i].mIBO);
        renderer.DetachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat );
    }
}
//==============================================================================
//
// piLibs 2014-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piRenderer
//
//==============================================================================

function piRenderer()
{
    // private members

    var mGL = null;
    var mBindedShader = null;
    var mIs20 = false;
    var mFloat32Textures;
    var mFloat32Filter;
    var mFloat16Textures;
    var mDrawBuffers;
    var mDepthTextures;
    var mDerivatives;
    var mFloat16Filter;
    var mShaderTextureLOD;
    var mAnisotropic;
    var mRenderToFloat32F;
    var mDebugShader;
    var mAsynchCompile;

    var mVBO_Quad = null;
    var mVBO_Tri = null;
    var mVBO_CubePosNor = null;
    var mVBO_CubePos = null;
    var mShaderHeader = ["",""];
    var mShaderHeaderLines = [0,0];

    // public members
    var me = {};

    me.CLEAR      = { Color: 1, Zbuffer : 2, Stencil : 4 };
    me.TEXFMT     = { C4I8 : 0, C1I8 : 1, C1F16 : 2, C4F16 : 3, C1F32 : 4, C4F32 : 5, Z16 : 6, Z24 : 7, Z32 : 8, C3F32:9 };
    me.TEXWRP     = { CLAMP : 0, REPEAT : 1 };
    me.BUFTYPE    = { STATIC : 0, DYNAMIC : 1 };
    me.PRIMTYPE   = { POINTS : 0, LINES : 1, LINE_LOOP : 2, LINE_STRIP : 3, TRIANGLES : 4, TRIANGLE_STRIP : 5 };
    me.RENDSTGATE = { WIREFRAME : 0, FRONT_FACE : 1, CULL_FACE : 2, DEPTH_TEST : 3, ALPHA_TO_COVERAGE : 4 };
    me.TEXTYPE    = { T2D : 0, T3D : 1, CUBEMAP : 2 };
    me.FILTER     = { NONE : 0, LINEAR : 1, MIPMAP : 2, NONE_MIPMAP : 3 };
    me.TYPE       = { UINT8 : 0, UINT16 : 1, UINT32 : 2, FLOAT16: 3, FLOAT32 : 4, FLOAT64: 5 };

    // private functions

    var iFormatPI2GL = function( format )
    {
        if( mIs20 )
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA8,           mGLExternal: mGL.RGBA,             mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.R8,              mGLExternal: mGL.RED,              mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.R16F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA16F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.R32F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA32F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C3F32) return { mGLFormat: mGL.RGB32F,          mGLExternal: mGL.RGB,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT16, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z24)   return { mGLFormat: mGL.DEPTH_COMPONENT24, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z32)   return { mGLFormat: mGL.DEPTH_COMPONENT32F, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        }
        else
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.RED,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT, mGLExternal: mGL.DEPTH_COMPONENT, mGLType: mGL.UNSIGNED_SHORT }
        }

        return null;
     }

    // public functions

    me.Initialize = function( gl )
                    {
                        mGL = gl;

                        mIs20 = !(gl instanceof WebGLRenderingContext);

                        if( mIs20 )
                        {
                            mFloat32Textures  = true;
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = true;
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = true;
                            mDrawBuffers      = true;
                            mDepthTextures    = true;
                            mShaderTextureLOD = true;
                            mAnisotropic = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mGL.getExtension( 'EXT_color_buffer_float');
                            mDebugShader = mGL.getExtension('WEBGL_debug_shaders');
                            mAsynchCompile = mGL.getExtension('KHR_parallel_shader_compile');

							mGL.hint( mGL.FRAGMENT_SHADER_DERIVATIVE_HINT, mGL.NICEST);
                        }
                        else
                        {
                            mFloat32Textures  = mGL.getExtension( 'OES_texture_float' );
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = mGL.getExtension( 'OES_texture_half_float' );
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = mGL.getExtension( 'OES_standard_derivatives' );
                            mDrawBuffers      = mGL.getExtension( 'WEBGL_draw_buffers' );
                            mDepthTextures    = mGL.getExtension( 'WEBGL_depth_texture' );
                            mShaderTextureLOD = mGL.getExtension( 'EXT_shader_texture_lod' );
                            mAnisotropic      = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mFloat32Textures;
                            mDebugShader      = null;
                            mAsynchCompile    = null;
							
							if( mDerivatives !== null) mGL.hint( mDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, mGL.NICEST);
                        }
                        
                        
                        var maxTexSize = mGL.getParameter( mGL.MAX_TEXTURE_SIZE );
                        var maxCubeSize = mGL.getParameter( mGL.MAX_CUBE_MAP_TEXTURE_SIZE );
                        var maxRenderbufferSize = mGL.getParameter( mGL.MAX_RENDERBUFFER_SIZE );
                        var extensions = mGL.getSupportedExtensions();
                        var textureUnits = mGL.getParameter( mGL.MAX_TEXTURE_IMAGE_UNITS );
                        console.log("WebGL (2.0=" + mIs20 + "):" +
                                    " Asynch Compile: "  + ((mAsynchCompile !==null) ? "yes" : "no") +
                                    ", Textures: F32 ["   + ((mFloat32Textures !==null) ? "yes" : "no") +
                                    "], F16 ["   + ((mFloat16Textures !==null) ? "yes" : "no") +
                                    "], Depth [" + ((mDepthTextures   !==null) ? "yes" : "no") +
                                    "], LOD ["    + ((mShaderTextureLOD!==null) ? "yes" : "no") +
                                    "], Aniso ["   + ((mAnisotropic     !==null) ? "yes" : "no") +
                                    "], Units [" + textureUnits +
                                    "], Max Size [" + maxTexSize +
                                    "], Cube Max Size [" + maxCubeSize +
                                    "], Targets: MRT ["            + ((mDrawBuffers     !==null) ? "yes" : "no") +
                                    "], F32 ["     + ((mRenderToFloat32F!==null) ? "yes" : "no") +
                                    "], Max Size [" + maxRenderbufferSize + "]");

                        // create a 2D quad Vertex Buffer
                        var vertices = new Float32Array( [ -1.0, -1.0,   1.0, -1.0,    -1.0,  1.0,     1.0, -1.0,    1.0,  1.0,    -1.0,  1.0] );
                        mVBO_Quad = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                        mGL.bufferData( mGL.ARRAY_BUFFER, vertices, mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 2D triangle Vertex Buffer
                        mVBO_Tri = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0,   3.0, -1.0,    -1.0,  3.0] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePosNor = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0, -1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                               1.0,  1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                               1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                               1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                               1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0,  1.0, -1.0,   0.0,  0.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePos = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0,  1.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        //-------------------------------------------------------------------

                        mShaderHeader[0] = "";
                        mShaderHeaderLines[0] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[0] += "#version 300 es\n" +
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[0] += 6;
                        }
                        else
                        {
                            mShaderHeader[0] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "#endif\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+                                                
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[0] += 26;
                        }

                        //-------------------------------------------------------

                        mShaderHeader[1] = "";
                        mShaderHeaderLines[1] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[1] += "#version 300 es\n"+
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[1] += 6;
                        }
                        else
                        {
                            if( mDerivatives ) { mShaderHeader[1] += "#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n"; mShaderHeaderLines[1]+=3; }
                            if( mShaderTextureLOD  ) { mShaderHeader[1] += "#extension GL_EXT_shader_texture_lod : enable\n"; mShaderHeaderLines[1]++; }
                            mShaderHeader[1] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "#endif\n"+ 
                                                "vec4 texture(     sampler2D   s, vec2 c)                   { return texture2D(s,c); }\n"+
                                                "vec4 texture(     sampler2D   s, vec2 c, float b)          { return texture2D(s,c,b); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c )                  { return textureCube(s,c); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c, float b)          { return textureCube(s,c,b); }\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[1] += 30;
                            if( mShaderTextureLOD )
                            {
                            mShaderHeader[1] += "vec4 textureLod(  sampler2D   s, vec2 c, float b)          { return texture2DLodEXT(s,c,b); }\n";
                            mShaderHeader[1] += "vec4 textureGrad( sampler2D   s, vec2 c, vec2 dx, vec2 dy) { return texture2DGradEXT(s,c,dx,dy); }\n";
                            mShaderHeaderLines[1] += 2;

                            //mShaderHeader[1] += "vec4 texelFetch( sampler2D s, ivec2 c, int l) { return texture2DLodEXT(s,(vec2(c)+0.5)/vec2(800,450),float(l)); }\n";
                            //mShaderHeaderLines[1] += 1;
                            }
                        }

                        return true;
                    };

        me.GetCaps =    function ()
                        {   
                            return { mIsGL20 : mIs20,
                                     mFloat32Textures: mFloat32Textures != null,
                                     mFloat16Textures: mFloat16Textures != null,
                                     mDrawBuffers: mDrawBuffers != null,
                                     mDepthTextures: mDepthTextures != null,
                                     mDerivatives: mDerivatives != null,
                                     mShaderTextureLOD: mShaderTextureLOD != null };
                        };

        me.GetShaderHeaderLines = function (shaderType)
                        {   
                            return mShaderHeaderLines[shaderType];
                        };

        me.CheckErrors = function()
                         {
                                var error = mGL.getError();
                                if( error != mGL.NO_ERROR ) 
                                { 
                                    for( var prop in mGL ) 
                                    {
                                        if( typeof mGL[prop] == 'number' ) 
                                        {
                                            if( mGL[prop] == error )
                                            {
                                                console.log( "GL Error " + error + ": " + prop );
                                                break;
                                            }
                                        }
                                    }
                                }
                         };

        me.Clear =  function( flags, ccolor, cdepth, cstencil )
                    {
                        var mode = 0;
                        if( flags & 1 ) { mode |= mGL.COLOR_BUFFER_BIT;   mGL.clearColor( ccolor[0], ccolor[1], ccolor[2], ccolor[3] ); }
                        if( flags & 2 ) { mode |= mGL.DEPTH_BUFFER_BIT;   mGL.clearDepth( cdepth ); }
                        if( flags & 4 ) { mode |= mGL.STENCIL_BUFFER_BIT; mGL.clearStencil( cstencil ); }
                        mGL.clear( mode );
                    };


        me.CreateTexture = function ( type, xres, yres, format, filter, wrap, buffer)
                           {
                                if( mGL===null ) return null;

                                var id = mGL.createTexture();

                                var glFoTy = iFormatPI2GL( format );
                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                if( type===me.TEXTYPE.T2D )
                                {
                                    mGL.bindTexture( mGL.TEXTURE_2D, id );
//if( buffer==null )
    //mGL.texStorage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres);
//else
                                    mGL.texImage2D( mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap );

                                    if (filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                }
                                else if( type===me.TEXTYPE.T3D )
                                {
                                    if( mIs20 )
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_3D, id );
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_BASE_LEVEL, 0);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAX_LEVEL, Math.log2(xres));
                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_3D);
                                        }
                                        mGL.texImage3D( mGL.TEXTURE_3D, 0, glFoTy.mGLFormat, xres, yres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap );

                                        if (filter === me.FILTER.MIPMAP)
                                            mGL.generateMipmap( mGL.TEXTURE_3D );
                                        mGL.bindTexture( mGL.TEXTURE_3D, null );
                                    }
                                    else 
                                    {
                                        return null;
                                    }
                                }
                                else 
                                {
                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );

                                    // this works great if we know the number of required mipmaps in advance (1, or other)
                                   //mGL.texStorage2D( mGL.TEXTURE_CUBE_MAP, 1, glFoTy.mGLFormat, xres, yres );

                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                    if( filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                    }

                                    if (filter === me.FILTER.MIPMAP)
                                        mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );

                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                }
                        return { mObjectID: id, mXres: xres, mYres: yres, mFormat: format, mType: type, mFilter: filter, mWrap: wrap, mVFlip:false };
                        };

        me.CreateTextureFromImage = function ( type, image, format, filter, wrap, flipY) 
                                {
                                    if( mGL===null ) return null;

                                    var id = mGL.createTexture();

                                    var glFoTy = iFormatPI2GL( format );

                                    var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                    if( type===me.TEXTYPE.T2D )
                                    {
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);

                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.pixelStorei(mGL.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                                        if( mIs20 ) mGL.pixelStorei(mGL.UNPACK_COLORSPACE_CONVERSION_WEBGL, mGL.NONE );

                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);

                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);

                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if( filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                    }
                                    else if( type===me.TEXTYPE.T3D )
                                    {
                                        return null;
                                    }
                                    else 
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );

                                        if( filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                    }
                                    return { mObjectID: id, mXres: image.width, mYres: image.height, mFormat: format, mType: type, mFilter: filter, mWrap:wrap, mVFlip:flipY };
                                };

        me.SetSamplerFilter = function (te, filter, doGenerateMipsIfNeeded) 
                            {
                                if (te.mFilter === filter) return;

                                if (te.mType === me.TEXTYPE.T2D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_3D, null);

                                }
                                else
                                {
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }


                                te.mFilter = filter;
                            };

        me.SetSamplerWrap = function (te, wrap)
                            {
                                if (te.mWrap === wrap) return;

                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, id);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, id);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_3D, null);
                                }

                                te.mWrap = wrap;
                            };

        me.SetSamplerVFlip = function (te, vflip, image)
                            {
                                if (te.mVFlip === vflip) return;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    if( image != null)
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                }
                                else if (te.mType === me.TEXTYPE.CUBEMAP)
                                {
                                    if( image != null)
                                    {
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei( mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
        
                                }

                                te.mVFlip = vflip;
                            };

        me.CreateMipmaps =  function (te)
                            {
                                if( te.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);
                                    mGL.generateMipmap(mGL.TEXTURE_2D);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);
                                }
                                else if( te.mType===me.TEXTYPE.CUBEMAP )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);
                                    mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }
                            };

        me.UpdateTexture =  function( tex, x0, y0, xres, yres, buffer )
                            {
                                var glFoTy = iFormatPI2GL( tex.mFormat );
                                if( tex.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture( mGL.TEXTURE0);
                                    mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                    mGL.texSubImage2D( mGL.TEXTURE_2D, 0, x0, y0, xres, yres, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                }
                            };

        me.UpdateTextureFromImage = function( tex, image )
                                {
                                    var glFoTy = iFormatPI2GL( tex.mFormat );
                                    if( tex.mType===me.TEXTYPE.T2D )
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                        mGL.texImage2D(  mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image );
                                        mGL.bindTexture( mGL.TEXTURE_2D, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                };

        me.DestroyTexture = function( te )
                            {
                                 mGL.deleteTexture( te.mObjectID );
                            };

        me.AttachTextures = function (num, t0, t1, t2, t3) 
                            {
                                if (num > 0 && t0 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                         if (t0.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t0.mObjectID);
                                }

                                if (num > 1 && t1 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE1);
                                         if (t1.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t1.mObjectID);
                                }

                                if (num > 2 && t2 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE2);
                                         if (t2.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t2.mObjectID);
                                }

                                if (num > 3 && t3 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE3);
                                         if (t3.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t3.mObjectID);
                                }
                            };

        me.DettachTextures = function()
                             {
                                mGL.activeTexture(mGL.TEXTURE0);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE1);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE2);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE3);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                             };

        me.CreateRenderTarget = function ( color0, color1, color2, color3, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);

                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_2D, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.DestroyRenderTarget = function ( tex )
                                 {
                                     mGL.deleteFramebuffer(tex.mObjectID);
                                 };

        me.SetRenderTarget = function (tex)
                             {
                                if( tex===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, tex.mObjectID);

                                //mGL.drawBuffers([mGL.COLOR_ATTACHMENT0, mGL.COLOR_ATTACHMENT1]);
                             };

        me.CreateRenderTargetNew = function ( wantColor0, wantZbuffer, xres, yres, samples )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if( wantZbuffer===true )
                                    {
                                        var zb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);

                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.DEPTH_COMPONENT16, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                    }

                                    if( wantColor0 )
                                    {
                                        var cb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, cb);
                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.RGBA8, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.RGBA8, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.RENDERBUFFER, cb);
                                    }

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                    {
                                        return null;
                                    }
                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mXres: xres, mYres:yres, mTex0: color0 };
                                };

        me.CreateRenderTargetCubeMap = function ( color0, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);
                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.SetRenderTargetCubeMap = function (fbo, face)
                             {
                                if( fbo===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                {
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, fbo.mObjectID);
                                    mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X+face, fbo.mTex0.mObjectID, 0);
                                }
                             };


        me.BlitRenderTarget = function( dst, src )
                                {
                                    mGL.bindFramebuffer(mGL.READ_FRAMEBUFFER, src.mObjectID);
                                    mGL.bindFramebuffer(mGL.DRAW_FRAMEBUFFER, dst.mObjectID);
                                    mGL.clearBufferfv(mGL.COLOR, 0, [0.0, 0.0, 0.0, 1.0]);
                                    mGL.blitFramebuffer( 0, 0, src.mXres, src.mYres,
                                                         0, 0, src.mXres, src.mYres,
                                                         mGL.COLOR_BUFFER_BIT, mGL.LINEAR
                                    );
                                };

        me.SetViewport = function( vp )
                         {
                              mGL.viewport( vp[0], vp[1], vp[2], vp[3] );
                         };

        me.SetWriteMask = function( c0, c1, c2, c3, z )
                          {
                              mGL.depthMask(z);
                              mGL.colorMask(c0,c0,c0,c0);
                          };

        me.SetState = function( stateName, stateValue )
                      {
                            if (stateName === me.RENDSTGATE.WIREFRAME)
                            {
                                if( stateValue ) mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.LINE );
                                else             mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.FILL );
                            }
                            else if (stateName === me.RENDSTGATE.FRONT_FACE)
                            {
                                if( stateValue ) mGL.cullFace( mGL.BACK );
                                else             mGL.cullFace( mGL.FRONT );
                            }
                            else if (stateName === me.RENDSTGATE.CULL_FACE)
                            {
                                if( stateValue ) mGL.enable( mGL.CULL_FACE );
                                else             mGL.disable( mGL.CULL_FACE );
                            }
                            else if (stateName === me.RENDSTGATE.DEPTH_TEST)
                            {
                                if( stateValue ) mGL.enable( mGL.DEPTH_TEST );
                                else             mGL.disable( mGL.DEPTH_TEST );
                            }
                            else if (stateName === me.RENDSTGATE.ALPHA_TO_COVERAGE)
                            {
                                if( stateValue ) { mGL.enable(  mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                                else             { mGL.disable( mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                            }
                      };

        me.SetMultisample = function( v)
                    {
                        if( v===true )
                        {
                            mGL.enable(mGL.SAMPLE_COVERAGE);
                            mGL.sampleCoverage(1.0, false);
                        }
                        else
                        {
                            mGL.disable(mGL.SAMPLE_COVERAGE);
                        }
                    };

        me.GetTranslatedShaderSource = function (shader) 
                          {
                            if( mGL===null ) return null;
                            if( mDebugShader===null ) return null;
                            let vfs = mGL.getAttachedShaders(shader.mProgram);
                            let str = mDebugShader.getTranslatedShaderSource(vfs[1]);
                            let parts = str.split("GLSL END"); str = (parts.length<2) ? str : parts[1];
                            return str;
                          };

        me.CreateShader = function (vsSource, fsSource, preventCache, forceSynch, onResolve) 
                          {
                            if( mGL===null ) return;

                            var vs = mGL.createShader( mGL.VERTEX_SHADER   );
                            var fs = mGL.createShader( mGL.FRAGMENT_SHADER );

                            vsSource = mShaderHeader[0] + vsSource;
                            fsSource = mShaderHeader[1] + fsSource;

                            if( preventCache )
                            {
                                let vran = Math.random().toString(36).substring(7);
                                let fran = Math.random().toString(36).substring(7);
                                vsSource += "\n#define K" + vran + "\n";
                                fsSource += "\n#define K" + fran + "\n";
                            }

                            var timeStart = getRealTime();

                            mGL.shaderSource(vs, vsSource);
                            mGL.shaderSource(fs, fsSource);
                            mGL.compileShader(vs);
                            mGL.compileShader(fs);

                            var pr = mGL.createProgram();
                            mGL.attachShader(pr, vs);
                            mGL.attachShader(pr, fs);
                            mGL.linkProgram(pr);

                            //-------------
                            let checkErrors = function()
                            {
                                if (!mGL.getProgramParameter(pr, mGL.LINK_STATUS))
                                {
                                    // vs error
                                    if (!mGL.getShaderParameter(vs, mGL.COMPILE_STATUS))
                                    {
                                        let vsLog = mGL.getShaderInfoLog(vs);
                                        onResolve(false, { mErrorType: 0, mErrorStr: vsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // fs error
                                    else if (!mGL.getShaderParameter(fs, mGL.COMPILE_STATUS))
                                    {
                                        let fsLog = mGL.getShaderInfoLog(fs);
                                        onResolve(false, { mErrorType: 1, mErrorStr: fsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // link error
                                    else
                                    {
                                        let infoLog = mGL.getProgramInfoLog(pr);
                                        onResolve(false, { mErrorType: 2, mErrorStr: infoLog });
                                        mGL.deleteProgram(pr);
                                    }
                                }
                                // no errors
                                else
                                {
                                    let compilationTime = getRealTime() - timeStart;
                                    onResolve(true, { mProgram: pr, mTime: compilationTime });
                                }
                            };

                            // check compilation
                            if (mAsynchCompile === null || forceSynch===true )
                            {
                                checkErrors();
                            }
                            else
                            {
                                let loopCheckCompletion = function ()
                                {
                                    if( mGL.getProgramParameter(pr, mAsynchCompile.COMPLETION_STATUS_KHR) === true )
                                        checkErrors();
                                    else
                                        setTimeout(loopCheckCompletion, 10);
                                };
                                setTimeout(loopCheckCompletion, 10);
                            }
                        };

        me.AttachShader = function( shader )
                          {
                                if( shader===null )
                                {
                                    mBindedShader = null;
                                    mGL.useProgram( null );
                                }
                                else
                                {
                                    mBindedShader = shader;
                                    mGL.useProgram(shader.mProgram);
                                }
                          };

        me.DetachShader = function ()
                        {
                            mGL.useProgram(null);
                        };

        me.DestroyShader = function( tex )
                        {
                            mGL.deleteProgram(tex.mProgram);
                        };

        me.GetAttribLocation = function (shader, name)
                        {
                            return mGL.getAttribLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantLocation = function (shader, name)
                        {
                            return mGL.getUniformLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantMat4F = function( uname, params, istranspose )
                        {
                            var program = mBindedShader;

                            let pos = mGL.getUniformLocation( program.mProgram, uname );
                            if( pos===null )
                                return false;

                            if( istranspose===false )
                            {
                                var tmp = new Float32Array( [ params[0], params[4], params[ 8], params[12],
                                                              params[1], params[5], params[ 9], params[13],
                                                              params[2], params[6], params[10], params[14],
                                                              params[3], params[7], params[11], params[15] ] );
	                            mGL.uniformMatrix4fv(pos,false,tmp);
                            }
                            else
                                mGL.uniformMatrix4fv(pos,false,new Float32Array(params) );
                            return true;
                        };

        me.SetShaderConstant1F_Pos = function(pos, x)
                        {
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1FV_Pos = function(pos, x)
                        {
                            mGL.uniform1fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant1F = function( uname, x )
                        {
                            var pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1I = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1i(pos, x);
                            return true;
                        };
        me.SetShaderConstant1I_Pos = function(pos, x)
                        {
                            mGL.uniform1i(pos, x);
                            return true;
                        };


        me.SetShaderConstant2F = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform2fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant3F = function(uname, x, y, z)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform3f(pos, x, y, z);
                            return true;
                        };

        me.SetShaderConstant1FV = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1fv(pos, new Float32Array(x));
                            return true;
                        };

        me.SetShaderConstant3FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform3fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderConstant4FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform4fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderTextureUnit = function( uname, unit )
                        {
                            var program = mBindedShader;
                            let pos = mGL.getUniformLocation(program.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform1i(pos, unit);
                            return true;
                        };

        me.CreateVertexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, id);
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.CreateIndexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, id );
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.DestroyArray = function( tex )
                        {
                            mGL.destroyBuffer(tex.mObject);
                        };

        me.AttachVertexArray = function( tex, attribs, pos )
                        {
                            let shader = mBindedShader;

                            mGL.bindBuffer( mGL.ARRAY_BUFFER, tex.mObject);

                            var num = attribs.mChannels.length;
                            var stride = attribs.mStride;

                            var offset = 0;
                            for (var i = 0; i < num; i++)
                            {
                                var id = pos[i];
                                mGL.enableVertexAttribArray(id);
                                var dtype = mGL.FLOAT;
                                var dsize = 4;
                                     if( attribs.mChannels[i].mType === me.TYPE.UINT8   ) { dtype = mGL.UNSIGNED_BYTE;  dsize = 1; }
                                else if( attribs.mChannels[i].mType === me.TYPE.UINT16  ) { dtype = mGL.UNSIGNED_SHORT; dsize = 2; }
                                else if( attribs.mChannels[i].mType === me.TYPE.FLOAT32 ) { dtype = mGL.FLOAT;          dsize = 4; }
                                mGL.vertexAttribPointer(id, attribs.mChannels[i].mNumComponents, dtype, attribs.mChannels[i].mNormalize, stride, offset);
                                offset += attribs.mChannels[i].mNumComponents * dsize;
                            }
                        };

        me.AttachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, tex.mObject);
                        };

        me.DetachVertexArray = function (tex, attribs)
                        {
                            let num = attribs.mChannels.length;
                            for (let i = 0; i < num; i++)
                                mGL.disableVertexAttribArray(i);
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, null);
                        };

        me.DetachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, null);
                        };

        me.DrawPrimitive = function( typeOfPrimitive, num, useIndexArray, numInstances )
                        {
                            let glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.POINTS ) glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.LINES ) glType = mGL.LINES;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_LOOP ) glType = mGL.LINE_LOOP;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_STRIP ) glType = mGL.LINE_STRIP;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLES ) glType = mGL.TRIANGLES;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLE_STRIP ) glType = mGL.TRIANGLE_STRIP;

                            if( numInstances<=1 )
                            {
  	                            if( useIndexArray ) mGL.drawElements( glType, num, mGL.UNSIGNED_SHORT, 0 );
	                            else                mGL.drawArrays( glType, 0, num );
                            }
                            else
                            {
                                mGL.drawArraysInstanced(glType, 0, num, numInstances);
                                mGL.drawElementsInstanced( glType, num, mGL.UNSIGNED_SHORT, 0, numInstances);
                            }
                        };


        me.DrawFullScreenTriangle_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 3 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };


        me.DrawUnitQuad_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 6 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };

        me.DrawUnitCube_XYZ_NOR = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                            mGL.vertexAttribPointer( vpos[0], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.vertexAttribPointer( vpos[1], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos[0] );
                            mGL.enableVertexAttribArray( vpos[1] );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos[0] );
                            mGL.disableVertexAttribArray( vpos[1] );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.DrawUnitCube_XYZ = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                            mGL.vertexAttribPointer( vpos, 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.SetBlend = function( enabled )
                    {
                        if( enabled )
                        {
                            mGL.enable( mGL.BLEND );
                            mGL.blendEquationSeparate( mGL.FUNC_ADD, mGL.FUNC_ADD );
                            mGL.blendFuncSeparate( mGL.SRC_ALPHA, mGL.ONE_MINUS_SRC_ALPHA, mGL.ONE, mGL.ONE_MINUS_SRC_ALPHA );
                        }
                        else
                        {
                            mGL.disable( mGL.BLEND );
                        }
                    };

        me.GetPixelData = function( data, offset, xres, yres )
                        {
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.UNSIGNED_BYTE, data, offset);
                        };

        me.GetPixelDataRenderTarget = function( obj, data, xres, yres )
                        {
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, obj.mObjectID);
                            mGL.readBuffer(mGL.COLOR_ATTACHMENT0);
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.FLOAT, data, 0);
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                        };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piShading
//
//==============================================================================

function smoothstep(a, b, x)
{
    x = (x - a) / (b - a);
    if (x < 0) x = 0; else if (x > 1) x = 1;
    return x * x * (3.0 - 2.0 * x);
}

function clamp01(x)
{
    if( x < 0.0 ) x = 0.0;
    if( x > 1.0 ) x = 1.0;
    return x;
}

function clamp(x, a, b)
{
    if( x < a ) x = a;
    if( x > b ) x = b;
    return x;
}

function screen(a, b)
{
    return 1.0 - (1.0 - a) * (1.0 - b);
}

function parabola(x)
{
    return 4.0 * x * (1.0 - x);
}

function min(a, b)
{
    return (a < b) ? a : b;
}

function max(a, b)
{
    return (a > b) ? a : b;
}

function noise( x )
{
    function grad(i, j, x, y)
    {
        var h = 7 * i + 131 * j;
        h = (h << 13) ^ h;
        h = (h * (h * h * 15731 + 789221) + 1376312589);

        var rx = (h & 0x20000000) ? x : -x;
        var ry = (h & 0x10000000) ? y : -y;

        return rx + ry;
    }

    var i = [ Math.floor(x[0]), Math.floor(x[1]) ];
    var f = [ x[0] - i[0], x[1] - i[1] ];
    var w = [ f[0]*f[0]*(3.0-2.0*f[0]), f[1]*f[1]*(3.0-2.0*f[1]) ];

    var a = grad( i[0]+0, i[1]+0, f[0]+0.0, f[1]+0.0 );
    var b = grad( i[0]+1, i[1]+0, f[0]-1.0, f[1]+0.0 );
    var c = grad( i[0]+0, i[1]+1, f[0]+0.0, f[1]-1.0 );
    var d = grad( i[0]+1, i[1]+1, f[0]-1.0, f[1]-1.0 );

    return a + (b-a)*w[0] + (c-a)*w[1] + (a-b-c+d)*w[0]*w[1];
}//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piVecTypes
//
//==============================================================================


function vec3( a, b, c )
{
    return [ a, b, c ];
}

function add( a, b )
{
    return [ a[0]+b[0], a[1]+b[1], a[2]+b[2] ];
}

function sub( a, b )
{
    return [ a[0]-b[0], a[1]-b[1], a[2]-b[2] ];
}

function mul( a, s ) 
{
    return [ a[0]*s, a[1]*s, a[2]*s ];
}

function cross( a, b )
{
    return [ a[1]*b[2] - a[2]*b[1],
             a[2]*b[0] - a[0]*b[2],
             a[0]*b[1] - a[1]*b[0] ];
}

function dot( a, b ) 
{
    return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
}

function normalize( v ) 
{
    var is = 1.0 / Math.sqrt( v[0]*v[0] + v[1]*v[1] + v[2]*v[2] );
    return [ v[0]*is, v[1]*is, v[2]*is ];
}

function createCirclePoint( cen, uuu, vvv, rad, s, t )
{
    return [ cen[0] + rad*(uuu[0]*s + vvv[0]*t),
             cen[1] + rad*(uuu[1]*s + vvv[1]*t),
             cen[2] + rad*(uuu[2]*s + vvv[2]*t) ];
}

function createTangent( a, b, c )
{
    var cb = normalize( [ c[0]-b[0], c[1]-b[1], c[2]-b[2] ] );
    var ba = normalize( [ b[0]-a[0], b[1]-a[1], b[2]-a[2] ] );
    return normalize( [ ba[0]+cb[0], ba[1]+cb[1], ba[2]+cb[2] ] );

}

//===================================

function vec4( a, b, c, d )
{
    return [ a, b, c, d ];
}

function getXYZ( v )
{
    return [ v[0], v[1], v[2] ];
}

//===================================

function setIdentity()
{
    return [ 1.0, 0.0, 0.0, 0.0,
             0.0, 1.0, 0.0, 0.0,
             0.0, 0.0, 1.0, 0.0,
             0.0, 0.0, 0.0, 1.0 ];
}

function setRotationX( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ 1.0,   0.0,   0.0, 0.0,
             0.0,  cost, -sint, 0.0, 
             0.0,  sint,  cost, 0.0,
             0.0,   0.0,   0.0, 1.0 ];
}

function setRotationY( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ cost, 0.0, -sint, 0.0,
              0.0, 1.0,   0.0, 0.0, 
             sint, 0.0,  cost, 0.0,
              0.0, 0.0,   0.0, 1.0 ];
}

function extractRotationEuler( m)
{
    var res = [];
    if (m[0] == 1.0)
    {
        res[0] = Math.atan2(m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;

    }
    else if (m[0] == -1.0)
    {
        res[0] = Math.atan2( m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;
    }
    else
    {
        res[0] = Math.atan2( -m[9], m[10]);
        res[1] = Math.atan2( m[8], Math.sqrt(m[9]*m[9] + m[10]*m[10]));
        res[2] = Math.atan2( m[4], m[0]);
    }
    return res;
}

function setFromQuaternion( q )
{
    var ww = q[3]*q[3];
    var xx = q[0]*q[0];
    var yy = q[1]*q[1];
    var zz = q[2]*q[2];

    return [ ww+xx-yy-zz,                   2.0*(q[0]*q[1] - q[3]*q[2]), 2.0*(q[0]*q[2] + q[3]*q[1]), 0.0,
               2.0*(q[0]*q[1] + q[3]*q[2]),   ww-xx+yy-zz,                 2.0*(q[1]*q[2] - q[3]*q[0]), 0.0,
               2.0*(q[0]*q[2] - q[3]*q[1]),   2.0*(q[1]*q[2] + q[3]*q[0]), ww-xx-yy+zz,                 0.0,
               0.0,                           0.0,                         0.0,                         1.0 ];
}

function setPerspective( fovy, aspect, znear, zfar )
{
    var tan = Math.tan(fovy * Math.PI/180.0);
    var x = 1.0 / (tan*aspect);
    var y = 1.0 / (tan);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0 * zfar * znear) / (zfar - znear);

    return [ x,    0.0,  0.0,  0.0,
             0.0,  y,    0.0,  0.0,
             0.0,  0.0,  c,     d,
             0.0,  0.0, -1.0,  0.0 ];
}

function setLookAt( eye, tar, up )
{
    var dir = [ -tar[0]+eye[0], -tar[1]+eye[1], -tar[2]+eye[2] ];

	var m00 = dir[2]*up[1] - dir[1]*up[2]; 
    var m01 = dir[0]*up[2] - dir[2]*up[0];
    var m02 = dir[1]*up[0] - dir[0]*up[1];
    var im = 1.0/Math.sqrt( m00*m00 + m01*m01 + m02*m02 );
    m00 *= im;
    m01 *= im;
    m02 *= im;

	var m04 = m02*dir[1] - m01*dir[2]; 
    var m05 = m00*dir[2] - m02*dir[0];
    var m06 = m01*dir[0] - m00*dir[1];
    im = 1.0/Math.sqrt( m04*m04 + m05*m05 + m06*m06 );
    m04 *= im;
    m05 *= im;
    m06 *= im;

	var m08 = dir[0];
	var m09 = dir[1];
	var m10 = dir[2];
    im = 1.0/Math.sqrt( m08*m08 + m09*m09 + m10*m10 );
    m08 *= im;
    m09 *= im;
    m10 *= im;

	var m03 = -(m00*eye[0] + m01*eye[1] + m02*eye[2] );
	var m07 = -(m04*eye[0] + m05*eye[1] + m06*eye[2] );
	var m11 = -(m08*eye[0] + m09*eye[1] + m10*eye[2] );

    return [ m00, m01, m02, m03,
             m04, m05, m06, m07,
             m08, m09, m10, m11,
             0.0, 0.0, 0.0, 1.0 ];
}


function setOrtho( left, right, bottom, top, znear, zfar )
{
   var x = 2.0 / (right - left);
   var y = 2.0 / (top - bottom);
   var a = (right + left) / (right - left);
   var b = (top + bottom) / (top - bottom);
   var c = -2.0 / (zfar - znear);
   var d = -(zfar + znear) / ( zfar - znear);

   return [  x, 0.0, 0.0,   a,
           0.0,   y, 0.0,   b,
           0.0, 0.0,   c,   d,
           0.0, 0.0, 0.0, 1.0 ];
}

function setTranslation( p )
{
    return [ 1.0, 0.0, 0.0, p[0],
             0.0, 1.0, 0.0, p[1],
             0.0, 0.0, 1.0, p[2],
             0.0, 0.0, 0.0, 1.0 ];
}

function setScale( s )
{
    return [ s[0], 0.0,  0.0,  0.0,
             0.0,  s[1], 0.0,  0.0,
             0.0,  0.0,  s[2], 0.0,
             0.0,  0.0,  0.0,  1.0];
}

function setProjection( fov, znear, zfar )
{
    var x = 2.0 / (fov[3]+fov[2]);
    var y = 2.0 / (fov[0]+fov[1]);
    var a = (fov[3]-fov[2]) / (fov[3]+fov[2]);
    var b = (fov[0]-fov[1]) / (fov[0]+fov[1]);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0*zfar*znear) / (zfar - znear);
    return [   x, 0.0,    a, 0.0,
             0.0,   y,    b, 0.0,
             0.0, 0.0,    c,   d,
             0.0, 0.0, -1.0, 0.0 ];
   // inverse is:
   //return mat4x4( 1.0/x, 0.0f,  0.0f,   a/x,
   //               0.0f,  1.0/y, 0.0f,   b/x,
   //               0.0f,  0.0f,  0.0f,   -1.0,
   //               0.0f,  0.0f,  1.0f/d, c/d );
}


function invertFast( m )
{
    var inv = [
   
             m[5]  * m[10] * m[15] - 
             m[5]  * m[11] * m[14] - 
             m[9]  * m[6]  * m[15] + 
             m[9]  * m[7]  * m[14] +
             m[13] * m[6]  * m[11] - 
             m[13] * m[7]  * m[10],

             -m[1]  * m[10] * m[15] + 
              m[1]  * m[11] * m[14] + 
              m[9]  * m[2] * m[15] - 
              m[9]  * m[3] * m[14] - 
              m[13] * m[2] * m[11] + 
              m[13] * m[3] * m[10],

             m[1]  * m[6] * m[15] - 
             m[1]  * m[7] * m[14] - 
             m[5]  * m[2] * m[15] + 
             m[5]  * m[3] * m[14] + 
             m[13] * m[2] * m[7] - 
             m[13] * m[3] * m[6],

             -m[1] * m[6] * m[11] + 
              m[1] * m[7] * m[10] + 
              m[5] * m[2] * m[11] - 
              m[5] * m[3] * m[10] - 
              m[9] * m[2] * m[7] + 
              m[9] * m[3] * m[6],

             -m[4]  * m[10] * m[15] + 
              m[4]  * m[11] * m[14] + 
              m[8]  * m[6]  * m[15] - 
              m[8]  * m[7]  * m[14] - 
              m[12] * m[6]  * m[11] + 
              m[12] * m[7]  * m[10],

             m[0]  * m[10] * m[15] - 
             m[0]  * m[11] * m[14] - 
             m[8]  * m[2] * m[15] + 
             m[8]  * m[3] * m[14] + 
             m[12] * m[2] * m[11] - 
             m[12] * m[3] * m[10],

             -m[0]  * m[6] * m[15] + 
              m[0]  * m[7] * m[14] + 
              m[4]  * m[2] * m[15] - 
              m[4]  * m[3] * m[14] - 
              m[12] * m[2] * m[7] + 
              m[12] * m[3] * m[6],


             m[0] * m[6] * m[11] - 
             m[0] * m[7] * m[10] - 
             m[4] * m[2] * m[11] + 
             m[4] * m[3] * m[10] + 
             m[8] * m[2] * m[7] - 
             m[8] * m[3] * m[6],


             m[4]  * m[9] * m[15] - 
             m[4]  * m[11] * m[13] - 
             m[8]  * m[5] * m[15] + 
             m[8]  * m[7] * m[13] + 
             m[12] * m[5] * m[11] - 
             m[12] * m[7] * m[9],



             -m[0]  * m[9] * m[15] + 
              m[0]  * m[11] * m[13] + 
              m[8]  * m[1] * m[15] - 
              m[8]  * m[3] * m[13] - 
              m[12] * m[1] * m[11] + 
              m[12] * m[3] * m[9],

              m[0]  * m[5] * m[15] - 
              m[0]  * m[7] * m[13] - 
              m[4]  * m[1] * m[15] + 
              m[4]  * m[3] * m[13] + 
              m[12] * m[1] * m[7] - 
              m[12] * m[3] * m[5],

              -m[0] * m[5] * m[11] + 
               m[0] * m[7] * m[9] + 
               m[4] * m[1] * m[11] - 
               m[4] * m[3] * m[9] - 
               m[8] * m[1] * m[7] + 
               m[8] * m[3] * m[5],

              -m[4]  * m[9] * m[14] + 
               m[4]  * m[10] * m[13] +
               m[8]  * m[5] * m[14] - 
               m[8]  * m[6] * m[13] - 
               m[12] * m[5] * m[10] + 
               m[12] * m[6] * m[9],

              m[0]  * m[9] * m[14] - 
              m[0]  * m[10] * m[13] - 
              m[8]  * m[1] * m[14] + 
              m[8]  * m[2] * m[13] + 
              m[12] * m[1] * m[10] - 
              m[12] * m[2] * m[9],

              -m[0]  * m[5] * m[14] + 
               m[0]  * m[6] * m[13] + 
               m[4]  * m[1] * m[14] - 
               m[4]  * m[2] * m[13] - 
               m[12] * m[1] * m[6] + 
               m[12] * m[2] * m[5],

              m[0] * m[5] * m[10] - 
              m[0] * m[6] * m[9] - 
              m[4] * m[1] * m[10] + 
              m[4] * m[2] * m[9] + 
              m[8] * m[1] * m[6] - 
              m[8] * m[2] * m[5] ];

    var det = m[0] * inv[0] + m[1] * inv[4] + m[2] * inv[8] + m[3] * inv[12];

    det = 1.0/det;

    for( var i = 0; i<16; i++ ) inv[i] = inv[i] * det;

    return inv;
}

function matMul( a, b )
{
    var res = [];
    for( var i=0; i<4; i++ )
    {
        var x = a[4*i+0];
        var y = a[4*i+1];
        var z = a[4*i+2];
        var w = a[4*i+3];

        res[4*i+0] = x * b[ 0] + y * b[ 4] + z * b[ 8] + w * b[12];
        res[4*i+1] = x * b[ 1] + y * b[ 5] + z * b[ 9] + w * b[13];
        res[4*i+2] = x * b[ 2] + y * b[ 6] + z * b[10] + w * b[14];
        res[4*i+3] = x * b[ 3] + y * b[ 7] + z * b[11] + w * b[15];
    }

    return res;
}

function matMulpoint( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2] + m[ 3],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2] + m[ 7],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] + m[11] ];
}

function matMulvec( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] ];
}


function bound3( infi )
{
    return [ infi, -infi, infi, -infi, infi, -infi ];
}

function bound3_include( a, p )
{
    return [
        (p[0]<a[0]) ? p[0] : a[0],
        (p[0]>a[1]) ? p[0] : a[1],
        (p[1]<a[2]) ? p[1] : a[2],
        (p[1]>a[3]) ? p[1] : a[3],
        (p[2]<a[4]) ? p[2] : a[4],
        (p[2]>a[5]) ? p[2] : a[5] ];
}

function bound3_center( b )
{
    return [ 0.5*(b[0]+b[1]),
             0.5*(b[2]+b[3]),
             0.5*(b[4]+b[5]) ];
}

function bound3_radius( b )
{
    return [ 0.5*(b[1]-b[0]),
             0.5*(b[3]-b[2]),
             0.5*(b[5]-b[4]) ];
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebVR
//
//==============================================================================

function WebVR( isVREnabledCallback, canvasElement )
{
    isVREnabledCallback(false);
    /*


    this.mSupportVR = false;
    this.mHMD = null;

    var me = this;
    var listVRDisplays = function (vrdevs) {
        for (var i = 0; i < vrdevs.length; i++)
        {
            if (vrdevs[i] instanceof VRDisplay)
            {
                me.mHMD = vrdevs[i];
                console.log("WebVR is available.");
                console.log(me.mHMD);
                break;
            }
        }

        isVREnabledCallback(true);
        me.mSupportVR = true;
    }

    if (navigator.getVRDisplays)
    {
        navigator.getVRDisplays().then(listVRDisplays);
    }

    isVREnabledCallback(false);
    this.mCanvas = canvasElement;
    */
}

WebVR.prototype.IsSupported = function()
{
    return false;
    //return this.mSupportVR;
}

WebVR.prototype.GetData = function( id )
{
    return {};
    /*
    var frameData = new VRFrameData();
    var s = this.mHMD.getFrameData(frameData);
    var ss = frameData.pose;
    
    var fovL = this.mHMD.getEyeParameters("left");
    var fovR = this.mHMD.getEyeParameters( "right" );

    // camera info
    var cPos = vec3(0.0, 0.0, 0.0);
    if (ss.position)
        cPos = vec3(-ss.position[0], -ss.position[1], -ss.position[2]);
    var rot = vec4(0.0, 0.0, 0.0, 0.0);
    if (ss.orientation)
        rot = vec4(ss.orientation[0], ss.orientation[1], ss.orientation[2], ss.orientation[3]);
    var cRot = setFromQuaternion(rot);
    var cTra = setTranslation(cPos);
    var cMat = matMul(invertFast(cRot), cTra);
    
    // per eye info
    var lTra = setTranslation( vec3(-fovL.offset[0], -fovL.offset[1], -fovL.offset[2]) );
    var lMat = matMul(lTra, cMat);
    var lPrj = [ Math.tan( fovL.fieldOfView.upDegrees * Math.PI/180.0),
                 Math.tan(fovL.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.rightDegrees * Math.PI / 180.0)];

    var rTra = setTranslation(vec3(-fovR.offset[0], -fovR.offset[1], -fovR.offset[2]));
    var rMat = matMul(rTra, cMat);
    var rPrj = [Math.tan(fovR.fieldOfView.upDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.rightDegrees * Math.PI / 180.0)];

    return {
        mCamera   : { mCamera: cMat },
        mLeftEye  : { mVP:[0,0,fovL.renderWidth,fovL.renderHeight], mProjection:lPrj, mCamera:lMat },
        mRightEye : { mVP:[fovR.renderWidth/2,0,fovR.renderWidth,fovR.renderHeight], mProjection:rPrj, mCamera:rMat }
           };
    */
}

WebVR.prototype.Enable = function( id )
{
    /*
    this.mHMD.requestPresent([{ source: this.mCanvas }]).then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : requestPresent failed.");
        }
    );
    */
}

WebVR.prototype.Disable = function( id )
{
    /*
    if (!this.mHMD.isPresenting)
    {
        return;
    }

    this.mHMD.exitPresent().then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : exitPresent failed.");
        }
    );
    */
}

WebVR.prototype.RequestAnimationFrame = function (id)
{
    //this.mHMD.requestAnimationFrame(id);
}

WebVR.prototype.IsPresenting = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        return true;
    }
    */
    return false;
}

WebVR.prototype.Finish = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        this.mHMD.submitFrame();
    }
    */
}

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebUtils
//
//==============================================================================


// RequestAnimationFrame
window.requestAnimFrame = ( function () { return window.requestAnimationFrame    || window.webkitRequestAnimationFrame ||
                                                 window.mozRequestAnimationFrame || window.oRequestAnimationFrame ||
                                                 window.msRequestAnimationFrame  || function( cb ) { window.setTimeout(cb,1000/60); };
                                        } )();

// performance.now
window.getRealTime = ( function() { if ("performance" in window ) return function() { return window.performance.now(); }
                                                                  return function() { return (new Date()).getTime(); }
                                  } )();

window.URL = window.URL || window.webkitURL;

navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;

function htmlEntities(str) 
{
    return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g,'&apos;');
}

function piDisableTouch()
{
    document.body.addEventListener('touchstart', function(e){ e.preventDefault(); });
}

var piGetTime = function ( timestamp )
{
    if (timestamp == 0)
        return "";
    return new Date(timestamp * 1000).toISOString().substr(0, 10);
}

function piGetCoords( obj )
{
    var x = 0;
    var y = 0; 
    do
    {
         x += obj.offsetLeft;
         y += obj.offsetTop;
    }while( obj = obj.offsetParent );

    return { mX:x, mY:y };
}

function piGetMouseCoords( ev, canvasElement )
{
    var pos = piGetCoords(canvasElement );
    var mcx =                        (ev.pageX - pos.mX) * canvasElement.width / canvasElement.offsetWidth;
    var mcy = canvasElement.height - (ev.pageY - pos.mY) * canvasElement.height / canvasElement.offsetHeight;

    return { mX: mcx, mY: mcy };

}

function piGetSourceElement( e )
{
    var ele = null;
    if( e.target )     ele = e.target;
    if( e.srcElement ) ele = e.srcElement;
    return ele;
}

function piRequestFullScreen( ele )
{
    if( ele==null ) ele =   document.documentElement;
         if( ele.requestFullscreen       ) ele.requestFullscreen();
    else if( ele.msRequestFullscreen     ) ele.msRequestFullscreen();
    else if( ele.mozRequestFullScreen    ) ele.mozRequestFullScreen();
    else if( ele.webkitRequestFullscreen ) ele.webkitRequestFullscreen( Element.ALLOW_KEYBOARD_INPUT );
}

function piIsFullScreen()
{
    return document.fullscreen || document.mozFullScreen || document.webkitIsFullScreen || document.msFullscreenElement || false;
}

function piExitFullScreen()
{
       if( document.exitFullscreen       ) document.exitFullscreen();
  else if( document.msExitFullscreen     ) document.msExitFullscreen();
  else if( document.mozCancelFullScreen  ) document.mozCancelFullScreen();
  else if( document.webkitExitFullscreen ) document.webkitExitFullscreen();
}

function piIsMobile()
{
    return (navigator.userAgent.match(/Android/i) ||
            navigator.userAgent.match(/webOS/i) ||
            navigator.userAgent.match(/iPhone/i) ||
            navigator.userAgent.match(/iPad/i) ||
            navigator.userAgent.match(/iPod/i) ||
            navigator.userAgent.match(/BlackBerry/i) ||
            navigator.userAgent.match(/Windows Phone/i)) ? true : false;
}

function piCreateGlContext( cv, useAlpha, useDepth, usePreserveBuffer, useSupersampling )
{
    var opts = { alpha: useAlpha, 
                 depth: useDepth, 
                 stencil: false, 
                 premultipliedAlpha: false, 
                 antialias: useSupersampling, 
                 preserveDrawingBuffer: usePreserveBuffer, 
                 powerPreference: "high-performance" }; // "low_power", "high_performance", "default"

    var gl = null;
    if( gl === null) gl = cv.getContext( "webgl2", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl2", opts );
    if( gl === null) gl = cv.getContext( "webgl", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl", opts );

    return gl;
}

function piCreateAudioContext()
{
    var res = null;
    try
    {
        if( window.AudioContext ) res = new AudioContext();
        if( res==null && window.webkitAudioContext ) res = new webkitAudioContext();
    }
    catch( e )
    {
        res = null;
    }
    return res;
}

function piHexColorToRGB(str) // "#ff3041"
{
    var rgb = parseInt(str.slice(1), 16);
    var r = (rgb >> 16) & 255;
    var g = (rgb >> 8) & 255;
    var b = (rgb >> 0) & 255;
    return [r, g, b];
}

function piCreateFPSCounter()
{
    var mFrame;
    var mTo;
    var mFPS;

    var iReset = function( time )
    {
        mFrame = 0;
        mTo = time;
        mFPS = 60.0;
    }

    var iCount = function( time )
    {
        mFrame++;

        if( (time-mTo)>500.0 )
        {
            mFPS = 1000.0*mFrame/(time-mTo);
            mFrame = 0;
            mTo = time;
            return true;
        }
        return false;
    }

    var iGetFPS = function()
    {
        return mFPS;
    }
    
    return { Reset : iReset, Count : iCount, GetFPS : iGetFPS };
}

function piCanMediaRecorded(canvas)
{
    if (typeof window.MediaRecorder !== 'function' || typeof canvas.captureStream !== 'function') {
        return false;
    }
    return true;
}

function piCreateMediaRecorder(isRecordingCallback, canvas) 
{
    if (piCanMediaRecorded(canvas) == false)
    {
        return null;
    }
    
    var options = { audioBitsPerSecond : 0, videoBitsPerSecond : 8000000 }; 
	     if (MediaRecorder.isTypeSupported('video/webm;codecs=h264')) options.mimeType = 'video/webm;codecs=h264';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9' )) options.mimeType = 'video/webm;codecs=vp9';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8' )) options.mimeType = 'video/webm;codecs=vp8';
    else                                                              options.mimeType = 'video/webm;';

    var mediaRecorder = new MediaRecorder(canvas.captureStream(), options);
    var chunks = [];
    
    mediaRecorder.ondataavailable = function(e) 
    {
        if (e.data.size > 0) 
        {
            chunks.push(e.data);
        }
    };
 
    mediaRecorder.onstart = function(){ 
        isRecordingCallback( true );
    };
    
    mediaRecorder.onstop = function()
    {
         isRecordingCallback( false );
         let blob     = new Blob(chunks, {type: "video/webm"});
         chunks       = [];
         let videoURL = window.URL.createObjectURL(blob);
         let url      = window.URL.createObjectURL(blob);
         let a        = document.createElement("a");
         document.body.appendChild(a);
         a.style      = "display: none";
         a.href       = url;
         a.download   = "capture.webm";
         a.click();
         window.URL.revokeObjectURL(url);
     };
    
    return mediaRecorder;
}

function piExportToEXR(width, height, numComponents, type, bytes)
{
    var bytesPerComponent = 0;
    if      (type=="Uint")   bytesPerComponent = 4; 
    else if (type=="Half")   bytesPerComponent = 2;
    else if (type=="Float")  bytesPerComponent = 4;

    var tHeader = 258 + (18 * numComponents + 1);
    var tTable = 8 * height;
    var tScanlines = height * (4 + 4 + (numComponents * bytesPerComponent * width));
    var tTotal = tHeader + tTable + tScanlines;

    //console.log("    header size = " + tHeader);
    //console.log("    table size = " + tTable);
    //console.log("    scanlines size = " + tScanlines);
    //console.log("    total = " + tTotal);

    var buffer = new ArrayBuffer(tTotal); 
    var data = new DataView(buffer);

    // Header
    {
        // Header : 4 bytes -> 0x76, 0x2f, 0x31, 0x01
        var c = 0;
        data.setUint8 (c++, 0x76);
        data.setUint8 (c++, 0x2f);
        data.setUint8 (c++, 0x31);
        data.setUint8 (c++, 0x01);

        // Version : 4 bytes -> 2, 0, 0, 0
        data.setUint8 (c++, 0x02);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        
        // Write channel info
        // Write attribute name : "channels"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x73);
            data.setUint8 (c++, 0x0);

            // Write attribute type : "chlist"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : 18 x 3 + 1 = 55
            var attribSize = 18 * numComponents + 1;
            data.setUint8 (c++, attribSize); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            var i;
            for (i = 0; i < numComponents; i++)
            {
                // Attribute : "B" (42) "G" (47) "R" (52)
                if (i==0)       data.setUint8 (c++, 0x42);
                else if (i==1)  data.setUint8 (c++, 0x47);
                else if (i==2)  data.setUint8 (c++, 0x52);
                data.setUint8 (c++, 0x00);
                
                // Value : Float (2), Half (1), Uint (0)
                if      (type=="Uint")   data.setUint8 (c++, 0x00); 
                else if (type=="Half")   data.setUint8 (c++, 0x01);
                else if (type=="Float")  data.setUint8 (c++, 0x02);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);

                // Plinear
                data.setUint8 (c++, 0x01);

                // Reserved
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 

                // X sampling
                data.setUint8 (c++, 0x01); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                
                // Y sampling
                data.setUint8 (c++, 0x01);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
            }
            // End attribute
            data.setUint8 (c++, 0x00);
    
        // Write attribute name : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute type : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : "1"
            data.setUint8 (c++, 0x01); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // Write attribute value : "0" (None)
            data.setUint8 (c++, 0x00);

        // datawindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00); 

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00);

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 

            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // displayWindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x79); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00);

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00); 

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // size
            data.setUint8 (c++, 0x01);
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);
            
            // value 
            data.setUint8 (c++, 0x00);

        // PixelAspectRatio
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x41); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x52); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x00); 

            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);
        
            // size 4
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 1.0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);
        
        // screenWindowCenter
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63);
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x43); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e);
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00);

            // v2f
            data.setUint8 (c++, 0x76); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x00);

            // size 8
            data.setUint8 (c++, 0x08); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

        // screenWindowWidth
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x00); 
            
            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00); 

            // size
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);

            // value
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);

        // End of header
        data.setUint8 (c++, 0x00);
    }
    //console.log("header size = " + c);

    // Scanline table
    var initc = c + height * 8;
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        var jump = initc + scanline * (8 + width * bytesPerComponent * numComponents); 
        data.setUint32 (c, jump, true);
        c += 4; 

        data.setUint32 (c, 0x00, true);
        c += 4;
    }
    //console.log("header + scanlines table size = " + c);

    // Scanlines
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        // Scanline
        data.setUint32(c, scanline, true);
        c += 4;

        // size 24
        var size = width * numComponents * bytesPerComponent; 
        data.setUint32(c, size, true);
        c += 4;

        var numComponentsSource = 4; // number of components in the SOURCE image
        for (var component = 0; component < numComponents ; component ++) 
        {
            for (var pixel = 0 ; pixel < width ; pixel ++) 
            {
                // flip vertical, so we read OpenGL buffers without JS image flipping
                var v = bytes[(height-1-scanline) * width *numComponentsSource + pixel * numComponentsSource + (2-component)];
                if      (type=="Float") data.setFloat32(c, v, true);
                else if (type=="Half")  data.setUint16(c, v, true);

                c += bytesPerComponent;
            }
        }
    }
    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}


function piExportToWAV(numSamples, rate, bits, numChannels, words)
{
    let numBytes = numSamples * numChannels * bits/8;

    let buffer = new ArrayBuffer(44 + numBytes); 
    let data = new DataView(buffer);

    {
        data.setUint32( 0, 0x46464952, true );  // RIFF
        data.setUint32( 4, numBytes + 36, true);
        {
            data.setUint32( 8, 0x45564157, true );  // WAV_WAVE
            data.setUint32( 12, 0x20746D66, true );  // WAV_FMT
            {
                data.setUint32( 16, 16, true);
                data.setUint16( 20, 1, true ); // WAV_FORMAT_PCM
                data.setUint16( 22, numChannels, true);
                data.setUint32( 24, rate, true);
                data.setUint32( 28, rate*numChannels*bits / 8, true);
                data.setUint16( 32, numChannels*bits / 8, true);
                data.setUint16( 34, bits, true);
            }

            data.setUint32( 36, 0x61746164, true);  // WAV_DATA
            {
                data.setUint32( 40, numBytes, true);
                let numWords = numSamples * numChannels;
                for(let i=0; i<numWords; i++ )
                {
                    data.setInt16( 44 + i*2, words[i], true );
                }
            }
        }
    }


    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}

function piTriggerDownload(name, blob)
{
    let url = URL.createObjectURL(blob);
    let aElement = document.createElement("a");
    aElement.href     = url;
    aElement.target   = "_self";
    aElement.download = name;
    document.body.appendChild(aElement);
    aElement.click();
    document.body.removeChild(aElement);
}</script>
    <script>"use strict"

function bufferID_to_assetID( id )
{
    if( id===0 ) return '4dXGR8';
    if( id===1 ) return 'XsXGR8';
    if( id===2 ) return '4sXGR8';
    if( id===3 ) return 'XdfGR8';
    return 'none';
}
function assetID_to_bufferID( id )
{
    if( id==='4dXGR8' ) return 0;
    if( id==='XsXGR8' ) return 1;
    if( id==='4sXGR8' ) return 2;
    if( id==='XdfGR8' ) return 3;
    return -1;
}

function assetID_to_cubemapBuferID( id )
{
    if( id==='4dX3Rr' ) return 0;
    return -1;
}
function cubamepBufferID_to_assetID( id )
{
    if( id===0 ) return '4dX3Rr';
    return 'none';
}

function EffectPass( renderer, is20, isLowEnd, hasShaderTextureLOD, callback, obj, forceMuted, forcePaused, outputGainNode, copyProgram, id, effect  )
{
    this.mID = id;
    this.mInputs  = [null, null, null, null ];
    this.mOutputs = [null, null, null, null ];
    this.mSource = null;

    this.mGainNode = outputGainNode;
    this.mSoundShaderCompiled = false;

    this.mEffect = effect;
    this.mRenderer = renderer;
    this.mProgramCopy = copyProgram; 
    this.mCompilationTime = 0;

    this.mType = "none";
    this.mName = "none";
    this.mFrame = 0;

    this.mShaderTextureLOD = hasShaderTextureLOD;
    this.mIs20 = is20;
    this.mIsLowEnd = isLowEnd;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mForceMuted = forceMuted;
    this.mForcePaused = forcePaused;
}

EffectPass.prototype.MakeHeader_Image = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        // old API
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                   header += "uniform sampler2D iChannel" + i + ";\n";

        // new API (see shadertoy.com/view/wtdGW8)
        header += "uniform struct {\n";
             if( inp===null )                  header += "  sampler2D";
        else if( inp.mInfo.mType==="cubemap" ) header += "  samplerCube";
        else if( inp.mInfo.mType==="volume"  ) header += "  sampler3D";
        else                                  header += "  sampler2D";
        header +=        " sampler;\n";
        header += "  vec3  size;\n";
        header += "  float time;\n";
        header += "  int   loaded;\n";
        header += "}iCh" + i + ";\n";
    }
	header += "void mainImage( out vec4 c, in vec2 f );\n";
    header += "void st_assert( bool cond );\n";
    header += "void st_assert( bool cond, int v );\n";

    if( this.mIs20 ) 
    {
        header += "\nout vec4 shadertoy_out_color;\n" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)shadertoy_out_color.x=-1.0;else if(v==1)shadertoy_out_color.y=-1.0;else if(v==2)shadertoy_out_color.z=-1.0;else shadertoy_out_color.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)shadertoy_out_color.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "shadertoy_out_color = vec4(1.0,1.0,1.0,1.0);" + 
            "vec4 color = vec4(1e20);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "if(shadertoy_out_color.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(shadertoy_out_color.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(shadertoy_out_color.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(shadertoy_out_color.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "shadertoy_out_color = vec4(color.xyz,1.0);" +
        "}";
    }
    else
    {
        header += "" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)gl_FragColor.x=-1.0;else if(v==1)gl_FragColor.y=-1.0;else if(v==2)gl_FragColor.z=-1.0;else gl_FragColor.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)gl_FragColor.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "gl_FragColor = vec4(0.0,0.0,0.0,1.0);" + 
            "vec4 color = vec4(1e20);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "color.w = 1.0;" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(gl_FragColor.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "gl_FragColor = vec4(color.xyz,1.0);"+
        "}";
    }
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 ) 
        this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "void main( void )" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );" +
        "color.w = 1.0;"
    if( this.mIs20 ) 
        this.mImagePassFooterVR +=  "outColor = color;}";
    else
        this.mImagePassFooterVR +=  "gl_FragColor = color;}";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Buffer = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                  header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainImage( out vec4 c,  in vec2 f );\n"

    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +
        "mainImage( color, gl_FragCoord.xy );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
    this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        this.mImagePassFooterVR +="outColor = color; }";
    else
        this.mImagePassFooterVR +="gl_FragColor = color; }";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Cubemap = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                   header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainCubemap( out vec4 c, in vec2 f, in vec3 ro, in vec3 rd );\n"

    header += "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainCubemap( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Sound = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform float     iChannelTime[4];\n" +
              "uniform float     iTimeOffset;\n" +
              "uniform int       iSampleOffset;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n";

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp!==null && inp.mInfo.mType==="cubemap" )
            header += "uniform samplerCube iChannel" + i + ";\n";
        else
            header += "uniform sampler2D iChannel" + i + ";\n";
    }
    header += "\n";
    header += "vec2 mainSound( in int samp, float time );\n";

    if( this.mIs20 )
    {
        header += "out vec4 outColor; void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "int   s = iSampleOffset + int(gl_FragCoord.y-0.2)*512 + int(gl_FragCoord.x-0.2);" +
            "vec2 y = mainSound( s, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "outColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    else
    {
        header += "void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "vec2 y = mainSound( 0, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "gl_FragColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    header += "\n";
    this.mHeader = header;
    this.mHeaderLength = 0;
}


EffectPass.prototype.MakeHeader_Common = function ()
{
    let header = "";
    let headerlength = 0;

    header += "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n";
    headerlength += 2;

    if (this.mIs20)
    {
        header += "out vec4 outColor;\n";
        headerlength += 1;
    }
    header += "void main( void )\n";
    headerlength += 1;

    if (this.mIs20)
        header += "{ outColor = vec4(0.0); }";
    else
        header += "{ gl_FragColor = vec4(0.0); }";
    headerlength += 1;
    header += "\n";
    headerlength += 1;

    this.mHeader = header;
    this.mHeaderLength = headerlength;
}

EffectPass.prototype.MakeHeader = function()
{
         if( this.mType==="image" ) this.MakeHeader_Image();
    else if( this.mType==="sound" ) this.MakeHeader_Sound();
    else if( this.mType==="buffer") this.MakeHeader_Buffer();
    else if( this.mType==="common") this.MakeHeader_Common();
    else if( this.mType==="cubemap") this.MakeHeader_Cubemap();
    else console.log("ERROR 4");
}

EffectPass.prototype.Create_Image = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}
EffectPass.prototype.Destroy_Image = function( wa )
{
}

EffectPass.prototype.Create_Buffer = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}

EffectPass.prototype.Destroy_Buffer = function( wa )
{
}

EffectPass.prototype.Create_Cubemap = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
}

EffectPass.prototype.Destroy_Cubemap = function( wa )
{
}

EffectPass.prototype.Create_Common = function( wa )
{
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.MakeHeader();
}
EffectPass.prototype.Destroy_Common = function( wa )
{
}

EffectPass.prototype.Create_Sound = function (wa)
{
    this.MakeHeader();

    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    this.mSampleRate = 44100;
    this.mPlayTime = 60*3;
    this.mPlaySamples = this.mPlayTime*this.mSampleRate;
    this.mBuffer = wa.createBuffer( 2, this.mPlaySamples, this.mSampleRate );

    //-------------------
    this.mTextureDimensions = 512;
    this.mRenderTexture = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D, 
                                                       this.mTextureDimensions, this.mTextureDimensions,
                                                       this.mRenderer.TEXFMT.C4I8,
                                                       this.mRenderer.FILTER.NONE,
                                                       this.mRenderer.TEXWRP.CLAMP, null);
    this.mRenderFBO = this.mRenderer.CreateRenderTarget(this.mRenderTexture, null, null, null, null, false);

    //-----------------------------

    // ArrayBufferView pixels;
    this.mTmpBufferSamples = this.mTextureDimensions*this.mTextureDimensions;
    this.mData = new Uint8Array( this.mTmpBufferSamples*4 );

    this.mPlaying = false;
}

EffectPass.prototype.Destroy_Sound = function( wa )
{
    if( this.mPlayNode!==null ) this.mPlayNode.stop();
    this.mPlayNode = null;
    this.mBuffer = null;
    this.mData = null;

    this.mRenderer.DestroyRenderTarget(this.mRenderFBO);
    this.mRenderer.DestroyTexture(this.mRenderTexture);
}

EffectPass.prototype.Create = function( passType, wa )
{
    this.mType = passType;
    this.mSource = null;

         if( passType==="image" ) this.Create_Image( wa );
    else if( passType==="sound" ) this.Create_Sound( wa );
    else if( passType==="buffer") this.Create_Buffer( wa );
    else if( passType==="common") this.Create_Common( wa );
    else if( passType==="cubemap") this.Create_Cubemap( wa );
    else alert("ERROR 1");
}

EffectPass.prototype.SetName = function (passName)
{
    this.mName = passName;
}

EffectPass.prototype.SetCode = function (src)
{
    this.mSource = src;
}

EffectPass.prototype.Destroy = function( wa )
{
    this.mSource = null;
         if( this.mType==="image" ) this.Destroy_Image( wa );
    else if( this.mType==="sound" ) this.Destroy_Sound( wa );
    else if( this.mType==="buffer") this.Destroy_Buffer( wa );
    else if( this.mType==="common") this.Destroy_Common( wa );
    else if( this.mType==="cubemap") this.Destroy_Cubemap( wa );
    else alert("ERROR 2");
}

EffectPass.prototype.NewShader_Sound = function( shaderCode, commonShaderCodes)
{
    let vsSource = null;

    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for( let i=0; i<commonShaderCodes.length; i++ )
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    this.mSoundShaderCompiled = false;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader_Image = function ( shaderCode, commonShaderCodes )
{
    this.mSupportsVR = false;

    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    return [vsSource, fsSource];


    /*
    let n1 = shaderCode.indexOf("mainVR(");
    let n2 = shaderCode.indexOf("mainVR (");
    let n3 = shaderCode.indexOf("mainVR  (");
    if( n1>0 || n2>0 || n3>0 )
    {
        let vsSourceVR;
        if( this.mIs20 )
            vsSourceVR = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        else
            vsSourceVR = "attribute in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

        let fsSourceVR = this.mHeader;
        for (let i = 0; i < commonShaderCodes.length; i++) {
            fsSourceVR += commonShaderCodes[i];
        }
        fsSourceVR += shaderCode;
        fsSourceVR += this.mImagePassFooterVR;

        let res = this.mRenderer.CreateShader(vsSource, fsSourceVR, preventCache);
        if( res.mResult == false )
        {
            return res.mInfo;
        }
        if( this.mProgramVR != null )
            this.mRenderer.DestroyShader( this.mProgramVR );

        this.mSupportsVR = true;
        this.mProgramVR = res;
    }
    */
}

EffectPass.prototype.NewShader_Cubemap = function( shaderCode, commonShaderCodes )
{
    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }

    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;

    fsSource += shaderCode;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader_Common = function (shaderCode )
{
    let vsSource = null;
    if (this.mIs20)
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader + shaderCode;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader = function ( commonSourceCodes, preventCache, onResolve)
{
    if( this.mRenderer===null ) return;

    let vs_fs = null;

         if( this.mType==="sound"  ) vs_fs = this.NewShader_Sound(   this.mSource, commonSourceCodes );
    else if( this.mType==="image"  ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="buffer" ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="common" ) vs_fs = this.NewShader_Common(  this.mSource,                   );
    else if( this.mType==="cubemap") vs_fs = this.NewShader_Cubemap( this.mSource, commonSourceCodes );
    else { console.log("ERROR 3: \"" + this.mType + "\""); return; }

    let me = this;
    this.mRenderer.CreateShader(vs_fs[0], vs_fs[1], preventCache, false,
        function (worked, info)
        {
            if (worked === true)
            {
                if (me.mType === "sound")
                {
                    me.mSoundShaderCompiled = true;
                }

                me.mCompilationTime = info.mTime;
                me.mError = false;
                me.mErrorStr = "No Errors";
                if (me.mProgram !== null)
                    me.mRenderer.DestroyShader(me.mProgram);
                me.mTranslatedSource = me.mRenderer.GetTranslatedShaderSource(info);
                me.mProgram = info;
            }
            else
            {
                me.mError = true;
                me.mErrorStr = info.mErrorStr;
            }
            onResolve();
        });
}

EffectPass.prototype.DestroyInput = function( id )
{
    if( this.mInputs[id]===null ) return;

    if( this.mInputs[id].mInfo.mType==="texture" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    if( this.mInputs[id].mInfo.mType==="volume" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="webcam" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video.src = "";

        if( this.mInputs[id].video.srcObject!==null )
        {
        let tracks = this.mInputs[id].video.srcObject.getVideoTracks();
        if( tracks ) tracks[0].stop();
        }
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="video" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="music" || this.mInputs[id].mInfo.mType==="musicstream")
    {
        this.mInputs[id].audio.pause();
        this.mInputs[id].audio.mSound.mFreqData = null;
        this.mInputs[id].audio.mSound.mWaveData = null;
        this.mInputs[id].audio = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="cubemap" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="keyboard" )
    {
        //if( this.mInputs[id].globject != null )
          //  this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="mic" )
    {
        this.mInputs[id].mic = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }

    this.mInputs[id] = null;
}

EffectPass.prototype.TooglePauseInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        else
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.audio.mPaused )
        {
            if( inp.loaded )
            {
                inp.audio.play();
            }
            inp.audio.mPaused = false;
        }
        else
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }

    return null;
}

EffectPass.prototype.StopInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused === false )
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused === false )
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.ResumeInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused )
        {
            inp.audio.play();
            inp.audio.mPaused = false;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.RewindInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp==null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.loaded )
        {
            inp.video.currentTime = 0;
        }
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.loaded )
        {
            inp.audio.currentTime = 0;
        }
    }
}

EffectPass.prototype.MuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = true;
        inp.video.mMuted = true;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 0.0;
        inp.audio.mMuted = true;
    }
}

EffectPass.prototype.UnMuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = false;
        inp.video.mMuted = false;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 1.0;
        inp.audio.mMuted = false;
    }
}

EffectPass.prototype.ToggleMuteInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];
    if( inp===null ) return null;

    if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.video.mMuted;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if( inp.audio.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.audio.mMuted;
    }

    return null;
}

EffectPass.prototype.UpdateInputs = function( wa, forceUpdate, keyboard )
{
   for (let i=0; i<this.mInputs.length; i++ )
   {
        let inp = this.mInputs[i];

        if( inp===null )
        {
            if( forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, null, false, 0, 0, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.image, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mPreview, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if( inp.loaded && forceUpdate )
            {
                if( this.mTextureCallbackFun!==null )
                {
                    let img = (assetID_to_cubemapBuferID(inp.mInfo.mID)===-1) ? inp.image[0] : inp.mImage;
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, img, true, 2, 1, -1.0, this.mID );
                }
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:keyboard.mIcon,mData:keyboard.mData}, false, 6, 0, -1.0, this.mID );
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, -1, this.mID );
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
              if( inp.loaded && inp.audio.mPaused === false && inp.audio.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                      inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                  }

                  if (this.mTextureCallbackFun!==null)
                  {
                           if (inp.mInfo.mType === "music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData}, false, 4, 1, inp.audio.currentTime, this.mID);
                      else if (inp.mInfo.mType === "musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData, info: inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                  }
              }
              else if( inp.loaded===false )
              {
                  if (this.mTextureCallbackFun!==null)
                      this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:null}, false, 4, 0, -1.0, this.mID);
              }
        }
        else if( inp.mInfo.mType==="mic" )
        {
              if( inp.loaded && inp.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                      inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
                  }
                  if( this.mTextureCallbackFun!==null )
                      this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave: ((wa==null)?null:inp.mFreqData) }, false, 5, 1, 0, this.mID );
              }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:null}, true, 9, 1, -1.0, this.mID );
            }
        }
    }
}

EffectPass.prototype.Sampler2Renderer = function (sampler)
{
    let filter = this.mRenderer.FILTER.NONE;
    if (sampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
    if (sampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
    let wrap = this.mRenderer.TEXWRP.REPEAT;
    if (sampler.wrap === "clamp") wrap = this.mRenderer.TEXWRP.CLAMP;
    let vflip = false;
    if (sampler.vflip === "true") vflip = true;

    return { mFilter: filter, mWrap: wrap, mVFlip: vflip };
}

EffectPass.prototype.GetSamplerVFlip = function (id)
{
    let inp = this.mInputs[id];
    return inp.mInfo.mSampler.vflip;
}

EffectPass.prototype.GetTranslatedShaderSource = function ()
{
    return this.mTranslatedSource;
}

EffectPass.prototype.SetSamplerVFlip = function (id, str) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = false;
    if (str === "true") filter = true;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, null);
            inp.mInfo.mSampler.vflip = str;
        }
    }
}

EffectPass.prototype.GetAcceptsVFlip = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return false;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return false;
    return true;
}

EffectPass.prototype.GetSamplerFilter = function (id)
{
    let inp = this.mInputs[id];
    if( inp===null) return;
    return inp.mInfo.mSampler.filter;
}

EffectPass.prototype.SetSamplerFilter = function (id, str, buffers, cubeBuffers) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = renderer.FILTER.NONE;
    if (str === "linear") filter = renderer.FILTER.LINEAR;
    if (str === "mipmap") filter = renderer.FILTER.MIPMAP;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0)
            {
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[0], filter, true);
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[1], filter, true);
                inp.mInfo.mSampler.filter = str;
            }
            else
            {
                renderer.SetSamplerFilter(inp.globject, filter, true);
                inp.mInfo.mSampler.filter = str;
            }
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[0], filter, true);
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[1], filter, true);
        inp.mInfo.mSampler.filter = str;
    }
    else if (inp.mInfo.mType === "keyboard")
    {
        inp.mInfo.mSampler.filter = str;
    }
}

EffectPass.prototype.GetAcceptsMipmapping = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetAcceptsLinear = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return true;
    if (inp.mInfo.mType === "musicstream") return true;
    if (inp.mInfo.mType === "mic")  return true;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return true;
    return false;
}

EffectPass.prototype.GetAcceptsWrapRepeat = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return false;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetSamplerWrap = function (id)
{
    return this.mInputs[id].mInfo.mSampler.wrap;
}

EffectPass.prototype.SetSamplerWrap = function (id, str, buffers)
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let restr = renderer.TEXWRP.REPEAT;
    if (str === "clamp") restr = renderer.TEXWRP.CLAMP;

    if (inp === null) 
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "video") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap") 
    {
        if (inp.loaded)
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "webcam") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[0], restr);
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[1], restr);
        inp.mInfo.mSampler.wrap = str;
    }
}


EffectPass.prototype.GetTexture = function( slot )
{
    let inp = this.mInputs[slot];
    if( inp===null ) return null;
    return inp.mInfo;
}

EffectPass.prototype.SetOutputs = function( slot, id )
{
    this.mOutputs[slot] = id;
}

EffectPass.prototype.SetOutputsByBufferID = function( slot, id )
{
    if( this.mType==="buffer" )
    {
        this.mOutputs[slot] = bufferID_to_assetID( id );

        this.mEffect.ResizeBuffer( id, this.mEffect.mXres, this.mEffect.mYres, false );
    }
    else if( this.mType==="cubemap" )
    {
        this.mOutputs[slot] = cubamepBufferID_to_assetID( id );
        this.mEffect.ResizeCubemapBuffer(id, 1024, 1024 );
    }
}

EffectPass.prototype.NewTexture = function( wa, slot, url, buffers, cubeBuffers, keyboard )
{
    var me = this;
    var renderer = this.mRenderer;

    if( renderer===null ) return;

    let texture = null;

    if( url===null || url.mType===null )
    {
        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( this.mTextureCallbackObj, slot, null, true, 0, 0, -1.0, me.mID );
        me.DestroyInput( slot );
        me.mInputs[slot] = null;
        me.MakeHeader();
        return { mFailed:false, mNeedsShaderCompile:false };
    }
    else if( url.mType==="texture" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.image = new Image();
        texture.image.crossOrigin = '';
        texture.image.onload = function()
        {
            let rti = me.Sampler2Renderer(url.mSampler);

            // O.M.G. FIX THIS
            let channels = renderer.TEXFMT.C4I8;
            if (url.mID === "Xdf3zn" || url.mID === "4sf3Rn" || url.mID === "4dXGzn" || url.mID === "4sf3Rr")
                channels = renderer.TEXFMT.C1I8;
            
            texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.image, channels, rti.mFilter, rti.mWrap, rti.mVFlip);

            texture.loaded = true;
            if( me.mTextureCallbackFun!==null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.image, true, 1, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="volume" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mImage = { mData:null, mXres:1, mYres:0, mZres:0 };
        texture.mPreview = new Image();
        texture.mPreview.crossOrigin = '';

	    var xmlHttp = new XMLHttpRequest();
        if( xmlHttp===null ) return { mFailed:true };

        xmlHttp.open('GET', url.mSrc, true);
        xmlHttp.responseType = "arraybuffer";
        xmlHttp.onerror = function()
        {
            console.log( "Error 1 loading Volume" );
        }
        xmlHttp.onload = function()
        {
            let data = xmlHttp.response;
            if (!data ) { console.log( "Error 2 loading Volume" ); return; }

            let file = piFile(data);

            let signature = file.ReadUInt32();
            texture.mImage.mXres = file.ReadUInt32();
            texture.mImage.mYres = file.ReadUInt32();
            texture.mImage.mZres = file.ReadUInt32();
            let binNumChannels = file.ReadUInt8();
            let binLayout = file.ReadUInt8();
            let binFormat = file.ReadUInt16();
            let format = renderer.TEXFMT.C1I8;
                 if( binNumChannels===1 && binFormat===0 )  format = renderer.TEXFMT.C1I8;
            else if( binNumChannels===2 && binFormat===0 )  format = renderer.TEXFMT.C2I8;
            else if( binNumChannels===3 && binFormat===0 )  format = renderer.TEXFMT.C3I8;
            else if( binNumChannels===4 && binFormat===0 )  format = renderer.TEXFMT.C4I8;
            else if( binNumChannels===1 && binFormat===10 ) format = renderer.TEXFMT.C1F32;
            else if( binNumChannels===2 && binFormat===10 ) format = renderer.TEXFMT.C2F32;
            else if( binNumChannels===3 && binFormat===10 ) format = renderer.TEXFMT.C3F32;
            else if( binNumChannels===4 && binFormat===10 ) format = renderer.TEXFMT.C4F32;
            else return;

            let buffer = new Uint8Array(data, 20); // skip 16 bytes (header of .bin)

            let rti = me.Sampler2Renderer(url.mSampler);

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T3D, texture.mImage.mXres, texture.mImage.mYres, format, rti.mFilter, rti.mWrap, buffer);

            if( texture.globject===null )
            {
                console.log( "Error 4: loading Volume" ); 
                return { mFailed:true };
            }

            if (me.mTextureCallbackFun !== null)
            {
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }

            texture.loaded = true;

            // load icon for it
            texture.mPreview.onload = function()
            {
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }
            texture.mPreview.src = url.mPreviewSrc;
        }
        xmlHttp.send("");


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="volume")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="cubemap" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        let rti = me.Sampler2Renderer(url.mSampler);

        if( assetID_to_cubemapBuferID(url.mID)!==-1 )
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 2, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/cubemap00.png";

            this.mEffect.ResizeCubemapBuffer(0, 1024, 1024 );

        }
        else
        {
            texture.image = [ new Image(), new Image(), new Image(), new Image(), new Image(), new Image() ];

            let numLoaded = 0;
            for (var i=0; i<6; i++ )
            {
                texture.image[i].mId = i;
                texture.image[i].crossOrigin = '';
                texture.image[i].onload = function()
                {
                    var id = this.mId;
                    numLoaded++;
                    if( numLoaded===6 )
                    {
                        texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.CUBEMAP, texture.image, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                        texture.loaded = true;
                        if (me.mTextureCallbackFun !== null)
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, texture.image[0], true, 2, 1, -1.0, me.mID);
                    }
                }

                if( i === 0) 
                {
                    texture.image[i].src = url.mSrc;
                } 
                else 
                {
                    let n = url.mSrc.lastIndexOf(".");
                    texture.image[i].src = url.mSrc.substring(0, n) + "_" + i + url.mSrc.substring(n, url.mSrc.length);
                }
            }
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="cubemap")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="webcam" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        texture.video = document.createElement('video');
    	texture.video.width = 320;
    	texture.video.height = 240;
    	texture.video.autoplay = true;
    	texture.video.loop = true;
        texture.mForceMuted = this.mForceMuted;
        texture.mImage = null;

        let rti = me.Sampler2Renderer(url.mSampler);

        var loadImageInsteadOfWebCam = function()
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.mImage, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 7, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/webcam.png";
        }
        
        loadImageInsteadOfWebCam();

        if( typeof navigator.getUserMedia !== "undefined"  && texture.mForceMuted===false )
        {
            texture.video.addEventListener("canplay", function (e)
            {
				try
				{
                    texture.mImage = null;
                    if( texture.globject != null )
                        renderer.DestroyTexture( texture.globject );
					texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
					texture.loaded = true;
                }
                catch(e)
                {
                    loadImageInsteadOfWebCam();
	                alert( 'Your browser can not transfer webcam data to the GPU.');
                }
            } );

            navigator.mediaDevices.getUserMedia( 
                                { "video": { width: 1280, height: 720 }, "audio": false } )
                                .then( function(stream)
                                       {
                                            texture.video.srcObject = stream;
    	                               } )
                                .catch( function(error)
                                        {
                                            loadImageInsteadOfWebCam();
    		                                alert( 'Unable to capture WebCam. Please reload the page.' );
    	                                } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="mic" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mForceMuted = this.mForceMuted;
        texture.mAnalyser = null;
        let num = 512;
        texture.mFreqData = new Uint8Array( num );
        texture.mWaveData = new Uint8Array( num );

        if( wa === null || typeof navigator.getUserMedia === "undefined" )
        {
            if( !texture.mForceMuted ) alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.mForceMuted = true; 
        }

        if( texture.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, num, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)
            texture.loaded = true;
        }
        else
        {
        navigator.getUserMedia( { "audio": true },
                                function(stream)
                                {
                                  texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, null)
                                  texture.mic = wa.createMediaStreamSource(stream);
                                  texture.mAnalyser = wa.createAnalyser();
                                  texture.mic.connect( texture.mAnalyser );
                                  texture.loaded = true;
    	                        },
                                function(error)
                                {
    		                        alert( 'Unable open Mic. Please reload the page.' );
    	                        } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="video" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.video = document.createElement('video');
    	texture.video.loop = true;
        texture.video.preload = "auto";
        texture.video.mPaused = this.mForcePaused;
        texture.video.mMuted = true;//this.mForceMuted;
    	texture.video.muted  = true;//this.mForceMuted;
        if( this.mForceMuted===true )
            texture.video.volume = 0;
    	texture.video.autoplay = false;
        texture.video.hasFalled = false;
        
        let rti = me.Sampler2Renderer(url.mSampler);

        texture.video.addEventListener("canplay", function (e)
        {
            texture.video.play().then( function()
                                       {
                                           texture.video.mPaused = false;

                                           texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                                           texture.loaded = true;
            
                                           if( me.mTextureCallbackFun!=null )
                                               me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.video, true, 3, 1, -1.0, me.mID );
                                        } )
                               .catch( function(error)
                                       {
                                           console.log( error );
                                       }
                                );
        } );

        texture.video.addEventListener( "error", function(e)
        {
               if( texture.video.hasFalled===true ) { alert("Error: cannot load video" ); return; }
               let str = texture.video.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".mp4";
               texture.video.src = str;
               texture.video.hasFalled = true;
        } );

        texture.video.src = url.mSrc;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="music" || url.mType==="musicstream" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.audio = document.createElement('audio');
    	texture.audio.loop = true;
        texture.audio.mMuted = this.mForceMuted;
        texture.audio.mForceMuted = this.mForceMuted;
        texture.audio.muted = this.mForceMuted;
        if( this.mForceMuted===true )
            texture.audio.volume = 0;
        texture.audio.autoplay = false;
        texture.audio.hasFalled = false;
        texture.audio.mPaused = false;
        texture.audio.mSound = {};

        if( this.mForceMuted===false )
        {
            if(url.mType==="musicstream" && SC === null)
            {
                alert( "Shadertoy: Soundcloud could not be reached" );
                texture.audio.mForceMuted = true;
            }
            }

        if( wa === null && this.mForceMuted===false )
        {
            alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.audio.mForceMuted = true;
        }

        if( texture.audio.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null);
            let num = 512;
            texture.audio.mSound.mFreqData = new Uint8Array( num );
            texture.audio.mSound.mWaveData = new Uint8Array( num );
            texture.loaded = true;
        }

        texture.audio.addEventListener( "canplay", function()
        {
            if( texture===null || texture.audio===null ) return;
            if( this.mForceMuted  ) return;
            if( texture.loaded === true ) return;

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)

            texture.audio.mSound.mSource   = wa.createMediaElementSource( texture.audio );
            texture.audio.mSound.mAnalyser = wa.createAnalyser();
            texture.audio.mSound.mGain     = wa.createGain();

            texture.audio.mSound.mSource.connect(   texture.audio.mSound.mAnalyser );
            texture.audio.mSound.mAnalyser.connect( texture.audio.mSound.mGain );
            texture.audio.mSound.mGain.connect(me.mGainNode);

            texture.audio.mSound.mFreqData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );
            texture.audio.mSound.mWaveData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );

            if( texture.audio.mPaused )
            {
                texture.audio.pause();
            }
            else
            {
                texture.audio.play().then( function() {} ).catch( function(e){console.log("error " + e);} );
            }
            texture.loaded = true;
        } );

        texture.audio.addEventListener( "error", function(e)
        {
               if( this.mForceMuted  ) return;

               if( texture.audio.hasFalled===true ) { return; }
               let str = texture.audio.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".ogg";
               texture.audio.src = str;
               texture.audio.hasFalled = true;
        } );

        if( !texture.audio.mForceMuted )
        {
            if(url.mType==="musicstream")
            {
                SC.resolve(url.mSrc, 
                    function(song) 
                    {
                        if( song.streamable===true )
                        {
                            texture.audio.crossOrigin = 'anonymous';
                            texture.audio.src = song.stream_url;
                            texture.audio.soundcloudInfo = song;
                        }
                        else
                        {
                            alert('Shadertoy: Soundcloud 3 - This track cannot be streamed' );
                        }
                    },
                    function(error)
                    {
                        if (me.mTextureCallbackFun!==null)
                        {
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
                        }
                    } );
            } 
            else
            {
                texture.audio.src = url.mSrc;
            }
        }

        if (me.mTextureCallbackFun!==null)
        {
            if (url.mType === "music")            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
            else if (url.mType === "musicstream") me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null, info: texture.audio.soundcloudInfo}, false, 8, 0, -1.0, me.mID);
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="keyboard" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = true;

        texture.keyboard = {};

        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {mImage: keyboard.mIcon, mData: keyboard.mData}, false, 6, 1, -1.0, me.mID );

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="buffer" )
    {
        texture = {};
        texture.mInfo = url;

        texture.image = new Image();
        texture.image.onload = function()
        {
            if( me.mTextureCallbackFun!==null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {texture: texture.image, data:null}, true, 9, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;
        texture.id = assetID_to_bufferID( url.mID );
        texture.loaded = true;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;

        this.mEffect.ResizeBuffer(texture.id, this.mEffect.mXres, this.mEffect.mYres, false );

        this.SetSamplerFilter(slot, url.mSampler.filter, buffers, cubeBuffers, true);
        this.SetSamplerVFlip(slot, url.mSampler.vflip);
        this.SetSamplerWrap(slot, url.mSampler.wrap, buffers);

        this.MakeHeader();
        return returnValue;
    }
    else
    {
        alert( "input type error" );
        return { mFailed: true };
    }

    return { mFailed: true };
}

EffectPass.prototype.Paint_Image = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];

    //------------------------
    
    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];
    let texIsLoaded = [0, 0, 0, 0 ];
    let texID = [ null, null, null, null];

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
            texIsLoaded[i] = 1;
            resos[3*i+0] = 256;
            resos[3*i+1] = 3;
            resos[3*i+2] = 1;
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;

                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                }
            }
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {

                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                texIsLoaded[i] = 0;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    times[i] = 10.0 + time;
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            let id = inp.id;
            if( inp.loaded===true  )
            {
                texID[i] = buffers[id].mTexture[ buffers[id].mLastRenderDone ];
                texIsLoaded[i] = 1;
                resos[3*i+0] = xres;
                resos[3*i+1] = yres;
                resos[3*i+2] = 1;
                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID[i], filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    let prog = this.mProgram;

    //if( vrData!=null && this.mSupportsVR ) prog = this.mProgramVR;

    this.mRenderer.AttachShader(prog);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F("iFrameRate", fps);

    this.mRenderer.SetShaderConstant1F(  "iCh0.time", times[0] );
    this.mRenderer.SetShaderConstant1F(  "iCh1.time", times[1] );
    this.mRenderer.SetShaderConstant1F(  "iCh2.time", times[2] );
    this.mRenderer.SetShaderConstant1F(  "iCh3.time", times[3] );
    this.mRenderer.SetShaderConstant3F(  "iCh0.size", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iCh1.size", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iCh2.size", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iCh3.size", resos[9], resos[10], resos[11] );
    this.mRenderer.SetShaderConstant1I(  "iCh0.loaded", texIsLoaded[0] );
    this.mRenderer.SetShaderConstant1I(  "iCh1.loaded", texIsLoaded[1] );
    this.mRenderer.SetShaderConstant1I(  "iCh2.loaded", texIsLoaded[2] );
    this.mRenderer.SetShaderConstant1I(  "iCh3.loaded", texIsLoaded[3] );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    if( (vrData !== null) && this.mSupportsVR )
    {
        for (let i=0; i<2; i++ )
        {
            let ei = (i===0) ? vrData.mLeftEye : vrData.mRightEye;

            let vp = [i * xres / 2, 0, xres / 2, yres];

            this.mRenderer.SetViewport(vp);

            let fov = ei.mProjection;
            let corA = [ -fov[2], -fov[1], -1.0 ];
            let corB = [  fov[3], -fov[1], -1.0 ];
            let corC = [  fov[3],  fov[0], -1.0 ];
            let corD = [ -fov[2],  fov[0], -1.0 ];
            let apex = [ 0.0, 0.0, 0.0 ];

            let ma = invertFast( ei.mCamera );
            corA = matMulpoint( ma, corA ); 
            corB = matMulpoint( ma, corB ); 
            corC = matMulpoint( ma, corC ); 
            corD = matMulpoint( ma, corD ); 
            apex = matMulpoint( ma, apex ); 

            let corners = [ corA[0], corA[1], corA[2], 
                            corB[0], corB[1], corB[2], 
                            corC[0], corC[1], corC[2], 
                            corD[0], corD[1], corD[2],
                            apex[0], apex[1], apex[2]];

            this.mRenderer.SetShaderConstant3FV("unCorners", corners);
            this.mRenderer.SetShaderConstant4FV("unViewport", vp);

            this.mRenderer.DrawUnitQuad_XY(l1);
        }
    }
    else 
    {
        this.mRenderer.SetViewport([0, 0, xres, yres]);
        this.mRenderer.DrawFullScreenTriangle_XY( l1 );
    }

    this.mRenderer.DettachTextures();
}

EffectPass.prototype.iRenderSound = function(d, callback )
{
    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds() ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    this.mRenderer.SetRenderTarget(this.mRenderFBO);

    this.mRenderer.SetViewport([0, 0, this.mTextureDimensions, this.mTextureDimensions]);
    this.mRenderer.AttachShader(this.mProgram);
    this.mRenderer.SetBlend( false );

    let texID = [null, null, null, null];
    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
    }

    this.mRenderer.AttachTextures(4, texID[0], texID[1], texID[2], texID[3]);

    let l2 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iTimeOffset");
    let l3 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iSampleOffset");
    this.mRenderer.SetShaderConstant4FV("iDate", dates);
    this.mRenderer.SetShaderConstant3FV("iChannelResolution", resos);
    this.mRenderer.SetShaderConstant1F("iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit("iChannel0", 0);
    this.mRenderer.SetShaderTextureUnit("iChannel1", 1);
    this.mRenderer.SetShaderTextureUnit("iChannel2", 2);
    this.mRenderer.SetShaderTextureUnit("iChannel3", 3);

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    //--------------------------------
    let numSamples = this.mTmpBufferSamples;
    let numBlocks = this.mPlaySamples / numSamples;
    for (let j=0; j<numBlocks; j++ )
    {
        let off = j*numSamples;
        
        this.mRenderer.SetShaderConstant1F_Pos(l2, off / this.mSampleRate);
        this.mRenderer.SetShaderConstant1I_Pos(l3, off );
        this.mRenderer.DrawUnitQuad_XY(l1);

        this.mRenderer.GetPixelData(this.mData, 0, this.mTextureDimensions, this.mTextureDimensions);

        callback( off, this.mData, numSamples );
    }

    this.mRenderer.DetachShader();
    this.mRenderer.DettachTextures();
    this.mRenderer.SetRenderTarget(null);
}

EffectPass.prototype.Paint_Sound = function( wa, d )
{
    let bufL = this.mBuffer.getChannelData(0); // Float32Array
    let bufR = this.mBuffer.getChannelData(1); // Float32Array

    this.iRenderSound( d, function(off, data, numSamples)
                         {
                            for( let i=0; i<numSamples; i++ )
                            {
                                bufL[off+i] = -1.0 + 2.0*(data[4*i+0]+256.0*data[4*i+1])/65535.0;
                                bufR[off+i] = -1.0 + 2.0*(data[4*i+2]+256.0*data[4*i+3])/65535.0;
                            }
                         }
                     );
}

EffectPass.prototype.SetUniforms = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    //------------------------
    
    let texID = [ null, null, null, null];

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
        }
        else if( inp.mInfo.mType=="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
    
                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                }
            }

        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
           if( inp.loaded===true )
           { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                times[i] = 10.0 + time;
            }

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = buffers[inp.id].mTexture[ buffers[inp.id].mLastRenderDone ];
                resos[3*i+0] = buffers[inp.id].mResolution[0];
                resos[3*i+1] = buffers[inp.id].mResolution[1];
                resos[3*i+2] = 1;
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    this.mRenderer.AttachShader(this.mProgram);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F(  "iFrameRate", fps );

    this.mRenderer.SetShaderConstant1F(  "iChannel[0].time",       times[0] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[1].time",       times[1] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[2].time",       times[2] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[3].time",       times[3] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[0].resolution", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[1].resolution", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[2].resolution", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[3].resolution", resos[9], resos[10], resos[11] );
}

EffectPass.prototype.ProcessInputs = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
        }
        else if( inp.mInfo.mType==="volume" )
        {
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );
                }
                else if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                if( inp.audio.mForceMuted === true )
                {
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                let id = inp.id;
                let texID = buffers[id].mTexture[ buffers[id].mLastRenderDone ];

                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID, filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
				let id = inp.id;
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }
}

EffectPass.prototype.Paint_Cubemap = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face )
{
    this.ProcessInputs(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
    this.SetUniforms(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    let vp = [0, 0, xres, yres];

    this.mRenderer.SetViewport(vp);

    let corA = [-1.0, -1.0, -1.0];
    let corB = [ 1.0, -1.0, -1.0];
    let corC = [ 1.0,  1.0, -1.0];
    let corD = [-1.0,  1.0, -1.0];
    let apex = [ 0.0,  0.0,  0.0];

         if( face===0 ) { corA=[ 1.0,  1.0,  1.0]; corB=[ 1.0,  1.0, -1.0]; corC=[ 1.0, -1.0, -1.0]; corD=[ 1.0, -1.0,  1.0]; }
    else if( face===1 ) { corA=[-1.0,  1.0, -1.0]; corB=[-1.0,  1.0,  1.0]; corC=[-1.0, -1.0,  1.0]; corD=[-1.0, -1.0, -1.0]; }
    else if( face===2 ) { corA=[-1.0,  1.0, -1.0]; corB=[ 1.0,  1.0, -1.0]; corC=[ 1.0,  1.0,  1.0]; corD=[-1.0,  1.0,  1.0]; }
    else if( face===3 ) { corA=[-1.0, -1.0,  1.0]; corB=[ 1.0, -1.0,  1.0]; corC=[ 1.0, -1.0, -1.0]; corD=[-1.0, -1.0, -1.0]; }
    else if( face===4 ) { corA=[-1.0,  1.0,  1.0]; corB=[ 1.0,  1.0,  1.0]; corC=[ 1.0, -1.0,  1.0]; corD=[-1.0, -1.0,  1.0]; }
    else if( face===5 ) { corA=[ 1.0,  1.0, -1.0]; corB=[-1.0,  1.0, -1.0]; corC=[-1.0, -1.0, -1.0]; corD=[ 1.0, -1.0, -1.0]; }

    let corners = [ corA[0], corA[1], corA[2], 
                    corB[0], corB[1], corB[2], 
                    corC[0], corC[1], corC[2], 
                    corD[0], corD[1], corD[2],
                    apex[0], apex[1], apex[2]];

    this.mRenderer.SetShaderConstant3FV("unCorners", corners);
    this.mRenderer.SetShaderConstant4FV("unViewport", vp);

    this.mRenderer.DrawUnitQuad_XY(l1);

    this.mRenderer.DettachTextures();
}

EffectPass.prototype.Paint = function( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, bufferNeedsMimaps, buffers, cubeBuffers, keyboard, effect )
{
    if( this.mType==="sound" )
    {
        if (this.mSoundShaderCompiled === true)
        {
            // make sure all textures are loaded
            for (let i=0; i<this.mInputs.length; i++ )
            {
                let inp = this.mInputs[i];
                if (inp === null) continue;

                if (inp.mInfo.mType === "texture" && !inp.loaded) return;
                if (inp.mInfo.mType === "cubemap" && !inp.loaded) return;
            }

            this.Paint_Sound(wa, da);
            this.mSoundShaderCompiled = false;
        }
        if (this.mFrame === 0)
        {
            if (this.mPlaying===true)
            {
                this.mPlayNode.disconnect();
                this.mPlayNode.stop();
                this.mPlayNode = null;
            }
            this.mPlaying = true;

            this.mPlayNode = wa.createBufferSource();
            this.mPlayNode.buffer = this.mBuffer;
            this.mPlayNode.connect(this.mGainNode);
            this.mPlayNode.start(0);
        }
        this.mFrame++;
    }
    else if( this.mType==="image" )
    {
        this.mRenderer.SetRenderTarget( null );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );
        this.mFrame++;
    }
    else if( this.mType==="common" )
    {
    }
    else if( this.mType==="buffer" )
    {
        this.mEffect.ResizeBuffer(bufferID, this.mEffect.mXres, this.mEffect.mYres, false );

        let buffer = buffers[bufferID];

        let dstID = 1 - buffer.mLastRenderDone;

        this.mRenderer.SetRenderTarget( buffer.mTarget[dstID] );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }

        // make thumbnail
        //if( this.mTextureCallbackFun != null )
        /*
        {
            this.mRenderer.SetRenderTarget( buffer.mThumbnailRenderTarget );
            let v = [0, 0, buffer.mThumbnailRes[0], buffer.mThumbnailRes[1]];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            this.mRenderer.SetShaderConstant4FV("v", v);
            this.mRenderer.AttachTextures(1, buffer.mTexture[dstID], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);
            this.mRenderer.DettachTextures();
            this.mRenderer.DetachShader();
            this.mRenderer.GetPixelData( new Uint8Array(buffer.mThumbnailBuffer.data.buffer), buffer.mThumbnailRes[0], buffer.mThumbnailRes[1] );
            this.mRenderer.SetRenderTarget(null);
        }
        */
        buffers[bufferID].mLastRenderDone = 1 - buffers[bufferID].mLastRenderDone;
        this.mFrame++;
    }
    else if( this.mType==="cubemap" )
    {
        this.mEffect.ResizeCubemapBuffer(bufferID, 1024, 1024, false );

        let buffer = cubeBuffers[bufferID];

        xres = buffer.mResolution[0];
        yres = buffer.mResolution[1];
        let dstID = 1 - buffer.mLastRenderDone;
        for( let face=0; face<6; face++ )
        {
            this.mRenderer.SetRenderTargetCubeMap( buffer.mTarget[dstID], face );
            this.Paint_Cubemap( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
        }
        this.mRenderer.SetRenderTargetCubeMap( null, 0 );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }
        cubeBuffers[bufferID].mLastRenderDone = 1 - cubeBuffers[bufferID].mLastRenderDone;

        this.mFrame++;
    }
}

EffectPass.prototype.StopOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;
    this.mPlayNode.disconnect();
}

EffectPass.prototype.ResumeOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;

    wa.resume()
    this.mPlayNode.connect( this.mGainNode );
}

EffectPass.prototype.StopOutput_Image = function( wa )
{
}

EffectPass.prototype.ResumeOutput_Image = function( wa )
{
}

EffectPass.prototype.StopOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.StopInput(j);

    if( this.mType==="sound" )
         this.StopOutput_Sound( wa );
    else
         this.StopOutput_Image( wa );
}

EffectPass.prototype.ResumeOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.ResumeInput(j);

    if( this.mType==="sound" )
         this.ResumeOutput_Sound( wa );
    else
         this.ResumeOutput_Image( wa );
}

EffectPass.prototype.GetCompilationTime = function()
{
    return this.mCompilationTime;
}

//============================================================================================================
function Screenshots()
{
    // private
    let mTexture = null;
    let mTarget = null;
    let mXres = 0;
    let mYres = 0;
    let mCubemapToEquirectProgram;
    let mRenderer = null;

    // public
    var me = {};

    me.Initialize = function(renderer)
    {
        mRenderer = renderer;
        let caps = mRenderer.GetCaps();
        let is20 = caps.mIsGL20;

        let vsSourceC, fsSourceC;
        if( is20 )
        {
            vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; out vec4 outColor; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); outColor = texture(t, rd); }";
        }
        else
        {
            vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); gl_FragColor = texture(t, rd); }";
        }

        let compileShader = function (worked, info)
        {
            if (worked === false)
            {
                console.log("Failed to compile cubemap resample shader (" + errorType + "): " + log);
            }
            else
            {
                mCubemapToEquirectProgram = info;
            }
        }
        mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, compileShader);

        return true;
    };

    me.Allocate = function( xres, yres )
    {
        if( xres>mXres || yres>mYres )
        {
            let texture = mRenderer.CreateTexture(mRenderer.TEXTYPE.T2D, xres, yres, mRenderer.TEXFMT.C4F32, mRenderer.FILTER.NONE, mRenderer.TEXWRP.CLAMP, null);
            let target = mRenderer.CreateRenderTarget( texture, null, null, null, null, false);

            if( mXres!==0 )
            {
                mRenderer.DestroyTexture(mTexture);
                mRenderer.DestroyRenderTarget(mTarget);
            }

            mTexture = texture;
            mTarget = target;
            mXres = xres;
            mYres = yres;
        }
    };

    me.GetProgram = function()
    {
        return mCubemapToEquirectProgram;
    };
    me.GetTarget = function()
    {
        return mTarget;
    };

    return me;
};

//============================================================================================================

function Effect(vr, ac, canvas, callback, obj, forceMuted, forcePaused, resizeCallback, crashCallback )
{
    let xres = canvas.width;
    let yres = canvas.height;

    let me = this;
    this.mCanvas = canvas;
    this.mCreated = false;
    this.mRenderer = null;
    this.mAudioContext = ac;
    this.mGLContext = null;
    this.mWebVR = vr;
    this.mRenderingStereo = false;
    this.mXres = xres;
    this.mYres = yres;
    this.mForceMuted = forceMuted;
    if( ac===null ) this.mForceMuted = true;
    this.mForcePaused = forcePaused;
    this.mGainNode = null;
    this.mPasses = [];
    this.mFrame = 0;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mMaxBuffers = 4;
    this.mMaxCubeBuffers = 1;
    this.mMaxPasses = this.mMaxBuffers + 1 + 1 + 1 + 1; // some day decouple passes from buffers (4 buffers + common + Imagen + sound + cubemap)
    this.mBuffers = [];
    this.mCubeBuffers = [];
    this.mScreenshotSytem = null;
    this.mCompilationTime = 0;
    this.mIsLowEnd = piIsMobile();

    this.mGLContext = piCreateGlContext(canvas, false, false, true, false); // need preserve-buffe to true in order to capture screenshots
    if (this.mGLContext === null)
    {
        return;
    }

    canvas.addEventListener("webglcontextlost", function (event)
        {
            event.preventDefault();
            crashCallback();
        }, false);

    this.mRenderer = piRenderer();
    if (!this.mRenderer.Initialize(this.mGLContext))
        return;

    this.mScreenshotSytem = Screenshots();
    if (!this.mScreenshotSytem.Initialize(this.mRenderer))
        return;

    var caps = this.mRenderer.GetCaps();
    this.mIs20 = caps.mIsGL20;
    this.mShaderTextureLOD = caps.mShaderTextureLOD;
    //-------------
    if( ac!==null )
    {   
        this.mGainNode = ac.createGain();
        if( !forceMuted )
        {
            this.mGainNode.connect( ac.destination);
        }
        if (this.mForceMuted )
            this.mGainNode.gain.value = 0.0;
        else
            this.mGainNode.gain.value = 1.0;
    }

    //-------------
    let vsSourceC, fsSourceC;
    if( this.mIs20 )
    {
        vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { outColor = textureLod(t, gl_FragCoord.xy / v.zw, 0.0); }";
    }
    else
    {
        vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; void main() { gl_FragColor = texture2D(t, gl_FragCoord.xy / v.zw, -100.0); }";
    }

    this.mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, function(worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to copy buffers : " + info.mErrorStr);
            else me.mProgramCopy = info;
        });

    let vsSourceD, fsSourceD;
    if( this.mIs20 )
    {
        vsSourceD = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { vec2 uv = gl_FragCoord.xy / v.zw; outColor = texture(t, vec2(uv.x,1.0-uv.y)); }";
    }
    else
    {
        vsSourceD = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; void main() { vec2 uv = gl_FragCoord.xy / v.zw; gl_FragColor = texture2D(t, vec2(uv.x,1.0-uv.y)); }";
    }

    this.mRenderer.CreateShader(vsSourceD, fsSourceD, false, true, function (worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to downscale buffers : " + info.mErrorStr);
            else me.mProgramDownscale = info;
        });


    // set all buffers and cubemaps to null
    for( let i=0; i<this.mMaxBuffers; i++ )
    {
        this.mBuffers[i] = { mTexture: [null, null], 
                             mTarget:  [null, null], 
                             mResolution: [0, 0],
                             mLastRenderDone: 0,
                             mThumbnailRenderTarget: null,
                             mThumbnailTexture: null,
                             mThumbnailBuffer:  null,
                             mThumbnailRes: [0, 0] };
    }

    for( let i=0; i<this.mMaxCubeBuffers; i++ )
    {
        this.mCubeBuffers[i] = { mTexture: [null, null], 
                                mTarget:  [null, null], 
                                mResolution: [0, 0],
                                mLastRenderDone: 0,
                                mThumbnailRenderTarget: null,
                                mThumbnailTexture: null,
                                mThumbnailBuffer:  null,
                                mThumbnailRes: [0, 0] };
    }

    //-------

    let keyboardData = new Uint8Array( 256*3 );
    for (let j=0; j<(256*3); j++ ) { keyboardData[j] = 0; }
    let kayboardTexture = this.mRenderer.CreateTexture( this.mRenderer.TEXTYPE.T2D, 256, 3, this.mRenderer.TEXFMT.C1I8, this.mRenderer.FILTER.NONE, this.mRenderer.TEXWRP.CLAMP, null);
    let keyboardImage = new Image();
    if( callback!==null )
        keyboardImage.src = "/img/keyboard.png"; // don't load PNG if no UI 
    this.mKeyboard = { mData: keyboardData, mTexture: kayboardTexture, mIcon: keyboardImage };

    let iResize = function( xres, yres )
    {
        me.mCanvas.width = xres;
        me.mCanvas.height = yres;
        me.mXres = xres;
        me.mYres = yres;
        me.ResizeBuffers(xres, yres);
        resizeCallback(xres, yres);
    };

    let bestAttemptFallback = function()
    {
        let devicePixelRatio = window.devicePixelRatio || 1;
        let xres = Math.round(me.mCanvas.offsetWidth  * devicePixelRatio) | 0;
        let yres = Math.round(me.mCanvas.offsetHeight * devicePixelRatio) | 0;
        iResize(xres, yres);
    };

    if(!window.ResizeObserver)
    {
        console.log("WARNING: This browser doesn't support ResizeObserver.");
        bestAttemptFallback();
        window.addEventListener("resize", bestAttemptFallback);
    }
    else
    {
        this.mRO = new ResizeObserver( function(entries, observer)
        {
            var entry = entries[0];
            if (!entry['devicePixelContentBoxSize'])
            {
                observer.unobserve(me.mCanvas);
                console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (2)");
                bestAttemptFallback();
                window.addEventListener("resize", bestAttemptFallback);
            }
            else
            {
                let box = entry.devicePixelContentBoxSize[0];
                let xres = box.inlineSize;
                let yres = box.blockSize;
                iResize(xres, yres);
            }
        });
        try
        {
            this.mRO.observe(this.mCanvas, { box: ["device-pixel-content-box"] });
            //this.mRO.observe(this.mCanvas);
        }
        catch (e)
        {
            console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (1)");
            bestAttemptFallback();
            window.addEventListener("resize", bestAttemptFallback);
        }
    }

    this.mCreated = true;
}

Effect.prototype.ResizeCubemapBuffer = function(i, xres, yres )
{
    let oldXres = this.mCubeBuffers[i].mResolution[0];
    let oldYres = this.mCubeBuffers[i].mResolution[1];

    if( this.mCubeBuffers[i].mTexture[0]===null || oldXres !== xres || oldYres !== yres )
    {
        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);
        let target1 = this.mRenderer.CreateRenderTargetCubeMap( texture1, null, false);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target2 = this.mRenderer.CreateRenderTargetCubeMap( texture2, null, false);

        // Store new buffers
        this.mCubeBuffers[i].mTexture = [texture1,texture2], 
        this.mCubeBuffers[i].mTarget =  [target1, target2 ], 
        this.mCubeBuffers[i].mLastRenderDone = 0;
        this.mCubeBuffers[i].mResolution[0] = xres;
        this.mCubeBuffers[i].mResolution[1] = yres;
    }
}

Effect.prototype.ResizeBuffer = function( i, xres, yres, skipIfNotExists )
{
    if( skipIfNotExists && this.mBuffers[i].mTexture[0]===null ) return;

    let oldXres = this.mBuffers[i].mResolution[0];
    let oldYres = this.mBuffers[i].mResolution[1];

    if( oldXres !== xres || oldYres !== yres )
    {
        let needCopy = (this.mBuffers[i].mTexture[0]!==null);

        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[0].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[0].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[1].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[1].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target1 = this.mRenderer.CreateRenderTarget( texture1, null, null, null, null, false);
        let target2 = this.mRenderer.CreateRenderTarget( texture2, null, null, null, null, false);

        if( needCopy )
        {
            let v = [0, 0, Math.min(xres, oldXres), Math.min(yres, oldYres)];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            let vOld = [0, 0, oldXres, oldYres];
            this.mRenderer.SetShaderConstant4FV("v", vOld);

            // Copy old buffers 1 to new buffer
            this.mRenderer.SetRenderTarget(target1);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[0], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Copy old buffers 2 to new buffer
            this.mRenderer.SetRenderTarget(target2);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[1], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Deallocate old memory
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[0]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[0]);
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[1]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[1]);
            //this.mRenderer.DestroyTexture(this.mBuffers[i].thumbnailTexture);
        }

        // Store new buffers
        this.mBuffers[i].mTexture = [texture1,texture2], 
        this.mBuffers[i].mTarget =  [target1, target2 ], 
        this.mBuffers[i].mLastRenderDone = 0;
        this.mBuffers[i].mResolution[0] = xres;
        this.mBuffers[i].mResolution[1] = yres;
    }
}

Effect.prototype.saveScreenshot = function(passid)
{
    let pass = this.mPasses[passid];

    if( pass.mType === "buffer" )
    {
        let bufferID = assetID_to_bufferID( this.mPasses[passid].mOutputs[0] );

        let texture = this.mBuffers[bufferID].mTarget[ this.mBuffers[bufferID].mLastRenderDone ];

        let numComponents = 3;
        let width = texture.mTex0.mXres;
        let height = texture.mTex0.mYres;
        let type = "Float"; // Other options Float, Half, Uint
        let bytes = new Float32Array(width * height * 4 );//numComponents);
        this.mRenderer.GetPixelDataRenderTarget( texture, bytes, width, height );
        let blob = piExportToEXR(width, height, numComponents, type, bytes);

        // Offer download automatically to the user
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "cubemap" )
    {
        let xres = 4096;
        let yres = 2048;
        this.mScreenshotSytem.Allocate( xres, yres );

        let cubeBuffer = this.mCubeBuffers[0];

        let target = this.mScreenshotSytem.GetTarget();
        this.mRenderer.SetRenderTarget( target );

        let program = this.mScreenshotSytem.GetProgram();

        this.mRenderer.AttachShader(program);
        let l1 = this.mRenderer.GetAttribLocation(program, "pos");
        this.mRenderer.SetViewport( [0, 0, xres, yres] );
        this.mRenderer.AttachTextures(1, cubeBuffer.mTexture[ cubeBuffer.mLastRenderDone ], null, null, null);
        this.mRenderer.DrawUnitQuad_XY(l1);
        this.mRenderer.DettachTextures();
        this.mRenderer.SetRenderTarget( null );

        let data = new Float32Array(xres*yres*4);
        this.mRenderer.GetPixelDataRenderTarget( target, data, xres, yres );

        let blob = piExportToEXR(xres, yres, 3, "Float", data );
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "sound" )
    {
        let offset = 0;
        const bits = 16;
        const numChannels = 2;
        let words = new Int16Array(60*pass.mSampleRate*numChannels );

        pass.iRenderSound( new Date(), function(off, data, numSamples)
                                         {
                                            for( let i=0; i<numSamples; i++ )
                                            {
                                                words[offset++] = (data[4*i+0]+256.0*data[4*i+1]) - 32767;
                                                words[offset++] = (data[4*i+2]+256.0*data[4*i+3]) - 32767;
                                            }
                                         }
                                     );

        let blob = piExportToWAV( 60*pass.mSampleRate, pass.mSampleRate, bits, numChannels, words);

        piTriggerDownload("sound.wav", blob);
    }    
}

Effect.prototype.ResizeBuffers = function(xres, yres)
{
    for (let i=0; i<this.mMaxBuffers; i++ )
    {
        this.ResizeBuffer(i, xres, yres, true);
    }
}

Effect.prototype.IsEnabledVR = function ()
{
    if (this.mRenderingStereo) return true;
    return false;
}

Effect.prototype.EnableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( this.mRenderingStereo ) return;

    this.mRenderingStereo = true;
    this.mWebVR.Enable();
}

Effect.prototype.DisableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( !this.mRenderingStereo ) return;

    this.mRenderingStereo = false;
    this.mWebVR.Disable();
}

Effect.prototype.GetTexture = function( passid, slot ) { return this.mPasses[passid].GetTexture( slot ); }
Effect.prototype.NewTexture = function (passid, slot, url) { return this.mPasses[passid].NewTexture( this.mAudioContext, slot, url, this.mBuffers, this.mCubeBuffers, this.mKeyboard ); }
Effect.prototype.SetOutputs = function( passid, slot, url ) { this.mPasses[passid].SetOutputs( slot, url ); }
Effect.prototype.SetOutputsByBufferID = function( passid, slot, id ) { this.mPasses[passid].SetOutputsByBufferID( slot, id ); }
Effect.prototype.GetAcceptsLinear = function (passid, slot) { return this.mPasses[passid].GetAcceptsLinear(slot); }
Effect.prototype.GetAcceptsMipmapping = function (passid, slot) { return this.mPasses[passid].GetAcceptsMipmapping(slot); }
Effect.prototype.GetAcceptsWrapRepeat = function (passid, slot) { return this.mPasses[passid].GetAcceptsWrapRepeat(slot); }
Effect.prototype.GetAcceptsVFlip = function (passid, slot) { return this.mPasses[passid].GetAcceptsVFlip(slot); }
Effect.prototype.SetSamplerFilter = function (passid, slot, str) { this.mPasses[passid].SetSamplerFilter(slot, str, this.mBuffers, this.mCubeBuffers); }
Effect.prototype.GetTranslatedShaderSource = function (passid) { return this.mPasses[passid].GetTranslatedShaderSource(); }
Effect.prototype.GetSamplerFilter = function (passid, slot) { return this.mPasses[passid].GetSamplerFilter(slot); }
Effect.prototype.SetSamplerWrap = function (passid, slot, str) { this.mPasses[passid].SetSamplerWrap(slot, str, this.mBuffers); }
Effect.prototype.GetSamplerWrap = function (passid, slot) { return this.mPasses[passid].GetSamplerWrap(slot); }
Effect.prototype.SetSamplerVFlip = function (passid, slot, str) { this.mPasses[passid].SetSamplerVFlip(slot, str); }
Effect.prototype.GetSamplerVFlip = function (passid, slot) { return this.mPasses[passid].GetSamplerVFlip(slot); }

Effect.prototype.GetHeaderSize = function (passid)
{
    return this.mPasses[passid].mHeaderLength + 
           this.mRenderer.GetShaderHeaderLines(1);
}

Effect.prototype.ToggleVolume = function()
{
    this.mForceMuted = !this.mForceMuted;

    // outp
    if (this.mForceMuted)
        this.mGainNode.gain.value = 0.0;
    else
        this.mGainNode.gain.value = 1.0;

    // inp
    let num = this.mPasses.length;
    for( let j=0; j<num; j++ )
    {
        for( let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            if( this.mForceMuted )
                this.mPasses[j].MuteInput( this.mAudioContext, i );
            else
                this.mPasses[j].UnMuteInput( this.mAudioContext, i );
        }
    }

    return this.mForceMuted;
}

Effect.prototype.SetKeyDown = function( passid, k )
{
    if( this.mKeyboard.mData[ k + 0*256 ] == 255 ) return;

    this.mKeyboard.mData[ k + 0*256 ] = 255;
    this.mKeyboard.mData[ k + 1*256 ] = 255;
    this.mKeyboard.mData[ k + 2*256 ] = 255 - this.mKeyboard.mData[ k + 2*256 ];
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }
}

Effect.prototype.SetKeyUp = function( passid, k )
{
    this.mKeyboard.mData[ k + 0*256 ] = 0;
    this.mKeyboard.mData[ k + 1*256 ] = 0;
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }
}

Effect.prototype.StopOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].StopOutput( wa );
    }
}

Effect.prototype.ResumeOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].ResumeOutput( wa );
    }
}

Effect.prototype.PauseInput = function( passid, id )
{
    return this.mPasses[passid].TooglePauseInput( this.mAudioContext, id );
}

Effect.prototype.ToggleMuteInput = function( passid, id )
{
    return this.mPasses[passid].ToggleMuteInput( this.mAudioContext, id );
}

Effect.prototype.RewindInput = function( passid, id )
{
    this.mPasses[passid].RewindInput( this.mAudioContext, id );
}

Effect.prototype.UpdateInputs = function( passid, forceUpdate )
{
   this.mPasses[passid].UpdateInputs( this.mAudioContext, forceUpdate, this.mKeyboard );
}

Effect.prototype.ResetTime = function()
{
    this.mFrame = 0;
    this.mAudioContext.resume()

    let num = this.mPasses.length;
    for( let i=0; i<num; i++ )
    {
        this.mPasses[i].mFrame = 0;
        for( let j=0; j<this.mPasses[i].mInputs.length; j++ )
            this.mPasses[i].RewindInput(this.mAudioContext, j)
    }
}

Effect.prototype.RequestAnimationFrame = function (id)
{
    if (this.mRenderingStereo && this.mWebVR.IsPresenting())
    {
        this.mWebVR.RequestAnimationFrame(id);
    }
    else
    {
        requestAnimFrame(id);
    }
}

Effect.prototype.Paint = function(time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, isPaused)
{
    let wa = this.mAudioContext;
    let da = new Date();
    let vrData = null; if (this.mRenderingStereo) vrData = this.mWebVR.GetData();
    let xres = this.mXres / 1;
    let yres = this.mYres / 1;

    if( this.mFrame===0 )
    {
        for( let i=0; i<this.mMaxBuffers; i++ )
        {
            if( this.mBuffers[i].mTexture[0]!==null )
            {
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[0] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[1] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
				
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[0] );
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[1] );
            }
        }
        for( let i=0; i<this.mMaxCubeBuffers; i++ )
        {
            if( this.mCubeBuffers[i].mTexture[0]!==null )
            {
                for( let face=0; face<6; face++ )
                {
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[0], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[1], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
					this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[0] );
				    this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[1] );
                }
            }
        }
    }

    let num = this.mPasses.length;

    // render sound first
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "sound" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "buffer" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;
        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="buffer" && inp.id === bufferID && inp.mInfo.mSampler.filter === "mipmap")
                {
                    needMipMaps = true;
                    break;
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render cubemap buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "cubemap" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = 0;//assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;

        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="cubemap" )
                {
                    if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0 && inp.mInfo.mSampler.filter === "mipmap" )
                    {
                        needMipMaps = true;
                        break;
                    }
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render image last
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "image" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }   

    // erase keypresses
    for (let k=0; k<256; k++ )
    {
       this.mKeyboard.mData[ k + 1*256 ] = 0;
    }
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    if( this.mRenderingStereo ) this.mWebVR.Finish();

    this.mFrame++;
}

Effect.prototype.NewShader = function( passid, preventCache, onResolve )
{
    let commonSourceCodes = [];
    for (let i=0; i<this.mPasses.length; i++ )
    {
        if( this.mPasses[i].mType==="common")
        {
            commonSourceCodes.push(this.mPasses[i].mSource);
        }
    }

    this.mPasses[passid].NewShader(commonSourceCodes, preventCache, onResolve );
}

Effect.prototype.GetNumPasses = function()
{
    return this.mPasses.length;
}

Effect.prototype.GetNumOfType = function(passtype)
{
    let id = 0;
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType===passtype )
        {
            id++;
        }
    }
    return id;
}

Effect.prototype.GetPassType = function( id ) { return this.mPasses[id].mType; }
Effect.prototype.GetPassName = function( id ) { return this.mPasses[id].mName; }
Effect.prototype.GetCode = function( id ) { return this.mPasses[id].mSource; }
Effect.prototype.SetCode = function( id, source ) { this.mPasses[id].SetCode(source); }
Effect.prototype.GetError = function (id) { return this.mPasses[id].mError; }
Effect.prototype.GetErrorStr = function (id) { return this.mPasses[id].mErrorStr; }
Effect.prototype.GetErrorGlobal = function()
{
    for (let i = 0; i < this.mPasses.length; i++)
    {
        if (this.mPasses[i].mError)
        {
            return true;
        }
    }
    return false;
}

Effect.prototype.Load = function (jobj )
{
    if (jobj.ver !== "0.1")
    {
        console.log("Wrong Format");
        return false;
    }

    let numPasses = jobj.renderpass.length;

    if( numPasses<1 || numPasses>this.mMaxPasses )
    {
        console.log("Corrupted Shader - " + numPasses);
        return false;
    }

    this.mPasses = [];
    for (let j = 0; j < numPasses; j++)
    {
        let rpass = jobj.renderpass[j];

        // skip sound passes if in thumbnail mode
        if( this.mForceMuted && rpass.type === "sound" ) continue;

        let wpass = new EffectPass(this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                   this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode,
                                   this.mProgramDownscale, j, this);

        wpass.Create(rpass.type, this.mAudioContext);

        let numInputs = rpass.inputs.length;

        for (let i = 0; i < 4; i++)
        {
            wpass.NewTexture(this.mAudioContext, i, null, null, null);
        }
        for (let i = 0; i < numInputs; i++)
        {
            let lid  = rpass.inputs[i].channel;
            let styp = rpass.inputs[i].type;
            let sid  = rpass.inputs[i].id;
            let ssrc = rpass.inputs[i].filepath;
            let psrc = rpass.inputs[i].previewfilepath;
            let samp = rpass.inputs[i].sampler;

            wpass.NewTexture(this.mAudioContext, lid, { mType: styp, mID: sid, mSrc: ssrc, mSampler: samp, mPreviewSrc: psrc }, this.mBuffers, this.mCubeBuffers, this.mKeyboard);
        }

        for (let i = 0; i < 4; i++)
        {
            wpass.SetOutputs(i, null);
        }

        let numOutputs = rpass.outputs.length;
        for (let i = 0; i < numOutputs; i++)
        {
            let outputID = rpass.outputs[i].id;
            let outputCH = rpass.outputs[i].channel;
            wpass.SetOutputs(outputCH, outputID);
        }

        // create some hardcoded names. This should come from the DB
        let rpassName = "";
        if (rpass.type === "common" ) rpassName = "Common";
        if (rpass.type === "sound"  ) rpassName = "Sound";
        if (rpass.type === "image"  ) rpassName = "Image";
        if (rpass.type === "buffer") rpassName = "Buffer " + String.fromCharCode(65 + assetID_to_bufferID(wpass.mOutputs[0]));
        if (rpass.type === "cubemap") rpassName = "Cube A";// " + String.fromCharCode(65 + assetID_to_bufferID(this.mPasses[j].mOutputs[0]));
        wpass.SetName(rpassName);
        wpass.SetCode(rpass.code);

        this.mPasses.push(wpass);
    }
    return true;
}

Effect.prototype.CompileSome = function ( passes, preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    for (let j = 0; j < passes.length; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(passes[j], preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < me.mPasses.length; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.Compile = function (preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(j, preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < numPasses; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.GetCompilationTime = function( id )
{
    return this.mPasses[id].GetCompilationTime()/1000.0;
}
Effect.prototype.GetTotalCompilationTime = function()
{
    return this.mCompilationTime/1000.0;
}

Effect.prototype.DestroyPass = function( id )
{
   this.mPasses[id].Destroy( this.mAudioContext );
   this.mPasses.splice(id, 1);
}

Effect.prototype.AddPass = function( passType, passName, onResolve )
{
    let shaderStr = null;

    if( passType==="sound"   ) shaderStr = "vec2 mainSound( int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n}";
    if( passType==="buffer"  ) shaderStr = "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}";
    if( passType==="common"  ) shaderStr = "vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}";
    if( passType==="cubemap" ) shaderStr = "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rayDir;\n\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}";

    let id = this.GetNumPasses();
    this.mPasses[id] = new EffectPass( this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                       this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode, 
                                       this.mProgramDownscale, id, this );

    this.mPasses[id].Create( passType, this.mAudioContext );
    this.mPasses[id].SetName( passName );
    this.mPasses[id].SetCode( shaderStr );
    this.NewShader(id, false, function ()
    {
        onResolve();
    });

    return { mId : id, mShader : shaderStr };
}

// this should be removed once we have MultiPass 2.0 and passes render to arbitrary buffers
Effect.prototype.IsBufferPassUsed = function( bufferID )
{
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType !== "buffer" ) continue;
        if( this.mPasses[j].mOutputs[0] === bufferID_to_assetID(bufferID) ) return true;
    }
    return false;
}

Effect.prototype.Save = function()
{
    var result = {};

    result.ver = "0.1";

    result.renderpass = [];

    let numPasses = this.mPasses.length;
    for (let j=0; j<numPasses; j++ )
    {
        result.renderpass[j] = {};

        result.renderpass[j].outputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            let outputID = this.mPasses[j].mOutputs[i];
            if( outputID===null ) continue;
            result.renderpass[j].outputs.push( { channel: i, id: outputID } );
        }
        result.renderpass[j].inputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            if( this.mPasses[j].mInputs[i]===null ) continue;
            result.renderpass[j].inputs.push( {channel: i,
                                               type    : this.mPasses[j].mInputs[i].mInfo.mType,
                                               id      : this.mPasses[j].mInputs[i].mInfo.mID,
                                               filepath: this.mPasses[j].mInputs[i].mInfo.mSrc,
                                               sampler : this.mPasses[j].mInputs[i].mInfo.mSampler });
        }

        result.renderpass[j].code = this.mPasses[j].mSource;
        result.renderpass[j].name = this.mPasses[j].mName
        result.renderpass[j].description = "";
        result.renderpass[j].type = this.mPasses[j].mType;
    }

    result.flags = this.calcFlags();

    return result;
}

Effect.prototype.calcFlags = function ()
{
    let flagVR = false;
    let flagWebcam = false;
    let flagSoundInput = false;
    let flagSoundOutput = false;
    let flagKeyboard = false;
    let flagMultipass = false;
    let flagMusicStream = false;

    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        let pass = this.mPasses[j];

        if (pass.mType === "sound") flagSoundOutput = true;
        if (pass.mType === "buffer") flagMultipass = true;

        for (let i = 0; i < 4; i++)
        {
            if (pass.mInputs[i] === null) continue;

            if (pass.mInputs[i].mInfo.mType === "webcam") flagWebcam = true;
            else if (pass.mInputs[i].mInfo.mType === "keyboard") flagKeyboard = true;
            else if (pass.mInputs[i].mInfo.mType === "mic") flagSoundInput = true;
            else if (pass.mInputs[i].mInfo.mType === "musicstream") flagMusicStream = true;
        }

        let n1 = pass.mSource.indexOf("mainVR(");
        let n2 = pass.mSource.indexOf("mainVR (");
        if (n1 > 0 || n2 > 0) flagVR = true;
    }

    return {
        mFlagVR: flagVR,
        mFlagWebcam: flagWebcam,
        mFlagSoundInput: flagSoundInput,
        mFlagSoundOutput: flagSoundOutput,
        mFlagKeyboard: flagKeyboard,
        mFlagMultipass: flagMultipass,
        mFlagMusicStream: flagMusicStream
    };
}</script>
    <script>"use strict"

const kMaxCompileTime = 10.0;

function iReportCrash(shaderID)
{
    let req = new XMLHttpRequest();
    req.onload = function ()
    {
        let jsn = req.response;
        if (jsn === null) return;
        if (jsn.result === 0)
        {
            // yep
        }
    };
    req.open("POST", "/shadertoy", true);
    req.responseType = "json";
    req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    req.send( "s=" + shaderID + "&r=2" );
}
</script>
    <script>"use strict"

var gActive = -1;
var mShaders = [];
var gNumCanvases = 0;

function myrefresh( id, slot, img, forceFrame, gui, guiID, renderID, time )
{
    if( mShaders[id].mReady===false ) return;
    if( forceFrame )
    {
        if (mShaders[id].mScreenshot === false)
        {
            mShaders[id].gEffect.Paint(mShaders[id].mTime / 1000.0, 1.0 / 60.0, 60.0, 0, 0, 0, 0, false);
        }
    }
}

function startRendering()
{
    if( gActive<0 ) return;
    if( mShaders[gActive].mReady===false ) return;
    if( mShaders[gActive].mScreenshot===true ) return;

    let time = getRealTime();

    mShaders[gActive].mFPS.Count( time );
    mShaders[gActive].mTime = mShaders[gActive].mTime0 + (time - mShaders[gActive].mTo);
    let dtime = 1000.0/60.0;
    mShaders[gActive].gEffect.Paint( mShaders[gActive].mTime/1000.0, dtime/1000.0, mShaders[gActive].mFPS.GetFPS(), 0,0,0,0, false);

    requestAnimFrame( startRendering );
}

function iLoadAndCompile(jsn, i )
{
    var shaderObj = jsn[i];
    if (shaderObj === null) return;

    var resizeCB = function (xres, yres) { myrefresh(i, 0, null, true, false, 0, -1.0) };
    var crashCB = function () { alert('crash');/*iReportCrash(gShaderIDs[i])*/ };
    mShaders[i].gEffect = new Effect(null, null, mShaders[i].mPreview.mCanvas, myrefresh, i, true, true, resizeCB, crashCB);

    if (!mShaders[i].gEffect.Load(shaderObj)) return;

    mShaders[i].gEffect.Compile(false, function (worked)
    {
        if (worked === true)
        {
            previewShowRender(mShaders[i].mPreview);

            mShaders[i].mScreenshot = false;
            mShaders[i].mReady = true;
            mShaders[i].mTime = 10.0 * 1000.0;
            mShaders[i].mTime0 = 0.0;
            mShaders[i].mTo = 0.0;
            mShaders[i].mFPS = piCreateFPSCounter();
            mShaders[i].mPreview.mCanvas.addEventListener("mouseout", function (ev) { gActive = -1; }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseover", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.add('isVisible'); }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseout", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.remove('isVisible'); }, true);
            mShaders[i].mPreview.mCanvas.addEventListener("mouseover", function (ev)
            {
                let ele = piGetSourceElement(ev);
                if (ele.mId === undefined) return;

                gActive = ele.mId;
                if (!mShaders[gActive].mReady) return;
                let time = getRealTime();
                mShaders[gActive].mTo = time;
                mShaders[gActive].mTime0 = mShaders[gActive].mTime;
                mShaders[gActive].mFPS.Reset(time);

                startRendering();
            }, true);


            /*
            let compilationTime = mShaders[i].gEffect.GetTotalCompilationTime();
            if (compilationTime > kMaxCompileTime)
            {
                iReportCrash(mShaders[i].mShaderID);
            }*/

            myrefresh(i, null, null, true, false, 0, -1.0);
        }
        else
        {
            mShaders[i].mReady = false;
            previewShowError(mShaders[i].mPreview);
        }
    });
};


function iProcessShader( jsn, i )
{
    var shaderObj = jsn[i];
    if( shaderObj===null ) return;

    if ((shaderObj.info.usePreview === 0 && !gUseScreenshots) || (mShaders[i].mPreviewReady !== 1))
    {
        iLoadAndCompile(jsn, i);
    }
    else
    {
        mShaders[i].mScreenshot = true;
        if( shaderObj.info.usePreview === 1 )
            previewShowScreenshot(mShaders[i].mPreview, 1); // comp
        else if (gUseScreenshots)
            previewShowScreenshot(mShaders[i].mPreview, 2); // sett
    }

    if( i<(jsn.length-1) ) setTimeout( function(){iProcessShader(jsn,i+1);}, 10 );
}

function iInitUI(numCanvases, uiCallback, windowTitle)
{
    gNumCanvases = numCanvases;
    document.getElementById("mySearch").focus();

    //-----------------------------------------------------------------
    // window
    //-----------------------------------------------------------------
    if (windowTitle !== null) {
        document.title = windowTitle;
    }

    //-----------------------------------------------------------------
    // ui
    //-----------------------------------------------------------------
    var num = Math.min(gShaders.length, gNumCanvases);

    //var base = document.getElementsByClassName( "searchResult" );

    for (let i = 0; i < gNumCanvases; i++)
    {
        let pv = createPreview(i);

        if (i >= num) {
            previewHide(pv);
            continue;
        }

        let shaderID = gShaders[i].info.id;
        
        if (pv.mUI !== null && uiCallback !== null) {
            pv.mUI.addEventListener('click', function (ev) {
                uiCallback(shaderID);
                ev.preventDefault();
            }, false);
        }
        
        previewShowLoading(pv);
        
        mShaders[i] = {};
        mShaders[i].mShaderID = shaderID;
        mShaders[i].mPreview = pv;
        mShaders[i].mScreenshot = false;
        mShaders[i].mPreview.mLink.href = "/view/" + shaderID;
        mShaders[i].mPreviewReady = 0;
        mShaders[i].mReady = false;
        mShaders[i].gEffect = null;

        previewLoadScreenshot(mShaders[i].mPreview,
            function () { mShaders[i].mPreviewReady = 1; if (mShaders[i].mReady === false) previewShowScreenshot(mShaders[i].mPreview, 0); },
            function () { mShaders[i].mPreviewReady = 2; },
            shaderID);
    }

    if (num <= 0) {
        return;
    }
}

function iInitShaders(jsn)
{
    for (let i = 0; i < jsn.length; i++)
    {
        let shaderObj = jsn[i];
        if (shaderObj === null) continue;
        let inf = shaderObj.info;
        mShaders[i].mPreview.mTextA.textContent = inf.name;
        mShaders[i].mPreview.mTextB.innerHTML = "<a class='user' href='/user/" + htmlEntities(inf.username) + "'>" + htmlEntities(inf.username) + "</a>";
        mShaders[i].mPreview.mTextC.innerHTML = "<img src='/img/themes/" + gThemeName + "/views.png' class='viewsIcon'></img>" + inf.viewed + "    &nbsp;&nbsp;  <img src='/img/themes/" + gThemeName + "/likes.png' class='likesIcon'></img>" + inf.likes;
    }

    setTimeout(function () { iProcessShader(jsn, 0); }, 10);
}

function resultsInitStatic(numCanvases, uiCallback, windowTitle)
{
    iInitUI(numCanvases, uiCallback, windowTitle);

    iInitShaders(gShaders);
}

function resultsInit(numCanvases, uiCallback, windowTitle)
{	
    iInitUI(numCanvases, uiCallback, windowTitle);

    var num = Math.min(gShaderIDs.length, gNumCanvases);

    var mHttpReq = new XMLHttpRequest();

    mHttpReq.abort();

    var str = "{ \"shaders\" : [";
    for( let i=0; i<num; i++ )
    {
         str += "\"" + gShaderIDs[i] + "\"";
         if( i!==(num-1) ) str += ", ";
    }
    str += "] }";

    str = "s=" + encodeURIComponent( str ) + "&nt=0&nl=0&np=0";

    mHttpReq.open( "POST", "/shadertoy", true );
    mHttpReq.responseType = "json";
    mHttpReq.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    mHttpReq.onload = function ()
    {
        let jsn = this.response;
        if( jsn===null )
        {
            console.log( "Could not load shaders" );
            return;
        }

        iInitShaders(jsn);
    }
    mHttpReq.send( str );
}</script>
    <style>
    .shaderPreview
    {
    display: block;
    background-color: #000000;
    background-image: url("/img/loading.gif");
    background-repeat: no-repeat;
    background-position: center;
    padding: 0px;
    margin: 0px;
    border: 0px solid #000000;
    border-radius: 8px;
    width:100%;
    height:100%;
    position: absolute;
    overflow:hidden;
    }

    .previewInfo
    {
    width: 100%;
    left: 0px;
    top: 2px;
    position: relative;
    visibility: hidden;
    }

    .previewCanvas
    {
    left: 0px;
    top: 0px;
    padding: 0px;
    margin: 0px;
    position: absolute;
    cursor: pointer;
    width:100%;
    height:100%;
    border-radius: 8px;
    border: 0px solid #000000;
    backgroundColor: transparent;
visibility: hidden;
opacity:0;
transition: opacity 1.0s ease;
    }

    .previewText
    {
        text-overflow: ellipsis;
    white-space: nowrap;
    padding-right: 1px;
    }

    .previewTextUser
    {
    text-overflow: ellipsis;
    white-space: nowrap;
    padding-left: 3px;
    }

    .previewStats
    {
    padding-right: 1px;
    right: 0px;
    top: 0px;
    position: absolute;
    }

    .previewErrorContainer
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    visibility:hidden;
    }

    .previewErrorMessage
    {
    top:50%;
    position:absolute;
    width:100%;
    text-align:center;
    padding:0;
    margin:auto;
    color:#ff0000;
    font-size:2em;
    font-style:italic;
    }

    .previewNoGLContainter
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    position:absolute;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    pointer-events:none;
    visibility:hidden;
    font-size:2em;
    }

    .previewNoGLMessage
    {
    width:86%;
    height:90%;
    padding-left:7%;
    padding-right:7%;
    padding-top:10%;
    padding-bottom:0px;
    color:#ff0000;
    position:absolute;
    visibility:hidden;
    }

    .previewThumbnailContainer
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    visibility:hidden;
    border-radius:8px;
    border:0px solid #000000;
    }

    .previewThumbnailImage
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    border-radius:8px;
    border:0px solid #000000;
opacity: 0.0;
transition: opacity 1.0s ease;
    }

    .previewThumbnailIcon
    {
    width:64px;
    height:32px;
    left:0px;
    top:0px;
    padding:0px;
    padding-top:12px;
    margin:0px;
    position:absolute;
    color:#ffffff;
    background-color:#ff8020;
    font-weight:bold;
    border-radius:0px 0px 8px 0px;
    text-align:center;
    //visibility:hidden;
    }


    .previewUIContainter
    {
    display: block;
    right:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    //cursor:pointer;
    //pointer-events:none;
    //visibility:hidden;
    }
</style>

<script>
    function previewHide(me)
    {
    me.mBase.style.visibility = "hidden";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";
    }

    function previewShowRender(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "visible";
me.mCanvas.style.opacity = 1.0;
    me.mCanvas.style.borderRadius ="8px;";
//  me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    }

    function previewShowScreenshot(me, message)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "visible";
me.mThumbnailImg.style.opacity = 1.0;
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    me.mThumbnailWar1.style.visibility = (message===1)?"visible":"hidden";
    me.mThumbnailWar2.style.visibility = (message===2)?"visible":"hidden";
    }

    function previewShowLoading(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";

    me.mLink.style.visibility = "visible";
    me.mBase.style.backgroundColor = "#ff0000;"
    me.mCont.style.visibility = "visible";
    }

    function previewShowNoWebGL(me, shaderID)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "visible";
    me.mError.style.visibility = "visible";
    me.mThumbnailImgNoWebGL.onerror = function(ev) 
                                      { 
                                            me.mThumbnailImgNoWebGL.style.visibility="hidden"; 
                                            me.mMessageNoWebGL.style.visibility="visible"; 
                                      };
    me.mThumbnailImgNoWebGL.src = "/media/shaders/" + shaderID + ".jpg";
    }

    function previewShowError(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "visible";
    me.mCont.style.visibility = "visible";
    }

    function previewLoadScreenshot( me, cbSuccess, cbError, shaderID )
    {
    var url = "/media/shaders/" + shaderID + ".jpg";
    me.mThumbnailImg.onload = cbSuccess;
    me.mThumbnailImg.onerror = function(ev) { cbError(); };
    me.mThumbnailImg.src = url;
    }
        
    function createPreview(id)
    {
        var bar = document.getElementById( "Preview_"+id+"_Canvas" );
        bar.width = bar.offsetWidth;
        bar.height = bar.offsetHeight;
        bar.mId = id;

        return { mBase: document.getElementById( "Preview_"+id+"_Container" ),
        mLink: document.getElementById( "Preview_"+id+"_Link" ),
        mCanvas: bar,
        mCont: document.getElementById( "Preview_"+id+"_Info" ),
        mTextA: document.getElementById( "Preview_"+id+"_Text" ),
        mTextB: document.getElementById( "Preview_"+id+"_TextUser" ),
        mTextC: document.getElementById( "Preview_"+id+"_Stats" ),
        mNoWebGL: document.getElementById( "Preview_"+id+"_NoWebGL" ),
        mError: document.getElementById( "Preview_"+id+"_Error" ),
        mCanvas2D: document.getElementById( "Preview_"+id+"_Thumnail" ),
        mThumbnailImg: document.getElementById( "Preview_"+id+"_ThumnailImage" ),
        mThumbnailWar1: document.getElementById( "Preview_"+id+"_ThumnailWarning1" ),
        mThumbnailWar2: document.getElementById( "Preview_"+id+"_ThumnailWarning2" ),
        mThumbnailImgNoWebGL: document.getElementById( "Preview_"+id+"_ThumnailImageNoWebGL" ),
        mMessageNoWebGL: document.getElementById( "Preview_"+id+"_MessageNoWebGL"),
        mUI: document.getElementById( "Preview_"+id+"_UI" )
        };
    }
</script>

    <style>

    div#shaderGrid
    {
        width:100%;
        padding:0px;
        margin:0px;
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        grid-template-rows: repeat(3, 1fr);
        grid-column-gap: 64px;
        grid-row-gap: 24px;
    }
    .searchResult
    {
        margin: 0px;
        padding: 0px;
        width: 100%;
    }
    .searchResultContainer
    {
        width: 100%;
        padding-bottom:56.25%;
        height: 0;
        position: relative;
    }
    .navigation
    {
        display:flex;
        align-items:center;
    }
    div#navBottom
    {
        display:none;
        justify-content:center;
    }
    a.pageButtons, .pageButtonsCurrent
    {
        border-style: solid;
        border-width: 1px;
        border-color: #808080;
        text-align: center;
        vertical-align: middle;
        margin-left: 12px;
        display: inline-block;
        border-radius: 4px;
		font-weight:bold;
        cursor: pointer;
        padding-bottom:5px;
        padding-top:4px;
        padding-left: 8px;
        padding-right: 8px;
        margin:8px;
    }
    a.pageButtons
    {
        text-decoration: none;
        -moz-transition:    background-color 0.15s linear, color 0.15s linear;
        -webkit-transition: background-color 0.15s linear, color 0.15s linear;
        transition:         background-color 0.15s linear, color 0.15s linear;
    }
    a.pageButtons:hover
    {
      background-color:#808080;
      color : #ff8020;
    }
    .pageButtonsCurrent
    {
        background-color: #808080;
        color:#000000;
    }
    div#controls
    {
        width:100%;
        padding-top:16px;
        padding-bottom:16px;
        display:flex;
        justify-content:space-between; 
        flex-wrap:wrap;
    }
    div#controls > div
    {
        display:inline-flex;
    }
    .controlOptions
    {
        display:inline-block;
    }

    /* ----------------------- media resolutions ------------------------ */

    @media screen and (max-width:799px) 
    {
        div#shaderGrid  { grid-template-columns: 1fr; grid-template-rows: repeat(12, 1fr); grid-column-gap: 0px; grid-row-gap: 16px; }
        div#controls
        {
            width:100%;
            display:flex;
            justify-content:flex-start; 
            flex-wrap:wrap;
        }
        div#controls > div
        {
            display:inline-flex;
            width:100%;
            margin-left: 0px;
            margin-right: 0px;
            padding-bottom:16px;
        }
        div#navBottom
        {
            display: flex;
        }
    }
    
    </style>
    <script>
    var gShaders=[{"ver":"0.1","info":{"id":"ltfXDM","date":"1437023412","viewed":10334,"name":"A lonely diamond...","username":"Nrx","description":"Variation of my original [url=https:\/\/www.shadertoy.com\/view\/ldfXzn]Diamonds are Forever[\/url].\nUse the mouse (X axis) to change the shape.","likes":110,"published":3,"flags":0,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"\/media\/a\/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"\/media\/ap\/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Rendering parameters\n#define RAY_LENGTH_MAX\t\t20.0\n#define RAY_BOUNCE_MAX\t\t10\n#define RAY_STEP_MAX\t\t40\n#define COLOR\t\t\t\tvec3 (0.8, 0.8, 0.9)\n#define ALPHA\t\t\t\t0.9\n#define REFRACT_INDEX\t\tvec3 (2.407, 2.426, 2.451)\n#define LIGHT\t\t\t\tvec3 (1.0, 1.0, -1.0)\n#define AMBIENT\t\t\t\t0.2\n#define SPECULAR_POWER\t\t3.0\n#define SPECULAR_INTENSITY\t0.5\n\n\/\/ Math constants\n#define DELTA\t0.001\n#define PI\t\t3.14159265359\n\n\/\/ Rotation matrix\nmat3 mRotate (in vec3 angle) {\n\tfloat c = cos (angle.x);\n\tfloat s = sin (angle.x);\n\tmat3 rx = mat3 (1.0, 0.0, 0.0, 0.0, c, s, 0.0, -s, c);\n\n\tc = cos (angle.y);\n\ts = sin (angle.y);\n\tmat3 ry = mat3 (c, 0.0, -s, 0.0, 1.0, 0.0, s, 0.0, c);\n\n\tc = cos (angle.z);\n\ts = sin (angle.z);\n\tmat3 rz = mat3 (c, s, 0.0, -s, c, 0.0, 0.0, 0.0, 1.0);\n\n\treturn rz * ry * rx;\n}\n\n\/\/ Rotation matrix (rotation on the Y axis)\nvec3 vRotateY (in vec3 p, in float angle) {\n\tfloat c = cos (angle);\n\tfloat s = sin (angle);\n\treturn vec3 (c * p.x - s * p.z, p.y, c * p.z + s * p.x);\n}\n\n\/\/ Distance to the scene\nvec3 normalTopA = normalize (vec3 (0.0, 1.0, 1.4));\nvec3 normalTopB = normalize (vec3 (0.0, 1.0, 1.0));\nvec3 normalTopC = normalize (vec3 (0.0, 1.0, 0.5));\nvec3 normalBottomA = normalize (vec3 (0.0, -1.0, 1.0));\nvec3 normalBottomB = normalize (vec3 (0.0, -1.0, 1.6));\nfloat getDistance (in vec3 p) {\n\tp = mRotate (vec3 (iTime)) * p;\n\n\tfloat topCut = p.y - 1.0;\n\tfloat angleStep = PI \/ (iMouse.z < 0.5 ? 8.0 : 2.0 + floor (18.0 * iMouse.x \/ iResolution.x));\n\tfloat angle = angleStep * (0.5 + floor (atan (p.x, p.z) \/ angleStep));\n\tvec3 q = vRotateY (p, angle);\n\tfloat topA = dot (q, normalTopA) - 2.0;\n\tfloat topC = dot (q, normalTopC) - 1.5;\n\tfloat bottomA = dot (q, normalBottomA) - 1.7;\n\tq = vRotateY (p, -angleStep * 0.5);\n\tangle = angleStep * floor (atan (q.x, q.z) \/ angleStep);\n\tq = vRotateY (p, angle);\n\tfloat topB = dot (q, normalTopB) - 1.85;\n\tfloat bottomB = dot (q, normalBottomB) - 1.9;\n\n\treturn max (topCut, max (topA, max (topB, max (topC, max (bottomA, bottomB)))));\n}\n\n\/\/ Normal at a given point\nvec3 getNormal (in vec3 p) {\n\tconst vec2 h = vec2 (DELTA, -DELTA);\n\treturn normalize (\n\t\th.xxx * getDistance (p + h.xxx) +\n\t\th.xyy * getDistance (p + h.xyy) +\n\t\th.yxy * getDistance (p + h.yxy) +\n\t\th.yyx * getDistance (p + h.yyx)\n\t);\n}\n\n\/\/ Cast a ray for a given color channel (and its corresponding refraction index)\nvec3 lightDirection = normalize (LIGHT);\nfloat raycast (in vec3 origin, in vec3 direction, in vec4 normal, in float color, in vec3 channel) {\n\n\t\/\/ The ray continues...\n\tcolor *= 1.0 - ALPHA;\n\tfloat intensity = ALPHA;\n\tfloat distanceFactor = 1.0;\n\tfloat refractIndex = dot (REFRACT_INDEX, channel);\n\tfor (int rayBounce = 1; rayBounce < RAY_BOUNCE_MAX; ++rayBounce) {\n\n\t\t\/\/ Interface with the material\n\t\tvec3 refraction = refract (direction, normal.xyz, distanceFactor > 0.0 ? 1.0 \/ refractIndex : refractIndex);\n\t\tif (dot (refraction, refraction) < DELTA) {\n\t\t\tdirection = reflect (direction, normal.xyz);\n\t\t\torigin += direction * DELTA * 2.0;\n\t\t} else {\n\t\t\tdirection = refraction;\n\t\t\tdistanceFactor = -distanceFactor;\n\t\t}\n\n\t\t\/\/ Ray marching\n\t\tfloat dist = RAY_LENGTH_MAX;\n\t\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\t\tdist = distanceFactor * getDistance (origin);\n\t\t\tfloat distMin = max (dist, DELTA);\n\t\t\tnormal.w += distMin;\n\t\t\tif (dist < 0.0 || normal.w > RAY_LENGTH_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\torigin += direction * distMin;\n\t\t}\n\n\t\t\/\/ Check whether we hit something\n\t\tif (dist >= 0.0) {\n\t\t\tbreak;\n\t\t}\n\n\t\t\/\/ Get the normal\n\t\tnormal.xyz = distanceFactor * getNormal (origin);\n\n\t\t\/\/ Basic lighting\n\t\tif (distanceFactor > 0.0) {\n\t\t\tfloat relfectionDiffuse = max (0.0, dot (normal.xyz, lightDirection));\n\t\t\tfloat relfectionSpecular = pow (max (0.0, dot (reflect (direction, normal.xyz), lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\t\t\tfloat localColor = (AMBIENT + relfectionDiffuse) * dot (COLOR, channel) + relfectionSpecular;\n\t\t\tcolor += localColor * (1.0 - ALPHA) * intensity;\n\t\t\tintensity *= ALPHA;\n\t\t}\n\t}\n\n\t\/\/ Get the background color\n\tfloat backColor = dot (texture (iChannel0, direction).rgb, channel);\n\n\t\/\/ Return the intensity of this color channel\n\treturn color + backColor * intensity;\n}\n\n\/\/ Main function\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t\/\/ Define the ray corresponding to this fragment\n\tvec2 frag = (2.0 * fragCoord.xy - iResolution.xy) \/ iResolution.y;\n\tvec3 direction = normalize (vec3 (frag, 2.0));\n\n\t\/\/ Set the camera\n\tvec3 origin = 7.0 * vec3 ((cos (iTime * 0.1)), sin (iTime * 0.2), sin (iTime * 0.1));\n\tvec3 forward = -origin;\n\tvec3 up = vec3 (sin (iTime * 0.3), 2.0, 0.0);\n\tmat3 rotation;\n\trotation [2] = normalize (forward);\n\trotation [0] = normalize (cross (up, forward));\n\trotation [1] = cross (rotation [2], rotation [0]);\n\tdirection = rotation * direction;\n\n\t\/\/ Cast the initial ray\n\tvec4 normal = vec4 (0.0);\n\tfloat dist = RAY_LENGTH_MAX;\n\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\tdist = getDistance (origin);\n\t\tfloat distMin = max (dist, DELTA);\n\t\tnormal.w += distMin;\n\t\tif (dist < 0.0 || normal.w > RAY_LENGTH_MAX) {\n\t\t\tbreak;\n\t\t}\n\t\torigin += direction * distMin;\n\t}\n\n\t\/\/ Check whether we hit something\n\tif (dist >= 0.0) {\n\t\tfragColor.rgb = texture (iChannel0, direction).rgb;\n\t} else {\n\n\t\t\/\/ Get the normal\n\t\tnormal.xyz = getNormal (origin);\n\n\t\t\/\/ Basic lighting\n\t\tfloat relfectionDiffuse = max (0.0, dot (normal.xyz, lightDirection));\n\t\tfloat relfectionSpecular = pow (max (0.0, dot (reflect (direction, normal.xyz), lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\t\tfragColor.rgb = (AMBIENT + relfectionDiffuse) * COLOR + relfectionSpecular;\n\n\t\t\/\/ Cast a ray for each color channel\n\t\tfragColor.r = raycast (origin, direction, normal, fragColor.r, vec3 (1.0, 0.0, 0.0));\n\t\tfragColor.g = raycast (origin, direction, normal, fragColor.g, vec3 (0.0, 1.0, 0.0));\n\t\tfragColor.b = raycast (origin, direction, normal, fragColor.b, vec3 (0.0, 0.0, 1.0));\n\t}\n\n\t\/\/ Set the alpha channel\n\tfragColor.a = 1.0;\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4s2GRR","date":"1382693934","viewed":10306,"name":"Fisheye \/ antifisheye","username":"SanchYESS","description":"Input parameter: \"power\", output effect: fisheye or fisheye correction of input texture. Should work with different proportions.\nOrigins from http:\/\/stackoverflow.com\/questions\/6030814\/add-fisheye-effect-to-images-at-runtime-using-opengl-es","likes":65,"published":1,"flags":0,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"\/media\/a\/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"\/media\/ap\/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\/\/Inspired by http:\/\/stackoverflow.com\/questions\/6030814\/add-fisheye-effect-to-images-at-runtime-using-opengl-es\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\/\/Drag mouse over rendering area\n{\n\tvec2 p = fragCoord.xy \/ iResolution.x;\/\/normalized coords with some cheat\n\t                                                         \/\/(assume 1:1 prop)\n\tfloat prop = iResolution.x \/ iResolution.y;\/\/screen proroption\n\tvec2 m = vec2(0.5, 0.5 \/ prop);\/\/center coords\n\tvec2 d = p - m;\/\/vector from center to current fragment\n\tfloat r = sqrt(dot(d, d)); \/\/ distance of pixel from center\n\n\tfloat power = ( 2.0 * 3.141592 \/ (2.0 * sqrt(dot(m, m))) ) *\n\t\t\t\t(iMouse.x \/ iResolution.x - 0.5);\/\/amount of effect\n\n\tfloat bind;\/\/radius of 1:1 effect\n\tif (power > 0.0) bind = sqrt(dot(m, m));\/\/stick to corners\n\telse {if (prop < 1.0) bind = m.x; else bind = m.y;}\/\/stick to borders\n\n\t\/\/Weird formulas\n\tvec2 uv;\n\tif (power > 0.0)\/\/fisheye\n\t\tuv = m + normalize(d) * tan(r * power) * bind \/ tan( bind * power);\n\telse if (power < 0.0)\/\/antifisheye\n\t\tuv = m + normalize(d) * atan(r * -power * 10.0) * bind \/ atan(-power * bind * 10.0);\n\telse uv = p;\/\/no effect for power = 1.0\n\n\tvec3 col = texture(iChannel0, vec2(uv.x, -uv.y * prop)).xyz;\/\/Second part of cheat\n\t                                                  \/\/for round effect, not elliptical\n\tfragColor = vec4(col, 1.0);\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"XtdSDn","date":"1485002732","viewed":10266,"name":"SmoothLife(L) ","username":"chronos","description":"SmoothLife by Stephan Rafler, a continuous analog of Conway's Game of Life.\nMy favorite cellular automaton \/ reaction diffusion like system, due the continuous rules and emergent behavior:\nfrequent gliders, connective ribbons which contract, etc.","likes":144,"published":1,"flags":48,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 CellColor = vec3(0.2, 0.2, 0.2);\nconst vec3 RingColor = vec3(0.0, 0.2, 0.2);\nconst vec3 DiskColor = vec3(0.0, 0.0, 0.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    \n    vec4 buffer = texture(iChannel0, uv);\n    \n    vec3 color = 1.0*(buffer.x * CellColor + buffer.y * RingColor + buffer.z * DiskColor);\n    \n    float c = 1.0 - buffer.z;\n    float c2 = 1. - texture(iChannel0, uv + .5\/iResolution.xy).y;\n    color += vec3(.6, .85, 1.)*max(c2*c2 - c*c, 0.)*4.;\n    \n    \n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"\/presets\/tex00.jpg","previewfilepath":"\/presets\/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"\/media\/a\/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"\/media\/ap\/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\/\/Conventions:\n\/\/ x component = outer radius \/ ring\n\/\/ y component = inner radius \/ disk\n\/*\n   _\n \/   \\\n|  O  |\n \\ _ \/\n*\/\nconst float PI = 3.14159265;\nconst float dt = 0.30;\n\n\nconst vec2 r = vec2(10.0, 3.0);\n\n\/\/ SmoothLifeL rules\nconst float b1 = 0.257;\nconst float b2 = 0.336;\nconst float d1 = 0.365;\nconst float d2 = 0.549;\n\nconst float alpha_n = 0.028;\nconst float alpha_m = 0.147;\n\/*------------------------------*\/\n\n\/\/const float KEY_LEFT  = 37.5\/256.0;\nconst float KEY_UP    = 38.5\/256.0;\n\/\/const float KEY_RIGHT = 39.5\/256.0;\nconst float KEY_DOWN  = 40.5\/256.0;\nconst float KEY_SPACE  = 32.5\/256.0;\n\n\n\/\/ 1 out, 3 in... <https:\/\/www.shadertoy.com\/view\/4djSRW>\n#define MOD3 vec3(.1031,.11369,.13787)\nfloat hash13(vec3 p3) {\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.x + p3.y)*p3.z);\n}\n\n\n\/* ---------------- Sigmoid functions ------------------------------------ *\/\n\n\/\/ TODO: reduce unnecessary parameters (remove arguments, use global consts)\n\nfloat sigmoid_a(float x, float a, float b) {\n    return 1.0 \/ (1.0 + exp(-(x - a) * 4.0 \/ b));\n}\n\n\/\/ unnecessary \nfloat sigmoid_b(float x, float b, float eb) {\n    return 1.0 - sigmoid_a(x, b, eb);\n}\n\nfloat sigmoid_ab(float x, float a, float b, float ea, float eb) {\n    return sigmoid_a(x, a, ea) * sigmoid_b(x, b, eb);\n}\n\nfloat sigmoid_mix(float x, float y, float m, float em) {\n    return x * (1.0 - sigmoid_a(m, 0.5, em)) + y * sigmoid_a(m, 0.5, em);\n}\n\n\/* ----------------------------------------------------------------------- *\/\n\n\/\/ SmoothLifeL\nfloat transition_function(vec2 disk_ring) {\n    return sigmoid_mix(sigmoid_ab(disk_ring.x, b1, b2, alpha_n, alpha_n),\n                       sigmoid_ab(disk_ring.x, d1, d2, alpha_n, alpha_n), disk_ring.y, alpha_m\n                      );\n}\n\n\/\/ unnecessary (?)\nfloat ramp_step(float steppos, float t) {\n    return clamp(t-steppos+0.5, 0.0, 1.0);\n}\n\n\/\/ unnecessary\nvec2 wrap(vec2 position) { return fract(position); }\n\n\/\/ Computes both inner and outer integrals\n\/\/ TODO: Optimize. Much redundant computation. Most expensive part of program.\nvec2 convolve(vec2 uv) {\n    vec2 result = vec2(0.0);\n    for (float dx = -r.x; dx <= r.x; dx++) {\n        for (float dy = -r.x; dy <= r.x; dy++) {\n            vec2 d = vec2(dx, dy);\n            float dist = length(d);\n            vec2 offset = d \/ iResolution.xy;\n            vec2 samplepos = wrap(uv + offset);\n            \/\/if(dist <= r.y + 1.0) {\n                float weight = texture(iChannel0, samplepos).x;\n            \tresult.x += weight * ramp_step(r.y, dist) * (1.0-ramp_step(r.x, dist));\t\n            \t\n            \/\/} else if(dist <= r.x + 1.) {\n                \/\/float weight = texture(iChannel0, uv+offset).x;\n\t\t\t\tresult.y += weight * (1.0-ramp_step(r.y, dist));\n            \/\/}\n        }\n    }\n    return result;\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0.0);\n    \n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n    \n    \/\/ Compute inner disk and outer ring area.\n    vec2 area = PI * r * r;\n    area.x -= area.y;\n    \/* -------------------------------------*\/\n    \n    \/\/ TODO: Cleanup.\n    color = texture(iChannel0, uv).xyz;\n    vec2 normalized_convolution = convolve(uv.xy).xy \/ area;\n    color.x = color.x + dt * (2.0 * transition_function(normalized_convolution) - 1.0);\n    color.yz = normalized_convolution;\n    color = clamp(color, 0.0, 1.0);\n    \n    \/\/ Set initial conditions. TODO: Move to function \/ cleanup\n    if(iFrame < 10 || texture( iChannel2, vec2(KEY_SPACE,0.5) ).x > 0.5) {\n        color = vec3(hash13(vec3(fragCoord, iFrame)) - texture(iChannel1, uv).x + 0.5);\n    }\n    \n    if(iMouse.z > 0.) {\n        \/\/vec2 dst = abs(uv - iMouse.xy\/iResolution.xy);\n        float dst = length((fragCoord.xy - iMouse.xy)\/iResolution.xx);\n        \/*if(max(dst.x * iResolution.x\/iResolution.y, dst.y) < 0.05) {\n        \tcolor = vec3(hash13(vec3(fragCoord, iFrame)) - texture(iChannel1, uv).x + 0.5);\n        }*\/\n        if(dst <= (r.x)\/iResolution.x) {\n        \tcolor.x = step((r.y+1.5)\/iResolution.x, dst) * (1.0 - step(r.x\/iResolution.x, dst));\n        }\n        \/*if(dst <= (r.x)\/iResolution.x) {\n        \tcolor.x = step((r.y+1.0)\/iResolution.x, dst) * (1.0 - step((r.x-0.5)\/iResolution.x, dst));\n        }*\/\n    }\n    \n    \/\/ Inspect transition function. TODO: Move to function \/ ifdef\n    if(texture( iChannel2, vec2(KEY_DOWN, 5.0\/3.0) ).x > 0.5) {\n        color = vec3(transition_function(uv));\n    }\n    \n    if(texture( iChannel2, vec2(KEY_UP, 0.5)).x > 0.5) {\n    \tcolor = vec3(0.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Buf A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"XlKSDR","date":"1483855619","viewed":10251,"name":"Physically-based SDF","username":"romainguy","description":"Signed distance fields, SH-indirect lighting, Cook-Torrance specular BRDF (GGX NDF\/Height-correlated Smith visibility term\/Schlick Fresnel), Burley diffuse BRDF (\"Disney\"), approximated ACES tone-mapping, fog","likes":177,"published":1,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define saturate(x) clamp(x, 0.0, 1.0)\n#define PI 3.14159265359\n\n\/\/------------------------------------------------------------------------------\n\/\/ Distance field functions\n\/\/------------------------------------------------------------------------------\n\nfloat sdPlane(in vec3 p) {\n    return p.y;\n}\n\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdTorus(in vec3 p, in vec2 t) {\n    return length(vec2(length(p.xz) - t.x, p.y)) - t.y;\n}\n\nvec2 opUnion(vec2 d1, vec2 d2) {\n    return d1.x < d2.x ? d1 : d2;\n}\n\nvec2 scene(in vec3 position) {\n    vec2 scene = opUnion(\n          vec2(sdPlane(position), 1.0),\n          vec2(sdSphere(position - vec3(0.0, 0.4, 0.0), 0.4), 12.0)\n    );\n    return scene;\n}\n\n\/\/------------------------------------------------------------------------------\n\/\/ Ray casting\n\/\/------------------------------------------------------------------------------\n\nfloat shadow(in vec3 origin, in vec3 direction) {\n    float hit = 1.0;\n    float t = 0.02;\n    \n    for (int i = 0; i < 1000; i++) {\n        float h = scene(origin + direction * t).x;\n        if (h < 0.001) return 0.0;\n        t += h;\n        hit = min(hit, 10.0 * h \/ t);\n        if (t >= 2.5) break;\n    }\n\n    return clamp(hit, 0.0, 1.0);\n}\n\nvec2 traceRay(in vec3 origin, in vec3 direction) {\n    float material = -1.0;\n\n    float t = 0.02;\n    \n    for (int i = 0; i < 1000; i++) {\n        vec2 hit = scene(origin + direction * t);\n        if (hit.x < 0.002 || t > 20.0) break;\n        t += hit.x;\n        material = hit.y;\n    }\n\n    if (t > 20.0) {\n        material = -1.0;\n    }\n\n    return vec2(t, material);\n}\n\nvec3 normal(in vec3 position) {\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          scene(position + epsilon.xyy).x - scene(position - epsilon.xyy).x,\n          scene(position + epsilon.yxy).x - scene(position - epsilon.yxy).x,\n          scene(position + epsilon.yyx).x - scene(position - epsilon.yyx).x);\n    return normalize(n);\n}\n\n\/\/------------------------------------------------------------------------------\n\/\/ BRDF\n\/\/------------------------------------------------------------------------------\n\nfloat pow5(float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat D_GGX(float linearRoughness, float NoH, const vec3 h) {\n    \/\/ Walter et al. 2007, \"Microfacet Models for Refraction through Rough Surfaces\"\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * linearRoughness;\n    float k = linearRoughness \/ (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 \/ PI);\n    return d;\n}\n\nfloat V_SmithGGXCorrelated(float linearRoughness, float NoV, float NoL) {\n    \/\/ Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    float a2 = linearRoughness * linearRoughness;\n    float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    return 0.5 \/ (GGXV + GGXL);\n}\n\nvec3 F_Schlick(const vec3 f0, float VoH) {\n    \/\/ Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"\n    return f0 + (vec3(1.0) - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    \/\/ Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 \/ PI);\n}\n\nfloat Fd_Lambert() {\n    return 1.0 \/ PI;\n}\n\n\/\/------------------------------------------------------------------------------\n\/\/ Indirect lighting\n\/\/------------------------------------------------------------------------------\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    \/\/ Irradiance from \"Ditch River\" IBL (http:\/\/www.hdrlabs.com\/sibl\/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    \/\/ Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\n\/\/------------------------------------------------------------------------------\n\/\/ Tone mapping and transfer functions\n\/\/------------------------------------------------------------------------------\n\nvec3 Tonemap_ACES(const vec3 x) {\n    \/\/ Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) \/ (x * (c * x + d) + e);\n}\n\nvec3 OECF_sRGBFast(const vec3 linear) {\n    return pow(linear, vec3(1.0 \/ 2.2));\n}\n\n\/\/------------------------------------------------------------------------------\n\/\/ Rendering\n\/\/------------------------------------------------------------------------------\n\nvec3 render(in vec3 origin, in vec3 direction, out float distance) {\n    \/\/ Sky gradient\n    vec3 color = vec3(0.65, 0.85, 1.0) + direction.y * 0.72;\n\n    \/\/ (distance, material)\n    vec2 hit = traceRay(origin, direction);\n    distance = hit.x;\n    float material = hit.y;\n\n    \/\/ We've hit something in the scene\n    if (material > 0.0) {\n        vec3 position = origin + distance * direction;\n\n        vec3 v = normalize(-direction);\n        vec3 n = normal(position);\n        vec3 l = normalize(vec3(0.6, 0.7, -0.7));\n        vec3 h = normalize(v + l);\n        vec3 r = normalize(reflect(direction, n));\n\n        float NoV = abs(dot(n, v)) + 1e-5;\n        float NoL = saturate(dot(n, l));\n        float NoH = saturate(dot(n, h));\n        float LoH = saturate(dot(l, h));\n\n        vec3 baseColor = vec3(0.0);\n        float roughness = 0.0;\n        float metallic = 0.0;\n\n        float intensity = 2.0;\n        float indirectIntensity = 0.64;\n\n        if (material < 4.0)  {\n            \/\/ Checkerboard floor\n            float f = mod(floor(6.0 * position.z) + floor(6.0 * position.x), 2.0);\n            baseColor = 0.4 + f * vec3(0.6);\n            roughness = 0.1;\n        } else if (material < 16.0) {\n            \/\/ Metallic objects\n            baseColor = vec3(0.3, 0.0, 0.0);\n            roughness = 0.2;\n        }\n\n        float linearRoughness = roughness * roughness;\n        vec3 diffuseColor = (1.0 - metallic) * baseColor.rgb;\n        vec3 f0 = 0.04 * (1.0 - metallic) + baseColor.rgb * metallic;\n\n        float attenuation = shadow(position, l);\n\n        \/\/ specular BRDF\n        float D = D_GGX(linearRoughness, NoH, h);\n        float V = V_SmithGGXCorrelated(linearRoughness, NoV, NoL);\n        vec3  F = F_Schlick(f0, LoH);\n        vec3 Fr = (D * V) * F;\n\n        \/\/ diffuse BRDF\n        vec3 Fd = diffuseColor * Fd_Burley(linearRoughness, NoV, NoL, LoH);\n\n        color = Fd + Fr;\n        color *= (intensity * attenuation * NoL) * vec3(0.98, 0.92, 0.89);\n\n        \/\/ diffuse indirect\n        vec3 indirectDiffuse = Irradiance_SphericalHarmonics(n) * Fd_Lambert();\n\n        vec2 indirectHit = traceRay(position, r);\n        vec3 indirectSpecular = vec3(0.65, 0.85, 1.0) + r.y * 0.72;\n        if (indirectHit.y > 0.0) {\n            if (indirectHit.y < 4.0)  {\n                vec3 indirectPosition = position + indirectHit.x * r;\n                \/\/ Checkerboard floor\n                float f = mod(floor(6.0 * indirectPosition.z) + floor(6.0 * indirectPosition.x), 2.0);\n                indirectSpecular = 0.4 + f * vec3(0.6);\n            } else if (indirectHit.y < 16.0) {\n                \/\/ Metallic objects\n                indirectSpecular = vec3(0.3, 0.0, 0.0);\n            }\n        }\n\n        \/\/ indirect contribution\n        vec2 dfg = PrefilteredDFG_Karis(roughness, NoV);\n        vec3 specularColor = f0 * dfg.x + dfg.y;\n        vec3 ibl = diffuseColor * indirectDiffuse + indirectSpecular * specularColor;\n\n        color += ibl * indirectIntensity;\n    }\n\n    return color;\n}\n\n\/\/------------------------------------------------------------------------------\n\/\/ Setup and execution\n\/\/------------------------------------------------------------------------------\n\nmat3 setCamera(in vec3 origin, in vec3 target, float rotation) {\n    vec3 forward = normalize(target - origin);\n    vec3 orientation = vec3(sin(rotation), cos(rotation), 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \/\/ Normalized coordinates\n    vec2 p = -1.0 + 2.0 * fragCoord.xy \/ iResolution.xy;\n    \/\/ Aspect ratio\n    p.x *= iResolution.x \/ iResolution.y;\n\n    \/\/ Camera position and \"look at\"\n    vec3 origin = vec3(0.0, 0.8, 0.0);\n    vec3 target = vec3(0.0);\n\n    origin.x += 1.7 * cos(iTime * 0.2);\n    origin.z += 1.7 * sin(iTime * 0.2);\n\n    mat3 toWorld = setCamera(origin, target, 0.0);\n    vec3 direction = toWorld * normalize(vec3(p.xy, 2.0));\n\n    \/\/ Render scene\n    float distance;\n    vec3 color = render(origin, direction, distance);\n\n    \/\/ Tone mapping\n    color = Tonemap_ACES(color);\n\n    \/\/ Exponential distance fog\n    color = mix(color, 0.8 * vec3(0.7, 0.8, 1.0), 1.0 - exp2(-0.011 * distance * distance));\n\n    \/\/ Gamma compression\n    color = OECF_sRGBFast(color);\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"Mt2XDD","date":"1443934432","viewed":10235,"name":"Flight over Bespin","username":"yamahabob","description":"My first published shader, which is borrowing heavily from other great works on this fantastic site.  I have no idea what I'm doing...","likes":97,"published":1,"flags":0,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\/\/ Flight over Bespin - yamahabob\n\/\/ Borrowed most of this code from inigo quilez et al\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define PI 3.141592654\n\n\/\/ General functions\n\nmat3 rx90 = mat3(1.0, 0.0, 0.0,\n\t\t\t     0.0, 0.0, 1.0,\n\t\t\t     0.0,-1.0, 0.0 );\nmat3 ry90 = mat3(0.0, 0.0,-1.0,\n\t\t\t     0.0, 1.0, 0.0, \n\t\t\t     1.0, 0.0, 0.0 );\nmat3 rz90 = mat3(0.0,-1.0, 0.0,\n\t\t\t     1.0, 0.0, 0.0, \n\t\t\t     0.0, 0.0, 1.0 );\n\nmat3 rotX( float a )\n{\n\treturn mat3(1.0,    0.0,    0.0,\n                0.0, cos(a),-sin(a),\n                0.0, sin(a), cos(a) );\n}\n\nmat3 rotY( float a )\n{\n\treturn mat3(cos(a), 0.0, sin(a),\n                   0.0, 1.0,    0.0, \n               -sin(a), 0.0, cos(a) );\n}\n\nmat3 rotZ( float a )\n{\n\treturn mat3(cos(a),-sin(a), 0.0,\n                sin(a), cos(a), 0.0,\n                   0.0,    0.0, 1.0 );\n}\n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\n\/\/ -------------------------------------\n\/\/ Cloud Calculations\n\/\/ (borrowed from iq)\n\/\/ -------------------------------------\n\n#define SPEED 5.\n\nfloat speed;\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\t\/\/f = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy + vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, 0.00390625*uv ).yx;\n\treturn 1.5*mix( rg.x, rg.y, f.z ) - 0.75;\n}\n\nfloat map5( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0)*speed;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q ); q = q*2.02;\n    f += 0.03125*noise( q );\n\treturn clamp( -p.y - 0.5 + 1.75*f, 0.0, 1.0 );\n}\n\nfloat map4( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0)*speed;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q );\n\treturn clamp( -p.y - 0.5 + 1.75*f, 0.0, 1.0 );\n}\nfloat map3( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0)*speed;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q );\n\treturn clamp( -p.y - 0.5 + 1.75*f, 0.0, 1.0 );\n}\nfloat map2( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0)*speed;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q );;\n\treturn clamp( -p.y - 0.5 + 1.75*f, 0.0, 1.0 );\n}\n\nvec3 sundir = normalize( vec3(-0.5,-0.1,-1.0) );\n\nvec4 integrate( in vec4 sum, in float dif, in float den, in vec3 bgcol, in float t )\n{\n    \/\/ lighting\n    vec3 lin = vec3(0.65,0.68,0.7)*1.2 + 0.5*vec3(0.7, 0.5, 0.3)*dif;        \n    vec4 col = vec4( mix( 1.15*vec3(1.0,0.95,0.8), vec3(0.65), den ), den );\n    col.xyz *= lin;\n    col.xyz = mix( col.xyz, bgcol, 1.0-exp(-0.004*t*t) );\n    \/\/ front to back blending    \n    col.a *= 0.4;\n    col.rgb *= col.a;\n    return sum + col*(1.0-sum.a);\n}\n\n#define MARCH(STEPS,MAPLOD) for(int i=0; i<STEPS; i++) { vec3  pos = ro + t*rd; if( pos.y<-3. || pos.y>1.2 || sum.a > 0.99 ) break; float den = MAPLOD( pos ); if( den>0.1 ) { float dif = clamp((den - MAPLOD(pos+0.5*sundir))*2., 0.0, 1.0 ); sum = integrate( sum, dif, den, bgcol, t ); } t += max(0.2,0.03*t); }\n\nvec4 raymarch( in vec3 ro, in vec3 rd, in vec3 bgcol )\n{\n\tvec4 sum = vec4(0.0);\n\n\tfloat t = 0.0;\n\n    MARCH(25,map4);\n    MARCH(20,map3);\n    MARCH(15,map2);\n    MARCH(15,map2);\n\n    return clamp( sum, 0.0, 1.0 );\n}\n\nmat3 lookat( vec3 fw, vec3 up ){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,normalize(up)));return mat3(rt,cross(rt,fw),fw);\n}\n\nmat3 setCamera( in vec3 fw )\n{\n\tvec3 cw = normalize( fw );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = vec3( -cw.z, 0.0, cw.x );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 cloudRender( in vec3 ro, in vec3 rd )\n{\n    \/\/ background sky     \n\tfloat sun = clamp( dot(sundir,rd), 0.0, 1.0 );\n\tvec3 col = 0.9*vec3(0.949,0.757,0.525) - rd.y*0.2*vec3(0.949,0.757,0.525);\/\/ + 0.15*0.5;\n\tcol += 0.8*vec3(1.0,.6,0.1)*pow( sun, 20.0 );\n\n    \/\/ clouds    \n    vec4 res = raymarch( ro, rd, col );\n    col = col*(1.0-res.w) + res.xyz;\n    \n    \/\/ sun glare    \n\tcol += 0.1*vec3(0.949,0.757,0.525)*pow( sun, 3.0 );\n\n    return col;\n}\n\n\n\/\/ =========== Ship Calculations ===========\n\nfloat time;\nvec3 shippos;\nmat3 shipltow;\nmat2 shiptilt;\n\n\/\/ the flight path\n\nvec3 shippath( float t )\n{\n    return vec3( 5.*sin( 0.9*t ), 2.5*sin( 0.6*t ), 0. );\n}\n\nvec3 shipvel( float t )\n{\n    return vec3( 5.*0.9*cos( 0.9*t ), 2.5*0.6*cos( 0.6*t ), 15. );\n}\n\nvec3 shipacc( float t )\n{\n    return vec3( -4.*0.9*0.9*sin( 0.9*(t)), -2.5*0.6*0.6*sin( 0.6*t ), 0. );\n}\n\n\n\/\/ distance functions for basic shapes\n\nfloat sdPlane( vec3 p, vec4 n ) { return dot(p,n.xyz) + n.w; }\n\nfloat sdSphere( vec3 p, float s ) { return length(p)-s; }\n\nfloat sdBox( vec3 p, vec3 b ) { vec3 d = abs(p) - b; return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)); }\n\nfloat sdHexPrism( vec3 p, vec2 h ) { vec3 q = abs(p); return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x); }\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) { vec3 pa = p-a, ba = b-a; return length( pa - ba*clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 )) - r; }\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*(r1-r2)\/h;\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat length8( vec3 d ) { vec3 q = pow( d, vec3(8.) ); return pow( q.x + q.y + q.z, 0.125 ); }\n\nfloat sdTorus82( vec3 p, vec2 t ) { vec2 q = vec2(length(p.xz)-t.x,p.y); return length8(vec3(q,0.))-t.y; }\n\nfloat sdCylinder( vec3 p, vec3 c ) { return length(p.xz-c.xy)-c.z; }\n\nfloat sdCappedCylinder( vec3 p, vec2 h ) { vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\nvec2 min2( vec2 d1, vec2 d2 ) { return ( d1.x < d2.x ) ? d1 : d2; }\n\nvec2 max2( vec2 d1, vec2 d2 ) { return ( d1.x > d2.x ) ? d1 : d2; }\n\nfloat smin( float a, float b, float k ) { float h = clamp( 0.5+0.5*(b-a)\/k, 0.0, 1.0 ); return mix( b, a, h ) - k*h*(1.0-h); }\n\nvec2 smin( vec2 a, vec2 b, float k ) { float h = clamp( 0.5+0.5*(b.x-a.x)\/k, 0.0, 1.0 ); return mix( b, a, h ) - k*h*(1.0-h); }\n\n\n\/\/ texture functions\n\nfloat noise( float s )\n{\n    vec2 uv = vec2( s, s );\n    return texture( iChannel0, uv ).x;\n}\n\nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x \/= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\n\/\/ plate texture\nfloat texPlates( vec2 uv )\n{\n    vec2 n = vec2( 10., 4. );\n    vec2 sec = floor( uv*n );\n    vec2 suv = uv*n - sec;\n    \n    float s1 = noise( 0.3*( uv.x + sec.y\/n.y ) );\n    float s2 = 0.3*s1+0.5;\n    float s3 = noise( 0.4*sec.y\/n.y );\n    float luma = 0.5*(1. - cubicPulse( s3, 0.03, suv.x )) + 0.5;\n    luma *= mix(1.0, s2, smoothstep(0.0, 1.0, suv.y));\n    luma *= 0.5*smoothstep( 0.0, 0.005*n.y, min( suv.y, 1.-suv.y)) + 0.5;\n\treturn clamp(luma, 0., 1.);\n}\n\n\/\/ circular hull texture\nvec3 texHull( vec3 p )\n{\n    vec2 uv;\n    uv.x = atan(p.z, p.x)\/PI;\n    float d = length(p.xz);\n    uv.y = 0.925 - 0.5*d;\n    vec3 shipCol1 = 0.9*vec3(0.729, 0.694, 0.627);\n    vec3 shipCol2 = 0.4*vec3(0.6, 0.537, 0.447);\n    return texPlates( uv ) * mix(shipCol1, shipCol2, cubicPulse( 0., 0.5, uv.x ));\n}\n\n\/\/ ship world to local transformation\n\nvec3 shipw2l( vec3 p )\n{\n    p.z = -p.z;\n    p = shipltow*(p - shippos);\n    p.zy *= shiptilt;\n\treturn p;\n}\n\n\/\/ ship distance evaluation where p is in world coords\n\nvec2 shipDE(vec3 p)\n{\n    float d1, d2, d3, d4;\n    p = shipw2l( p );\n    d1 = sdSphere( p, 3.3 ); \/\/ the bounding 'hit' sphere\n    if ( d1 > 0.2 ) return vec2( d1, 0. );\n\t\n    \/\/ main disk\n    vec3 q = p;\n    q.y = abs(q.y);\n\td1 = sdSphere( q + vec3( 0., 14.78, 0. ), 15. );\n    d1 = max( d1, sdSphere( q, 2. ));\n    d1 = max( -q.y + 0.06, d1 );\n\td2 = max(  q.y - 0.06, sdSphere( q, 1.95 ));\n    vec2 vres = vec2( min( d1, d2 ), 1.);\n    \n    \/\/ centre pylon\n  \tvres = smin( vres, vec2( sdCappedCylinder( p, vec2( 0.45, 0.28 )), 2.), 0.1);\n    \n    \/\/ front forks\n    q = p;\n    q.z = abs(q.z);\n    q += vec3(1.45, 0., -1.1);\n    float front = sdBox( q, vec3( 1.8, 0.09, 0.8 )); \/\/ front\n    vec3 norm = normalize(vec3(-1.1, 0.0, 2.3));\n    q = p;\n    q.z = abs(q.z);\n    float plane = sdPlane( q, vec4(-norm, 1.92) );\n    d1 = max( -plane, front );\n    vres = min2( vres, vec2( d1, 3. ));\n\t\n    \/\/ Z crossbar\n    d1 = sdHexPrism( p, vec2( 0.26, 2.0 ));\n  \td2 = sdBox( p, vec3( 0.8, 0.8, 0.6 ));\n    vres = min2( vres, vec2( max( -d2, d1 ), 4.));\n    \n    \/\/ X crossbar\n    q = p;\n    q.y = abs(q.y);\n    q = ry90 * rotZ(0.07) * q + vec3( 0., 0.02, -1.5);\n    vres = min2( vres, vec2( max( -abs(p.y) + 0.07, sdHexPrism( q, vec2(0.36, 0.9 ))), 5.));\n\n    \/\/ cockpit walkway\n    vec3 p1 = vec3(-0.8*sin(0.524), 0.1, -0.8*cos(0.524));\n    vec3 p2 = vec3(-2.1*sin(0.524), 0.07, -2.1*cos(0.524));\n    vec3 p3 = p2 + vec3(-0.2, 0., 0.);\n    vres = min2( vres, vec2( sdCapsule( p, p1, p2, 0.18 ), 6.));\n    vres = min2( vres, vec2( sdCapsule( p, p2, p3, 0.18 ), 6.1));\n\n    \/\/ cockpit\n    q = rz90*(p - p3 + vec3(0.2, 0., 0.));\n    vres = min2( vres, vec2( sdConeSection( q, 0.15, 0.18, 0.08), 7. ));\n    \n    \/\/ side cylinders\n    q = vec3( 0., 3.87, 0. );\n    q = mod( rx90 * p, q ) - 0.5*q;\n    vres = max2( vres, vec2( -sdTorus82( q, vec2( 0.26, 0.09 )), 8.));\n\n    \/\/ exhaust ports\n    p1 = vec3(0.75, 0., 0.);\n    p2 = vec3(0.45, 0., 0.);\n    q = p - p1;\n  \tvres = smin( vres, vec2( sdCappedCylinder( q, vec2( 0.14, 0.255 )), 9.), 0.044);\n    q -= p2;\n  \tvres = smin( vres, vec2( sdCappedCylinder( q, vec2( 0.14, 0.225 )), 9.), 0.044);\n\tq = p;\n    q.z = -abs(q.z); \/\/ reflect\n    q = rotY(0.45)*q - p1;\n    vres = smin( vres, vec2( sdCappedCylinder( q, vec2( 0.14, 0.255 )), 9.), 0.044);\n    q -= p2;\n    vres = smin( vres, vec2( sdCappedCylinder( q, vec2( 0.14, 0.225 )), 9.), 0.044);\n\n    \/\/ gun port\n    q = p + vec3(0.22, 0., 0.);\n  \tvres = min2( vres, vec2( sdCappedCylinder( q, vec2( 0.14, 0.32 )), 9.));\n    \n    \/\/ gun\n    p1 = vec3(-0.22, 0., 0.);\n    p2 = p1 + vec3( 0., 0.35, 0.0);\n    p3 = vec3(-0.22, 0.33, 0.03);\n    vec3 p4 = p3 + vec3(-0.25, 0.04, 0.);\n    vec3 p5 = vec3(0., 0.03, 0.);\n    q = p;\n    q.z = abs(q.z);\n    q.y = abs(q.y);\n    d1 = sdCapsule( q, p1, p2, 0.06 ); \/\/ gun pod\n    d1 = min( d1, sdCapsule( q, p3, p4, 0.01 )); \/\/ gun 1\n    d1 = min( d1, sdCapsule( q, p3 + p5, p4 + p5, 0.01 )); \/\/ gun 2\n    vres = min2( vres, vec2( d1, 10.));\n    \n    \/\/ upper dish\n    p1 = vec3( -1.1, 0.4, 0.83 );\n    p2 = p1 - vec3( -0.05, 0.0, 0.0 );\n    p3 = p2 - vec3( -0.1, 0.25, 0.0 );\n    q = p - p1;\n    d1 = sdSphere( q, 0.2 );\n   \tq = q + vec3( 0.75, -0.1, 0.0 );\n    d2 = sdSphere( q, 0.8 );\n\td3 = sdSphere( q, 0.81 );\n    d4 = sdCapsule( p, p2, p3, 0.03 );\n    vres = min2( vres, vec2( min( d4, max( d3, max( -d2, d1 ))), 10.));\n    \n    return vres;\n}\n\n\/\/ ray marching and rendering\n\nvec2 shipCastRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n\tconst float precis = 0.001;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = shipDE( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if ( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = shipDE( ro + rd*t ).x;\n        res = min( res, 8.0*h\/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    shipDE(pos+eps.xyy).x - shipDE(pos-eps.xyy).x,\n\t    shipDE(pos+eps.yxy).x - shipDE(pos-eps.yxy).x,\n\t    shipDE(pos+eps.yyx).x - shipDE(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)\/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = shipDE( aopos ).x;\n        occ -= (dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 shipRender( in vec3 ro, in vec3 rd, in vec3 col )\n{ \n    vec2 res = shipCastRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m >-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        vec2 uv = vec2(0.);\n        float luma = 0.;\n        \n        vec3 shipCol = 0.9*vec3(0.729, 0.694, 0.627);\/\/vec3(0.5, 0.45, 0.45);\n\n        vec3 q = shipw2l( pos );\n        bool isExhaust = false;\n        \n        if ( abs(q.y) < 0.06 && m < 3.5 )\n        {\n            if (q.x < 1.6)\n            \tcol = mix(vec3(0.1), shipCol, 0.5 * texture( iChannel0, 0.2*q.xy ).x);\n            else\n                isExhaust = true;\n        } else if ( m < 1.1 ) \/\/ main disk\n        {\n        \tcol = texHull( q );\n        } else if ( m < 2.1 ) \/\/ centre pylon\n        {\n            q = 1.5*(q + vec3(0.22, 0., 0.));\n\t\t\tuv.x = 0.5*(atan(q.z, q.x)\/PI);\n\t\t\tuv.y = 1. - length(q.xz);\n            luma = texPlates( uv );\n        \tcol = luma * shipCol;\n        } else if ( m < 3.1 ) \/\/ front forks\n        {\n            uv.x = 0.3*abs(q.z);\n            uv.y = 0.25*q.x+0.4;\n            luma = texPlates( uv );\n        \tcol = luma * shipCol;\n        } else if ( m < 4.1 ) \/\/ Z crossbar\n        {\n            uv.x = 0.5*q.x;\n            uv.y = -0.8*abs(q.z);\n            float luma = texPlates( uv );\n        \tcol = luma * shipCol;\n        } else if ( m < 5.1 ) \/\/ X crossbar\n        {\n            uv.x = 0.5*q.z;\n            uv.y = q.x;\n            if (abs(q.z) < 0.12 && abs(q.x) > 0.8 && abs(q.x) < 2.3)\n            {\n                uv.y *= 0.5;\n                col = shipCol * mix( 0.5, 1., 0.5 * texture( iChannel0, 0.2*uv ).x);\n            } else\n                col = shipCol * texPlates( uv );\n        } else if ( m < 6.6 ) \/\/ cockpit walkway\n        {\n            uv = rot(0.524)*q.xz;\n            uv.x = 0.5*uv.x;\n            uv.y = uv.y;\n            luma = texPlates( uv );\n        \tcol = luma * shipCol;\n        } else if ( m < 7.1 ) \/\/ cockpit\n        {\n            if ( q.y > 0.12 )\n        \t\tcol = vec3(0.03);\n            else\n                col = shipCol;\n        } else if ( m < 8.1 ) \/\/ side ports\n        {\n            col = shipCol;\n        } else if ( m < 9.9 ) \/\/ exhaust ports and gun port\n        {\n            col = vec3(0.05);\n        } else\n        {\n        \tcol = shipCol;\n        }\n\n        if ( isExhaust )\n        {\n            \/\/ ship exhaust\n            float blume = pow( clamp( dot(nor,-rd), 0.0, 1.0), 10. );\n            col = clamp( blume + vec3( 0.215, 0.945, 1. ) * (0.5 * cos( 80.*q.z ) + 0.5), 0., 1.);\n        } else\n        {\n            \/\/ ship hull lighting        \n            float occ = calcAO( pos, nor );\n            vec3  lig = sundir;\n            float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n            float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n            float dom = smoothstep( -0.1, 0.1, ref.y );\n            float fre = pow( clamp( 1.0+dot(nor,rd),0.0,1.0), 2.0 );\n            float spe = pow( clamp( dot( ref, lig ), 0.0, 1.0 ), 16.0 );\n\n            dif *= softshadow( pos, lig, 0.02, 2.5 );\n            dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n            vec3 brdf = vec3(0.0);\n            brdf += 1.20*dif*vec3(1.00,0.90,0.60);\n            brdf += 1.10*spe*vec3(1.00,0.90,0.60)*dif;\n            brdf += 0.30*amb*vec3(0.50,0.70,1.00)*occ;\n            brdf += 0.40*dom*vec3(0.50,0.70,1.00)*occ;\n            brdf += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n            brdf += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n            brdf += 0.02;\n            col = clamp(col*brdf, 0.0, 1.0);\n            \n            \/\/ Gamma correction\n\t\t\tcol = pow( col, vec3(0.4545) );\n        }\n    }\n\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy\/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x\/iResolution.y;\n\/\/    vec2 md = iMouse.xy\/iResolution.xy - 0.5;\n\n    \/\/ render clouds and sky\n    speed = iTime * SPEED;\n    vec3 ro = 4.0*normalize(vec3( 0.0, 0.3, 5.0));\n\tvec3 ta = vec3(0.0, -1.0, 0.0);\n    mat3 ca = setCamera( ta - ro );\n    vec3 rd = ca * normalize( vec3(p.xy,1.0) );\n    vec3 col = cloudRender( ro, rd );\n\n    \/\/ animate\n\ttime = iTime;\n\tshippos = shippath( time );\n    vec3 shipv = shipvel( time );\n    vec3 shipa = shipacc( time );\n\n\t\/\/ camera\t\n    \/\/ro = rotY(2.*PI*md.x) * rotX(-0.99*PI*md.y) * vec3( 0.0, 0.0, 9.);\n    ro = vec3( 0.0, 0.0, 5.*sin( 0.5*time ) + 13.);\n\t\n\t\/\/ camera-to-world transformation\n    ca = setCamera( ta - ro );\n    \n    \/\/ ship direction\n    shiptilt = rot( 0.4*shipa.x );\n    shipltow = ry90 * setCamera( -normalize( shipv ) );\n    \n    \/\/ ray direction\n\trd = ca * normalize( vec3(p.xy, 1.0) );\n\n    \/\/ render ship\n    col = shipRender( ro, rd, col );\n\n    fragColor = vec4(col, 1.);\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"Xs2cR1","date":"1494281883","viewed":10197,"name":"Super Shader GUI 98","username":"P_Malin","description":"Shadertoy UI framework.\nUI processing and UI data in Buf A. Values read and UI composited simply in image shader.\nData configuration and window layout logic at the end of Buf A.\nFor more example usage see: https:\/\/www.shadertoy.com\/view\/Msffzn","likes":168,"published":3,"flags":48,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"\/media\/a\/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"\/media\/ap\/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dfGRn","filepath":"\/media\/a\/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"\/media\/ap\/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"\/media\/a\/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"\/media\/ap\/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define iChannelUI iChannel0\n\nfloat UI_GetFloat( int iData )\n{\n    return texelFetch( iChannelUI, ivec2(iData,0), 0 ).x;\n}\n\nbool UI_GetBool( int iData )\n{\n    return UI_GetFloat( iData ) > 0.5;\n}\n\nvec3 UI_GetColor( int iData )\n{\n    return texelFetch( iChannelUI, ivec2(iData,0), 0 ).rgb;\n}\n\n\nvoid UI_Compose( vec2 fragCoord, inout vec3 vColor, out int windowId, out vec2 vWindowCoord, out float fShadow )\n{\n    vec4 vUISample = texelFetch( iChannelUI, ivec2(fragCoord), 0 );\n    \n    if ( fragCoord.y < 2.0 )\n    {\n        \/\/ Hide data\n        vUISample = vec4(1.0, 1.0, 1.0, 1.0);\n    }\n    \n    vColor.rgb = vColor.rgb * (1.0f - vUISample.w) + vUISample.rgb;    \n    \n    windowId = -1;\n    vWindowCoord = vec2(0);\n    \n    fShadow = 1.0f;\n    if ( vUISample.a < 0.0 )\n    {\n        vWindowCoord = vUISample.rg;\n        windowId = int(round(vUISample.b));\n        \n        fShadow = clamp( -vUISample.a - 1.0, 0.0, 1.0);\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vUV = fragCoord.xy \/ iResolution.xy;\n    vec3 vResult = UI_GetColor( DATA_BG_COLOR );\n\n    if ( UI_GetBool(DATA_BACKGROUND_IMAGE) )\n    {\n    \tvResult.rgb = textureLod( iChannel1, vUV * UI_GetFloat(DATA_BACKGROUND_SCALE), 0.0 ).rgb * UI_GetFloat( DATA_BACKGROUND_BRIGHTNESS );\n    }\n    \n    int windowId;\n    vec2 vWindowCoord;\n    float fShadow;\n    UI_Compose( fragCoord, vResult, windowId, vWindowCoord, fShadow );\n        \n    if ( windowId == IDC_WINDOW_IMAGEA )\n    {\n        vResult.rgb = texelFetch( iChannel2, ivec2(vWindowCoord.xy), 0 ).rgb * UI_GetFloat( DATA_IMAGE_BRIGHTNESS );\n\t    vResult *= fShadow;\n    }\n\n    if ( windowId == IDC_WINDOW_IMAGEB )\n    {\n        vResult.rgb = textureLod( iChannel3, vWindowCoord.xy, 0.0 ).rgb * UI_GetColor( DATA_IMAGE_COLOR );\n\t    vResult *= fShadow;\n    }\n        \n\tfragColor = vec4(vResult,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"\/presets\/tex00.jpg","previewfilepath":"\/presets\/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"\/media\/a\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"\/media\/ap\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ Super Shader GUI\n\/\/ https:\/\/www.shadertoy.com\/view\/Xs2cR1\n\/\/ Shadertoy UI framework - @P_Malin\n\n\/\/ Todo: \n\/\/ * window stacking order?\n\n#define iChannelUI \t\t\tiChannel0\n#define iChannelKeyboard \tiChannel1\n#define iChannelFont \t\tiChannel2\n\n#define SHADOW_TEST\n\n\/\/#define NEW_THEME\n\n#ifdef NEW_THEME\nvec3 cCheckboxOutline = vec3(0.4);\nvec3 cSliderLineCol = vec3(0.7);\nvec3 cSliderHandleOutlineCol = vec3(0.5);\nvec3 cButtonActive = vec3(0.6, 0.6, 0.9 );\nvec3 cButtonInactive = vec3( 0.5 );\nvec3 cWindowBorder = vec3(0.5, 0.5, 0.6 );\nvec3 cActiveWindowBorder = vec3(0.3, 0.3, 0.5 );\nvec3 cWindowBackgroundColor = vec3(0.9);\nconst vec3 cTitleBarA = vec3(0.7);\nconst vec3 cTitleBarB = cTitleBarA + 0.1;\nvec3 cTitleBarAActive = cTitleBarA + 0.05;\nvec3 cTitleBarBActive = cTitleBarB + 0.05; \nvec3 cWindowTitle = vec3(0.0);\nvec3 cResize = vec3( 0.7 );\nvec3 cResizeActive = vec3( 0.8 );\nvec3 cScrollPanelCorner = vec3(0.6);\nvec3 cScrollPanelCornerOutline = vec3(0.7);\n#else\nvec3 cWindowBackgroundColor = vec3(0.75);\nconst vec3 cTitleBarA = vec3(0.0, 0.0, 0.5);\nconst vec3 cTitleBarB = vec3(0.03, 0.5, 0.8);\nvec3 cTitleBarAActive = cTitleBarA + 0.1;\nvec3 cTitleBarBActive = cTitleBarB + 0.1; \nvec3 cWindowTitle = vec3(1.0);        \nvec3 cResize = vec3( 0.6 );\nvec3 cResizeActive = vec3( 0.8 );\nvec3 cScrollPanelCorner = vec3(0.7);\n#endif\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Data Storage\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec4 LoadVec4( sampler2D sampler, in ivec2 vAddr )\n{\n    return texelFetch( sampler, vAddr, 0 );\n}\n\nvec3 LoadVec3( sampler2D sampler, in ivec2 vAddr )\n{\n    return LoadVec4( sampler, vAddr ).xyz;\n}\n\nbool AtAddress( ivec2 p, ivec2 c ) { return all( equal( p, c ) ); }\n\nvoid StoreVec4( in ivec2 vAddr, in vec4 vValue, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in ivec2 vAddr, in vec3 vValue, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Rect\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nstruct Rect\n{\n    vec2 vPos;\n    vec2 vSize;\n};      \n\nbool Inside( vec2 vPos, vec2 vMin, vec2 vMax )\n{\n    return all( greaterThanEqual( vPos, vMin ) ) && all( lessThan( vPos, vMax ) );\n}\n\nbool Outside( vec2 vPos, vec2 vMin, vec2 vMax )\n{\n    return any( lessThan( vPos, vMin ) ) || any( greaterThanEqual( vPos, vMax ) );\n}\n\nbool Inside( vec2 vPos, Rect rect )\n{\n    return Inside( vPos, rect.vPos, rect.vPos + rect.vSize );\n}\n    \nbool Outside( vec2 vPos, Rect rect )\n{\n    return Outside( vPos, rect.vPos, rect.vPos + rect.vSize );\n}\n\nvoid RectExpand( inout Rect region, vec2 vPadding )\n{\n    \/\/ Padding\n    region.vPos -= vPadding;\n    region.vSize += vPadding * 2.0;        \n}\n\nvoid RectShrink( inout Rect region, vec2 vPadding )\n{\n    RectExpand( region, -vPadding);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Font\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ Font printing based on https:\/\/www.shadertoy.com\/view\/ldfcDr\n\n#define AUTO_FONT_SPACING\n\/\/#define HANDLE_EOL\n\/\/#define HANDLE_PRINT_STYLES\n\n\/\/ Font characters\nconst uint\n   \t\/\/ HTML Entity Names\n    \n    _SP = 0x20u,\t\t\/\/ ' '\n    _EXCL = 0x21u, \t\t\/\/ '!' \n    _QUOT = 0x22u, \t\t\/\/ '\"'\n    _NUM = 0x23u,  \t\t\/\/ '#'\n    _DOLLAR = 0x24u, \t\/\/ '$'\n    _PERCNT = 0x25u, \t\/\/ '%'\n    _AMP = 0x26u, \t\t\/\/ '&'\n    _APOS = 0x27u,\t\t\/\/ '''    \n    _LPAR = 0x28u, \t\t\/\/ '('\n    _RPAR= 0x29u, \t\t\/\/ ')'\n    _AST = 0x2Au,\t\t\/\/ '*'\n    _PLUS = 0x2Bu,\t\t\/\/ '+'\n    _COMMA = 0x2Cu,\t\t\/\/ ','    \n    _MINUS = 0x2Du,\t\t\/\/ '-'\n    _PERIOD = 0x2Eu,\t\/\/ '.'\n    _SOL = 0x2Fu,\t\t\/\/ '\/' \n\n    _0 = 0x30u, _1 = 0x31u, _2 = 0x32u, _3 = 0x33u, _4 = 0x34u, \n    _5 = 0x35u, _6 = 0x36u, _7 = 0x37u, _8 = 0x38u, _9 = 0x39u, \n\n    _COLON = 0x3Au,\t\t\/\/ ':' \n    _SEMI = 0x3Bu,\t\t\/\/ ';' \n    _LT = 0x3Cu,\t\t\/\/ '<' \n    _EQUALS = 0x3Du,\t\/\/ '=' \n    _GT = 0x3Eu,\t\t\/\/ '>' \n    _QUEST = 0x3Fu,\t\t\/\/ '?' \n    _COMAT = 0x40u,\t\t\/\/ '@' \n    \n    _A = 0x41u, _B = 0x42u, _C = 0x43u, _D = 0x44u, _E = 0x45u, \n    _F = 0x46u, _G = 0x47u, _H = 0x48u, _I = 0x49u, _J = 0x4Au,\n    _K = 0x4Bu, _L = 0x4Cu, _M = 0x4Du, _N = 0x4Eu, _O = 0x4Fu,\n    _P = 0x50u, _Q = 0x51u, _R = 0x52u, _S = 0x53u, _T = 0x54u,\n    _U = 0x55u, _V = 0x56u, _W = 0x57u, _X = 0x58u, _Y = 0x59u,\n    _Z = 0x5Au,\n\n    _LSQB = 0x5Bu,\t\t\/\/ '[' \n    _BSOL = 0x5Cu,\t\t\/\/ '\\'\n    _RSQB = 0x5Du,\t\t\/\/ ']' \n    _CIRC = 0x5Eu,\t\t\/\/ '^' \n    _LOWBAR = 0x5Fu,\t\/\/ '_' \n    _GRAVE = 0x60u,\t\t\/\/ '`' \n    \n    _a = 0x61u, _b = 0x62u, _c = 0x63u, _d = 0x64u, _e = 0x65u,\n    _f = 0x66u, _g = 0x67u, _h = 0x68u, _i = 0x69u, _j = 0x6Au,\n    _k = 0x6Bu, _l = 0x6Cu, _m = 0x6Du, _n = 0x6Eu, _o = 0x6Fu,\n    _p = 0x70u, _q = 0x71u, _r = 0x72u, _s = 0x73u, _t = 0x74u,\n    _u = 0x75u, _v = 0x76u, _w = 0x77u, _x = 0x78u, _y = 0x79u,\n    _z = 0x7Au\n\n\t,_LCUB = 0x7Bu\t\t\/\/ '{'\n    ,_VERBAR = 0x7Cu\t\/\/ '|'\n    ,_RCUB = 0x7Du\t\t\/\/ '}'\n    ,_TILDE = 0x7Eu\t\t\/\/ '~'\n    \n#ifdef HANDLE_EOL       \n    ,_EOL = 0x1000u \t\/\/ End of Line - Carriage Return & Line Feed    \n#endif    \n#ifdef HANDLE_PRINT_STYLES    \n    ,_BOLDON = 0x1001u\t\/\/ Special\n    ,_BOLDOFF = 0x1002u\t\/\/ Special\n    ,_ITALON = 0x1003u\t\/\/ Special\n    ,_ITALOFF = 0x1004u\t\/\/ Special    \n#endif    \n;\n\n\nvec4 SampleCharacterTex( uint iChar, vec2 vCharUV )\n{\n    uvec2 iChPos = uvec2( iChar % 16u, iChar \/ 16u );\n    vec2 vUV = (vec2(iChPos) + vCharUV) \/ 16.0f;\n    return textureLod( iChannelFont, vUV, 0.0 );\n}\n    \nvec4 SampleCharacter( uint iChar, vec2 vCharUV )\n{\n    uvec2 iChPos = uvec2( iChar % 16u, iChar \/ 16u );\n    vec2 vClampedCharUV = clamp(vCharUV, vec2(0.01), vec2(0.99));\n    vec2 vUV = (vec2(iChPos) + vClampedCharUV) \/ 16.0f;\n\n    vec4 vSample;\n    \n    float l = length( (vClampedCharUV - vCharUV) );\n\n    \/\/ Skip texture sample when not in character boundary\n    \/\/ Ok unless we have big font weight\n    if ( l > 0.01f )\n    {\n        vSample.rgb = vec3(0);\n\t\tvSample.w = 2000000.0; \n    }\n    else\n    {\n\t\tvSample = textureLod( iChannelFont, vUV, 0.0 );    \n        vSample.gb = vSample.gb * 2.0f - 1.0f;\n        vSample.a -= 0.5f + 1.0\/256.0;    \n    }\n        \n    return vSample;\n}\n\n\nstruct CharExtents\n{\n    float left;\n    float width;\n};\n    \n\/\/ Auto font spacing adapted from Klems shader: https:\/\/www.shadertoy.com\/view\/MsfyDN\nfloat CharVerticalPos(uint iChar, vec2 vUV) \n{\n    vec4 vSample = SampleCharacterTex(iChar, vUV);\n    float dist = vSample.a - (127.0\/255.0);\n    dist *= vSample.g * 2.0 - 1.0;\n    return vUV.x - dist;\n}\n\nCharExtents GetCharExtents( uint iChar )\n{\n    CharExtents result;\n\n    result.left = CharVerticalPos( iChar, vec2(0.02, 0.5) );\n    float right = CharVerticalPos( iChar, vec2(0.98, 0.5) );\n    result.width = right - result.left;\n    \n    if ( iChar == _SP )\n    {\n        result.left = 0.3f;\n        result.width = 0.4f;\n    }\n    return result;\n}\n\nstruct PrintState\n{\n    vec2 vPixelPos;\n    \n    vec2 vLayoutStart;\n    \/\/ print position\n    vec2 vCursorPos;\n    vec2 vPixelSize;\n\n#ifdef HANDLE_EOL\n    bool EOL;\n#endif\n\n    \/\/ result\n    float fDistance;\n};    \n\nvoid MoveTo( inout PrintState state, vec2 vPos )\n{\n    state.vLayoutStart = vPos;\n    state.vCursorPos = vPos;\n#ifdef HANDLE_EOL\n    state.EOL = false;\n#endif\n}\n\nvoid ClearPrintResult( inout PrintState state )\n{\n    state.fDistance = 1000000.0;   \n}\n\nPrintState PrintState_InitCanvas( vec2 vCoords, vec2 vPixelSize )\n{\n    PrintState state;\n    state.vPixelPos = vCoords;\n    state.vPixelSize = vPixelSize;\n    \n    MoveTo( state, vec2(0) );\n\n    ClearPrintResult( state );\n    \n    return state;\n}\n\nstruct LayoutStyle\n{\n    vec2 vSize;\n    float fLineGap;\n    float fAdvancement;\n#ifdef HANDLE_PRINT_STYLES    \n    bool bItalic;\n    bool bBold;  \n#endif    \n};\n    \nLayoutStyle LayoutStyle_Default()\n{\n    LayoutStyle style;\n    style.vSize = vec2(24.0f, 32.0f);    \n    style.fLineGap = 0.1f;\n    style.fAdvancement = 0.1f;\n#ifdef HANDLE_PRINT_STYLES    \n    style.bItalic = false;\n    style.bBold = false;       \n#endif    \n    return style;\n}\n\nstruct RenderStyle\n{\n    vec3 vFontColor;\n    float fFontWeight;   \n};\n\nRenderStyle RenderStyle_Default( vec3 vFontColor )\n{\n    RenderStyle style;\n    style.vFontColor = vFontColor;\n    style.fFontWeight = 0.0f;  \n    return style;\n}\n\nconst float g_fFontDescent = 0.15f;\nconst float g_fFontAscent = 0.65f;\n\nvoid PrintEndCurrentLine( inout PrintState state, const LayoutStyle style )\n{\n    \/\/ Apply CR\n    state.vCursorPos.x = state.vLayoutStart.x;\n    \n    \/\/ advance Y position to bottom of descender based on current font size.\n\tstate.vCursorPos.y += style.vSize.y * g_fFontDescent;    \n}\n\nvoid PrintBeginNextLine( inout PrintState state, const LayoutStyle style )\n{\n    \/\/ move Y position to baseline based on current font size\n\tstate.vCursorPos.y += style.vSize.y * (g_fFontAscent + style.fLineGap);\n}\n\n#ifdef HANDLE_EOL\nvoid PrintEOL( inout PrintState state, const LayoutStyle style )\n{\n    if ( state.EOL )\n    {\n        PrintBeginNextLine( state, style );\n    }\n    PrintEndCurrentLine( state, style );\n    state.EOL = true;\n}\n#endif\n\nvoid PrintCh( inout PrintState state, inout LayoutStyle style, const uint iChar )\n{\n#ifdef HANDLE_EOL\n    if ( iChar == _EOL )\n    {\n        PrintEOL( state, style );\n        return;\n    }\n    else\n#endif\n#ifdef HANDLE_PRINT_STYLES            \n    if ( iChar == _BOLDON )\n    {\n        style.bBold = true;\n        return;\n    }\n    else\n    if ( iChar == _BOLDOFF )\n    {\n        style.bBold = false;\n        return;\n    }\n    else\n    if ( iChar == _ITALON )\n    {\n        style.bItalic = true;\n        return;\n    }\n    else\n    if ( iChar == _ITALOFF )\n    {\n        style.bItalic = false;\n        return;\n    }\n#endif\n    \n#ifdef HANDLE_EOL\n    if ( state.EOL )\n    {\n        PrintBeginNextLine( state, style );\n\t\tstate.EOL = false;\n    }\n#endif\n    \n    vec2 vUV = ((state.vPixelPos - state.vCursorPos) \/ style.vSize);\n\n    \/*if ( (vUV.y > -0.1) && (vUV.y < 0.1) && (abs(vUV.x) < 0.02 || abs(vUV.x - CharWidth(iChar)) < 0.02) )\n    {\n        state.fDistance = -10.0;\n    }*\/\n    \n\tCharExtents extents = GetCharExtents( iChar );    \n    vUV.y += 0.8f; \/\/ Move baseline\n    vUV.x += extents.left - style.fAdvancement;\n    \n#ifdef HANDLE_PRINT_STYLES    \n    if ( style.bItalic )\n    {\n    \tvUV.x += (1.0 - vUV.y) * -0.4f;\n    }\n#endif\n    \n    vec3 v = SampleCharacter( iChar, vUV ).agb;\n\n#ifdef HANDLE_PRINT_STYLES    \n    if ( style.bBold )\n    {\n    \tv.x -= 0.025f;\n    }\n#endif    \n    \n    if ( v.x < state.fDistance )\n    {\n        state.fDistance = v.x;       \n    }\n    \n    state.vCursorPos.x += style.vSize.x * (extents.width + style.fAdvancement);\n}\n\n\nRect GetFontRect( PrintState state, LayoutStyle style, bool initialLineOffset )\n{\n    Rect rect;\n    \n    rect.vPos = state.vLayoutStart;\n    if ( initialLineOffset )\n    {\n    \trect.vPos.y += style.vSize.y * (style.fLineGap + g_fFontAscent);\n    }\n\trect.vPos.y -= style.vSize.y * (g_fFontAscent);\n    rect.vSize.x = state.vCursorPos.x - state.vLayoutStart.x;\n    rect.vSize.y = style.vSize.y * ( g_fFontAscent + g_fFontDescent );\n    \n    return rect;\n}\n\nfloat GetFontBlend( PrintState state, LayoutStyle style, float size )\n{\n    float fFeatherDist = 1.0f * length(state.vPixelSize \/ style.vSize);    \n    float f = clamp( (size-state.fDistance + fFeatherDist * 0.5f) \/ fFeatherDist, 0.0, 1.0);\n    return f;\n}\n\nvoid RenderFont( PrintState state, LayoutStyle style, RenderStyle renderStyle, inout vec3 color )\n{   \n    float f = GetFontBlend( state, style, renderStyle.fFontWeight );\n\n    vec3 vCol = renderStyle.vFontColor;\n    \n    color.rgb = mix( color.rgb, vCol, f);    \n}\n\n\/\/ Font print helpers\n\n#define NO_UNROLL(X) (X + min(0,iFrame))\n#define NO_UNROLLU(X) (X + uint(min(0,iFrame)))\n\n#define ARRAY_PRINT( STATE, STYLE, CHAR_ARRAY ) { for (int i=0; i< NO_UNROLL( CHAR_ARRAY.length() ); i++) PrintCh( STATE, STYLE, CHAR_ARRAY[i] ); }\n\nvoid Print( inout PrintState state, LayoutStyle style, uint value )\n{\n\tuint place = 1000000000u;\n\n    bool leadingZeros = true;\n    while( place > NO_UNROLLU( 0u ) )\n    {\n        uint digit = (value \/ place) % 10u;\n        if ( place == 1u || digit != 0u )\n        {\n            leadingZeros = false;\n        }\n        \n        if (!leadingZeros)\n        {\n            PrintCh( state, style, _0 + digit );\n        }\n        place = place \/ 10u;\n    }    \n}\n\nvoid Print( inout PrintState state, LayoutStyle style, int value )\n{\n    if ( value < 0 )\n    {\n        PrintCh( state, style, _MINUS );\n        value = -value;\n    }\n\n    Print ( state, style, uint(value) );    \n}\n\nvoid Print( inout PrintState state, LayoutStyle style, float value, int decimalPlaces )\n{\n    if ( value < 0.0f )\n    {\n        PrintCh( state, style, _MINUS );\n    }\n    value = abs(value);\n    \n    int placeIndex = 10;\n    \n    bool leadingZeros = true;\n    while( placeIndex >= NO_UNROLL( -decimalPlaces ) )\n    {\n        float place = pow(10.0f, float(placeIndex) );\n        float digitValue = floor( value \/ place );\n        value -= digitValue * place;\n        \n        \n        uint digit = min( uint( digitValue ), 9u );\n        \n        if ( placeIndex == -1 )\n        {\n            PrintCh( state, style, _PERIOD );\n        }\n        \n        if ( placeIndex == 0 || digit != 0u )\n        {\n            leadingZeros = false;\n        }        \n        \n        if ( !leadingZeros )\n        {\n        \tPrintCh( state, style, _0 + digit );\n        }\n                \n        placeIndex--;\n    }\n}\n\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ General 2d Drawing\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvoid DrawRect( vec2 vCanvasPos, Rect rect, vec4 vColor, inout vec4 vOutColor )\n{\n\tif ( Inside( vCanvasPos, rect ) )\n    {\n        vOutColor = vColor;\n    }\n}\n\nvoid DrawLine( vec2 vCanvasPos, vec2 vA, vec2 vB, float fThickness, vec4 vColor, inout vec4 vOutColor )\n{\n    vec2 vDir = vB - vA;\n    float l = length( vDir );\n    vDir = normalize( vDir );\n\n    vec2 vOffset = vCanvasPos - vA;\n    float fDot = dot( vOffset, vDir );\n    float fT = clamp( fDot, 0.0, l );\n\n    vec2 vClosest = vA + vDir * fT;\n    float fDist = length(vClosest - vCanvasPos) - fThickness;\n\n    if ( fDist < 0.0 )\n    {\n        vOutColor = vColor;\n    }    \n}\n\nvoid DrawBorderOutdent( vec2 vCanvasPos, Rect rect, inout vec4 vOutColor )\n{    \n    vec2 vThickness = vec2(1.0);\n    \n\tif ( Inside( vCanvasPos, rect ) )\n    {\n        if ( any( lessThanEqual( vCanvasPos, rect.vPos + vThickness) ) )\n        {\n            vOutColor.rgb = vec3(0.85);\n        }\n        else\n        if ( any( greaterThan( vCanvasPos, rect.vPos + rect.vSize - vThickness) ) )\n        {\n            vOutColor.rgb = vec3(0.0);\n        }\n        else\n        if ( any( lessThanEqual( vCanvasPos, rect.vPos + vThickness * 2.0) ) )\n        {\n            vOutColor.rgb = vec3(1.0);\n        }\n        else\n        if ( any( greaterThan( vCanvasPos, rect.vPos + rect.vSize - vThickness * 2.0) ) )\n        {\n            vOutColor.rgb = vec3(0.4);\n        }\n    }\n}\n\nvoid DrawBorderRect( vec2 vCanvasPos, Rect rect, vec3 vOutlineColor, inout vec4 vOutColor )\n{ \n    vec2 vThickness = vec2(1.0);\n    \n\tif ( Inside( vCanvasPos, rect ) )\n    {        \n        if ( any( lessThanEqual( vCanvasPos, rect.vPos + vThickness) ) )\n        {\n            vOutColor.rgb = vOutlineColor;\n        }\n        else\n        if ( any( greaterThan( vCanvasPos, rect.vPos + rect.vSize - vThickness) ) )\n        {\n            vOutColor.rgb = vOutlineColor;\n        }\n        else\n        if ( any( lessThanEqual( vCanvasPos, rect.vPos + vThickness * 2.0) ) )\n        {\n            vOutColor.rgb = vOutlineColor;\n        }\n        else\n        if ( any( greaterThan( vCanvasPos, rect.vPos + rect.vSize - vThickness * 2.0) ) )\n        {\n            vOutColor.rgb = vOutlineColor;\n        }\n    }    \n}\n\nvoid DrawBorderIndent( vec2 vCanvasPos, Rect rect, inout vec4 vOutColor )\n{    \n    vec2 vThickness = vec2(1.0);\n    \n\tif ( Inside( vCanvasPos, rect ) )\n    {        \n        if ( any( lessThanEqual( vCanvasPos, rect.vPos + vThickness) ) )\n        {\n            vOutColor.rgb = vec3(0.0);\n        }\n        else\n        if ( any( greaterThan( vCanvasPos, rect.vPos + rect.vSize - vThickness) ) )\n        {\n            vOutColor.rgb = vec3(0.85);\n        }\n        else\n        if ( any( lessThanEqual( vCanvasPos, rect.vPos + vThickness * 2.0) ) )\n        {\n            vOutColor.rgb = vec3(0.4);\n        }\n        else\n        if ( any( greaterThan( vCanvasPos, rect.vPos + rect.vSize - vThickness * 2.0) ) )\n        {\n            vOutColor.rgb = vec3(1.0);\n        }\n    }\n}\n    \nstruct UIDrawContext\n{        \n    vec2 vCanvasSize;\n    \n    \/\/ position and size of unclipped viewport on the screen\n    Rect viewport;\n    \n    \/\/ visible region of viewport on the screen\n    Rect clip;\n    \n    \/\/ canvas co-ordinates at top-left corner of viewport\n    vec2 vOffset;\n};\n\nvec2 UIDrawContext_ScreenPosToCanvasPos( UIDrawContext drawContext, vec2 vScreenPos )\n{\n    vec2 vViewPos = vScreenPos - drawContext.viewport.vPos;\n    return vViewPos + drawContext.vOffset;\n}\n\nvec2 UIDrawContext_CanvasPosToScreenPos( UIDrawContext drawContext, vec2 vCanvasPos )\n{\n    return vCanvasPos - drawContext.vOffset + drawContext.viewport.vPos;\n}\n\nbool UIDrawContext_ScreenPosInView( UIDrawContext drawContext, vec2 vScreenPos )\n{\n    return Inside( vScreenPos, drawContext.clip );\n}\n\nbool UIDrawContext_ScreenPosInCanvasRect( UIDrawContext drawContext, vec2 vScreenPos, Rect canvasRect )\n{\n\tvec2 vCanvasPos = UIDrawContext_ScreenPosToCanvasPos( drawContext, vScreenPos );    \n    return Inside( vCanvasPos, canvasRect );\n}\n\nUIDrawContext UIDrawContext_SetupFromRect( Rect rect )\n{\n    UIDrawContext drawContext;\n    drawContext.viewport = rect;\n    drawContext.vOffset = vec2(0);\n    drawContext.vCanvasSize = rect.vSize;\n\treturn drawContext;\n}\n\n\nUIDrawContext UIDrawContext_TransformChild( UIDrawContext parentContext, UIDrawContext childContext )\n{\n    UIDrawContext result;\n    \n    \/\/ The child canvas size is unmodified\n    result.vCanvasSize = childContext.vCanvasSize;\n\n    \/\/ Child viewport positions are in the parent's canvas\n    \/\/ Transform them to screen co-ordinates    \n    result.viewport.vPos = UIDrawContext_CanvasPosToScreenPos( parentContext, childContext.viewport.vPos );\n    vec2 vMax = childContext.viewport.vPos + childContext.viewport.vSize;\n    vec2 vScreenMax = UIDrawContext_CanvasPosToScreenPos( parentContext, vMax );\n    result.viewport.vSize = vScreenMax - result.viewport.vPos;\n    result.vOffset = childContext.vOffset;\n    \n    \/\/ Now clip the view so that it is within the parent view\n    vec2 vViewMin = max( result.viewport.vPos, parentContext.clip.vPos );\n    vec2 vViewMax = min( result.viewport.vPos + result.viewport.vSize, parentContext.clip.vPos + parentContext.clip.vSize );\n\n    \/\/ Clip view to current canvas\n    vec2 vCanvasViewMin = result.viewport.vPos - result.vOffset;\n    vec2 vCanvasViewMax = vCanvasViewMin + result.vCanvasSize;\n    \n    vViewMin = max( vViewMin, vCanvasViewMin );\n\tvViewMax = min( vViewMax, vCanvasViewMax );\n    \n    result.clip = Rect( vViewMin, vViewMax - vViewMin );\n    \n    return result;\n}\n\nfloat \tUIStyle_TitleBarHeight();\nvec2 \tUIStyle_WindowBorderSize();\nvec2 \tUIStyle_WindowContentPadding();\nvec2 \tUIStyle_ControlSpacing();\nvec2 \tUIStyle_FontPadding();\nvec2 \tUIStyle_CheckboxSize();\nvec2 \tUIStyle_SliderSize();\nvec3 \tUIStyle_ColorPickerSize();\nfloat \tUIStyle_ScrollBarSize();\nfloat   UIStyle_WindowTransparency();\n\nstruct UILayout\n{\n    float fTabPosition;\n    vec2 vCursor;\n    Rect controlRect;\n    \n    \/\/ Bounds of controls in current stack\n    vec2 vControlMax;\n    vec2 vControlMin;\n};\n    \nUILayout UILayout_Reset()\n{\n    UILayout uiLayout;\n    \n    uiLayout.fTabPosition = 0.0;\n    uiLayout.vCursor = vec2(0);\n    uiLayout.controlRect = Rect( vec2(0), vec2(0) );\n    uiLayout.vControlMax = vec2(0);\n    uiLayout.vControlMin = vec2(0);\n    \n    return uiLayout;\n}\n\nRect UILayout_GetStackedControlRect( inout UILayout uiLayout, vec2 vSize )\n{\n    return Rect( uiLayout.vCursor, vSize );\n}\n\nvoid UILayout_SetControlRect( inout UILayout uiLayout, Rect rect )\n{\n    uiLayout.controlRect = rect;\n    \n    uiLayout.vControlMax = max( uiLayout.vControlMax, rect.vPos + rect.vSize );\n    uiLayout.vControlMin = max( uiLayout.vControlMin, rect.vPos );    \n}\n\nRect UILayout_StackControlRect( inout UILayout uiLayout, vec2 vSize )\n{\n    Rect rect = UILayout_GetStackedControlRect( uiLayout, vSize );\n    UILayout_SetControlRect( uiLayout, rect );\n    return rect;\n}\n\nvoid UILayout_SetX( inout UILayout uiLayout, float xPos )\n{\n    uiLayout.vCursor.x = xPos;\n    uiLayout.vControlMax.x = uiLayout.vCursor.x;\n    uiLayout.vControlMin.x = uiLayout.vCursor.x;\n}\n\nvoid UILayout_StackRight( inout UILayout uiLayout )\n{\n    UILayout_SetX( uiLayout, uiLayout.vControlMax.x + UIStyle_ControlSpacing().x );\n}\n\nvoid UILayout_StackDown( inout UILayout uiLayout )\n{\n    uiLayout.vCursor.x = uiLayout.fTabPosition;\n    uiLayout.vCursor.y = uiLayout.vControlMax.y + UIStyle_ControlSpacing().y;    \n    uiLayout.vControlMax.x = uiLayout.vCursor.x;\n    uiLayout.vControlMin.x = uiLayout.vCursor.x;\n    uiLayout.vControlMax.y = uiLayout.vCursor.y;\n    uiLayout.vControlMin.y = uiLayout.vCursor.y;\n}\n\n#define IDC_NONE            -1\n\nstruct UIContext\n{\n    vec2 vPixelPos;\n    \n    vec2 vMousePos;\n    bool bMouseDown;\n    bool bMouseWasDown;\n    bool bHandledClick;\n    \n    ivec2 vFragCoord;\n    vec4 vOutColor;\n    float fBlendRemaining;\n\n    vec4 vOutData;\n    \n    int iActiveControl;\n    vec2 vActivePos;\n\n    UIDrawContext drawContext;\n    bool bPixelInView; \/\/ derived from drawContext\n    vec2 vPixelCanvasPos; \/\/ derived from drawContext\n    bool bMouseInView; \/\/ derived from drawContext\n    vec2 vMouseCanvasPos; \/\/ derived from drawContext\n\n    vec4 vWindowOutColor; \/\/ Output for current window draw pass\n#ifdef SHADOW_TEST\n    float fShadow;\n    float fOutShadow;\n#endif    \n};\n\nvoid UI_SetDrawContext( inout UIContext uiContext, UIDrawContext drawContext )\n{\n    uiContext.drawContext = drawContext;\n    \n    uiContext.vPixelCanvasPos = UIDrawContext_ScreenPosToCanvasPos( drawContext, uiContext.vPixelPos );\n    uiContext.bPixelInView = UIDrawContext_ScreenPosInView( drawContext, uiContext.vPixelPos );\n\n    uiContext.vMouseCanvasPos = UIDrawContext_ScreenPosToCanvasPos( drawContext, uiContext.vMousePos );\n    uiContext.bMouseInView = UIDrawContext_ScreenPosInView( drawContext, uiContext.vMousePos );\n}    \n\nUIContext UI_GetContext( vec2 fragCoord, int iData )\n{\n    UIContext uiContext;\n    \n    uiContext.vPixelPos = fragCoord;\n    uiContext.vPixelPos.y = iResolution.y - uiContext.vPixelPos.y;\n    uiContext.vMousePos = iMouse.xy;\n    uiContext.vMousePos.y = iResolution.y - uiContext.vMousePos.y;\n    uiContext.bMouseDown = iMouse.z > 0.0;       \n    \n    vec4 vData0 = LoadVec4( iChannelUI, ivec2(iData,0) );\n    \n    uiContext.bMouseWasDown = (vData0.x > 0.0);\n    \n    uiContext.vFragCoord = ivec2(fragCoord);\n    uiContext.vOutColor = vec4(0.0);\n#ifdef SHADOW_TEST    \n    uiContext.fShadow = 1.0;\n    uiContext.fOutShadow = 1.0f;\n#endif    \n    uiContext.fBlendRemaining = 1.0;\n    \n    uiContext.vOutData = vec4(0.0);\n    if ( int(uiContext.vFragCoord.y) < 2 )\n    {\n        \/\/ Initialize data with previous value\n\t    uiContext.vOutData = texelFetch( iChannelUI, uiContext.vFragCoord, 0 );     \n    }\n    uiContext.bHandledClick = false;\n    \n    uiContext.iActiveControl = int(vData0.y);\n    uiContext.vActivePos = vec2(vData0.zw);\n        \n    \n    UIDrawContext rootContext;\n    \n    rootContext.vCanvasSize = iResolution.xy;\n    rootContext.vOffset = vec2(0);\n    rootContext.viewport = Rect( vec2(0), vec2(iResolution.xy) );\n    rootContext.clip = rootContext.viewport;\n\n    UI_SetDrawContext( uiContext, rootContext );\n    \n    uiContext.vWindowOutColor = vec4(0);    \n        \n    if ( iFrame == 0 )\n    {\n        uiContext.bMouseWasDown = false;\n        uiContext.iActiveControl = IDC_NONE;\n    }\n    \n    return uiContext;\n}\/\/\/\n\nvoid UI_StoreContext( inout UIContext uiContext, int iData )\n{\n    vec4 vData0 = vec4( uiContext.bMouseDown ? 1.0 : 0.0, float(uiContext.iActiveControl), uiContext.vActivePos.x, uiContext.vActivePos.y );\n    StoreVec4( ivec2(iData,0), vData0, uiContext.vOutData, ivec2(uiContext.vFragCoord) );\n}\n\nvec4 UI_GetFinalColor( UIContext uiContext )\n{\n    if ( int(uiContext.vFragCoord.y) < 2 )\n    {\n        return uiContext.vOutData;\n    }\n    \n    if ( uiContext.vOutColor.a >= 0.0 )\n    {\n        \/\/ Apply premultiplied alpha.\n        uiContext.vOutColor.rgb *= uiContext.vOutColor.a;\n  \n#ifdef SHADOW_TEST\n        \/\/ Shadow composite for premultiplied alpha.\n        \/\/ Don't even ask how this works - I'm not sure I know\n        uiContext.vOutColor.rgb *= uiContext.fOutShadow;\n        uiContext.vOutColor.a = 1.0 - ((1.0 - uiContext.vOutColor.a) * uiContext.fOutShadow);\n#endif \t\n    }\n    else\n    {\n#ifdef SHADOW_TEST\n        uiContext.vOutColor.a = -1.0 -uiContext.fOutShadow;\n#else\n        uiContext.vOutColor.a = -2.0;\n#endif \n    }\n    \n    return uiContext.vOutColor;\n}\n\nvoid UI_ComposeWindowLayer( inout UIContext uiContext, float fTransparency, Rect windowRect )\n{\n#ifdef SHADOW_TEST   \n  \tif ( !uiContext.bPixelInView )\n    {\n        return;\n    }\n\n#if 1\n    \/\/ cull window?\n    Rect boundsRect = windowRect;\n    RectExpand( boundsRect, vec2( 16.0 ) );\n    if ( !Inside( uiContext.vPixelPos, boundsRect ) )\n    {\n        return;\n    }\n#endif\n    \n    \/\/ We need to compose in the parent drawContext for this to work...\n    float fPrevShadow = uiContext.fShadow;\n    \n    vec2 vShadowOffset = vec2( 5.0, 8.0 );\n    float fShadowInner = 3.0;\n\tfloat fShadowOuter = 12.0;\n    \n    Rect shadowRect = windowRect;\n    RectShrink( shadowRect, vec2( fShadowInner ) );\n    \n    vec2 vShadowTestPos = uiContext.vPixelPos - vShadowOffset;\n    vec2 vWindowClosest = clamp( vShadowTestPos, shadowRect.vPos, shadowRect.vPos + shadowRect.vSize );\n\n    float fWindowDist = length( vWindowClosest - vShadowTestPos );\n    \n    float fCurrentShadow = clamp( (fWindowDist) \/ (fShadowOuter + fShadowInner), 0.0, 1.0 );\n    fCurrentShadow = sqrt( fCurrentShadow );\n    float fShadowTransparency = 0.5;\n\tuiContext.fShadow *= fCurrentShadow * (1.0 - fShadowTransparency) + fShadowTransparency; \n#endif    \n\n  \tif ( !Inside( uiContext.vPixelPos, windowRect ) )\n    {\n        return;\n    }\n\n    float fBlend = uiContext.fBlendRemaining * (1.0f - fTransparency);\n\n#ifdef SHADOW_TEST\n    uiContext.fOutShadow *= fPrevShadow * (fBlend) + (1.0 - fBlend);\n#endif\n    \n    \/\/ never blend under \"ID\" window\n    if ( uiContext.vOutColor.a < 0.0 )\n    {\n        return;\n    }\n    \n    if ( uiContext.vWindowOutColor.a < 0.0 )\n    {\n        if ( uiContext.fBlendRemaining == 1.0f )\n        {\n            \/\/ Ouput ID without blending\n            uiContext.vOutColor = uiContext.vWindowOutColor;\n            uiContext.fBlendRemaining = 0.0f;\n            return;\n        }\n        else\n        {\n            \/\/ blending id under existing color - blend in grey instead of ID\n            uiContext.vWindowOutColor = vec4(0.75, 0.75, 0.75, 1.0);\n        }\n    }\n\n    uiContext.vOutColor += uiContext.vWindowOutColor * fBlend;\n    \n    uiContext.fBlendRemaining *= fTransparency;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ UI Data\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define DIRTY_DATA_MAGIC\t\t\t123.456\n\n\/\/ from HSV and HSL by iq - https:\/\/www.shadertoy.com\/view\/lsS3Wc\nconst float eps = 0.0000001;\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 rgb2hsv( in vec3 c)\n{\n    vec4 k = vec4(0.0, -1.0\/3.0, 2.0\/3.0, -1.0);\n    vec4 p = mix(vec4(c.zy, k.wz), vec4(c.yz, k.xy), (c.z<c.y) ? 1.0 : 0.0);\n    vec4 q = mix(vec4(p.xyw, c.x), vec4(c.x, p.yzx), (p.x<c.x) ? 1.0 : 0.0);\n    float d = q.x - min(q.w, q.y);\n    return vec3(abs(q.z + (q.w - q.y) \/ (6.0*d+eps)), d \/ (q.x+eps), q.x);\n}\n\nstruct UIData_Bool\n{\n    bool bValue;\n};\n    \nUIData_Bool UI_GetDataBool( int iData, bool bDefault )  \n{\n    UIData_Bool dataBool;\n        \n\tvec4 vData0 = LoadVec4( iChannelUI, ivec2(iData,0) );\n    \n    if ( iFrame == 0 )\n    {\n        dataBool.bValue = bDefault;\n    }\n    else\n    {\n        dataBool.bValue =  vData0.x > 0.5;\n    }\n    \n    return dataBool;\n}\n\nvoid UI_StoreDataBool( inout UIContext uiContext, UIData_Bool dataBool, int iData )\n{\n    vec4 vData0 = vec4(0);\n    vData0.x = dataBool.bValue ? 1.0 : 0.0;\n    StoreVec4( ivec2(iData,0), vData0, uiContext.vOutData, ivec2(uiContext.vFragCoord) );            \n}\n\n\nstruct UIData_Value\n{\n    float fValue;\n    float fRangeMin;\n    float fRangeMax;\n};\n\nUIData_Value UI_GetDataValue( int iData, float fDefaultValue, float fRangeMin, float fRangeMax )  \n{\n    UIData_Value dataValue;\n    \n    vec4 vData0 = LoadVec4( iChannelUI, ivec2(iData,0) );\n    \n    if ( iFrame == 0 )\n    {\n        dataValue.fValue = fDefaultValue;\n    }\n    else\n    {\n        dataValue.fValue = vData0.x;\n    }\n    \n    dataValue.fRangeMin = fRangeMin;\n    dataValue.fRangeMax = fRangeMax;\n    \n    return dataValue;\n}\n\nvoid UI_StoreDataValue( inout UIContext uiContext, UIData_Value dataValue, int iData )\n{\n    vec4 vData0 = vec4(0);\n    vData0.x = dataValue.fValue;\n    StoreVec4( ivec2(iData,0), vData0, uiContext.vOutData, ivec2(uiContext.vFragCoord) );            \n}\n\nstruct UIData_Color\n{    \n    vec3 vHSV;\n};\n\nUIData_Color UI_GetDataColor( int iData, vec3 cDefaultRGB )  \n{\n    UIData_Color dataColor;\n    \n    vec4 vData1 = LoadVec4( iChannelUI, ivec2(iData,1) );\n    \n    if ( iFrame == 0 )\n    {\n        dataColor.vHSV = rgb2hsv( cDefaultRGB );\n    }\n    else\n    {\n        dataColor.vHSV = vData1.rgb;\n    }\n    \n    return dataColor;\n}\n\nvoid UI_StoreDataColor( inout UIContext uiContext, UIData_Color dataColor, int iData )\n{\n    vec4 vData0 = vec4(0);\n    vData0.rgb = hsv2rgb( dataColor.vHSV );\n        \n    StoreVec4( ivec2(iData,0), vData0, uiContext.vOutData, ivec2(uiContext.vFragCoord) );            \n\n    vec4 vData1 = vec4(0);\n    vData1.rgb = dataColor.vHSV;\n        \n    StoreVec4( ivec2(iData,1), vData1, uiContext.vOutData, ivec2(uiContext.vFragCoord) );            \n}\n\nPrintState UI_PrintState_Init( inout UIContext uiContext, LayoutStyle style, vec2 vPosition )\n{\n    vec2 vCanvasPos = uiContext.vPixelCanvasPos;\n    \n    PrintState state = PrintState_InitCanvas( vCanvasPos, vec2(1.0) );\n    MoveTo( state, vPosition + UIStyle_FontPadding() );\n\tPrintBeginNextLine(state, style);\n\n\treturn state;\n}\n\nRect UI_GetFontRect( PrintState state, LayoutStyle style )\n{\n    Rect rect;\n    rect = GetFontRect( state, style, true );\n    vec2 vExpand = UIStyle_FontPadding();\n    vExpand.y += style.vSize.y * style.fLineGap;\n    RectExpand( rect, vExpand );\n\treturn rect;\n}\n\nvoid UI_RenderFont( inout UIContext uiContext, PrintState state, LayoutStyle style, RenderStyle renderStyle )\n{\n    if( uiContext.bPixelInView )\n    {\n        RenderFont( state, style, renderStyle, uiContext.vWindowOutColor.rgb );\n    }\n}\n\nvoid UILayout_SetControlRectFromText( inout UILayout uiLayout, PrintState state, LayoutStyle style )\n{\n    UILayout_SetControlRect( uiLayout, UI_GetFontRect( state, style ) );\n}\n\nstruct UIPanelState\n{\n    UIDrawContext parentDrawContext;\n\tvec4 vParentWindowColor;\n};\n    \nvoid UI_PanelBegin( inout UIContext uiContext, inout UIPanelState panelState )\n{\n    panelState.parentDrawContext = uiContext.drawContext;\n    panelState.vParentWindowColor = uiContext.vWindowOutColor;\n}\n\nvoid UI_PanelEnd( inout UIContext uiContext, inout UIPanelState panelState )\n{\n    if ( !uiContext.bPixelInView )\n    {\n        \/\/ Restore parent window color if outside view\n\t    uiContext.vWindowOutColor = panelState.vParentWindowColor;    \n    }\n\n    UI_SetDrawContext( uiContext, panelState.parentDrawContext );\n}\n\n#define FLAG_SET(X,F) (( X & F ) != 0u)\n    \nconst uint\tWINDOW_CONTROL_FLAG_CLOSE_BOX \t\t= 1u,\n\t\t\tWINDOW_CONTROL_FLAG_MINIMIZE_BOX\t= 2u,\n\t\t\tWINDOW_CONTROL_FLAG_RESIZE_WIDGET \t= 4u,\n\t\t\tWINDOW_CONTROL_FLAG_TITLE_BAR \t\t= 8u;\n    \nstruct UIWindowDesc\n{\n    Rect initialRect;\n    bool bStartMinimized;\n    bool bStartClosed;\n    bool bOpenWindow;\n    \n    uint uControlFlags;    \n    vec2 vMaxSize;\n};\n\n\nstruct UIWindowState\n{\n    UIPanelState panelState;\n\n    Rect rect;\n    bool bMinimized;\n    bool bClosed;\n    \n    uint uControlFlags;    \n    vec2 vMaxSize;\n    int iControlId;\n\n    Rect drawRect;\n};\n\n\nUIWindowState UI_GetWindowState( UIContext uiContext, int iControlId, int iData, UIWindowDesc desc )\n{\n    UIWindowState window;    \n    \n    vec4 vData0 = LoadVec4( iChannelUI, ivec2(iData,0) );\n        \n    window.rect = Rect( vData0.xy, vData0.zw );\n    \n    vec4 vData1 = LoadVec4( iChannelUI, ivec2(iData,1) );\n    \n    window.bMinimized = (vData1.x > 0.0);    \n    window.bClosed = (vData1.y > 0.0) && !desc.bOpenWindow;    \n    \n    \/\/ Clamp window position so title bar is always on canvas\n\tvec2 vSafeMin = vec2(24.0);        \n\tvec2 vSafeMax = vec2(32.0);        \n    vec2 vPosMin = vec2( -window.rect.vSize.x + vSafeMin.x, -vSafeMin.y);\/\/vec2( -window.rect.vSize.x, 0.0) + 24.0, -24.0 );\n    vec2 vPosMax = uiContext.drawContext.vCanvasSize - vSafeMax;\n    window.rect.vPos = clamp( window.rect.vPos, vPosMin, vPosMax );\n    \n    if ( iFrame == 0 || vData1.z != DIRTY_DATA_MAGIC)\n    {\n        window.rect = desc.initialRect;\n        window.bMinimized = desc.bStartMinimized;\n\t    window.bClosed = desc.bStartClosed;\n    }       \n    \n    window.uControlFlags = desc.uControlFlags;\n    window.vMaxSize = desc.vMaxSize;\n    \n    window.iControlId = iControlId;\n        \n    return window;\n}\n\nvoid UI_StoreWindowState( inout UIContext uiContext, UIWindowState window, int iData )\n{    \n    vec4 vData0;\n    vData0.xy = window.rect.vPos;\n    vData0.zw = window.rect.vSize;\n    \n    StoreVec4( ivec2(iData,0), vData0, uiContext.vOutData, ivec2(uiContext.vFragCoord) );        \n\n    vec4 vData1;\n    \n    vData1.x = window.bMinimized ? 1.0f : 0.0f;\n    vData1.y = window.bClosed ? 1.0f : 0.0f;\n    vData1.z = DIRTY_DATA_MAGIC;\n    vData1.w = 0.0f;\n\n    StoreVec4( ivec2(iData,1), vData1, uiContext.vOutData, ivec2(uiContext.vFragCoord) );        \n}\n\nbool UI_ShouldProcessWindow( UIWindowState window )\n{\n    return !window.bMinimized && !window.bClosed;\n}\n\nvoid UI_WriteCanvasPos( inout UIContext uiContext, int iControlId )        \n{\n\tif (!uiContext.bPixelInView)\n        return;\n    Rect rect = Rect( vec2(0), uiContext.drawContext.vCanvasSize );\n    DrawRect( uiContext.vPixelCanvasPos, rect, vec4(uiContext.vPixelCanvasPos, float(iControlId), -1.0 ), uiContext.vWindowOutColor );\n}    \n\nvoid UI_WriteCanvasUV( inout UIContext uiContext, int iControlId )        \n{\n\tif (!uiContext.bPixelInView)\n        return;\n    Rect rect = Rect( vec2(0), uiContext.drawContext.vCanvasSize );\n    DrawRect( uiContext.vPixelCanvasPos, rect, vec4(uiContext.vPixelCanvasPos \/ uiContext.drawContext.vCanvasSize, float(iControlId), -1.0 ), uiContext.vWindowOutColor );\n}\n\nvoid UI_DrawButton( inout UIContext uiContext, bool bActive, bool bMouseOver, Rect buttonRect )\n{\n\tif (!uiContext.bPixelInView)\n        return;\n    \n    if ( bActive && bMouseOver )\n    {\n#ifdef NEW_THEME\n    \tDrawBorderRect( uiContext.vPixelCanvasPos, buttonRect, cButtonActive, uiContext.vWindowOutColor );\n#else\n    \tDrawBorderIndent( uiContext.vPixelCanvasPos, buttonRect, uiContext.vWindowOutColor );\n#endif        \n    }\n    else\n    {\n#ifdef NEW_THEME\n    \tDrawBorderRect( uiContext.vPixelCanvasPos, buttonRect, cButtonInactive, uiContext.vWindowOutColor );\n#else\n    \tDrawBorderOutdent( uiContext.vPixelCanvasPos, buttonRect, uiContext.vWindowOutColor );\n#endif        \n    }\n}\n\nbool UI_ProcessButton( inout UIContext uiContext, int iControlId, Rect buttonRect )\n{    \n    bool bMouseOver = Inside( uiContext.vMouseCanvasPos, buttonRect ) && uiContext.bMouseInView;\n    \n    bool bButtonPressed = false;\n    \n    if ( uiContext.iActiveControl == IDC_NONE )\n    {\n        if ( uiContext.bMouseDown && (!uiContext.bMouseWasDown) && bMouseOver && !uiContext.bHandledClick )\n        {\n            uiContext.iActiveControl = iControlId;\n            uiContext.bHandledClick = true;\n        }\n    }\n    else\n    if ( uiContext.iActiveControl == iControlId )\n    {\n        if ( !uiContext.bMouseDown )\n        {\n            uiContext.iActiveControl = IDC_NONE;\n            if ( bMouseOver )\n            {\n                bButtonPressed = true;\n            }\n        }\n    }\n\n    bool bActive = (uiContext.iActiveControl == iControlId);\n    \n    UI_DrawButton( uiContext, bActive, bMouseOver, buttonRect );    \n        \n    return bButtonPressed;\n}\n\nvoid UI_DrawCheckbox( inout UIContext uiContext, bool bActive, bool bMouseOver, bool bChecked, Rect checkBoxRect )\n{\n\tif (!uiContext.bPixelInView || Outside( uiContext.vPixelCanvasPos, checkBoxRect ))\n        return;\n    \n    uiContext.vWindowOutColor = vec4(1.0);\n    \n    if ( bActive && bMouseOver )\n    {\n        uiContext.vWindowOutColor = vec4(0.85,0.85,0.85,1.0);\n    }\n\n#ifdef NEW_THEME\n    DrawBorderRect( uiContext.vPixelCanvasPos, checkBoxRect, cCheckboxOutline, uiContext.vWindowOutColor );\n#else    \n    DrawBorderIndent( uiContext.vPixelCanvasPos, checkBoxRect, uiContext.vWindowOutColor );\n#endif    \n\n    Rect smallerRect = checkBoxRect;\n    RectShrink( smallerRect, vec2(6.0));\n\n    if ( bChecked )\n    {\n        vec4 vCheckColor = vec4(0.0, 0.0, 0.0, 1.0);\n        DrawLine( uiContext.vPixelCanvasPos, smallerRect.vPos+ smallerRect.vSize * vec2(0.0, 0.75), smallerRect.vPos+ smallerRect.vSize * vec2(0.25, 1.0), 2.0f, vCheckColor, uiContext.vWindowOutColor );\n        DrawLine( uiContext.vPixelCanvasPos, smallerRect.vPos+ smallerRect.vSize * vec2(0.25, 1.0), smallerRect.vPos+ smallerRect.vSize * vec2(1.0, 0.25), 2.0f, vCheckColor, uiContext.vWindowOutColor );\n    }\n}\n\nvoid UI_ProcessCheckbox( inout UIContext uiContext, int iControlId, inout UIData_Bool data, Rect checkBoxRect )\n{    \n    bool bMouseOver = Inside( uiContext.vMouseCanvasPos, checkBoxRect ) && uiContext.bMouseInView;\n    \n    if ( uiContext.iActiveControl == IDC_NONE )\n    {\n        if ( uiContext.bMouseDown && (!uiContext.bMouseWasDown) && bMouseOver && !uiContext.bHandledClick )\n        {\n            uiContext.iActiveControl = iControlId;\n            uiContext.bHandledClick = true;\n        }\n    }\n    else\n    if ( uiContext.iActiveControl == iControlId )\n    {\n        if ( !uiContext.bMouseDown )\n        {\n            uiContext.iActiveControl = IDC_NONE;\n            if ( bMouseOver )\n            {\n                data.bValue = !data.bValue;\n            }\n        }\n    }\n    \n    bool bActive = (uiContext.iActiveControl == iControlId);\n    \n    UI_DrawCheckbox( uiContext, bActive, bMouseOver, data.bValue, checkBoxRect );    \n}\n\nvoid UI_DrawSliderX( inout UIContext uiContext, bool bActive, bool bMouseOver, float fPosition, Rect sliderRect, float fHandleSize, bool scrollbarStyle )\n{\n\tif (!uiContext.bPixelInView || Outside( uiContext.vPixelCanvasPos, sliderRect ))\n        return;\n    \n    Rect horizLineRect;\n    \n    horizLineRect = sliderRect;\n    if (!scrollbarStyle)\n    {\n\t    float fMid = sliderRect.vPos.y + sliderRect.vSize.y * 0.5;\n    \thorizLineRect.vPos.y = fMid - 2.0;\n    \thorizLineRect.vSize.y = 4.0;\n    }\n\n#ifdef NEW_THEME    \n    DrawBorderRect( uiContext.vPixelCanvasPos, horizLineRect, cSliderLineCol, uiContext.vWindowOutColor );\n#else    \n    DrawBorderIndent( uiContext.vPixelCanvasPos, horizLineRect, uiContext.vWindowOutColor );\n#endif\n\n    float fSlideMin = sliderRect.vPos.x + fHandleSize * 0.5f;\n    float fSlideMax = sliderRect.vPos.x + sliderRect.vSize.x - fHandleSize * 0.5f;\n\n    float fDistSlider = (fSlideMin + (fSlideMax-fSlideMin) * fPosition);\n\n    Rect handleRect;\n\n    handleRect = sliderRect;\n    handleRect.vPos.x = fDistSlider - fHandleSize * 0.5f;\n    handleRect.vSize.x = fHandleSize;\n\n    vec4 handleColor = vec4(0.75, 0.75, 0.75, 1.0);\n    if ( bActive )\n    {\n        handleColor.rgb += 0.1;\n    }       \n    \n    \/\/ highlight\n#ifdef NEW_THEME     \n    if ( (uiContext.vPixelCanvasPos.y - handleRect.vPos.y) < handleRect.vSize.y * 0.3 )\n    {\n        handleColor.rgb += 0.05;\n    }\n#endif    \n\n    DrawRect( uiContext.vPixelCanvasPos, handleRect, handleColor, uiContext.vWindowOutColor );\n\n#ifdef NEW_THEME   \n    DrawBorderRect( uiContext.vPixelCanvasPos, handleRect, cSliderHandleOutlineCol, uiContext.vWindowOutColor );\n#else    \n    DrawBorderOutdent( uiContext.vPixelCanvasPos, handleRect, uiContext.vWindowOutColor );\n#endif    \n}\n\nvoid UI_DrawSliderY( inout UIContext uiContext, bool bActive, bool bMouseOver, float fPosition, Rect sliderRect, float fHandleSize, bool scrollbarStyle )\n{\n\tif (!uiContext.bPixelInView || Outside( uiContext.vPixelCanvasPos, sliderRect ))\n        return;\n    \n    Rect horizLineRect;\n    \n    horizLineRect = sliderRect;\n    if (!scrollbarStyle)\n    {\n\t    float fMid = sliderRect.vPos.x + sliderRect.vSize.x * 0.5;\n    \thorizLineRect.vPos.x = fMid - 2.0;\n    \thorizLineRect.vSize.x = 4.0;\n    }\n\n#ifdef NEW_THEME    \n    DrawBorderRect( uiContext.vPixelCanvasPos, horizLineRect, cSliderLineCol, uiContext.vWindowOutColor );\n#else    \n    DrawBorderIndent( uiContext.vPixelCanvasPos, horizLineRect, uiContext.vWindowOutColor );\n#endif    \n\n    float fSlideMin = sliderRect.vPos.y + fHandleSize * 0.5f;\n    float fSlideMax = sliderRect.vPos.y + sliderRect.vSize.y - fHandleSize * 0.5f;\n\n    float fDistSlider = (fSlideMin + (fSlideMax-fSlideMin) * fPosition);\n\n    Rect handleRect;\n\n    handleRect = sliderRect;\n    handleRect.vPos.y = fDistSlider - fHandleSize * 0.5f;\n    handleRect.vSize.y = fHandleSize;\n\n    vec4 handleColor = vec4(0.75, 0.75, 0.75, 1.0);\n    if ( bActive )\n    {\n        handleColor.rgb += 0.1;\n    }\n    \n    \/\/ highlight\n#ifdef NEW_THEME     \n    if ( (uiContext.vPixelCanvasPos.y - handleRect.vPos.y) < handleRect.vSize.y * 0.3 )\n    {\n        handleColor.rgb += 0.05;\n    }\n#endif    \n\n    DrawRect( uiContext.vPixelCanvasPos, handleRect, handleColor, uiContext.vWindowOutColor );\n#ifdef NEW_THEME   \n    DrawBorderRect( uiContext.vPixelCanvasPos, handleRect, cSliderHandleOutlineCol, uiContext.vWindowOutColor );\n#else     \n    DrawBorderOutdent( uiContext.vPixelCanvasPos, handleRect, uiContext.vWindowOutColor );\n#endif    \n}\n\nvoid UI_ProcessSlider( inout UIContext uiContext, int iControlId, inout UIData_Value data, Rect sliderRect )\n{    \n    float fHandleSize = 8.0;\n    \n    bool bMouseOver = Inside( uiContext.vMouseCanvasPos, sliderRect ) && uiContext.bMouseInView;\n    \n    if ( uiContext.iActiveControl == IDC_NONE )\n    {\n        if ( uiContext.bMouseDown && (!uiContext.bMouseWasDown) && bMouseOver && !uiContext.bHandledClick )\n        {\n            uiContext.iActiveControl = iControlId;\n            uiContext.bHandledClick = true;\n        }\n    }\n    else\n    if ( uiContext.iActiveControl == iControlId )\n    {\n        float fSlidePosMin = sliderRect.vPos.x + fHandleSize * 0.5f;\n        float fSlidePosMax = sliderRect.vPos.x + sliderRect.vSize.x - fHandleSize * 0.5f;\n        float fPosition = (uiContext.vMouseCanvasPos.x - fSlidePosMin) \/ (fSlidePosMax - fSlidePosMin);\n        fPosition = clamp( fPosition, 0.0f, 1.0f );\n        data.fValue = data.fRangeMin + fPosition * (data.fRangeMax - data.fRangeMin);\n        if ( !uiContext.bMouseDown )\n        {\n            uiContext.iActiveControl = IDC_NONE;\n        }\n    }\n        \n    bool bActive = (uiContext.iActiveControl == iControlId);\n    float fPosition = (data.fValue - data.fRangeMin) \/ (data.fRangeMax - data.fRangeMin);\n    \n    UI_DrawSliderX( uiContext, bActive, bMouseOver, fPosition, sliderRect, fHandleSize, false );    \n}\n\nvoid UI_ProcessScrollbarX( inout UIContext uiContext, int iControlId, inout UIData_Value data, Rect sliderRect, float fHandleSize )\n{    \n    bool bMouseOver = Inside( uiContext.vMouseCanvasPos, sliderRect ) && uiContext.bMouseInView;\n        \n    if ( uiContext.iActiveControl == IDC_NONE )\n    {\n        if ( uiContext.bMouseDown && (!uiContext.bMouseWasDown) && bMouseOver && !uiContext.bHandledClick )\n        {\n            uiContext.iActiveControl = iControlId;\n            uiContext.bHandledClick = true;\n        }\n    }\n    else\n    if ( uiContext.iActiveControl == iControlId )\n    {\n        float fSlidePosMin = sliderRect.vPos.x + fHandleSize * 0.5f;\n        float fSlidePosMax = sliderRect.vPos.x + sliderRect.vSize.x - fHandleSize * 0.5f;\n        float fPosition = (uiContext.vMouseCanvasPos.x - fSlidePosMin) \/ (fSlidePosMax - fSlidePosMin);\n        fPosition = clamp( fPosition, 0.0f, 1.0f );\n        data.fValue = data.fRangeMin + fPosition * (data.fRangeMax - data.fRangeMin);\n        if ( !uiContext.bMouseDown )\n        {\n            uiContext.iActiveControl = IDC_NONE;\n        }\n    }\n        \n    bool bActive = (uiContext.iActiveControl == iControlId);\n    float fPosition = (data.fValue - data.fRangeMin) \/ (data.fRangeMax - data.fRangeMin);\n    \n    UI_DrawSliderX( uiContext, bActive, bMouseOver, fPosition, sliderRect, fHandleSize, true );    \n}\n\nvoid UI_ProcessScrollbarY( inout UIContext uiContext, int iControlId, inout UIData_Value data, Rect sliderRect, float fHandleSize )\n{    \n    bool bMouseOver = Inside( uiContext.vMouseCanvasPos, sliderRect ) && uiContext.bMouseInView;\n    \n    if ( uiContext.iActiveControl == IDC_NONE )\n    {\n        if ( uiContext.bMouseDown && (!uiContext.bMouseWasDown) && bMouseOver && !uiContext.bHandledClick )\n        {\n            uiContext.iActiveControl = iControlId;\n            uiContext.bHandledClick = true;\n        }\n    }\n    else\n    if ( uiContext.iActiveControl == iControlId )\n    {\n        float fSlidePosMin = sliderRect.vPos.y + fHandleSize * 0.5f;\n        float fSlidePosMax = sliderRect.vPos.y + sliderRect.vSize.y - fHandleSize * 0.5f;\n        float fPosition = (uiContext.vMouseCanvasPos.y - fSlidePosMin) \/ (fSlidePosMax - fSlidePosMin);\n        fPosition = clamp( fPosition, 0.0f, 1.0f );\n        data.fValue = data.fRangeMin + fPosition * (data.fRangeMax - data.fRangeMin);\n        if ( !uiContext.bMouseDown )\n        {\n            uiContext.iActiveControl = IDC_NONE;\n        }\n    }\n        \n    bool bActive = (uiContext.iActiveControl == iControlId);\n    float fPosition = (data.fValue - data.fRangeMin) \/ (data.fRangeMax - data.fRangeMin);\n    \n    UI_DrawSliderY( uiContext, bActive, bMouseOver, fPosition, sliderRect, fHandleSize, true );    \n}\n\nvoid UI_DrawColorPickerSV( inout UIContext uiContext, bool bActive, vec3 vHSV, Rect pickerRect )\n{\n\tif (!uiContext.bPixelInView || Outside( uiContext.vPixelCanvasPos, pickerRect ))\n        return;\n    \n    vec2 vCurrPixelPos = (uiContext.vPixelCanvasPos - pickerRect.vPos) \/ pickerRect.vSize;\n    vCurrPixelPos.y = 1.0f - vCurrPixelPos.y;\n    vec3 vHSVCurr = vHSV;\n    vHSVCurr.yz = vCurrPixelPos;\n\n    uiContext.vWindowOutColor = vec4( hsv2rgb( vHSVCurr ), 1.0 );\n    \n    vec2 vSelectedPos = vHSV.yz;\n    vSelectedPos.y = 1.0f - vSelectedPos.y;\n    vSelectedPos = vSelectedPos * pickerRect.vSize + pickerRect.vPos;\n        \n    float l = length( vSelectedPos - uiContext.vPixelCanvasPos );\n    float d = l - 3.0;\n    d = min(d, 5.0 - l);\n    if ( bActive )\n    {\n        float d2 = l - 5.0;\n    \td2 = min(d2, 7.0 - l);\n\t    d = max(d, d2);\n    }\n    \n    float fBlend = clamp(d, 0.0, 1.0);\n    \n    uiContext.vWindowOutColor.rgb = mix(uiContext.vWindowOutColor.rgb, vec3(1.0) - uiContext.vWindowOutColor.rgb, fBlend);\n}\n\nvoid UI_ProcessColorPickerSV( inout UIContext uiContext, int iControlId, inout UIData_Color data, Rect pickerRect )\n{\n    bool bMouseOver = Inside( uiContext.vMouseCanvasPos, pickerRect ) && uiContext.bMouseInView;\n    \n    vec3 vHSV = data.vHSV;\n    \n    if ( uiContext.iActiveControl == IDC_NONE )\n    {\n        if ( uiContext.bMouseDown && (!uiContext.bMouseWasDown) && bMouseOver && !uiContext.bHandledClick )\n        {\n            uiContext.iActiveControl = iControlId;\n            uiContext.bHandledClick = true;\n        }\n    }\n    else\n    if ( uiContext.iActiveControl == iControlId )\n    {\n        vec2 vPos = (uiContext.vMouseCanvasPos - pickerRect.vPos) \/ pickerRect.vSize;\n        vPos = clamp( vPos, vec2(0), vec2(1) );\n        \n        vHSV.yz = vPos;\n        vHSV.z = 1.0f - vHSV.z;\n        \n        if ( !uiContext.bMouseDown )\n        {\n            uiContext.iActiveControl = IDC_NONE;\n        }\n    }\n    \n    data.vHSV = vHSV;\n    \n    bool bActive = (uiContext.iActiveControl == iControlId);\n    \n    UI_DrawColorPickerSV( uiContext, bActive, vHSV, pickerRect );    \n}\n\nvoid UI_DrawColorPickerH( inout UIContext uiContext, bool bActive, vec3 vHSV, Rect pickerRect )\n{\n\tif (!uiContext.bPixelInView || Outside( uiContext.vPixelCanvasPos, pickerRect ))\n        return;\n    \n    vec2 vCurrPixelPos = (uiContext.vPixelCanvasPos - pickerRect.vPos) \/ pickerRect.vSize;\n    vec3 vHSVCurr = vHSV;\n    vHSVCurr.x = vCurrPixelPos.y;\n    vHSVCurr.yz = vec2(1.0, 1.0);\n    \n    float fSelectedPos = vHSV.x * pickerRect.vSize.y + pickerRect.vPos.y;\n\n\tuiContext.vWindowOutColor = vec4( hsv2rgb( vHSVCurr ), 1.0 );\n        \n    float l = length( fSelectedPos - uiContext.vPixelCanvasPos.y );\n    float d = l - 1.0;\n    d = min(d, 5.0 - l);\n    if ( bActive )\n    {\n        float d2 = l - 4.0;\n    \td2 = min(d2, 6.0 - l);\n\t    d = max(d, d2);\n    }\n    \n    float fBlend = clamp(d, 0.0, 1.0);\n    \n    uiContext.vWindowOutColor.rgb = mix(uiContext.vWindowOutColor.rgb, vec3(0.5), fBlend);    \n}\n\nvoid UI_ProcessColorPickerH( inout UIContext uiContext, int iControlId, inout UIData_Color data, Rect pickerRect )\n{\n    bool bMouseOver = Inside( uiContext.vMouseCanvasPos, pickerRect ) && uiContext.bMouseInView;\n    \n    vec3 vHSV = data.vHSV;\n    \n    if ( uiContext.iActiveControl == IDC_NONE )\n    {\n        if ( uiContext.bMouseDown && (!uiContext.bMouseWasDown) && bMouseOver && !uiContext.bHandledClick )\n        {\n            uiContext.iActiveControl = iControlId;\n            uiContext.bHandledClick = true;\n        }\n    }\n    else\n    if ( uiContext.iActiveControl == iControlId )\n    {\n        float fPos = (uiContext.vMouseCanvasPos.y - pickerRect.vPos.y) \/ pickerRect.vSize.y;\n        fPos = clamp( fPos, 0.0f, 1.0f );\n        \n        vHSV.x = fPos;\n        \n        if ( !uiContext.bMouseDown )\n        {\n            uiContext.iActiveControl = IDC_NONE;\n        }\n    }\n    \n    data.vHSV = vHSV;\n    \n    bool bActive = (uiContext.iActiveControl == iControlId);\n    \n    UI_DrawColorPickerH( uiContext, bActive, vHSV, pickerRect );\n}\n\nbool UI_DrawWindowCloseBox( inout UIContext uiContext, Rect closeBoxRect )\n{\n\tif (!uiContext.bPixelInView || !Inside( uiContext.vPixelCanvasPos, closeBoxRect ))\n        return false;\n    \n    vec2 vCrossPos = closeBoxRect.vPos + closeBoxRect.vSize * 0.5;        \n    vec2 vCrossSize = closeBoxRect.vSize * 0.5 * 0.4;\n    vec4 crossColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec2 vCrossSizeFlip = vCrossSize * vec2(1.0, -1.0);\n    \n    DrawLine( uiContext.vPixelCanvasPos, vCrossPos - vCrossSize, vCrossPos + vCrossSize, 2.0f, crossColor, uiContext.vWindowOutColor );\n    DrawLine( uiContext.vPixelCanvasPos, vCrossPos - vCrossSizeFlip, vCrossPos + vCrossSizeFlip, 2.0f, crossColor, uiContext.vWindowOutColor );\n    \n    return true;\n}\n\nbool UI_ProcessWindowCloseBox( inout UIContext uiContext, inout UIWindowState window, int iControlId, Rect closeBoxRect )\n{\n    bool bPressed = UI_ProcessButton( uiContext, iControlId, closeBoxRect );\n    \n    if ( bPressed )\n    {\n \t\twindow.bClosed = true;\n    }\n\n    bool bActive = (uiContext.iActiveControl == iControlId);\n    \n    return UI_DrawWindowCloseBox( uiContext, closeBoxRect );\n}\n    \nbool UI_DrawWindowMinimizeWidget( inout UIContext uiContext, bool bMinimized, Rect minimizeBoxRect )\n{\n\tif (!uiContext.bPixelInView || !Inside( uiContext.vPixelCanvasPos, minimizeBoxRect ))\n        return false;\n    \n    vec2 vArrowPos = minimizeBoxRect.vPos + minimizeBoxRect.vSize * 0.5;        \n    vec2 vArrowSize = minimizeBoxRect.vSize * 0.25;\n    vec4 arrowColor = vec4(0.0, 0.0, 0.0, 1.0);\n    if ( !bMinimized )\n    {\n        DrawLine( uiContext.vPixelCanvasPos, vArrowPos + vec2(-1.0, -0.5) * vArrowSize, vArrowPos + vec2(0.0, 0.5) * vArrowSize, 2.0f, arrowColor, uiContext.vWindowOutColor );\n        DrawLine( uiContext.vPixelCanvasPos, vArrowPos + vec2( 1.0, -0.5) * vArrowSize, vArrowPos + vec2(0.0, 0.5) * vArrowSize, 2.0f, arrowColor, uiContext.vWindowOutColor );\n    }\n    else\n    {\n        DrawLine( uiContext.vPixelCanvasPos, vArrowPos + vec2( 0.5, 0.0 )* vArrowSize, vArrowPos + vec2(-0.5, -1.0) * vArrowSize, 2.0f, arrowColor, uiContext.vWindowOutColor );\n        DrawLine( uiContext.vPixelCanvasPos, vArrowPos + vec2( 0.5, 0.0 )* vArrowSize, vArrowPos + vec2(-0.5,  1.0) * vArrowSize, 2.0f, arrowColor, uiContext.vWindowOutColor );\n    }    \n    \n    return true;\n}\n\nbool UI_ProcessWindowMinimizeWidget( inout UIContext uiContext, inout UIWindowState window, int iControlId, Rect minimizeBoxRect )\n{    \n    bool bPressed = UI_ProcessButton( uiContext, iControlId, minimizeBoxRect );\n    \n    if ( bPressed )\n    {\n \t\twindow.bMinimized = !window.bMinimized;        \n    }\n\n    bool bActive = (uiContext.iActiveControl == iControlId);\n    \n    return UI_DrawWindowMinimizeWidget( uiContext, window.bMinimized, minimizeBoxRect );\n}\n\nvoid UI_ProcessScrollbarPanelBegin( inout UIContext uiContext, inout UIPanelState scrollbarState, int iControlId, int iData, Rect scrollbarPanelRect, vec2 vScrollbarCanvasSize )\n{\n    float styleSize = UIStyle_ScrollBarSize();\n    \n\tbool bScrollbarHorizontal = (scrollbarPanelRect.vSize.x < vScrollbarCanvasSize.x);\n    if ( bScrollbarHorizontal )\n    {        \n        scrollbarPanelRect.vSize.y -= styleSize;\n    }\n\n    bool bScrollbarVertical = (scrollbarPanelRect.vSize.y < vScrollbarCanvasSize.y);\n    if ( bScrollbarVertical )\n    {\n        scrollbarPanelRect.vSize.x -= styleSize;\n    }\n\n    \/\/ Adding a vertical scrollbar may mean we now need a horizontal one\n    if ( !bScrollbarHorizontal )\n    {\n        bScrollbarHorizontal = (scrollbarPanelRect.vSize.x < vScrollbarCanvasSize.x);\n        if ( bScrollbarHorizontal )\n        {        \n            scrollbarPanelRect.vSize.y -= styleSize;\n        }\n    }\n    \n    \/\/ Todo : Force enable or disable ?\n\n\tvec4 vData0 = LoadVec4( iChannelUI, ivec2(iData,0) );   \n        \n    UIData_Value scrollValueX;\n    scrollValueX.fRangeMin = 0.0;\n    scrollValueX.fRangeMax = max(0.0, vScrollbarCanvasSize.x - scrollbarPanelRect.vSize.x);\n        \n    UIData_Value scrollValueY;\n    scrollValueY.fRangeMin = 0.0;\n    scrollValueY.fRangeMax = max(0.0, vScrollbarCanvasSize.y - scrollbarPanelRect.vSize.y);\n    \n    if ( iFrame == 0 || vData0.z != DIRTY_DATA_MAGIC )\n    {\n        scrollValueX.fValue = 0.0;\n        scrollValueY.fValue = 0.0;\n    }\n    else\n    {\n        scrollValueX.fValue = vData0.x;\n        scrollValueY.fValue = vData0.y;\n    }    \n    \n    scrollValueX.fValue = clamp( scrollValueX.fValue, scrollValueX.fRangeMin, scrollValueX.fRangeMax );\n    scrollValueY.fValue = clamp( scrollValueY.fValue, scrollValueY.fRangeMin, scrollValueY.fRangeMax );\n    \n    if ( bScrollbarHorizontal )\n    {\n        Rect scrollbarRect;\n        scrollbarRect.vPos = scrollbarPanelRect.vPos;\n        scrollbarRect.vPos.y += scrollbarPanelRect.vSize.y;\n        scrollbarRect.vSize.x = scrollbarPanelRect.vSize.x;\n        scrollbarRect.vSize.y = styleSize;\n        \n        float fHandleSize = scrollbarRect.vSize.x * (scrollbarPanelRect.vSize.x \/ vScrollbarCanvasSize.x);\n\n        if ( uiContext.bPixelInView ) \n        {\n\t        DrawRect( uiContext.vPixelCanvasPos, scrollbarRect, vec4(0.6, 0.6, 0.6, 1.0), uiContext.vWindowOutColor );\n        }        \n        UI_ProcessScrollbarX( uiContext, iControlId, scrollValueX, scrollbarRect, fHandleSize );\n    }\n        \n    if ( bScrollbarVertical )\n    {        \n        Rect scrollbarRect;\n        scrollbarRect.vPos = scrollbarPanelRect.vPos;\n        scrollbarRect.vPos.x += scrollbarPanelRect.vSize.x;\n        scrollbarRect.vSize.x = styleSize;\n        scrollbarRect.vSize.y = scrollbarPanelRect.vSize.y;\n        \n        float fHandleSize = scrollbarRect.vSize.y * (scrollbarPanelRect.vSize.y \/ vScrollbarCanvasSize.y);\n        \n        if ( uiContext.bPixelInView ) \n        {\n\t        DrawRect( uiContext.vPixelCanvasPos, scrollbarRect, vec4(0.6, 0.6, 0.6, 1.0), uiContext.vWindowOutColor );\n        }\n        \n        UI_ProcessScrollbarY( uiContext, iControlId + 1000, scrollValueY, scrollbarRect, fHandleSize );\n    }\n    \n    if ( bScrollbarHorizontal && bScrollbarVertical ) \n    {\n        Rect cornerRect;\n        cornerRect.vPos = scrollbarPanelRect.vPos;\n        cornerRect.vPos += scrollbarPanelRect.vSize;\n        cornerRect.vSize = vec2(styleSize);\n        \n        if ( uiContext.bPixelInView ) \n        {\n            DrawRect( uiContext.vPixelCanvasPos, cornerRect, vec4(cScrollPanelCorner, 1.0), uiContext.vWindowOutColor );\n#ifdef NEW_THEME  \n        \tDrawBorderRect( uiContext.vPixelCanvasPos, cornerRect, cScrollPanelCornerOutline, uiContext.vWindowOutColor );\n#else            \n        \tDrawBorderIndent( uiContext.vPixelCanvasPos, cornerRect, uiContext.vWindowOutColor );\n#endif            \n        }\n    }\n\n    UI_PanelBegin( uiContext, scrollbarState );    \n    \n    vData0.x = scrollValueX.fValue;\n    vData0.y = scrollValueY.fValue;\n    vData0.z = DIRTY_DATA_MAGIC;\n    StoreVec4( ivec2(iData,0), vData0, uiContext.vOutData, ivec2(uiContext.vFragCoord) );    \n        \n            \n    UIDrawContext scrollbarPanelContextDesc = UIDrawContext_SetupFromRect( scrollbarPanelRect );\n    scrollbarPanelContextDesc.vCanvasSize = vScrollbarCanvasSize;\n    scrollbarPanelContextDesc.vOffset = vec2(scrollValueX.fValue, scrollValueY.fValue);\n\n    UIDrawContext scrollbarPanelContext = UIDrawContext_TransformChild( scrollbarState.parentDrawContext, scrollbarPanelContextDesc );\n    UI_SetDrawContext( uiContext, scrollbarPanelContext );\n}\n\nvoid UI_ProcessScrollbarPanelEnd( inout UIContext uiContext, inout UIPanelState scrollbarState )\n{\n    UI_PanelEnd( uiContext, scrollbarState );    \n}\n\n\nvoid UIStyle_GetFontStyleTitle( inout LayoutStyle style, inout RenderStyle renderStyle );\nvoid PrintWindowTitle( inout PrintState state, LayoutStyle style, int controlId );\n\nvec2 UI_WindowGetTitleBarSize( UIContext uiContext, inout UIWindowState window )\n{\n    return vec2(window.drawRect.vSize.x - UIStyle_WindowBorderSize().x * 2.0, UIStyle_TitleBarHeight() );\n}\n\nvoid UI_DrawWindowTitleBar( inout UIContext uiContext, bool bActive, Rect titleBarRect, inout UIWindowState window )\n{   \n\tif (!uiContext.bPixelInView || Outside( uiContext.vPixelCanvasPos, titleBarRect ))\n        return;\n    \n    vec4 colorA = vec4(cTitleBarA, 1.0);\n    vec4 colorB = vec4(cTitleBarB, 1.0);\n       \n    if ( bActive )\n    {\n        colorA.rgb = cTitleBarAActive;\n        colorB.rgb = cTitleBarBActive;\n    }\n\n    float t = (uiContext.vPixelCanvasPos.x - titleBarRect.vPos.x) \/ 512.0;\n    t = clamp( t, 0.0f, 1.0f );\n    uiContext.vWindowOutColor = mix( colorA, colorB, t );\n    \n    {\n        LayoutStyle style;\n        RenderStyle renderStyle;\n        UIStyle_GetFontStyleTitle( style, renderStyle );\n\n        vec2 vTextOrigin = vec2(0);\n        if ( FLAG_SET(window.uControlFlags, WINDOW_CONTROL_FLAG_MINIMIZE_BOX) )\n        {\n        \tvTextOrigin.x += titleBarRect.vSize.y;\n        }\n        \n        PrintState state = UI_PrintState_Init( uiContext, style, vTextOrigin );    \n        PrintWindowTitle( state, style, window.iControlId );    \n        RenderFont( state, style, renderStyle, uiContext.vWindowOutColor.rgb );\n    }\n}\n\nbool UI_ProcessWindowTitleBar( inout UIContext uiContext, inout UIWindowState window )\n{\n    int iWindowTitleBarControlId = window.iControlId;\n    int iWindowMinimizeControlId = window.iControlId + 1000;\n    int iWindowCloseControlId = window.iControlId + 3000;\n    Rect titleBarRect = Rect( vec2(0.0), UI_WindowGetTitleBarSize( uiContext, window ) );\n    \n    bool bRenderedWidget = false;\n    if ( FLAG_SET(window.uControlFlags, WINDOW_CONTROL_FLAG_MINIMIZE_BOX) )\n    {\n        Rect minimizeBoxRect = Rect( vec2(0.0), vec2(titleBarRect.vSize.y) );\n        RectShrink( minimizeBoxRect, vec2(4.0) );\n        \n    \tbRenderedWidget = UI_ProcessWindowMinimizeWidget( uiContext, window, iWindowMinimizeControlId, minimizeBoxRect );\n    }\n\n    if ( FLAG_SET(window.uControlFlags, WINDOW_CONTROL_FLAG_CLOSE_BOX) )\n    {\n        Rect closeBoxRect = Rect( vec2(0.0), vec2(titleBarRect.vSize.y) ); \n        closeBoxRect.vPos.x = titleBarRect.vSize.x - closeBoxRect.vSize.x;\n        RectShrink( closeBoxRect, vec2(4.0) );\n        \n        if( UI_ProcessWindowCloseBox( uiContext, window, iWindowCloseControlId, closeBoxRect ) )\n        {\n            bRenderedWidget = true;\n        }\n    }\n            \n    bool bMouseOver = Inside( uiContext.vMouseCanvasPos, titleBarRect ) && uiContext.bMouseInView;\n        \n    if ( uiContext.iActiveControl == IDC_NONE )\n    {\n        if ( uiContext.bMouseDown && (!uiContext.bMouseWasDown) && bMouseOver && !uiContext.bHandledClick )\n        {\n            uiContext.iActiveControl = iWindowTitleBarControlId;\n            uiContext.vActivePos = window.rect.vPos - uiContext.vMousePos;\n            uiContext.bHandledClick = true;\n        }\n    }\n    else\n    if ( uiContext.iActiveControl == iWindowTitleBarControlId )\n    {\n        if ( !uiContext.bMouseDown )\n        {\n            uiContext.iActiveControl = IDC_NONE;\n        }\n    }    \n    \n    bool bActive = (uiContext.iActiveControl == iWindowTitleBarControlId);\n    \n    if ( bActive )\n    {\n        window.rect.vPos = uiContext.vMousePos + uiContext.vActivePos;\n    }   \n    \n    if (!bRenderedWidget)\n    {\n    \tUI_DrawWindowTitleBar( uiContext, bActive, titleBarRect, window );\n    }\n    \n    return Inside( uiContext.vPixelCanvasPos, titleBarRect );\n}\n\nbool ScreenPosInResizeWidget( inout UIContext uiContext, vec2 vCorner, float fControlSize, vec2 vTestPos )\n{\n    vec2 vTestCanvasPos = UIDrawContext_ScreenPosToCanvasPos( uiContext.drawContext, vTestPos );\n    vec2 vOffset = vTestCanvasPos - vCorner + vec2( fControlSize, 0.0 );\n    bool bInCorner = (vOffset.x + vOffset.y) > 0.0;\n    \n    return bInCorner;\n}\n\nvoid UI_ProcessWindowResizeWidget( inout UIContext uiContext, inout UIWindowState window, int iControlId )\n{\n    vec2 vCorner = uiContext.drawContext.vCanvasSize;\n    float fControlSize = 24.0;\n    \n    bool bMouseOver = ScreenPosInResizeWidget( uiContext, vCorner, fControlSize, uiContext.vMousePos )\n        && uiContext.bMouseInView;\n        \n    if ( uiContext.iActiveControl == IDC_NONE )\n    {\n        if ( uiContext.bMouseDown && (!uiContext.bMouseWasDown) && bMouseOver && !uiContext.bHandledClick)\n        {\n            uiContext.iActiveControl = iControlId;\n            \n            uiContext.vActivePos = window.rect.vSize - uiContext.vMousePos;\n            \n            uiContext.bHandledClick = true;\n        }\n    }\n    else\n    if ( uiContext.iActiveControl == iControlId )\n    {\n        if ( !uiContext.bMouseDown )\n        {\n            uiContext.iActiveControl = IDC_NONE;\n        }\n    }\n        \n    bool bActive = (uiContext.iActiveControl == iControlId);        \n    \n    if ( bActive )\n    {\n        window.rect.vSize = uiContext.vMousePos + uiContext.vActivePos;\n        vec2 vMinWindowSize = vec2( 96.0, 64.0 );\n        window.rect.vSize = max( vMinWindowSize, window.rect.vSize );\n        window.rect.vSize = min( window.vMaxSize, window.rect.vSize );\n    }\n    \n    \n    if ( uiContext.bPixelInView &&\n        ScreenPosInResizeWidget( uiContext, vCorner, fControlSize, uiContext.vPixelPos ) )\n    {\n        vec4 vColor = vec4(cResize, 1.0);\n        \n        if( bActive )\n        {\n            vColor = vec4(cResizeActive, 1.0);\n        }\n        uiContext.vWindowOutColor = vColor;\n    }    \n}\n\nvec2 UI_GetWindowSizeForContent( vec2 vContentSize )\n{\n    return vContentSize \n        + vec2( 0.0, UIStyle_TitleBarHeight() )\n    \t+ UIStyle_WindowBorderSize() * 2.0\n    \t+ UIStyle_WindowContentPadding() * 2.0;\n}\n\nUIWindowState UI_ProcessWindowCommonBegin( inout UIContext uiContext, int iControlId, int iData, UIWindowDesc desc )\n{   \n    UIWindowState window = UI_GetWindowState( uiContext, iControlId, iData, desc );\n        \n    if ( window.bClosed )\n    {\n        return window;\n    }\n    \n    UI_PanelBegin( uiContext, window.panelState );\n    \n    uiContext.vWindowOutColor.rgba = vec4( cWindowBackgroundColor, 1.0 );\n    \n    window.drawRect = window.rect;\n    \n    Rect contextRect = window.drawRect;    \n    RectShrink( contextRect, UIStyle_WindowBorderSize() );\n    \n    vec2 vTitleBarSize = UI_WindowGetTitleBarSize( uiContext, window );\n    if ( window.bMinimized )\n    {\n\t    window.drawRect.vSize.y = vTitleBarSize.y + UIStyle_WindowBorderSize().y * 2.0;\n    }\n    \n    \/\/ Get window main panel view\n    Rect panelRect = contextRect;\n    \n    panelRect.vPos.y += vTitleBarSize.y;\n    panelRect.vSize.y -= vTitleBarSize.y;\n    \n    if ( window.bMinimized )\n    {\n        panelRect.vSize.y = 0.0;\n    }           \n    \n    \n    UIDrawContext panelDesc = UIDrawContext_SetupFromRect( panelRect );\n    UIDrawContext panelContext = UIDrawContext_TransformChild( window.panelState.parentDrawContext, panelDesc );\n    UI_SetDrawContext( uiContext, panelContext );\n    \n    if ( FLAG_SET(window.uControlFlags, WINDOW_CONTROL_FLAG_RESIZE_WIDGET) )\n    {\n        int iWindowResizeControlId = window.iControlId + 2000; \/\/ hack        \n    \tUI_ProcessWindowResizeWidget( uiContext, window, iWindowResizeControlId );\n    }\n            \n    \/\/ Get window content panel view\n    UIDrawContext contentPanelDesc;\n    contentPanelDesc.viewport = Rect( vec2(0.0), uiContext.drawContext.viewport.vSize );\n    RectShrink( contentPanelDesc.viewport, UIStyle_WindowContentPadding() );\n    contentPanelDesc.vOffset = vec2(0);\n    contentPanelDesc.vCanvasSize = contentPanelDesc.viewport.vSize;\n\n    UI_SetDrawContext( uiContext, UIDrawContext_TransformChild( panelContext, contentPanelDesc ) ); \n    \n    return window;\n}\n\nvoid UI_ProcessWindowCommonEnd( inout UIContext uiContext, inout UIWindowState window, int iData )\n{    \n    bool bPixelInPanel = uiContext.bPixelInView;\n    \n    Rect contextRect = window.drawRect;    \n    RectShrink( contextRect, UIStyle_WindowBorderSize() );\n    \n    UIDrawContext windowContextDesc = UIDrawContext_SetupFromRect( contextRect );\n    UIDrawContext windowContext = UIDrawContext_TransformChild( window.panelState.parentDrawContext, windowContextDesc );\n\tUI_SetDrawContext( uiContext, windowContext );\n    \n    bool inTitleBar = false;\n    if (  FLAG_SET(window.uControlFlags, WINDOW_CONTROL_FLAG_TITLE_BAR)  )\n    {\n    \tinTitleBar = UI_ProcessWindowTitleBar( uiContext, window );\n    }\n    \n    UIDrawContext windowBackgroundContextDesc = UIDrawContext_SetupFromRect( window.drawRect );\n    UIDrawContext windowBackgroundContext = UIDrawContext_TransformChild( window.panelState.parentDrawContext, windowBackgroundContextDesc );    \n\n    UI_SetDrawContext( uiContext, windowBackgroundContext );\n    if ( !bPixelInPanel && !inTitleBar )\n    {\n        Rect rect = Rect( vec2(0), window.drawRect.vSize );\n#ifdef NEW_THEME        \n\t    DrawBorderRect( uiContext.vPixelCanvasPos, rect, cWindowBorder, uiContext.vWindowOutColor );                            \n#else        \n\t    DrawBorderOutdent( uiContext.vPixelCanvasPos, rect, uiContext.vWindowOutColor );                    \n#endif\n        \n    }    \n    \n    if ( uiContext.bMouseDown && uiContext.bMouseInView && !uiContext.bHandledClick )\n    {\n        uiContext.bHandledClick = true;\n    }\n    \n    Rect windowRect = uiContext.drawContext.clip;\n\n    UI_PanelEnd( uiContext, window.panelState );\n    UI_ComposeWindowLayer( uiContext, UIStyle_WindowTransparency(), windowRect );\n    \n    UI_StoreWindowState( uiContext, window, iData );    \n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Client Code Below Here\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/#define MAIN_WINDOW_ONLY\n\nfloat \tUIStyle_TitleBarHeight() \t\t{ return 32.0; }\nvec2 \tUIStyle_WindowBorderSize() \t\t{ return vec2(6.0); }\nvec2 \tUIStyle_WindowContentPadding() \t{ return vec2(16.0, 8.0); }\nvec2 \tUIStyle_ControlSpacing() \t\t{ return  vec2(6.0); }\nvec2 \tUIStyle_FontPadding() \t\t\t{ return vec2(8.0, 2.0); }\nvec2 \tUIStyle_CheckboxSize() \t\t\t{ return vec2(24.0); }\nvec2 \tUIStyle_SliderSize()\t\t\t{ return vec2(128.0, 32.0f); }\nvec3 \tUIStyle_ColorPickerSize()\t\t{ return vec3(128.0, 128.0, 32.0); }\nfloat \tUIStyle_ScrollBarSize() \t\t{ return 24.0; }\nfloat   UIStyle_WindowTransparency() \t{ return 0.025f; }\n\nvoid UIStyle_GetFontStyleWindowText( inout LayoutStyle style, inout RenderStyle renderStyle )\n{\n    style = LayoutStyle_Default();\n\trenderStyle = RenderStyle_Default( vec3(0.0) );\n}\n\nvoid UIStyle_GetFontStyleTitle( inout LayoutStyle style, inout RenderStyle renderStyle )\n{\n    style = LayoutStyle_Default();\n\trenderStyle = RenderStyle_Default( cWindowTitle );\n}\n\nvoid PrintWindowTitle( inout PrintState state, LayoutStyle style, int controlId )\n{\n    if ( controlId == IDC_WINDOW_CONTROLS )\n    {\n        uint strA[] = uint[] ( _C, _o, _n, _t, _r, _o, _l, _s );\n        ARRAY_PRINT(state, style, strA);\n    }\n    if ( controlId == IDC_WINDOW_IMAGE_CONTROL )\n    {\n        uint strA[] = uint[] ( _I, _m, _g, _SP, _C, _o, _n, _t, _r, _o, _l );\n        ARRAY_PRINT(state, style, strA);\n    }\n    if ( controlId == IDC_WINDOW_IMAGEA )\n    {\n        uint strA[] = uint[] ( _I, _m, _a, _g, _e, _SP, _A );\n        ARRAY_PRINT(state, style, strA);\n    }\n    if ( controlId == IDC_WINDOW_IMAGEB )\n    {\n        uint strA[] = uint[] ( _I, _m, _a, _g, _e, _SP, _B );\n        ARRAY_PRINT(state, style, strA);\n    }\n    if ( controlId == IDC_WINDOW_EDIT_COLOR )\n    {\n        uint strA[] = uint[] ( _C, _o, _l, _o, _r );\n        ARRAY_PRINT(state, style, strA);\n    }\n}\n\nstruct UIData\n{\n    UIData_Bool backgroundImage;\n    UIData_Bool showImageWindow;\n    UIData_Bool buttonA;\n    \n    UIData_Value backgroundBrightness;\n    UIData_Value backgroundScale;\n    UIData_Value imageBrightness;\n\n    UIData_Value editWhichColor;\n    UIData_Color bgColor;\n    UIData_Color imgColor;\n};    \n\n    \nUIData UI_GetControlData()\n{\n    UIData data;\n    \n    data.backgroundImage = UI_GetDataBool( DATA_BACKGROUND_IMAGE, false );\n    data.showImageWindow = UI_GetDataBool( DATA_CHECKBOX_SHOW_IMAGE, true );\n    data.buttonA = UI_GetDataBool( DATA_BUTTONA, false );\n    \n    data.backgroundBrightness = UI_GetDataValue( DATA_BACKGROUND_BRIGHTNESS, 0.5, 0.0, 1.0 );\n    data.backgroundScale = UI_GetDataValue( DATA_BACKGROUND_SCALE, 10.0, 1.0, 10.0 );\n    data.imageBrightness = UI_GetDataValue( DATA_IMAGE_BRIGHTNESS, 1.0, 0.0, 1.0 );\n    \n    data.editWhichColor = UI_GetDataValue( DATA_EDIT_WHICH_COLOR, -1.0, -1.0, 100.0 );\n    data.bgColor = UI_GetDataColor( DATA_BG_COLOR, vec3(0, 0.5, 0.5) );\n    data.imgColor = UI_GetDataColor( DATA_IMAGE_COLOR, vec3(1.0, 1.0, 1.0) );\n    \n    return data;\n}\n\nvoid UI_StoreControlData( inout UIContext uiContext, UIData data )\n{\n    UI_StoreDataBool( uiContext, data.backgroundImage, DATA_BACKGROUND_IMAGE );\n    UI_StoreDataBool( uiContext, data.showImageWindow, DATA_CHECKBOX_SHOW_IMAGE );\n    UI_StoreDataBool( uiContext, data.buttonA, DATA_BUTTONA );\n\n    UI_StoreDataValue( uiContext, data.backgroundBrightness, DATA_BACKGROUND_BRIGHTNESS );\n    UI_StoreDataValue( uiContext, data.backgroundScale, DATA_BACKGROUND_SCALE );\n    UI_StoreDataValue( uiContext, data.imageBrightness, DATA_IMAGE_BRIGHTNESS );\n    \n    UI_StoreDataValue( uiContext, data.editWhichColor, DATA_EDIT_WHICH_COLOR );\n    UI_StoreDataColor( uiContext, data.bgColor, DATA_BG_COLOR );\n    UI_StoreDataColor( uiContext, data.imgColor, DATA_IMAGE_COLOR );\n}\n\nvoid UI_ProcessWindowImageControl( inout UIContext uiContext, inout UIData uiData, int iControlId, int iData )\n{\n    UIWindowDesc desc;\n    \n    desc.initialRect = Rect( vec2(280, 24), vec2(180, 100) );\n    desc.uControlFlags = WINDOW_CONTROL_FLAG_TITLE_BAR;\n    desc.bStartClosed = false;\n    desc.bStartMinimized = false;\n    desc.bOpenWindow = false;\n    desc.vMaxSize = vec2(100000.0);\n\n    UIWindowState window = UI_ProcessWindowCommonBegin( uiContext, iControlId, iData, desc );\n        \n    \/\/ Controls...\n    if ( UI_ShouldProcessWindow( window ) )\n    {\n\t\tUILayout uiLayout = UILayout_Reset();\n        \n\t\tUILayout_StackControlRect( uiLayout, UIStyle_SliderSize() );\n        UI_ProcessSlider( uiContext, IDC_SLIDER_IMAGE_BRIGHTNESS, uiData.imageBrightness, uiLayout.controlRect );\n    }\n    \n    UI_ProcessWindowCommonEnd( uiContext, window, iData );\n}\n\n\nvoid UI_ProcessWindowImageB( inout UIContext uiContext, inout UIData uiData, int iControlId, int iData )\n{\n    UIWindowDesc desc;\n    \n    desc.initialRect = Rect( vec2(32, 8), vec2(192, 192) );\n    desc.bStartMinimized = false;\n    desc.bStartClosed = false;\n    desc.bOpenWindow = false;   \n    desc.uControlFlags = WINDOW_CONTROL_FLAG_TITLE_BAR | WINDOW_CONTROL_FLAG_MINIMIZE_BOX | WINDOW_CONTROL_FLAG_RESIZE_WIDGET;\n\tdesc.vMaxSize = vec2(100000.0);\n\n    UIWindowState window = UI_ProcessWindowCommonBegin( uiContext, iControlId, iData, desc );\n    \n    \/\/ Controls...\n    if ( UI_ShouldProcessWindow( window ) )\n    {    \n        UI_WriteCanvasUV( uiContext, iControlId );\n    }\n\n    UI_ProcessWindowCommonEnd( uiContext, window, iData );\n}\n\nvoid UI_ProcessWindowImageA( inout UIContext uiContext, inout UIData uiData, int iControlId, int iData )\n{\n    UIWindowDesc desc;\n    \n    vec2 vWindowIdealSize = UI_GetWindowSizeForContent( vec2(512, 512) );\n    desc.initialRect = Rect( vec2(96, 48 - 32), vec2( vWindowIdealSize.x, 350 ) );\n    desc.bStartMinimized = false;\n    desc.bStartClosed = false;\n    desc.bOpenWindow = false;      \n    desc.uControlFlags = WINDOW_CONTROL_FLAG_TITLE_BAR | WINDOW_CONTROL_FLAG_MINIMIZE_BOX | WINDOW_CONTROL_FLAG_RESIZE_WIDGET;\n\n    desc.vMaxSize = vWindowIdealSize;\n\n    UIWindowState window = UI_ProcessWindowCommonBegin( uiContext, iControlId, iData, desc );\n        \n    \/\/ Controls...\n    if ( UI_ShouldProcessWindow( window ) )\n    {        \n        Rect scrollbarPanelRect;\n\n        #if 0\n        \/\/ ScrollBar panel in fixed location\n        scrollbarPanelRect = Rect( vec2(10, 32), vec2(256) );\n        #else\n        \/\/ ScrollBar panel with parent window size        \t\n        scrollbarPanelRect = Rect( vec2(0), uiContext.drawContext.vCanvasSize );\n        #endif\n\n        vec2 vScrollbarCanvasSize = vec2(512);\n\n        UIPanelState scrollbarPanelState;            \n        UI_ProcessScrollbarPanelBegin( uiContext, scrollbarPanelState, IDC_SCROLLBAR_PANEL, DATA_SCROLLBAR_PANEL, scrollbarPanelRect, vScrollbarCanvasSize );\n\n        \/\/ Controls...\n        {\n            UI_ProcessWindowImageControl( uiContext, uiData, IDC_WINDOW_IMAGE_CONTROL, DATA_WINDOW_IMAGE_CONTROL );\n            UI_ProcessWindowImageB( uiContext, uiData, IDC_WINDOW_IMAGEB, DATA_WINDOW_IMAGEB );\n\n            UI_WriteCanvasPos( uiContext, iControlId );\n        }\n\n        UI_ProcessScrollbarPanelEnd(uiContext, scrollbarPanelState);\n    }\n    \n    UI_ProcessWindowCommonEnd( uiContext, window, iData );\n}\n\nvoid PrintRGB( inout PrintState state, LayoutStyle style, vec3 vRGB )\n{\n    PrintCh( state, style, _R );\n    PrintCh( state, style, _COLON );\n\n    Print(state, style, vRGB.r, 2 );\n\n    PrintCh( state, style, _SP );\n    PrintCh( state, style, _G );\n    PrintCh( state, style, _COLON );\n\n    Print(state, style, vRGB.g, 2 );\n\n    PrintCh( state, style, _SP );\n    PrintCh( state, style, _B );\n    PrintCh( state, style, _COLON );\n\n    Print(state, style, vRGB.b, 2 );    \n}\n\nvoid UI_ProcessWindowEditColor( inout UIContext uiContext, inout UIData uiData, int iControlId, int iData )\n{\n    UIWindowDesc desc;\n    \n    desc.initialRect = Rect( vec2(256, 48), vec2(210, 260) );\n    desc.bStartMinimized = false;\n    desc.bStartClosed = false;\n    desc.bOpenWindow = true;        \n    desc.uControlFlags = WINDOW_CONTROL_FLAG_TITLE_BAR | WINDOW_CONTROL_FLAG_CLOSE_BOX;\n    desc.vMaxSize = vec2(100000.0);\n\n    UIWindowState window = UI_ProcessWindowCommonBegin( uiContext, iControlId, iData, desc );\n    \n    bool closeButtonPressed = false;\n    \n    \/\/ Controls...\n    if ( UI_ShouldProcessWindow( window ) )\n    {    \n\t\tUILayout uiLayout = UILayout_Reset();\n        \n        LayoutStyle style;\n        RenderStyle renderStyle;             \n        UIStyle_GetFontStyleWindowText( style, renderStyle );\n        \n        UIData_Color dataColor;\n        \n        if ( uiData.editWhichColor.fValue == 0.0 )\n        {\n            dataColor = uiData.bgColor;\n        }\n        else\n        if ( uiData.editWhichColor.fValue == 1.0 )\n        {\n            dataColor = uiData.imgColor;\n        }\n        \n\t\tUILayout_StackControlRect( uiLayout, UIStyle_ColorPickerSize().xy );                \n        UI_ProcessColorPickerSV( uiContext, IDC_COLOR_PICKER, dataColor, uiLayout.controlRect );\n        UILayout_StackRight( uiLayout );\n\t\tUILayout_StackControlRect( uiLayout, UIStyle_ColorPickerSize().zy );        \n        UI_ProcessColorPickerH( uiContext, IDC_COLOR_PICKER+1000, dataColor, uiLayout.controlRect );\n        UILayout_StackDown( uiLayout );        \n        \n        {\n            style.vSize *= 0.6;\n\n            PrintState state = UI_PrintState_Init( uiContext, style, uiLayout.vCursor );        \n\n            vec3 vRGB = hsv2rgb(dataColor.vHSV);\n            PrintRGB( state, style, vRGB );\n                \n            UI_RenderFont( uiContext, state, style, renderStyle );\n                        \n\t\t\tUILayout_SetControlRectFromText( uiLayout, state, style );\n\t        UILayout_StackDown( uiLayout );            \n\n            style.vSize \/= 0.6;            \n        }\n        \n        if ( uiData.editWhichColor.fValue == 0.0 )\n        {\n            uiData.bgColor = dataColor;\n        }\n        else\n        if ( uiData.editWhichColor.fValue == 1.0 )\n        {\n            uiData.imgColor = dataColor;\n        }\n    \n        {\n            PrintState state = UI_PrintState_Init( uiContext, style, uiLayout.vCursor );        \n            uint strA[] = uint[] ( _O, _k );\n            ARRAY_PRINT(state, style, strA);\n            UI_RenderFont( uiContext, state, style, renderStyle );\n\t\t\tUILayout_SetControlRectFromText( uiLayout, state, style );\n\n            bool buttonPressed = UI_ProcessButton( uiContext, IDC_COLOR_PICKER + 2000, uiLayout.controlRect ); \/\/ Use text for button rect\n            if ( buttonPressed )\n            {\n                window.bClosed = true;\n            }\n\t        UILayout_StackDown( uiLayout );                  \n        }        \n    }\n    \n    UI_ProcessWindowCommonEnd( uiContext, window, iData );\n    \n    if ( window.bClosed )\n    {\n        uiData.editWhichColor.fValue = -1.0;\n        \/\/uiData.backgroundImage.bValue = false;\n    }    \n}\n\nvoid UI_ProcessWindowMain( inout UIContext uiContext, inout UIData uiData, int iControlId, int iData )\n{\n    UIWindowDesc desc;\n    \n    desc.initialRect = Rect( vec2(32, 128), vec2(380, 180) );\n    desc.bStartMinimized = false;\n    desc.bStartClosed = false;\n    desc.bOpenWindow = false;    \n    desc.uControlFlags = WINDOW_CONTROL_FLAG_TITLE_BAR | WINDOW_CONTROL_FLAG_MINIMIZE_BOX | WINDOW_CONTROL_FLAG_RESIZE_WIDGET;    \n    desc.vMaxSize = vec2(100000.0);\n\n    UIWindowState window = UI_ProcessWindowCommonBegin( uiContext, iControlId, iData, desc );\n    \n    if ( UI_ShouldProcessWindow( window ) )\n    {\n        \/\/ Controls...\n\n        UILayout uiLayout = UILayout_Reset();\n               \n        LayoutStyle style;\n        RenderStyle renderStyle;             \n        UIStyle_GetFontStyleWindowText( style, renderStyle );       \n        \n\t\tUILayout_StackControlRect( uiLayout, UIStyle_CheckboxSize() );                \n        UI_ProcessCheckbox( uiContext, IDC_CHECKBOX_BACKGROUND_IMAGE, uiData.backgroundImage, uiLayout.controlRect );\n        UILayout_StackRight( uiLayout );\n        \/\/UILayout_StackDown( uiContext.uiLayout );\n        \n\t\tUILayout_StackControlRect( uiLayout, UIStyle_SliderSize() );                \n        UI_ProcessSlider( uiContext, IDC_SLIDER_BACKGROUND_BRIGHTNESS, uiData.backgroundBrightness, uiLayout.controlRect );\n        UILayout_StackRight( uiLayout );\n\n        {\n        \tPrintState state = UI_PrintState_Init( uiContext, style, uiLayout.vCursor );        \n            uint strA[] = uint[] ( _V, _a, _l, _u, _e, _COLON, _SP );\n\n            ARRAY_PRINT(state, style, strA);\n\n            Print(state, style, uiData.backgroundBrightness.fValue, 2 );\n\n            UI_RenderFont( uiContext, state, style, renderStyle );\n            \n\t\t\tUILayout_SetControlRectFromText( uiLayout, state, style );\n        }\n        \n        UILayout_StackDown( uiLayout );    \n\n\t\tUILayout_StackControlRect( uiLayout, UIStyle_SliderSize() );                \n        UI_ProcessSlider( uiContext, IDC_SLIDER_BACKGROUND_SCALE, uiData.backgroundScale, uiLayout.controlRect );       \n        \/\/UILayout_StackDown( uiContext.uiLayout );    \n        UILayout_StackRight( uiLayout );\n\n        {\n            PrintState state = UI_PrintState_Init( uiContext, style, uiLayout.vCursor );        \n            uint strA[] = uint[] ( _V, _a, _l, _u, _e, _COLON, _SP );\n            ARRAY_PRINT(state, style, strA);\n            Print(state, style, uiData.backgroundScale.fValue, 1 );\n            UI_RenderFont( uiContext, state, style, renderStyle );\n\t\t\tUILayout_SetControlRectFromText( uiLayout, state, style );\n        }\n        UILayout_StackDown( uiLayout );\n                        \n        {\n            \/\/ Draw color swatch\n            vec2 vSwatchSize = vec2( uiLayout.controlRect.vSize.y);\n\t\t\tUILayout_StackControlRect( uiLayout, vSwatchSize );\n            if (uiContext.bPixelInView)\n            {\n                DrawRect( uiContext.vPixelCanvasPos, uiLayout.controlRect, vec4(hsv2rgb(uiData.bgColor.vHSV), 1.0), uiContext.vWindowOutColor );\n            }\n        }\n        \n        bool buttonAPressed = UI_ProcessButton( uiContext, IDC_BUTTONA, uiLayout.controlRect ); \/\/ Get button position from prev control\n        uiData.buttonA.bValue = buttonAPressed; \/\/ Only need to do this if we use it in another buffer\n        \n        if ( buttonAPressed )\n        {\n            uiData.editWhichColor.fValue = 0.0;\n        }        \n        \n        UILayout_StackRight( uiLayout );        \n        {\n            PrintState state = UI_PrintState_Init( uiContext, style, uiLayout.vCursor );\n            uint strA[] = uint[] ( _B, _G, _SP, _C, _o, _l );\n            ARRAY_PRINT(state, style, strA);\n\t\t\tUILayout_SetControlRectFromText( uiLayout, state, style );            \n            UI_RenderFont( uiContext, state, style, renderStyle );\n             \n        }\n                \n        UILayout_StackRight( uiLayout );        \n        \n        {\n            \/\/ Draw color swatch\n            vec2 vSwatchSize = vec2(uiLayout.controlRect.vSize.y);\n\t\t\tUILayout_StackControlRect( uiLayout, vSwatchSize );\n            if (uiContext.bPixelInView)\n            {\n                DrawRect( uiContext.vPixelCanvasPos, uiLayout.controlRect, vec4(hsv2rgb(uiData.imgColor.vHSV), 1.0), uiContext.vWindowOutColor );\n            }\n        }\n\n        bool buttonBPressed = UI_ProcessButton( uiContext, IDC_BUTTONB, uiLayout.controlRect );        \n        \n        if ( buttonBPressed )\n        {\n            uiData.editWhichColor.fValue = 1.0;\n        }        \n\n        UILayout_StackRight( uiLayout );        \n        \n        {\n            PrintState state = UI_PrintState_Init( uiContext, style, uiLayout.vCursor );                    \n            uint strA[] = uint[] ( _I, _M, _G, _SP, _B, _SP, _C, _o, _l );\n            ARRAY_PRINT(state, style, strA);\t\t\t            \n\t\t\tUILayout_SetControlRectFromText( uiLayout, state, style );            \n            UI_RenderFont( uiContext, state, style, renderStyle );            \n        }\n        \n        UILayout_StackDown( uiLayout );        \n        \n        #if 1\n        \/\/ Debug state\n        {\n            PrintState state = UI_PrintState_Init( uiContext, style, uiLayout.vCursor );\n            uint strA[] = uint[] ( _C, _t, _r, _l, _COLON );\n            ARRAY_PRINT(state, style, strA);\n\n            Print(state, style, uiContext.iActiveControl );\n            UI_RenderFont( uiContext, state, style, renderStyle );\n\n            UILayout_SetControlRectFromText( uiLayout, state, style );            \n        }        \n        #endif\n    }    \n    \n    UI_ProcessWindowCommonEnd( uiContext, window, iData );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    UIContext uiContext = UI_GetContext( fragCoord, DATA_UICONTEXT );\n    UIData uiData = UI_GetControlData();\n        \n    \/\/ Content...\n    if ( uiData.editWhichColor.fValue >= 0.0 )\n    {\n\t    UI_ProcessWindowEditColor( uiContext, uiData, IDC_WINDOW_EDIT_COLOR, DATA_WINDOW_EDIT_COLOR );\n    }\n    \n    UI_ProcessWindowMain( uiContext, uiData, IDC_WINDOW_CONTROLS, DATA_WINDOW_CONTROLS );\n\n#ifndef MAIN_WINDOW_ONLY    \n    \n    if ( uiData.showImageWindow.bValue )\n    {\n        UI_ProcessWindowImageA( uiContext, uiData, IDC_WINDOW_IMAGEA, DATA_WINDOW_IMAGEA );\n    }\n    \n    \/\/ Desktop Controls...\n    \n    UILayout uiLayout = UILayout_Reset();\n    \n\tUILayout_StackControlRect( uiLayout, UIStyle_CheckboxSize() );                \n    UI_ProcessCheckbox( uiContext, IDC_CHECKBOX_SHOW_IMAGE, uiData.showImageWindow, uiLayout.controlRect );         \n    UILayout_StackDown( uiLayout );\n#endif    \n    \n    Rect composeRect = uiContext.drawContext.clip;\n    UI_ComposeWindowLayer( uiContext, 0.0f, composeRect );\n\n    UI_StoreControlData( uiContext, uiData );\n    \n    UI_StoreContext( uiContext, DATA_UICONTEXT );\n    \n    fragColor = UI_GetFinalColor( uiContext );    \n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const int\n    DATA_UICONTEXT\t\t\t\t\t\t= 0,\t\n\tDATA_CHECKBOX_SHOW_IMAGE \t\t\t= 1,\n\tDATA_WINDOW_CONTROLS   \t\t\t\t= 2,\n\tDATA_BACKGROUND_IMAGE\t\t\t\t= 3,\n\tDATA_BACKGROUND_BRIGHTNESS\t\t\t= 4,\n\tDATA_BACKGROUND_SCALE        \t\t= 5,\n\tDATA_WINDOW_IMAGE_CONTROL\t\t\t= 6,\n\tDATA_IMAGE_BRIGHTNESS \t\t\t\t= 7,\n\tDATA_WINDOW_IMAGEA\t\t\t\t\t= 8,\n\tDATA_WINDOW_IMAGEB\t\t\t\t\t= 9,\n    DATA_BUTTONA\t\t\t\t\t\t= 10,\n    DATA_BG_COLOR\t\t\t\t\t\t= 11,\n    DATA_IMAGE_COLOR\t\t\t\t\t= 12,\n    DATA_WINDOW_EDIT_COLOR\t\t\t\t= 13,\n    DATA_EDIT_WHICH_COLOR\t\t\t\t= 14,\n    DATA_SCROLLBAR_PANEL\t\t\t\t= 15;\n    \nconst int\n    IDC_CHECKBOX_SHOW_IMAGE \t\t\t= 0,\n\tIDC_WINDOW_CONTROLS      \t\t\t= 1,\n\tIDC_CHECKBOX_BACKGROUND_IMAGE \t\t= 2,\n\tIDC_SLIDER_BACKGROUND_BRIGHTNESS\t= 3,\n\tIDC_SLIDER_BACKGROUND_SCALE        \t= 4,\n\tIDC_WINDOW_IMAGE_CONTROL\t\t\t= 5,\n\tIDC_SLIDER_IMAGE_BRIGHTNESS\t\t\t= 6,\n\tIDC_WINDOW_IMAGEA   \t\t\t\t= 7,\n\tIDC_WINDOW_IMAGEB   \t\t\t\t= 8,\n    IDC_BUTTONA\t\t\t\t\t\t\t= 9,\n    IDC_BUTTONB\t\t\t\t\t\t\t= 10,\n    IDC_WINDOW_EDIT_COLOR       \t\t= 11,\n    IDC_COLOR_PICKER \t\t\t\t\t= 12,\n    IDC_SCROLLBAR_PANEL\t\t\t\t\t= 13;\n\n","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"Xlj3Rh","date":"1426859378","viewed":10185,"name":"[NV15] DIY Spaceman Cave","username":"eiffie","description":"You can tell your under pressure when you turn to glow.","likes":89,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[],"code":"\/\/ DIY Spaceman Cave by eiffie\n\/\/ Stole a bit from kali on this one.\n#define PI 3.1416\n#define SUN vec3(0.73,0.1,0.689)\n\nfloat tym,ftym,ud1,ud2,ud3=0.0;\nint iStop;\nvoid Setup(float t){\n\ttym=t*0.2;\n\tiStop=int(floor(tym));\n\tif(tym<3.4){\n\t\tfloat ft=fract(tym);\n\t\tftym=clamp(ft*5.0,0.0,1.0);\n\t\tif(ft<0.2){ud1=0.66;ud2=ftym*0.33;}\n\t\telse if(ft<0.4){ft=(ft-0.2)*5.0;ud1=mix(0.66,1.0,ft);ud2=mix(0.33,0.0,ft);}\n\t\telse if(ft<0.6){ft=(ft-0.4)*5.0;ud1=1.0;ud2=ft;}\n\t\telse if(ft<0.8){ft=(ft-0.6)*5.0;ud1=1.0-ft;ud2=1.0-ft;}\n\t\telse {ft=(ft-0.8)*5.0;ud1=mix(0.0,0.66,ft);ud2=0.0;}\n\t}else{\n\t\tif(tym<12.0 || mod(tym,6.0)>3.0){\n\t\t\tud1=1.0;\n\t\t\tud2=0.0;\n\t\t\tftym=min(1.0+tym-3.4,2.0);\n\t\t\tud3=clamp(tym*0.2-1.0,0.0,0.4);\n\t\t}else{ud1=1.0;ud2=1.0;ftym=2.0;}\n\t}\n}\n\nvec2 rotate(vec2 v, float angle) {return cos(angle)*v+sin(angle)*vec2(v.y,-v.x);}\n\nfloat Oct(in vec3 p, float r1){p=abs(p);return 0.577*(p.x+p.y+p.z-r1);}\nvec2 TubeFrame(in vec3 p){\n\tp=abs(p);\n\tp.x-=1.0;\n\tvec3 b=vec3(-1.0,ud1,ud2);\n\tfloat t=clamp(dot(p,b)\/dot(b,b),0.0,1.0);\n\treturn vec2(length(p-b*t)-0.03+clamp((abs(fract(t*4.0)-0.5)-0.25)*0.1,0.0,0.01),t);\n}\nvoid Srp(inout vec4 p, inout int iCnt){\n\tp = abs(p)*2.0;\n\tif (p.x<p.y){p.xy = p.yx;iCnt++;}\n\tif (p.x<p.z)p.xz = p.zx;\n\tif (p.y<p.z)p.yz = p.zy;\n\tp.x-=1.0;\n}\n\nfloat DE(in vec3 p0){\n\tvec4 p=vec4(p0,1.0);\n\tint iCnt=0;\n\tfor (int n = 0; n < 3; n++) {\n\t\tif(n==iStop)break;\n\t\tif(n==2 && ud3>0.0)p.yz=rotate(p.yz,ud3);\n\t\tSrp(p,iCnt);\n\t}\n\tvec4 pL=p;\n\tfloat d=100.0;\n\tif(ftym>1.0 && iCnt>1){\n\t\tpL.x+=ftym-2.0;\n\t\td=Oct(pL.xyz,ftym-1.0)\/pL.w;\n\t}\n\tSrp(p,iCnt);\n\tif(ftym<1.0)p=mix(pL,p,ftym);\n\td=min(d,TubeFrame(p.xyz).x\/p.w);\n\treturn d;\n}\nvec4 mcol;\n#define fld vec3(1.,5.,2.)\nfloat AlienTechLikeThingy(in vec3 p,float x){\/\/from kali\n\tp=abs(0.5-fract(p*0.4+tym+x))*1.25;\n\tfloat l=0.0, expsmo=0.0,ot=1000.0;\n\tfor (int i = 0; i < 2; i++) { \n\t\tp=clamp(p,-fld,fld)*2.0-p;\n\t\tp*= -1.5\/min(dot(p, p)+0.005, 1.);\n\t\tp+= fld;\n\t\tfloat pl = l;\n\t\tl = length(p);\n\t\texpsmo+= exp(-1. \/ abs(l - pl));\n\t\tot=min(ot,l);\n\t\tp=clamp(p,-fld,fld)*2.0-p;\n\t\tp\/= min(dot(p, p)+0.01, 1.);\n\t\tp = p* -1.5 + fld;\n\t}\n\tmcol+=ud3*vec4(p.xyz,max(0., 2. - ot) )*0.5;\n\treturn ud3*expsmo;\n}\nfloat CE(in vec3 p0){\n\tfloat x=p0.x;\n\tvec4 p=vec4(p0,1.0);\/\/+sin(p0.yzx*10.0)*0.03*ud3\n\tint iCnt=0;\n\tfor (int n = 0; n < 3; n++) {\n\t\tif(n==iStop)break;\n\t\tif(n==2 && ud3>0.0)p.yz=rotate(p.yz,ud3);\n\t\tSrp(p,iCnt);\n\t}\n\tvec4 pL=p;\n\tfloat d=100.0;\n\tif(ftym>1.0 && iCnt>1){\n\t\tpL.x+=ftym-2.0;\n\t\td=Oct(pL.xyz,ftym-1.0)\/pL.w;\n\t}\n\tSrp(p,iCnt);\n\tif(ftym<1.0)p=mix(pL,p,ftym);\n\tvec2 d2=TubeFrame(p.xyz);\n\td2.x\/=p.w;\n\tif(d2.x<d){\n\t\tmcol+=vec4(vec3(4.0*(1.0-abs(fract(d2.y*4.0)-0.5))),-3.0+d2.y);\/\/abs(sin(d2.y*10.0))),-3.0+d2.y);\n\t\td=d2.x;\n\t}else{\n\t\tif(ud3>0.0)d-=AlienTechLikeThingy(pL.xyz*3.0,x)*0.0325;\n\t}\n\treturn d;\n}\n\nfloat rand(vec2 co){\/\/from Dave Hoskins\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nvec2 rand2(vec2 co){\n    return fract(sin(vec2(dot(co.xy ,vec2(12.9898,78.233)),dot(co.yx,vec2(13.1898,73.231)))) * 43758.5453);\n}\n\nfloat stars(in vec2 p){\n\tfloat d=1.0;\n\tp=p*3.0;\n\tvec2 c=floor(p),f=fract(p),v=vec2(60.0,10.0);\n\tvec2 r=rand2(c)*0.8-f+0.1;\n\tr*=1.0+rand(c.yx);\n\td=min(d,min(length(r*v),length(r*v.yx)));\n\tp=p*(10.0-abs(p.y)*2.0);\n\tc=floor(p);f=fract(p);\n\tr=rand2(c)*0.9-f+0.05;\n\tr*=1.0+rand(c.yx);\n\td=min(d,10.0*length(r));\n\treturn d;\n}\nvec3 Space(in vec3 rd){\n\tvec2 p=vec2(atan(rd.z,rd.x)*1.4,rd.y);\n\tfloat d=stars(p);\n\tvec3 col=vec3(1.0-d-abs(rd.y)*2.0)+rd*0.1;\n\td=pow(max(0.0,dot(SUN,rd)),100.0);\n\tcol+=mix(vec3(0.0,0.2,0.0),10.0*vec3(1.0,0.7,0.4),d);\n\td=pow(max(0.0,dot(SUN.zyx,rd)),200.0);\n\tcol=mix(col,vec3(0.0),d*0.2);\n\treturn col;\n}\n\nfloat Waves(vec2 p, float tm){\n\tfloat h=0.0;\n\tmat2 m=mat2(0.78,1.21,-1.21,0.78);\n\tp+=3.0*sin(p.yx*0.1);\n\tfor(float i=2.0;i<5.0;i+=1.0){\n\t\th+=sin(p.x+sin(p.y+11.0*tm)+tm)\/i;\n\t\tp=p*m;\n\t}\n\treturn clamp(h*0.5+0.75,0.0,1.0);\n}\nfloat shad(in vec3 ro, in vec3 rd, float rnd){\n\tfloat t=abs(DE(ro))*rnd;\n\tfor(int i=0;i<14;i++){\n\t\tt+=abs(DE(ro+rd*t));\n\t}\n\treturn clamp(t,0.0,1.0);\n}\nvec3 scene(in vec3 ro, in vec3 rd, in vec2 uv){\n\tvec3 col=Space(rd),V=normalize(ro)+rd;\n\tfloat rnd=rand(uv),t=rnd*DE(ro),d,dm=0.25,g=0.0;\n\tfor(int i=0;i<48;i++){\n\t\tt+=d=DE(ro+rd*t);\n\t\tdm=min(d,dm);\n\t\tg+=0.04+0.005*rnd;\n\t\tif(t>6.0 || d<0.002)break;\n\t}\n\tg*=g;\n\tif(d<0.01){\t\n\t\tmcol=vec4(0.0);g*=0.5;\n\t\tvec2 v=vec2(0.005,0.0);\n\t\tro+=rd*t;\n\t\tvec3 N=normalize(vec3(CE(ro+v.xyy)-CE(ro-v.xyy),CE(ro+v.yxy)-CE(ro-v.yxy),CE(ro+v.yyx)-CE(ro-v.yyx)));\n\t\tvec3 R=reflect(rd,N);\n\t\tmcol.rgb=abs(sin(mcol.rgb))*0.25+0.5;\n\t\tcol=mcol.rgb*max(0.0,dot(-rd,N))*0.2+mcol.rgb*max(0.0,dot(N,SUN))*shad(ro+N*0.01,SUN,rnd);\n\t\tif(mcol.w>=0.0){\n\t\t\tcol+=clamp(Space(R)*0.5,0.0,0.5);\n\t\t\tcol+=pow(min(mcol.w,1.0), 4.0) * vec3(1.0,0.5,0.1) * (1.0 + sin(tym * 5.0 - ro.y * 10.0) );\/\/stolen from kali\n\t\t}else{\n\t\t\tif(tym<6.0)col+=abs(vec3(sin(tym*6.0),1.0,cos(tym*6.0)))*clamp(mcol.w+10.0*sin(tym*20.0+ro.z+ro.y),0.0,1.0);\n\t\t}\n\t}else{\n\t\tV=normalize(V);\n\t\tuv=-vec2(atan(V.z,V.x),V.y);\n\t\tg*=mix(Waves(uv*20.0,tym*5.0),1.0,min(dm*4.0+(0.4-ud3)*2.5,1.0));\n\t}\n\tcol+=vec3(0.3,0.6,1.0)*g;\n\treturn col;\n}\nmat3 lookat(vec3 fw){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,vec3(0.0,1.0,0.0)));return mat3(rt,cross(rt,fw),fw);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat tim=iTime;\n\tSetup(tim);\n\tvec2 uv=fragCoord.xy\/iResolution.xy;\n\ttim*=0.5;\n\tvec3 ro=vec3(cos(tim),cos(tim*0.3)*0.5,cos(tim*0.7))*min(0.5+tim*0.1+cos(tim*0.4)*0.5,1.5);\n\tvec3 rd=lookat(-ro)*normalize(vec3((fragCoord.xy-0.5*iResolution.xy)\/iResolution.y,1.0));\n\tvec3 color=scene(ro,rd,fragCoord.xy);\n\tcolor=clamp(color,0.0,min(tim,1.0));\n\tfragColor = vec4(color,1.0);\n}\n","name":"","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\/\/chords to Space Oddity intro used without permission\n\n#define PI 3.1416\nfloat rnd(float t){return 2.0*(fract(sin(t+sin(t))*33113.31541)-.5);}\/\/from Dave Hoskins\nfloat noyz(float t){return mix(rnd(floor(t)),rnd(floor(t)+1.0),fract(t));}\n\n#define SPEEDOFSOUND 10.0\n#define DAMPING 1.0\nfloat snd(float time){\n\tfloat a1=noyz(700.0*time)*clamp(time*0.04-1.0,0.0,2.0);\n\tif(time<17.0)a1+=rnd(1764.6*time)*clamp(0.15-fract(time),0.0,1.0);\n\tif(time>17.0 && time<30.0)a1+=sin(time*2764.6*2.0)*clamp(sin(time*4.0)-0.5,0.0,1.0);\n\treturn a1;\n}\nfloat phys(float time, float dist){\n\tfloat tim=time-dist\/SPEEDOFSOUND;\n\treturn snd(tim)*exp(-dist*DAMPING);\n}\nvec3 herert(vec3 fw,vec3 up){\n\tfw=normalize(fw);return normalize(cross(fw,normalize(up)));\n}\n\n\n#define bps 3.0\n\n#define C1 261.63\n#define D1 293.66\n#define E1 329.63\n#define F1 349.23\n#define G1 392.0\n#define A1 440.0\n#define B1 493.88\n\nfloat amp(float t, float b){\n\tt-=b;\n\treturn clamp(t*10.0,0.0,1.0)*exp(-t);\n}\nfloat att(float t){\n\tt=mod(t,32.0);\n\tfloat a=0.0;\n\ta+=amp(t,0.0);\n\ta+=amp(t,3.0);\n\ta+=amp(t,4.0);\n\ta+=amp(t,7.0);\n\ta+=amp(t,9.0);\n\ta+=amp(t,10.0);\n\ta+=amp(t,13.0);\n\ta+=amp(t,14.0);\n\treturn a;\n}\nvec2 mainSound( in int samp,float time)\n{\n\tfloat tim=time*bps,T=time*PI;\n\tfloat EMinor=sin(T*E1)+sin(T*G1)+sin(T*B1)+sin(T*2.0*D1)+sin(T*2.0*E1);\n\tfloat FMajor=sin(T*F1)+sin(T*A1)+sin(T*2.0*C1)+sin(T*2.0*F1);\n\tEMinor*=att(tim);\n\tFMajor*=att(tim+16.0);\n\t\t\n\ttim=time*0.5;\n\tvec3 ro=vec3(cos(tim),cos(tim*0.3)*0.5,cos(tim*0.7))*min(0.5+tim*0.1+cos(tim*0.4)*0.5,1.5);\n\tvec3 rd=-ro;\n\n\tvec3 rt=0.1*herert(rd,vec3(0.0,1.0,0.0));\n\tfloat d1=length(ro-rt),d2=length(ro+rt);\n\tfloat a1=phys(time,d1),a2=phys(time,d2);\n\n\treturn vec2(EMinor,FMajor)*0.2+vec2(a1,a2);\n}\n","name":"","description":"","type":"sound"}]},{"ver":"0.1","info":{"id":"ld3SRr","date":"1457308996","viewed":10171,"name":"Image Based PBR Material","username":"Bers","description":"Importance sampling is used, since no cubemap mipmap available for blurry reflections. Cubemap sampling was HDR-ized and gamma balanced.","likes":203,"published":3,"flags":32,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"\/media\/a\/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"\/media\/ap\/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"\/media\/a\/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"\/media\/ap\/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Author : S\u00c3\u00a9bastien B\u00c3\u00a9rub\u00c3\u00a9\n\/\/ Created : Dec 2015\n\/\/ Modified : Jan 2016\n\/\/\n\/\/ A ShaderToy implementation of Image Based PBR Material.\n\/\/ I struggled quite a bit with the TextureCubes available :\n\/\/ \t\t-One is gamma corrected, the other is not.\n\/\/      -The skylight boundary between low and the high detail Cubemaps won't align\n\/\/       with each other, unless the sky color value is cranked up very much where saturated.\n\/\/       With the Cubemaps \"HDR remapped\", they finally aligned properly.\n\/\/       \n\/\/ Importance Sampling is used, where mipmaps would usually be used in a game engine (much more efficient).\n\/\/ I ended up using a mix between random samples and a fixed sampling pattern.\n\/\/ Random sampling was too jittery, unless a very high sample count was used.\n\/\/\n\/\/ Platic Materials lack a diffuse base. I have a WIP coming for this. It requires another cubemap lightness\n\/\/ hemisphere integration, for the diffuse part. Should be done in a seperate pass, not to kill the framerate.\n\/\/\n\/\/ Regarding the IBL version of the PBR Equation, I also struggled to balance lighting. Most articles\n\/\/ and code examples are about point lights, and some pieces of code I found could not be used in the \n\/\/ IBL Scenario. A popular version of the geometric term as proposed by Disney, for example, has a modified \"k\" value \n\/\/ to \"reduce hotness\", which don't give good results with IBL (edges reflections, at grazing angles, would be\n\/\/ too dark, see Unreal4 2013SiggraphPresentationsNotes pdf link p.3 below).\n\/\/ Also, GGX Distribution term must not be used with IBL, because 1) it will look like garbage and 2)it makes no\n\/\/ sense (for \"perfect\" reflection angles (H==N), GGX value goes to the stratosphere, which you really don't want\n\/\/ with IBL). Energy conservation problems don't show as much with point lights, but they really do with Image Based\n\/\/ Lighting.\n\/\/\n\/\/ HDR Color was choosen arbitrarily. You can change from red to blue using the second rightmost slider.\n\/\/ \n\/\/ Sources:\n\/\/ https:\/\/de45xmedrsdbp.cloudfront.net\/Resources\/files\/2013SiggraphPresentationsNotes-26915738.pdf\n\/\/ https:\/\/seblagarde.wordpress.com\/2011\/08\/17\/feeding-a-physical-based-lighting-mode\/\n\/\/ http:\/\/blog.selfshadow.com\/publications\/s2012-shading-course\/burley\/s2012_pbs_disney_brdf_slides_v2.pdf\n\/\/ https:\/\/www.youtube.com\/watch?v=LP7HgIMv4Qo [impressive realtime materials with Substance, see 16m00s, 25m00s]\n\/\/ http:\/\/sirkan.iit.bme.hu\/~szirmay\/fresnel.pdf\n\/\/ http:\/\/www.codinglabs.net\/article_physically_based_rendering_cook_torrance.aspx\n\/\/ http:\/\/refractiveindex.info\/?shelf=3d&book=liquids&page=water\n\/\/ http:\/\/www.filmetrics.com\/refractive-index-database\/Al\/Aluminium\n\/\/ https:\/\/www.shadertoy.com\/view\/4djSRW Dave Hoskin's hash without sine\n\/\/\n\/\/ License : Creative Commons Non-commercial (NC) license\n\/\/\n\n\/\/----------------------\n\/\/ Constants \nconst float GEO_MAX_DIST   = 50.0;\nconst int MATERIALID_SKY    = 2;\nconst int MATERIALID_SPHERE = 3;\nconst vec3  F_ALU_N  = vec3(1.600,0.912,0.695); \/\/(Red ~ 670 nm; Green ~ 540 nm; Blue ~ 475 nm)\nconst vec3  F_ALU_K  = vec3(8.010,6.500,5.800); \/\/(Red ~ 670 nm; Green ~ 540 nm; Blue ~ 475 nm)\n\n\/\/----------------------\n\/\/ Slider bound globals. Use the slider, don't change the value here.\nfloat ROUGHNESS_AMOUNT       = 0.85;\/\/Valid range : [0-1] 0=shiny, 1=rough map\nfloat SKY_COLOR              = 0.0; \/\/[0.0=Red, 1.0=Blue)\nfloat ABL_LIGHT_CONTRIBUTION = 0.0; \/\/[0-1] Additional ABL Light Contribution\n\n#define saturate(x) clamp(x,0.0,1.0)\n\n\/\/PBR Equation for both (IBL) or (ABL), plastic or metal.\nvec3 PBR_Equation(vec3 V, vec3 L, vec3 N, float roughness, const vec3 ior_n, const vec3 ior_k, const bool metallic, const bool bIBL)\n{\n    float cosT = saturate( dot(L, N) );\n    float sinT = sqrt( 1.0 - cosT * cosT);\n\tvec3 H = normalize(L+V);\n\tfloat NdotH = dot(N,H);\/\/Nn.H;\n\tfloat NdotL = dot(N,L);\/\/Nn.Ln;\n\tfloat VdotH = dot(V,H);\/\/Vn.H;\n    float NdotV = dot(N,V);\/\/Nn.Vn;\n    \n    \/\/Distribution Term\n    float PI = 3.14159;\n    float alpha2 = roughness * roughness;\n    float NoH2 = NdotH * NdotH;\n    float den = NoH2*(alpha2-1.0)+1.0;\n    float D = 1.0; \/\/Distribution term is externalized from IBL version\n    if(!bIBL)\n        D = (NdotH>0.)?alpha2\/(PI*den*den):0.0; \/\/GGX Distribution.\n\t\n    \/\/Fresnel Term\n\tvec3 F;\n    if(metallic)\n    {\n        float cos_theta = 1.0-NdotV;\n        F =  ((ior_n-1.)*(ior_n-1.)+ior_k*ior_k+4.*ior_n*pow(1.-cos_theta,5.))\n\t\t    \/((ior_n+1.)*(ior_n+1.)+ior_k*ior_k);\n    }\n    else \/\/Dielectric (Note: R\/G\/B do not really differ for dielectric materials)\n    {\n        float F0 = pow((1.0 - ior_n.x) \/ (1.0 + ior_n.x),2.0);\n  \t\tF = vec3(F0 + (1.-F0) * pow( 1. - VdotH, 5.));\n    }\n    \n    \/\/Geometric term (Source: Real Shading in Unreal Engine 4 2013 Siggraph Presentation p.3\/59)\n    \/\/k = Schlick model (IBL) : Disney's modification to reduce hotness (point light)\n    float k = bIBL?(roughness*roughness\/2.0):(roughness+1.)*(roughness+1.)\/8.; \n    float Gl = max(NdotL,0.)\/(NdotL*(1.0-k)+k);\n    float Gv = max(NdotV,0.)\/(NdotV*(1.0-k)+k);\n    float G = Gl*Gv;\n    \n    float softTr = 0.1; \/\/ Valid range : [0.001-0.25]. Transition softness factor, close from dot(L,N) ~= 0\n    float angleLim = 0.;\/\/2.75; \/\/ Valid range : [0-0.75]. Compensates for IBL integration suface size.\n    \/\/sinT = 1.;\n    if(bIBL)\n        return (F*G*(angleLim+sinT)\/(angleLim+1.0) \/ (4.*NdotV*saturate(NdotH)*(1.0-softTr)+softTr));\n    else\n        return D*F*G \/ (4.*NdotV*NdotL*(1.0-softTr)+softTr);\n}\n\nvec3 PBR_HDRremap(vec3 c)\n{\n    float fHDR = smoothstep(2.900,3.0,c.x+c.y+c.z);\n    vec3 cRedSky   = mix(c,1.3*vec3(4.5,2.5,2.0),fHDR);\n    vec3 cBlueSky  = mix(c,1.8*vec3(2.0,2.5,3.0),fHDR);\n    return mix(cRedSky,cBlueSky,SKY_COLOR);\n}\n\nvec3 PBR_HDRCubemap(vec3 sampleDir, float LOD_01)\n{\n    vec3 linearGammaColor_sharp = PBR_HDRremap(pow(texture( iChannel2, sampleDir ).rgb,vec3(2.2)));\n    vec3 linearGammaColor_blur  = PBR_HDRremap(pow(texture( iChannel3, sampleDir ).rgb,vec3(1)));\n    vec3 linearGammaColor = mix(linearGammaColor_sharp,linearGammaColor_blur,saturate(LOD_01));\n    return linearGammaColor;\n}\n\n\/\/Arbitrary axis rotation (around u, normalized)\nmat3 PBR_axisRotationMatrix( vec3 u, float ct, float st ) \/\/u=axis, co=cos(t), st=sin(t)\n{\n    return mat3(  ct+u.x*u.x*(1.-ct),     u.x*u.y*(1.-ct)-u.z*st, u.x*u.z*(1.-ct)+u.y*st,\n\t              u.y*u.x*(1.-ct)+u.z*st, ct+u.y*u.y*(1.-ct),     u.y*u.z*(1.-ct)-u.x*st,\n\t              u.z*u.x*(1.-ct)-u.y*st, u.z*u.y*(1.-ct)+u.x*st, ct+u.z*u.z*(1.-ct) );\n}\n\nvec3 PBR_importanceSampling(vec3 sampleDir, float roughness, float e1, float e2, out float range)\n{\n    const float PI = 3.14159;\n    range = atan( roughness*sqrt(e1)\/sqrt(1.0-e1) );\n    float phi = 2.0*PI*e2;\n    \/\/Improve this? https:\/\/blog.selfshadow.com\/2011\/10\/17\/perp-vectors\/\n    vec3 notColinear   = (abs(sampleDir.y)<0.8)?vec3(0,1,0):vec3(1,0,0);\n    vec3 othogonalAxis = normalize(cross(notColinear,sampleDir));\n\tmat3 m1 = PBR_axisRotationMatrix(normalize(othogonalAxis), cos(range), sin(range));\n\tmat3 m2 = PBR_axisRotationMatrix(normalize(sampleDir),     cos(phi),   sin(phi));\n\treturn sampleDir*m1*m2;\n}\n\nvec3 PBR_visitSamples(vec3 V, vec3 N, float roughness, bool metallic, vec3 ior_n, vec3 ior_k )\n{\n    const float MIPMAP_SWITCH  = 0.29; \/\/sampling angle delta (rad) equivalent to the lowest LOD.\n    const ivec2 SAMPLE_COUNT = ivec2(05,15); \/\/(5 random, 15 fixed) samples\n    const vec2 weight = vec2(1.\/float(SAMPLE_COUNT.x),1.\/float(SAMPLE_COUNT.y));\n    float angularRange = 0.;    \n    vec3 vCenter = reflect(-V,N);\n    \n    \/\/Randomized Samples : more realistic, but jittery\n    float randomness_range = 0.75; \/\/Cover only the closest 75% of the distribution. Reduces range, but improves stability.\n    float fIdx = 0.0;              \/\/valid range = [0.5-1.0]. Note : it is physically correct at 1.0.\n    vec3 totalRandom = vec3(0.0);\n    for(int i=0; i < SAMPLE_COUNT[0]; ++i)\n    {\n        \/\/Random noise from DaveHoskin's hash without sine : https:\/\/www.shadertoy.com\/view\/4djSRW\n        vec3 p3 = fract(vec3(fIdx*10.0+vCenter.xyx*100.0) * vec3(.1031,.11369,.13787)); \n    \tp3 += dot(p3.zxy, p3.yzx+19.19);\n    \tvec2 jitter = fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n        vec3 sampleDir    = PBR_importanceSampling(vCenter, roughness, jitter.x*randomness_range, jitter.y, angularRange);\n        vec3 sampleColor  = PBR_HDRCubemap( sampleDir, angularRange\/MIPMAP_SWITCH);\n        vec3 contribution = PBR_Equation(V, sampleDir, N, roughness, ior_n, ior_k, metallic, true)*weight[0];\n    \ttotalRandom += contribution*sampleColor;\n\t\t++fIdx;\n    }\n    \n    \/\/Fixed Samples : More stable, but can create sampling pattern artifacts (revealing the sampling pattern)\n    fIdx = 0.0;\n    vec3 totalFixed = vec3(0.0);\n    for(int i=0; i < SAMPLE_COUNT[1]; ++i)\n    {\n        vec2 jitter = vec2( clamp(weight[1]*fIdx,0.0,0.50), fract(weight[1]*fIdx*1.25)+3.14*fIdx); \/\/Fixed sampling pattern.\n        vec3 sampleDir    = PBR_importanceSampling(vCenter, roughness, jitter.x, jitter.y, angularRange);\n        vec3 sampleColor  = PBR_HDRCubemap( sampleDir, angularRange\/MIPMAP_SWITCH);\n        vec3 contribution = PBR_Equation(V, sampleDir, N, roughness, ior_n, ior_k, metallic, true)*weight[1];\n        totalFixed += contribution*sampleColor;\n\t\t++fIdx;\n    }\n    \n    return (totalRandom*weight[1]+totalFixed*weight[0])\/(weight[0]+weight[1]);\n}\n\nvec4 MAT_triplanarTexturing(vec3 p, vec3 n)\n{\n    p = fract(p+0.5);\n    \n    float sw = 0.20; \/\/stiching width\n    vec3 stitchingFade = vec3(1.)-smoothstep(vec3(0.5-sw),vec3(0.5),abs(p-0.5));\n    \n    float fTotal = abs(n.x)+abs(n.y)+abs(n.z);\n    vec4 cX = abs(n.x)*texture(iChannel1,p.zy);\n    vec4 cY = abs(n.y)*texture(iChannel1,p.xz);\n    vec4 cZ = abs(n.z)*texture(iChannel1,p.xy);\n    \n    return  vec4(stitchingFade.y*stitchingFade.z*cX.rgb\n                +stitchingFade.x*stitchingFade.z*cY.rgb\n                +stitchingFade.x*stitchingFade.y*cZ.rgb,cX.a+cY.a+cZ.a)\/fTotal;\n}\n\nstruct TraceData\n{\n    float rayLen; \/\/Run Distance\n    vec3  rayDir; \/\/Run Direction\n    vec3  normal; \/\/Hit normal\n    int   matID;  \/\/Hit material ID\n};\n\n\/\/The main material function.\nvec3 MAT_apply(vec3 pos, TraceData traceData)\n{\n    \/\/Roughness texture\n    vec4 roughnessBuffer = MAT_triplanarTexturing(pos*1.5,traceData.normal);\n    roughnessBuffer += MAT_triplanarTexturing(pos*1.5+0.75,traceData.normal);\n    float roughness = (roughnessBuffer.x+roughnessBuffer.y+roughnessBuffer.z)\/3.0;\n    roughness = roughnessBuffer.w+saturate(roughness-1.00+ROUGHNESS_AMOUNT)*0.25;\n    \n    \/\/IBL and ABL PBR Lighting\n    vec3 rd  = traceData.rayDir;\n    vec3 V = normalize(-traceData.rayDir);\n    vec3 N = traceData.normal;\n    vec3 L = normalize(vec3(1,1,0));\n    vec3 col = PBR_visitSamples(V,N,roughness, true, F_ALU_N, F_ALU_K);\n    vec3 L0  = PBR_Equation(V,L,N,roughness+0.01, F_ALU_N, F_ALU_K, true, false);\n    col     += PBR_HDRremap(vec3(1))*L0*ABL_LIGHT_CONTRIBUTION;\n    \n    \/\/Anti-aliasing trick (normal-based)\n    vec3 backgroundColor = pow(texture( iChannel2, traceData.rayDir ).xyz,vec3(2.2));\n    float aaAmount = 0.095;\n    float smoothFactor = 1.0-clamp(-dot(N,traceData.rayDir)\/(aaAmount), 0.0, 1.0);\n    col = (dot(N,-traceData.rayDir)<aaAmount)? mix(col, backgroundColor, smoothFactor) : col;\n    \n    return traceData.matID==MATERIALID_SKY?backgroundColor:col;\n}\n\nfloat map( in vec3 pos )\n{\n    const float GEO_SPHERE_RAD = 0.5;\n    return length(pos)-GEO_SPHERE_RAD;\n}\n\n\/\/o=ray origin, d=ray direction\nTraceData TRACE_geometry(vec3 o, vec3 d)\n{\n    float t = 0.0;\n    float tmax = GEO_MAX_DIST;\n    float dist = GEO_MAX_DIST;\n    for( int i=0; i<50; i++ )\n    {\n\t    dist = map( o+d*t );\n        if( abs(dist)<0.001 || t>GEO_MAX_DIST ) break;\n        t += dist;\n    }\n    \n    vec3 dfHitPosition  = o+t*d;\n    bool bBackground = (dist>0.01 || t>GEO_MAX_DIST);\n    \n    return TraceData(t,d,normalize(dfHitPosition),bBackground?MATERIALID_SKY:MATERIALID_SPHERE);\n}\n\nvec4 processSliders(in vec2 fragCoord)\n{\n    vec4 sliderVal = texture(iChannel0,vec2(0,0));\n\tROUGHNESS_AMOUNT        = sliderVal[1];\n    SKY_COLOR               = sliderVal[2];\n    ABL_LIGHT_CONTRIBUTION  = sliderVal[3];\n    \n    if(length(fragCoord.xy-vec2(0,0))>1.)\n    {\n    \treturn texture(iChannel0,fragCoord.xy\/iResolution.xy);\n    }\n    return vec4(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/Camera & setup\n    vec4 cSlider = processSliders(fragCoord);\n    float rotX = ((iMouse.z>0.)&&any(lessThan(iMouse.xy\/iResolution.xy,vec2(0.9,0.80))))?\n\t             ((iMouse.x\/iResolution.x)*2.0*3.14) : (iTime*0.3);\n    vec2 uv = 2.5*(fragCoord.xy-0.5*iResolution.xy) \/ iResolution.xx;\n    vec3 camO = vec3(cos(rotX),0.4,sin(rotX))*0.95;\n    vec3 camD = normalize(vec3(0)-camO);\n    vec3 camR = normalize(cross(camD,vec3(0,1,0)));\n    vec3 camU = cross(camR,camD);\n   \tvec3 dir =  normalize(uv.x*camR+uv.y*camU+camD);\n    \n    \/\/Raytrace\n    TraceData geometryTraceData = TRACE_geometry(camO, dir);\n    vec3 ptGeo = (geometryTraceData.rayLen < GEO_MAX_DIST)? camO+dir*geometryTraceData.rayLen : vec3(0);\n    \n    \/\/Material\n    vec3 c = MAT_apply(ptGeo,geometryTraceData).xyz;\n    \n    \/\/Post-processing\n    float sin2 = dot(uv\/1.6,uv\/1.6);\n    float vignetting = pow(1.0-min(sin2*sin2,1.0),2.);\n    c = pow(c*vignetting,vec3(0.4545)); \/\/2.2 Gamma compensation\n    \n    \/\/Slider overlay\n    fragColor = vec4(mix(c,cSlider.rgb,cSlider.a),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ Buffer A : Sliders\n\/\/\n\/\/ Author : S\u00c3\u00a9bastien B\u00c3\u00a9rub\u00c3\u00a9\n\/\/ Created : Dec 2015\n\/\/ Modified : Mar 2016\n#define saturate(x) clamp(x,0.0,1.0)\nvec4 sliderVal = vec4(0.30,0.75,0.0,0.10); \/\/Default slider values [0-1]\n\nvoid SLIDER_setValue(float idx, float val)\n{\n    if(idx<0.) return;\n    else if(idx<0.25) sliderVal[0] = saturate(val);\n\telse if(idx<0.50) sliderVal[1] = saturate(val);\n\telse if(idx<0.75) sliderVal[2] = saturate(val);\n\telse if(idx<1.00) sliderVal[3] = saturate(val);\n}\n\nfloat SLIDER_getValue(float idx)\n{\n    if     (idx<0.25) return sliderVal[0];\n    else if(idx<0.50) return sliderVal[1];\n    else if(idx<0.75) return sliderVal[2];\n    else if(idx<1.00) return sliderVal[3];\n\telse return 0.;\n}\n\nvoid SLIDER_init(vec2 mousePos, vec2 cMin, vec2 cMax )\n{\n    vec4 cPingPong = texture(iChannel0,vec2(0));\n    if(length(cPingPong)>0.001)\n        sliderVal = cPingPong;\n        \n    float width = cMax.x-cMin.x;\n    float height = cMax.y-cMin.y;\n    if(mousePos.x>cMin.x && mousePos.x<cMax.x &&\n       mousePos.y>cMin.y && mousePos.y<cMax.y )\n    {\n        float t = (mousePos.y-cMin.y)\/height;\n        t = clamp(t\/0.75-0.125,0.,1.); \/\/25% top\/bottom margins\n\t\tSLIDER_setValue((mousePos.x-cMin.x)\/width, t);\n    }\n}\n\n\/\/Returns the distance from point \"p\" to a given line segment defined by 2 points [a,b]\nfloat UTIL_distanceToLineSeg(vec2 p, vec2 a, vec2 b)\n{\n    \/\/       p\n    \/\/      \/\n    \/\/     \/\n    \/\/    a--e-------b\n    vec2 ap = p-a;\n    vec2 ab = b-a;\n    \/\/Scalar projection of ap in the ab direction = dot(ap,ab)\/|ab| : Amount of ap aligned towards ab\n    \/\/Divided by |ab| again, it becomes normalized along ab length : dot(ap,ab)\/(|ab||ab|) = dot(ap,ab)\/dot(ab,ab)\n    \/\/The clamp provides the line seg limits. e is therefore the \"capped orthogogal projection\", and length(p-e) is dist.\n    vec2 e = a+clamp(dot(ap,ab)\/dot(ab,ab),0.0,1.0)*ab;\n    return length(p-e);\n}\n\n\/\/uv = slider pixel in local space [0-1], t = slider value [0-1], ar = aspect ratio (w\/h)\nvec4 SLIDER_drawSingle(vec2 uv, float t, vec2 ar, bool bHighlighted)\n{\n    const vec3  ITEM_COLOR = vec3(1);\n    const vec3  HIGHLIGHT_COLOR = vec3(0.2,0.7,0.8);\n    const float RAD = 0.05;  \/\/Cursor radius, in local space\n    const float LW  = 0.030; \/\/Line width\n    float aa  = 14.\/iResolution.x; \/\/antialiasing width (smooth transition)\n    vec3 selectionColor = bHighlighted?HIGHLIGHT_COLOR:ITEM_COLOR;\n    vec3 cheapGloss   = 0.8*selectionColor+0.2*smoothstep(-aa,aa,uv.y-t-0.01+0.01*sin(uv.x*12.));\n    vec2 bottomCenter = vec2(0.5,0.0);\n\tvec2 topCenter    = vec2(0.5,1.0);\n    vec2 cursorPos    = vec2(0.5,t);\n    float distBar = UTIL_distanceToLineSeg(uv*ar, bottomCenter*ar, topCenter*ar);\n    float distCur = length((uv-cursorPos)*ar)-RAD;\n    float alphaBar = 1.0-smoothstep(2.0*LW-aa,2.0*LW+aa, distBar);\n    float alphaCur = 1.0-smoothstep(2.0*LW-aa,2.0*LW+aa, distCur);\n    vec4  colorBar = vec4(mix(   vec3(1),vec3(0),smoothstep(LW-aa,LW+aa, distBar)),alphaBar);\n    vec4  colorCur = vec4(mix(cheapGloss,vec3(0),smoothstep(LW-aa,LW+aa, distCur)),alphaCur);\n    return mix(colorBar,colorCur,colorCur.a);\n}\n\n#define withinUnitRect(a) (a.x>=0. && a.x<=1. && a.y>=0. && a.y<=1.0)\nvec4 SLIDER_drawAll(vec2 uv, vec2 cMin, vec2 cMax, vec2 muv)\n{\n    float width = cMax.x-cMin.x;\n    float height = cMax.y-cMin.y;\n    vec2 ar = vec2(0.30,1.0);\n    uv  = (uv -cMin)\/vec2(width,height); \/\/pixel Normalization\n    muv = (muv-cMin)\/vec2(width,height); \/\/mouse Normalization\n    if( withinUnitRect(uv) )\n    {\n        float t = SLIDER_getValue(uv.x);\n\t\tbool bHighlight = withinUnitRect(muv) && abs(floor(uv.x*4.0)-floor(muv.x*4.0))<0.01;\n\t\tuv.x = fract(uv.x*4.0); \/\/repeat 4x\n\t\tuv.y = uv.y\/0.75-0.125; \/\/25% margins\n        return SLIDER_drawSingle(uv,t,ar,bHighlight);\n    }\n    return vec4(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 cMinSliders = vec2(0.9,0.80);\n    vec2 cMaxSliders = vec2(1.0,1.00);\n    vec2 uvSliders = fragCoord.xy \/ iResolution.xy;\n    vec2 mousePos = iMouse.xy \/ iResolution.xy;\n    SLIDER_init(mousePos, cMinSliders, cMaxSliders);\n    vec4 cSlider = SLIDER_drawAll(uvSliders,cMinSliders, cMaxSliders, mousePos);\n    \n    if(length(fragCoord.xy-vec2(0,0))<1.) \n        fragColor = sliderVal;\n\telse fragColor = cSlider;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XdXGzn","filepath":"\/media\/a\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"\/media\/ap\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/\/ Buffer B : Material Roughness map\n\/\/\n\/\/ Author : S\u00c3\u00a9bastien B\u00c3\u00a9rub\u00c3\u00a9\n\/\/\n\/\/ This is just noise, you could implement whatever roughness map you want.\n\/\/ This needs some clean-up, as it was originally coded as 3D noise, but only a 2D slice is used here.\n\n#define saturate(x) clamp(x,0.0,1.0)\nfloat UTIL_distanceToLineSeg(vec2 p, vec2 a, vec2 b)\n{\n    \/\/Scalar projection of ap in the ab direction = dot(ap,ab)\/|ab| : Amount of ap aligned towards ab\n    \/\/Divided by |ab| again, it becomes normalized along ab length : dot(ap,ab)\/(|ab||ab|) = dot(ap,ab)\/dot(ab,ab)\n    \/\/The clamp provides the line seg limits. e is therefore the \"capped orthogogal projection\".\n    \/\/       p\n    \/\/      \/\n    \/\/     \/\n    \/\/    a--e-------b\n    vec2 ap = p-a;\n    vec2 ab = b-a;\n    vec2 e = a+clamp(dot(ap,ab)\/dot(ab,ab),0.0,1.0)*ab;\n    return length(p-e);\n}\nvec2 noise(vec2 p)\n{\n    return texture(iChannel1,p,-100.0).xy;\n}\nstruct repeatInfo\n{\n\tvec2 pRepeated;\n    vec2 anchor;\n};\nrepeatInfo UTIL_repeat(vec2 p, float interval)\n{\n    repeatInfo rInfo;\n    rInfo.pRepeated = p \/ interval; \/\/Normalize\n    rInfo.pRepeated = fract(rInfo.pRepeated+0.5)-0.5; \/\/centered fract\n    rInfo.pRepeated *= interval; \/\/Rescale\n    rInfo.anchor = p-rInfo.pRepeated;\n    return rInfo;\n}\nfloat MAT_scratchTexture(vec2 p)\n{\n    const float squareWidth = 0.10*2.0;\n    const float moveAmp   = squareWidth*0.75;\n    const float lineWidth = 0.0005;\n    float repeatInterval = squareWidth+moveAmp;\n    repeatInfo rInfo = UTIL_repeat(p,repeatInterval);\n    float margin = repeatInterval-squareWidth;\n    \n    vec2 a = moveAmp*noise(rInfo.anchor);\n    vec2 b = -moveAmp*noise(rInfo.anchor+10.0);\n    float dseg = 1000.0*UTIL_distanceToLineSeg(rInfo.pRepeated, a, b)\/squareWidth;\n    return saturate(10.0\/dseg-0.5)*0.25;\n}\n\nfloat MAT_layeredScratches(vec2 p)\n{\n    const mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n    float I = MAT_scratchTexture(p);\n    p = m2*p;\n    I += MAT_scratchTexture(p*1.11+2.0);\n    p = m2*p;\n    I += MAT_scratchTexture(p*1.24+3.8);\n    p = m2*p;\n    I += MAT_scratchTexture(p*1.34+5.3);\n    p = m2*p;\n    I += MAT_scratchTexture(p*1.34+5.3);\n    p = m2*p;\n    I += MAT_scratchTexture(p*1.34+5.3);\n        \n    return I;\n}\n\nfloat MAT_triplanarScratches(vec3 p, vec3 n)\n{\n    \/\/Idea from http:\/\/http.developer.nvidia.com\/GPUGems3\/gpugems3_ch01.html\n    \/\/Figure 1-23 Triplanar Texturing\n    float fTotal = abs(n.x)+abs(n.y)+abs(n.z);\n    return ( abs(n.x)*MAT_layeredScratches(p.zy)\n            +abs(n.y)*MAT_layeredScratches(p.xz)\n            +abs(n.z)*MAT_layeredScratches(p.xy))\/fTotal;\n}\n\nvec4 NOISE_trilinearWithDerivative(vec3 p)\n{\n    \/\/Trilinear extension over noise derivative from (Elevated), & using the noise stacking trick from (Clouds).\n\t\/\/Inspiration & Idea from :\n    \/\/https:\/\/www.shadertoy.com\/view\/MdX3Rr (Elevated)\n    \/\/https:\/\/www.shadertoy.com\/view\/XslGRr (Clouds)\n    \n    \/\/For more information, see also:\n    \/\/NoiseVolumeExplained : https:\/\/www.shadertoy.com\/view\/XsyGWz\n\t\/\/2DSignalDerivativeViewer : https:\/\/www.shadertoy.com\/view\/ldGGDR\n    \n    const float TEXTURE_RES = 256.0; \/\/Noise texture resolution\n    vec3 pixCoord = floor(p);\/\/Pixel coord, integer [0,1,2,3...256...]\n    \/\/noise volume stacking trick : g layer = r layer shifted by (37x17 pixels)\n    \/\/(37x17)-> this value is the actual translation embedded in the noise texture, can't get around it.\n\t\/\/Note : shift is different from g to b layer (but it also works)\n    vec2 layer_translation = -pixCoord.z*vec2(37.0,17.0)\/TEXTURE_RES; \n    \n    vec2 c1 = texture(iChannel2,layer_translation+(pixCoord.xy+vec2(0,0)+0.5)\/TEXTURE_RES,-100.0).rg;\n    vec2 c2 = texture(iChannel2,layer_translation+(pixCoord.xy+vec2(1,0)+0.5)\/TEXTURE_RES,-100.0).rg; \/\/+x\n    vec2 c3 = texture(iChannel2,layer_translation+(pixCoord.xy+vec2(0,1)+0.5)\/TEXTURE_RES,-100.0).rg; \/\/+z\n    vec2 c4 = texture(iChannel2,layer_translation+(pixCoord.xy+vec2(1,1)+0.5)\/TEXTURE_RES,-100.0).rg; \/\/+x+z\n    \n    vec3 x = p-pixCoord; \/\/Pixel interpolation position, linear range [0-1] (fractional part)\n    \n    vec3 x2 = x*x;\n    vec3 t = (6.*x2-15.0*x+10.)*x*x2; \/\/Quintic ease-in\/ease-out function.\n    vec3 d_xyz = (30.*x2-60.*x+30.)*x2; \/\/dt\/dx : Ease-in ease-out derivative.\n    \n    \/\/Lower quad corners\n    float a = c1.x; \/\/(x+0,y+0,z+0)\n    float b = c2.x; \/\/(x+1,y+0,z+0)\n    float c = c3.x; \/\/(x+0,y+1,z+0)\n    float d = c4.x; \/\/(x+1,y+1,z+0)\n    \n    \/\/Upper quad corners\n    float e = c1.y; \/\/(x+0,y+0,z+1)\n    float f = c2.y; \/\/(x+1,y+0,z+1)\n    float g = c3.y; \/\/(x+0,y+1,z+1)\n    float h = c4.y; \/\/(x+1,y+1,z+1)\n    \n    \/\/Trilinear noise interpolation : (1-t)*v1+(t)*v2, repeated along the 3 axis of the interpolation cube.\n    float za = ((a+(b-a)*t.x)*(1.-t.y)\n               +(c+(d-c)*t.x)*(   t.y));\n    float zb = ((e+(f-e)*t.x)*(1.-t.y)\n               +(g+(h-g)*t.x)*(   t.y));\n    float value = (1.-t.z)*za+t.z*zb;\n    \n    \/\/Derivative scaling (texture lookup slope, along interpolation cross sections).\n    \/\/This could be factorized\/optimized but I fear it would make it cryptic.\n    float sx =  ((b-a)+t.y*(a-b-c+d))*(1.-t.z)\n               +((f-e)+t.y*(e-f-g+h))*(   t.z);\n    float sy =  ((c-a)+t.x*(a-b-c+d))*(1.-t.z)\n               +((g-e)+t.x*(e-f-g+h))*(   t.z);\n    float sz =  zb-za;\n    \n    return vec4(value,d_xyz*vec3(sx,sy,sz));\n}\n\nfloat ROUGHNESS_MAP_UV_SCALE = 6.00;\/\/Valid range : [0.1-100.0]\n\n\/\/Stacked perlin noise\nvec3 NOISE_volumetricRoughnessMap(vec3 p, float rayLen)\n{\n    vec4 sliderVal = vec4(0.5,0.85,0,0.5);\n    ROUGHNESS_MAP_UV_SCALE *= 0.1*pow(10.,2.0*sliderVal[0]);\n    \n    float f = iTime;\n    const mat3 R1  = mat3(0.500, 0.000, -.866,\n\t                     0.000, 1.000, 0.000,\n                          .866, 0.000, 0.500);\n    const mat3 R2  = mat3(1.000, 0.000, 0.000,\n\t                      0.000, 0.500, -.866,\n                          0.000,  .866, 0.500);\n    const mat3 R = R1*R2;\n    p *= ROUGHNESS_MAP_UV_SCALE;\n    p = R1*p;\n    vec4 v1 = NOISE_trilinearWithDerivative(p);\n    p = R1*p*2.021;\n    vec4 v2 = NOISE_trilinearWithDerivative(p);\n    p = R1*p*2.021+1.204*v1.xyz;\n    vec4 v3 = NOISE_trilinearWithDerivative(p);\n    p = R1*p*2.021+0.704*v2.xyz;\n    vec4 v4 = NOISE_trilinearWithDerivative(p);\n    \n    return (v1\n\t      +0.5*(v2+0.25)\n\t      +0.4*(v3+0.25)\n\t      +0.6*(v4+0.25)).yzw;\n}\n\nvoid processSliders(in vec2 fragCoord)\n{\n    vec4 sliderVal = texture(iChannel0,vec2(0,0));\n\tROUGHNESS_MAP_UV_SCALE *= 0.1*pow(10.,2.0*sliderVal[0]);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    processSliders(fragCoord);\n    vec2 uv = 3.0*fragCoord.xy\/iResolution.xy;\n    vec3 roughnessNoise = NOISE_volumetricRoughnessMap(vec3(2.0*uv,0),1.0).rgb;\n    float scratchTex = MAT_scratchTexture(2.0*uv);\n    scratchTex += MAT_layeredScratches(uv+0.25);\n    scratchTex += MAT_layeredScratches(1.7*uv+vec2(0.35));\n    scratchTex += MAT_scratchTexture(uv+vec2(1.15));\n    scratchTex += MAT_scratchTexture(uv+vec2(2.75));\n    fragColor = vec4(roughnessNoise,scratchTex*0.3);\n}","name":"Buffer B","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"Mlt3Wn","date":"1469019958","viewed":10140,"name":"[SH16C] Stubble Bobble","username":"stubbe","description":"As much of the old classic as I could reimplement in GLSL in a week. I think I managed to cover most of the essential features. Unsurprisingly, the gameplay logic would prove to be the real challenge.\n\nArrows + Space.","likes":88,"published":3,"flags":56,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ONLY_INTEGER_SCALING 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 targetSize = vec2(32.,27.)*8.;\n    vec2 tmp = iResolution.xy \/ targetSize;\n    float scale = min(tmp.x, tmp.y);\n#if ONLY_INTEGER_SCALING\n    scale = floor(scale);\n#endif\n    vec2 windowOffset = floor((iResolution.xy - targetSize*scale)*.5);\n    \n    vec2 coord = (fragCoord- windowOffset) \/ scale;\n    if(coord.x < 0.0 || coord.y < 0.0 || coord.x >= targetSize.x || coord.y >= targetSize.y)\n    {\n        fragColor.xyz = vec3(0.0);\n        return;\n    }\n    \n    fragColor = texture(iChannel0, coord \/ iChannelResolution[0].xy) ;\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"XsfGRr","channel":0}],"code":"const float BPM = 125.0;\nconst float SPEED = 6.0;\nconst float ROWS_PER_SEC = BPM * 24.0 \/ (60.0 * SPEED);\nconst float SEC_PER_ROW = 1.0 \/ ROWS_PER_SEC;\n\nconst int\tPATTERN0_LENGTH = 153;\nconst int\tPATTERN_LENGTH = 64;\nconst int \tNUM_PATTERNS = 7;\n\nconst float PI = 3.1415926535;\n\nconst int C  = 0;\nconst int Cs = 1;\nconst int D  = 2;\nconst int Ds = 3;\nconst int E  = 4;\nconst int F  = 5;\nconst int Fs = 6;\nconst int G  = 7;\nconst int Gs = 8;\nconst int A  = 9;\nconst int As = 10;\nconst int B  = 11;\nconst int X  = -1;\n\n#define N(_pos, _note, _octave) if(row >= (_pos)) { note = ((_octave)*12 + (_note)); hitRow = baseRow + (_pos); }\n\nint imod(int x, int m)\n{\n    return x - x \/ m * m;\n}\n\nint Data(float time, int track, out float envTime)\n{\n    int globalRow = int(time * ROWS_PER_SEC);\n    \n    int baseRow = 0;\n    int pattern = 0;\n    int row = globalRow;\n    \n    if(globalRow >= PATTERN0_LENGTH)\n    {\n        int m = NUM_PATTERNS - 1;\n        \n        int tmp = globalRow - PATTERN0_LENGTH;\n        \n        row = imod(tmp, PATTERN_LENGTH);\n        \n        pattern = tmp \/ PATTERN_LENGTH;\n        int numRepeats = pattern \/ m;\n        pattern = imod(pattern, m);\n        \n        baseRow = PATTERN0_LENGTH + (numRepeats*m+pattern) * PATTERN_LENGTH;\n        pattern++;\n    }\n    \n    int hitRow = -10;\n    int note = 0;\n    if(track == 0)\n    {\n        if(pattern == 0)\n        {\n            N( 0,  B, 0) N( 1,  C, 1) N( 2,  D, 1) N( 3,  E, 1) N( 4,  F, 1) N( 5,  G, 1) N( 6,  A, 1) N( 7,  B, 1) N( 8,  C, 2) \n            N( 9,  D, 2) N(10,  E, 2) N(11,  F, 2) N(12,  G, 2) N(13,  A, 2) N(14,  C, 3) N(20,  X, 0)         \n            \/\/break between splash and intro. Currently 60 beats.\n            N(80,  C, 2) N(86,  C, 2) N(90,  B, 1) N(92,  A, 1)\n            N(96,  B, 1) N(98,  C, 2) N(100, D, 2) N(102, G, 1) N(108,  B, 1)\n            N(112, A, 1) N(118, E, 1) N(124, B, 1)\n            N(128, C, 2) N(132, D, 2) N(139, E, 2) N(146, Fs, 2)\n        }\n        else if(pattern == 1)\n        {\n            N( 0,  G, 2) N( 2, Fs, 2) N( 4,  E, 2) N( 7,  D, 2) N( 8, Fs, 2) N(10,  E, 2) N(12,  D, 2) N(15,  C, 2)\n            N(16,  E, 2) N(18,  D, 2) N(20,  C, 2) N(21,  B, 1) N(24,  D, 2) N(30,  B, 1) N(31,  A, 1) \n            N(32,  G, 1) N(34,  A, 1) N(36,  B, 1) N(38,  C, 2) N(40,  A, 1) N(42,  B, 1) N(43,  C, 2) N(46,  D, 2)\n            N(48,  D, 2) N(50,  E, 2) N(52, Fs, 2) N(53,  E, 2) N(56,  D, 2) N(58,  D, 2) N(60,  E, 2) N(62, Fs, 2) \n        }\n        else if(pattern == 2)\n        {\n            N( 0,  G, 2) N( 2, Fs, 2) N( 4,  E, 2) N( 7,  D, 2) N( 8, Fs, 2) N(10,  E, 2) N(12,  D, 2) N(15,  C, 2)\n            N(16,  E, 2) N(18,  D, 2) N(20,  C, 2) N(21,  B, 1) N(24,  D, 2) N(30,  B, 1) N(31,  A, 1) \n            N(32,  G, 1) N(34,  A, 1) N(36,  B, 1) N(38,  C, 2) N(40,  A, 1) N(42,  B, 1) N(43,  C, 2) N(46,  D, 2)\n            N(48,  D, 2) N(50,  E, 2) N(52, Fs, 2) N(53,  D, 2) N(56,  G, 2) N(58,  D, 2) N(60,  E, 2) N(62, Fs, 2) \n        }\n        else if(pattern == 3)\n        {\n            N( 0, Fs, 2) N(10,  D, 2) N(12,  E, 2) N(14, Fs, 2)\n            N(16,  G, 2) N(26,  D, 2) N(28,  E, 2) N(30, Fs, 2)\n            N(32,  A, 2) N(42,  D, 2) N(44,  E, 2) N(46, Fs, 2)\n            N(48,  B, 2) N(58,  G, 2) N(60,  A, 2) N(62,  B, 2)\n        }\n        else if(pattern == 4)\n        {\n            N( 0,  C, 3) N( 2,  C, 3) N( 6,  C, 3) N(10,  B, 2) N(12,  A, 2)\n            N(16,  B, 2) N(28,  B, 2)\n            N(32,  A, 2) N(38,  E, 2) N(44,  B, 2) N(48,  A, 2) \n            N(58,  D, 2) N(60,  E, 2) N(62,  Fs, 2) \n        }\n        else if(pattern == 5)\n        {\n            N( 0, Fs, 2) N(10,  D, 2) N(12,  E, 2) N(14, Fs, 2)\n            N(16,  G, 2) N(26,  D, 2) N(28,  E, 2) N(30, Fs, 2)\n            N(32,  A, 2) N(42,  D, 2) N(44,  E, 2) N(46, Fs, 2)\n            N(48,  B, 2) N(58,  G, 2) N(60,  A, 2) N(62,  B, 2)\n        }\n        else if(pattern == 6)\n        {\n            N( 0,  C, 3) N( 2,  C, 3) N( 6,  C, 3) N(10,  B, 2) N(12,  A, 2)\n            N(16,  B, 2) N(28,  B, 2)\n            N(32,  A, 2) N(38,  D, 2) N(42,  B, 2) N(44,  D, 2) N(46,  B, 2)\n            N(48,  G, 2) N(56,  X, 0) N(58,  D, 2) N(60,  E, 2) N(62, Fs, 2) \n        }\n    }\n    else if(track == 1)\n    {\n        if(pattern == 0)\n            \n        {\n            N(50, C, 1) \n            N(66,  G, 1)\n            N(82,  A, 1)\n            N(98,  D, 1) N(102,  D, 1) N(109,  E, 1) N(116, Fs, 1)\n\n        }\n        else if(pattern == 1)\n        {\n            N( 0,  G, 1) N( 2,  G, 2) N( 4,  G, 1) N( 6,  G, 2) N( 8,  G, 1) N(10,  G, 2) N(12,  G, 1) N(14,  G, 2)\n            N(16,  G, 1) N(18,  G, 2) N(20,  G, 1) N(22,  G, 2) N(24,  G, 1) N(26,  G, 2) N(28,  G, 1) N(30,  G, 2)\n            N(32,  E, 0) N(34,  E, 1) N(36,  E, 0) N(38,  E, 1) N(40,  E, 0) N(42,  E, 1) N(44,  E, 0) N(46,  E, 1)\n            N(48,  E, 0) N(50,  E, 1) N(52,  E, 0) N(54,  E, 1) N(56,  E, 0) N(58,  E, 1) N(60,  E, 0) N(62,  E, 1)\n        }\n        else if(pattern == 2)\n        {\n            N( 0,  G, 1) N( 2,  G, 2) N( 4,  G, 1) N( 6,  G, 2) N( 8,  G, 1) N(10,  G, 2) N(12,  G, 1) N(14,  G, 2)\n            N(16,  G, 1) N(18,  G, 2) N(20,  G, 1) N(22,  G, 2) N(24,  G, 1) N(26,  G, 2) N(28,  G, 1) N(30,  G, 2)\n            N(32,  E, 0) N(34,  E, 1) N(36,  E, 0) N(38,  E, 1) N(40,  E, 0) N(42,  E, 1) N(44,  E, 0) N(46,  E, 1)\n            N(48,  E, 0) N(50,  E, 1) N(52,  E, 0) N(54,  E, 1) N(56,  G, 0) N(58,  D, 0) N(60,  E, 0) N(62,  F, 0)\n        }\n        else if(pattern == 3 || pattern == 5)\n        {\n            N( 0, Fs, 0) N( 2, Fs, 1) N( 4, Fs, 0) N( 6, Fs, 1) N( 8, Fs, 0) N(10,  D, 0) N(12,  E, 0) N(14, Fs, 0)\n            N(16,  G, 0) N(18,  G, 1) N(20,  G, 0) N(22,  G, 1) N(24,  G, 0) N(26,  D, 0) N(28,  E, 0) N(30,  F, 0)\n            N(32, Fs, 0) N(34, Fs, 1) N(36, Fs, 0) N(38, Fs, 1) N(40, Fs, 0) N(42,  D, 0) N(44,  E, 0) N(46, Fs, 0)\n            N(48,  G, 0) N(50,  G, 1) N(52,  G, 0) N(54,  G, 1) N(56,  G, 0) N(58,  G, 0) N(60,  A, 1) N(62,  B, 1)\n        }\n        else if(pattern == 4)\n        {\n            N( 0,  C, 1) N( 2,  C, 2) N( 4,  C, 1) N( 6,  C, 2) N( 8,  C, 1) N(10,  C, 2) N(12,  C, 1) N(14,  C, 2)\n            N(16,  B, 0) N(18,  B, 1) N(20,  B, 0) N(22,  B, 1) N(24,  B, 0) N(26,  B, 1) N(28,  B, 0) N(30,  B, 1)\n            N(32,  A, 0) N(34,  A, 1) N(36,  A, 0) N(38,  A, 1) N(40,  E, 0) N(42,  E, 1) N(44,  E, 0) N(46,  E, 1)\n            N(48,  A, 0) N(50,  A, 1) N(52,  A, 0) N(54,  A, 1) N(56,  A, 0) \n        }\n        else if(pattern == 6)\n        {\n            N( 0,  C, 1) N( 2,  C, 2) N( 4,  C, 1) N( 6,  C, 2) N( 8,  C, 1) N(10,  C, 2) N(12,  C, 1) N(14,  C, 2)\n            N(16,  B, 0) N(18,  B, 1) N(20,  B, 0) N(22,  B, 1) N(24,  B, 0) N(26,  B, 1) N(28,  B, 0) N(30,  B, 1)\n            N(32,  A, 0) N(34,  A, 1) N(36,  A, 0) N(38,  A, 1) N(40,  D, 0) N(42,  A, 0) N(44,  D, 0) N(46,  A, 0)\n            N(48,  G, 0) N(56,  X, 0) N(58,  D, 0) N(60,  E, 1) N(62, Fs, 1) \n        }\n    }\n    else if(track == 2)\n    {\n        if(pattern == 3 || pattern == 5)\n        {\n            N( 2,  D, 3) N( 4,  E, 3) N( 6,  F, 3) N( 8, Fs, 3)\n            N(18,  D, 3) N(20,  E, 3) N(22, Fs, 3) N(24,  G, 3)\n            N(34,  D, 3) N(36,  E, 3) N(38, Fs, 3) N(40,  A, 3)\n            N(50,  D, 3) N(52,  E, 3) N(54, Fs, 3) N(56,  B, 3)\n        }\n    }\n    \n    envTime = time - float(hitRow)*SEC_PER_ROW;\n    \n    return note;\n}\n\nfloat Square(float x, float threshold)\n{\n    return fract(x) > threshold ? 1.0 : -1.0;\n}\n\nfloat Square2(float x, float threshold, float detune)\n{\n    return (Square(x-detune, threshold) + Square(x+detune, threshold))*.5;\n}\n    \nvec2 mainSound( in int samp, float time )\n{\n    float threshold = sin(time*5.)*.1+.5;\n    \n    float envTime0;\n    float envTime1;\n    float envTime2;\n    float envTime3;\n    \n    int note0 = Data(time, 0, envTime0);\n    int note1 = Data(time, 1, envTime1);\n    int note2 = Data(time, 2, envTime2);\n    int note3 = Data(time - SEC_PER_ROW, 0, envTime3);\n    \n    float freq0 = 440.0*pow(2.0, float(note0)\/12.0)*.5*.5;\n    float freq1 = 440.0*pow(2.0, float(note1)\/12.0)*.5*.5;\n    float freq2 = 440.0*pow(2.0, float(note2)\/12.0)*.5*.5;\n    float freq3 = 440.0*pow(2.0, float(note3)\/12.0)*.5*.5;\n    \n    float v = 0.0;\n    v += Square(envTime0*freq0, .5) * exp(-envTime0*.1) * float(note0 >= 0);\n    v += Square(envTime3*freq3, .5) * exp(-envTime3*.1) * float(note0 >= 0) * .2;\n    v += Square2(envTime1*freq1*.5*.5, threshold, 0.03) * float(note0 >= 0);\n    v += Square(envTime2*freq2, .5) * exp(-envTime2*2.) * float(note0 >= 0);\n    \n    return vec2(v*.1);\n}","name":"Sound","description":"","type":"sound"},{"inputs":[{"id":"4dXGRr","filepath":"\/presets\/tex00.jpg","previewfilepath":"\/presets\/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ shared game state\n\nconst int ENTITIES_START_Y = 1;\nconst int MAX_ENTITIES = 64;\nconst int NUM_DYNAMIC_ROWS = 3;\n\nconst int LEVEL_WIDTH = 28;\nconst int LEVEL_HEIGHT = 25;\nconst int LEVEL_START_Y = 32;\nconst int NUM_LEVELS = 4;\n\nconst int FONT_START_Y = 8;\nconst int FONT_HEIGHT = 8;\nconst int FONT_WIDTH = 8;\n\nconst int SPRITE_WIDTH = 16;\nconst int SPRITE_HEIGHT = 16;\nconst int SPRITE_START_Y = 16;\n\nconst int STRINGS_START_Y = 60;\nconst int STR_GAME_OVER = 0;\nconst int STR_BEGINNING0 = 1;\nconst int STR_BEGINNING1 = 2;\nconst int STR_BEGINNING2 = 3;\nconst int STR_BEGINNING3 = 4;\nconst int STR_BEGINNING4 = 5;\nconst int STR_PUSH_START = 6;\nconst int STR_1UP = 7;\nconst int STR_HIGH_SCORE = 8;\nconst int STR_00 = 9;\nconst int STR_INSERT = 10;\nconst int STR_COIN = 11;\nconst int STR_TO = 12;\nconst int STR_CONTINUE = 13;\nconst int STR_COPYRIGHT = 14;\nconst int STR_ALL_RIGHTS = 15;\nconst int STR_INSERT_COIN = 16;    \nconst int NUM_STRINGS = 17;\n\nconst int LOGO_START_Y = 200;\nconst int LOGO_WIDTH = 300;\nconst int LOGO_HEIGHT = 150;\n\nconst float ENTITY_TYPE_BUBBLE = 1.0;\nconst float ENTITY_TYPE_MONSTER = 2.0;\nconst float ENTITY_TYPE_TUMBLING_MONSTER = 3.0;\nconst float ENTITY_TYPE_ITEM = 4.0;\nconst float ENTITY_TYPE_SCORE = 5.0;\n\nconst int MONSTER_SPRITE_START_IDX = 5;\nconst int ITEM_SPRITE_START_IDX = 9;\n\nconst int NUM_PLACE_PLAYER_FRAMES = 120;\n\nconst float BUBBLE_ATTACK_FRAMES = 20.0;\nconst float BUBBLE_DEATH_FRAMES = 30.0;\nconst float BUBBLE_LIFE_FRAMES = 1200.0;\nconst float BUBBLE_FLOW_POWER = 0.4;\nconst float BUBBLE_ATTACK_EXP_SCALE = .15;\nconst float BUBBLE_POP_THRESHOLD = 4.0;\nconst float BUBBLE_COOLDOWN = 15.0;\nconst float RESPAWN_FRAMES = 120.0;\nconst float MONSTER_FREE_FRAME = 120.0;\nconst float MONSTER_HIT_DIST_SQ = 60.0;\n\nconst float WIN_DELAY_FRAMES = 150.0;\nconst float INVULNERABLE_FRAMES = 90.0;\n\nconst float PI = 3.1415926535;\nconst float GRAVITY = 0.10;\nconst float TERMINAL_VELOCITY = 1.0;\nconst float MOVEMENT_SPEED = 1.5;\nconst float JUMP_VELOCITY = 3.0;\nconst float PUSH_VECTOR_SCALE = .3;\nconst vec2 txGameState =    vec2(0.0,0.0);\nconst vec2 txGameState2 =   vec2(1.0,0.0);\nconst vec2 txGameState3 =   vec2(2.0,0.0);\nconst vec2 txPlayerPos =    vec2(3.0,0.0);  \nconst vec2 txPlayerSprite = vec2(4.0,0.0);  \/\/vec4(sprite_idx, mirrored, 0, 0)\nconst vec2 txPlayerFlags =  vec2(5.0,0.0);\n\/\/ private game state\nconst vec2 txPlayerVel =    vec2(6.0,0.0);\nconst vec2 txKeyWasDown =\tvec2(7.0,0.0);\nconst vec2 txCoolDown = \tvec2(8.0,0.0);\nconst vec2 txStaticDataInited = vec2(9.0,0.0);\n\nconst int SKIP_INTRO = 0;\nconst int START_LEVEL = 1;\n\nconst float KEY_SPACE = 32.5\/256.0;\nconst float KEY_LEFT  = 37.5\/256.0;\nconst float KEY_UP    = 38.5\/256.0;\nconst float KEY_RIGHT = 39.5\/256.0;\n\nconst int _A = 10, _B = 11, _C = 12, _D = 13, _E = 14, _F = 15, _G = 16, _H = 17, _I = 18, _J = 19, _K = 20, _L = 21, _M = 22, _N = 23, _O = 24, _P = 25, _Q = 26, _R = 27, _S = 28, _T = 29, _U = 30, _V = 31, _W = 32, _X = 33, _Y = 34, _Z = 35, _COPYRIGHT = 36, _EXCLAMATION = 37, _SPACE = 38;\n\n#define HASHSCALE1 .1031\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 Logo(int x, int y)\n{\n    y += 50;\n    vec2 coord = vec2(x, y);\n    float radius = 5.0;\n    float radiusSq = radius*radius;\n    vec2 pos = vec2(0);\n    \n    const int NUM_STEPS = 50;\n    const int NUM_OBJECTS = 13;\n    const int NUM_PARTS = 3;\n    const float STEP_SIZE = 1.5;\n    \n\t#define P(_T) enabled = true; if(phase == ph++ && t >= (_T)) phase++, \n    #define E(_T) if(phase == ph++ && t >= (_T)) break;\n    \n    float value = 0.0;\t\/\/0.0: not drawn, 1.0: inner, 2.0: edge, 3.0: shadow\n    \n    vec2 shadowOffset = vec2(-3,-2);\n    for(int object = 0; object < NUM_OBJECTS; object++)\n    {\n        for(int pass = 0; pass < 2; pass++)\n        {\n            for(int part = 0; part < NUM_PARTS; part++)\n            {       \n                int phase = 0;\n                float shortestDistSq = 1e10;\n                float hitT = 0.0;\n\n                float angle = 0.0;\n                float velocity = 0.0;\n                float acceleration = 0.0;\n                bool enabled = false;\n                bool overrideInner = false;\n                for(int i = 0; i < NUM_STEPS; i++)\n                {\n                    float t = float(i) \/ float(NUM_STEPS - 1);\n                    int ph = 0;\n                    \n                    \/\/ E\n                    if(object == 0)\n                    {\n                        if(part == 0)\n                        {\n                            P(0.0) pos=vec2(170,115), angle = -PI*.5;\n                            P(0.4) angle += PI*.5;\n                            E(0.6);\n                        }\n                        if(part == 1)\n                        {\n                            P(0.0) pos=vec2(170,115), angle = -PI*.5;\n                            P(0.2) angle += PI*.5;\n                            E(0.35);\n                        }\n                        if(part == 2)\n                        {\n                            P(0.0) pos=vec2(170,115), angle = 0.0;\n                            E(0.2);\n                        }\n                    }\n                    \n                    \/\/ L\n                    if(object == 1)\n                    {\n                        if(part == 0)\n                        {\n                            P(0.0) pos=vec2(155,115), angle = -PI*.5-.2;\n                            P(0.4) angle += PI*.5;\n                            E(0.6);\n                        }\n                    }\n                    \n                    \/\/ B\n                    if(object == 2)\n                    {\n                        if(part == 0)\n                        {\n                            P(0.0) pos=vec2(130,95), angle = PI*.5;\n                            P(0.35) angle -= PI*0.5, acceleration = -0.007;\n                            P(0.70) acceleration = 0.004;\n                            E(0.82);\n                        }\n                        if(part == 1)\n                        {\n                            P(0.0) pos=vec2(130,95), angle = -.3, acceleration = 0.007;\n                            P(0.2) overrideInner = true;\n                            E(0.35);\n                        }\n                    }\n                    \n                    \/\/ B\n                    if(object == 3)\n                    {\n                        if(part == 0)\n                        {\n                            P(0.0) pos=vec2(108,90), angle = PI*.5-.2;\n                            P(0.35) angle -= PI*0.5, acceleration = -0.007;\n                            P(0.70) acceleration = 0.004;\n                            E(0.82);\n                        }\n                        if(part == 1)\n                        {\n                            P(0.0) pos=vec2(108,90), angle = -.5, acceleration = 0.007;\n                            P(0.2) overrideInner = true;\n                            E(0.37);\n                        }\n                    }\n                    \n                    \/\/ O\n                    if(object == 4)\n                    {\n                        if(part == 0)\n                        {\n                    \t\tP(0.0) pos=vec2(95,100), velocity = 0.13;\n                            E(0.7);\n                        }\n                    }\n                    \n                    \/\/ B\n                    if(object == 5)\n                    {\n                        if(part == 0)\n                        {\n                            P(0.0) pos=vec2(65,90), angle = PI*.5;\n                            P(0.4) angle -= PI*0.5, acceleration = -0.007;\n                            P(0.8) acceleration = 0.004;\n                            E(0.87);\n                        }\n                        if(part == 1)\n                        {\n                            P(0.0) pos=vec2(65,90), angle = -0.2, acceleration = 0.0065;\n                            P(0.2) overrideInner = true;\n                            E(0.4);\n                        }   \n                    }\n                    \n                    \/\/ E\n                    if(object == 6)\n                    {\n                        if(part == 0)\n                        {\n                            P(0.0) pos=vec2(190,165), angle = -PI*.5-.2;\n                            P(0.4) angle += PI*.5;\n                            E(0.6);\n                        }\n                        if(part == 1)\n                        {\n                            P(0.0) pos=vec2(190,165), angle = -PI*.5-.2;\n                            P(0.2) angle += PI*.5;\n                            E(0.35);\n                        }\n                        if(part == 2)\n                        {\n                            P(0.0) pos=vec2(190,165), angle = -.2;\n                            E(0.2);\n                        }\n                    }\n                    \n                    \/\/ L\n                    if(object == 7)\n                    {\n                        if(part == 0)\n                        {\n                            P(0.0) pos=vec2(173,165), angle = -PI*.5-.25;\n                            P(0.4) angle += PI*.5;\n                            E(0.6);\n                        }\n                    }\n                    \n                    \/\/ B\n                    if(object == 8)\n                    {\n                        if(part == 0)\n                        {\n                            P(0.0) pos=vec2(140,135), angle = PI*.5-.1;\n                            P(0.37) angle -= PI*0.5, acceleration = -0.007;\n                            P(0.70) acceleration = 0.004;\n                            E(0.82);\n                        }\n                        if(part == 1)\n                        {\n                            P(0.0) pos=vec2(140,135), angle = -.4, acceleration = 0.007;\n                            P(0.2) overrideInner = true;\n                            E(0.4);\n                        }\n                    }\n                    \n                    \/\/ B\n                    if(object == 9)\n                    {\n                        if(part == 0)\n                        {\n                            P(0.0) pos=vec2(115,135), angle = PI*.5-.1;\n                            P(0.35) angle -= PI*0.5, acceleration = -0.007;\n                            P(0.70) acceleration = 0.004;\n                            E(0.82);\n                        }\n                        if(part == 1)\n                        {\n                            P(0.0) pos=vec2(115,135), angle = -.4, acceleration = 0.007;\n                            P(0.2) overrideInner = true;\n                            E(0.37);\n                        }\n                    }\n                    \n                    \/\/ U\n                    if(object == 10)\n                    {\n                        if(part == 0)\n                        {\n                    \t\tP(0.0) pos=vec2(95,155), angle =-PI*.5-.2;\n                            P(0.2) velocity = 0.15;\n                            P(0.489) velocity = 0.0;\n                            E(0.68);\n                        }\n                    }\n                    \n                    \/\/ T\n                    if(object == 11)\n                    {\n                        if(part == 0)\n                        {\n                            P(0.0) pos=vec2(80,160), angle = -PI*.5+.1;\n                            E(0.35);\n                        }\n                        \n                        if(part == 1)\n                        {\n                            P(0.0) pos=vec2(67,157), angle = .1;\n                            E(0.30);\n                        }\n                    }\n                    \n                    \/\/ S\n                    if(object == 12)\n                    {\n                        if(part == 0)\n                        {\n                            P(0.0) pos=vec2(60,167), angle = PI+.3;\n                            P(0.1) velocity = 0.12;\n                            P(0.35) velocity = 0.0;\n                            P(0.6) velocity = -0.15;\n                            P(0.85) velocity = 0.0;\n                            E(0.95);\n                        }\n                        \n                    }\n                    \n                    \n                    if(!enabled) break;\n\n                    velocity += acceleration * STEP_SIZE;\n                    angle += velocity * STEP_SIZE;\n                    pos += STEP_SIZE * vec2(cos(angle), sin(angle));\n\n                    vec2 offset = (pass == 0) ? shadowOffset : vec2(0,0);\n                    vec2 delta = (coord + offset) - pos;\n                    float lenSq = dot(delta, delta);\n                    if(lenSq < radiusSq)\n                    {\n                        if(lenSq < shortestDistSq)\n                        {\n                            shortestDistSq = lenSq;\n                            hitT = t;\n\n                            if(pass == 0)\n                                value = 3.0;\n                            else\n                                if(lenSq < radiusSq * 0.4)\n                                {\n                                    value = 1.0;\n                                }\n                            \telse\n                                {\n                                    if(value != 1.0 || overrideInner)\n                                    \tvalue = 2.0;\n                                }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    vec3 color = vec3(0);\n    float len = 1e10;\n    for(int i = 0; i < 200; i++)\n    {\n        float t = float(i) + 1200.0;\n        vec2 p = vec2((hash11(t)*2.0)*80.0-80.0,(hash11(t+1000.0)*2.0)*40.0-40.0) + vec2(128, 125);\n        len = min(len, length(p - coord) - hash11(t + 2000.0)*25.+8.0);\n    }\n    if(len < 10.0)\n    {\n        color = mix(vec3(250,161,0)\/255.0, color, smoothstep(9.5, 10.0, len));\n        color = mix(vec3(0), color, smoothstep(6.5, 7.0, len));\n        color = mix(vec3(255,240,32)\/255.0, color, smoothstep(5.0, 5.5, len));\n    }\n    \n    if(value == 1.0)\n        color = vec3(-1);\n    else if(value >= 2.0)\n        color = vec3(0);\n    \n    return color;\n}\n\n\n\n\/\/hack hack: encode bits into floating point mantissa. much faster to compile than any of the alternatives\n#define D24(_y, _d0, _d1, _d2, _d3, _d4, _d5, _d6, _d7, _d8, _d9, _d10, _d11, _d12, _d13, _d14, _d15, _d16, _d17, _d18, _d19, _d20, _d21, _d22, _d23) v = (y == (_y)) ? (float(_d0)*0.5 + float(_d1)*1.0 + float(_d2)*2.0 + float(_d3)*4.0 + float(_d4)*8.0 + float(_d5)*16.0 + float(_d6)*32.0 + float(_d7)*64.0 + float(_d8)*128.0 + float(_d9)*256.0 + float(_d10)*512.0 + float(_d11)*1024.0 + float(_d12)*2048.0 + float(_d13)*4096.0 + float(_d14)*8192.0 + float(_d15)*16384.0 + float(_d16)*32768.0 + float(_d17)*65536.0 + float(_d18)*131072.0 + float(_d19)*262144.0 + float(_d20)*524288.0 + float(_d21)*1048576.0 + float(_d22)*2097152.0 + float(_d23)*4194304.0) : v;\n\nbool Font(int x, int y, int n)\n{\n    if(x < 0 || x >= FONT_WIDTH || y < 0 || y >= FONT_HEIGHT) return false;\n    float v = 0.0;\n    y = (FONT_HEIGHT - 1) - y;\n    \n    int b = n \/ 3;\n    \n    \n    if(b == 0)\n    {\n        \/\/ 0, 1, 2\n        D24(0, 0,0,0,1,1,1,0,0, 0,0,0,0,1,1,0,0, 0,0,1,1,1,1,1,0)\n        D24(1, 0,0,1,0,0,1,1,0, 0,0,0,1,1,1,0,0, 0,1,1,0,0,0,1,1)\n        D24(2, 0,1,1,0,0,0,1,1, 0,0,0,0,1,1,0,0, 0,0,0,0,0,1,1,1)\n        D24(3, 0,1,1,0,0,0,1,1, 0,0,0,0,1,1,0,0, 0,0,0,1,1,1,1,0)\n        D24(4, 0,1,1,0,0,0,1,1, 0,0,0,0,1,1,0,0, 0,0,1,1,1,1,0,0)\n        D24(5, 0,0,1,1,0,0,1,0, 0,0,0,0,1,1,0,0, 0,1,1,1,0,0,0,0)\n        D24(6, 0,0,0,1,1,1,0,0, 0,0,1,1,1,1,1,1, 0,1,1,1,1,1,1,1) \n    }\n    else if(b == 1)\n    {\n        \/\/ 3, 4, 5\n        D24(0, 0,0,1,1,1,1,1,1, 0,0,0,0,1,1,1,0, 0,1,1,1,1,1,1,0)\n        D24(1, 0,0,0,0,0,1,1,0, 0,0,0,1,1,1,1,0, 0,1,1,0,0,0,0,0)\n        D24(2, 0,0,0,0,1,1,0,0, 0,0,1,1,0,1,1,0, 0,1,1,1,1,1,1,0)\n        D24(3, 0,0,0,1,1,1,1,0, 0,1,1,0,0,1,1,0, 0,0,0,0,0,0,1,1)\n        D24(4, 0,0,0,0,0,0,1,1, 0,1,1,1,1,1,1,1, 0,0,0,0,0,0,1,1)\n        D24(5, 0,1,1,0,0,0,1,1, 0,0,0,0,0,1,1,0, 0,1,1,0,0,0,1,1)\n        D24(6, 0,0,1,1,1,1,1,0, 0,0,0,0,0,1,1,0, 0,0,1,1,1,1,1,0)        \n    }\n    else if(b == 2)\n    {\n        \/\/ 6, 7, 8\n        D24(0, 0,0,0,1,1,1,1,0, 0,1,1,1,1,1,1,1, 0,0,1,1,1,1,0,0)\n        D24(1, 0,0,1,1,0,0,0,0, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,0)\n        D24(2, 0,1,1,0,0,0,0,0, 0,0,0,0,0,1,1,0, 0,1,1,1,0,0,1,0)\n        D24(3, 0,1,1,1,1,1,1,0, 0,0,0,0,1,1,0,0, 0,0,1,1,1,1,0,0)\n        D24(4, 0,1,1,0,0,0,1,1, 0,0,0,1,1,0,0,0, 0,1,0,0,1,1,1,1)\n        D24(5, 0,1,1,0,0,0,1,1, 0,0,0,1,1,0,0,0, 0,1,0,0,0,0,1,1)\n        D24(6, 0,0,1,1,1,1,1,0, 0,0,0,1,1,0,0,0, 0,0,1,1,1,1,1,0)\n    }\n    else if(b == 3)\n    {\n        \/\/ 9, A, B\n        D24(0, 0,0,1,1,1,1,1,0, 0,0,0,1,1,1,0,0, 0,1,1,1,1,1,1,0)\n        D24(1, 0,1,1,0,0,0,1,1, 0,0,1,1,0,1,1,0, 0,1,1,0,0,0,1,1)\n        D24(2, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1)\n        D24(3, 0,0,1,1,1,1,1,1, 0,1,1,0,0,0,1,1, 0,1,1,1,1,1,1,0)\n        D24(4, 0,0,0,0,0,0,1,1, 0,1,1,1,1,1,1,1, 0,1,1,0,0,0,1,1)\n        D24(5, 0,0,0,0,0,1,1,0, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1)\n        D24(6, 0,0,1,1,1,1,0,0, 0,1,1,0,0,0,1,1, 0,1,1,1,1,1,1,0)\n    }\n    else if(b == 4)\n    {\n        \/\/ C, D, E\n        D24(0, 0,0,0,1,1,1,1,0, 0,1,1,1,1,1,0,0, 0,1,1,1,1,1,1,1)\n        D24(1, 0,0,1,1,0,0,1,1, 0,1,1,0,0,1,1,0, 0,1,1,0,0,0,0,0)\n        D24(2, 0,1,1,0,0,0,0,0, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,0,0)\n        D24(3, 0,1,1,0,0,0,0,0, 0,1,1,0,0,0,1,1, 0,1,1,1,1,1,1,0)\n        D24(4, 0,1,1,0,0,0,0,0, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,0,0)\n        D24(5, 0,0,1,1,0,0,1,1, 0,1,1,0,0,1,1,0, 0,1,1,0,0,0,0,0)\n        D24(6, 0,0,0,1,1,1,1,0, 0,1,1,1,1,1,0,0, 0,1,1,1,1,1,1,1)\n    }\n    else if(b == 5)\n    {\n        \/\/ F, G, H\n        D24(0, 0,1,1,1,1,1,1,1, 0,0,0,1,1,1,1,1, 0,1,1,0,0,0,1,1)\n        D24(1, 0,1,1,0,0,0,0,0, 0,0,1,1,0,0,0,0, 0,1,1,0,0,0,1,1)\n        D24(2, 0,1,1,0,0,0,0,0, 0,1,1,0,0,0,0,0, 0,1,1,0,0,0,1,1)\n        D24(3, 0,1,1,1,1,1,1,0, 0,1,1,0,0,1,1,1, 0,1,1,1,1,1,1,1)\n        D24(4, 0,1,1,0,0,0,0,0, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1)\n        D24(5, 0,1,1,0,0,0,0,0, 0,0,1,1,0,0,1,1, 0,1,1,0,0,0,1,1)\n        D24(6, 0,1,1,0,0,0,0,0, 0,0,0,1,1,1,1,1, 0,1,1,0,0,0,1,1)\n    }\n    else if(b == 6)\n    {\n        \/\/ I, J, K\n        D24(0, 0,0,1,1,1,1,1,1, 0,0,0,0,0,0,1,1, 0,1,1,0,0,0,1,1)\n        D24(1, 0,0,0,0,1,1,0,0, 0,0,0,0,0,0,1,1, 0,1,1,0,0,1,1,0)\n        D24(2, 0,0,0,0,1,1,0,0, 0,0,0,0,0,0,1,1, 0,1,1,0,1,1,0,0)\n        D24(3, 0,0,0,0,1,1,0,0, 0,0,0,0,0,0,1,1, 0,1,1,1,1,0,0,0)\n        D24(4, 0,0,0,0,1,1,0,0, 0,0,0,0,0,0,1,1, 0,1,1,1,1,1,0,0)\n        D24(5, 0,0,0,0,1,1,0,0, 0,1,1,0,0,0,1,1, 0,1,1,0,1,1,1,0)\n        D24(6, 0,0,1,1,1,1,1,1, 0,0,1,1,1,1,1,0, 0,1,1,0,0,1,1,1)\n    }\n    else if(b == 7)\n    {\n        \/\/ L, M, N\n        D24(0, 0,1,1,0,0,0,0,0, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1)\n        D24(1, 0,1,1,0,0,0,0,0, 0,1,1,1,0,1,1,1, 0,1,1,1,0,0,1,1)\n        D24(2, 0,1,1,0,0,0,0,0, 0,1,1,1,1,1,1,1, 0,1,1,1,1,0,1,1)\n        D24(3, 0,1,1,0,0,0,0,0, 0,1,1,1,1,1,1,1, 0,1,1,1,1,1,1,1)\n        D24(4, 0,1,1,0,0,0,0,0, 0,1,1,0,1,0,1,1, 0,1,1,0,1,1,1,1)\n        D24(5, 0,1,1,0,0,0,0,0, 0,1,1,0,0,0,1,1, 0,1,1,0,0,1,1,1)\n        D24(6, 0,1,1,1,1,1,1,1, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1)\n    }\n    else if(b == 8)\n    {\n        \/\/ O, P, Q\n        D24(0, 0,0,1,1,1,1,1,0, 0,1,1,1,1,1,1,0, 0,0,1,1,1,1,1,0)\n        D24(1, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1)\n        D24(2, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1)\n        D24(3, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1)\n        D24(4, 0,1,1,0,0,0,1,1, 0,1,1,1,1,1,1,0, 0,1,1,0,1,1,1,1)\n        D24(5, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,0,0, 0,1,1,0,0,1,1,0)\n        D24(6, 0,0,1,1,1,1,1,0, 0,1,1,0,0,0,0,0, 0,0,1,1,1,1,0,1)\n    }\n    else if(b == 9)\n    {\n        \/\/ R, S, T\n        D24(0, 0,1,1,1,1,1,1,0, 0,0,1,1,1,1,0,0, 0,0,1,1,1,1,1,1)\n        D24(1, 0,1,1,0,0,0,1,1, 0,1,1,0,0,1,1,0, 0,0,0,0,1,1,0,0)\n        D24(2, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,0,0, 0,0,0,0,1,1,0,0)\n        D24(3, 0,1,1,0,0,1,1,1, 0,0,1,1,1,1,1,0, 0,0,0,0,1,1,0,0)\n        D24(4, 0,1,1,1,1,1,0,0, 0,0,0,0,0,0,1,1, 0,0,0,0,1,1,0,0)\n        D24(5, 0,1,1,0,1,1,1,0, 0,1,1,0,0,0,1,1, 0,0,0,0,1,1,0,0)\n        D24(6, 0,1,1,0,0,1,1,1, 0,0,1,1,1,1,1,0, 0,0,0,0,1,1,0,0)\n    }\n    else if(b == 10)\n    {\n        \/\/ U, V, W\n        D24(0, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1)\n        D24(1, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1)\n        D24(2, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1, 0,1,1,0,1,0,1,1)\n        D24(3, 0,1,1,0,0,0,1,1, 0,1,1,1,0,1,1,1, 0,1,1,1,1,1,1,1)\n        D24(4, 0,1,1,0,0,0,1,1, 0,0,1,1,1,1,1,0, 0,1,1,1,1,1,1,1)\n        D24(5, 0,1,1,0,0,0,1,1, 0,0,0,1,1,1,0,0, 0,1,1,1,0,1,1,1)\n        D24(6, 0,0,1,1,1,1,1,0, 0,0,0,0,1,0,0,0, 0,1,1,0,0,0,1,1)\n    }\n    else if(b == 11)\n    {\n        \/\/ X, Y, Z\n        D24(0, 0,1,1,0,0,0,1,1, 0,0,1,1,0,0,1,1, 0,1,1,1,1,1,1,1)\n        D24(1, 0,1,1,1,0,1,1,1, 0,0,1,1,0,0,1,1, 0,0,0,0,0,1,1,1)\n        D24(2, 0,0,1,1,1,1,1,0, 0,0,1,1,0,0,1,1, 0,0,0,0,1,1,1,0)\n        D24(3, 0,0,0,1,1,1,0,0, 0,0,0,1,1,1,1,0, 0,0,0,1,1,1,0,0)\n        D24(4, 0,0,1,1,1,1,1,0, 0,0,0,0,1,1,0,0, 0,0,1,1,1,0,0,0)\n        D24(5, 0,1,1,1,0,1,1,1, 0,0,0,0,1,1,0,0, 0,1,1,1,0,0,0,0)\n        D24(6, 0,1,1,0,0,0,1,1, 0,0,0,0,1,1,0,0, 0,1,1,1,1,1,1,1)\n    }\n    else if(b == 12)\n    {\n        \/\/ copyright, exclamation, space\n        D24(0, 0,0,1,1,1,1,0,0, 0,0,0,1,1,1,0,0, 0,0,0,0,0,0,0,0)\n        D24(1, 0,1,0,0,0,0,1,0, 0,0,0,1,1,1,0,0, 0,0,0,0,0,0,0,0)\n        D24(2, 1,0,0,1,1,0,0,1, 0,0,0,1,1,1,0,0, 0,0,0,0,0,0,0,0)\n        D24(3, 1,0,1,0,0,0,0,1, 0,0,0,1,1,0,0,0, 0,0,0,0,0,0,0,0)\n        D24(4, 1,0,1,0,0,0,0,1, 0,0,0,1,1,0,0,0, 0,0,0,0,0,0,0,0)\n        D24(5, 1,0,0,1,1,0,0,1, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0)\n        D24(6, 0,1,0,0,0,0,1,0, 0,0,0,1,1,0,0,0, 0,0,0,0,0,0,0,0)\n        D24(7, 0,0,1,1,1,1,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0)\n    }\n    \n    int bi = n - b*3;\n    return fract(v*exp2(float(-(bi*8 + x)))) >= 0.5;\n}\n\nint ModLevel(int level)\n{\n    if(level == 0) return 0;\n    return level - (level - 1)\/NUM_LEVELS*NUM_LEVELS;\n}\n\nbool Level(int x, int y, int level)\n{\n    if(x < 0 || x >= LEVEL_WIDTH) return true;\n    if(y < 0 || y >= LEVEL_HEIGHT) return false;\n    \n    int abs_x = x <= (LEVEL_WIDTH - 1) - x ? x : (LEVEL_WIDTH - 1) - x;\n    \n    level = ModLevel(level);\n    \n    if(level == 1)\n    {\n        if(y == 0 || y == LEVEL_HEIGHT - 1)\n            return true;\n        else if((y == 5 || y == 10 || y == 15) && (abs_x <= 1 || abs_x >= 5))\n            return true;\n    }\n    else if(level == 2)\n    {\n        if(y == 0)\n            return true;\n        else if(y == 5 && ((abs_x >= 2 && abs_x <= 8) || (abs_x >= 11)))\n            return true;\n        else if(y == 10 && abs_x >= 5)\n            return true;\n        else if(y == 15 && abs_x >= 9 && abs_x <= 12)\n            return true;\n        else if(y == 20 && abs_x >= 11)\n            return true;\n    }\n    else if(level == 3)\n    {\n        if((y == 0 || y == 24) && (abs_x <= 6 || abs_x >= 11))\n            return true;\n        else if(y == 5 && (abs_x <= 4 || (abs_x >= 7 && abs_x <= 9)))\n            return true;\n        else if(abs_x == 3 && y >= 10 && y <= 19)\n            return true;\n        else if(y == 10 && abs_x >= 3 && abs_x <= 12)\n            return true;\n        else if(y == 15 && abs_x >= 3 && abs_x <= 11)\n            return true;\n        else if(y == 20 && abs_x >= 3 && abs_x <= 10)\n            return true;\n    }\n    else if(level == 4)\n    {\n        if((y == 0 || y == 24) && (abs_x <= 6 || abs_x >= 11))\n            return true;\n        if(y == 5 && (abs_x >= 3 && abs_x <= 9 || abs_x == 13))\n            return true;\n        if((y == 10 || y == 15) && (abs_x >= 3 && abs_x <= 6))\n            return true;\n        if(y == 19 && (abs_x >= 3 && abs_x <= 11))\n           return true;\n        if(y == 22 && (abs_x >= 6 && abs_x <= 8))\n           return true;\n        if(y == 23 && abs_x == 6)\n           return true;\n        if(abs_x == 3 && (y >= 5 && y <= 10 || y >= 15 && y <= 19))\n            return true;\n        if((abs_x >= 10 && abs_x <= 11) && (y >= 11 && y <= 19))\n            return true;\n    }\n    \n    return false;\n}\n\nbool Collision(int x, int y, int level)\n{\n    if(level == 0) return false;\n    \n    if(y < 0 || y >= LEVEL_HEIGHT-1) return false;\n    if(x < 0 || x >= LEVEL_WIDTH) return true;\n    \n    level = ModLevel(level);\n    \n    return textureLod(iChannel0, (vec2(x + level*LEVEL_WIDTH, y+LEVEL_START_Y) + 0.5) \/ iChannelResolution[0].xy, 0.0).x > 0.5;\n}\n\n#define D16(_y, _d0, _d1, _d2, _d3, _d4, _d5, _d6, _d7, _d8, _d9, _d10, _d11, _d12, _d13, _d14, _d15) if(y == (_y)) v0 = float(_d0) * 0.125 + float(_d1) * 1.0 + float(_d2) * 8.0 + float(_d3) * 64.0 + float(_d4) * 512.0 + float(_d5) * 4096.0 + float(_d6) * 32768.0 + float(_d7) * 262144.0, v1 = float(_d8) * 0.125 + float(_d9) * 1.0 + float(_d10) * 8.0 + float(_d11) * 64.0 + float(_d12) * 512.0 + float(_d13) * 4096.0 + float(_d14) * 32768.0 + float(_d15) * 262144.0;    \nvec3 Sprite(int x, int y, int n)\n{\n    vec3 color = vec3(-1);\n    if(x < 0 || x >= SPRITE_WIDTH || y < 0 || y >= SPRITE_HEIGHT) return color;\n    y = (SPRITE_HEIGHT - 1) - y;\n \n    int palette = 0;\n    \n    float v0 = 0.0;\n    float v1 = 0.0;\n    if(n == 1)\n    {\n        palette = 0;\n        D16( 0, 0,0,0,0,0,0,0,0, 1,0,0,0,0,0,0,0)\n        D16( 1, 0,0,0,0,0,0,0,1, 1,1,0,0,0,0,0,0)\n        D16( 2, 0,0,0,1,1,1,1,2, 2,2,2,2,0,0,0,0)\n        D16( 3, 0,0,0,0,1,1,2,2, 2,2,2,2,2,0,0,0)\n        D16( 4, 0,0,0,0,0,2,2,2, 2,3,3,2,3,2,0,0)\n        D16( 5, 0,0,1,1,1,2,2,2, 3,3,4,2,4,3,0,0)\n        D16( 6, 0,0,0,1,2,2,2,2, 3,3,4,2,4,3,0,0)\n        D16( 7, 0,0,0,0,2,2,2,2, 3,3,4,2,4,3,2,0)\n        D16( 8, 0,0,1,1,2,2,2,2, 3,3,4,2,4,3,2,0)\n        D16( 9, 0,0,0,1,2,2,2,2, 2,3,3,2,3,3,2,0)\n        D16(10, 0,0,0,0,2,1,2,2, 0,0,0,3,0,0,0,0)\n        D16(11, 0,0,0,2,1,1,1,2, 2,2,2,2,2,2,0,0)\n        D16(12, 0,0,0,2,1,1,1,2, 2,3,3,3,3,0,0,0)\n        D16(13, 0,0,1,2,1,1,2,2, 3,3,3,3,3,3,0,0)\n        D16(14, 0,1,2,2,2,2,2,1, 1,3,3,3,3,3,0,0)\n        D16(15, 2,2,2,2,2,2,1,1, 1,1,3,3,3,1,1,1)\n    }\n    else if(n == 2)\n    {\n        \/\/ shoot\n        palette = 0;\n        D16( 0, 0,0,0,0,0,0,0,1, 0,0,0,0,0,0,0,0)\n        D16( 1, 0,0,0,0,0,0,1,1, 1,3,3,0,0,0,0,0)\n        D16( 2, 0,0,0,1,1,1,1,2, 2,4,3,3,2,0,0,0)\n\t\tD16( 3, 0,0,0,0,1,1,2,3, 4,2,4,3,3,2,0,0)\n        D16( 4, 0,0,0,0,0,2,3,3, 4,4,2,3,2,2,0,0)\n        D16( 5, 0,0,1,1,1,2,3,3, 3,4,3,2,2,0,0,0)\n        D16( 6, 0,0,0,1,2,2,2,3, 3,3,3,2,3,0,0,0)\n\t\tD16( 7, 0,0,0,0,2,2,2,2, 3,3,2,0,0,0,0,0)\n        D16( 8, 0,0,1,1,2,2,2,2, 2,2,0,0,0,0,0,0)\n        D16( 9, 0,0,0,0,0,2,2,2, 2,0,0,0,0,0,0,0)\n        D16(10, 0,0,0,1,1,1,2,2, 0,0,0,0,0,0,0,0)\n\t\tD16(11, 0,0,0,1,1,1,1,2, 2,2,2,2,2,2,0,0)\n        D16(12, 2,0,0,0,1,1,2,2, 2,3,3,3,3,0,0,0)\n        D16(13, 2,1,1,2,2,2,2,2, 3,3,3,3,3,3,0,0)\n        D16(14, 0,2,2,2,2,2,2,1, 1,1,3,3,3,3,0,0)\n\t\tD16(15, 0,0,2,2,2,2,1,1, 1,1,1,3,3,1,1,1)\n    }\n    else if(n == 3)\n    {\n        \/\/ dead!\n        palette = 0;\n        D16( 0, 0,0,0,3,0,0,0,0, 1,0,0,0,0,0,0,0)\n        D16( 1, 0,3,0,0,0,0,0,1, 1,1,0,0,0,0,0,0)\n        D16( 2, 0,0,0,1,1,1,1,2, 2,2,2,2,0,0,0,0)\n        D16( 3, 0,0,0,0,1,1,2,2 ,2,2,2,2,2,0,0,0)\n        D16( 4, 0,0,0,0,0,2,2,2 ,2,3,3,2,3,2,0,0)\n        D16( 5, 0,0,1,1,1,2,2,2 ,3,3,4,3,4,3,0,0)\n        D16( 6, 0,0,0,1,2,2,2,2 ,3,3,4,3,4,3,0,0)\n        D16( 7, 2,0,0,1,2,2,2,2 ,4,4,4,4,4,4,2,0)\n        D16( 8, 2,1,1,0,2,2,2,2 ,3,3,4,3,4,3,2,0)\n        D16( 9, 2,1,1,1,1,2,2,2 ,2,3,3,2,3,2,2,0)\n        D16(10, 0,1,1,1,1,1,2,0 ,0,0,0,0,0,0,0,0)\n        D16(11, 0,2,1,1,1,2,2,2 ,0,0,0,0,0,0,0,0)\n        D16(12, 0,0,2,2,2,2,2,2 ,0,0,0,0,0,0,0,0)\n        D16(13, 0,0,2,1,1,1,1,3 ,3,0,0,0,0,0,0,0)\n        D16(14, 0,0,2,2,1,1,1,1 ,3,3,3,3,1,1,1,0)\n        D16(15, 0,0,0,2,3,1,1,1 ,3,3,3,1,1,1,0,0)\n    }\n    else if(n == 4)\n    {\n        \/\/ in bubble\n        D16( 0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0)\n        D16( 1, 0,0,0,0,0,0,2,2, 2,2,0,0,0,0,0,0)\n        D16( 2, 0,0,0,0,2,2,2,2, 2,2,2,2,0,0,0,0)\n        D16( 3, 0,0,0,0,2,2,3,3, 2,3,3,2,0,0,0,0)\n        D16( 4, 0,0,0,2,2,3,3,4, 2,4,3,3,2,0,0,0)\n        D16( 5, 0,0,0,2,2,3,3,4, 2,4,3,3,2,0,0,0)\n        D16( 6, 0,0,2,2,2,3,3,4, 2,4,3,3,2,0,0,0)\n        D16( 7, 0,0,2,4,2,3,3,3, 2,3,3,3,2,2,0,0)\n        D16( 8, 0,0,2,4,2,2,3,3, 2,3,3,2,2,2,0,0)\n        D16( 9, 0,0,0,2,4,4,4,4, 4,4,4,4,4,0,0,0)\n        D16(10, 0,0,1,1,1,2,2,2, 2,2,2,2,2,0,1,0)\n        D16(11, 0,1,1,1,1,2,3,3, 3,3,3,2,1,1,1,0)\n        D16(12, 0,0,1,1,2,3,3,3, 3,3,3,3,2,1,0,0)\n        D16(13, 0,0,2,2,1,1,1,3, 3,3,1,1,1,0,0,0)\n        D16(14, 0,0,0,1,1,1,1,1, 3,1,1,1,1,0,0,0)\n        D16(15, 0,0,0,0,0,0,0,0, 0,1,1,1,0,0,0,0)\n    }\n    else if(n == 5)\n    {\n        \/\/ monster 0\n        palette = 1;\n        D16( 0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0)\n        D16( 1, 0,0,0,1,1,1,1,1, 1,1,1,1,1,0,0,0)\n        D16( 2, 0,0,1,1,3,1,1,1, 1,1,1,1,1,1,0,0)\n        D16( 3, 0,0,1,3,1,1,1,1, 1,1,1,1,1,1,0,0)\n        D16( 4, 0,0,1,3,1,1,1,1, 1,1,1,1,1,1,0,0)\n        D16( 5, 0,0,1,1,1,1,1,1, 1,1,1,1,2,5,5,0)\n        D16( 6, 0,0,1,1,1,1,1,1, 1,1,1,1,5,6,6,5)\n        D16( 7, 0,0,1,4,1,4,1,1, 1,1,1,1,5,6,6,5)\n        D16( 8, 0,0,1,4,1,4,1,1, 1,1,5,5,5,5,5,0)\n        D16( 9, 0,0,1,4,1,4,1,1, 1,2,6,6,5,6,0,0)\n        D16(10, 0,0,1,1,1,1,1,2, 2,2,6,6,5,6,0,0)\n        D16(11, 0,2,2,2,2,2,2,2, 2,6,5,5,6,2,0,0)\n        D16(12, 0,2,2,2,2,2,2,2, 2,2,6,6,2,2,0,0)\n        D16(13, 0,0,2,2,2,2,2,2, 2,2,2,2,2,0,0,0)\n        D16(14, 0,0,0,0,7,7,7,0, 0,7,7,7,7,0,0,0)\n        D16(15, 0,0,7,7,7,7,7,7, 0,0,0,0,0,0,0,0)\n    }\n    else if(n == 6)\n    {\n        \/\/ monster 1\n        palette = 1;\n        D16( 0, 0,0,0,0,0,1,1,1, 1,1,1,0,0,0,0,0)\n        D16( 1, 0,0,0,0,1,1,3,1, 1,1,1,1,1,1,0,0)\n        D16( 2, 0,0,0,1,1,3,1,1, 1,1,1,1,1,1,1,0)\n\t\tD16( 3, 0,0,0,1,1,1,1,1, 1,1,1,1,1,1,1,0)\n        D16( 4, 0,0,0,1,4,1,4,1, 1,1,1,1,1,1,1,0)\n        D16( 5, 0,0,0,1,4,1,4,1, 1,1,1,1,6,5,5,0)\n        D16( 6, 0,0,0,1,4,1,4,1, 1,1,1,6,5,6,6,5)\n\t\tD16( 7, 0,0,0,1,1,1,1,1, 1,1,1,6,5,6,6,5)\n        D16( 8, 0,0,0,4,4,4,4,4, 4,1,1,1,6,5,5,0)\n        D16( 9, 0,0,0,0,4,4,4,4, 4,4,4,4,5,5,5,0)\n        D16(10, 0,0,2,2,2,2,2,2, 2,2,2,6,5,6,6,5)\n\t\tD16(11, 0,0,2,2,2,2,2,2, 2,2,2,6,5,6,6,5)\n        D16(12, 0,0,2,2,2,2,2,2, 2,2,2,2,6,5,5,0)\n        D16(13, 0,7,7,2,2,2,2,2, 2,2,2,2,2,6,0,0)\n        D16(14, 0,0,0,7,7,7,7,0, 0,7,7,7,0,0,0,0)\n\t\tD16(15, 0,0,0,0,0,0,0,7, 7,7,7,7,7,0,0,0)\n    }\n    else if(n == 7)\n    {\n        \/\/ monster 2\n        palette = 1;\n        D16( 0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0)\n        D16( 1, 0,0,0,1,1,1,1,1, 1,1,1,1,1,0,0,0)\n        D16( 2, 0,0,1,1,3,1,1,1, 1,1,1,1,1,1,0,0)\n        D16( 3, 0,0,1,3,1,1,1,1, 1,1,1,1,1,1,0,0)\n        D16( 4, 0,0,1,3,1,1,1,1, 1,1,1,1,1,1,0,0)\n        D16( 5, 0,0,1,1,1,1,1,1, 1,1,5,5,1,1,0,0)\n        D16( 6, 0,0,1,1,1,1,1,1, 1,5,6,6,5,0,0,0)\n        D16( 7, 0,0,1,4,1,4,1,1, 1,5,6,6,5,0,0,0)\n        D16( 8, 0,0,1,4,1,4,1,1, 1,6,5,5,5,5,5,0)\n        D16( 9, 0,0,1,4,1,4,1,1, 1,1,1,1,5,6,6,5)\n        D16(10, 0,0,1,1,1,1,1,2, 2,2,2,2,5,6,6,5)\n        D16(11, 0,2,2,2,2,2,2,2, 2,2,2,2,6,5,5,6)\n        D16(12, 0,2,2,2,2,2,2,2, 2,2,2,7,7,6,6,0)\n        D16(13, 0,0,2,2,2,2,2,2, 2,7,7,7,7,7,0,0)\n        D16(14, 0,0,0,0,7,7,7,0, 0,7,7,7,0,0,0,0)\n        D16(15, 0,0,7,7,7,7,7,7, 0,0,0,0,0,0,0,0)   \n    }\n    else if(n == 8)\n    {\n        \/\/ monster 3\n        palette = 1;\n        D16( 0, 0,0,0,0,1,1,1,1, 1,1,0,0,0,0,0,0)\n        D16( 1, 0,0,0,1,1,3,1,1, 1,1,1,1,1,0,0,0)\n        D16( 2, 0,0,1,1,3,1,1,1, 1,1,1,1,1,1,0,0)\n        D16( 3, 0,0,1,1,1,1,1,1, 1,1,1,1,1,1,0,0)\n        D16( 4, 0,0,1,4,1,4,1,1, 1,1,1,1,1,1,0,0)\n        D16( 5, 0,0,1,4,1,4,1,1, 1,1,1,1,1,1,0,0)\n        D16( 6, 0,0,1,4,1,4,1,1, 1,1,5,5,1,5,5,0)\n        D16( 7, 0,0,1,1,1,1,1,1, 1,5,6,6,5,6,6,5)\n        D16( 8, 0,0,4,4,4,4,4,4, 1,5,6,6,5,6,6,5)\n        D16( 9, 0,0,0,4,4,4,4,4, 4,4,5,5,6,5,5,0)\n        D16(10, 0,2,2,2,2,2,2,2, 2,2,6,6,2,6,0,0)\n        D16(11, 0,2,2,2,2,2,2,2, 2,2,2,2,2,2,0,0)\n        D16(12, 7,7,7,7,2,2,2,2, 2,2,2,2,2,2,0,0)\n        D16(13, 0,7,7,7,7,2,2,2, 2,2,2,2,2,0,0,0)\n        D16(14, 0,0,7,7,7,7,0,0, 7,7,7,0,0,0,0,0)\n        D16(15, 0,0,0,0,0,0,7,7, 7,7,7,7,0,0,0,0)        \n    }\n    else if(n == 9)\n    {\n        \/\/ banana?\n        palette = 2;\n        D16( 0, 0,0,0,0,0,0,0,0, 0,0,0,3,3,0,0,0)\n        D16( 1, 0,0,0,0,0,0,0,0, 0,0,0,1,2,3,0,0)\n        D16( 2, 0,0,0,0,0,0,0,0, 0,0,0,1,1,1,3,0)\n        D16( 3, 0,0,0,0,0,0,0,0, 0,5,3,1,1,1,1,1)\n        D16( 4, 0,0,0,0,0,0,0,5, 5,3,3,3,1,1,0,0)\n        D16( 5, 5,5,5,5,5,5,5,3, 3,2,3,3,1,1,1,0)\n        D16( 6, 5,3,3,3,3,3,2,2, 2,3,3,1,3,1,1,0)\n        D16( 7, 0,2,2,2,2,2,2,3, 3,3,1,3,3,2,1,0)\n        D16( 8, 0,0,0,2,2,3,3,3, 3,1,3,3,3,2,1,0)\n        D16( 9, 5,5,5,5,5,3,3,2, 1,3,3,3,2,2,1,0)\n        D16(10, 1,5,5,3,2,2,1,1, 3,3,3,2,2,1,0,0)\n        D16(11, 0,1,1,1,1,2,3,3, 3,3,2,2,1,1,0,0)\n        D16(12, 0,0,5,5,5,5,3,3, 2,2,2,1,1,0,0,0)\n        D16(13, 0,5,5,5,5,3,2,2, 2,1,1,1,0,0,0,0)\n        D16(14, 0,0,1,1,1,1,1,1, 1,1,1,0,0,0,0,0)\n        D16(15, 0,0,0,0,1,1,1,1, 1,0,0,0,0,0,0,0)\n    }\n    else if(n == 10)\n    {\n        palette = 2;\n        D16( 0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0)\n        D16( 1, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0)\n        D16( 2, 0,0,0,0,0,0,0,0, 0,0,0,3,2,0,0,0)\n        D16( 3, 0,0,0,0,0,0,1,2, 2,2,2,3,4,2,0,0)\n        D16( 4, 0,0,0,0,1,2,2,3, 3,3,3,3,3,2,0,0)\n        D16( 5, 0,0,0,1,2,3,3,6, 6,3,3,2,2,2,0,0)\n        D16( 6, 0,0,0,2,3,3,3,6, 6,3,3,3,2,2,0,0)\n        D16( 7, 0,0,1,3,3,6,3,3, 3,3,3,3,3,2,0,0)\n        D16( 8, 0,0,2,3,3,3,3,3, 3,3,3,3,3,2,0,0)\n        D16( 9, 0,0,2,3,3,3,3,3, 3,3,3,3,3,2,0,0)\n        D16(10, 0,0,2,3,3,3,3,3, 3,3,3,3,2,2,0,0)\n        D16(11, 0,0,3,3,3,3,3,3, 3,3,3,3,2,2,0,0)\n        D16(12, 0,2,3,3,3,3,3,3, 3,3,3,2,2,0,0,0)\n        D16(13, 0,2,3,2,3,3,3,3, 3,3,2,2,2,0,0,0)\n        D16(14, 0,0,2,2,2,2,2,2, 2,2,2,2,0,0,0,0)\n        D16(15, 0,0,0,0,2,2,2,2, 2,2,0,0,0,0,0,0)\n    }\n    else if(n == 11)\n    {\n        palette = 2;\n        D16( 0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,4,4)\n        D16( 1, 0,0,0,0,0,0,0,0, 0,0,5,5,5,0,4,0)\n        D16( 2, 0,0,0,0,0,0,0,0, 0,5,5,5,4,4,0,0)\n        D16( 3, 0,0,0,0,0,0,0,0, 4,5,6,5,5,4,4,0)\n        D16( 4, 0,0,0,0,0,0,4,4, 4,5,5,5,5,4,4,0)\n        D16( 5, 0,0,0,4,4,4,4,4, 5,5,5,5,5,4,4,0)\n        D16( 6, 0,0,4,4,4,5,5,5, 5,5,5,5,5,4,4,0)\n        D16( 7, 0,4,4,4,4,6,6,4, 5,5,5,5,4,4,4,0)\n        D16( 8, 0,4,4,5,5,6,6,5, 5,4,5,5,4,4,0,0)\n        D16( 9, 4,4,4,5,5,4,5,5, 5,5,5,4,4,4,0,0)\n        D16(10, 4,4,5,4,5,5,5,4, 5,5,5,4,4,4,0,0)\n        D16(11, 4,4,5,5,5,5,5,5, 5,5,4,4,4,0,0,0)\n        D16(12, 4,4,4,5,4,5,5,5, 4,5,4,4,4,0,0,0)\n        D16(13, 0,4,4,4,5,5,4,5, 0,4,4,4,4,0,0,0)\n        D16(14, 0,4,4,4,4,4,4,4, 4,4,4,4,0,0,0,0)\n        D16(15, 0,0,4,4,4,4,4,4, 4,4,4,0,0,0,0,0)\n    }\n    \n    int shift = x < 8 ? 3*x : 3*x-24;\n    float v = x < 8 ? v0 : v1;\n    float idx = floor(fract(v*exp2(float(-shift))) * 8.0);\n    if(palette == 0)\n    {\n        color = (idx == 1.0) ? vec3(224,128, 64)\/255.0 : color;\n        color = (idx == 2.0) ? vec3( 96,224, 64)\/255.0 : color;\n        color = (idx == 3.0) ? vec3(255,255,255)\/255.0 : color;\n        color = (idx == 4.0) ? vec3(  0,  0,  0)\/255.0 : color;\n    }\n    else if(palette == 1)\n    {\n        color = (idx == 1.0) ? vec3(170,170,221)\/255.0 : color;\n        color = (idx == 2.0) ? vec3(136,136,187)\/255.0 : color;\n        color = (idx == 3.0) ? vec3(255,255,255)\/255.0 : color;\n        color = (idx == 4.0) ? vec3(  0,  0,  0)\/255.0 : color;\n        color = (idx == 5.0) ? vec3(  0,153,255)\/255.0 : color;\n        color = (idx == 6.0) ? vec3(136,  0,255)\/255.0 : color;\n        color = (idx == 7.0) ? vec3(255,  0,119)\/255.0 : color;\n    }\n    else if(palette == 2)\n    {\n        color = (idx == 1.0) ? vec3(255,136,  0)\/255.0 : color;\n        color = (idx == 2.0) ? vec3(255,187,  0)\/255.0 : color;\n        color = (idx == 3.0) ? vec3(204,255,  0)\/255.0 : color;\n        color = (idx == 4.0) ? vec3(  0,187,  0)\/255.0 : color;\n        color = (idx == 5.0) ? vec3(  0,255,  0)\/255.0 : color;\n        color = (idx == 6.0) ? vec3(255,255,255)\/255.0 : color;\n\n    }\n    \n    return color;\n}\n\nvec2 Flow(int x, int y, int level)\n{\n    if(x < 0) return vec2(1,0);\n    if(x >= LEVEL_WIDTH) return vec2(-1,0);\n    if(y < 0) return vec2(0,1);\n    if(y >= LEVEL_HEIGHT - 2) return vec2(0,-1);\n    \n    level = ModLevel(level);\n    \n    float xsign = sign(float(14 - x));\n    \n    \/\/if(level == 1 || level == 2)\n    {\n        if(y > 21) return vec2(xsign, 0);\n    }\n    \n    return vec2(0,1);\n}\n\n#define S4(_c0, _c1, _c2, _c3) { v = (current++ == b) ? (float(_c0)*0.015625 + float(_c1)*1.0 + float(_c2)*64.0 + float(_c3)*4096.0) : v; }\nint String(int str, int x)\n{\n    int b = x \/ 4;\n    int bi = x - b*4;\n    int current = 0;\n    float v = float(_SPACE)*4161.015625;\n    if(str == STR_GAME_OVER)\n    {\n        S4(_G, _A, _M, _E)\n        S4(_SPACE, _O, _V, _E)\n        S4(_R, _SPACE, _SPACE, _SPACE)\n    }\n    else if(str == STR_BEGINNING0)\n    {\n        S4(_N, _O, _W, _SPACE)\n        S4(_I, _T, _SPACE, _I)\n        S4(_S, _SPACE, _T, _H)\n        S4(_E, _SPACE, _B, _E)\n        S4(_G, _I, _N, _N)\n        S4(_I, _N, _G, _SPACE)\n        S4(_O, _F, _SPACE, _SPACE)\n    } else if(str == STR_BEGINNING1)\n    {\n        S4(_A, _SPACE, _F, _A)\n        S4(_N, _T, _A, _S)\n        S4(_T, _I, _C, _SPACE)\n        S4(_S, _T, _O, _R)\n        S4(_Y, _EXCLAMATION, _SPACE, _L)\n        S4(_E, _T, _SPACE, _U)\n        S4(_S, _SPACE, _SPACE, _SPACE)\n    }\n    else if(str == STR_BEGINNING2)\n    {\n        S4(_M, _A, _K, _E)\n        S4(_SPACE, _A, _SPACE, _J)\n        S4(_O, _U, _R, _N)\n        S4(_E, _Y, _SPACE, _T)\n        S4(_O, _SPACE, _SPACE, _SPACE)\n    }\n    else if(str == STR_BEGINNING3)\n    {\n        S4(_T, _H, _E, _SPACE)\n        S4(_C, _A, _V, _E)\n        S4(_SPACE, _O, _F, _SPACE)\n        S4(_M, _O, _N, _S)\n        S4(_T, _E, _R, _S)\n        S4(_EXCLAMATION, _SPACE, _SPACE, _SPACE)\n    }\n    else if(str == STR_BEGINNING4)\n    {\n        S4(_G, _O, _O, _D)\n        S4(_SPACE, _L, _U, _C)\n        S4(_K, _EXCLAMATION, _SPACE, _SPACE)\n    }\n    else if(str == STR_PUSH_START)\n    {\n        S4(_P, _U, _S, _H)\n        S4(_SPACE, _S, _T, _A)\n        S4(_R, _T, _SPACE, _SPACE)\n    }\n    else if(str == STR_1UP)\n    {\n        S4(1, _U, _P, _SPACE)\n    }\n    else if(str == STR_HIGH_SCORE)\n    {\n        S4(_H, _I, _G, _H)\n        S4(_SPACE, _S, _C, _O)\n        S4(_R, _E, _SPACE, _SPACE)\n    }\n    else if(str == STR_00)\n    {\n        S4(0, 0, _SPACE, _SPACE)\n    }\n    else if(str == STR_INSERT)\n    {\n        S4(_I, _N, _S, _E)\n        S4(_R, _T, _SPACE, _SPACE)\n    }\n    else if(str == STR_COIN)\n    {\n        S4(_C, _O, _I, _N)\n    }\n    else if(str == STR_TO)\n    {\n        S4(_T, _O, _SPACE, _SPACE)\n    }\n    else if(str == STR_CONTINUE)\n    {\n        S4(_C, _O, _N, _T)\n        S4(_I, _N, _U, _E)\n    }\n    else if(str == STR_COPYRIGHT)\n    {\n        S4(_COPYRIGHT, _SPACE, _M, _E)\n        S4(_N,_T,_O,_R)\n        S4(_SPACE,_C,_O,_R)\n        S4(_P,_O,_R,_A)\n        S4(_T,_I,_O,_N)\n        S4(_SPACE,1,9,8)\n        S4(6,_SPACE,_SPACE,_SPACE)\n    }\n    else if(str == STR_ALL_RIGHTS)\n    {\n        S4(_A,_L,_L,_SPACE)\n        S4(_R,_I,_G,_H)\n        S4(_T,_S,_SPACE,_R)\n        S4(_E,_S,_E,_R)\n        S4(_V,_E,_D,_SPACE)\n    }\n    else if(str == STR_INSERT_COIN)\n    {\n        S4(_I, _N, _S, _E)\n        S4(_R, _T, _SPACE, _C)\n        S4(_O, _I, _N, _SPACE)\n    }\n       \n    return int(fract(v * exp2(-float(bi*6)))*64.0);\n}\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\n\nvec4 loadValue(vec2 re)\n{\n    return textureLod( iChannel0, (0.5 + re) \/ iChannelResolution[0].xy, 0.0 );\n}\n\nvoid storeValue(vec2 re, vec4 va, inout vec4 fragColor, vec2 fragCoord)\n{\n    fragColor = (isInside(fragCoord, re) > 0.0) ? va : fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int x = int(fragCoord.x);\n    int y = int(fragCoord.y);\n\n    fragColor = textureLod( iChannel0, fragCoord \/ iChannelResolution[0].xy, 0.0 );\n    vec4 staticDataInited = loadValue(txStaticDataInited);\n    if(staticDataInited.x == 0.0)\n    {\n        fragColor = vec4(0);\n        if(y >= FONT_START_Y && y < FONT_START_Y + FONT_HEIGHT)\n        {\n            fragColor = Font(x - x\/FONT_WIDTH*FONT_WIDTH, y - FONT_START_Y, x\/FONT_WIDTH) ? vec4(1) : vec4(0);\n        }\n        \n        if(y >= LEVEL_START_Y && y < LEVEL_START_Y + LEVEL_HEIGHT)\n        {\n            fragColor = Level(x - x\/LEVEL_WIDTH*LEVEL_WIDTH, y - LEVEL_START_Y, x\/LEVEL_WIDTH) ? vec4(1) : vec4(0);\n        }\n        \n        if(y >= SPRITE_START_Y && y < SPRITE_START_Y + SPRITE_HEIGHT)\n        {\n            fragColor = vec4(Sprite(x - x\/SPRITE_WIDTH*SPRITE_WIDTH, y - SPRITE_START_Y, x\/SPRITE_WIDTH), 1.0);\n        }\n        if(y >= STRINGS_START_Y && y < STRINGS_START_Y + NUM_STRINGS*FONT_HEIGHT)\n        {\n            int str = (y - STRINGS_START_Y) \/ FONT_HEIGHT;\n            int c = String(str, x \/ FONT_WIDTH);\n            int lx = x - x\/FONT_WIDTH*FONT_WIDTH;\n            int ly = (y - STRINGS_START_Y) - str*FONT_HEIGHT;\n            fragColor = Font(lx, ly, c) ? vec4(1) : vec4(0);\n        }\n        if(y >= LOGO_START_Y && y < LOGO_START_Y + LOGO_HEIGHT)\n        {\n            fragColor.xyz = Logo(x, y - LOGO_START_Y);\n        }\n        \n        staticDataInited.x = 1.0;\n\t}\n    else\n    {\n        if(y >= NUM_DYNAMIC_ROWS)\n        {\n            return;\n        }\n    }\n\n    if(y == 0 && x >= 16) discard;\n    if(((y == ENTITIES_START_Y) || (y == ENTITIES_START_Y + 1)) && x >= MAX_ENTITIES) discard;\n    \n    \/\/ load state\n    vec4 gameState = loadValue(txGameState);\n    vec4 gameState2 = loadValue(txGameState2);\n    vec4 gameState3 = loadValue(txGameState3);\n    vec4 playerPos = loadValue(txPlayerPos);\n    vec4 playerSprite = loadValue(txPlayerSprite);\n    \n    vec4 playerVel = loadValue(txPlayerVel);\n    vec4 playerFlags = loadValue(txPlayerFlags);\n    vec4 keyWasDown = loadValue(txKeyWasDown);\n    vec4 cooldown = loadValue(txCoolDown);\n    \n    float moveRight = textureLod( iChannel1, vec2(KEY_RIGHT, 0.25), 0.0 ).x;\n    float moveLeft  = textureLod( iChannel1, vec2(KEY_LEFT,  0.25), 0.0 ).x;\n    float moveUp    = textureLod( iChannel1, vec2(KEY_UP,    0.25), 0.0 ).x;\n    float keySpace\t= textureLod( iChannel1, vec2(KEY_SPACE, 0.0), 0.0 ).x;\n    \n    float time = iTime - gameState2.w;\n    \n    \n    if(gameState.x == 0.0)\n    {\n        \/\/ init\n        playerPos = vec4(0,8,0,0);\n        playerSprite = vec4(1,0,0,0);\n        playerVel = vec4(0);\n        playerFlags = vec4(0);\n        gameState = vec4((SKIP_INTRO == 0) ? 1.0 : 5.0, float(0.0), 0.0, 2.0);   \/\/state, level, score, lives\n        \/\/gameState2 = vec4(0,0,0,0);\t\t\/\/old_player_x, old_player_x, frame_counter, globaltime offset\n        gameState2.xyz = vec3(0,0,0);\n        gameState3 = vec4(0);\t\/\/win_counter\n        \n        if(y == ENTITIES_START_Y || y == ENTITIES_START_Y + 1)\n        {\n            fragColor = vec4(-1);\t\t\/\/(x, y, time, type)\n            \/\/monster:\n            \/\/(x, y, time, type), (direction, target_height, y_velocity, had_floor_contact)\n            \/\/bubble:\n            \/\/(x, y, time, type), (direction, monster, pop_from_timeout, ?)\n        }\n        \n    }\n    else if(gameState.x == 1.0)\n    {\n        if(time > 7.0)\n            gameState.x = 2.0;\n    }\n    else if(gameState.x == 2.0)\n    {\n        if(time > 9.6)\n        {\n            gameState.x = 3.0;\n            gameState2.z = 0.0;\n            \n            float angle = time*2.5;\n        \tplayerPos.xy = vec2(40,120) + vec2(cos(angle)*30.0,sin(angle)*20.0);\t\/\/hack: avoid pop\n        }\n    }\n    else if(gameState.x == 3.0)\n    {\n        \/\/ now is the beginning...\n        float angle = time*2.5;\n        playerPos.xy = vec2(40,120) + vec2(cos(angle)*30.0,sin(angle)*20.0);\n        \n        if(time > 18.36)\n        {\n            gameState.x = 4.0;\n            \n            gameState.y += 1.0;\t\/\/hack: avoid pop\n            gameState2.xy = playerPos.xy;\n            playerPos = vec4(0,8,0,0);\n            playerSprite = vec4(1,0,0,0);\n            playerVel = vec4(0);\n            playerFlags = vec4(0);\n        }\n    }\n    else if(gameState.x == 4.0)\n    {\n        if(gameState2.z == 0.0)\n        {\n            if(y == ENTITIES_START_Y || y == ENTITIES_START_Y + 1)\n            {\n                fragColor = vec4(-100,-100,-1,-1e5);\n            }\n            \n            \/\/ init level\n            \/*\n            gameState2.xy = playerPos.xy;\n            playerPos = vec4(0,8,0,0);\n            playerSprite = vec4(1,0,0,0);\n            playerVel = vec4(0);\n            playerFlags = vec4(0);\n            *\/\n            int modLevel = ModLevel(int(gameState.y));\n         \n            if(modLevel == 1)\n            {\n                if(y == ENTITIES_START_Y)\n                {\n                    if(x == 0) fragColor = vec4(14*8, LEVEL_HEIGHT*8, 0, ENTITY_TYPE_MONSTER);\n                    if(x == 1) fragColor = vec4(14*8, LEVEL_HEIGHT*8+16, 0, ENTITY_TYPE_MONSTER);\n                    if(x == 2) fragColor = vec4(14*8, LEVEL_HEIGHT*8+32, 0, ENTITY_TYPE_MONSTER);\n                }\n                \n                if(y == ENTITIES_START_Y + 1)\n                {\n                    if(x == 0) fragColor = vec4(-1, 16*8, -1, -1);\n                    if(x == 1) fragColor = vec4(-1, 18*8, -1, -1);\n                    if(x == 2) fragColor = vec4(-1, 20*8, -1, -1);\n                }\n            }\n            else if(modLevel == 2)\n            {\n                if(y == ENTITIES_START_Y)\n                {\n                    if(x == 0) fragColor = vec4(10*8, LEVEL_HEIGHT*8, 0, ENTITY_TYPE_MONSTER);\n                    if(x == 1) fragColor = vec4(12*8, LEVEL_HEIGHT*8, 0, ENTITY_TYPE_MONSTER);\n                    if(x == 2) fragColor = vec4(14*8, LEVEL_HEIGHT*8, 0, ENTITY_TYPE_MONSTER);\n                    if(x == 3) fragColor = vec4(16*8, LEVEL_HEIGHT*8, 0, ENTITY_TYPE_MONSTER);\n                }\n                \n                if(y == ENTITIES_START_Y + 1)\n                {\n                    if(x == 0) fragColor = vec4(-1, 16*8, -1, -1);\n                    if(x == 1) fragColor = vec4(-1, 21*8, -1, -1);\n                    if(x == 2) fragColor = vec4( 1, 21*8, -1, -1);\n                    if(x == 3) fragColor = vec4( 1, 16*8, -1, -1);\n                }\n            }\n            else if(modLevel == 3)\n            {\n                if(y == ENTITIES_START_Y)\n                {\n                    if(x == 0) fragColor = vec4(4*8, LEVEL_HEIGHT*8,  0, ENTITY_TYPE_MONSTER);\n                    if(x == 1) fragColor = vec4(8*8, LEVEL_HEIGHT*8,  0, ENTITY_TYPE_MONSTER);\n                    if(x == 2) fragColor = vec4(18*8, LEVEL_HEIGHT*8, 0, ENTITY_TYPE_MONSTER);\n                    if(x == 3) fragColor = vec4(22*8, LEVEL_HEIGHT*8, 0, ENTITY_TYPE_MONSTER);\n                }\n                \n                if(y == ENTITIES_START_Y + 1)\n                {\n                    if(x == 0) fragColor = vec4( 1, 16*8, -1, -1);\n                    if(x == 1) fragColor = vec4( 1, 21*8, -1, -1);\n                    if(x == 2) fragColor = vec4(-1, 21*8, -1, -1);\n                    if(x == 3) fragColor = vec4(-1, 16*8, -1, -1);\n                }\n            }\n            else if(modLevel == 4)\n            {\n                if(y == ENTITIES_START_Y)\n                {\n                    if(x == 0) fragColor = vec4(4*8, LEVEL_HEIGHT*8,  0, ENTITY_TYPE_MONSTER);\n                    if(x == 1) fragColor = vec4(6*8, LEVEL_HEIGHT*8,  0, ENTITY_TYPE_MONSTER);\n                    if(x == 2) fragColor = vec4(8*8, LEVEL_HEIGHT*8,  0, ENTITY_TYPE_MONSTER);\n                    if(x == 3) fragColor = vec4(18*8, LEVEL_HEIGHT*8, 0, ENTITY_TYPE_MONSTER);\n                    if(x == 4) fragColor = vec4(20*8, LEVEL_HEIGHT*8, 0, ENTITY_TYPE_MONSTER);\n                    if(x == 5) fragColor = vec4(22*8, LEVEL_HEIGHT*8, 0, ENTITY_TYPE_MONSTER);\n                }\n                \n                if(y == ENTITIES_START_Y + 1)\n                {\n                    if(x == 0) fragColor = vec4( 1, 20*8, -1, -1);\n                    if(x == 1) fragColor = vec4( 1, 16*8, -1, -1);\n                    if(x == 2) fragColor = vec4( 1,  8*8, -1, -1);\n                    if(x == 3) fragColor = vec4(-1,  8*8, -1, -1);\n                    if(x == 4) fragColor = vec4(-1, 16*8, -1, -1);\n                    if(x == 5) fragColor = vec4(-1, 20*8, -1, -1);\n                }\n            }\n\n        }\n        \n        gameState2.z++;\n        if(gameState2.z > float(NUM_PLACE_PLAYER_FRAMES))\n        {\n            gameState.x = 5.0;\n            gameState2.z = 0.0;\n        }\n    }\n    else if(gameState.x == 5.0)\n    {\n        gameState2.z++;\n\n        \n        \/\/ player\n        playerVel.y = max(playerVel.y - GRAVITY, -TERMINAL_VELOCITY);\n\n        float oldPlayerPosX = playerPos.x;\n        if(playerFlags.y >= 0.0)\n        {\n            \/\/ alive\n            \n            if(moveUp > 0.0 && playerFlags.x == 1.0)\t\/\/only allow jump if we had ground collision last frame\n            {\n                \/\/playerFlags.x = 1.0;\n                playerVel.y += JUMP_VELOCITY;\n            }\n\n            playerPos.x += MOVEMENT_SPEED * (moveRight - moveLeft);\n            playerSprite.y = (moveRight > 0.0 ^^ moveLeft > 0.0) ? float(moveLeft) : playerSprite.y;\n            \n            playerFlags.y += 1.0;\n        }\n        else\n        {\n            playerFlags.y -= 1.0;\n        }\n        \n        playerPos.xy += playerVel.xy;\n        \n        {\n            float deltaX = playerPos.x - oldPlayerPosX;\n            if(deltaX > 0.0)\n            {\n                int bx = int(playerPos.x\/8.0+2.0);\n            \tbool wallCollision = Collision(bx, int(playerPos.y\/8.0+0.5), int(gameState.y)) &&\n                \t\t\t\t\tCollision(bx, int(playerPos.y\/8.0+1.5), int(gameState.y));\n            \tif(wallCollision) playerPos.x = float(bx)*8.0-16.0;\n            }\n            else\n            {\n                int bx = int(floor(playerPos.x\/8.0));\n                bool wallCollision = Collision(bx, int(playerPos.y\/8.0+0.5), int(gameState.y)) &&\n                    \t\t\t\tCollision(bx, int(playerPos.y\/8.0+1.5), int(gameState.y));\n                if(wallCollision) playerPos.x = float(bx)*8.0+8.0;\n            }            \n        }\n        \n        \n        if(playerPos.y < -16.0) playerPos.y = float(LEVEL_HEIGHT)*8.0;\t\/\/ wrap around y-axis\n        \n        \n        \/\/ did I walk into a monster?\n        int firstFreeEntity = 0;\n        for(int i = 0; i < MAX_ENTITIES; i++)\n        {\n            vec4 entity0 = textureLod( iChannel0, (vec2(i, ENTITIES_START_Y) + 0.5) \/ iChannelResolution[0].xy, 0.0 );\n            \n            if(entity0.w == ENTITY_TYPE_MONSTER && playerFlags.y >= INVULNERABLE_FRAMES && length(entity0.xy - playerPos.xy) < 10.0)\n            {\n                \/\/ death\n                playerFlags.y = -1.0;\n                gameState.w -= 1.0;\n            }\n            \n            if(entity0.w < 0.0 && firstFreeEntity == 0)\n            {\n                firstFreeEntity = i;\n            }\n        }\n        \n        \/\/ respawn?\n        if(playerFlags.y < -RESPAWN_FRAMES)\n        {\n            if(gameState.w >= 0.0)\n            {\n                playerFlags.y = 0.0;\n                playerPos = vec4(0,8,0,0);\n                playerSprite = vec4(1,0,0,0);\n                playerVel = vec4(0);\n            }\n            else\n            {\n                gameState.x = 6.0;\t\/\/game over!\n            }\n        }\n        \n        \n        bool didFire = (keySpace != 0.0 && keyWasDown.x == 0.0 && cooldown.x <= 0.0 && playerFlags.y >= 0.0);\n        if(didFire)\n        {\n            cooldown.x = BUBBLE_COOLDOWN;\n        }\n        \n        if(playerFlags.y >= 0.0)\n        \tplayerSprite.x = float(cooldown.x > 5.0) + 1.0;\n        else\n            playerSprite.x = 3.0; \n        \n        bool floorCollision = Collision(int(playerPos.x\/8.0+.5), int(playerPos.y\/8.0), int(gameState.y)) || Collision(int(playerPos.x\/8.0+.5)+1, int(playerPos.y\/8.0), int(gameState.y));\n        playerFlags.x = 0.0;\n        if(playerVel.y <= 0.0 && floorCollision)\n        {\n            float new_y = (floor(playerPos.y\/8.0)+1.0)*8.0;\n            if(new_y <= playerPos.y + 2.0)\t\/\/ignore if it moves us up too much\n            {\n                playerPos.y = new_y;\n                playerVel.y = 0.0;\n                playerFlags.x = 1.0;\n            }\n        }\n\n        \n        \/\/ entity update\n        if((y == ENTITIES_START_Y || y == ENTITIES_START_Y + 1) && x < MAX_ENTITIES)\n        {\n            vec4 entity0 = textureLod( iChannel0, (vec2(x, ENTITIES_START_Y + 0) + 0.5) \/ iChannelResolution[0].xy, 0.0 );\n            vec4 entity1 = textureLod( iChannel0, (vec2(x, ENTITIES_START_Y + 1) + 0.5) \/ iChannelResolution[0].xy, 0.0 );\n            \n            \n            if(entity0.w == ENTITY_TYPE_BUBBLE)\t\/\/ bubble update\n            {\n                entity1.w = 0.0;\t\/\/ clear points\n                \n                bool turnToMonster = false;\n                bool turnToTumbling = false;\n                \n                vec2 pushVector = vec2(0);\n            \tfor(int i = 0; i < MAX_ENTITIES; i++)\n            \t{\n                \tvec4 otherEntity0 = textureLod( iChannel0, (vec2(i, ENTITIES_START_Y + 0) + 0.5) \/ iChannelResolution[0].xy, 0.0 );\n                    vec4 otherEntity1 = textureLod( iChannel0, (vec2(i, ENTITIES_START_Y + 1) + 0.5) \/ iChannelResolution[0].xy, 0.0 );\n                \n                    if(entity0.z >= 0.0 && otherEntity0.w == ENTITY_TYPE_BUBBLE)\n                    {\n                        vec2 delta = entity0.xy - otherEntity0.xy;\n                        float dist = length(delta);\n                        if(otherEntity0.z >= 0.0)\n                        {\n                            if(length(delta) > 0.01) pushVector += normalize(delta) * max(0., 13.0 - dist);\n                        }\n                        else if(otherEntity0.z >= -2.0 && otherEntity1.z == 0.0 && dist < 15.0)\t\/\/neighbor died very recently\n                        {\n                            entity0.z = -1.0;\n                            entity1.z =  0.0;\t\/\/ not timeout\n                            entity1.w = (entity1.y > 0.0) ? 1000.0 : 10.0;\t\/\/ points\n                           \tturnToTumbling = (entity1.y > 0.0);\n                        }\n                    }\n            \t}\n                \n                if(entity0.z >= 0.0)\n                {\n                    if(entity0.z < BUBBLE_ATTACK_FRAMES && entity1.y <= 0.0 && gameState2.z >= MONSTER_FREE_FRAME)\n                    {\n                        for(int j = 0; j < MAX_ENTITIES; j++)\n                        {\n                            vec4 otherEntity0 = textureLod( iChannel0, (vec2(j, ENTITIES_START_Y + 0) + 0.5) \/ iChannelResolution[0].xy, 0.0 );\n                            if(otherEntity0.w == ENTITY_TYPE_MONSTER)\n                            {\n                                vec2 delta = entity0.xy - (otherEntity0.xy + vec2(8,8));\n                                if(dot(delta, delta) < MONSTER_HIT_DIST_SQ)\n                                {\n                                    entity1.y = 1.0;\t\/\/ caught a monster!\n                                }\n                            }\n                        }\n                    }\n                    \n                    vec2 delta = entity0.xy - (playerPos.xy + vec2(8,8));\n                    float penetration = max(0.,16. - length(delta));\n                    if(length(delta) > .01) pushVector += normalize(delta) * penetration;\n\n                    if(entity0.z < BUBBLE_ATTACK_FRAMES)\n                        entity0.x += entity1.x * exp2(-BUBBLE_ATTACK_EXP_SCALE * entity0.z) \/ BUBBLE_ATTACK_EXP_SCALE;\n                    else\n                        entity0.xy += Flow(int(entity0.x\/8.0), int(entity0.y\/8.0), int(gameState.y)) * BUBBLE_FLOW_POWER;\n                    entity0.xy += pushVector*PUSH_VECTOR_SCALE;\n                    entity0.x = clamp(entity0.x, 8., float(LEVEL_WIDTH)*8.-8.);\n                    entity0.z += 1.0;\n                    if(entity0.z >= BUBBLE_LIFE_FRAMES)\n                    {\n                        entity0.z = -1.0;\n                        entity1.z =  1.0;\t\/\/ timeout\n                        entity1.w =  0.0;\t\/\/ 0 points\n                        turnToMonster = (entity1.y > 0.0);\n                    }\n                    else if(entity0.z > 10.0 && penetration > BUBBLE_POP_THRESHOLD)\n                    {\n                        entity0.z = -1.0;\t\/\/ popped by player\n                        entity1.z =  0.0;\t\/\/ not timeout\n                        entity1.w = (entity1.y > 0.0) ? 1000.0 : 10.0;\t\/\/ points\n                        turnToTumbling = (entity1.y > 0.0);\n                    }   \n                }\n                else\n                {\n                    entity0.z -= 1.0;\n                }\n              \n                if(entity0.z < -BUBBLE_DEATH_FRAMES)\n                {\n                    entity0.w = -1.0;\n                }\n                \n                if(turnToMonster)\n                {\n                    entity0.z = 0.0;\n                    entity0.w = ENTITY_TYPE_MONSTER;\n                    entity1 = vec4(1, 0, -1, -1);\n                }\n                \n                if(turnToTumbling)\n                {\n                    entity0.z = 0.0;\n                    entity0.w = ENTITY_TYPE_TUMBLING_MONSTER;\n                    entity1 = vec4(-1, -1, -1, 1000.0);\n                    entity1.x = (hash11(iTime + float(x)*100.0)*2.0-1.0)*3.0;\n                    entity1.y = 3.5;\n                }\n                \n            }\n            else if(entity0.w == ENTITY_TYPE_MONSTER)\t\/\/ monster update\n            {\n                \/\/ alive                \n                if(gameState2.z < MONSTER_FREE_FRAME)\n                {\n                    \/\/move monsters down to starting location\n                    if(entity0.y > entity1.y)\n                    {\n                        entity0.y = max(entity0.y - 1.5, entity1.y);\n                    }\n                }\n                else\n                {\n                    \/\/ was monster hit by bubble?\n                    for(int i = 0; i < MAX_ENTITIES; i++)\n                    {\n                        vec4 otherEntity0 = textureLod( iChannel0, (vec2(i, ENTITIES_START_Y + 0) + 0.5) \/ iChannelResolution[0].xy, 0.0 );\n                        vec4 otherEntity1 = textureLod( iChannel0, (vec2(i, ENTITIES_START_Y + 1) + 0.5) \/ iChannelResolution[0].xy, 0.0 );\n                        if(otherEntity0.w == ENTITY_TYPE_BUBBLE && otherEntity0.z >= 0.0 && otherEntity0.z < BUBBLE_ATTACK_FRAMES && otherEntity1.y <= 0.0)\n                        {\n                            vec2 delta = otherEntity0.xy - (entity0.xy + vec2(8,8));\n                            if(dot(delta, delta) < MONSTER_HIT_DIST_SQ)\n                            {\n                                entity0.w = -1.0;\n                            }\n                        }\n                    }\n                    \n                    entity1.z = max(entity1.z - GRAVITY, -TERMINAL_VELOCITY);\n                    \n                    \n                    entity0.y += entity1.z;\n                    bool floorCollision = Collision(int(entity0.x\/8.0+.5), int(entity0.y\/8.0), int(gameState.y)) || Collision(int(entity0.x\/8.0+.5)+1, int(entity0.y\/8.0), int(gameState.y));\n                    \n                    bool ceilingCollision = false;\n                    for(int i = 2; i <= 5; i++)\n                    {\n                        ceilingCollision = ceilingCollision || Collision(int(entity0.x\/8.0+1.0), int(entity0.y\/8.0+float(i)), int(gameState.y));\n                    }\n                    \n                    if(entity1.w > 0.0)\n                    {\n                        \/\/we can jump, but should we?\n                        if(playerPos.y > entity0.y + 8.0 && ceilingCollision && hash11(time+float(x)*200.0)>0.98)\n                        {\n                             \/\/ yes!\n                            entity1.z += JUMP_VELOCITY;\n                            entity1.w = 0.0;\n                        }\n                    }\n                    \n                    entity1.w = 0.0;\n                    if(entity1.z <= 0.0 && floorCollision)\n                    {\n                        float new_y = (floor(entity0.y\/8.0)+1.0)*8.0;\n                        if(new_y <= entity0.y + 2.0)\t\/\/ignore if it moves us up too much\n                        {\n                            entity0.y = new_y;\n                            entity1.z = 0.0;\n                            entity1.w = 1.0;\n                        }\n                        entity0.x += entity1.x;\n                        \n                        float xpos = entity0.x\/8.0 + ((entity1.x < 0.0) ? -1.0 : 2.0);\n                        bool wallCollision = Collision(int(xpos), int(entity0.y\/8.0+.5), int(gameState.y));\n                        if(wallCollision)\n                        {\n                            entity0.x -= entity1.x;\n                            entity1.x *= -1.0;\n                        }\n                    }\n                    if(entity0.y < -16.0) entity0.y = float(LEVEL_HEIGHT)*8.0;\t\/\/ wrap around y-axis\n                    \n                }\n                entity0.z += 1.0;\n            }\n            else if(entity0.w == ENTITY_TYPE_TUMBLING_MONSTER)\n            {\n                entity1.w = 0.0;\t\/\/clear points\n                \n                entity0.z += 1.0;\n                entity0.xy += entity1.xy;\n                if(entity0.y < -16.0) entity0.y = float(LEVEL_HEIGHT)*8.0;\t\/\/ wrap around y-axis\n                \n                entity1.y = max(entity1.y - GRAVITY, -TERMINAL_VELOCITY);\n                \n                if(entity0.x < 0.0)\n                {\n                    entity0.x = 0.0;\n                    entity1.x *= -1.0;\n                }\n                else if(entity0.x >= float(LEVEL_WIDTH-4)*8.0)\n                {\n                    entity0.x = float(LEVEL_WIDTH-4)*8.0;\n                    entity1.x *= -1.0;\n                }\n                entity1.x *= 0.98;\n                \n                if(entity0.z > 180.0)\n                {\n                    bool floorCollision = Collision(int(entity0.x\/8.0+.5), int(entity0.y\/8.0), int(gameState.y)) || Collision(int(entity0.x\/8.0+.5)+1, int(entity0.y\/8.0), int(gameState.y));\n    \t\t\t\tif(floorCollision)\n                    {\n                        entity0.y = (floor(entity0.y\/8.0)+1.0)*8.0;\n                    \tentity0.z = floor(hash11(iTime + float(x)*100.0)*2.99);\t\/\/ icon\n                        entity0.w = ENTITY_TYPE_ITEM;\n                        entity1.w = 1000.0;\t\/\/ points\n                    }\n                }   \n            }\n            else if(entity0.w == ENTITY_TYPE_ITEM)\n            {\n                if(length(playerPos.xy - entity0.xy) < 10.0)\n                {\n                    entity0.w = ENTITY_TYPE_SCORE;\n                    entity1.w = 1000.0;\n                }\n            }\n            else if(entity0.w == ENTITY_TYPE_SCORE)\n            {\n                entity1.w = 0.0;\n            }\n            \n            \/\/ fire new bubble?\n            if(didFire && x == firstFreeEntity)\n            {\n                if(playerSprite.y > 0.0)\n                {\n                    entity0 = vec4(playerPos.x +  6.0, playerPos.y + 8., 0, ENTITY_TYPE_BUBBLE);\n                    entity1 = vec4(-1, -1, -1, 0);\n                }\n                else\n                {\n                    entity0 = vec4(playerPos.x + 10.0, playerPos.y + 8., 0, ENTITY_TYPE_BUBBLE);\n                    entity1 = vec4( 1, -1, -1, 0);\n                }\n            }\n            \n            fragColor = (y == ENTITIES_START_Y) ? entity0 : entity1;\n        }\n        \n        \n        \n        keyWasDown.x = keySpace;\n        cooldown -= 1.0;\n        \n        bool winCondition = true;\/\/gameState.y > 0.0;\n        if(y == 0)\n        {\n            for(int i = 0; i < MAX_ENTITIES; i++)\n            {\n                vec4 entity0 = textureLod( iChannel0, (vec2(i, ENTITIES_START_Y + 0) + 0.5) \/ iChannelResolution[0].xy, 0.0 );\n                vec4 entity1 = textureLod( iChannel0, (vec2(i, ENTITIES_START_Y + 1) + 0.5) \/ iChannelResolution[0].xy, 0.0 );\n                if(entity0.w == ENTITY_TYPE_MONSTER || (entity0.w == ENTITY_TYPE_BUBBLE && entity1.y > 0.0))\n                {\n                    winCondition = false;\n                }\n                if(entity0.w == ENTITY_TYPE_BUBBLE || entity0.w == ENTITY_TYPE_SCORE)\n                {\n                    gameState.z += entity1.w;\n                }\n                if(entity0.w == ENTITY_TYPE_TUMBLING_MONSTER)\n                {\n                    gameState.z += entity1.w;\n                    winCondition = false;\n                }\n            }\n        }\n        \n        if(winCondition)\n        {\n            gameState3.x += 1.0;\n            \n            if(gameState3.x >= WIN_DELAY_FRAMES)\n            {\n                gameState.x = 4.0;\t\/\/next level\n                gameState2.z = 0.0;\n                gameState3.x = 0.0;\n                \n                \/\/hack hack to avoid pop when changing level\n                gameState.y++;\n                gameState2.xy = playerPos.xy;\n                playerPos = vec4(0,8,0,0);\n                playerSprite = vec4(1,0,0,0);\n                playerVel = vec4(0);\n                playerFlags = vec4(0);\n            }\n        }\n        \n    } else if(gameState.x == 6.0)\n    {\n        if(keySpace != 0.0)\n        {\n            gameState.x = 0.0;\n            gameState2.w = iTime;\n        }\n    }\n    \n    \/\/ store state\n    storeValue(txGameState,     vec4(gameState),    fragColor, fragCoord);\n    storeValue(txGameState2,    vec4(gameState2),   fragColor, fragCoord);\n    storeValue(txGameState3,    vec4(gameState3),   fragColor, fragCoord);\n    storeValue(txPlayerPos,     vec4(playerPos),    fragColor, fragCoord);\n    storeValue(txPlayerSprite,  vec4(playerSprite), fragColor, fragCoord);\n    storeValue(txPlayerVel,     vec4(playerVel),    fragColor, fragCoord);\n    storeValue(txPlayerFlags,   vec4(playerFlags),  fragColor, fragCoord);\n    storeValue(txKeyWasDown,  \tvec4(keyWasDown),\tfragColor, fragCoord);\n    storeValue(txCoolDown,  \tvec4(cooldown),\t\tfragColor, fragCoord);\n    storeValue(txStaticDataInited, vec4(staticDataInited),\tfragColor, fragCoord);\n    \n}\n\n\n\/\/TODO:\n\/\/*d24 font\n\/\/**baseline: ~2s\n\/\/**now: ~1s\n\/\/*move sprites to Buf A\n\/\/**baseline: ~5s\n\/\/**now: ~3s\n\/\/**float hacking for sprites\n\/\/*monster sprite + movement\n\/\/*sprite rotation\n\/\/*life counter\n\/\/*fix pattern 0 length\n\/\/*intro animation: \"now it is the beginning of a fantastic story..\"\n\/\/*hero in bubble\n\/\/*change level animation\n\/\/*game over\n\/\/*game restart\n\/\/-fix state transition glitches!\n\/\/**remove bubbles\n\/\/**clear jump state\n\/\/-monster in bubble: begin: 9:17\n\/\/**monster disappears when hit by attack bubble: 9:26\n\/\/**monster trapped in bubble: 10:55\n\/\/**monsters\/items\/bubbles are entities! 11:12\n\/\/**release monster\n\/\/**win condition\n\/\/*bug: hit multiple monsters with one bubble!\n\/\/**multipop doesn't work anymore\n\/\/**fall out the bottom...\n\/\/**bug: can walk on top of level\n\/\/**draw monster in bubble\n\/\/*support for multiple tiles\n\/\/*shake bubble when about to pop\n\/\/*bubbles shouldn't pop neighbors when popped by timeout\n\/\/*points for bubbles\n\/\/*monsters use collision\n\/\/**wall collision\n\/\/*collision issues\n\/\/**jump after fall\n\/\/**glide into wall\n\/\/**walk through wall\n\/\/*monster fall\n\/\/*monster jump\n\/\/*better AI\n\/\/*repeat levels!\n\/\/*invulnerable\n\/\/*item pickup\n\/\/**sync music with logo\n\/\/**optimize: performance is crappy now\n\/\/*resolution scaling\n\/\/*more fruit\n\/\/*faster compile\n\/\/*only update 'dynamic' part of texture\n\/\/*level 4\n\/\/*fix transitions\n\/\/*logo\n\/\/*copyright message?\n\/\/-long compile time because of logo\n\/\/-real tiles\n\/\/-bubble effect in intro\n\/\/-dead monster sprite\n\/\/-bug no wall colision on top row\n\/\/-logo AA?\n\/\/-jump animation\n\/\/-fall animation\n\/\/-walk animation\n\/\/-bubbles collide with level?\n\/\/-monster leaping\n\/\/-death animation\n\/\/-player 2\n\/\/-TODO: retrigger notes\n\/\/-note slide\n\n","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/\/ shared game state\nconst int LEVEL_WIDTH = 28;\nconst int LEVEL_HEIGHT = 25;\nconst int LEVEL_START_Y = 32;\nconst int NUM_LEVELS = 4;\n\nconst int FONT_START_Y = 8;\nconst int FONT_HEIGHT = 8;\nconst int FONT_WIDTH = 8;\n\nconst int SPRITE_WIDTH = 16;\nconst int SPRITE_HEIGHT = 16;\nconst int SPRITE_START_Y = 16;\n\nconst int ENTITIES_START_Y = 1;\nconst int MAX_ENTITIES = 64;\n\nconst int STRINGS_START_Y = 60;\nconst int STR_GAME_OVER = 0;\nconst int STR_BEGINNING0 = 1;\nconst int STR_BEGINNING1 = 2;\nconst int STR_BEGINNING2 = 3;\nconst int STR_BEGINNING3 = 4;\nconst int STR_BEGINNING4 = 5;\nconst int STR_PUSH_START = 6;\nconst int STR_1UP = 7;\nconst int STR_HIGH_SCORE = 8;\nconst int STR_00 = 9;\nconst int STR_INSERT = 10;\nconst int STR_COIN = 11;\nconst int STR_TO = 12;\nconst int STR_CONTINUE = 13;\nconst int STR_COPYRIGHT = 14;\nconst int STR_ALL_RIGHTS = 15;\nconst int STR_INSERT_COIN = 16;\n\nconst int LOGO_START_Y = 200;\nconst int LOGO_WIDTH = 300;\nconst int LOGO_HEIGHT = 150;\n\n\nconst float ENTITY_TYPE_BUBBLE = 1.0;\nconst float ENTITY_TYPE_MONSTER = 2.0;\nconst float ENTITY_TYPE_TUMBLING_MONSTER = 3.0;\nconst float ENTITY_TYPE_ITEM = 4.0;\n\nconst int MONSTER_SPRITE_START_IDX = 5;\nconst int ITEM_SPRITE_START_IDX = 9;\n\nconst int NUM_PLACE_PLAYER_FRAMES = 120;\nconst float INVULNERABLE_FRAMES = 90.0;\n\nconst float BUBBLE_ATTACK_FRAMES = 20.0;\nconst float BUBBLE_DEATH_FRAMES = 30.0;\nconst float BUBBLE_LIFE_FRAMES = 1200.0;\nconst vec3 BUBBLE_COLOR = vec3(0.25, 1.0, 0.25);\n\nconst float TILE_SIZE = 8.;\nconst float SHADOW_WIDTH = 3.0;\nconst int LEVEL_HEIGHT_MARGIN = 4;\nconst int LEVEL_HEIGHT_IN_PIXELS = int(TILE_SIZE) * (LEVEL_HEIGHT + LEVEL_HEIGHT_MARGIN);\nconst vec2 txGameState = \tvec2(0.0,0.0);\nconst vec2 txGameState2 = \tvec2(1.0,0.0);\nconst vec2 txGameState3 = \tvec2(2.0,0.0);\nconst vec2 txPlayerPos = \tvec2(3.0,0.0);\nconst vec2 txPlayerSprite = vec2(4.0,0.0);\nconst vec2 txPlayerFlags =  vec2(5.0,0.0);\n\nconst float PI = 3.1415926535;\n\n\n\n#define HASHSCALE1 .1031\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nbool Letter(int x, int y, int n)\n{\n    if(x < 0 || x >= FONT_WIDTH || y < 0 || y >= FONT_HEIGHT) return false;\n    return textureLod(iChannel0, (vec2(x + n*FONT_WIDTH, y+FONT_START_Y) + 0.5) \/ iChannelResolution[0].xy, 0.0).x > 0.5;\n}\n\nint ModLevel(int level)\n{\n    if(level == 0) return 0;\n    return level - (level - 1) \/ NUM_LEVELS * NUM_LEVELS;\n}\n\n#define D16(_y, _d0, _d1, _d2, _d3, _d4, _d5, _d6, _d7, _d8, _d9, _d10, _d11, _d12, _d13, _d14, _d15) if(y == (_y)) v0 = float(_d0) * 0.125 + float(_d1) * 1.0 + float(_d2) * 8.0 + float(_d3) * 64.0 + float(_d4) * 512.0 + float(_d5) * 4096.0 + float(_d6) * 32768.0 + float(_d7) * 262144.0, v1 = float(_d8) * 0.125 + float(_d9) * 1.0 + float(_d10) * 8.0 + float(_d11) * 64.0 + float(_d12) * 512.0 + float(_d13) * 4096.0 + float(_d14) * 32768.0 + float(_d15) * 262144.0;    \nvec3 Sprite(vec2 coord, int n, vec3 color, bool mirror, int rotate, vec3 colorMultiply)\n{\n    int x = int(coord.x);\n    int y = int(coord.y);\n    if(mirror) x = (SPRITE_WIDTH - 1) - x;\n    int old_x = x;\n    int old_y = y;\n    if(rotate == 1) { x = 15-old_y; y = old_x; }\n    else if(rotate == 2) { x = 15-old_x; y = 15-old_y; }\n    else if(rotate == 3) { x = old_y; y = 15-old_x; }\n\n    if(x < 0 || x >= SPRITE_WIDTH || y < 0 || y >= SPRITE_HEIGHT) return color;\n    \n    vec3 c = textureLod(iChannel0, (vec2(x + n*SPRITE_WIDTH, y + SPRITE_START_Y) + 0.5) \/ iChannelResolution[0].xy, 0.0).xyz;\n    return c.x >= 0.0 ? (c * colorMultiply) : color;\n}\n\n\nvec3 PrintStr(vec2 fragCoord, int x, int y, int str, vec3 color, vec3 inputColor)\n{\n    int lx = int(fragCoord.x) - x;\t\n    int ly = int(fragCoord.y) - y;\n    if(lx < 0 || ly < 0 || ly >= FONT_HEIGHT) return inputColor;\n    \n    return textureLod(iChannel0, (vec2(lx, STRINGS_START_Y + str * FONT_HEIGHT + ly) + 0.5) \/ iChannelResolution[0].xy, 0.0).x > 0.5 ? color : inputColor;\n}\n\n\nfloat Number(vec2 coord, int n, int numDigits)\n{\n    int x = int(coord.x);\n    int y = int(coord.y);\n    if(x < 0 || y < 0 || x >= FONT_WIDTH*numDigits || y >= FONT_HEIGHT)\n    {\n        return 0.0;\n    }\n    \n    int d = x \/ FONT_WIDTH;\n    x = x - d * FONT_WIDTH;\n    int tmp = int((float(n) + 0.5) \/ pow(10.,float((numDigits - 1) - d)));\n    if(tmp == 0 && d < numDigits - 2)\n        return 0.0;\n\n    tmp = tmp - tmp\/10*10;\n    return Letter(x, y, tmp) ? 1.0 : 0.0;\n}\n\nbool Map(vec2 coord, int level)\n{\n    int x = int(coord.x);\n    int y = int(coord.y);\n    \n    if(level == 0) return false;\n    \n    if(y < 0 || y >= LEVEL_HEIGHT) return false;\n    if(x < 0 || x >= LEVEL_WIDTH) return true;\n    \n    level = ModLevel(level);\n    \n    \n    return textureLod(iChannel0, (vec2(x + level*LEVEL_WIDTH, y+LEVEL_START_Y) + 0.5) \/ iChannelResolution[0].xy, 0.0).x > 0.5;\n}\n\nvec3 Tile(vec2 coord, int tile)\n{\n    \/\/coord = floor(coord);\t\/\/pixelate\n    if(tile == 1)\n    {\n        float s = sin((coord.x + coord.y)\/8.0*PI*2.0+1.);\n        return (s >= 0.0 ? vec3(244,106,252) : vec3(252, 194, 252)) \/ 255.0;\n    }\n    else if(tile == 2)\n    {\n        float s = sin((coord.x + coord.y)\/8.0*PI*2.0+1.);\n        return (s >= 0.0 ? vec3(106,244,252) : vec3(194, 252, 252)) \/ 255.0;\n    }\n    else if(tile == 3)\n    {\n        float s = sin((coord.x + coord.y)\/8.0*PI*2.0+1.);\n        return (s >= 0.0 ? vec3(244,252,106) : vec3(252, 252, 194)) \/ 255.0;\n    }\n    else if(tile == 4)\n    {\n        float s = sin((coord.x + coord.y)\/8.0*PI*2.0+1.);\n        return (s >= 0.0 ? vec3(244,252,106) : vec3(252, 252, 194)) \/ 255.0;\n    }\n    \n    return vec3(0.0);\n}\n\nvoid TileShadowColors(int tile, out vec3 color0, out vec3 color1)\n{\n    color0 = color1 = vec3(0);\n    if(tile == 1)\n    {\n        color0 = vec3(244,106,252)\/255.0*.6;\n        color1 = vec3(244,106,252)\/255.0*.4;\n    } else if(tile == 2)\n    {\n        color0 = vec3(106,244,252)\/255.0*.6;\n        color1 = vec3(106,244,252)\/255.0*.4;\n    }\n    else if(tile == 3)\n    {\n        color0 = vec3(244,252,106)\/255.0*.6;\n        color1 = vec3(244,252,106)\/255.0*.4;\n    }\n    else if(tile == 4)\n    {\n        color0 = vec3(244,252,106)\/255.0*.6;\n        color1 = vec3(244,252,106)\/255.0*.4;\n    }\n}\n\n\n\nvec3 LargeBubble(vec2 coord, float time, vec3 color)\n{\n    float radius = 12.0 + sin(time*3.0);\n    float aspect = 1.0 + sin(time*7.5)*.1;\n    float len = abs(length(coord*vec2(aspect, 2.0 - aspect)) - radius);\n    float alpha = max(0.0, 1.0 - len);\n    return mix(color, vec3(1), alpha);\n}\n\nvec3 DrawMap(vec2 pixelCoord, float offset, vec3 color)\n{\n    if(offset < float(LEVEL_HEIGHT_IN_PIXELS)*.5)\n    {\n        int ioffset = int(offset);\n        \n        \/\/ vec3 PrintStr(vec2 fragCoord, int x, int y, int str, vec3 color, vec3 inputColor)\n        color = PrintStr(pixelCoord, 1*8, 25*8+ioffset, STR_BEGINNING0, vec3(1), color);\n        color = PrintStr(pixelCoord, 2*8, 23*8+ioffset, STR_BEGINNING1, vec3(1), color);\n        color = PrintStr(pixelCoord, 6*8, 21*8+ioffset, STR_BEGINNING2, vec3(1), color);\n        color = PrintStr(pixelCoord, 4*8, 19*8+ioffset, STR_BEGINNING3, vec3(1), color);\n        color = PrintStr(pixelCoord, 9*8, 16*8+ioffset, STR_BEGINNING4, vec3(1), color);\n    }\n    \n    int level = int(offset - pixelCoord.y + float(LEVEL_HEIGHT_IN_PIXELS)) \/ LEVEL_HEIGHT_IN_PIXELS;\n    level = ModLevel(level);\n    pixelCoord.y = mod(pixelCoord.y - offset, float(LEVEL_HEIGHT_IN_PIXELS));\n                    \n    vec2 tileCoord = floor((pixelCoord + 0.5) \/ TILE_SIZE);\n    vec2 tileOffset = (pixelCoord - tileCoord*TILE_SIZE);\n    tileOffset.y = (TILE_SIZE - 1.0) - tileOffset.y;\n    \n    \n    \n    \n    int tile = level;\n    if(Map(tileCoord, level))\n    {\n        color = Tile(tileOffset, tile);\n    }\n    else\n    {\n        \/\/TODO: optimize this!\n        vec3 color0, color1;\n        TileShadowColors(tile, color0, color1);\n        bool left = Map(tileCoord+vec2(-1,0), level);\n        bool up = Map(tileCoord+vec2(0,1), level);\n        bool upleft = Map(tileCoord+vec2(-1,1), level);\n        if(upleft && left && up && tileOffset.x < SHADOW_WIDTH && tileOffset.y < SHADOW_WIDTH)\n        \tcolor = (tileOffset.x < tileOffset.y)?color0:color1;\n        else if(upleft && left && tileOffset.x < SHADOW_WIDTH)\n        \tcolor = color0;\/\/ now is the beginning...\n        else if(upleft && up && tileOffset.y < SHADOW_WIDTH)\n        \tcolor = color1;\n        else if(upleft && tileOffset.x < SHADOW_WIDTH && tileOffset.y < SHADOW_WIDTH)\n        \tcolor = (tileOffset.x < tileOffset.y)?color1:color0;\n        else if(left && tileOffset.x < SHADOW_WIDTH)\n            color = (tileOffset.x < tileOffset.y)?color0:vec3(0);\n        else if(up && tileOffset.y < SHADOW_WIDTH)\n            color = (tileOffset.x < tileOffset.y)?vec3(0):color1;\n    }\n    return color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 targetSize = vec2(32.,27.)*TILE_SIZE;\n    if(fragCoord.x > targetSize.x || fragCoord.y > targetSize.y) discard;\n    fragColor = vec4(0);\n    \n    \/\/ load state\n    vec4 gameState = \ttextureLod(iChannel0, (txGameState + 0.5) \/ iChannelResolution[0].xy, 0.0);\n    vec4 gameState2= \ttextureLod(iChannel0, (txGameState2+ 0.5) \/ iChannelResolution[0].xy, 0.0);\n    vec2 playerPos = \ttextureLod(iChannel0, (txPlayerPos + 0.5) \/ iChannelResolution[0].xy, 0.0).xy;\n    vec4 playerSprite =\ttextureLod(iChannel0, (txPlayerSprite + 0.5) \/ iChannelResolution[0].xy, 0.0);\n    vec4 playerFlags =\ttextureLod(iChannel0, (txPlayerFlags + 0.5) \/ iChannelResolution[0].xy, 0.0);\n    \n    vec2 playFieldCoord = fragCoord - vec2(TILE_SIZE*2.0,0);\n    vec2 tileCoord = floor((playFieldCoord + 0.5) \/ TILE_SIZE);\n    vec2 tileOffset = (playFieldCoord - tileCoord*TILE_SIZE);\n    tileOffset.y = (TILE_SIZE - 1.0) - tileOffset.y;\n    \n    float time = iTime;\n    \n\tint level = int(gameState.y);\n    \/*\n    if(gameState.x == 3.0)\n    {\n        \/\/ now is the beginning...\n        \n        fragColor.xyz = Sprite(playFieldCoord - playerPos.xy, 4, fragColor.xyz, fract(time*2.0) > 0.5, 0);\n        fragColor.xyz = LargeBubble(playFieldCoord - playerPos.xy - vec2(8.0, 8.0), time, fragColor.xyz);\n        \n        \n        \n        return;\n    }\n    *\/\n    \n    if(gameState.x == 3.0 || gameState.x == 4.0)\n    {\n        \/\/ transition to level\n        float s = min(1.0, gameState2.z * .01);\n        vec2 pos = mix(gameState2.xy, playerPos.xy, s);\n        float offset = (float(level-1)+s) * float(LEVEL_HEIGHT_IN_PIXELS);\n        if(gameState.x == 3.0)\n        {\n            pos = playerPos;\n            offset = 0.0;\n        }\n    \n        fragColor.xyz = DrawMap(playFieldCoord, offset, fragColor.xyz);\n        \n        fragColor.xyz = Sprite(playFieldCoord - pos.xy, 4, fragColor.xyz, fract(time*2.0) > 0.5, 0, vec3(1));\n        fragColor.xyz = LargeBubble(playFieldCoord - pos.xy - vec2(8.0, 8.0), time, fragColor.xyz);\n        \n        return;\n    }\n    \n    \/\/ header\n    if(tileCoord.y > 24.0)\n    {\n        int score = int(gameState.z);\n        fragColor.xyz = vec3( Number(fragCoord - vec2(0,25.*8.), score, 8) +\n                              Number(fragCoord - vec2(10*8,25.*8.), 30000, 8));\n    \n        fragColor.xyz = PrintStr(fragCoord, 4*8, 26*8, STR_1UP, vec3(0,210,0)\/255., fragColor.xyz);\n        fragColor.xyz = PrintStr(fragCoord, 11*8, 26*8, STR_HIGH_SCORE, vec3(210,0,0)\/255., fragColor.xyz);\n        \n        float playTime = iTime;\t\/\/TODO: fix this\n        if(gameState.x < 4.0)\n        {\n            fragColor.xyz = PrintStr(fragCoord, 25*8, 26*8, STR_1UP, vec3(0,190,255)\/255., fragColor.xyz);\n            fragColor.xyz = PrintStr(fragCoord, 27*8, 25*8, STR_00, vec3(0,190,255)\/255., fragColor.xyz);\n        }\n        else\n        {\n            if(mod(iTime,3.0) < 1.5)\n            {\n                fragColor.xyz = PrintStr(fragCoord, 24*8, 26*8, STR_INSERT, vec3(0,190,255)\/255., fragColor.xyz);\n                fragColor.xyz = PrintStr(fragCoord, 25*8, 25*8, STR_COIN, vec3(0,190,255)\/255., fragColor.xyz);\n            }\n            else\n            {\n                fragColor.xyz = PrintStr(fragCoord, 26*8, 26*8, STR_TO, vec3(0,190,255)\/255., fragColor.xyz);\n                fragColor.xyz = PrintStr(fragCoord, 23*8, 25*8, STR_CONTINUE, vec3(0,190,255)\/255., fragColor.xyz);\n            }\n        }\n        \n        return;\n    }\n\n\n    \n    if(gameState.x == 1.0)\n    {\n        \/\/ bubble bobble splash\n        \n        fragColor.xyz = PrintStr(fragCoord, 3*8, 5*8, STR_COPYRIGHT, vec3(1), fragColor.xyz);\n        fragColor.xyz = PrintStr(fragCoord, 7*8, 3*8, STR_ALL_RIGHTS, vec3(1), fragColor.xyz);\n        \n        float c = sin(iTime*24.5)*.5+0.5;\n        \n        \/*\n        vec2 coord = fragCoord + vec2(0, min(0.0,-160.0+floor(iTime*120.0)));\n        float len = 1e10;\n        for(int i = 0; i < 200; i++)\n        {\n            float t = float(i) + 1200.0;\n            vec2 p = vec2((hash11(t)*2.0)*80.0-80.0,(hash11(t+1000.0)*2.0)*40.0-40.0) + vec2(128, 125);\n            len = min(len, length(p - coord) - hash11(t + 2000.0)*25.+8.0);\n        }\n        if(len < 10.0)\n        {\n            vec3 color = vec3(0);\n            color = mix(vec3(250,161,0)\/255.0, color, smoothstep(9.5, 10.0, len));\n            color = mix(vec3(0), color, smoothstep(6.5, 7.0, len));\n            color = mix(vec3(255,240,32)\/255.0, color, smoothstep(5.0, 5.5, len));\n        \tfragColor.xyz = color;\n        }\n        \n        fragColor.xyz = Logo(int(coord.x), int(coord.y), vec3(1), fragColor.xyz);\n\t\t*\/\n        \n        vec2 coord = fragCoord - vec2(0, 50) + vec2(0, min(0.0,-160.0+floor(iTime*120.0)));\n        int x = int(coord.x);\n        int y = int(coord.y);\n        \n        \n        if(x >= 0 && x < LOGO_WIDTH && y >= 0 && y < LOGO_HEIGHT)\n        {\n            vec3 tmp = textureLod(iChannel0, (vec2(x, y+LOGO_START_Y) + 0.5) \/ iChannelResolution[0].xy, 0.0).xyz;\n            float s = sin(iTime*50.0)*.5+.5;\n            \n            if(iTime >= 0.12*20.0) s = 0.0;\n    \t\tvec3 drawColor = mix(vec3(255, 88, 152), vec3(255, 255, 100), s)\/255.0;\n            \n    \n    \t\tfragColor.xyz = tmp.x < 0.0 ? drawColor : tmp;\n        }\n        \n        return;\n    }\n    \n    if(gameState.x == 2.0)\n    {\n        \/\/ insert coin\n        fragColor.xyz = PrintStr(fragCoord, 10*8, 13*8, STR_INSERT_COIN, vec3(1), fragColor.xyz);\n        return;\n    }\n    \n    if(gameState.x == 6.0)\n    {\n        \/\/ game over        \n        fragColor.xyz = PrintStr(fragCoord, 12*8, 13*8, STR_GAME_OVER, vec3(1), fragColor.xyz);\n        fragColor.xyz = PrintStr(fragCoord, 11*8, 7*8, STR_PUSH_START, vec3(1), fragColor.xyz);\n        return;\n    }\n    \n    fragColor.xyz = DrawMap(playFieldCoord, float(level * LEVEL_HEIGHT_IN_PIXELS), fragColor.xyz);\n    \n    int lives = int(gameState.w);\n    \n    \/\/ bubbles    \n    for(int i = 0; i < MAX_ENTITIES; i++)\n    {\n        vec4 entity0 = textureLod(iChannel0, (vec2(i, ENTITIES_START_Y + 0) + 0.5) \/ iChannelResolution[0].xy, 0.0);\n        vec4 entity1 = textureLod(iChannel0, (vec2(i, ENTITIES_START_Y + 1) + 0.5) \/ iChannelResolution[0].xy, 0.0);\n        if(entity0.w == ENTITY_TYPE_BUBBLE && entity0.z >= -BUBBLE_DEATH_FRAMES)\n        {\n            float radius =  min(8.,1.0 + entity0.z*.5);\n            if(entity0.z < 0.0) radius = 8.0;\n            vec2 delta = playFieldCoord - entity0.xy;\n            float aspect = 1.0 + sin(entity0.z*.1 )*.1;\n            float l = length(delta*vec2(aspect,2.0-aspect));\n            if(l < radius + 1.)\n            {\n                float l2 = length(delta + vec2(2,-2));\n                float c = max(0.0, 1.0 - entity0.z \/ BUBBLE_ATTACK_FRAMES);\n                \n                if(entity0.z >= 0.0)\n                {    \n                    if(entity1.y >= 0.0)\n                    {\n                        \/\/ draw monster inside\n                        fragColor.xyz = Sprite(delta*1.25 + vec2(8.,8.), MONSTER_SPRITE_START_IDX, fragColor.xyz, false, 0, vec3(1));\n                    }\n                    \n                    \/\/ bubble\n                    float shake = max(0., entity0.z - (BUBBLE_LIFE_FRAMES - 120.0));\n                    shake = sin(shake)*.3 + 1.0;\n                    float alpha = max(0., 1.0 - abs(l - 7.5)*.75);\n                \tfragColor.xyz = ((fragColor.xyz + c) * (mix(vec3(1), BUBBLE_COLOR, c)) + (alpha*.75*BUBBLE_COLOR + exp(-l2)))*shake;\n                }\n                else\n                {\n                    \/\/ bursting animation\n                    float angle = fract(atan(delta.y, delta.x)\/(2.0*PI));\n                    float band = min(.4 - entity0.z*.05, 1.3);\n                    float q = abs(0.5 - 2.0*fract(angle*16.0))*5.0\/l * float(l > radius*(band-.1) && l < radius*band);\n                    q = clamp(q, 0.0, 1.0);\n                    fragColor.xyz = mix(fragColor.xyz, vec3(1), vec3(q));\n                }\n            }\n        }\n    }\n    \n    \/\/ draw monsters\/tumblers\/items\n    for(int i = 0; i < MAX_ENTITIES; i++)\n    {\n        vec4 entity0 = textureLod(iChannel0, (vec2(i, ENTITIES_START_Y + 0) + 0.5) \/ iChannelResolution[0].xy, 0.0);\n        vec4 entity1 = textureLod(iChannel0, (vec2(i, ENTITIES_START_Y + 1) + 0.5) \/ iChannelResolution[0].xy, 0.0);\n        if(entity0.w == ENTITY_TYPE_MONSTER)\n        {\n            int frame = int(mod(entity0.z*.1, 4.0));\n            fragColor.xyz = Sprite(playFieldCoord - entity0.xy, MONSTER_SPRITE_START_IDX+frame, fragColor.xyz, entity1.x > 0.0, 0, vec3(1));\n        }\n        else if(entity0.w == ENTITY_TYPE_TUMBLING_MONSTER)\n        {\n            int rot = int(mod(entity0.z*.1, 4.0));\n            int frame = int(mod(entity0.z*.2, 4.0));\n            fragColor.xyz = Sprite(playFieldCoord - entity0.xy, MONSTER_SPRITE_START_IDX+frame, fragColor.xyz, entity1.x > 0.0, rot, vec3(0.5,0.7,1));\n        }\n        else if(entity0.w == ENTITY_TYPE_ITEM)\n        {\n            int frame = int(entity0.z);\n            fragColor.xyz = Sprite(playFieldCoord - entity0.xy, ITEM_SPRITE_START_IDX+frame, fragColor.xyz, false, 0, vec3(1));\n        }\n    }\n\n    if(playerFlags.y >= 0.0)\n    {\n        float intensity = 1.0 + 0.1*sin(playerFlags.y)*float(playerFlags.y < INVULNERABLE_FRAMES);\n        \/\/ alive\n        fragColor.xyz = Sprite(playFieldCoord - playerPos, int(playerSprite.x), fragColor.xyz, playerSprite.y != 0.0, 0, vec3(intensity));\n    }\n    else\n    {\n        \/\/ dead\n        int rot = int(-playerFlags.y)\/16;\n        rot = rot - rot\/4*4;\n        fragColor.xyz = Sprite(playFieldCoord - playerPos, int(playerSprite.x), fragColor.xyz, playerSprite.y != 0.0, rot, vec3(1));\n    }\n    \n    \n    \n    if(fragCoord.x < 2.0*8.0)\n    {\n    \t\/\/ level\n        if(fragCoord.y > 23.5*8.0)\n        {\n            fragColor.xyz -= Number(fragCoord - vec2(-1,24.*8.-1.) + vec2(-1,1), level, 2);\n            fragColor.xyz = clamp(fragColor.xyz, 0.0, 1.0);\n            fragColor.xyz += Number(fragCoord - vec2(-1,24.*8.-1.), level, 2);\n        }\n        \/\/ lives\n        if(fragCoord.y < 8.0)\n        {\n            fragColor.xyz -= Number(fragCoord - vec2(-1,0.*8.-1.) + vec2(-1,1), lives, 2);\n            fragColor.xyz = clamp(fragColor.xyz, 0.0, 1.0);\n            fragColor.xyz += Number(fragCoord - vec2(-1,0.*8.-1.), lives, 2);\n        }\n    }\n}","name":"Buf B","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"4tdcWS","date":"1533861026","viewed":10139,"name":"[SH18] Woman","username":"reinder","description":"I wanted to create an organic-looking SDF scene in a single, fully procedural, fragment shader.","likes":186,"published":3,"flags":1,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ [SH18] Woman. Created by Reinder Nijhoff 2018\n\/\/ Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n\/\/ @reindernijhoff\n\/\/\n\/\/ https:\/\/www.shadertoy.com\/view\/4tdcWS\n\/\/\n\/\/ I wanted to create an organic-looking SDF scene in a single, fully procedural,\n\/\/ fragment shader. The scene is modelled for this specific camera viewpoint and \n\/\/ lighting setup.\n\/\/\n\/\/ Please change AA (line 13) to 1 if this shader is running slow.\n\/\/\n\n#define AA 1\n#define FLOOR 0.\n#define BODY 1.\n#define HAIR 2.\n\n\/\/\n\/\/ Hash functions by Dave Hoskins:\n\/\/\n\/\/ https:\/\/www.shadertoy.com\/view\/4djSRW\n\/\/\n\nfloat hash12(vec2 p) {\n    vec3 p3  = fract(vec3(p.xyx) * 443.8975);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3) {\n    p3 = fract(p3 * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yxz + 19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nfloat noise(in vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f*f*(3. -2.*f);\n    \n    return mix(mix(hash12(i + vec2(0, 0)), \n                   hash12(i + vec2(1, 0)), u.x), \n               mix(hash12(i + vec2(0, 1)), \n                   hash12(i + vec2(1, 1)), u.x), u.y);\n}\n\n\/\/\n\/\/ SDF framework by Inigo Quilez:\n\/\/\n\/\/ https:\/\/www.shadertoy.com\/view\/Xds3zN\n\/\/\n\nvec2 boxIntersect(in vec3 ro, in vec3 rd, in vec3 rad) {\n    vec3 m = 1.\/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    \n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    \n    if(tN > tF || tF < .0) return vec2(-1);\n    \n    return vec2(tN, tF);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(.5 + .5*(b - a)\/k, .0, 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat udRoundBox(vec3 p, vec3 b, float r) {\n    return length(max(abs(p)-b, .0)) -r;\n}\n\nfloat sdCapsuleF(vec3 p, vec3 a, vec3 b, const float r0, const float r1, const float f) {\n    vec3 d = b -a;\n    float h = length(d);\n    d = normalize(d);\n    float t=dot(p-a, d);\n    float th = t\/h;\n    return distance(a+clamp(t,0.,h)*d, p)-mix(r0, r1, th) * \n           max(0., 1.+f-f*4.*abs(th-.5)*abs(th -.5));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, const float r0, const float r1) {\n    vec3 d = b -a;\n    float h = length(d);\n    d = normalize(d);\n    float t=clamp(dot(p-a, d), 0., h);\n    return distance(a+t*d, p) -mix(r0, r1, t\/h);\n}\n\nfloat mapHand(in vec3 p) {\n    float sph = length(p) - .1;\n    if (sph > .1) return sph; \/\/  bounding sphere\n    \n    const float s = 1.175;\n    float d = udRoundBox(p, vec3(.0175\/s + p.y * (.25\/s), .035\/s + p.x * (.2\/s), 0.), .01);\n    d = smin(d, min(sdCapsule(p, vec3(.025, .0475, 0)\/s, vec3(.028, .08, .02)\/s, .01\/s, .0075\/s), \n                    sdCapsule(p, vec3(.028, .08, .02)\/s, vec3(.03, 0.1, .06)\/s, .0075\/s, .007\/s)), .0057);\n    d = smin(d, min(sdCapsule(p, vec3(.01, .0425, 0)\/s, vec3(.008, .07, .025)\/s, .009\/s, .0075\/s), \n                    sdCapsule(p, vec3(.008, .07, .025)\/s, vec3(.008, .085, .065)\/s, .0075\/s, .007\/s)), .0057);\n    d = smin(d, min(sdCapsule(p, vec3(-.01, .04, 0)\/s, vec3(-.012, .065, .028)\/s, .009\/s, .0075\/s), \n                    sdCapsule(p, vec3(-.012, .065, .028)\/s, vec3(-.012, .07, .055)\/s, .0075\/s, .007\/s)), .0057);\n    d = smin(d, min(sdCapsule(p, vec3(-.025, .035, 0)\/s, vec3(-.027, .058, .03)\/s, .009\/s, .0075\/s), \n                    sdCapsule(p, vec3(-.027, .058, .03)\/s, vec3(-.028, .06, .05)\/s, .0075\/s, .007\/s)), .0057);\n    return d;\n}\n\nvec2 map(in vec3 pos) {\n    const float f0 = .075;\n    const float f1 = .2;\n    const float f2 = .275;\n    \n    vec3 ph = pos;\n    \n    if (pos.x < 0.) {\n        ph += vec3(.11, -.135, .2);\n        ph = mat3(-0.8674127459526062, -0.49060970544815063, 0.08304927498102188, 0.22917310893535614, -0.5420454144477844, -0.8084964156150818, 0.4416726529598236, -0.6822674870491028, 0.5826116800308228) * ph;\n    } else {\n        ph.x = -ph.x;\n        ph += vec3(.075, -.09, .125);\n        ph = mat3(-0.6703562140464783, -0.7417424321174622, 0.020991835743188858, 0.36215442419052124, -0.3517296612262726, -0.8632093667984009, 0.6476624608039856, -0.5710554718971252, 0.5044094920158386) * ph;\n    }\n    \n    float dh = mapHand(ph);\n    \n    \/\/  right arm\n    float d = sdCapsuleF(pos, vec3(0.13, 0.535, -.036), vec3(.09, 0.292, -0.1), .035, .025, f1);\n    d = smin(d, sdCapsuleF(pos, vec3(.08, 0.29, -0.1), vec3(-.09, 0.15, -0.17), .03, .02, f0), .0051);\n    if (pos.x < 0.) d = smin(d, dh, .015);\n    \n    \/\/  left arm\n    float d1 = sdCapsuleF(pos, vec3(-0.12, 0.56, .02), vec3(-0.11, 0.325, -.045), .035, .025, f1);\n    d1 = smin(d1, sdCapsuleF(pos, vec3(-0.11, 0.315, -.05), vec3(.07, .08, -0.11), .024, .022, f2), .005);\n    if (pos.x > 0.) d1 = smin(d1, dh, .015);\n    d = min(d1, d);\n    \n    \/\/  body\n    vec3 bp1 = pos;\n    bp1 += vec3(0, -.44, -.027);\n    bp1 = mat3(0.9761762022972107, 0.033977385610342026, 0.2143024057149887, -0.07553963363170624, 0.9790945649147034, 0.18885889649391174, -0.20340539515018463, -0.20054790377616882, 0.9583353996276855) * bp1;\n    float db = udRoundBox(bp1, vec3(.07 + bp1.y*.3, 0.135 -abs(bp1.x)*0.2, 0.), .04);\n    \n    vec3 bp2 = pos;\n    bp2 += vec3(-.032, -.235, -.06);\n    bp2 = mat3(0.8958174586296082, -0.37155669927597046, 0.24383758008480072, 0.3379548490047455, 0.9258314967155457, 0.16918234527111053, -0.28861331939697266, -0.0691504031419754, 0.9549453258514404) * bp2;\n    db = smin(db, udRoundBox(bp2, vec3(.065 - bp2.y*.25, 0.1, .02 -bp2.y*.13), .04), .03);\n    \n    db = smin(db, sdCapsule(pos, vec3(0.11, 0.5, -.032), vec3(.05, 0.52, -.015), .04, .035), .01);\n    db = smin(db, sdCapsule(pos, vec3(.01, 0.4, -.01), vec3(.01, 0.7, .0), .045, .04), .02);\n    \n    vec3 bp3 = pos;\n    bp3 += vec3(-.005, -.48, .018);\n    bp3 = mat3(0.9800665974617004, 0.05107402056455612, 0.19199204444885254, 0, 0.9663899540901184, -0.2570805549621582, -0.19866932928562164, 0.2519560754299164, 0.9471265077590942) * bp3;\n    db = smin(db, udRoundBox(bp3, vec3(.056 + bp3.y*.23 , .06, 0.), .04), .01);\n    \n    d = smin(d, db, .01);\n    \n    \/\/  right leg\n    float d2 = sdCapsuleF(pos, vec3(0.152, 0.15, .05), vec3(-.03, 0.43, -.08), .071, .055, f2);\n    d2 = smin(d2, sdCapsuleF(pos, vec3(0.14, .08, .05), vec3(-.01, 0.23, -.02), .05, .02, f1), .075);\n    d = min(d, d2);\n    float d3 = sdCapsuleF(pos, vec3(-.03, 0.43, -.084), vec3(.055, .04, -.04), .053, .02, f0);\n    d3 = smin(d3, sdCapsuleF(pos, vec3(-.0, 0.35, -.05), vec3(.025, 0.2, -.03), .04, .02, f2), .05);\n    d = min(d, d3);\n    \n    \/\/  left leg\n    d = min(d, sdCapsuleF(pos, vec3(-.02, 0.12, 0.1), vec3(-0.145, .08, -0.17), .07, .055, f2));\n    float d4 = sdCapsuleF(pos, vec3(-0.145, .08, -0.17), vec3(0.205, .02, -0.09), .05, .0185, f0);\n    d4 = smin(d4, sdCapsuleF(pos, vec3(-.05, .085, -0.145), vec3(.05, .03, -.09), .035, .03, f2), .0075);\n    \n    \/\/  right feet\n    float d6 = distance(pos, vec3(.0, .0, -0.1)) -.1; \/\/  bounding sphere\n    if(d6 < 0.1) {\n        d = min(d, sdCapsule(pos, vec3(.03, .03, -.08), vec3(.031, .01, -0.146), .015, .005));\n        d = min(d, sdCapsule(pos, vec3(.02, .03, -.08), vec3(.018, .01, -0.1505), .015, .006));\n        d = min(d, sdCapsule(pos, vec3(.00, .03, -.08), vec3(.005, .01, -0.1525), .015, .007));\n        d = min(d, sdCapsule(pos, vec3(-.01, .03, -.08), vec3(-.014, .01, -0.1575), .015, .01));\n    } else {\n        d = min(d6, d);\n    }\n    \n    \/\/  left feet\n    float d5 = distance(pos, vec3(0.25, .025, -0.1)) -.12; \/\/  bounding sphere\n    if(d5 < 0.1) {\n        d5 = sdCapsule(pos, vec3(0.2, .035, -.075), vec3(0.3, .01, -.09), .035, .02);\n        d5 = smin(d5, sdCapsule(pos, vec3(0.31, .035, -.0975), vec3(0.1, .01, -0.10), .015, .02), .02);\n        d5 = smin(d5, sdCapsule(pos, vec3(0.31, .035, -.0975), vec3(0.355, .034, -0.10), .015, .01), .005);\n        d5 = min(d5, sdCapsule(pos, vec3(0.31, .022, -.0875), vec3(0.335, .022, -.09), .02, .01));\n    }\n    d4 = smin(d4, d5, .025);\n    d = min(d, d4);\n    \n    \/\/  hair\n    vec3 hp = pos;\n    hp.x += smoothstep(.55, .45, pos.y)*.035;\n    hp.z *= 1.9 - .8 * pos.y;\n    hp.yz -= 2.*pos.x*pos.x;\n    float h = sdCapsule(hp, vec3(.0, 0.725, -.02), vec3(-.02, 0.415, .0), .094, .085);\n    h = smin(h, sdCapsule(hp, vec3(.0, 0.725, -.02), vec3(.06, 0.705, -.05), .085, .095), .02);\n    h = max(-(pos.y - abs(fract(pos.x*90.) -.5)*0.1 -.14 - smoothstep(-0.2, 0.1, pos.x)*.5), h);\n    \n    return (h < d) ? vec2(h, HAIR) : vec2(d, BODY);\n}\n\n\nfloat calcSoftshadow(in vec3 ro, in vec3 rd, in float mint, in float tmax) {\n    float res = 1.;\n    float t = mint;\n    for(int i=0; i<14; i++) {\n        float h = map(ro + rd*t).x;\n        res = min(res, 8.*h\/t);\n        t += max(h, .02);\n        if(res<.005 || t>tmax) break;\n    }\n    return clamp(res,0.,1.);\n}\n\nvec3 calcNormal(in vec3 pos) {\n    vec2 e = vec2(1,-1)*.00005;\n    return normalize(e.xyy*map(pos + e.xyy).x +\n                     e.yyx*map(pos + e.yyx).x +\n                     e.yxy*map(pos + e.yxy).x +\n                     e.xxx*map(pos + e.xxx).x);\n}\n\nfloat calcAO(in vec3 pos, in vec3 nor) {\n    float occ = 0.;\n    float sca = 1.;\n    for(int i=0; i<5; i++) {\n        float hr = .005 + .12*float(i)\/4.;\n        vec3 aopos =  nor * hr + pos;\n        float dd = min(aopos.y, map(aopos).x);\n        occ += -(dd -hr)*sca;\n        sca *= .95;\n    }\n    return clamp(1. - 3.*occ, 0., 1.);\n}\n\nfloat render(in vec3 ro, in vec3 rd, in vec2 uv) {\n    \/\/  cast ray\n    float planeIntersect = abs(-ro.y\/rd.y);\n    vec2 box = boxIntersect(ro, rd, vec3(.37, 1, .3));\n    float t = box.x;\n    float tmax = min(box.y, planeIntersect);\n    \n    float m = FLOOR;\n    if (t > 0.) {\n        for(int i=0; i<40; i++) {\n            float precis = .0004*t;\n            vec2 res = map(ro+rd*t);\n            m = res.y;\n            if(abs(res.x) < precis || t > tmax) break;\n            t += res.x;\n        }\n    }\n    if(t>=tmax || t<0.) {\n        t = rd.y < 0. ? planeIntersect : 1000.;\n        m = FLOOR;\n    }\n    \n    \/\/  shade scene\n    float col = 0.;\n    if(t < 10.) {\n        vec3 pos = ro + t*rd;\n        vec3 nor = vec3(0, 1, 0);\n        \n        if (m < FLOOR + .5) {\n            col = .03;\n        } else {\n            col = .5;\n            nor = calcNormal(pos);\n        }\n        if (m > BODY + .5) {\n            col = 0.;\n        }\n        nor = normalize(nor + (hash33(pos) -.5) * .1);\n        vec3 ligp = vec3(5., 5., -.5);\n        vec3 lig = -normalize(pos - ligp);\n        float dif = clamp(dot(nor, lig), 0., 1.);\n        float bac = clamp(dot(nor, normalize(vec3(-.2, .5, -.02))), .0, 1.0)\n                    *clamp(1.-pos.y,0.,1.);  \n        if(m > FLOOR) bac *= clamp(-10.*pos.z+.4,0.,1.);\n        \n        float occ, sha;\n        if (pos.x > .4 || pos.z > 1.) {\n            occ = sha = 1.;\n        } else {\n            occ = calcAO(pos, nor);\n            sha = calcSoftshadow(pos, lig, .01, 1.5);\n        }\n        \n        col *= 1.30*dif*sha*(.25+.75*occ) + .5*bac*occ;\n        \n        if (m > BODY + .5) {\n            \/\/ totally fake hair lighting\n            vec3 ref = reflect(rd, nor);\n            vec3 hal = normalize(normalize(vec3(-.1, .5, .35)) -rd);\n            vec2 hv = mix(vec2(pos.x*60. -pos.z*35., 0.), \n                          vec2(-pos.x*50. -pos.z*50., 0.), \n                          smoothstep(.0, .01, -dot(pos, normalize(vec3(-1., .15, .45)))));\n            float n = noise(hv*20. + vec2(2. + 10.*sin(pos.y*20.+.4), 2.5));\n            n = smoothstep(.4, 1., n);\n            float nd = noise(hv*40.+ vec2(2. + 10.*sin(pos.y*20.+.4), .5));\n            n *= nd * nd;\n            col += n * pow(max(0., dot(ref, hal)), 8.);\n            col += .03 * n * max(0., dot(ref, hal)) * smoothstep(.75, .5, pos.y);\n        }\n        \n        col *= smoothstep(.985, 1., dot(normalize(vec3(0.7, 0.58, -.05)), lig));\n    }\n    \n    return clamp(col, 0., 1.);\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta) {\n    vec3 cw = normalize(ta -ro);\n    vec3 cu = normalize(cross(cw, vec3(0,1,0)));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float angle = -.18+ .18*sin(iTime*0.5);\n    float tot = 0.;\n    \n    for(int m=0; m<AA + min(0,iFrame); m++)\n        for(int n=0; n<AA + min(0,iFrame); n++) {\n            vec2 o = vec2(float(m), float(n))\/float(AA) - .5;\n            vec2 p = (-iResolution.xy + 2.*(fragCoord+o))\/iResolution.y;\n            \n            p.x -= .8;\n            \n            vec3 ro = vec3(2.9*sin(angle) , .65, -2.9*cos(angle));\n            vec3 ta = vec3(0., 0.45, 0.);\n            mat3 ca = setCamera(ro, ta);\n            vec3 rd = ca * normalize(vec3(p.xy, 5));\n            \n            float col = render(ro, rd, p);\n            tot += pow(col, .4545);\n        }\n    tot \/= float(AA*AA);\n    \n    tot += .075 * hash12(fragCoord\/iResolution.xy);\n    tot *= 1.35;\n    \n    fragColor = vec4(min(tot*vec3(1, .97, .92), 1.), 1.);\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd ) {\n    vec2 p = (-iResolution.xy + 2.*fragCoord)\/iResolution.y;\n    float c = pow(render(ro + vec3(0,.65,-1), rd, p), .4545);\n    fragColor = vec4(c,c,c,1.);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"3tsyzl","date":"1593154586","viewed":10139,"name":"Julia - Quaternion 3","username":"iq","description":"The cubic Julia set used in the introduction of my video \"Geodes\" ([url]https:\/\/www.shadertoy.com\/view\/3llyzl[\/url]). It has 3 bounces of super simple GI (no specular) and some temporal reprojection to remove noise.","likes":147,"published":3,"flags":32,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Copyright Inigo Quilez, 2020 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work neither\n\/\/ as it is or altered, here on Shadertoy or anywhere else, in any\n\/\/ form including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it or train a neural\n\/\/ network with it without permission. I share this Work for educational\n\/\/ purposes, and you can link to it, through an URL, proper attribution\n\/\/ and unmodified screenshot, as part of your educational material. If\n\/\/ these conditions are too restrictive please contact me and we'll\n\/\/ definitely work it out.\n\n\/\/ The Julia set of f(z) = z\u00b3 + c, as rendered for the Youtube\n\/\/ video called \"Geodes\": https:\/\/www.youtube.com\/watch?v=rQ2bnU4dkso\n\/\/\n\/\/ I simplified a few things, reduced the number of GI bounces\n\/\/ and did some temporal reprojection to keep it more or less\n\/\/ real-time while looking similar to the one in the video.\n\/\/\n\/\/ Explanations:\n\/\/  https:\/\/iquilezles.org\/articles\/distancefractals\n\/\/  https:\/\/iquilezles.org\/articles\/orbittraps3d\n\/\/\n\/\/ Related shaders:\n\/\/\n\/\/ Julia - Quaternion 1 : https:\/\/www.shadertoy.com\/view\/MsfGRr\n\/\/ Julia - Quaternion 2 : https:\/\/www.shadertoy.com\/view\/lsl3W2\n\/\/ Julia - Quaternion 3 : https:\/\/www.shadertoy.com\/view\/3tsyzl\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord \/ iResolution.xy;\n\n    vec3 col = texture( iChannel0, p ).xyz;\n\n    \/\/ color grade\n    col = col*2.0\/(1.0+col);\n    col = pow( col, vec3(0.4545) );\n    col = pow(col,vec3(0.85,0.97,1.0));\n    col = col*0.5 + 0.5*col*col*(3.0-2.0*col);\n\n    \/\/ vignette\n    col *= 0.5 + 0.5*pow( 16.0*p.x*p.y*(1.0-p.x)*(1.0-p.y), 0.1 );\n    \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ Created by inigo quilez - iq\/2020\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ The Julia set of f(z) = z\u00b3 + c, as rendered for the Youtube\n\/\/ video called \"Geodes\": https:\/\/www.shadertoy.com\/view\/3llyzl\n\/\/\n\/\/ I simplified a few things, reduced the number of GI bounces\n\/\/ and did some temporal reprojection to keep it more or less\n\/\/ real-time while looking similar to the one in the video.\n\/\/\n\/\/ Explanations:\n\/\/  https:\/\/iquilezles.org\/articles\/distancefractals\n\/\/  https:\/\/iquilezles.org\/articles\/orbittraps3d\n\/\/\n\/\/ Related shaders:\n\/\/\n\/\/ Julia - Quaternion 1 : https:\/\/www.shadertoy.com\/view\/MsfGRr\n\/\/ Julia - Quaternion 2 : https:\/\/www.shadertoy.com\/view\/lsl3W2\n\/\/ Julia - Quaternion 3 : https:\/\/www.shadertoy.com\/view\/3tsyzl\n\n\n\/\/ disable TRAPs to see just the set\n#define TRAPS\n\n\/\/ disable CUT to see the whole set\n#define CUT\n\nconst int   kNumIte = 200;\nconst float kPrecis = 0.00025;\nconst vec4  kC = vec4(-2,6,15,-6)\/22.0;\nconst float kFocLen = 3.0;\n#ifdef TRAPS\nconst float kBSRad = 2.0;\n#else\nconst float kBSRad = 1.2;\n#endif\n#define     kNumBounces 3\n\n\/\/ --------------------------------------\n\/\/ oldschool rand() from Visual Studio\n\/\/ --------------------------------------\nint   seed = 1;\nint   rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())\/32767.0; }\nvoid  srand( ivec2 p, int frame )\n{\n    int n = frame;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589; \/\/ by Hugo Elias\n    n += p.y;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589;\n    n += p.x;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589;\n    seed = n;\n}\n\n\/\/--------------------------------------------------------------------------------\n\/\/ http:\/\/amietia.com\/lambertnotangent.html\n\/\/--------------------------------------------------------------------------------\nvec3 cosineDirection( in vec3 nor)\n{\n    float u = frand()*2.0-1.0;\n    float a = frand()*6.28318531;\n    return normalize(nor+vec3(sqrt(1.0-u*u)*vec2(cos(a),sin(a)), u) );\n}\n\/\/--------------------------------------------------------------------------------\n\/\/ quaternion manipulation\n\/\/--------------------------------------------------------------------------------\nvec4 qSquare( in vec4 q )\n{\n    return vec4(q.x*q.x - q.y*q.y - q.z*q.z - q.w*q.w, 2.0*q.x*q.yzw);\n}\nvec4 qCube( in vec4 q )\n{\n    vec4  q2 = q*q;\n    return vec4(q.x  *(    q2.x - 3.0*q2.y - 3.0*q2.z - 3.0*q2.w), \n                q.yzw*(3.0*q2.x -     q2.y -     q2.z -     q2.w));\n}\nfloat qLength2( in vec4 q ) { return dot(q,q); }\n\/\/--------------------------------------------------------------------------------\n\/\/ ray-sphere intersection\n\/\/ https:\/\/iquilezles.org\/articles\/intersectors\n\/\/--------------------------------------------------------------------------------\nvec2 iSphere( in vec3 ro, in vec3 rd, in float rad )\n{\n\tfloat b = dot( ro, rd );\n\tfloat c = dot( ro, ro ) - rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n    h = sqrt(h);\n\treturn vec2(-b-h, -b+h );\n}\n\/\/--------------------------------------------------------------------------------\n\/\/ build camera rotation matrix\n\/\/--------------------------------------------------------------------------------\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\/\/--------------------------------------------------------------------------------\n\/\/ SDF of the Julia set z\u00b3+c\n\/\/ https:\/\/iquilezles.org\/articles\/distancefractals\n\/\/--------------------------------------------------------------------------------\nvec2 map( in vec3 p )\n{\n    vec4 z = vec4( p, 0.0 );\n    float dz2 = 1.0;\n\tfloat m2  = 0.0;\n    float n   = 0.0;\n    #ifdef TRAPS\n    float o   = 1e10;\n    #endif\n    \n    for( int i=0; i<kNumIte; i++ ) \n\t{\n        \/\/ z' = 3z\u00b2 -> |z'|\u00b2 = 9|z\u00b2|\u00b2\n\t\tdz2 *= 9.0*qLength2(qSquare(z));\n        \n        \/\/ z = z\u00b3 + c\t\t\n\t\tz = qCube( z ) + kC;\n        \n        \/\/ stop under divergence\t\t\n        m2 = qLength2(z);\t\t\n\n        \/\/ orbit trapping : https:\/\/iquilezles.org\/articles\/orbittraps3d\n        #ifdef TRAPS\n        o = min( o, length(z.xz-vec2(0.45,0.55))-0.1 );\n        #endif\n        \n        \/\/ exit condition\n        if( m2>256.0 ) break;\t\t\t\t \n\t\tn += 1.0;\n\t}\n   \n\t\/\/ sdf(z) = log|z|\u00b7|z|\/|dz| : https:\/\/iquilezles.org\/articles\/distancefractals\n\tfloat d = 0.25*log(m2)*sqrt(m2\/dz2);\n    \n    #ifdef TRAPS\n    d = min(o,d);\n    #endif\n    #ifdef CUT\n    d = max(d, p.y);\n    #endif\n    \n\treturn vec2(d,n);        \n}\n\n\/\/--------------------------------------------------------------------------------\n\/\/ Compute Normal to SDF\n\/\/--------------------------------------------------------------------------------\n\n#if 1\n\/\/ https:\/\/iquilezles.org\/articles\/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    const vec2 e = vec2(1.0,-1.0)*0.5773*kPrecis;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n#else\n\/\/ https:\/\/iquilezles.org\/articles\/juliasets3d\nvec3 calcNormal( in vec3 p )\n{\n    #ifdef TRAPS\n    the code below only works for the actual Julia set, not the traps\n    #endif\n        \n    vec4 z = vec4(p,0.0);\n\n    \/\/ identity derivative\n    mat4x4 J = mat4x4(1,0,0,0,  \n                      0,1,0,0,  \n                      0,0,1,0,  \n                      0,0,0,1 );\n\n  \tfor(int i=0; i<kNumIte; i++)\n    {\n        \/\/ f(q) = q\u00b3 + c = \n        \/\/   x =  x\u00b2x - 3y\u00b2x - 3z\u00b2x - 3w\u00b2x + c.x\n        \/\/   y = 3x\u00b2y -  y\u00b2y -  z\u00b2y -  w\u00b2y + c.y\n        \/\/   z = 3x\u00b2z -  y\u00b2z -  z\u00b2z -  w\u00b2z + c.z\n        \/\/   w = 3x\u00b2w -  y\u00b2w -  z\u00b2w -  w\u00b2w + c.w\n\t\t\/\/\n        \/\/ Jacobian, J(f(q)) =\n        \/\/   3(x\u00b2-y\u00b2-z\u00b2-w\u00b2)  6xy            6xz            6xw\n        \/\/    -6xy           3x\u00b2-3y\u00b2-z\u00b2-w\u00b2 -2yz           -2yw\n        \/\/    -6xz          -2yz            3x2-y\u00b2-3z\u00b2-w\u00b2 -2zw\n        \/\/    -6xw          -2yw           -2zw            3x\u00b2-y\u00b2-z\u00b2-3w\u00b2\n        \n        float k1 = 6.0*z.x*z.y, k2 = 6.0*z.x*z.z;\n        float k3 = 6.0*z.x*z.w, k4 = 2.0*z.y*z.z;\n        float k5 = 2.0*z.y*z.w, k6 = 2.0*z.z*z.w;\n        float sx = z.x*z.x, sy = z.y*z.y;\n        float sz = z.z*z.z, sw = z.w*z.w;\n        float mx = 3.0*sx-3.0*sy-3.0*sz-3.0*sw;\n        float my = 3.0*sx-3.0*sy-    sz-    sw;\n        float mz = 3.0*sx-    sy-3.0*sz-    sw;\n        float mw = 3.0*sx-    sy-    sz-3.0*sw;\n        \n        \/\/ chain rule of jacobians\n        J = J*mat4x4( mx, -k1, -k2, -k3,\n                      k1,  my, -k4, -k5,\n                      k2, -k4,  mz, -k6,\n                      k3, -k5, -k6,  mw );\n        \/\/ q = q\u00b3 + c\n        z = qCube(z) + kC; \n        \n        \/\/ exit condition\n        if(dot2(z)>256.0) break;\n    }\n\n    return (p.y>0.0 ) ? vec3(0.0,1.0,0.0) : normalize( (J*z).xyz );\n}\n#endif\n\n\/\/--------------------------------------------------------------------------------\n\/\/ ray-scene intersection\n\/\/--------------------------------------------------------------------------------\nvec2 raycast( in vec3 ro, in vec3 rd )\n{\n    float tmax = 7.0;\n\tfloat tmin = kPrecis;    \n\n    \/\/ intersect clipping plane\n    #ifdef CUT\n    const float kSplit = 0.01;\n    float tpS = (kSplit-ro.y)\/rd.y;\n    if( tpS>0.0 )\n    {\n        if( ro.y>kSplit ) tmin = max(tmin,tpS);\n        else              tmax = min(tmax,tpS);\n    }\n\t#endif\n    \n    \/\/ intersect lower clipping plane\n    #if 1\n    {\n    float tpF = (-0.8-ro.y)\/rd.y;\n    if( tpF>0.0 ) tmax = min(tmax,tpF);\n    }\n    #endif\n\n    \/\/ intersect bounding sphere\n    #if 1\n    vec2 bv = iSphere( ro, rd, kBSRad );\n    if( bv.y<0.0 ) return vec2(-2.0,0.0);\n    tmin = max(tmin,bv.x);\n    tmax = min(tmax,bv.y);\n\t#endif\n    \n    \/\/ raymarch\n    vec2  res = vec2(-1.0);\n    float t = tmin;\n\tfloat lt = 0.0;\n\tfloat lh = 0.0;\n    for(int i=0; i<1024; i++ )\n    {\n        res = map(ro+rd*t);\n        if( res.x<kPrecis ) break;\n\t\tlt = t;\n\t\tlh = res.x;\n        #ifndef TRAPS\n        t += min(res.x,0.2);\n        #else\n        t += min(res.x,0.01)*(0.5+0.5*frand());\n        #endif\n        if( t>tmax ) break;\n    }\n    \/\/ linear interpolation for better isosurface\n\tif( lt>0.0001 && res.x<0.0 ) t = lt - lh*(t-lt)\/(res.x-lh);\n\t\n    res.x = (t<tmax)?t:-1.0;\n\n    return res;\n}\n\n\/\/--------------------------------------------------------------------------------\n\/\/ color of the surface\n\/\/--------------------------------------------------------------------------------\nvec3 colorSurface( in vec3 pos, in vec3 nor, in vec2 tn )\n{\n    vec3 col = 0.5+0.5*cos(log2(tn.y)*0.9+3.5+vec3(0.0,0.6,1.0));\n    if( pos.y>0.0 ) col = mix(col,vec3(1.0),0.2);\n    float inside = smoothstep(14.0,15.0,tn.y);\n    col *= vec3(0.45,0.42,0.40) + vec3(0.55,0.58,0.60)*inside;\n    col = mix(col*col*(3.0-2.0*col),col,inside);\n    col = mix( mix(col,vec3(dot(col,vec3(0.3333))),-0.4),\n                        col, inside);\n    return clamp(col*0.65,0.0,1.0);\n}\n\n\/\/--------------------------------------------------------------------------------\n\/\/ Render the scene through super simplified path-tracing\n\/\/--------------------------------------------------------------------------------\nvec3 render( in  vec2 fragCoord, in vec3 ro, in vec3 rd,\n             out vec3 resPos, out float resT)\n{\n    vec3 colorMask = vec3(1.0);\n \tresT = 1e20;\n    \n    \/\/ path-tracing\n    for( int bounce=0; bounce<kNumBounces; bounce++ )\n    {\n        vec2 tn = raycast( ro, rd );\n        float t = tn.x;\n        if( t < 0.0 )\n        {\n            return (bounce>0) ? colorMask*1.65*step(0.0,rd.y) \n                              : vec3(clamp(0.02+0.021*rd.y,0.0,1.0));\n        }\n        else\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal( pos );\n\n            if( bounce==0 ) { resT = t; resPos = pos; }\n\n\t\t\tcolorMask *= colorSurface( pos, nor, tn );\n            rd = cosineDirection(nor);\n        \tro = pos+nor*kPrecis;\n        }\n   }\n   \n   return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/-----------------------------------------------\n\t\/\/ init random seed\n    \/\/-----------------------------------------------\n    ivec2 q = ivec2(fragCoord);\n    srand( q, iFrame );\n    \n    \/\/-----------------------------------------------\n    \/\/ camera\n    \/\/-----------------------------------------------\n    float an = 0.5+iTime*0.03;\n    vec3  ro = 2.0*vec3(sin(an),0.8,cos(an));\n    #ifdef CUT\n    vec3  ta = vec3( 0.0, -0.3, 0.0 );\n    #else\n    vec3  ta = vec3( 0.0, -0.1, 0.0 );\n\t#endif\n    mat3x3 cam = setCamera(ro,ta,0.0);\n    \n    \/\/-----------------------------------------------\n    \/\/ ray direction\n    \/\/-----------------------------------------------\n    vec2 p = (2.0*fragCoord-iResolution.xy)\/iResolution.y;\n    vec3 rd = normalize( cam*vec3(p.xy,kFocLen) );\n    \n    \/\/-----------------------------------------------\n    \/\/ render fractal\n    \/\/-----------------------------------------------\n    vec3 pos; float resT;\n    vec3 col = render(fragCoord,ro,rd,pos,resT);\n\n    \/\/-----------------------------------------------\n\t\/\/ reproject to previous frame and pull history\n    \/\/-----------------------------------------------\n\n    \/\/ fetch previous camera matrix from the bottom left three pixels\n    mat3x4 oldCam = mat3x4( texelFetch(iChannel0,ivec2(0,0), 0),\n                            texelFetch(iChannel0,ivec2(1,0), 0),\n                            texelFetch(iChannel0,ivec2(2,0), 0) );\n    \/\/ world space point\n    vec4 wpos = vec4(pos,1.0);\n    \/\/ convert to camera space (note inverse multiply)\n    vec3 cpos = wpos*oldCam;\n    \/\/ convert to NDC space (project)\n    vec2 npos = kFocLen*cpos.xy\/cpos.z;\n    \/\/ convert to screen space\n    vec2 spos = 0.5 + 0.5*npos*vec2(iResolution.y\/iResolution.x,1.0);\n\t\/\/ convert to raster space\n    vec2 rpos = spos * iResolution.xy;\n\n    \/\/ read color+depth from this point's previous screen location\n    vec4 ocolt = textureLod( iChannel0, spos, 0.0 );\n    \/\/ if we consider the data contains the history for this point\n    if( iFrame>0 && resT<100.0 && (rpos.y>1.5||rpos.x>3.5) )\n    {\n        \/\/ blend with history (it's a IIR low pas filter really)\n        col = mix( ocolt.xyz, col, 0.06 );\n    }\n    \/\/ output\n\tif( q.y==0 && q.x<3 )\n    {\n    \t\/\/ camera matrix in lower left three pixels, for next frame\n             if( q.x==0 ) fragColor = vec4( cam[0], -dot(cam[0],ro) );\n        else if( q.x==1 ) fragColor = vec4( cam[1], -dot(cam[1],ro) );\n        else              fragColor = vec4( cam[2], -dot(cam[2],ro) );\n    }\n    else\n    {\n        \/\/ color and depth\n        fragColor = vec4( col, resT );\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"lsXSDn","date":"1398957530","viewed":10129,"name":"Matrix Rain Shader","username":"raja","description":"Matrix Rain","likes":125,"published":1,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"\/media\/a\/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"\/media\/ap\/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define RAIN_SPEED 1.75 \/\/ Speed of rain droplets\n#define DROP_SIZE  3.0  \/\/ Higher value lowers, the size of individual droplets\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rchar(vec2 outer, vec2 inner, float globalTime) {\n\t\/\/return float(rand(floor(inner * 2.0) + outer) > 0.9);\n\t\n\tvec2 seed = floor(inner * 4.0) + outer.y;\n\tif (rand(vec2(outer.y, 23.0)) > 0.98) {\n\t\tseed += floor((globalTime + rand(vec2(outer.y, 49.0))) * 3.0);\n\t}\n\t\n\treturn float(rand(seed) > 0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 position = fragCoord.xy \/ iResolution.xy;\n\tvec2 uv = vec2(position.x, position.y);\n    position.x \/= iResolution.x \/ iResolution.y;\n\tfloat globalTime = iTime * RAIN_SPEED;\n\t\n\tfloat scaledown = DROP_SIZE;\n\tfloat rx = fragCoord.x \/ (40.0 * scaledown);\n\tfloat mx = 40.0*scaledown*fract(position.x * 30.0 * scaledown);\n\tvec4 result;\n\t\n\tif (mx > 12.0 * scaledown) {\n\t\tresult = vec4(0.0);\n\t} else \n\t{\n        float x = floor(rx);\n\t\tfloat r1x = floor(fragCoord.x \/ (15.0));\n\t\t\n\n\t\tfloat ry = position.y*600.0 + rand(vec2(x, x * 3.0)) * 100000.0 + globalTime* rand(vec2(r1x, 23.0)) * 120.0;\n\t\tfloat my = mod(ry, 15.0);\n\t\tif (my > 12.0 * scaledown) {\n\t\t\tresult = vec4(0.0);\n\t\t} else {\n\t\t\n\t\t\tfloat y = floor(ry \/ 15.0);\n\t\t\t\n\t\t\tfloat b = rchar(vec2(rx, floor((ry) \/ 15.0)), vec2(mx, my) \/ 12.0, globalTime);\n\t\t\tfloat col = max(mod(-y, 24.0) - 4.0, 0.0) \/ 20.0;\n\t\t\tvec3 c = col < 0.8 ? vec3(0.0, col \/ 0.8, 0.0) : mix(vec3(0.0, 1.0, 0.0), vec3(1.0), (col - 0.8) \/ 0.2);\n\t\t\t\n\t\t\tresult = vec4(c * b, 1.0)  ;\n\t\t}\n\t}\n\t\n\tposition.x += 0.05;\n\n\tscaledown = DROP_SIZE;\n\trx = fragCoord.x \/ (40.0 * scaledown);\n\tmx = 40.0*scaledown*fract(position.x * 30.0 * scaledown);\n\t\n\tif (mx > 12.0 * scaledown) {\n\t\tresult += vec4(0.0);\n\t} else \n\t{\n        float x = floor(rx);\n\t\tfloat r1x = floor(fragCoord.x \/ (12.0));\n\t\t\n\n\t\tfloat ry = position.y*700.0 + rand(vec2(x, x * 3.0)) * 100000.0 + globalTime* rand(vec2(r1x, 23.0)) * 120.0;\n\t\tfloat my = mod(ry, 15.0);\n\t\tif (my > 12.0 * scaledown) {\n\t\t\tresult += vec4(0.0);\n\t\t} else {\n\t\t\n\t\t\tfloat y = floor(ry \/ 15.0);\n\t\t\t\n\t\t\tfloat b = rchar(vec2(rx, floor((ry) \/ 15.0)), vec2(mx, my) \/ 12.0, globalTime);\n\t\t\tfloat col = max(mod(-y, 24.0) - 4.0, 0.0) \/ 20.0;\n\t\t\tvec3 c = col < 0.8 ? vec3(0.0, col \/ 0.8, 0.0) : mix(vec3(0.0, 1.0, 0.0), vec3(1.0), (col - 0.8) \/ 0.2);\n\t\t\t\n\t\t\tresult += vec4(c * b, 1.0)  ;\n\t\t}\n\t}\n\t\n\tresult = result * length(texture(iChannel0,uv).rgb) + 0.22 * vec4(0.,texture(iChannel0,uv).g,0.,1.);\n\tif(result.b < 0.5)\n\tresult.b = result.g * 0.5 ;\n\tfragColor = result;\n}","name":"","description":"","type":"image"}]}];    var gUseScreenshots = piIsMobile();
    var gThemeName = "classic";



    </script>
</head>

<!-- <body onload="resultsInit(12,null,null)"> -->
<body onload="resultsInitStatic(12,null,null)">

<!-- header =================================================================================== -->


<div id="header">

    <div id="headerBlock1">
        <a href="/" id="headerTitle">Shadertoy</a>
        <form name="formSearch" action="/results" method="get" style="display:inline-block;">
        <div  id="headerSearch">
            <input type="search" id="mySearch" name="query" placeholder="Search..." value=""/>
        </div>
        </form>
    </div>

    <div id="headerBlock2">
            <a class="headerLinks" href="/browse">Browse</a>
        <a class="headerLinks" href="/new">New</a>
        <a class="headerLinks" href="/signin">Sign In</a>
        </div>
</div>
<!-- content ================================================================================== -->

<div id="content">

  <div id="controls">
    <div>
      <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
      Sort:      </div>
      <div class="controlOptions"><div class="pageButtonsCurrent" href="/results?query=&sort=popular&filter=">Popular</div><a class="pageButtons" href="/results?query=&sort=newest&filter=">Newest</a><a class="pageButtons" href="/results?query=&sort=love&filter=">Love</a><a class="pageButtons" href="/results?query=&sort=hot&filter=">Hot</a></div>
    </div>

    <div id="controlFilter">
      <div style="display:flex;margin-right:8px;align-items:center;">Filter:</div>
      <div class="controlOptions"> <a class="pageButtons" href="/results?query=&sort=popular&filter=multipass">Multipass</a><a class="pageButtons" href="/results?query=&sort=popular&filter=soundoutput">GPU Sound</a><a class="pageButtons" href="/results?query=&sort=popular&filter=vr">VR</a><a class="pageButtons" href="/results?query=&sort=popular&filter=soundinput">Microphone</a><a class="pageButtons" href="/results?query=&sort=popular&filter=musicstream">Soundcloud</a><a class="pageButtons" href="/results?query=&sort=popular&filter=webcam">Webcam</a></div>
    </div>

    <div>
        <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
        View:</div>
        <div><a class="pageButtons" href="/slideshow?query=&sort=popular">Slideshow</a></div>
    </div>

    <div class="navigation" id="navTop" ><span style="padding-right:8px;">Results (74098):</span><div class="controlOptions"><a id="pageButtonFirst" class="pageButtons" href="results?query=&sort=popular&from=0&num=12">1</a><span>...</span><a id="pageButton"0 class="pageButtons" href="results?query=&sort=popular&from=624&num=12">53</a><a id="pageButton"1 class="pageButtons" href="results?query=&sort=popular&from=636&num=12">54</a><div id="pageButton"2 class="pageButtonsCurrent" href="results?query=&sort=popular&from=648&num=12">55</div><a id="pageButton"3 class="pageButtons" href="results?query=&sort=popular&from=660&num=12">56</a><a id="pageButton"4 class="pageButtons" href="results?query=&sort=popular&from=672&num=12">57</a><span>...</span><a id="pageButtonLast" class="pageButtons" href="results?query=&sort=popular&from=74088&num=12">6175</a></div>
</div>
  </div>


  <div id="shaderGrid">
    <div class='searchResult'><div class='searchResultContainer' id='Preview_0_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_0_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_0_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_0_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_0_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_0_Thumnail'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_0_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_0_Info'>  <span class='previewText'  id='Preview_0_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_0_TextUser'></span>  <span class='previewStats' id='Preview_0_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_1_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_1_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_1_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_1_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_1_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_1_Thumnail'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_1_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_1_Info'>  <span class='previewText'  id='Preview_1_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_1_TextUser'></span>  <span class='previewStats' id='Preview_1_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_2_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_2_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_2_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_2_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_2_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_2_Thumnail'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_2_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_2_Info'>  <span class='previewText'  id='Preview_2_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_2_TextUser'></span>  <span class='previewStats' id='Preview_2_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_3_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_3_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_3_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_3_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_3_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_3_Thumnail'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_3_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_3_Info'>  <span class='previewText'  id='Preview_3_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_3_TextUser'></span>  <span class='previewStats' id='Preview_3_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_4_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_4_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_4_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_4_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_4_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_4_Thumnail'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_4_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_4_Info'>  <span class='previewText'  id='Preview_4_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_4_TextUser'></span>  <span class='previewStats' id='Preview_4_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_5_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_5_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_5_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_5_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_5_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_5_Thumnail'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_5_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_5_Info'>  <span class='previewText'  id='Preview_5_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_5_TextUser'></span>  <span class='previewStats' id='Preview_5_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_6_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_6_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_6_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_6_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_6_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_6_Thumnail'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_6_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_6_Info'>  <span class='previewText'  id='Preview_6_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_6_TextUser'></span>  <span class='previewStats' id='Preview_6_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_7_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_7_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_7_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_7_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_7_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_7_Thumnail'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_7_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_7_Info'>  <span class='previewText'  id='Preview_7_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_7_TextUser'></span>  <span class='previewStats' id='Preview_7_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_8_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_8_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_8_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_8_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_8_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_8_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_8_Thumnail'>        <img class='previewThumbnailImage' id='Preview_8_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_8_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_8_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_8_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_8_Info'>  <span class='previewText'  id='Preview_8_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_8_TextUser'></span>  <span class='previewStats' id='Preview_8_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_9_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_9_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_9_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_9_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_9_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_9_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_9_Thumnail'>        <img class='previewThumbnailImage' id='Preview_9_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_9_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_9_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_9_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_9_Info'>  <span class='previewText'  id='Preview_9_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_9_TextUser'></span>  <span class='previewStats' id='Preview_9_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_10_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_10_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_10_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_10_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_10_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_10_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_10_Thumnail'>        <img class='previewThumbnailImage' id='Preview_10_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_10_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_10_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_10_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_10_Info'>  <span class='previewText'  id='Preview_10_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_10_TextUser'></span>  <span class='previewStats' id='Preview_10_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_11_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_11_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_11_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_11_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_11_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_11_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_11_Thumnail'>        <img class='previewThumbnailImage' id='Preview_11_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_11_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_11_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_11_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_11_Info'>  <span class='previewText'  id='Preview_11_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_11_TextUser'></span>  <span class='previewStats' id='Preview_11_Stats'></span></div></div>  </div>
  <br>
  <div class="navigation" id="navBottom" ><span style="padding-right:8px;">Results (74098):</span><div class="controlOptions"><a id="pageButtonFirst" class="pageButtons" href="results?query=&sort=popular&from=0&num=12">1</a><span>...</span><a id="pageButton"0 class="pageButtons" href="results?query=&sort=popular&from=624&num=12">53</a><a id="pageButton"1 class="pageButtons" href="results?query=&sort=popular&from=636&num=12">54</a><div id="pageButton"2 class="pageButtonsCurrent" href="results?query=&sort=popular&from=648&num=12">55</div><a id="pageButton"3 class="pageButtons" href="results?query=&sort=popular&from=660&num=12">56</a><a id="pageButton"4 class="pageButtons" href="results?query=&sort=popular&from=672&num=12">57</a><span>...</span><a id="pageButtonLast" class="pageButtons" href="results?query=&sort=popular&from=74088&num=12">6175</a></div>
</div>  <br>      
</div>

<!-- footer ================================================================================== -->

<div id="footer">
    
    <div><span style="color:#ffffff;">Community Forums</span>
      <ul>
      <li><a class="regular" href="/events">Official Events</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/147749602472741">In Facebook (english)</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/1339783682699494">In Facebook (korean)</a></li>
      <li><a class="regular" href="https://discord.gg/XtmMN6E">In Discord</a> (<a class="regular" href="https://discordapp.com/channels/578696555612209173/579531723348639754">direct link</a>)</li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Feedback and Support</span>
      <ul>
      <li><a class="regular" href="https://www.facebook.com/Shadertoy">Facebook</a></li>
      <li><a class="regular" href="https://twitter.com/shadertoy">Twitter</a></li>
      <li><a class="regular" href="https://www.patreon.com/shadertoy">Patreon</a></li>
      <li><a class="regular" href="https://trello.com/b/5hM0CjId">Roadmap</a></li>

      
      </ul>
    </div>

    <div><span style="color:#ffffff;">Shadertoy</span>
      <ul>
      <li><a class="regular" href="/store">Store</a></li>
      <li><a class="regular" href="/howto">Documentation</a></li>
      <li><a class="regular" href="/terms">Terms & Privacy</a></li>
      <li><a class="regular" href="/about">About</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Apps and Plugins</span>
      <ul>
      <li><a class="regular" href="https://itunes.apple.com/us/app/shadertoy/id717961814">Official iPhone App</a> by <a class="user" href="/user/reinder">Reinder</a></li>
      <li><a class="regular" href="https://steamcommunity.com/sharedfiles/filedetails/?id=1726697188">Screensaver</a> by <a class="user" href="/user/kosro">Kosro</a></li>
      <li><a class="regular" href="https://chrome.google.com/webstore/detail/shadertoy-unofficial-plug/ohicbclhdmkhoabobgppffepcopomhgl">Shadertoy plugin</a> by <a class="user" href="/user/patu">Patu</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Tutorials</span>
      <ul>
      <li><a class="regular" href="https://www.youtube.com/watch?v=0ifChJ0nJfM">Shader coding intro</a> by <a class="user" href="/user/iq">iq</a></li>
      <li><a class="regular" href="https://shadertoyunofficial.wordpress.com/">Shadertoy Unofficial</a> by <a class="user" href="/user/FabriceNeyret2">FabriceNeyret2</a></li>
      </ul>
    </div>

</div>

<div id="compliance" style="padding-bottom:6px;visibility:hidden;left:0;top:0px;width:100%;background-color:rgb(200,120,20,0.93);position:absolute;color:#FFFFFF">
    <div style="text-align: center; margin-top:8px">
        We use cookies to give you the best experience on our website. If you continue using Shadertoy, we'll assume that you are happy to receive all cookies on this website. 
        For more information, please review our <a class="regular" href="/terms">Terms & Privacy</a>.
    </div> 
    <div style="text-align: center;margin-top:6px">
        <button type="button" style="width:100px;font-size:inherit" onclick="acceptCompliance()">Accept</button>
    </div>
</div>

<script>
(function runCompliance() 
{
    let showCompliance = 1;
    let allcookies = document.cookie;
    let cookiearray = allcookies.split(';');
    for (var i=0; i<cookiearray.length; i++)
    {
        let name  = cookiearray[i].split('=')[0];
        let value = cookiearray[i].split('=')[1];
        if (name.trim() == "scmp") 
        {
            showCompliance = value;
            break;
        }
    }

    if (showCompliance === 1) 
    {
        var ve = document.getElementById("compliance");
        ve.style.visibility="visible";
    }
})();

function acceptCompliance()
{
    let now = new Date();
    now.setTime( now.getTime() + (5*365*24*60*60*1000) );
    document.cookie="scmp=0;expires=" + now.toUTCString() + ";";

    var ve = document.getElementById("compliance");
    ve.style.visibility="hidden";
}
</script>

</body>
</html>
