<!DOCTYPE HTML>
<html lang="en">
<head>

    
<script async src="https://www.googletagmanager.com/gtag/js?id=G-7SYLWGZYJ2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-7SYLWGZYJ2');
</script>

<title>Browse (42) - Shadertoy BETA</title>
<meta charset="utf-8" />
<meta name="Keywords" content="shadertoy, shader toy, quilez, inigo, jeremias, pol, fractals, demoscene, computer graphics, mathematics, rendering, demo, 3D, realtime, shader, raytracing, raymarching, webgl, glsl" />
<meta name="Description" content="Build shaders, share them, and learn from the best community." />
<meta name="Author" content="Beautypi" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<link rel="image_src" href="https://www.shadertoy.com/img/logo.png" />
<link rel="apple-touch-icon" href="/img/launch_icon_57.png"/>
<link rel="apple-touch-icon" sizes="72x72" href="/img/launch_icon_72.png"/>
<link rel="apple-touch-icon" sizes="114x114" href="/img/launch_icon_114.png"/>
<link rel="shortcut icon" href="/img/favicon.ico"/>

<style>::-webkit-scrollbar {
    height: 8px;
    width: 8px;
    background: #404040;
}

::-webkit-scrollbar-thumb
{
    background: #909090;
    border-radius: 0ex;
}

::-webkit-scrollbar-corner
{
    background: #000;
}

::-webkit-input-placeholder
{
	font-style:italic;
}
input:-moz-placeholder, textarea:-moz-placeholder
{
	font-style:italic;
}
input.placeholder-text, textarea.placeholder-text
{
	font-style:italic;
}

pre 
{
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
    white-space: -pre-wrap;
    white-space: -o-pre-wrap;
    word-wrap: break-word;
}

@font-face
{
    font-family: Lobster;
    src: url("/img/lobster.otf") format("opentype");
}

div#centerScreen
{
    left: 50%;
    top: 50%;
    position: absolute;
}

a.headerLinks:hover
{
    background-color:#505050;
    color : #ff8020;
}

body
{
    color: #000000;
    font-size:12px;
    font-style:normal;
    font-family:Tahoma,Arial;
    background-repeat: no-repeat;
    //background-attachment: fixed;
    padding:0px;
    margin:0px;
    text-align: left;
    background-color: #d0d0d0;
    background-repeat: repeat;
    user-select: text;
}

a,
a:hover,
a:visited
{
  color : inherit;
}

div#content {
    width: 95%;
    overflow: hidden;
    margin: auto;
    padding: 0px;
    min-height: calc(100vh - 80px);
    //box-sizing: border-box;
}


.notificationCount
{
 background-color:#ff0000;
 padding-left:3px;
 padding-right:1px;
 padding-top:1px;
 padding-bottom:1px;
}

div#header
{
    background-color: #404040;
    top: 0px;
    left: 0px;
    width: 100%;
    padding: 0;
    margin: 0;
    color: #ffffff;
    display: flex;
    flex-direction:row;
}

#headerBlock1
{
    width: 50%;
    display:flex;
    align-items:center;
}

a#headerTitle
{
    font-size: 2.25em;
    font-family: Lobster,Tahoma,Arial;
    text-decoration: none;
    padding-left:32px;
    padding-right:32px;
}

#headerSearch
{
    display: inline-block;
    color: #000000;
    width: 300px;
}

input[type=search]#mySearch
{
    width: 100%;
    border-radius: 6px;
    border: 1px solid black;
    padding:12px;
}

#headerBlock2
{
    width: 50%;
    margin-left: auto;
    display: flex;
    justify-content: flex-end;
}


a#headerTitle:hover
{
    color : #ff8020;
}

a.headerLinks
{
    font-weight: bold;
    padding-top: 14px;
    padding-bottom: 14px;
    padding-left: 14px;
    padding-right: 14px;
    margin:0px;
    text-decoration: none;
    transition: background-color 0.15s linear, color 0.15s linear;
}

#footer
{
    background-color: rgba(64,64,64,0.25);
    color: #000000;
    padding: 0px;
    margin: 0px;
    width: 100%;
    display: flex;
    justify-content: space-between;
    flex-wrap: wrap;
}

#footer div
{
    padding-top:10px;
    padding-bottom:0px;
    padding-left:16px;
    padding-right:16px;
}

#footer div ul
{
    margin-left:0px;
    padding-left:16px;
}

#footer div ul li
{
    padding-top:6px;
}

a.regular
{
    font-weight:bold;
    text-decoration:none
}

a.regular:hover
{
  color : #ff8020;
}

a.user
{
    font-weight:bold;
    text-decoration:none;
}

a.user:hover
{
  color : #ff8020;
  text-decoration: underline;
}

.uiButton
{
    border: none;
    outline: none;
    margin: 0px;
    padding: 0px;
    width: 22px;
    height: 22px;
    position: absolute;
    cursor: pointer;
    border-radius: 4px;
}

.uiButton:hover
{
    box-shadow: inset 0px 0px 1px 1px #808080, 0px 0px 1px 1px #808080;
}

.uiDivBUtton
{
    cursor:pointer;
}

.uiDivBUtton:hover
{
    color: #ffffff;
}


.dialog
{
    display: block;
    background-color: #e0e0e0;
    color: #000000;
    border:1px solid #000;
    padding:0px;
    margin:0px;
    text-align:left;
    border-radius: 4px;
    box-shadow:4px 4px 6px 0px rgba(0,0,0,0.5);
    overflow: hidden;
    z-index:1000;
    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;
}

.dialogHeader
{
    left:0px;
    top: 0px;
    width:100%;
    height:32px;
    position: absolute;
    background-color: #808080;
    cursor:move;
}

.dialogTitle
{
    left: 12px;
    top: 4px;
    position: absolute;
    padding: 0px;
    margin: 0px;
    color:#000000;
    font-size:1.5em;
    text-align: left;
    user-select: none;
    -moz-user-select: -moz-none;
    -webkit-user-select: none;
}

.dialogOverlay
{
    z-index:1000;

    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;

    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    width:100%;
    height:100%;
    position:absolute;

    background-color:rgba(0,0,0,.4);
}

.viewsIcon, .likesIcon
{
    border: none;
    outline: none;
    display:inline-block;
    background-repeat:no-repeat;
    top:0px;
    left:0px;
    padding:0px;
    padding-right: 2px;
    margin:0px;
    position:relative;
}

.userPictureSmall
{
    background-color:#808080;
    border: 1px solid #000000;
    width:32px;
    height:32px;
}

.dialogCloseButton
{
    right:8px;
    top: 4px;
    width:22px;
    height:22px;
    position: absolute;
    background-image: url("/img/close.png");
    cursor: pointer;
    border-radius: 4px;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContentButtons
{
     padding:0;
     border:0;
     text-align: justify;
     left: 24px;
     bottom:40px;
     position:absolute;
}

.dialogButton
{
    text-align: center;
    vertical-align: middle;
    display: inline-block;
    border-radius: 4px;
    font-weight: bold;
    cursor: pointer;
    padding-bottom:5px;
    padding-top:4px;
    padding-left: 8px;
    padding-right: 8px;
    margin-left:4px;
    margin-right:4px;
    text-decoration: none;
    color:#000000;
    width: 80px;
    -moz-transition:    background-color 0.15s linear, color 0.15s linear;
    -webkit-transition: background-color 0.15s linear, color 0.15s linear;
    transition:         background-color 0.15s linear, color 0.15s linear;
}

.dialogButton:hover
{
  background-color:#808080;
  color : #ff8020;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContent
{
    color: inherit;
    overflow: auto;
    width:100%;
    height:100%;
    left: 0px;
    top: 32px;
    position:absolute
}

.dialogContentBody
{
    color: inherit;
    width:100%;
    height:auto;
    padding-top:24px;
    padding-bottom:24px;
    padding-left:24px;
    padding-right:24px;
    text-align: left;
}

.formButton
{
    font-weight:bold;
	color:#ffffff;
	border:none;
    text-align:center;
	background-color:#808080;
    border-radius: 4px;
	padding-left:8px;
	padding-right:8px;
	padding-top:4px;
	padding-bottom:4px;
    cursor:pointer;
    min-width:80px;
    box-sizing: border-box;
}
.formInput {
    border-radius: 6px;
    border: 1px solid black;
    padding: 4px;
    border: none;
}
.formButton:hover {
    background-color: #e0e0e0;
}
.formButton:disabled
{
	color:#b0b0b0;
	background-color:#808080;
}

.formButtonSmall
{
    color:#ffffff;
    border:none;
    text-align:center;
    background-color:#808080;
    border-radius: 4px;
    padding-left:2px;
    padding-right:2px;
    padding-top:2px;
    padding-bottom:2px;
    cursor:pointer;
    min-width:40px;
}

.formButtonSmall:hover
{
    background-color: #e0e0e0;
}

.formButtonSmall:disabled
{
    color:#b0b0b0;
    background-color:#808080;
}

.formButtonSmall.disabled2,
.formButton.disabled2 { color:#b0b0b0; background-color:#808080; pointer-events: none; }

.inputForm
{
    padding-left:2%;
    padding-right:2%;
    resize: none;
    text-align: left;
    background-color:#e0e0e0;
    outline: none;
    border-radius: 4px;
    border: 1px solid #808080;
    color:inherit;
    box-sizing: border-box;
}

.inputForm:focus
{
    border: 1px solid #AFCDD8;
    background-color: #EBF2F4;
}

.transparentPannel
{
    background-color:rgba(64,64,64,0.1);
    padding:16px;
}

.comment, .commentSelf, .commentNew
{
    border-radius: 4px;
    width: 100%;
    margin-left: 0px;
    margin-right: 0px;
    margin-top: 0px;
    margin-bottom: 6px;

    padding: 14px;
    box-sizing: border-box;
    display: grid;
    grid-template-columns: 32px auto 8px;
    grid-template-rows: 1fr;
    grid-gap:8px;
}

.comment:nth-child(even)
{
    background-color: rgba(64,64,64,0.1);
}

.comment:nth-child(odd)
{
    background-color: rgba(128,128,128,0.1);
}

.commentSelf
{
    background-color: rgba(240,160,64,0.1);
}

.commentNew
{
    padding-right: 0px;
    grid-template-columns: 40px auto;
}

.commentContent
{
    vertical-align: top;
    text-align: left;
    word-break: break-all;
    word-break: break-word;
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
}


/* ----------------------- media resolutions ------------------------ */

@media screen and (max-width:799px)
{
    div#header {flex-direction:column; }
    #headerBlock1 { width:100%; }
    #headerBlock2 { width:100%; justify-content: space-around;}
    div#headerSearch {width:200px;}
    input#mySearch { width:200px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:10px; }
}

@media screen and (min-width:800px) and (max-width:1279px)
{
    body { font-size: 9px; }
    div#headerSearch {width: 250px;}
    input#mySearch { width:250px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:11px; }
}

@media screen and (min-width:1280px) and (max-width:1439px)
{
    body { font-size: 10px; }
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1440px) and (max-width:1919px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1920px) and (max-width:2559px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}

@media screen and (min-width:2560px) 
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}
body
{
    background-image: url("/img/themes/classic/background.jpg");
}
</style>

    <script>"use strict"

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piCamera
//
//==============================================================================

function piCamera()
{
    var mMatrix = setIdentity();
    var mMatrixInv = setIdentity();

    var mPosition = [0.0,0.0,0.0];
    var mXRotation = 0.0;
    var mYRotation = 0.0;

    var mPositionTarget = [0.0,0.0,0.0];
    var mXRotationTarget = 0.0;
    var mYRotationTarget = 0.0;

    var me = {};
/*
    me.Set = function( pos, dir, roll) 
             {
                 mMatrix    = setLookat( pos, add(pos,dir), [Math.sin(roll),Math.cos(roll),Math.sin(roll)] );
                 mMatrixInv = invertFast( mMatrix );
             };
*/
    me.SetPos = function(pos)
                {
                    mPosition = pos;
                    //mMatrix[ 3] = -(mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                    //mMatrix[ 7] = -(mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                    //mMatrix[11] = -(mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                };
/*
    me.GlobalMove = function(pos)
                    {
                        mMatrix[ 3] -= (mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                        mMatrix[ 7] -= (mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                        mMatrix[11] -= (mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                        mMatrixInv = invertFast(mMatrix);
                    };
*/
    me.LocalMove = function( dis )
                    {
                        dis = matMulvec( setRotationY(-mYRotation), dis);
                        mPositionTarget = sub(mPositionTarget,dis)
                    };

    me.RotateXY = function( x, y)
                  {
                    mXRotationTarget -= x;
                    mYRotationTarget -= y;
                    mXRotationTarget = Math.min( Math.max( mXRotationTarget, -Math.PI/2), Math.PI/2 );
                  };


    me.CameraExectue = function( dt )
    {
        // smooth position
        mXRotation += (mXRotationTarget-mXRotation) * 12.0*dt;
        mYRotation += (mYRotationTarget-mYRotation) * 12.0*dt;
        mPosition = add(mPosition, mul( sub(mPositionTarget, mPosition), 12.0*dt));

        // Make Camera matrix
        mMatrix = matMul( matMul(setRotationX(mXRotation), 
                                 setRotationY(mYRotation)),  
                                 setTranslation(mPosition));
        mMatrixInv = invertFast(mMatrix);

    }

    me.GetMatrix = function() { return mMatrix; };
    me.GetMatrixInverse = function() { return mMatrixInv; };
    me.SetMatrix = function( mat ) 
                    {
                        mMatrix = mat;
                        mMatrixInv = invertFast(mMatrix);

                        mPosition = getXYZ(matMulpoint(mat, [0.0,0.0,0.0]));
                        mPositionTarget = mPosition;
                    };

    me.GetPos = function() { return getXYZ(matMulpoint(mMatrixInv, [0.0,0.0,0.0])); }
    me.GetDir = function() { return getXYZ(normalize(matMulvec(mMatrixInv, [0.0,0.0,-1.0]))); }

    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piFile
//
//==============================================================================

function piFile( binaryDataArrayBuffer )
{
    // private
    //var mDataView = new DataView( binaryDataArrayBuffer, 0 );
    var mDataView = binaryDataArrayBuffer;
    var mOffset = 0;

    // public members
    var me = {};
    me.mDummy = 0;
/*
    // public functions
    me.Seek = function( off ) { mOffset = off - 3; };
    me.ReadUInt16 = function()  { var res = mDataView.getUint16( mOffset ); mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = mDataView.getUint32( mOffset ); mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = mDataView.getFloat32( mOffset ); mOffset+=4; return res; };
*/

    me.Seek = function( off ) { mOffset = off; };
    me.ReadUInt8  = function()  { var res = (new Uint8Array(mDataView,mOffset))[0]; mOffset+=1; return res; };
    me.ReadUInt16 = function()  { var res = (new Uint16Array(mDataView,mOffset))[0]; mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = (new Uint32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = (new Float32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadFloat32Array = function(n) 
                          { 
                              var src = new Float32Array(mDataView, mOffset);
                              var res = [];  for( var i=0; i<n; i++ ) { res[i] = src[i]; }
                              mOffset += 4*n;
                              return res;
                          };
    me.ReadFloat32ArrayNative = function(n) { var src = new Float32Array(mDataView, mOffset); mOffset += 4*n; return src; };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piMesh
//
//==============================================================================

function piMesh()
{
    this.mChunks = [];
    this.mPrimitiveType = 0;
    this.mVertexFormat = null;
}

/*
piMesh.prototype.normalize = function( ppos, npos )
{
    var numv = this.mVertexData.length;
    var numt = this.mIndices.length;

    for( var i=0; i<numv; i++ )
    {
        //float *v = (float*)piMesh_GetVertexData( me, i, npos );
        //v[0] = 0.0f;
        //v[1] = 0.0f;
        //v[2] = 0.0f;
        this.mVerts[8 * i + 3] = 0.0;
        this.mVerts[8 * i + 4] = 0.0;
        this.mVerts[8 * i + 5] = 0.0;
    }

    for( var i=0; i<numt; i++ )
    {
        piMeshFace *face = me->mFaceData.mIndexArray[0].mBuffer + i;

        const int ft = face->mNum;
        
        vec3 nor = vec3( 0.0f, 0.0f, 0.0f );
        for( int j=0; j<ft; j++ )
        {
            const vec3 va = *((vec3*)piMesh_GetVertexData( me, face->mIndex[ j      ], ppos ));
            const vec3 vb = *((vec3*)piMesh_GetVertexData( me, face->mIndex[(j+1)%ft], ppos ));

            nor += cross( va, vb );
        }

        for( int j=0; j<ft; j++ )
        {
            vec3 *n = (vec3*)piMesh_GetVertexData( me, face->mIndex[j], npos );
            n->x += nor.x;
            n->y += nor.y;
            n->z += nor.z;
        }
    }

    for( var i=0; i<numv; i++ )
    {
        vec3 *v = (vec3*)piMesh_GetVertexData( me, i, npos );
        *v = normalize( *v );
    }
}
*/

piMesh.prototype.createCube = function(renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([ -1.0, -1.0, -1.0,
                                       1.0, -1.0, -1.0,
                                      -1.0,  1.0, -1.0,
                                       1.0,  1.0, -1.0,
                                      -1.0, -1.0,  1.0,
                                       1.0, -1.0,  1.0,
                                      -1.0,  1.0,  1.0,
                                       1.0,  1.0,  1.0 ]),

                        mIndices : new Uint16Array([ 0, 2, 1,   1, 2, 3,   5, 1, 3,   5, 3, 7,   4, 5, 7,   4, 7, 6,   4, 6, 2,   4, 2, 0,   6, 7, 3,   6, 3, 2,   4, 0, 1,   4, 1, 5 ]),
                        mNumVertices : 8,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };

    this.mVertexFormat = { mStride:12, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}

piMesh.prototype.createCubeSharp = function (renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 1.0,
                                    -1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 0.0,

                                     1.0, 1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 0.0,

                                     1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 1.0,
                                    -1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   1.0, 1.0,
                                     1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   1.0, 0.0,

                                    -1.0, 1.0, 1.0,  -1.0, 0.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0,-1.0,  -1.0, 0.0, 0.0,   0.0, 1.0,
                                    -1.0,-1.0,-1.0,  -1.0, 0.0, 0.0,   1.0, 1.0,
                                    -1.0,-1.0, 1.0,  -1.0, 0.0, 0.0,   1.0, 0.0 ]),

                        mIndices : new Uint16Array([0,1,2, 0,2,3,   4,5,6, 4,6,7,    8,9,10,8,10,11,   12,13,14,12,14,15,   16,17,18,16,18,19,   20,21,22,20,22,23]),
                        mNumVertices : 24,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };


    this.mVertexFormat = { mStride:32, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}


piMesh.prototype.createUnitQuad = function (renderer)
{
    this.mPrimitiveType = 0;
    this.mVertexFormat = { mStride:8, mChannels: [ {mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false} ] };

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0,  1.0, 1.0,  1.0]),
                        mIndices : new Uint16Array([0, 2, 1, 1, 2, 3]),
                        mNumVertices : 4,
                        mNumFaces : 2, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };
 
    return true;
}




piMesh.prototype.destroy = function()
{
    //delete this.mVerts;   this.mVerts = null;
    //delete this.mIndices; this.mIndices = null;
}

piMesh.prototype.scale = function (x, y, z)
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] *= x;
            this.mChunks[j].mVerts[stride * i + 1] *= y;
            this.mChunks[j].mVerts[stride * i + 2] *= z;
        }
    }
}

piMesh.prototype.translate = function (x, y, z) 
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] += x;
            this.mChunks[j].mVerts[stride * i + 1] += y;
            this.mChunks[j].mVerts[stride * i + 2] += z;
        }
    }
}

piMesh.prototype.GPULoad = function (renderer)
{
    for( var i=0; i<this.mChunks.length; i++ )
    {
        var vbo = renderer.CreateVertexArray(this.mChunks[i].mVerts, renderer.BUFTYPE.STATIC );
        if (vbo == null)
            return false;

        var ibo = renderer.CreateIndexArray(this.mChunks[i].mIndices, renderer.BUFTYPE.STATIC);
        if (ibo == null)
            return false;

        this.mChunks[i].mVBO = vbo;
        this.mChunks[i].mIBO = ibo;
    }
    return true;
}

piMesh.prototype.GPURender = function (renderer, positions )//, matPrj, matCam )
{
    //renderer.SetShaderConstantMat4F("unMPrj", matPrj, false );

    var num = this.mChunks.length;
    for( var i=0; i<num; i++ )
    {
        //var mat =  matMul( matCam, this.mChunks[i].mTransform );
        //renderer.SetShaderConstantMat4F("unMMod", mat, false);

        renderer.AttachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat, positions );
        renderer.AttachIndexArray(this.mChunks[i].mIBO );
        renderer.DrawPrimitive(renderer.PRIMTYPE.TRIANGLES, this.mChunks[i].mNumFaces * 3, true, 1);
        renderer.DetachIndexArray(this.mChunks[i].mIBO);
        renderer.DetachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat );
    }
}
//==============================================================================
//
// piLibs 2014-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piRenderer
//
//==============================================================================

function piRenderer()
{
    // private members

    var mGL = null;
    var mBindedShader = null;
    var mIs20 = false;
    var mFloat32Textures;
    var mFloat32Filter;
    var mFloat16Textures;
    var mDrawBuffers;
    var mDepthTextures;
    var mDerivatives;
    var mFloat16Filter;
    var mShaderTextureLOD;
    var mAnisotropic;
    var mRenderToFloat32F;
    var mDebugShader;
    var mAsynchCompile;

    var mVBO_Quad = null;
    var mVBO_Tri = null;
    var mVBO_CubePosNor = null;
    var mVBO_CubePos = null;
    var mShaderHeader = ["",""];
    var mShaderHeaderLines = [0,0];

    // public members
    var me = {};

    me.CLEAR      = { Color: 1, Zbuffer : 2, Stencil : 4 };
    me.TEXFMT     = { C4I8 : 0, C1I8 : 1, C1F16 : 2, C4F16 : 3, C1F32 : 4, C4F32 : 5, Z16 : 6, Z24 : 7, Z32 : 8, C3F32:9 };
    me.TEXWRP     = { CLAMP : 0, REPEAT : 1 };
    me.BUFTYPE    = { STATIC : 0, DYNAMIC : 1 };
    me.PRIMTYPE   = { POINTS : 0, LINES : 1, LINE_LOOP : 2, LINE_STRIP : 3, TRIANGLES : 4, TRIANGLE_STRIP : 5 };
    me.RENDSTGATE = { WIREFRAME : 0, FRONT_FACE : 1, CULL_FACE : 2, DEPTH_TEST : 3, ALPHA_TO_COVERAGE : 4 };
    me.TEXTYPE    = { T2D : 0, T3D : 1, CUBEMAP : 2 };
    me.FILTER     = { NONE : 0, LINEAR : 1, MIPMAP : 2, NONE_MIPMAP : 3 };
    me.TYPE       = { UINT8 : 0, UINT16 : 1, UINT32 : 2, FLOAT16: 3, FLOAT32 : 4, FLOAT64: 5 };

    // private functions

    var iFormatPI2GL = function( format )
    {
        if( mIs20 )
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA8,           mGLExternal: mGL.RGBA,             mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.R8,              mGLExternal: mGL.RED,              mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.R16F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA16F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.R32F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA32F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C3F32) return { mGLFormat: mGL.RGB32F,          mGLExternal: mGL.RGB,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT16, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z24)   return { mGLFormat: mGL.DEPTH_COMPONENT24, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z32)   return { mGLFormat: mGL.DEPTH_COMPONENT32F, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        }
        else
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.RED,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT, mGLExternal: mGL.DEPTH_COMPONENT, mGLType: mGL.UNSIGNED_SHORT }
        }

        return null;
     }

    // public functions

    me.Initialize = function( gl )
                    {
                        mGL = gl;

                        mIs20 = !(gl instanceof WebGLRenderingContext);

                        if( mIs20 )
                        {
                            mFloat32Textures  = true;
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = true;
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = true;
                            mDrawBuffers      = true;
                            mDepthTextures    = true;
                            mShaderTextureLOD = true;
                            mAnisotropic = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mGL.getExtension( 'EXT_color_buffer_float');
                            mDebugShader = mGL.getExtension('WEBGL_debug_shaders');
                            mAsynchCompile = mGL.getExtension('KHR_parallel_shader_compile');

							mGL.hint( mGL.FRAGMENT_SHADER_DERIVATIVE_HINT, mGL.NICEST);
                        }
                        else
                        {
                            mFloat32Textures  = mGL.getExtension( 'OES_texture_float' );
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = mGL.getExtension( 'OES_texture_half_float' );
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = mGL.getExtension( 'OES_standard_derivatives' );
                            mDrawBuffers      = mGL.getExtension( 'WEBGL_draw_buffers' );
                            mDepthTextures    = mGL.getExtension( 'WEBGL_depth_texture' );
                            mShaderTextureLOD = mGL.getExtension( 'EXT_shader_texture_lod' );
                            mAnisotropic      = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mFloat32Textures;
                            mDebugShader      = null;
                            mAsynchCompile    = null;
							
							if( mDerivatives !== null) mGL.hint( mDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, mGL.NICEST);
                        }
                        
                        
                        var maxTexSize = mGL.getParameter( mGL.MAX_TEXTURE_SIZE );
                        var maxCubeSize = mGL.getParameter( mGL.MAX_CUBE_MAP_TEXTURE_SIZE );
                        var maxRenderbufferSize = mGL.getParameter( mGL.MAX_RENDERBUFFER_SIZE );
                        var extensions = mGL.getSupportedExtensions();
                        var textureUnits = mGL.getParameter( mGL.MAX_TEXTURE_IMAGE_UNITS );
                        console.log("WebGL (2.0=" + mIs20 + "):" +
                                    " Asynch Compile: "  + ((mAsynchCompile !==null) ? "yes" : "no") +
                                    ", Textures: F32 ["   + ((mFloat32Textures !==null) ? "yes" : "no") +
                                    "], F16 ["   + ((mFloat16Textures !==null) ? "yes" : "no") +
                                    "], Depth [" + ((mDepthTextures   !==null) ? "yes" : "no") +
                                    "], LOD ["    + ((mShaderTextureLOD!==null) ? "yes" : "no") +
                                    "], Aniso ["   + ((mAnisotropic     !==null) ? "yes" : "no") +
                                    "], Units [" + textureUnits +
                                    "], Max Size [" + maxTexSize +
                                    "], Cube Max Size [" + maxCubeSize +
                                    "], Targets: MRT ["            + ((mDrawBuffers     !==null) ? "yes" : "no") +
                                    "], F32 ["     + ((mRenderToFloat32F!==null) ? "yes" : "no") +
                                    "], Max Size [" + maxRenderbufferSize + "]");

                        // create a 2D quad Vertex Buffer
                        var vertices = new Float32Array( [ -1.0, -1.0,   1.0, -1.0,    -1.0,  1.0,     1.0, -1.0,    1.0,  1.0,    -1.0,  1.0] );
                        mVBO_Quad = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                        mGL.bufferData( mGL.ARRAY_BUFFER, vertices, mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 2D triangle Vertex Buffer
                        mVBO_Tri = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0,   3.0, -1.0,    -1.0,  3.0] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePosNor = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0, -1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                               1.0,  1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                               1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                               1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                               1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0,  1.0, -1.0,   0.0,  0.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePos = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0,  1.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        //-------------------------------------------------------------------

                        mShaderHeader[0] = "";
                        mShaderHeaderLines[0] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[0] += "#version 300 es\n" +
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[0] += 6;
                        }
                        else
                        {
                            mShaderHeader[0] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "#endif\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+                                                
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[0] += 26;
                        }

                        //-------------------------------------------------------

                        mShaderHeader[1] = "";
                        mShaderHeaderLines[1] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[1] += "#version 300 es\n"+
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[1] += 6;
                        }
                        else
                        {
                            if( mDerivatives ) { mShaderHeader[1] += "#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n"; mShaderHeaderLines[1]+=3; }
                            if( mShaderTextureLOD  ) { mShaderHeader[1] += "#extension GL_EXT_shader_texture_lod : enable\n"; mShaderHeaderLines[1]++; }
                            mShaderHeader[1] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "#endif\n"+ 
                                                "vec4 texture(     sampler2D   s, vec2 c)                   { return texture2D(s,c); }\n"+
                                                "vec4 texture(     sampler2D   s, vec2 c, float b)          { return texture2D(s,c,b); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c )                  { return textureCube(s,c); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c, float b)          { return textureCube(s,c,b); }\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[1] += 30;
                            if( mShaderTextureLOD )
                            {
                            mShaderHeader[1] += "vec4 textureLod(  sampler2D   s, vec2 c, float b)          { return texture2DLodEXT(s,c,b); }\n";
                            mShaderHeader[1] += "vec4 textureGrad( sampler2D   s, vec2 c, vec2 dx, vec2 dy) { return texture2DGradEXT(s,c,dx,dy); }\n";
                            mShaderHeaderLines[1] += 2;

                            //mShaderHeader[1] += "vec4 texelFetch( sampler2D s, ivec2 c, int l) { return texture2DLodEXT(s,(vec2(c)+0.5)/vec2(800,450),float(l)); }\n";
                            //mShaderHeaderLines[1] += 1;
                            }
                        }

                        return true;
                    };

        me.GetCaps =    function ()
                        {   
                            return { mIsGL20 : mIs20,
                                     mFloat32Textures: mFloat32Textures != null,
                                     mFloat16Textures: mFloat16Textures != null,
                                     mDrawBuffers: mDrawBuffers != null,
                                     mDepthTextures: mDepthTextures != null,
                                     mDerivatives: mDerivatives != null,
                                     mShaderTextureLOD: mShaderTextureLOD != null };
                        };

        me.GetShaderHeaderLines = function (shaderType)
                        {   
                            return mShaderHeaderLines[shaderType];
                        };

        me.CheckErrors = function()
                         {
                                var error = mGL.getError();
                                if( error != mGL.NO_ERROR ) 
                                { 
                                    for( var prop in mGL ) 
                                    {
                                        if( typeof mGL[prop] == 'number' ) 
                                        {
                                            if( mGL[prop] == error )
                                            {
                                                console.log( "GL Error " + error + ": " + prop );
                                                break;
                                            }
                                        }
                                    }
                                }
                         };

        me.Clear =  function( flags, ccolor, cdepth, cstencil )
                    {
                        var mode = 0;
                        if( flags & 1 ) { mode |= mGL.COLOR_BUFFER_BIT;   mGL.clearColor( ccolor[0], ccolor[1], ccolor[2], ccolor[3] ); }
                        if( flags & 2 ) { mode |= mGL.DEPTH_BUFFER_BIT;   mGL.clearDepth( cdepth ); }
                        if( flags & 4 ) { mode |= mGL.STENCIL_BUFFER_BIT; mGL.clearStencil( cstencil ); }
                        mGL.clear( mode );
                    };


        me.CreateTexture = function ( type, xres, yres, format, filter, wrap, buffer)
                           {
                                if( mGL===null ) return null;

                                var id = mGL.createTexture();

                                var glFoTy = iFormatPI2GL( format );
                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                if( type===me.TEXTYPE.T2D )
                                {
                                    mGL.bindTexture( mGL.TEXTURE_2D, id );
//if( buffer==null )
    //mGL.texStorage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres);
//else
                                    mGL.texImage2D( mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap );

                                    if (filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                }
                                else if( type===me.TEXTYPE.T3D )
                                {
                                    if( mIs20 )
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_3D, id );
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_BASE_LEVEL, 0);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAX_LEVEL, Math.log2(xres));
                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_3D);
                                        }
                                        mGL.texImage3D( mGL.TEXTURE_3D, 0, glFoTy.mGLFormat, xres, yres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap );

                                        if (filter === me.FILTER.MIPMAP)
                                            mGL.generateMipmap( mGL.TEXTURE_3D );
                                        mGL.bindTexture( mGL.TEXTURE_3D, null );
                                    }
                                    else 
                                    {
                                        return null;
                                    }
                                }
                                else 
                                {
                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );

                                    // this works great if we know the number of required mipmaps in advance (1, or other)
                                   //mGL.texStorage2D( mGL.TEXTURE_CUBE_MAP, 1, glFoTy.mGLFormat, xres, yres );

                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                    if( filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                    }

                                    if (filter === me.FILTER.MIPMAP)
                                        mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );

                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                }
                        return { mObjectID: id, mXres: xres, mYres: yres, mFormat: format, mType: type, mFilter: filter, mWrap: wrap, mVFlip:false };
                        };

        me.CreateTextureFromImage = function ( type, image, format, filter, wrap, flipY) 
                                {
                                    if( mGL===null ) return null;

                                    var id = mGL.createTexture();

                                    var glFoTy = iFormatPI2GL( format );

                                    var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                    if( type===me.TEXTYPE.T2D )
                                    {
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);

                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.pixelStorei(mGL.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                                        if( mIs20 ) mGL.pixelStorei(mGL.UNPACK_COLORSPACE_CONVERSION_WEBGL, mGL.NONE );

                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);

                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);

                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if( filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                    }
                                    else if( type===me.TEXTYPE.T3D )
                                    {
                                        return null;
                                    }
                                    else 
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );

                                        if( filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                    }
                                    return { mObjectID: id, mXres: image.width, mYres: image.height, mFormat: format, mType: type, mFilter: filter, mWrap:wrap, mVFlip:flipY };
                                };

        me.SetSamplerFilter = function (te, filter, doGenerateMipsIfNeeded) 
                            {
                                if (te.mFilter === filter) return;

                                if (te.mType === me.TEXTYPE.T2D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_3D, null);

                                }
                                else
                                {
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }


                                te.mFilter = filter;
                            };

        me.SetSamplerWrap = function (te, wrap)
                            {
                                if (te.mWrap === wrap) return;

                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, id);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, id);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_3D, null);
                                }

                                te.mWrap = wrap;
                            };

        me.SetSamplerVFlip = function (te, vflip, image)
                            {
                                if (te.mVFlip === vflip) return;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    if( image != null)
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                }
                                else if (te.mType === me.TEXTYPE.CUBEMAP)
                                {
                                    if( image != null)
                                    {
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei( mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
        
                                }

                                te.mVFlip = vflip;
                            };

        me.CreateMipmaps =  function (te)
                            {
                                if( te.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);
                                    mGL.generateMipmap(mGL.TEXTURE_2D);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);
                                }
                                else if( te.mType===me.TEXTYPE.CUBEMAP )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);
                                    mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }
                            };

        me.UpdateTexture =  function( tex, x0, y0, xres, yres, buffer )
                            {
                                var glFoTy = iFormatPI2GL( tex.mFormat );
                                if( tex.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture( mGL.TEXTURE0);
                                    mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                    mGL.texSubImage2D( mGL.TEXTURE_2D, 0, x0, y0, xres, yres, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                }
                            };

        me.UpdateTextureFromImage = function( tex, image )
                                {
                                    var glFoTy = iFormatPI2GL( tex.mFormat );
                                    if( tex.mType===me.TEXTYPE.T2D )
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                        mGL.texImage2D(  mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image );
                                        mGL.bindTexture( mGL.TEXTURE_2D, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                };

        me.DestroyTexture = function( te )
                            {
                                 mGL.deleteTexture( te.mObjectID );
                            };

        me.AttachTextures = function (num, t0, t1, t2, t3) 
                            {
                                if (num > 0 && t0 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                         if (t0.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t0.mObjectID);
                                }

                                if (num > 1 && t1 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE1);
                                         if (t1.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t1.mObjectID);
                                }

                                if (num > 2 && t2 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE2);
                                         if (t2.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t2.mObjectID);
                                }

                                if (num > 3 && t3 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE3);
                                         if (t3.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t3.mObjectID);
                                }
                            };

        me.DettachTextures = function()
                             {
                                mGL.activeTexture(mGL.TEXTURE0);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE1);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE2);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE3);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                             };

        me.CreateRenderTarget = function ( color0, color1, color2, color3, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);

                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_2D, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.DestroyRenderTarget = function ( tex )
                                 {
                                     mGL.deleteFramebuffer(tex.mObjectID);
                                 };

        me.SetRenderTarget = function (tex)
                             {
                                if( tex===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, tex.mObjectID);

                                //mGL.drawBuffers([mGL.COLOR_ATTACHMENT0, mGL.COLOR_ATTACHMENT1]);
                             };

        me.CreateRenderTargetNew = function ( wantColor0, wantZbuffer, xres, yres, samples )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if( wantZbuffer===true )
                                    {
                                        var zb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);

                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.DEPTH_COMPONENT16, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                    }

                                    if( wantColor0 )
                                    {
                                        var cb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, cb);
                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.RGBA8, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.RGBA8, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.RENDERBUFFER, cb);
                                    }

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                    {
                                        return null;
                                    }
                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mXres: xres, mYres:yres, mTex0: color0 };
                                };

        me.CreateRenderTargetCubeMap = function ( color0, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);
                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.SetRenderTargetCubeMap = function (fbo, face)
                             {
                                if( fbo===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                {
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, fbo.mObjectID);
                                    mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X+face, fbo.mTex0.mObjectID, 0);
                                }
                             };


        me.BlitRenderTarget = function( dst, src )
                                {
                                    mGL.bindFramebuffer(mGL.READ_FRAMEBUFFER, src.mObjectID);
                                    mGL.bindFramebuffer(mGL.DRAW_FRAMEBUFFER, dst.mObjectID);
                                    mGL.clearBufferfv(mGL.COLOR, 0, [0.0, 0.0, 0.0, 1.0]);
                                    mGL.blitFramebuffer( 0, 0, src.mXres, src.mYres,
                                                         0, 0, src.mXres, src.mYres,
                                                         mGL.COLOR_BUFFER_BIT, mGL.LINEAR
                                    );
                                };

        me.SetViewport = function( vp )
                         {
                              mGL.viewport( vp[0], vp[1], vp[2], vp[3] );
                         };

        me.SetWriteMask = function( c0, c1, c2, c3, z )
                          {
                              mGL.depthMask(z);
                              mGL.colorMask(c0,c0,c0,c0);
                          };

        me.SetState = function( stateName, stateValue )
                      {
                            if (stateName === me.RENDSTGATE.WIREFRAME)
                            {
                                if( stateValue ) mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.LINE );
                                else             mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.FILL );
                            }
                            else if (stateName === me.RENDSTGATE.FRONT_FACE)
                            {
                                if( stateValue ) mGL.cullFace( mGL.BACK );
                                else             mGL.cullFace( mGL.FRONT );
                            }
                            else if (stateName === me.RENDSTGATE.CULL_FACE)
                            {
                                if( stateValue ) mGL.enable( mGL.CULL_FACE );
                                else             mGL.disable( mGL.CULL_FACE );
                            }
                            else if (stateName === me.RENDSTGATE.DEPTH_TEST)
                            {
                                if( stateValue ) mGL.enable( mGL.DEPTH_TEST );
                                else             mGL.disable( mGL.DEPTH_TEST );
                            }
                            else if (stateName === me.RENDSTGATE.ALPHA_TO_COVERAGE)
                            {
                                if( stateValue ) { mGL.enable(  mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                                else             { mGL.disable( mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                            }
                      };

        me.SetMultisample = function( v)
                    {
                        if( v===true )
                        {
                            mGL.enable(mGL.SAMPLE_COVERAGE);
                            mGL.sampleCoverage(1.0, false);
                        }
                        else
                        {
                            mGL.disable(mGL.SAMPLE_COVERAGE);
                        }
                    };

        me.GetTranslatedShaderSource = function (shader) 
                          {
                            if( mGL===null ) return null;
                            if( mDebugShader===null ) return null;
                            let vfs = mGL.getAttachedShaders(shader.mProgram);
                            let str = mDebugShader.getTranslatedShaderSource(vfs[1]);
                            let parts = str.split("GLSL END"); str = (parts.length<2) ? str : parts[1];
                            return str;
                          };

        me.CreateShader = function (vsSource, fsSource, preventCache, forceSynch, onResolve) 
                          {
                            if( mGL===null ) return;

                            var vs = mGL.createShader( mGL.VERTEX_SHADER   );
                            var fs = mGL.createShader( mGL.FRAGMENT_SHADER );

                            vsSource = mShaderHeader[0] + vsSource;
                            fsSource = mShaderHeader[1] + fsSource;

                            if( preventCache )
                            {
                                let vran = Math.random().toString(36).substring(7);
                                let fran = Math.random().toString(36).substring(7);
                                vsSource += "\n#define K" + vran + "\n";
                                fsSource += "\n#define K" + fran + "\n";
                            }

                            var timeStart = getRealTime();

                            mGL.shaderSource(vs, vsSource);
                            mGL.shaderSource(fs, fsSource);
                            mGL.compileShader(vs);
                            mGL.compileShader(fs);

                            var pr = mGL.createProgram();
                            mGL.attachShader(pr, vs);
                            mGL.attachShader(pr, fs);
                            mGL.linkProgram(pr);

                            //-------------
                            let checkErrors = function()
                            {
                                if (!mGL.getProgramParameter(pr, mGL.LINK_STATUS))
                                {
                                    // vs error
                                    if (!mGL.getShaderParameter(vs, mGL.COMPILE_STATUS))
                                    {
                                        let vsLog = mGL.getShaderInfoLog(vs);
                                        onResolve(false, { mErrorType: 0, mErrorStr: vsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // fs error
                                    else if (!mGL.getShaderParameter(fs, mGL.COMPILE_STATUS))
                                    {
                                        let fsLog = mGL.getShaderInfoLog(fs);
                                        onResolve(false, { mErrorType: 1, mErrorStr: fsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // link error
                                    else
                                    {
                                        let infoLog = mGL.getProgramInfoLog(pr);
                                        onResolve(false, { mErrorType: 2, mErrorStr: infoLog });
                                        mGL.deleteProgram(pr);
                                    }
                                }
                                // no errors
                                else
                                {
                                    let compilationTime = getRealTime() - timeStart;
                                    onResolve(true, { mProgram: pr, mTime: compilationTime });
                                }
                            };

                            // check compilation
                            if (mAsynchCompile === null || forceSynch===true )
                            {
                                checkErrors();
                            }
                            else
                            {
                                let loopCheckCompletion = function ()
                                {
                                    if( mGL.getProgramParameter(pr, mAsynchCompile.COMPLETION_STATUS_KHR) === true )
                                        checkErrors();
                                    else
                                        setTimeout(loopCheckCompletion, 10);
                                };
                                setTimeout(loopCheckCompletion, 10);
                            }
                        };

        me.AttachShader = function( shader )
                          {
                                if( shader===null )
                                {
                                    mBindedShader = null;
                                    mGL.useProgram( null );
                                }
                                else
                                {
                                    mBindedShader = shader;
                                    mGL.useProgram(shader.mProgram);
                                }
                          };

        me.DetachShader = function ()
                        {
                            mGL.useProgram(null);
                        };

        me.DestroyShader = function( tex )
                        {
                            mGL.deleteProgram(tex.mProgram);
                        };

        me.GetAttribLocation = function (shader, name)
                        {
                            return mGL.getAttribLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantLocation = function (shader, name)
                        {
                            return mGL.getUniformLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantMat4F = function( uname, params, istranspose )
                        {
                            var program = mBindedShader;

                            let pos = mGL.getUniformLocation( program.mProgram, uname );
                            if( pos===null )
                                return false;

                            if( istranspose===false )
                            {
                                var tmp = new Float32Array( [ params[0], params[4], params[ 8], params[12],
                                                              params[1], params[5], params[ 9], params[13],
                                                              params[2], params[6], params[10], params[14],
                                                              params[3], params[7], params[11], params[15] ] );
	                            mGL.uniformMatrix4fv(pos,false,tmp);
                            }
                            else
                                mGL.uniformMatrix4fv(pos,false,new Float32Array(params) );
                            return true;
                        };

        me.SetShaderConstant1F_Pos = function(pos, x)
                        {
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1FV_Pos = function(pos, x)
                        {
                            mGL.uniform1fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant1F = function( uname, x )
                        {
                            var pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1I = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1i(pos, x);
                            return true;
                        };
        me.SetShaderConstant1I_Pos = function(pos, x)
                        {
                            mGL.uniform1i(pos, x);
                            return true;
                        };


        me.SetShaderConstant2F = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform2fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant3F = function(uname, x, y, z)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform3f(pos, x, y, z);
                            return true;
                        };

        me.SetShaderConstant1FV = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1fv(pos, new Float32Array(x));
                            return true;
                        };

        me.SetShaderConstant3FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform3fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderConstant4FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform4fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderTextureUnit = function( uname, unit )
                        {
                            var program = mBindedShader;
                            let pos = mGL.getUniformLocation(program.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform1i(pos, unit);
                            return true;
                        };

        me.CreateVertexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, id);
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.CreateIndexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, id );
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.DestroyArray = function( tex )
                        {
                            mGL.destroyBuffer(tex.mObject);
                        };

        me.AttachVertexArray = function( tex, attribs, pos )
                        {
                            let shader = mBindedShader;

                            mGL.bindBuffer( mGL.ARRAY_BUFFER, tex.mObject);

                            var num = attribs.mChannels.length;
                            var stride = attribs.mStride;

                            var offset = 0;
                            for (var i = 0; i < num; i++)
                            {
                                var id = pos[i];
                                mGL.enableVertexAttribArray(id);
                                var dtype = mGL.FLOAT;
                                var dsize = 4;
                                     if( attribs.mChannels[i].mType === me.TYPE.UINT8   ) { dtype = mGL.UNSIGNED_BYTE;  dsize = 1; }
                                else if( attribs.mChannels[i].mType === me.TYPE.UINT16  ) { dtype = mGL.UNSIGNED_SHORT; dsize = 2; }
                                else if( attribs.mChannels[i].mType === me.TYPE.FLOAT32 ) { dtype = mGL.FLOAT;          dsize = 4; }
                                mGL.vertexAttribPointer(id, attribs.mChannels[i].mNumComponents, dtype, attribs.mChannels[i].mNormalize, stride, offset);
                                offset += attribs.mChannels[i].mNumComponents * dsize;
                            }
                        };

        me.AttachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, tex.mObject);
                        };

        me.DetachVertexArray = function (tex, attribs)
                        {
                            let num = attribs.mChannels.length;
                            for (let i = 0; i < num; i++)
                                mGL.disableVertexAttribArray(i);
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, null);
                        };

        me.DetachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, null);
                        };

        me.DrawPrimitive = function( typeOfPrimitive, num, useIndexArray, numInstances )
                        {
                            let glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.POINTS ) glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.LINES ) glType = mGL.LINES;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_LOOP ) glType = mGL.LINE_LOOP;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_STRIP ) glType = mGL.LINE_STRIP;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLES ) glType = mGL.TRIANGLES;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLE_STRIP ) glType = mGL.TRIANGLE_STRIP;

                            if( numInstances<=1 )
                            {
  	                            if( useIndexArray ) mGL.drawElements( glType, num, mGL.UNSIGNED_SHORT, 0 );
	                            else                mGL.drawArrays( glType, 0, num );
                            }
                            else
                            {
                                mGL.drawArraysInstanced(glType, 0, num, numInstances);
                                mGL.drawElementsInstanced( glType, num, mGL.UNSIGNED_SHORT, 0, numInstances);
                            }
                        };


        me.DrawFullScreenTriangle_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 3 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };


        me.DrawUnitQuad_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 6 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };

        me.DrawUnitCube_XYZ_NOR = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                            mGL.vertexAttribPointer( vpos[0], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.vertexAttribPointer( vpos[1], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos[0] );
                            mGL.enableVertexAttribArray( vpos[1] );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos[0] );
                            mGL.disableVertexAttribArray( vpos[1] );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.DrawUnitCube_XYZ = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                            mGL.vertexAttribPointer( vpos, 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.SetBlend = function( enabled )
                    {
                        if( enabled )
                        {
                            mGL.enable( mGL.BLEND );
                            mGL.blendEquationSeparate( mGL.FUNC_ADD, mGL.FUNC_ADD );
                            mGL.blendFuncSeparate( mGL.SRC_ALPHA, mGL.ONE_MINUS_SRC_ALPHA, mGL.ONE, mGL.ONE_MINUS_SRC_ALPHA );
                        }
                        else
                        {
                            mGL.disable( mGL.BLEND );
                        }
                    };

        me.GetPixelData = function( data, offset, xres, yres )
                        {
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.UNSIGNED_BYTE, data, offset);
                        };

        me.GetPixelDataRenderTarget = function( obj, data, xres, yres )
                        {
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, obj.mObjectID);
                            mGL.readBuffer(mGL.COLOR_ATTACHMENT0);
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.FLOAT, data, 0);
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                        };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piShading
//
//==============================================================================

function smoothstep(a, b, x)
{
    x = (x - a) / (b - a);
    if (x < 0) x = 0; else if (x > 1) x = 1;
    return x * x * (3.0 - 2.0 * x);
}

function clamp01(x)
{
    if( x < 0.0 ) x = 0.0;
    if( x > 1.0 ) x = 1.0;
    return x;
}

function clamp(x, a, b)
{
    if( x < a ) x = a;
    if( x > b ) x = b;
    return x;
}

function screen(a, b)
{
    return 1.0 - (1.0 - a) * (1.0 - b);
}

function parabola(x)
{
    return 4.0 * x * (1.0 - x);
}

function min(a, b)
{
    return (a < b) ? a : b;
}

function max(a, b)
{
    return (a > b) ? a : b;
}

function noise( x )
{
    function grad(i, j, x, y)
    {
        var h = 7 * i + 131 * j;
        h = (h << 13) ^ h;
        h = (h * (h * h * 15731 + 789221) + 1376312589);

        var rx = (h & 0x20000000) ? x : -x;
        var ry = (h & 0x10000000) ? y : -y;

        return rx + ry;
    }

    var i = [ Math.floor(x[0]), Math.floor(x[1]) ];
    var f = [ x[0] - i[0], x[1] - i[1] ];
    var w = [ f[0]*f[0]*(3.0-2.0*f[0]), f[1]*f[1]*(3.0-2.0*f[1]) ];

    var a = grad( i[0]+0, i[1]+0, f[0]+0.0, f[1]+0.0 );
    var b = grad( i[0]+1, i[1]+0, f[0]-1.0, f[1]+0.0 );
    var c = grad( i[0]+0, i[1]+1, f[0]+0.0, f[1]-1.0 );
    var d = grad( i[0]+1, i[1]+1, f[0]-1.0, f[1]-1.0 );

    return a + (b-a)*w[0] + (c-a)*w[1] + (a-b-c+d)*w[0]*w[1];
}//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piVecTypes
//
//==============================================================================


function vec3( a, b, c )
{
    return [ a, b, c ];
}

function add( a, b )
{
    return [ a[0]+b[0], a[1]+b[1], a[2]+b[2] ];
}

function sub( a, b )
{
    return [ a[0]-b[0], a[1]-b[1], a[2]-b[2] ];
}

function mul( a, s ) 
{
    return [ a[0]*s, a[1]*s, a[2]*s ];
}

function cross( a, b )
{
    return [ a[1]*b[2] - a[2]*b[1],
             a[2]*b[0] - a[0]*b[2],
             a[0]*b[1] - a[1]*b[0] ];
}

function dot( a, b ) 
{
    return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
}

function normalize( v ) 
{
    var is = 1.0 / Math.sqrt( v[0]*v[0] + v[1]*v[1] + v[2]*v[2] );
    return [ v[0]*is, v[1]*is, v[2]*is ];
}

function createCirclePoint( cen, uuu, vvv, rad, s, t )
{
    return [ cen[0] + rad*(uuu[0]*s + vvv[0]*t),
             cen[1] + rad*(uuu[1]*s + vvv[1]*t),
             cen[2] + rad*(uuu[2]*s + vvv[2]*t) ];
}

function createTangent( a, b, c )
{
    var cb = normalize( [ c[0]-b[0], c[1]-b[1], c[2]-b[2] ] );
    var ba = normalize( [ b[0]-a[0], b[1]-a[1], b[2]-a[2] ] );
    return normalize( [ ba[0]+cb[0], ba[1]+cb[1], ba[2]+cb[2] ] );

}

//===================================

function vec4( a, b, c, d )
{
    return [ a, b, c, d ];
}

function getXYZ( v )
{
    return [ v[0], v[1], v[2] ];
}

//===================================

function setIdentity()
{
    return [ 1.0, 0.0, 0.0, 0.0,
             0.0, 1.0, 0.0, 0.0,
             0.0, 0.0, 1.0, 0.0,
             0.0, 0.0, 0.0, 1.0 ];
}

function setRotationX( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ 1.0,   0.0,   0.0, 0.0,
             0.0,  cost, -sint, 0.0, 
             0.0,  sint,  cost, 0.0,
             0.0,   0.0,   0.0, 1.0 ];
}

function setRotationY( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ cost, 0.0, -sint, 0.0,
              0.0, 1.0,   0.0, 0.0, 
             sint, 0.0,  cost, 0.0,
              0.0, 0.0,   0.0, 1.0 ];
}

function extractRotationEuler( m)
{
    var res = [];
    if (m[0] == 1.0)
    {
        res[0] = Math.atan2(m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;

    }
    else if (m[0] == -1.0)
    {
        res[0] = Math.atan2( m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;
    }
    else
    {
        res[0] = Math.atan2( -m[9], m[10]);
        res[1] = Math.atan2( m[8], Math.sqrt(m[9]*m[9] + m[10]*m[10]));
        res[2] = Math.atan2( m[4], m[0]);
    }
    return res;
}

function setFromQuaternion( q )
{
    var ww = q[3]*q[3];
    var xx = q[0]*q[0];
    var yy = q[1]*q[1];
    var zz = q[2]*q[2];

    return [ ww+xx-yy-zz,                   2.0*(q[0]*q[1] - q[3]*q[2]), 2.0*(q[0]*q[2] + q[3]*q[1]), 0.0,
               2.0*(q[0]*q[1] + q[3]*q[2]),   ww-xx+yy-zz,                 2.0*(q[1]*q[2] - q[3]*q[0]), 0.0,
               2.0*(q[0]*q[2] - q[3]*q[1]),   2.0*(q[1]*q[2] + q[3]*q[0]), ww-xx-yy+zz,                 0.0,
               0.0,                           0.0,                         0.0,                         1.0 ];
}

function setPerspective( fovy, aspect, znear, zfar )
{
    var tan = Math.tan(fovy * Math.PI/180.0);
    var x = 1.0 / (tan*aspect);
    var y = 1.0 / (tan);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0 * zfar * znear) / (zfar - znear);

    return [ x,    0.0,  0.0,  0.0,
             0.0,  y,    0.0,  0.0,
             0.0,  0.0,  c,     d,
             0.0,  0.0, -1.0,  0.0 ];
}

function setLookAt( eye, tar, up )
{
    var dir = [ -tar[0]+eye[0], -tar[1]+eye[1], -tar[2]+eye[2] ];

	var m00 = dir[2]*up[1] - dir[1]*up[2]; 
    var m01 = dir[0]*up[2] - dir[2]*up[0];
    var m02 = dir[1]*up[0] - dir[0]*up[1];
    var im = 1.0/Math.sqrt( m00*m00 + m01*m01 + m02*m02 );
    m00 *= im;
    m01 *= im;
    m02 *= im;

	var m04 = m02*dir[1] - m01*dir[2]; 
    var m05 = m00*dir[2] - m02*dir[0];
    var m06 = m01*dir[0] - m00*dir[1];
    im = 1.0/Math.sqrt( m04*m04 + m05*m05 + m06*m06 );
    m04 *= im;
    m05 *= im;
    m06 *= im;

	var m08 = dir[0];
	var m09 = dir[1];
	var m10 = dir[2];
    im = 1.0/Math.sqrt( m08*m08 + m09*m09 + m10*m10 );
    m08 *= im;
    m09 *= im;
    m10 *= im;

	var m03 = -(m00*eye[0] + m01*eye[1] + m02*eye[2] );
	var m07 = -(m04*eye[0] + m05*eye[1] + m06*eye[2] );
	var m11 = -(m08*eye[0] + m09*eye[1] + m10*eye[2] );

    return [ m00, m01, m02, m03,
             m04, m05, m06, m07,
             m08, m09, m10, m11,
             0.0, 0.0, 0.0, 1.0 ];
}


function setOrtho( left, right, bottom, top, znear, zfar )
{
   var x = 2.0 / (right - left);
   var y = 2.0 / (top - bottom);
   var a = (right + left) / (right - left);
   var b = (top + bottom) / (top - bottom);
   var c = -2.0 / (zfar - znear);
   var d = -(zfar + znear) / ( zfar - znear);

   return [  x, 0.0, 0.0,   a,
           0.0,   y, 0.0,   b,
           0.0, 0.0,   c,   d,
           0.0, 0.0, 0.0, 1.0 ];
}

function setTranslation( p )
{
    return [ 1.0, 0.0, 0.0, p[0],
             0.0, 1.0, 0.0, p[1],
             0.0, 0.0, 1.0, p[2],
             0.0, 0.0, 0.0, 1.0 ];
}

function setScale( s )
{
    return [ s[0], 0.0,  0.0,  0.0,
             0.0,  s[1], 0.0,  0.0,
             0.0,  0.0,  s[2], 0.0,
             0.0,  0.0,  0.0,  1.0];
}

function setProjection( fov, znear, zfar )
{
    var x = 2.0 / (fov[3]+fov[2]);
    var y = 2.0 / (fov[0]+fov[1]);
    var a = (fov[3]-fov[2]) / (fov[3]+fov[2]);
    var b = (fov[0]-fov[1]) / (fov[0]+fov[1]);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0*zfar*znear) / (zfar - znear);
    return [   x, 0.0,    a, 0.0,
             0.0,   y,    b, 0.0,
             0.0, 0.0,    c,   d,
             0.0, 0.0, -1.0, 0.0 ];
   // inverse is:
   //return mat4x4( 1.0/x, 0.0f,  0.0f,   a/x,
   //               0.0f,  1.0/y, 0.0f,   b/x,
   //               0.0f,  0.0f,  0.0f,   -1.0,
   //               0.0f,  0.0f,  1.0f/d, c/d );
}


function invertFast( m )
{
    var inv = [
   
             m[5]  * m[10] * m[15] - 
             m[5]  * m[11] * m[14] - 
             m[9]  * m[6]  * m[15] + 
             m[9]  * m[7]  * m[14] +
             m[13] * m[6]  * m[11] - 
             m[13] * m[7]  * m[10],

             -m[1]  * m[10] * m[15] + 
              m[1]  * m[11] * m[14] + 
              m[9]  * m[2] * m[15] - 
              m[9]  * m[3] * m[14] - 
              m[13] * m[2] * m[11] + 
              m[13] * m[3] * m[10],

             m[1]  * m[6] * m[15] - 
             m[1]  * m[7] * m[14] - 
             m[5]  * m[2] * m[15] + 
             m[5]  * m[3] * m[14] + 
             m[13] * m[2] * m[7] - 
             m[13] * m[3] * m[6],

             -m[1] * m[6] * m[11] + 
              m[1] * m[7] * m[10] + 
              m[5] * m[2] * m[11] - 
              m[5] * m[3] * m[10] - 
              m[9] * m[2] * m[7] + 
              m[9] * m[3] * m[6],

             -m[4]  * m[10] * m[15] + 
              m[4]  * m[11] * m[14] + 
              m[8]  * m[6]  * m[15] - 
              m[8]  * m[7]  * m[14] - 
              m[12] * m[6]  * m[11] + 
              m[12] * m[7]  * m[10],

             m[0]  * m[10] * m[15] - 
             m[0]  * m[11] * m[14] - 
             m[8]  * m[2] * m[15] + 
             m[8]  * m[3] * m[14] + 
             m[12] * m[2] * m[11] - 
             m[12] * m[3] * m[10],

             -m[0]  * m[6] * m[15] + 
              m[0]  * m[7] * m[14] + 
              m[4]  * m[2] * m[15] - 
              m[4]  * m[3] * m[14] - 
              m[12] * m[2] * m[7] + 
              m[12] * m[3] * m[6],


             m[0] * m[6] * m[11] - 
             m[0] * m[7] * m[10] - 
             m[4] * m[2] * m[11] + 
             m[4] * m[3] * m[10] + 
             m[8] * m[2] * m[7] - 
             m[8] * m[3] * m[6],


             m[4]  * m[9] * m[15] - 
             m[4]  * m[11] * m[13] - 
             m[8]  * m[5] * m[15] + 
             m[8]  * m[7] * m[13] + 
             m[12] * m[5] * m[11] - 
             m[12] * m[7] * m[9],



             -m[0]  * m[9] * m[15] + 
              m[0]  * m[11] * m[13] + 
              m[8]  * m[1] * m[15] - 
              m[8]  * m[3] * m[13] - 
              m[12] * m[1] * m[11] + 
              m[12] * m[3] * m[9],

              m[0]  * m[5] * m[15] - 
              m[0]  * m[7] * m[13] - 
              m[4]  * m[1] * m[15] + 
              m[4]  * m[3] * m[13] + 
              m[12] * m[1] * m[7] - 
              m[12] * m[3] * m[5],

              -m[0] * m[5] * m[11] + 
               m[0] * m[7] * m[9] + 
               m[4] * m[1] * m[11] - 
               m[4] * m[3] * m[9] - 
               m[8] * m[1] * m[7] + 
               m[8] * m[3] * m[5],

              -m[4]  * m[9] * m[14] + 
               m[4]  * m[10] * m[13] +
               m[8]  * m[5] * m[14] - 
               m[8]  * m[6] * m[13] - 
               m[12] * m[5] * m[10] + 
               m[12] * m[6] * m[9],

              m[0]  * m[9] * m[14] - 
              m[0]  * m[10] * m[13] - 
              m[8]  * m[1] * m[14] + 
              m[8]  * m[2] * m[13] + 
              m[12] * m[1] * m[10] - 
              m[12] * m[2] * m[9],

              -m[0]  * m[5] * m[14] + 
               m[0]  * m[6] * m[13] + 
               m[4]  * m[1] * m[14] - 
               m[4]  * m[2] * m[13] - 
               m[12] * m[1] * m[6] + 
               m[12] * m[2] * m[5],

              m[0] * m[5] * m[10] - 
              m[0] * m[6] * m[9] - 
              m[4] * m[1] * m[10] + 
              m[4] * m[2] * m[9] + 
              m[8] * m[1] * m[6] - 
              m[8] * m[2] * m[5] ];

    var det = m[0] * inv[0] + m[1] * inv[4] + m[2] * inv[8] + m[3] * inv[12];

    det = 1.0/det;

    for( var i = 0; i<16; i++ ) inv[i] = inv[i] * det;

    return inv;
}

function matMul( a, b )
{
    var res = [];
    for( var i=0; i<4; i++ )
    {
        var x = a[4*i+0];
        var y = a[4*i+1];
        var z = a[4*i+2];
        var w = a[4*i+3];

        res[4*i+0] = x * b[ 0] + y * b[ 4] + z * b[ 8] + w * b[12];
        res[4*i+1] = x * b[ 1] + y * b[ 5] + z * b[ 9] + w * b[13];
        res[4*i+2] = x * b[ 2] + y * b[ 6] + z * b[10] + w * b[14];
        res[4*i+3] = x * b[ 3] + y * b[ 7] + z * b[11] + w * b[15];
    }

    return res;
}

function matMulpoint( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2] + m[ 3],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2] + m[ 7],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] + m[11] ];
}

function matMulvec( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] ];
}


function bound3( infi )
{
    return [ infi, -infi, infi, -infi, infi, -infi ];
}

function bound3_include( a, p )
{
    return [
        (p[0]<a[0]) ? p[0] : a[0],
        (p[0]>a[1]) ? p[0] : a[1],
        (p[1]<a[2]) ? p[1] : a[2],
        (p[1]>a[3]) ? p[1] : a[3],
        (p[2]<a[4]) ? p[2] : a[4],
        (p[2]>a[5]) ? p[2] : a[5] ];
}

function bound3_center( b )
{
    return [ 0.5*(b[0]+b[1]),
             0.5*(b[2]+b[3]),
             0.5*(b[4]+b[5]) ];
}

function bound3_radius( b )
{
    return [ 0.5*(b[1]-b[0]),
             0.5*(b[3]-b[2]),
             0.5*(b[5]-b[4]) ];
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebVR
//
//==============================================================================

function WebVR( isVREnabledCallback, canvasElement )
{
    isVREnabledCallback(false);
    /*


    this.mSupportVR = false;
    this.mHMD = null;

    var me = this;
    var listVRDisplays = function (vrdevs) {
        for (var i = 0; i < vrdevs.length; i++)
        {
            if (vrdevs[i] instanceof VRDisplay)
            {
                me.mHMD = vrdevs[i];
                console.log("WebVR is available.");
                console.log(me.mHMD);
                break;
            }
        }

        isVREnabledCallback(true);
        me.mSupportVR = true;
    }

    if (navigator.getVRDisplays)
    {
        navigator.getVRDisplays().then(listVRDisplays);
    }

    isVREnabledCallback(false);
    this.mCanvas = canvasElement;
    */
}

WebVR.prototype.IsSupported = function()
{
    return false;
    //return this.mSupportVR;
}

WebVR.prototype.GetData = function( id )
{
    return {};
    /*
    var frameData = new VRFrameData();
    var s = this.mHMD.getFrameData(frameData);
    var ss = frameData.pose;
    
    var fovL = this.mHMD.getEyeParameters("left");
    var fovR = this.mHMD.getEyeParameters( "right" );

    // camera info
    var cPos = vec3(0.0, 0.0, 0.0);
    if (ss.position)
        cPos = vec3(-ss.position[0], -ss.position[1], -ss.position[2]);
    var rot = vec4(0.0, 0.0, 0.0, 0.0);
    if (ss.orientation)
        rot = vec4(ss.orientation[0], ss.orientation[1], ss.orientation[2], ss.orientation[3]);
    var cRot = setFromQuaternion(rot);
    var cTra = setTranslation(cPos);
    var cMat = matMul(invertFast(cRot), cTra);
    
    // per eye info
    var lTra = setTranslation( vec3(-fovL.offset[0], -fovL.offset[1], -fovL.offset[2]) );
    var lMat = matMul(lTra, cMat);
    var lPrj = [ Math.tan( fovL.fieldOfView.upDegrees * Math.PI/180.0),
                 Math.tan(fovL.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.rightDegrees * Math.PI / 180.0)];

    var rTra = setTranslation(vec3(-fovR.offset[0], -fovR.offset[1], -fovR.offset[2]));
    var rMat = matMul(rTra, cMat);
    var rPrj = [Math.tan(fovR.fieldOfView.upDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.rightDegrees * Math.PI / 180.0)];

    return {
        mCamera   : { mCamera: cMat },
        mLeftEye  : { mVP:[0,0,fovL.renderWidth,fovL.renderHeight], mProjection:lPrj, mCamera:lMat },
        mRightEye : { mVP:[fovR.renderWidth/2,0,fovR.renderWidth,fovR.renderHeight], mProjection:rPrj, mCamera:rMat }
           };
    */
}

WebVR.prototype.Enable = function( id )
{
    /*
    this.mHMD.requestPresent([{ source: this.mCanvas }]).then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : requestPresent failed.");
        }
    );
    */
}

WebVR.prototype.Disable = function( id )
{
    /*
    if (!this.mHMD.isPresenting)
    {
        return;
    }

    this.mHMD.exitPresent().then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : exitPresent failed.");
        }
    );
    */
}

WebVR.prototype.RequestAnimationFrame = function (id)
{
    //this.mHMD.requestAnimationFrame(id);
}

WebVR.prototype.IsPresenting = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        return true;
    }
    */
    return false;
}

WebVR.prototype.Finish = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        this.mHMD.submitFrame();
    }
    */
}

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebUtils
//
//==============================================================================


// RequestAnimationFrame
window.requestAnimFrame = ( function () { return window.requestAnimationFrame    || window.webkitRequestAnimationFrame ||
                                                 window.mozRequestAnimationFrame || window.oRequestAnimationFrame ||
                                                 window.msRequestAnimationFrame  || function( cb ) { window.setTimeout(cb,1000/60); };
                                        } )();

// performance.now
window.getRealTime = ( function() { if ("performance" in window ) return function() { return window.performance.now(); }
                                                                  return function() { return (new Date()).getTime(); }
                                  } )();

window.URL = window.URL || window.webkitURL;

navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;

function htmlEntities(str) 
{
    return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g,'&apos;');
}

function piDisableTouch()
{
    document.body.addEventListener('touchstart', function(e){ e.preventDefault(); });
}

var piGetTime = function ( timestamp )
{
    if (timestamp == 0)
        return "";
    return new Date(timestamp * 1000).toISOString().substr(0, 10);
}

function piGetCoords( obj )
{
    var x = 0;
    var y = 0; 
    do
    {
         x += obj.offsetLeft;
         y += obj.offsetTop;
    }while( obj = obj.offsetParent );

    return { mX:x, mY:y };
}

function piGetMouseCoords( ev, canvasElement )
{
    var pos = piGetCoords(canvasElement );
    var mcx =                        (ev.pageX - pos.mX) * canvasElement.width / canvasElement.offsetWidth;
    var mcy = canvasElement.height - (ev.pageY - pos.mY) * canvasElement.height / canvasElement.offsetHeight;

    return { mX: mcx, mY: mcy };

}

function piGetSourceElement( e )
{
    var ele = null;
    if( e.target )     ele = e.target;
    if( e.srcElement ) ele = e.srcElement;
    return ele;
}

function piRequestFullScreen( ele )
{
    if( ele==null ) ele =   document.documentElement;
         if( ele.requestFullscreen       ) ele.requestFullscreen();
    else if( ele.msRequestFullscreen     ) ele.msRequestFullscreen();
    else if( ele.mozRequestFullScreen    ) ele.mozRequestFullScreen();
    else if( ele.webkitRequestFullscreen ) ele.webkitRequestFullscreen( Element.ALLOW_KEYBOARD_INPUT );
}

function piIsFullScreen()
{
    return document.fullscreen || document.mozFullScreen || document.webkitIsFullScreen || document.msFullscreenElement || false;
}

function piExitFullScreen()
{
       if( document.exitFullscreen       ) document.exitFullscreen();
  else if( document.msExitFullscreen     ) document.msExitFullscreen();
  else if( document.mozCancelFullScreen  ) document.mozCancelFullScreen();
  else if( document.webkitExitFullscreen ) document.webkitExitFullscreen();
}

function piIsMobile()
{
    return (navigator.userAgent.match(/Android/i) ||
            navigator.userAgent.match(/webOS/i) ||
            navigator.userAgent.match(/iPhone/i) ||
            navigator.userAgent.match(/iPad/i) ||
            navigator.userAgent.match(/iPod/i) ||
            navigator.userAgent.match(/BlackBerry/i) ||
            navigator.userAgent.match(/Windows Phone/i)) ? true : false;
}

function piCreateGlContext( cv, useAlpha, useDepth, usePreserveBuffer, useSupersampling )
{
    var opts = { alpha: useAlpha, 
                 depth: useDepth, 
                 stencil: false, 
                 premultipliedAlpha: false, 
                 antialias: useSupersampling, 
                 preserveDrawingBuffer: usePreserveBuffer, 
                 powerPreference: "high-performance" }; // "low_power", "high_performance", "default"

    var gl = null;
    if( gl === null) gl = cv.getContext( "webgl2", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl2", opts );
    if( gl === null) gl = cv.getContext( "webgl", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl", opts );

    return gl;
}

function piCreateAudioContext()
{
    var res = null;
    try
    {
        if( window.AudioContext ) res = new AudioContext();
        if( res==null && window.webkitAudioContext ) res = new webkitAudioContext();
    }
    catch( e )
    {
        res = null;
    }
    return res;
}

function piHexColorToRGB(str) // "#ff3041"
{
    var rgb = parseInt(str.slice(1), 16);
    var r = (rgb >> 16) & 255;
    var g = (rgb >> 8) & 255;
    var b = (rgb >> 0) & 255;
    return [r, g, b];
}

function piCreateFPSCounter()
{
    var mFrame;
    var mTo;
    var mFPS;

    var iReset = function( time )
    {
        mFrame = 0;
        mTo = time;
        mFPS = 60.0;
    }

    var iCount = function( time )
    {
        mFrame++;

        if( (time-mTo)>500.0 )
        {
            mFPS = 1000.0*mFrame/(time-mTo);
            mFrame = 0;
            mTo = time;
            return true;
        }
        return false;
    }

    var iGetFPS = function()
    {
        return mFPS;
    }
    
    return { Reset : iReset, Count : iCount, GetFPS : iGetFPS };
}

function piCanMediaRecorded(canvas)
{
    if (typeof window.MediaRecorder !== 'function' || typeof canvas.captureStream !== 'function') {
        return false;
    }
    return true;
}

function piCreateMediaRecorder(isRecordingCallback, canvas) 
{
    if (piCanMediaRecorded(canvas) == false)
    {
        return null;
    }
    
    var options = { audioBitsPerSecond : 0, videoBitsPerSecond : 8000000 }; 
	     if (MediaRecorder.isTypeSupported('video/webm;codecs=h264')) options.mimeType = 'video/webm;codecs=h264';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9' )) options.mimeType = 'video/webm;codecs=vp9';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8' )) options.mimeType = 'video/webm;codecs=vp8';
    else                                                              options.mimeType = 'video/webm;';

    var mediaRecorder = new MediaRecorder(canvas.captureStream(), options);
    var chunks = [];
    
    mediaRecorder.ondataavailable = function(e) 
    {
        if (e.data.size > 0) 
        {
            chunks.push(e.data);
        }
    };
 
    mediaRecorder.onstart = function(){ 
        isRecordingCallback( true );
    };
    
    mediaRecorder.onstop = function()
    {
         isRecordingCallback( false );
         let blob     = new Blob(chunks, {type: "video/webm"});
         chunks       = [];
         let videoURL = window.URL.createObjectURL(blob);
         let url      = window.URL.createObjectURL(blob);
         let a        = document.createElement("a");
         document.body.appendChild(a);
         a.style      = "display: none";
         a.href       = url;
         a.download   = "capture.webm";
         a.click();
         window.URL.revokeObjectURL(url);
     };
    
    return mediaRecorder;
}

function piExportToEXR(width, height, numComponents, type, bytes)
{
    var bytesPerComponent = 0;
    if      (type=="Uint")   bytesPerComponent = 4; 
    else if (type=="Half")   bytesPerComponent = 2;
    else if (type=="Float")  bytesPerComponent = 4;

    var tHeader = 258 + (18 * numComponents + 1);
    var tTable = 8 * height;
    var tScanlines = height * (4 + 4 + (numComponents * bytesPerComponent * width));
    var tTotal = tHeader + tTable + tScanlines;

    //console.log("    header size = " + tHeader);
    //console.log("    table size = " + tTable);
    //console.log("    scanlines size = " + tScanlines);
    //console.log("    total = " + tTotal);

    var buffer = new ArrayBuffer(tTotal); 
    var data = new DataView(buffer);

    // Header
    {
        // Header : 4 bytes -> 0x76, 0x2f, 0x31, 0x01
        var c = 0;
        data.setUint8 (c++, 0x76);
        data.setUint8 (c++, 0x2f);
        data.setUint8 (c++, 0x31);
        data.setUint8 (c++, 0x01);

        // Version : 4 bytes -> 2, 0, 0, 0
        data.setUint8 (c++, 0x02);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        
        // Write channel info
        // Write attribute name : "channels"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x73);
            data.setUint8 (c++, 0x0);

            // Write attribute type : "chlist"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : 18 x 3 + 1 = 55
            var attribSize = 18 * numComponents + 1;
            data.setUint8 (c++, attribSize); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            var i;
            for (i = 0; i < numComponents; i++)
            {
                // Attribute : "B" (42) "G" (47) "R" (52)
                if (i==0)       data.setUint8 (c++, 0x42);
                else if (i==1)  data.setUint8 (c++, 0x47);
                else if (i==2)  data.setUint8 (c++, 0x52);
                data.setUint8 (c++, 0x00);
                
                // Value : Float (2), Half (1), Uint (0)
                if      (type=="Uint")   data.setUint8 (c++, 0x00); 
                else if (type=="Half")   data.setUint8 (c++, 0x01);
                else if (type=="Float")  data.setUint8 (c++, 0x02);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);

                // Plinear
                data.setUint8 (c++, 0x01);

                // Reserved
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 

                // X sampling
                data.setUint8 (c++, 0x01); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                
                // Y sampling
                data.setUint8 (c++, 0x01);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
            }
            // End attribute
            data.setUint8 (c++, 0x00);
    
        // Write attribute name : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute type : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : "1"
            data.setUint8 (c++, 0x01); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // Write attribute value : "0" (None)
            data.setUint8 (c++, 0x00);

        // datawindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00); 

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00);

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 

            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // displayWindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x79); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00);

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00); 

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // size
            data.setUint8 (c++, 0x01);
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);
            
            // value 
            data.setUint8 (c++, 0x00);

        // PixelAspectRatio
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x41); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x52); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x00); 

            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);
        
            // size 4
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 1.0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);
        
        // screenWindowCenter
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63);
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x43); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e);
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00);

            // v2f
            data.setUint8 (c++, 0x76); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x00);

            // size 8
            data.setUint8 (c++, 0x08); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

        // screenWindowWidth
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x00); 
            
            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00); 

            // size
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);

            // value
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);

        // End of header
        data.setUint8 (c++, 0x00);
    }
    //console.log("header size = " + c);

    // Scanline table
    var initc = c + height * 8;
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        var jump = initc + scanline * (8 + width * bytesPerComponent * numComponents); 
        data.setUint32 (c, jump, true);
        c += 4; 

        data.setUint32 (c, 0x00, true);
        c += 4;
    }
    //console.log("header + scanlines table size = " + c);

    // Scanlines
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        // Scanline
        data.setUint32(c, scanline, true);
        c += 4;

        // size 24
        var size = width * numComponents * bytesPerComponent; 
        data.setUint32(c, size, true);
        c += 4;

        var numComponentsSource = 4; // number of components in the SOURCE image
        for (var component = 0; component < numComponents ; component ++) 
        {
            for (var pixel = 0 ; pixel < width ; pixel ++) 
            {
                // flip vertical, so we read OpenGL buffers without JS image flipping
                var v = bytes[(height-1-scanline) * width *numComponentsSource + pixel * numComponentsSource + (2-component)];
                if      (type=="Float") data.setFloat32(c, v, true);
                else if (type=="Half")  data.setUint16(c, v, true);

                c += bytesPerComponent;
            }
        }
    }
    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}


function piExportToWAV(numSamples, rate, bits, numChannels, words)
{
    let numBytes = numSamples * numChannels * bits/8;

    let buffer = new ArrayBuffer(44 + numBytes); 
    let data = new DataView(buffer);

    {
        data.setUint32( 0, 0x46464952, true );  // RIFF
        data.setUint32( 4, numBytes + 36, true);
        {
            data.setUint32( 8, 0x45564157, true );  // WAV_WAVE
            data.setUint32( 12, 0x20746D66, true );  // WAV_FMT
            {
                data.setUint32( 16, 16, true);
                data.setUint16( 20, 1, true ); // WAV_FORMAT_PCM
                data.setUint16( 22, numChannels, true);
                data.setUint32( 24, rate, true);
                data.setUint32( 28, rate*numChannels*bits / 8, true);
                data.setUint16( 32, numChannels*bits / 8, true);
                data.setUint16( 34, bits, true);
            }

            data.setUint32( 36, 0x61746164, true);  // WAV_DATA
            {
                data.setUint32( 40, numBytes, true);
                let numWords = numSamples * numChannels;
                for(let i=0; i<numWords; i++ )
                {
                    data.setInt16( 44 + i*2, words[i], true );
                }
            }
        }
    }


    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}

function piTriggerDownload(name, blob)
{
    let url = URL.createObjectURL(blob);
    let aElement = document.createElement("a");
    aElement.href     = url;
    aElement.target   = "_self";
    aElement.download = name;
    document.body.appendChild(aElement);
    aElement.click();
    document.body.removeChild(aElement);
}</script>
    <script>"use strict"

function bufferID_to_assetID( id )
{
    if( id===0 ) return '4dXGR8';
    if( id===1 ) return 'XsXGR8';
    if( id===2 ) return '4sXGR8';
    if( id===3 ) return 'XdfGR8';
    return 'none';
}
function assetID_to_bufferID( id )
{
    if( id==='4dXGR8' ) return 0;
    if( id==='XsXGR8' ) return 1;
    if( id==='4sXGR8' ) return 2;
    if( id==='XdfGR8' ) return 3;
    return -1;
}

function assetID_to_cubemapBuferID( id )
{
    if( id==='4dX3Rr' ) return 0;
    return -1;
}
function cubamepBufferID_to_assetID( id )
{
    if( id===0 ) return '4dX3Rr';
    return 'none';
}

function EffectPass( renderer, is20, isLowEnd, hasShaderTextureLOD, callback, obj, forceMuted, forcePaused, outputGainNode, copyProgram, id, effect  )
{
    this.mID = id;
    this.mInputs  = [null, null, null, null ];
    this.mOutputs = [null, null, null, null ];
    this.mSource = null;

    this.mGainNode = outputGainNode;
    this.mSoundShaderCompiled = false;

    this.mEffect = effect;
    this.mRenderer = renderer;
    this.mProgramCopy = copyProgram; 
    this.mCompilationTime = 0;

    this.mType = "none";
    this.mName = "none";
    this.mFrame = 0;

    this.mShaderTextureLOD = hasShaderTextureLOD;
    this.mIs20 = is20;
    this.mIsLowEnd = isLowEnd;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mForceMuted = forceMuted;
    this.mForcePaused = forcePaused;
}

EffectPass.prototype.MakeHeader_Image = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        // old API
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                   header += "uniform sampler2D iChannel" + i + ";\n";

        // new API (see shadertoy.com/view/wtdGW8)
        header += "uniform struct {\n";
             if( inp===null )                  header += "  sampler2D";
        else if( inp.mInfo.mType==="cubemap" ) header += "  samplerCube";
        else if( inp.mInfo.mType==="volume"  ) header += "  sampler3D";
        else                                  header += "  sampler2D";
        header +=        " sampler;\n";
        header += "  vec3  size;\n";
        header += "  float time;\n";
        header += "  int   loaded;\n";
        header += "}iCh" + i + ";\n";
    }
	header += "void mainImage( out vec4 c, in vec2 f );\n";
    header += "void st_assert( bool cond );\n";
    header += "void st_assert( bool cond, int v );\n";

    if( this.mIs20 ) 
    {
        header += "\nout vec4 shadertoy_out_color;\n" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)shadertoy_out_color.x=-1.0;else if(v==1)shadertoy_out_color.y=-1.0;else if(v==2)shadertoy_out_color.z=-1.0;else shadertoy_out_color.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)shadertoy_out_color.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "shadertoy_out_color = vec4(1.0,1.0,1.0,1.0);" + 
            "vec4 color = vec4(1e20);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "if(shadertoy_out_color.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(shadertoy_out_color.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(shadertoy_out_color.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(shadertoy_out_color.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "shadertoy_out_color = vec4(color.xyz,1.0);" +
        "}";
    }
    else
    {
        header += "" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)gl_FragColor.x=-1.0;else if(v==1)gl_FragColor.y=-1.0;else if(v==2)gl_FragColor.z=-1.0;else gl_FragColor.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)gl_FragColor.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "gl_FragColor = vec4(0.0,0.0,0.0,1.0);" + 
            "vec4 color = vec4(1e20);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "color.w = 1.0;" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(gl_FragColor.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "gl_FragColor = vec4(color.xyz,1.0);"+
        "}";
    }
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 ) 
        this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "void main( void )" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );" +
        "color.w = 1.0;"
    if( this.mIs20 ) 
        this.mImagePassFooterVR +=  "outColor = color;}";
    else
        this.mImagePassFooterVR +=  "gl_FragColor = color;}";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Buffer = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                  header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainImage( out vec4 c,  in vec2 f );\n"

    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +
        "mainImage( color, gl_FragCoord.xy );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
    this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        this.mImagePassFooterVR +="outColor = color; }";
    else
        this.mImagePassFooterVR +="gl_FragColor = color; }";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Cubemap = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                   header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainCubemap( out vec4 c, in vec2 f, in vec3 ro, in vec3 rd );\n"

    header += "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainCubemap( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Sound = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform float     iChannelTime[4];\n" +
              "uniform float     iTimeOffset;\n" +
              "uniform int       iSampleOffset;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n";

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp!==null && inp.mInfo.mType==="cubemap" )
            header += "uniform samplerCube iChannel" + i + ";\n";
        else
            header += "uniform sampler2D iChannel" + i + ";\n";
    }
    header += "\n";
    header += "vec2 mainSound( in int samp, float time );\n";

    if( this.mIs20 )
    {
        header += "out vec4 outColor; void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "int   s = iSampleOffset + int(gl_FragCoord.y-0.2)*512 + int(gl_FragCoord.x-0.2);" +
            "vec2 y = mainSound( s, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "outColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    else
    {
        header += "void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "vec2 y = mainSound( 0, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "gl_FragColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    header += "\n";
    this.mHeader = header;
    this.mHeaderLength = 0;
}


EffectPass.prototype.MakeHeader_Common = function ()
{
    let header = "";
    let headerlength = 0;

    header += "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n";
    headerlength += 2;

    if (this.mIs20)
    {
        header += "out vec4 outColor;\n";
        headerlength += 1;
    }
    header += "void main( void )\n";
    headerlength += 1;

    if (this.mIs20)
        header += "{ outColor = vec4(0.0); }";
    else
        header += "{ gl_FragColor = vec4(0.0); }";
    headerlength += 1;
    header += "\n";
    headerlength += 1;

    this.mHeader = header;
    this.mHeaderLength = headerlength;
}

EffectPass.prototype.MakeHeader = function()
{
         if( this.mType==="image" ) this.MakeHeader_Image();
    else if( this.mType==="sound" ) this.MakeHeader_Sound();
    else if( this.mType==="buffer") this.MakeHeader_Buffer();
    else if( this.mType==="common") this.MakeHeader_Common();
    else if( this.mType==="cubemap") this.MakeHeader_Cubemap();
    else console.log("ERROR 4");
}

EffectPass.prototype.Create_Image = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}
EffectPass.prototype.Destroy_Image = function( wa )
{
}

EffectPass.prototype.Create_Buffer = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}

EffectPass.prototype.Destroy_Buffer = function( wa )
{
}

EffectPass.prototype.Create_Cubemap = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
}

EffectPass.prototype.Destroy_Cubemap = function( wa )
{
}

EffectPass.prototype.Create_Common = function( wa )
{
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.MakeHeader();
}
EffectPass.prototype.Destroy_Common = function( wa )
{
}

EffectPass.prototype.Create_Sound = function (wa)
{
    this.MakeHeader();

    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    this.mSampleRate = 44100;
    this.mPlayTime = 60*3;
    this.mPlaySamples = this.mPlayTime*this.mSampleRate;
    this.mBuffer = wa.createBuffer( 2, this.mPlaySamples, this.mSampleRate );

    //-------------------
    this.mTextureDimensions = 512;
    this.mRenderTexture = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D, 
                                                       this.mTextureDimensions, this.mTextureDimensions,
                                                       this.mRenderer.TEXFMT.C4I8,
                                                       this.mRenderer.FILTER.NONE,
                                                       this.mRenderer.TEXWRP.CLAMP, null);
    this.mRenderFBO = this.mRenderer.CreateRenderTarget(this.mRenderTexture, null, null, null, null, false);

    //-----------------------------

    // ArrayBufferView pixels;
    this.mTmpBufferSamples = this.mTextureDimensions*this.mTextureDimensions;
    this.mData = new Uint8Array( this.mTmpBufferSamples*4 );

    this.mPlaying = false;
}

EffectPass.prototype.Destroy_Sound = function( wa )
{
    if( this.mPlayNode!==null ) this.mPlayNode.stop();
    this.mPlayNode = null;
    this.mBuffer = null;
    this.mData = null;

    this.mRenderer.DestroyRenderTarget(this.mRenderFBO);
    this.mRenderer.DestroyTexture(this.mRenderTexture);
}

EffectPass.prototype.Create = function( passType, wa )
{
    this.mType = passType;
    this.mSource = null;

         if( passType==="image" ) this.Create_Image( wa );
    else if( passType==="sound" ) this.Create_Sound( wa );
    else if( passType==="buffer") this.Create_Buffer( wa );
    else if( passType==="common") this.Create_Common( wa );
    else if( passType==="cubemap") this.Create_Cubemap( wa );
    else alert("ERROR 1");
}

EffectPass.prototype.SetName = function (passName)
{
    this.mName = passName;
}

EffectPass.prototype.SetCode = function (src)
{
    this.mSource = src;
}

EffectPass.prototype.Destroy = function( wa )
{
    this.mSource = null;
         if( this.mType==="image" ) this.Destroy_Image( wa );
    else if( this.mType==="sound" ) this.Destroy_Sound( wa );
    else if( this.mType==="buffer") this.Destroy_Buffer( wa );
    else if( this.mType==="common") this.Destroy_Common( wa );
    else if( this.mType==="cubemap") this.Destroy_Cubemap( wa );
    else alert("ERROR 2");
}

EffectPass.prototype.NewShader_Sound = function( shaderCode, commonShaderCodes)
{
    let vsSource = null;

    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for( let i=0; i<commonShaderCodes.length; i++ )
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    this.mSoundShaderCompiled = false;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader_Image = function ( shaderCode, commonShaderCodes )
{
    this.mSupportsVR = false;

    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    return [vsSource, fsSource];


    /*
    let n1 = shaderCode.indexOf("mainVR(");
    let n2 = shaderCode.indexOf("mainVR (");
    let n3 = shaderCode.indexOf("mainVR  (");
    if( n1>0 || n2>0 || n3>0 )
    {
        let vsSourceVR;
        if( this.mIs20 )
            vsSourceVR = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        else
            vsSourceVR = "attribute in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

        let fsSourceVR = this.mHeader;
        for (let i = 0; i < commonShaderCodes.length; i++) {
            fsSourceVR += commonShaderCodes[i];
        }
        fsSourceVR += shaderCode;
        fsSourceVR += this.mImagePassFooterVR;

        let res = this.mRenderer.CreateShader(vsSource, fsSourceVR, preventCache);
        if( res.mResult == false )
        {
            return res.mInfo;
        }
        if( this.mProgramVR != null )
            this.mRenderer.DestroyShader( this.mProgramVR );

        this.mSupportsVR = true;
        this.mProgramVR = res;
    }
    */
}

EffectPass.prototype.NewShader_Cubemap = function( shaderCode, commonShaderCodes )
{
    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }

    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;

    fsSource += shaderCode;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader_Common = function (shaderCode )
{
    let vsSource = null;
    if (this.mIs20)
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader + shaderCode;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader = function ( commonSourceCodes, preventCache, onResolve)
{
    if( this.mRenderer===null ) return;

    let vs_fs = null;

         if( this.mType==="sound"  ) vs_fs = this.NewShader_Sound(   this.mSource, commonSourceCodes );
    else if( this.mType==="image"  ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="buffer" ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="common" ) vs_fs = this.NewShader_Common(  this.mSource,                   );
    else if( this.mType==="cubemap") vs_fs = this.NewShader_Cubemap( this.mSource, commonSourceCodes );
    else { console.log("ERROR 3: \"" + this.mType + "\""); return; }

    let me = this;
    this.mRenderer.CreateShader(vs_fs[0], vs_fs[1], preventCache, false,
        function (worked, info)
        {
            if (worked === true)
            {
                if (me.mType === "sound")
                {
                    me.mSoundShaderCompiled = true;
                }

                me.mCompilationTime = info.mTime;
                me.mError = false;
                me.mErrorStr = "No Errors";
                if (me.mProgram !== null)
                    me.mRenderer.DestroyShader(me.mProgram);
                me.mTranslatedSource = me.mRenderer.GetTranslatedShaderSource(info);
                me.mProgram = info;
            }
            else
            {
                me.mError = true;
                me.mErrorStr = info.mErrorStr;
            }
            onResolve();
        });
}

EffectPass.prototype.DestroyInput = function( id )
{
    if( this.mInputs[id]===null ) return;

    if( this.mInputs[id].mInfo.mType==="texture" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    if( this.mInputs[id].mInfo.mType==="volume" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="webcam" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video.src = "";

        if( this.mInputs[id].video.srcObject!==null )
        {
        let tracks = this.mInputs[id].video.srcObject.getVideoTracks();
        if( tracks ) tracks[0].stop();
        }
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="video" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="music" || this.mInputs[id].mInfo.mType==="musicstream")
    {
        this.mInputs[id].audio.pause();
        this.mInputs[id].audio.mSound.mFreqData = null;
        this.mInputs[id].audio.mSound.mWaveData = null;
        this.mInputs[id].audio = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="cubemap" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="keyboard" )
    {
        //if( this.mInputs[id].globject != null )
          //  this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="mic" )
    {
        this.mInputs[id].mic = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }

    this.mInputs[id] = null;
}

EffectPass.prototype.TooglePauseInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        else
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.audio.mPaused )
        {
            if( inp.loaded )
            {
                inp.audio.play();
            }
            inp.audio.mPaused = false;
        }
        else
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }

    return null;
}

EffectPass.prototype.StopInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused === false )
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused === false )
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.ResumeInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused )
        {
            inp.audio.play();
            inp.audio.mPaused = false;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.RewindInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp==null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.loaded )
        {
            inp.video.currentTime = 0;
        }
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.loaded )
        {
            inp.audio.currentTime = 0;
        }
    }
}

EffectPass.prototype.MuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = true;
        inp.video.mMuted = true;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 0.0;
        inp.audio.mMuted = true;
    }
}

EffectPass.prototype.UnMuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = false;
        inp.video.mMuted = false;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 1.0;
        inp.audio.mMuted = false;
    }
}

EffectPass.prototype.ToggleMuteInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];
    if( inp===null ) return null;

    if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.video.mMuted;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if( inp.audio.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.audio.mMuted;
    }

    return null;
}

EffectPass.prototype.UpdateInputs = function( wa, forceUpdate, keyboard )
{
   for (let i=0; i<this.mInputs.length; i++ )
   {
        let inp = this.mInputs[i];

        if( inp===null )
        {
            if( forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, null, false, 0, 0, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.image, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mPreview, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if( inp.loaded && forceUpdate )
            {
                if( this.mTextureCallbackFun!==null )
                {
                    let img = (assetID_to_cubemapBuferID(inp.mInfo.mID)===-1) ? inp.image[0] : inp.mImage;
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, img, true, 2, 1, -1.0, this.mID );
                }
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:keyboard.mIcon,mData:keyboard.mData}, false, 6, 0, -1.0, this.mID );
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, -1, this.mID );
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
              if( inp.loaded && inp.audio.mPaused === false && inp.audio.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                      inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                  }

                  if (this.mTextureCallbackFun!==null)
                  {
                           if (inp.mInfo.mType === "music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData}, false, 4, 1, inp.audio.currentTime, this.mID);
                      else if (inp.mInfo.mType === "musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData, info: inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                  }
              }
              else if( inp.loaded===false )
              {
                  if (this.mTextureCallbackFun!==null)
                      this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:null}, false, 4, 0, -1.0, this.mID);
              }
        }
        else if( inp.mInfo.mType==="mic" )
        {
              if( inp.loaded && inp.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                      inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
                  }
                  if( this.mTextureCallbackFun!==null )
                      this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave: ((wa==null)?null:inp.mFreqData) }, false, 5, 1, 0, this.mID );
              }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:null}, true, 9, 1, -1.0, this.mID );
            }
        }
    }
}

EffectPass.prototype.Sampler2Renderer = function (sampler)
{
    let filter = this.mRenderer.FILTER.NONE;
    if (sampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
    if (sampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
    let wrap = this.mRenderer.TEXWRP.REPEAT;
    if (sampler.wrap === "clamp") wrap = this.mRenderer.TEXWRP.CLAMP;
    let vflip = false;
    if (sampler.vflip === "true") vflip = true;

    return { mFilter: filter, mWrap: wrap, mVFlip: vflip };
}

EffectPass.prototype.GetSamplerVFlip = function (id)
{
    let inp = this.mInputs[id];
    return inp.mInfo.mSampler.vflip;
}

EffectPass.prototype.GetTranslatedShaderSource = function ()
{
    return this.mTranslatedSource;
}

EffectPass.prototype.SetSamplerVFlip = function (id, str) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = false;
    if (str === "true") filter = true;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, null);
            inp.mInfo.mSampler.vflip = str;
        }
    }
}

EffectPass.prototype.GetAcceptsVFlip = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return false;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return false;
    return true;
}

EffectPass.prototype.GetSamplerFilter = function (id)
{
    let inp = this.mInputs[id];
    if( inp===null) return;
    return inp.mInfo.mSampler.filter;
}

EffectPass.prototype.SetSamplerFilter = function (id, str, buffers, cubeBuffers) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = renderer.FILTER.NONE;
    if (str === "linear") filter = renderer.FILTER.LINEAR;
    if (str === "mipmap") filter = renderer.FILTER.MIPMAP;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0)
            {
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[0], filter, true);
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[1], filter, true);
                inp.mInfo.mSampler.filter = str;
            }
            else
            {
                renderer.SetSamplerFilter(inp.globject, filter, true);
                inp.mInfo.mSampler.filter = str;
            }
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[0], filter, true);
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[1], filter, true);
        inp.mInfo.mSampler.filter = str;
    }
    else if (inp.mInfo.mType === "keyboard")
    {
        inp.mInfo.mSampler.filter = str;
    }
}

EffectPass.prototype.GetAcceptsMipmapping = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetAcceptsLinear = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return true;
    if (inp.mInfo.mType === "musicstream") return true;
    if (inp.mInfo.mType === "mic")  return true;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return true;
    return false;
}

EffectPass.prototype.GetAcceptsWrapRepeat = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return false;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetSamplerWrap = function (id)
{
    return this.mInputs[id].mInfo.mSampler.wrap;
}

EffectPass.prototype.SetSamplerWrap = function (id, str, buffers)
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let restr = renderer.TEXWRP.REPEAT;
    if (str === "clamp") restr = renderer.TEXWRP.CLAMP;

    if (inp === null) 
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "video") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap") 
    {
        if (inp.loaded)
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "webcam") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[0], restr);
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[1], restr);
        inp.mInfo.mSampler.wrap = str;
    }
}


EffectPass.prototype.GetTexture = function( slot )
{
    let inp = this.mInputs[slot];
    if( inp===null ) return null;
    return inp.mInfo;
}

EffectPass.prototype.SetOutputs = function( slot, id )
{
    this.mOutputs[slot] = id;
}

EffectPass.prototype.SetOutputsByBufferID = function( slot, id )
{
    if( this.mType==="buffer" )
    {
        this.mOutputs[slot] = bufferID_to_assetID( id );

        this.mEffect.ResizeBuffer( id, this.mEffect.mXres, this.mEffect.mYres, false );
    }
    else if( this.mType==="cubemap" )
    {
        this.mOutputs[slot] = cubamepBufferID_to_assetID( id );
        this.mEffect.ResizeCubemapBuffer(id, 1024, 1024 );
    }
}

EffectPass.prototype.NewTexture = function( wa, slot, url, buffers, cubeBuffers, keyboard )
{
    var me = this;
    var renderer = this.mRenderer;

    if( renderer===null ) return;

    let texture = null;

    if( url===null || url.mType===null )
    {
        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( this.mTextureCallbackObj, slot, null, true, 0, 0, -1.0, me.mID );
        me.DestroyInput( slot );
        me.mInputs[slot] = null;
        me.MakeHeader();
        return { mFailed:false, mNeedsShaderCompile:false };
    }
    else if( url.mType==="texture" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.image = new Image();
        texture.image.crossOrigin = '';
        texture.image.onload = function()
        {
            let rti = me.Sampler2Renderer(url.mSampler);

            // O.M.G. FIX THIS
            let channels = renderer.TEXFMT.C4I8;
            if (url.mID === "Xdf3zn" || url.mID === "4sf3Rn" || url.mID === "4dXGzn" || url.mID === "4sf3Rr")
                channels = renderer.TEXFMT.C1I8;
            
            texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.image, channels, rti.mFilter, rti.mWrap, rti.mVFlip);

            texture.loaded = true;
            if( me.mTextureCallbackFun!==null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.image, true, 1, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="volume" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mImage = { mData:null, mXres:1, mYres:0, mZres:0 };
        texture.mPreview = new Image();
        texture.mPreview.crossOrigin = '';

	    var xmlHttp = new XMLHttpRequest();
        if( xmlHttp===null ) return { mFailed:true };

        xmlHttp.open('GET', url.mSrc, true);
        xmlHttp.responseType = "arraybuffer";
        xmlHttp.onerror = function()
        {
            console.log( "Error 1 loading Volume" );
        }
        xmlHttp.onload = function()
        {
            let data = xmlHttp.response;
            if (!data ) { console.log( "Error 2 loading Volume" ); return; }

            let file = piFile(data);

            let signature = file.ReadUInt32();
            texture.mImage.mXres = file.ReadUInt32();
            texture.mImage.mYres = file.ReadUInt32();
            texture.mImage.mZres = file.ReadUInt32();
            let binNumChannels = file.ReadUInt8();
            let binLayout = file.ReadUInt8();
            let binFormat = file.ReadUInt16();
            let format = renderer.TEXFMT.C1I8;
                 if( binNumChannels===1 && binFormat===0 )  format = renderer.TEXFMT.C1I8;
            else if( binNumChannels===2 && binFormat===0 )  format = renderer.TEXFMT.C2I8;
            else if( binNumChannels===3 && binFormat===0 )  format = renderer.TEXFMT.C3I8;
            else if( binNumChannels===4 && binFormat===0 )  format = renderer.TEXFMT.C4I8;
            else if( binNumChannels===1 && binFormat===10 ) format = renderer.TEXFMT.C1F32;
            else if( binNumChannels===2 && binFormat===10 ) format = renderer.TEXFMT.C2F32;
            else if( binNumChannels===3 && binFormat===10 ) format = renderer.TEXFMT.C3F32;
            else if( binNumChannels===4 && binFormat===10 ) format = renderer.TEXFMT.C4F32;
            else return;

            let buffer = new Uint8Array(data, 20); // skip 16 bytes (header of .bin)

            let rti = me.Sampler2Renderer(url.mSampler);

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T3D, texture.mImage.mXres, texture.mImage.mYres, format, rti.mFilter, rti.mWrap, buffer);

            if( texture.globject===null )
            {
                console.log( "Error 4: loading Volume" ); 
                return { mFailed:true };
            }

            if (me.mTextureCallbackFun !== null)
            {
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }

            texture.loaded = true;

            // load icon for it
            texture.mPreview.onload = function()
            {
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }
            texture.mPreview.src = url.mPreviewSrc;
        }
        xmlHttp.send("");


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="volume")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="cubemap" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        let rti = me.Sampler2Renderer(url.mSampler);

        if( assetID_to_cubemapBuferID(url.mID)!==-1 )
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 2, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/cubemap00.png";

            this.mEffect.ResizeCubemapBuffer(0, 1024, 1024 );

        }
        else
        {
            texture.image = [ new Image(), new Image(), new Image(), new Image(), new Image(), new Image() ];

            let numLoaded = 0;
            for (var i=0; i<6; i++ )
            {
                texture.image[i].mId = i;
                texture.image[i].crossOrigin = '';
                texture.image[i].onload = function()
                {
                    var id = this.mId;
                    numLoaded++;
                    if( numLoaded===6 )
                    {
                        texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.CUBEMAP, texture.image, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                        texture.loaded = true;
                        if (me.mTextureCallbackFun !== null)
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, texture.image[0], true, 2, 1, -1.0, me.mID);
                    }
                }

                if( i === 0) 
                {
                    texture.image[i].src = url.mSrc;
                } 
                else 
                {
                    let n = url.mSrc.lastIndexOf(".");
                    texture.image[i].src = url.mSrc.substring(0, n) + "_" + i + url.mSrc.substring(n, url.mSrc.length);
                }
            }
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="cubemap")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="webcam" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        texture.video = document.createElement('video');
    	texture.video.width = 320;
    	texture.video.height = 240;
    	texture.video.autoplay = true;
    	texture.video.loop = true;
        texture.mForceMuted = this.mForceMuted;
        texture.mImage = null;

        let rti = me.Sampler2Renderer(url.mSampler);

        var loadImageInsteadOfWebCam = function()
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.mImage, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 7, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/webcam.png";
        }
        
        loadImageInsteadOfWebCam();

        if( typeof navigator.getUserMedia !== "undefined"  && texture.mForceMuted===false )
        {
            texture.video.addEventListener("canplay", function (e)
            {
				try
				{
                    texture.mImage = null;
                    if( texture.globject != null )
                        renderer.DestroyTexture( texture.globject );
					texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
					texture.loaded = true;
                }
                catch(e)
                {
                    loadImageInsteadOfWebCam();
	                alert( 'Your browser can not transfer webcam data to the GPU.');
                }
            } );

            navigator.mediaDevices.getUserMedia( 
                                { "video": { width: 1280, height: 720 }, "audio": false } )
                                .then( function(stream)
                                       {
                                            texture.video.srcObject = stream;
    	                               } )
                                .catch( function(error)
                                        {
                                            loadImageInsteadOfWebCam();
    		                                alert( 'Unable to capture WebCam. Please reload the page.' );
    	                                } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="mic" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mForceMuted = this.mForceMuted;
        texture.mAnalyser = null;
        let num = 512;
        texture.mFreqData = new Uint8Array( num );
        texture.mWaveData = new Uint8Array( num );

        if( wa === null || typeof navigator.getUserMedia === "undefined" )
        {
            if( !texture.mForceMuted ) alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.mForceMuted = true; 
        }

        if( texture.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, num, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)
            texture.loaded = true;
        }
        else
        {
        navigator.getUserMedia( { "audio": true },
                                function(stream)
                                {
                                  texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, null)
                                  texture.mic = wa.createMediaStreamSource(stream);
                                  texture.mAnalyser = wa.createAnalyser();
                                  texture.mic.connect( texture.mAnalyser );
                                  texture.loaded = true;
    	                        },
                                function(error)
                                {
    		                        alert( 'Unable open Mic. Please reload the page.' );
    	                        } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="video" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.video = document.createElement('video');
    	texture.video.loop = true;
        texture.video.preload = "auto";
        texture.video.mPaused = this.mForcePaused;
        texture.video.mMuted = true;//this.mForceMuted;
    	texture.video.muted  = true;//this.mForceMuted;
        if( this.mForceMuted===true )
            texture.video.volume = 0;
    	texture.video.autoplay = false;
        texture.video.hasFalled = false;
        
        let rti = me.Sampler2Renderer(url.mSampler);

        texture.video.addEventListener("canplay", function (e)
        {
            texture.video.play().then( function()
                                       {
                                           texture.video.mPaused = false;

                                           texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                                           texture.loaded = true;
            
                                           if( me.mTextureCallbackFun!=null )
                                               me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.video, true, 3, 1, -1.0, me.mID );
                                        } )
                               .catch( function(error)
                                       {
                                           console.log( error );
                                       }
                                );
        } );

        texture.video.addEventListener( "error", function(e)
        {
               if( texture.video.hasFalled===true ) { alert("Error: cannot load video" ); return; }
               let str = texture.video.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".mp4";
               texture.video.src = str;
               texture.video.hasFalled = true;
        } );

        texture.video.src = url.mSrc;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="music" || url.mType==="musicstream" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.audio = document.createElement('audio');
    	texture.audio.loop = true;
        texture.audio.mMuted = this.mForceMuted;
        texture.audio.mForceMuted = this.mForceMuted;
        texture.audio.muted = this.mForceMuted;
        if( this.mForceMuted===true )
            texture.audio.volume = 0;
        texture.audio.autoplay = false;
        texture.audio.hasFalled = false;
        texture.audio.mPaused = false;
        texture.audio.mSound = {};

        if( this.mForceMuted===false )
        {
            if(url.mType==="musicstream" && SC === null)
            {
                alert( "Shadertoy: Soundcloud could not be reached" );
                texture.audio.mForceMuted = true;
            }
            }

        if( wa === null && this.mForceMuted===false )
        {
            alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.audio.mForceMuted = true;
        }

        if( texture.audio.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null);
            let num = 512;
            texture.audio.mSound.mFreqData = new Uint8Array( num );
            texture.audio.mSound.mWaveData = new Uint8Array( num );
            texture.loaded = true;
        }

        texture.audio.addEventListener( "canplay", function()
        {
            if( texture===null || texture.audio===null ) return;
            if( this.mForceMuted  ) return;
            if( texture.loaded === true ) return;

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)

            texture.audio.mSound.mSource   = wa.createMediaElementSource( texture.audio );
            texture.audio.mSound.mAnalyser = wa.createAnalyser();
            texture.audio.mSound.mGain     = wa.createGain();

            texture.audio.mSound.mSource.connect(   texture.audio.mSound.mAnalyser );
            texture.audio.mSound.mAnalyser.connect( texture.audio.mSound.mGain );
            texture.audio.mSound.mGain.connect(me.mGainNode);

            texture.audio.mSound.mFreqData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );
            texture.audio.mSound.mWaveData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );

            if( texture.audio.mPaused )
            {
                texture.audio.pause();
            }
            else
            {
                texture.audio.play().then( function() {} ).catch( function(e){console.log("error " + e);} );
            }
            texture.loaded = true;
        } );

        texture.audio.addEventListener( "error", function(e)
        {
               if( this.mForceMuted  ) return;

               if( texture.audio.hasFalled===true ) { return; }
               let str = texture.audio.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".ogg";
               texture.audio.src = str;
               texture.audio.hasFalled = true;
        } );

        if( !texture.audio.mForceMuted )
        {
            if(url.mType==="musicstream")
            {
                SC.resolve(url.mSrc, 
                    function(song) 
                    {
                        if( song.streamable===true )
                        {
                            texture.audio.crossOrigin = 'anonymous';
                            texture.audio.src = song.stream_url;
                            texture.audio.soundcloudInfo = song;
                        }
                        else
                        {
                            alert('Shadertoy: Soundcloud 3 - This track cannot be streamed' );
                        }
                    },
                    function(error)
                    {
                        if (me.mTextureCallbackFun!==null)
                        {
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
                        }
                    } );
            } 
            else
            {
                texture.audio.src = url.mSrc;
            }
        }

        if (me.mTextureCallbackFun!==null)
        {
            if (url.mType === "music")            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
            else if (url.mType === "musicstream") me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null, info: texture.audio.soundcloudInfo}, false, 8, 0, -1.0, me.mID);
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="keyboard" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = true;

        texture.keyboard = {};

        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {mImage: keyboard.mIcon, mData: keyboard.mData}, false, 6, 1, -1.0, me.mID );

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="buffer" )
    {
        texture = {};
        texture.mInfo = url;

        texture.image = new Image();
        texture.image.onload = function()
        {
            if( me.mTextureCallbackFun!==null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {texture: texture.image, data:null}, true, 9, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;
        texture.id = assetID_to_bufferID( url.mID );
        texture.loaded = true;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;

        this.mEffect.ResizeBuffer(texture.id, this.mEffect.mXres, this.mEffect.mYres, false );

        this.SetSamplerFilter(slot, url.mSampler.filter, buffers, cubeBuffers, true);
        this.SetSamplerVFlip(slot, url.mSampler.vflip);
        this.SetSamplerWrap(slot, url.mSampler.wrap, buffers);

        this.MakeHeader();
        return returnValue;
    }
    else
    {
        alert( "input type error" );
        return { mFailed: true };
    }

    return { mFailed: true };
}

EffectPass.prototype.Paint_Image = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];

    //------------------------
    
    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];
    let texIsLoaded = [0, 0, 0, 0 ];
    let texID = [ null, null, null, null];

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
            texIsLoaded[i] = 1;
            resos[3*i+0] = 256;
            resos[3*i+1] = 3;
            resos[3*i+2] = 1;
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;

                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                }
            }
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {

                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                texIsLoaded[i] = 0;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    times[i] = 10.0 + time;
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            let id = inp.id;
            if( inp.loaded===true  )
            {
                texID[i] = buffers[id].mTexture[ buffers[id].mLastRenderDone ];
                texIsLoaded[i] = 1;
                resos[3*i+0] = xres;
                resos[3*i+1] = yres;
                resos[3*i+2] = 1;
                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID[i], filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    let prog = this.mProgram;

    //if( vrData!=null && this.mSupportsVR ) prog = this.mProgramVR;

    this.mRenderer.AttachShader(prog);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F("iFrameRate", fps);

    this.mRenderer.SetShaderConstant1F(  "iCh0.time", times[0] );
    this.mRenderer.SetShaderConstant1F(  "iCh1.time", times[1] );
    this.mRenderer.SetShaderConstant1F(  "iCh2.time", times[2] );
    this.mRenderer.SetShaderConstant1F(  "iCh3.time", times[3] );
    this.mRenderer.SetShaderConstant3F(  "iCh0.size", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iCh1.size", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iCh2.size", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iCh3.size", resos[9], resos[10], resos[11] );
    this.mRenderer.SetShaderConstant1I(  "iCh0.loaded", texIsLoaded[0] );
    this.mRenderer.SetShaderConstant1I(  "iCh1.loaded", texIsLoaded[1] );
    this.mRenderer.SetShaderConstant1I(  "iCh2.loaded", texIsLoaded[2] );
    this.mRenderer.SetShaderConstant1I(  "iCh3.loaded", texIsLoaded[3] );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    if( (vrData !== null) && this.mSupportsVR )
    {
        for (let i=0; i<2; i++ )
        {
            let ei = (i===0) ? vrData.mLeftEye : vrData.mRightEye;

            let vp = [i * xres / 2, 0, xres / 2, yres];

            this.mRenderer.SetViewport(vp);

            let fov = ei.mProjection;
            let corA = [ -fov[2], -fov[1], -1.0 ];
            let corB = [  fov[3], -fov[1], -1.0 ];
            let corC = [  fov[3],  fov[0], -1.0 ];
            let corD = [ -fov[2],  fov[0], -1.0 ];
            let apex = [ 0.0, 0.0, 0.0 ];

            let ma = invertFast( ei.mCamera );
            corA = matMulpoint( ma, corA ); 
            corB = matMulpoint( ma, corB ); 
            corC = matMulpoint( ma, corC ); 
            corD = matMulpoint( ma, corD ); 
            apex = matMulpoint( ma, apex ); 

            let corners = [ corA[0], corA[1], corA[2], 
                            corB[0], corB[1], corB[2], 
                            corC[0], corC[1], corC[2], 
                            corD[0], corD[1], corD[2],
                            apex[0], apex[1], apex[2]];

            this.mRenderer.SetShaderConstant3FV("unCorners", corners);
            this.mRenderer.SetShaderConstant4FV("unViewport", vp);

            this.mRenderer.DrawUnitQuad_XY(l1);
        }
    }
    else 
    {
        this.mRenderer.SetViewport([0, 0, xres, yres]);
        this.mRenderer.DrawFullScreenTriangle_XY( l1 );
    }

    this.mRenderer.DettachTextures();
}

EffectPass.prototype.iRenderSound = function(d, callback )
{
    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds() ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    this.mRenderer.SetRenderTarget(this.mRenderFBO);

    this.mRenderer.SetViewport([0, 0, this.mTextureDimensions, this.mTextureDimensions]);
    this.mRenderer.AttachShader(this.mProgram);
    this.mRenderer.SetBlend( false );

    let texID = [null, null, null, null];
    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
    }

    this.mRenderer.AttachTextures(4, texID[0], texID[1], texID[2], texID[3]);

    let l2 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iTimeOffset");
    let l3 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iSampleOffset");
    this.mRenderer.SetShaderConstant4FV("iDate", dates);
    this.mRenderer.SetShaderConstant3FV("iChannelResolution", resos);
    this.mRenderer.SetShaderConstant1F("iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit("iChannel0", 0);
    this.mRenderer.SetShaderTextureUnit("iChannel1", 1);
    this.mRenderer.SetShaderTextureUnit("iChannel2", 2);
    this.mRenderer.SetShaderTextureUnit("iChannel3", 3);

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    //--------------------------------
    let numSamples = this.mTmpBufferSamples;
    let numBlocks = this.mPlaySamples / numSamples;
    for (let j=0; j<numBlocks; j++ )
    {
        let off = j*numSamples;
        
        this.mRenderer.SetShaderConstant1F_Pos(l2, off / this.mSampleRate);
        this.mRenderer.SetShaderConstant1I_Pos(l3, off );
        this.mRenderer.DrawUnitQuad_XY(l1);

        this.mRenderer.GetPixelData(this.mData, 0, this.mTextureDimensions, this.mTextureDimensions);

        callback( off, this.mData, numSamples );
    }

    this.mRenderer.DetachShader();
    this.mRenderer.DettachTextures();
    this.mRenderer.SetRenderTarget(null);
}

EffectPass.prototype.Paint_Sound = function( wa, d )
{
    let bufL = this.mBuffer.getChannelData(0); // Float32Array
    let bufR = this.mBuffer.getChannelData(1); // Float32Array

    this.iRenderSound( d, function(off, data, numSamples)
                         {
                            for( let i=0; i<numSamples; i++ )
                            {
                                bufL[off+i] = -1.0 + 2.0*(data[4*i+0]+256.0*data[4*i+1])/65535.0;
                                bufR[off+i] = -1.0 + 2.0*(data[4*i+2]+256.0*data[4*i+3])/65535.0;
                            }
                         }
                     );
}

EffectPass.prototype.SetUniforms = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    //------------------------
    
    let texID = [ null, null, null, null];

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
        }
        else if( inp.mInfo.mType=="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
    
                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                }
            }

        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
           if( inp.loaded===true )
           { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                times[i] = 10.0 + time;
            }

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = buffers[inp.id].mTexture[ buffers[inp.id].mLastRenderDone ];
                resos[3*i+0] = buffers[inp.id].mResolution[0];
                resos[3*i+1] = buffers[inp.id].mResolution[1];
                resos[3*i+2] = 1;
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    this.mRenderer.AttachShader(this.mProgram);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F(  "iFrameRate", fps );

    this.mRenderer.SetShaderConstant1F(  "iChannel[0].time",       times[0] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[1].time",       times[1] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[2].time",       times[2] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[3].time",       times[3] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[0].resolution", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[1].resolution", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[2].resolution", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[3].resolution", resos[9], resos[10], resos[11] );
}

EffectPass.prototype.ProcessInputs = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
        }
        else if( inp.mInfo.mType==="volume" )
        {
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );
                }
                else if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                if( inp.audio.mForceMuted === true )
                {
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                let id = inp.id;
                let texID = buffers[id].mTexture[ buffers[id].mLastRenderDone ];

                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID, filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
				let id = inp.id;
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }
}

EffectPass.prototype.Paint_Cubemap = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face )
{
    this.ProcessInputs(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
    this.SetUniforms(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    let vp = [0, 0, xres, yres];

    this.mRenderer.SetViewport(vp);

    let corA = [-1.0, -1.0, -1.0];
    let corB = [ 1.0, -1.0, -1.0];
    let corC = [ 1.0,  1.0, -1.0];
    let corD = [-1.0,  1.0, -1.0];
    let apex = [ 0.0,  0.0,  0.0];

         if( face===0 ) { corA=[ 1.0,  1.0,  1.0]; corB=[ 1.0,  1.0, -1.0]; corC=[ 1.0, -1.0, -1.0]; corD=[ 1.0, -1.0,  1.0]; }
    else if( face===1 ) { corA=[-1.0,  1.0, -1.0]; corB=[-1.0,  1.0,  1.0]; corC=[-1.0, -1.0,  1.0]; corD=[-1.0, -1.0, -1.0]; }
    else if( face===2 ) { corA=[-1.0,  1.0, -1.0]; corB=[ 1.0,  1.0, -1.0]; corC=[ 1.0,  1.0,  1.0]; corD=[-1.0,  1.0,  1.0]; }
    else if( face===3 ) { corA=[-1.0, -1.0,  1.0]; corB=[ 1.0, -1.0,  1.0]; corC=[ 1.0, -1.0, -1.0]; corD=[-1.0, -1.0, -1.0]; }
    else if( face===4 ) { corA=[-1.0,  1.0,  1.0]; corB=[ 1.0,  1.0,  1.0]; corC=[ 1.0, -1.0,  1.0]; corD=[-1.0, -1.0,  1.0]; }
    else if( face===5 ) { corA=[ 1.0,  1.0, -1.0]; corB=[-1.0,  1.0, -1.0]; corC=[-1.0, -1.0, -1.0]; corD=[ 1.0, -1.0, -1.0]; }

    let corners = [ corA[0], corA[1], corA[2], 
                    corB[0], corB[1], corB[2], 
                    corC[0], corC[1], corC[2], 
                    corD[0], corD[1], corD[2],
                    apex[0], apex[1], apex[2]];

    this.mRenderer.SetShaderConstant3FV("unCorners", corners);
    this.mRenderer.SetShaderConstant4FV("unViewport", vp);

    this.mRenderer.DrawUnitQuad_XY(l1);

    this.mRenderer.DettachTextures();
}

EffectPass.prototype.Paint = function( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, bufferNeedsMimaps, buffers, cubeBuffers, keyboard, effect )
{
    if( this.mType==="sound" )
    {
        if (this.mSoundShaderCompiled === true)
        {
            // make sure all textures are loaded
            for (let i=0; i<this.mInputs.length; i++ )
            {
                let inp = this.mInputs[i];
                if (inp === null) continue;

                if (inp.mInfo.mType === "texture" && !inp.loaded) return;
                if (inp.mInfo.mType === "cubemap" && !inp.loaded) return;
            }

            this.Paint_Sound(wa, da);
            this.mSoundShaderCompiled = false;
        }
        if (this.mFrame === 0)
        {
            if (this.mPlaying===true)
            {
                this.mPlayNode.disconnect();
                this.mPlayNode.stop();
                this.mPlayNode = null;
            }
            this.mPlaying = true;

            this.mPlayNode = wa.createBufferSource();
            this.mPlayNode.buffer = this.mBuffer;
            this.mPlayNode.connect(this.mGainNode);
            this.mPlayNode.start(0);
        }
        this.mFrame++;
    }
    else if( this.mType==="image" )
    {
        this.mRenderer.SetRenderTarget( null );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );
        this.mFrame++;
    }
    else if( this.mType==="common" )
    {
    }
    else if( this.mType==="buffer" )
    {
        this.mEffect.ResizeBuffer(bufferID, this.mEffect.mXres, this.mEffect.mYres, false );

        let buffer = buffers[bufferID];

        let dstID = 1 - buffer.mLastRenderDone;

        this.mRenderer.SetRenderTarget( buffer.mTarget[dstID] );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }

        // make thumbnail
        //if( this.mTextureCallbackFun != null )
        /*
        {
            this.mRenderer.SetRenderTarget( buffer.mThumbnailRenderTarget );
            let v = [0, 0, buffer.mThumbnailRes[0], buffer.mThumbnailRes[1]];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            this.mRenderer.SetShaderConstant4FV("v", v);
            this.mRenderer.AttachTextures(1, buffer.mTexture[dstID], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);
            this.mRenderer.DettachTextures();
            this.mRenderer.DetachShader();
            this.mRenderer.GetPixelData( new Uint8Array(buffer.mThumbnailBuffer.data.buffer), buffer.mThumbnailRes[0], buffer.mThumbnailRes[1] );
            this.mRenderer.SetRenderTarget(null);
        }
        */
        buffers[bufferID].mLastRenderDone = 1 - buffers[bufferID].mLastRenderDone;
        this.mFrame++;
    }
    else if( this.mType==="cubemap" )
    {
        this.mEffect.ResizeCubemapBuffer(bufferID, 1024, 1024, false );

        let buffer = cubeBuffers[bufferID];

        xres = buffer.mResolution[0];
        yres = buffer.mResolution[1];
        let dstID = 1 - buffer.mLastRenderDone;
        for( let face=0; face<6; face++ )
        {
            this.mRenderer.SetRenderTargetCubeMap( buffer.mTarget[dstID], face );
            this.Paint_Cubemap( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
        }
        this.mRenderer.SetRenderTargetCubeMap( null, 0 );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }
        cubeBuffers[bufferID].mLastRenderDone = 1 - cubeBuffers[bufferID].mLastRenderDone;

        this.mFrame++;
    }
}

EffectPass.prototype.StopOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;
    this.mPlayNode.disconnect();
}

EffectPass.prototype.ResumeOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;

    wa.resume()
    this.mPlayNode.connect( this.mGainNode );
}

EffectPass.prototype.StopOutput_Image = function( wa )
{
}

EffectPass.prototype.ResumeOutput_Image = function( wa )
{
}

EffectPass.prototype.StopOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.StopInput(j);

    if( this.mType==="sound" )
         this.StopOutput_Sound( wa );
    else
         this.StopOutput_Image( wa );
}

EffectPass.prototype.ResumeOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.ResumeInput(j);

    if( this.mType==="sound" )
         this.ResumeOutput_Sound( wa );
    else
         this.ResumeOutput_Image( wa );
}

EffectPass.prototype.GetCompilationTime = function()
{
    return this.mCompilationTime;
}

//============================================================================================================
function Screenshots()
{
    // private
    let mTexture = null;
    let mTarget = null;
    let mXres = 0;
    let mYres = 0;
    let mCubemapToEquirectProgram;
    let mRenderer = null;

    // public
    var me = {};

    me.Initialize = function(renderer)
    {
        mRenderer = renderer;
        let caps = mRenderer.GetCaps();
        let is20 = caps.mIsGL20;

        let vsSourceC, fsSourceC;
        if( is20 )
        {
            vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; out vec4 outColor; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); outColor = texture(t, rd); }";
        }
        else
        {
            vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); gl_FragColor = texture(t, rd); }";
        }

        let compileShader = function (worked, info)
        {
            if (worked === false)
            {
                console.log("Failed to compile cubemap resample shader (" + errorType + "): " + log);
            }
            else
            {
                mCubemapToEquirectProgram = info;
            }
        }
        mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, compileShader);

        return true;
    };

    me.Allocate = function( xres, yres )
    {
        if( xres>mXres || yres>mYres )
        {
            let texture = mRenderer.CreateTexture(mRenderer.TEXTYPE.T2D, xres, yres, mRenderer.TEXFMT.C4F32, mRenderer.FILTER.NONE, mRenderer.TEXWRP.CLAMP, null);
            let target = mRenderer.CreateRenderTarget( texture, null, null, null, null, false);

            if( mXres!==0 )
            {
                mRenderer.DestroyTexture(mTexture);
                mRenderer.DestroyRenderTarget(mTarget);
            }

            mTexture = texture;
            mTarget = target;
            mXres = xres;
            mYres = yres;
        }
    };

    me.GetProgram = function()
    {
        return mCubemapToEquirectProgram;
    };
    me.GetTarget = function()
    {
        return mTarget;
    };

    return me;
};

//============================================================================================================

function Effect(vr, ac, canvas, callback, obj, forceMuted, forcePaused, resizeCallback, crashCallback )
{
    let xres = canvas.width;
    let yres = canvas.height;

    let me = this;
    this.mCanvas = canvas;
    this.mCreated = false;
    this.mRenderer = null;
    this.mAudioContext = ac;
    this.mGLContext = null;
    this.mWebVR = vr;
    this.mRenderingStereo = false;
    this.mXres = xres;
    this.mYres = yres;
    this.mForceMuted = forceMuted;
    if( ac===null ) this.mForceMuted = true;
    this.mForcePaused = forcePaused;
    this.mGainNode = null;
    this.mPasses = [];
    this.mFrame = 0;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mMaxBuffers = 4;
    this.mMaxCubeBuffers = 1;
    this.mMaxPasses = this.mMaxBuffers + 1 + 1 + 1 + 1; // some day decouple passes from buffers (4 buffers + common + Imagen + sound + cubemap)
    this.mBuffers = [];
    this.mCubeBuffers = [];
    this.mScreenshotSytem = null;
    this.mCompilationTime = 0;
    this.mIsLowEnd = piIsMobile();

    this.mGLContext = piCreateGlContext(canvas, false, false, true, false); // need preserve-buffe to true in order to capture screenshots
    if (this.mGLContext === null)
    {
        return;
    }

    canvas.addEventListener("webglcontextlost", function (event)
        {
            event.preventDefault();
            crashCallback();
        }, false);

    this.mRenderer = piRenderer();
    if (!this.mRenderer.Initialize(this.mGLContext))
        return;

    this.mScreenshotSytem = Screenshots();
    if (!this.mScreenshotSytem.Initialize(this.mRenderer))
        return;

    var caps = this.mRenderer.GetCaps();
    this.mIs20 = caps.mIsGL20;
    this.mShaderTextureLOD = caps.mShaderTextureLOD;
    //-------------
    if( ac!==null )
    {   
        this.mGainNode = ac.createGain();
        if( !forceMuted )
        {
            this.mGainNode.connect( ac.destination);
        }
        if (this.mForceMuted )
            this.mGainNode.gain.value = 0.0;
        else
            this.mGainNode.gain.value = 1.0;
    }

    //-------------
    let vsSourceC, fsSourceC;
    if( this.mIs20 )
    {
        vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { outColor = textureLod(t, gl_FragCoord.xy / v.zw, 0.0); }";
    }
    else
    {
        vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; void main() { gl_FragColor = texture2D(t, gl_FragCoord.xy / v.zw, -100.0); }";
    }

    this.mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, function(worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to copy buffers : " + info.mErrorStr);
            else me.mProgramCopy = info;
        });

    let vsSourceD, fsSourceD;
    if( this.mIs20 )
    {
        vsSourceD = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { vec2 uv = gl_FragCoord.xy / v.zw; outColor = texture(t, vec2(uv.x,1.0-uv.y)); }";
    }
    else
    {
        vsSourceD = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; void main() { vec2 uv = gl_FragCoord.xy / v.zw; gl_FragColor = texture2D(t, vec2(uv.x,1.0-uv.y)); }";
    }

    this.mRenderer.CreateShader(vsSourceD, fsSourceD, false, true, function (worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to downscale buffers : " + info.mErrorStr);
            else me.mProgramDownscale = info;
        });


    // set all buffers and cubemaps to null
    for( let i=0; i<this.mMaxBuffers; i++ )
    {
        this.mBuffers[i] = { mTexture: [null, null], 
                             mTarget:  [null, null], 
                             mResolution: [0, 0],
                             mLastRenderDone: 0,
                             mThumbnailRenderTarget: null,
                             mThumbnailTexture: null,
                             mThumbnailBuffer:  null,
                             mThumbnailRes: [0, 0] };
    }

    for( let i=0; i<this.mMaxCubeBuffers; i++ )
    {
        this.mCubeBuffers[i] = { mTexture: [null, null], 
                                mTarget:  [null, null], 
                                mResolution: [0, 0],
                                mLastRenderDone: 0,
                                mThumbnailRenderTarget: null,
                                mThumbnailTexture: null,
                                mThumbnailBuffer:  null,
                                mThumbnailRes: [0, 0] };
    }

    //-------

    let keyboardData = new Uint8Array( 256*3 );
    for (let j=0; j<(256*3); j++ ) { keyboardData[j] = 0; }
    let kayboardTexture = this.mRenderer.CreateTexture( this.mRenderer.TEXTYPE.T2D, 256, 3, this.mRenderer.TEXFMT.C1I8, this.mRenderer.FILTER.NONE, this.mRenderer.TEXWRP.CLAMP, null);
    let keyboardImage = new Image();
    if( callback!==null )
        keyboardImage.src = "/img/keyboard.png"; // don't load PNG if no UI 
    this.mKeyboard = { mData: keyboardData, mTexture: kayboardTexture, mIcon: keyboardImage };

    let iResize = function( xres, yres )
    {
        me.mCanvas.width = xres;
        me.mCanvas.height = yres;
        me.mXres = xres;
        me.mYres = yres;
        me.ResizeBuffers(xres, yres);
        resizeCallback(xres, yres);
    };

    let bestAttemptFallback = function()
    {
        let devicePixelRatio = window.devicePixelRatio || 1;
        let xres = Math.round(me.mCanvas.offsetWidth  * devicePixelRatio) | 0;
        let yres = Math.round(me.mCanvas.offsetHeight * devicePixelRatio) | 0;
        iResize(xres, yres);
    };

    if(!window.ResizeObserver)
    {
        console.log("WARNING: This browser doesn't support ResizeObserver.");
        bestAttemptFallback();
        window.addEventListener("resize", bestAttemptFallback);
    }
    else
    {
        this.mRO = new ResizeObserver( function(entries, observer)
        {
            var entry = entries[0];
            if (!entry['devicePixelContentBoxSize'])
            {
                observer.unobserve(me.mCanvas);
                console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (2)");
                bestAttemptFallback();
                window.addEventListener("resize", bestAttemptFallback);
            }
            else
            {
                let box = entry.devicePixelContentBoxSize[0];
                let xres = box.inlineSize;
                let yres = box.blockSize;
                iResize(xres, yres);
            }
        });
        try
        {
            this.mRO.observe(this.mCanvas, { box: ["device-pixel-content-box"] });
            //this.mRO.observe(this.mCanvas);
        }
        catch (e)
        {
            console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (1)");
            bestAttemptFallback();
            window.addEventListener("resize", bestAttemptFallback);
        }
    }

    this.mCreated = true;
}

Effect.prototype.ResizeCubemapBuffer = function(i, xres, yres )
{
    let oldXres = this.mCubeBuffers[i].mResolution[0];
    let oldYres = this.mCubeBuffers[i].mResolution[1];

    if( this.mCubeBuffers[i].mTexture[0]===null || oldXres !== xres || oldYres !== yres )
    {
        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);
        let target1 = this.mRenderer.CreateRenderTargetCubeMap( texture1, null, false);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target2 = this.mRenderer.CreateRenderTargetCubeMap( texture2, null, false);

        // Store new buffers
        this.mCubeBuffers[i].mTexture = [texture1,texture2], 
        this.mCubeBuffers[i].mTarget =  [target1, target2 ], 
        this.mCubeBuffers[i].mLastRenderDone = 0;
        this.mCubeBuffers[i].mResolution[0] = xres;
        this.mCubeBuffers[i].mResolution[1] = yres;
    }
}

Effect.prototype.ResizeBuffer = function( i, xres, yres, skipIfNotExists )
{
    if( skipIfNotExists && this.mBuffers[i].mTexture[0]===null ) return;

    let oldXres = this.mBuffers[i].mResolution[0];
    let oldYres = this.mBuffers[i].mResolution[1];

    if( oldXres !== xres || oldYres !== yres )
    {
        let needCopy = (this.mBuffers[i].mTexture[0]!==null);

        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[0].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[0].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[1].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[1].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target1 = this.mRenderer.CreateRenderTarget( texture1, null, null, null, null, false);
        let target2 = this.mRenderer.CreateRenderTarget( texture2, null, null, null, null, false);

        if( needCopy )
        {
            let v = [0, 0, Math.min(xres, oldXres), Math.min(yres, oldYres)];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            let vOld = [0, 0, oldXres, oldYres];
            this.mRenderer.SetShaderConstant4FV("v", vOld);

            // Copy old buffers 1 to new buffer
            this.mRenderer.SetRenderTarget(target1);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[0], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Copy old buffers 2 to new buffer
            this.mRenderer.SetRenderTarget(target2);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[1], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Deallocate old memory
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[0]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[0]);
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[1]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[1]);
            //this.mRenderer.DestroyTexture(this.mBuffers[i].thumbnailTexture);
        }

        // Store new buffers
        this.mBuffers[i].mTexture = [texture1,texture2], 
        this.mBuffers[i].mTarget =  [target1, target2 ], 
        this.mBuffers[i].mLastRenderDone = 0;
        this.mBuffers[i].mResolution[0] = xres;
        this.mBuffers[i].mResolution[1] = yres;
    }
}

Effect.prototype.saveScreenshot = function(passid)
{
    let pass = this.mPasses[passid];

    if( pass.mType === "buffer" )
    {
        let bufferID = assetID_to_bufferID( this.mPasses[passid].mOutputs[0] );

        let texture = this.mBuffers[bufferID].mTarget[ this.mBuffers[bufferID].mLastRenderDone ];

        let numComponents = 3;
        let width = texture.mTex0.mXres;
        let height = texture.mTex0.mYres;
        let type = "Float"; // Other options Float, Half, Uint
        let bytes = new Float32Array(width * height * 4 );//numComponents);
        this.mRenderer.GetPixelDataRenderTarget( texture, bytes, width, height );
        let blob = piExportToEXR(width, height, numComponents, type, bytes);

        // Offer download automatically to the user
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "cubemap" )
    {
        let xres = 4096;
        let yres = 2048;
        this.mScreenshotSytem.Allocate( xres, yres );

        let cubeBuffer = this.mCubeBuffers[0];

        let target = this.mScreenshotSytem.GetTarget();
        this.mRenderer.SetRenderTarget( target );

        let program = this.mScreenshotSytem.GetProgram();

        this.mRenderer.AttachShader(program);
        let l1 = this.mRenderer.GetAttribLocation(program, "pos");
        this.mRenderer.SetViewport( [0, 0, xres, yres] );
        this.mRenderer.AttachTextures(1, cubeBuffer.mTexture[ cubeBuffer.mLastRenderDone ], null, null, null);
        this.mRenderer.DrawUnitQuad_XY(l1);
        this.mRenderer.DettachTextures();
        this.mRenderer.SetRenderTarget( null );

        let data = new Float32Array(xres*yres*4);
        this.mRenderer.GetPixelDataRenderTarget( target, data, xres, yres );

        let blob = piExportToEXR(xres, yres, 3, "Float", data );
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "sound" )
    {
        let offset = 0;
        const bits = 16;
        const numChannels = 2;
        let words = new Int16Array(60*pass.mSampleRate*numChannels );

        pass.iRenderSound( new Date(), function(off, data, numSamples)
                                         {
                                            for( let i=0; i<numSamples; i++ )
                                            {
                                                words[offset++] = (data[4*i+0]+256.0*data[4*i+1]) - 32767;
                                                words[offset++] = (data[4*i+2]+256.0*data[4*i+3]) - 32767;
                                            }
                                         }
                                     );

        let blob = piExportToWAV( 60*pass.mSampleRate, pass.mSampleRate, bits, numChannels, words);

        piTriggerDownload("sound.wav", blob);
    }    
}

Effect.prototype.ResizeBuffers = function(xres, yres)
{
    for (let i=0; i<this.mMaxBuffers; i++ )
    {
        this.ResizeBuffer(i, xres, yres, true);
    }
}

Effect.prototype.IsEnabledVR = function ()
{
    if (this.mRenderingStereo) return true;
    return false;
}

Effect.prototype.EnableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( this.mRenderingStereo ) return;

    this.mRenderingStereo = true;
    this.mWebVR.Enable();
}

Effect.prototype.DisableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( !this.mRenderingStereo ) return;

    this.mRenderingStereo = false;
    this.mWebVR.Disable();
}

Effect.prototype.GetTexture = function( passid, slot ) { return this.mPasses[passid].GetTexture( slot ); }
Effect.prototype.NewTexture = function (passid, slot, url) { return this.mPasses[passid].NewTexture( this.mAudioContext, slot, url, this.mBuffers, this.mCubeBuffers, this.mKeyboard ); }
Effect.prototype.SetOutputs = function( passid, slot, url ) { this.mPasses[passid].SetOutputs( slot, url ); }
Effect.prototype.SetOutputsByBufferID = function( passid, slot, id ) { this.mPasses[passid].SetOutputsByBufferID( slot, id ); }
Effect.prototype.GetAcceptsLinear = function (passid, slot) { return this.mPasses[passid].GetAcceptsLinear(slot); }
Effect.prototype.GetAcceptsMipmapping = function (passid, slot) { return this.mPasses[passid].GetAcceptsMipmapping(slot); }
Effect.prototype.GetAcceptsWrapRepeat = function (passid, slot) { return this.mPasses[passid].GetAcceptsWrapRepeat(slot); }
Effect.prototype.GetAcceptsVFlip = function (passid, slot) { return this.mPasses[passid].GetAcceptsVFlip(slot); }
Effect.prototype.SetSamplerFilter = function (passid, slot, str) { this.mPasses[passid].SetSamplerFilter(slot, str, this.mBuffers, this.mCubeBuffers); }
Effect.prototype.GetTranslatedShaderSource = function (passid) { return this.mPasses[passid].GetTranslatedShaderSource(); }
Effect.prototype.GetSamplerFilter = function (passid, slot) { return this.mPasses[passid].GetSamplerFilter(slot); }
Effect.prototype.SetSamplerWrap = function (passid, slot, str) { this.mPasses[passid].SetSamplerWrap(slot, str, this.mBuffers); }
Effect.prototype.GetSamplerWrap = function (passid, slot) { return this.mPasses[passid].GetSamplerWrap(slot); }
Effect.prototype.SetSamplerVFlip = function (passid, slot, str) { this.mPasses[passid].SetSamplerVFlip(slot, str); }
Effect.prototype.GetSamplerVFlip = function (passid, slot) { return this.mPasses[passid].GetSamplerVFlip(slot); }

Effect.prototype.GetHeaderSize = function (passid)
{
    return this.mPasses[passid].mHeaderLength + 
           this.mRenderer.GetShaderHeaderLines(1);
}

Effect.prototype.ToggleVolume = function()
{
    this.mForceMuted = !this.mForceMuted;

    // outp
    if (this.mForceMuted)
        this.mGainNode.gain.value = 0.0;
    else
        this.mGainNode.gain.value = 1.0;

    // inp
    let num = this.mPasses.length;
    for( let j=0; j<num; j++ )
    {
        for( let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            if( this.mForceMuted )
                this.mPasses[j].MuteInput( this.mAudioContext, i );
            else
                this.mPasses[j].UnMuteInput( this.mAudioContext, i );
        }
    }

    return this.mForceMuted;
}

Effect.prototype.SetKeyDown = function( passid, k )
{
    if( this.mKeyboard.mData[ k + 0*256 ] == 255 ) return;

    this.mKeyboard.mData[ k + 0*256 ] = 255;
    this.mKeyboard.mData[ k + 1*256 ] = 255;
    this.mKeyboard.mData[ k + 2*256 ] = 255 - this.mKeyboard.mData[ k + 2*256 ];
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }
}

Effect.prototype.SetKeyUp = function( passid, k )
{
    this.mKeyboard.mData[ k + 0*256 ] = 0;
    this.mKeyboard.mData[ k + 1*256 ] = 0;
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }
}

Effect.prototype.StopOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].StopOutput( wa );
    }
}

Effect.prototype.ResumeOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].ResumeOutput( wa );
    }
}

Effect.prototype.PauseInput = function( passid, id )
{
    return this.mPasses[passid].TooglePauseInput( this.mAudioContext, id );
}

Effect.prototype.ToggleMuteInput = function( passid, id )
{
    return this.mPasses[passid].ToggleMuteInput( this.mAudioContext, id );
}

Effect.prototype.RewindInput = function( passid, id )
{
    this.mPasses[passid].RewindInput( this.mAudioContext, id );
}

Effect.prototype.UpdateInputs = function( passid, forceUpdate )
{
   this.mPasses[passid].UpdateInputs( this.mAudioContext, forceUpdate, this.mKeyboard );
}

Effect.prototype.ResetTime = function()
{
    this.mFrame = 0;
    this.mAudioContext.resume()

    let num = this.mPasses.length;
    for( let i=0; i<num; i++ )
    {
        this.mPasses[i].mFrame = 0;
        for( let j=0; j<this.mPasses[i].mInputs.length; j++ )
            this.mPasses[i].RewindInput(this.mAudioContext, j)
    }
}

Effect.prototype.RequestAnimationFrame = function (id)
{
    if (this.mRenderingStereo && this.mWebVR.IsPresenting())
    {
        this.mWebVR.RequestAnimationFrame(id);
    }
    else
    {
        requestAnimFrame(id);
    }
}

Effect.prototype.Paint = function(time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, isPaused)
{
    let wa = this.mAudioContext;
    let da = new Date();
    let vrData = null; if (this.mRenderingStereo) vrData = this.mWebVR.GetData();
    let xres = this.mXres / 1;
    let yres = this.mYres / 1;

    if( this.mFrame===0 )
    {
        for( let i=0; i<this.mMaxBuffers; i++ )
        {
            if( this.mBuffers[i].mTexture[0]!==null )
            {
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[0] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[1] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
				
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[0] );
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[1] );
            }
        }
        for( let i=0; i<this.mMaxCubeBuffers; i++ )
        {
            if( this.mCubeBuffers[i].mTexture[0]!==null )
            {
                for( let face=0; face<6; face++ )
                {
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[0], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[1], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
					this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[0] );
				    this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[1] );
                }
            }
        }
    }

    let num = this.mPasses.length;

    // render sound first
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "sound" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "buffer" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;
        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="buffer" && inp.id === bufferID && inp.mInfo.mSampler.filter === "mipmap")
                {
                    needMipMaps = true;
                    break;
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render cubemap buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "cubemap" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = 0;//assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;

        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="cubemap" )
                {
                    if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0 && inp.mInfo.mSampler.filter === "mipmap" )
                    {
                        needMipMaps = true;
                        break;
                    }
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render image last
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "image" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }   

    // erase keypresses
    for (let k=0; k<256; k++ )
    {
       this.mKeyboard.mData[ k + 1*256 ] = 0;
    }
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    if( this.mRenderingStereo ) this.mWebVR.Finish();

    this.mFrame++;
}

Effect.prototype.NewShader = function( passid, preventCache, onResolve )
{
    let commonSourceCodes = [];
    for (let i=0; i<this.mPasses.length; i++ )
    {
        if( this.mPasses[i].mType==="common")
        {
            commonSourceCodes.push(this.mPasses[i].mSource);
        }
    }

    this.mPasses[passid].NewShader(commonSourceCodes, preventCache, onResolve );
}

Effect.prototype.GetNumPasses = function()
{
    return this.mPasses.length;
}

Effect.prototype.GetNumOfType = function(passtype)
{
    let id = 0;
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType===passtype )
        {
            id++;
        }
    }
    return id;
}

Effect.prototype.GetPassType = function( id ) { return this.mPasses[id].mType; }
Effect.prototype.GetPassName = function( id ) { return this.mPasses[id].mName; }
Effect.prototype.GetCode = function( id ) { return this.mPasses[id].mSource; }
Effect.prototype.SetCode = function( id, source ) { this.mPasses[id].SetCode(source); }
Effect.prototype.GetError = function (id) { return this.mPasses[id].mError; }
Effect.prototype.GetErrorStr = function (id) { return this.mPasses[id].mErrorStr; }
Effect.prototype.GetErrorGlobal = function()
{
    for (let i = 0; i < this.mPasses.length; i++)
    {
        if (this.mPasses[i].mError)
        {
            return true;
        }
    }
    return false;
}

Effect.prototype.Load = function (jobj )
{
    if (jobj.ver !== "0.1")
    {
        console.log("Wrong Format");
        return false;
    }

    let numPasses = jobj.renderpass.length;

    if( numPasses<1 || numPasses>this.mMaxPasses )
    {
        console.log("Corrupted Shader - " + numPasses);
        return false;
    }

    this.mPasses = [];
    for (let j = 0; j < numPasses; j++)
    {
        let rpass = jobj.renderpass[j];

        // skip sound passes if in thumbnail mode
        if( this.mForceMuted && rpass.type === "sound" ) continue;

        let wpass = new EffectPass(this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                   this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode,
                                   this.mProgramDownscale, j, this);

        wpass.Create(rpass.type, this.mAudioContext);

        let numInputs = rpass.inputs.length;

        for (let i = 0; i < 4; i++)
        {
            wpass.NewTexture(this.mAudioContext, i, null, null, null);
        }
        for (let i = 0; i < numInputs; i++)
        {
            let lid  = rpass.inputs[i].channel;
            let styp = rpass.inputs[i].type;
            let sid  = rpass.inputs[i].id;
            let ssrc = rpass.inputs[i].filepath;
            let psrc = rpass.inputs[i].previewfilepath;
            let samp = rpass.inputs[i].sampler;

            wpass.NewTexture(this.mAudioContext, lid, { mType: styp, mID: sid, mSrc: ssrc, mSampler: samp, mPreviewSrc: psrc }, this.mBuffers, this.mCubeBuffers, this.mKeyboard);
        }

        for (let i = 0; i < 4; i++)
        {
            wpass.SetOutputs(i, null);
        }

        let numOutputs = rpass.outputs.length;
        for (let i = 0; i < numOutputs; i++)
        {
            let outputID = rpass.outputs[i].id;
            let outputCH = rpass.outputs[i].channel;
            wpass.SetOutputs(outputCH, outputID);
        }

        // create some hardcoded names. This should come from the DB
        let rpassName = "";
        if (rpass.type === "common" ) rpassName = "Common";
        if (rpass.type === "sound"  ) rpassName = "Sound";
        if (rpass.type === "image"  ) rpassName = "Image";
        if (rpass.type === "buffer") rpassName = "Buffer " + String.fromCharCode(65 + assetID_to_bufferID(wpass.mOutputs[0]));
        if (rpass.type === "cubemap") rpassName = "Cube A";// " + String.fromCharCode(65 + assetID_to_bufferID(this.mPasses[j].mOutputs[0]));
        wpass.SetName(rpassName);
        wpass.SetCode(rpass.code);

        this.mPasses.push(wpass);
    }
    return true;
}

Effect.prototype.CompileSome = function ( passes, preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    for (let j = 0; j < passes.length; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(passes[j], preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < me.mPasses.length; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.Compile = function (preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(j, preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < numPasses; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.GetCompilationTime = function( id )
{
    return this.mPasses[id].GetCompilationTime()/1000.0;
}
Effect.prototype.GetTotalCompilationTime = function()
{
    return this.mCompilationTime/1000.0;
}

Effect.prototype.DestroyPass = function( id )
{
   this.mPasses[id].Destroy( this.mAudioContext );
   this.mPasses.splice(id, 1);
}

Effect.prototype.AddPass = function( passType, passName, onResolve )
{
    let shaderStr = null;

    if( passType==="sound"   ) shaderStr = "vec2 mainSound( int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n}";
    if( passType==="buffer"  ) shaderStr = "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}";
    if( passType==="common"  ) shaderStr = "vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}";
    if( passType==="cubemap" ) shaderStr = "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rayDir;\n\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}";

    let id = this.GetNumPasses();
    this.mPasses[id] = new EffectPass( this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                       this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode, 
                                       this.mProgramDownscale, id, this );

    this.mPasses[id].Create( passType, this.mAudioContext );
    this.mPasses[id].SetName( passName );
    this.mPasses[id].SetCode( shaderStr );
    this.NewShader(id, false, function ()
    {
        onResolve();
    });

    return { mId : id, mShader : shaderStr };
}

// this should be removed once we have MultiPass 2.0 and passes render to arbitrary buffers
Effect.prototype.IsBufferPassUsed = function( bufferID )
{
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType !== "buffer" ) continue;
        if( this.mPasses[j].mOutputs[0] === bufferID_to_assetID(bufferID) ) return true;
    }
    return false;
}

Effect.prototype.Save = function()
{
    var result = {};

    result.ver = "0.1";

    result.renderpass = [];

    let numPasses = this.mPasses.length;
    for (let j=0; j<numPasses; j++ )
    {
        result.renderpass[j] = {};

        result.renderpass[j].outputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            let outputID = this.mPasses[j].mOutputs[i];
            if( outputID===null ) continue;
            result.renderpass[j].outputs.push( { channel: i, id: outputID } );
        }
        result.renderpass[j].inputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            if( this.mPasses[j].mInputs[i]===null ) continue;
            result.renderpass[j].inputs.push( {channel: i,
                                               type    : this.mPasses[j].mInputs[i].mInfo.mType,
                                               id      : this.mPasses[j].mInputs[i].mInfo.mID,
                                               filepath: this.mPasses[j].mInputs[i].mInfo.mSrc,
                                               sampler : this.mPasses[j].mInputs[i].mInfo.mSampler });
        }

        result.renderpass[j].code = this.mPasses[j].mSource;
        result.renderpass[j].name = this.mPasses[j].mName
        result.renderpass[j].description = "";
        result.renderpass[j].type = this.mPasses[j].mType;
    }

    result.flags = this.calcFlags();

    return result;
}

Effect.prototype.calcFlags = function ()
{
    let flagVR = false;
    let flagWebcam = false;
    let flagSoundInput = false;
    let flagSoundOutput = false;
    let flagKeyboard = false;
    let flagMultipass = false;
    let flagMusicStream = false;

    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        let pass = this.mPasses[j];

        if (pass.mType === "sound") flagSoundOutput = true;
        if (pass.mType === "buffer") flagMultipass = true;

        for (let i = 0; i < 4; i++)
        {
            if (pass.mInputs[i] === null) continue;

            if (pass.mInputs[i].mInfo.mType === "webcam") flagWebcam = true;
            else if (pass.mInputs[i].mInfo.mType === "keyboard") flagKeyboard = true;
            else if (pass.mInputs[i].mInfo.mType === "mic") flagSoundInput = true;
            else if (pass.mInputs[i].mInfo.mType === "musicstream") flagMusicStream = true;
        }

        let n1 = pass.mSource.indexOf("mainVR(");
        let n2 = pass.mSource.indexOf("mainVR (");
        if (n1 > 0 || n2 > 0) flagVR = true;
    }

    return {
        mFlagVR: flagVR,
        mFlagWebcam: flagWebcam,
        mFlagSoundInput: flagSoundInput,
        mFlagSoundOutput: flagSoundOutput,
        mFlagKeyboard: flagKeyboard,
        mFlagMultipass: flagMultipass,
        mFlagMusicStream: flagMusicStream
    };
}</script>
    <script>"use strict"

const kMaxCompileTime = 10.0;

function iReportCrash(shaderID)
{
    let req = new XMLHttpRequest();
    req.onload = function ()
    {
        let jsn = req.response;
        if (jsn === null) return;
        if (jsn.result === 0)
        {
            // yep
        }
    };
    req.open("POST", "/shadertoy", true);
    req.responseType = "json";
    req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    req.send( "s=" + shaderID + "&r=2" );
}
</script>
    <script>"use strict"

var gActive = -1;
var mShaders = [];
var gNumCanvases = 0;

function myrefresh( id, slot, img, forceFrame, gui, guiID, renderID, time )
{
    if( mShaders[id].mReady===false ) return;
    if( forceFrame )
    {
        if (mShaders[id].mScreenshot === false)
        {
            mShaders[id].gEffect.Paint(mShaders[id].mTime / 1000.0, 1.0 / 60.0, 60.0, 0, 0, 0, 0, false);
        }
    }
}

function startRendering()
{
    if( gActive<0 ) return;
    if( mShaders[gActive].mReady===false ) return;
    if( mShaders[gActive].mScreenshot===true ) return;

    let time = getRealTime();

    mShaders[gActive].mFPS.Count( time );
    mShaders[gActive].mTime = mShaders[gActive].mTime0 + (time - mShaders[gActive].mTo);
    let dtime = 1000.0/60.0;
    mShaders[gActive].gEffect.Paint( mShaders[gActive].mTime/1000.0, dtime/1000.0, mShaders[gActive].mFPS.GetFPS(), 0,0,0,0, false);

    requestAnimFrame( startRendering );
}

function iLoadAndCompile(jsn, i )
{
    var shaderObj = jsn[i];
    if (shaderObj === null) return;

    var resizeCB = function (xres, yres) { myrefresh(i, 0, null, true, false, 0, -1.0) };
    var crashCB = function () { alert('crash');/*iReportCrash(gShaderIDs[i])*/ };
    mShaders[i].gEffect = new Effect(null, null, mShaders[i].mPreview.mCanvas, myrefresh, i, true, true, resizeCB, crashCB);

    if (!mShaders[i].gEffect.Load(shaderObj)) return;

    mShaders[i].gEffect.Compile(false, function (worked)
    {
        if (worked === true)
        {
            previewShowRender(mShaders[i].mPreview);

            mShaders[i].mScreenshot = false;
            mShaders[i].mReady = true;
            mShaders[i].mTime = 10.0 * 1000.0;
            mShaders[i].mTime0 = 0.0;
            mShaders[i].mTo = 0.0;
            mShaders[i].mFPS = piCreateFPSCounter();
            mShaders[i].mPreview.mCanvas.addEventListener("mouseout", function (ev) { gActive = -1; }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseover", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.add('isVisible'); }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseout", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.remove('isVisible'); }, true);
            mShaders[i].mPreview.mCanvas.addEventListener("mouseover", function (ev)
            {
                let ele = piGetSourceElement(ev);
                if (ele.mId === undefined) return;

                gActive = ele.mId;
                if (!mShaders[gActive].mReady) return;
                let time = getRealTime();
                mShaders[gActive].mTo = time;
                mShaders[gActive].mTime0 = mShaders[gActive].mTime;
                mShaders[gActive].mFPS.Reset(time);

                startRendering();
            }, true);


            /*
            let compilationTime = mShaders[i].gEffect.GetTotalCompilationTime();
            if (compilationTime > kMaxCompileTime)
            {
                iReportCrash(mShaders[i].mShaderID);
            }*/

            myrefresh(i, null, null, true, false, 0, -1.0);
        }
        else
        {
            mShaders[i].mReady = false;
            previewShowError(mShaders[i].mPreview);
        }
    });
};


function iProcessShader( jsn, i )
{
    var shaderObj = jsn[i];
    if( shaderObj===null ) return;

    if ((shaderObj.info.usePreview === 0 && !gUseScreenshots) || (mShaders[i].mPreviewReady !== 1))
    {
        iLoadAndCompile(jsn, i);
    }
    else
    {
        mShaders[i].mScreenshot = true;
        if( shaderObj.info.usePreview === 1 )
            previewShowScreenshot(mShaders[i].mPreview, 1); // comp
        else if (gUseScreenshots)
            previewShowScreenshot(mShaders[i].mPreview, 2); // sett
    }

    if( i<(jsn.length-1) ) setTimeout( function(){iProcessShader(jsn,i+1);}, 10 );
}

function iInitUI(numCanvases, uiCallback, windowTitle)
{
    gNumCanvases = numCanvases;
    document.getElementById("mySearch").focus();

    //-----------------------------------------------------------------
    // window
    //-----------------------------------------------------------------
    if (windowTitle !== null) {
        document.title = windowTitle;
    }

    //-----------------------------------------------------------------
    // ui
    //-----------------------------------------------------------------
    var num = Math.min(gShaders.length, gNumCanvases);

    //var base = document.getElementsByClassName( "searchResult" );

    for (let i = 0; i < gNumCanvases; i++)
    {
        let pv = createPreview(i);

        if (i >= num) {
            previewHide(pv);
            continue;
        }

        let shaderID = gShaders[i].info.id;
        
        if (pv.mUI !== null && uiCallback !== null) {
            pv.mUI.addEventListener('click', function (ev) {
                uiCallback(shaderID);
                ev.preventDefault();
            }, false);
        }
        
        previewShowLoading(pv);
        
        mShaders[i] = {};
        mShaders[i].mShaderID = shaderID;
        mShaders[i].mPreview = pv;
        mShaders[i].mScreenshot = false;
        mShaders[i].mPreview.mLink.href = "/view/" + shaderID;
        mShaders[i].mPreviewReady = 0;
        mShaders[i].mReady = false;
        mShaders[i].gEffect = null;

        previewLoadScreenshot(mShaders[i].mPreview,
            function () { mShaders[i].mPreviewReady = 1; if (mShaders[i].mReady === false) previewShowScreenshot(mShaders[i].mPreview, 0); },
            function () { mShaders[i].mPreviewReady = 2; },
            shaderID);
    }

    if (num <= 0) {
        return;
    }
}

function iInitShaders(jsn)
{
    for (let i = 0; i < jsn.length; i++)
    {
        let shaderObj = jsn[i];
        if (shaderObj === null) continue;
        let inf = shaderObj.info;
        mShaders[i].mPreview.mTextA.textContent = inf.name;
        mShaders[i].mPreview.mTextB.innerHTML = "<a class='user' href='/user/" + htmlEntities(inf.username) + "'>" + htmlEntities(inf.username) + "</a>";
        mShaders[i].mPreview.mTextC.innerHTML = "<img src='/img/themes/" + gThemeName + "/views.png' class='viewsIcon'></img>" + inf.viewed + "    &nbsp;&nbsp;  <img src='/img/themes/" + gThemeName + "/likes.png' class='likesIcon'></img>" + inf.likes;
    }

    setTimeout(function () { iProcessShader(jsn, 0); }, 10);
}

function resultsInitStatic(numCanvases, uiCallback, windowTitle)
{
    iInitUI(numCanvases, uiCallback, windowTitle);

    iInitShaders(gShaders);
}

function resultsInit(numCanvases, uiCallback, windowTitle)
{	
    iInitUI(numCanvases, uiCallback, windowTitle);

    var num = Math.min(gShaderIDs.length, gNumCanvases);

    var mHttpReq = new XMLHttpRequest();

    mHttpReq.abort();

    var str = "{ \"shaders\" : [";
    for( let i=0; i<num; i++ )
    {
         str += "\"" + gShaderIDs[i] + "\"";
         if( i!==(num-1) ) str += ", ";
    }
    str += "] }";

    str = "s=" + encodeURIComponent( str ) + "&nt=0&nl=0&np=0";

    mHttpReq.open( "POST", "/shadertoy", true );
    mHttpReq.responseType = "json";
    mHttpReq.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    mHttpReq.onload = function ()
    {
        let jsn = this.response;
        if( jsn===null )
        {
            console.log( "Could not load shaders" );
            return;
        }

        iInitShaders(jsn);
    }
    mHttpReq.send( str );
}</script>
    <style>
    .shaderPreview
    {
    display: block;
    background-color: #000000;
    background-image: url("/img/loading.gif");
    background-repeat: no-repeat;
    background-position: center;
    padding: 0px;
    margin: 0px;
    border: 0px solid #000000;
    border-radius: 8px;
    width:100%;
    height:100%;
    position: absolute;
    overflow:hidden;
    }

    .previewInfo
    {
    width: 100%;
    left: 0px;
    top: 2px;
    position: relative;
    visibility: hidden;
    }

    .previewCanvas
    {
    left: 0px;
    top: 0px;
    padding: 0px;
    margin: 0px;
    position: absolute;
    cursor: pointer;
    width:100%;
    height:100%;
    border-radius: 8px;
    border: 0px solid #000000;
    backgroundColor: transparent;
visibility: hidden;
opacity:0;
transition: opacity 1.0s ease;
    }

    .previewText
    {
        text-overflow: ellipsis;
    white-space: nowrap;
    padding-right: 1px;
    }

    .previewTextUser
    {
    text-overflow: ellipsis;
    white-space: nowrap;
    padding-left: 3px;
    }

    .previewStats
    {
    padding-right: 1px;
    right: 0px;
    top: 0px;
    position: absolute;
    }

    .previewErrorContainer
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    visibility:hidden;
    }

    .previewErrorMessage
    {
    top:50%;
    position:absolute;
    width:100%;
    text-align:center;
    padding:0;
    margin:auto;
    color:#ff0000;
    font-size:2em;
    font-style:italic;
    }

    .previewNoGLContainter
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    position:absolute;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    pointer-events:none;
    visibility:hidden;
    font-size:2em;
    }

    .previewNoGLMessage
    {
    width:86%;
    height:90%;
    padding-left:7%;
    padding-right:7%;
    padding-top:10%;
    padding-bottom:0px;
    color:#ff0000;
    position:absolute;
    visibility:hidden;
    }

    .previewThumbnailContainer
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    visibility:hidden;
    border-radius:8px;
    border:0px solid #000000;
    }

    .previewThumbnailImage
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    border-radius:8px;
    border:0px solid #000000;
opacity: 0.0;
transition: opacity 1.0s ease;
    }

    .previewThumbnailIcon
    {
    width:64px;
    height:32px;
    left:0px;
    top:0px;
    padding:0px;
    padding-top:12px;
    margin:0px;
    position:absolute;
    color:#ffffff;
    background-color:#ff8020;
    font-weight:bold;
    border-radius:0px 0px 8px 0px;
    text-align:center;
    //visibility:hidden;
    }


    .previewUIContainter
    {
    display: block;
    right:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    //cursor:pointer;
    //pointer-events:none;
    //visibility:hidden;
    }
</style>

<script>
    function previewHide(me)
    {
    me.mBase.style.visibility = "hidden";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";
    }

    function previewShowRender(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "visible";
me.mCanvas.style.opacity = 1.0;
    me.mCanvas.style.borderRadius ="8px;";
//  me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    }

    function previewShowScreenshot(me, message)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "visible";
me.mThumbnailImg.style.opacity = 1.0;
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    me.mThumbnailWar1.style.visibility = (message===1)?"visible":"hidden";
    me.mThumbnailWar2.style.visibility = (message===2)?"visible":"hidden";
    }

    function previewShowLoading(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";

    me.mLink.style.visibility = "visible";
    me.mBase.style.backgroundColor = "#ff0000;"
    me.mCont.style.visibility = "visible";
    }

    function previewShowNoWebGL(me, shaderID)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "visible";
    me.mError.style.visibility = "visible";
    me.mThumbnailImgNoWebGL.onerror = function(ev) 
                                      { 
                                            me.mThumbnailImgNoWebGL.style.visibility="hidden"; 
                                            me.mMessageNoWebGL.style.visibility="visible"; 
                                      };
    me.mThumbnailImgNoWebGL.src = "/media/shaders/" + shaderID + ".jpg";
    }

    function previewShowError(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "visible";
    me.mCont.style.visibility = "visible";
    }

    function previewLoadScreenshot( me, cbSuccess, cbError, shaderID )
    {
    var url = "/media/shaders/" + shaderID + ".jpg";
    me.mThumbnailImg.onload = cbSuccess;
    me.mThumbnailImg.onerror = function(ev) { cbError(); };
    me.mThumbnailImg.src = url;
    }
        
    function createPreview(id)
    {
        var bar = document.getElementById( "Preview_"+id+"_Canvas" );
        bar.width = bar.offsetWidth;
        bar.height = bar.offsetHeight;
        bar.mId = id;

        return { mBase: document.getElementById( "Preview_"+id+"_Container" ),
        mLink: document.getElementById( "Preview_"+id+"_Link" ),
        mCanvas: bar,
        mCont: document.getElementById( "Preview_"+id+"_Info" ),
        mTextA: document.getElementById( "Preview_"+id+"_Text" ),
        mTextB: document.getElementById( "Preview_"+id+"_TextUser" ),
        mTextC: document.getElementById( "Preview_"+id+"_Stats" ),
        mNoWebGL: document.getElementById( "Preview_"+id+"_NoWebGL" ),
        mError: document.getElementById( "Preview_"+id+"_Error" ),
        mCanvas2D: document.getElementById( "Preview_"+id+"_Thumnail" ),
        mThumbnailImg: document.getElementById( "Preview_"+id+"_ThumnailImage" ),
        mThumbnailWar1: document.getElementById( "Preview_"+id+"_ThumnailWarning1" ),
        mThumbnailWar2: document.getElementById( "Preview_"+id+"_ThumnailWarning2" ),
        mThumbnailImgNoWebGL: document.getElementById( "Preview_"+id+"_ThumnailImageNoWebGL" ),
        mMessageNoWebGL: document.getElementById( "Preview_"+id+"_MessageNoWebGL"),
        mUI: document.getElementById( "Preview_"+id+"_UI" )
        };
    }
</script>

    <style>

    div#shaderGrid
    {
        width:100%;
        padding:0px;
        margin:0px;
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        grid-template-rows: repeat(3, 1fr);
        grid-column-gap: 64px;
        grid-row-gap: 24px;
    }
    .searchResult
    {
        margin: 0px;
        padding: 0px;
        width: 100%;
    }
    .searchResultContainer
    {
        width: 100%;
        padding-bottom:56.25%;
        height: 0;
        position: relative;
    }
    .navigation
    {
        display:flex;
        align-items:center;
    }
    div#navBottom
    {
        display:none;
        justify-content:center;
    }
    a.pageButtons, .pageButtonsCurrent
    {
        border-style: solid;
        border-width: 1px;
        border-color: #808080;
        text-align: center;
        vertical-align: middle;
        margin-left: 12px;
        display: inline-block;
        border-radius: 4px;
		font-weight:bold;
        cursor: pointer;
        padding-bottom:5px;
        padding-top:4px;
        padding-left: 8px;
        padding-right: 8px;
        margin:8px;
    }
    a.pageButtons
    {
        text-decoration: none;
        -moz-transition:    background-color 0.15s linear, color 0.15s linear;
        -webkit-transition: background-color 0.15s linear, color 0.15s linear;
        transition:         background-color 0.15s linear, color 0.15s linear;
    }
    a.pageButtons:hover
    {
      background-color:#808080;
      color : #ff8020;
    }
    .pageButtonsCurrent
    {
        background-color: #808080;
        color:#000000;
    }
    div#controls
    {
        width:100%;
        padding-top:16px;
        padding-bottom:16px;
        display:flex;
        justify-content:space-between; 
        flex-wrap:wrap;
    }
    div#controls > div
    {
        display:inline-flex;
    }
    .controlOptions
    {
        display:inline-block;
    }

    /* ----------------------- media resolutions ------------------------ */

    @media screen and (max-width:799px) 
    {
        div#shaderGrid  { grid-template-columns: 1fr; grid-template-rows: repeat(12, 1fr); grid-column-gap: 0px; grid-row-gap: 16px; }
        div#controls
        {
            width:100%;
            display:flex;
            justify-content:flex-start; 
            flex-wrap:wrap;
        }
        div#controls > div
        {
            display:inline-flex;
            width:100%;
            margin-left: 0px;
            margin-right: 0px;
            padding-bottom:16px;
        }
        div#navBottom
        {
            display: flex;
        }
    }
    
    </style>
    <script>
    var gShaders=[{"ver":"0.1","info":{"id":"XdcGW2","date":"1452110960","viewed":13301,"name":"strange fluid","username":"capsadmin","description":"draw fluid with mouse","likes":209,"published":1,"flags":32,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float val = texture(iChannel0, fragCoord\/iResolution.xy).r;\n \n   \t\/\/{fragColor = vec4(val,val,val,1.0); return;}\n    fragColor = vec4(val, val, val, 1.0);\n        \n    vec4 color = pow(vec4(cos(val), tan(val), sin(val), 1.0) * 0.5 + 0.5, vec4(0.5));\n    \n    \/\/ code below taken from\n    \/\/https:\/\/www.shadertoy.com\/view\/Xsd3DB\n    \n    vec2 q = fragCoord.xy\/iResolution.xy;\n    \n    vec3 e = vec3(vec2(1.0)\/iResolution.xy,0.);\n    float p10 = texture(iChannel0, q-e.zy).x;\n    float p01 = texture(iChannel0, q-e.xz).x;\n    float p21 = texture(iChannel0, q+e.xz).x;\n    float p12 = texture(iChannel0, q+e.zy).x;\n        \n    vec3 grad = normalize(vec3(p21 - p01, p12 - p10, 1.));\n    vec3 light = normalize(vec3(.2,-.25,.7));\n    float diffuse = dot(grad,light);\n    float spec = pow(max(0.,-reflect(light,grad).z),32.0);\n    \n    fragColor = (color * diffuse) + spec;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float pi = 3.1415;\nconst float pi2 = pi\/2.0;\n\nfloat random()\n{\n\treturn fract(sin(dot(gl_FragCoord.xy, vec2(12.9898,78.233))) * 43758.5453);  \n}\n\nvec4 get_pixel(float x_offset, float y_offset)\n{\n\treturn texture(iChannel0, (gl_FragCoord.xy \/ iResolution.xy) + (vec2(x_offset, y_offset) \/ iResolution.xy));\n}\n\nfloat step_simulation()\n{\n\tfloat val = get_pixel(0.0, 0.0).r;\n    \n    val += random()*val*0.15; \/\/ errosion\n    \n  \tval = get_pixel(\n    \tsin(get_pixel(val, 0.0).r  - get_pixel(-val, 0.0) + pi).r  * val * 0.4, \n        cos(get_pixel(0.0, -val).r - get_pixel(0.0 , val) - pi2).r * val * 0.4\n   \t).r;\n    \n    val *= 1.0001;\n    \n    return val;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    float val = step_simulation();\n \n    if(iFrame == 0)\n        val = \n        \trandom()*length(iResolution.xy)\/100.0 + \n        \tsmoothstep(length(iResolution.xy)\/2.0, 0.5, length(iResolution.xy * 0.5 - fragCoord.xy))*25.0;\n    \n    if (iMouse.z > 0.0) \n        val += smoothstep(length(iResolution.xy)\/10.0, 0.5, length(iMouse.xy - fragCoord.xy));\n        \n    fragColor.r = val;\n}","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"Xlf3zl","date":"1424149610","viewed":13296,"name":"Parametric graph by curvature","username":"iq","description":"An attempt to find a way to compute the distance to a parametric curve map(t) that is better than linear search, based on curvature. An intuition really, need to think about this deeply. Inspired by eiffie's shaders.","likes":79,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[],"code":"\/\/ Created by inigo quilez - iq\/2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\/\/ An attempt to find a way to compute the distance to a parametric curve p(t) that is\n\/\/ better than linear search. In this case, I'm trying to measure curvature to concentrate\n\/\/ the samples in highly curved areas.\n\/\/\n\/\/ The shader switches between the linear search and the optimized version, showing how for the\n\/\/ same amount of steps \/ complexity, the new method produces better results.\n\/\/\n\/\/ I need to work on this more, I am not sure yet the right way to do this really, all I got was\n\/\/ an intuition inspired by eiffie's shader https:\/\/www.shadertoy.com\/view\/4tfGRl.\\\n\n\nvec2 map(float t)\n{\n    return 0.85*cos( t + vec2(0.0,1.0) )*(0.6+0.4*cos(t*7.0+vec2(0.0,1.0)));\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdSqSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p - a, ba = b - a;\n\treturn dot2( pa - ba*clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 ) );\n}\n\nfloat graph( vec2 p, bool doOptimized )\n{\n    float h = doOptimized ? 0.05 : 6.2831\/70.0;\n\tfloat t = 0.0;\n    \n    vec2  a = map(t);\n    float d = dot2( p - a );\n    \n    t += h;\n    for( int i=0; i<70; i++ )\n    {\n        vec2  b = map(t);\n        d = min( d, sdSqSegment( p, a, b ) );\n        \n\t\tt += (doOptimized) ? clamp( 0.026*length(a-p)\/length(a-b), 0.02, 0.1 ) : h;\n        a = b;\n\t}\n    \n\treturn sqrt(d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy+2.0*fragCoord.xy)\/iResolution.y;\n    \n    bool doOptimized = sin(2.0*iTime) > 0.0;\n\n    float d = graph( p, doOptimized );\n        \n    vec3 col = vec3(0.9);\n    col *= 1.0 - 0.03*smoothstep(-0.3,0.3,sin( 120.0*d ));\n    col *= smoothstep(0.0, 0.01, d );\n    col *= 1.0 - 0.1*dot(p,p);\n\n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"lsGGDd","date":"1457224940","viewed":13295,"name":"Load Custom Textures","username":"AntoineC","description":"A simple method to load custom image textures in Shadertoy. Read the instructions in the code. Let me know in the comments if it works on your system and browser...","likes":124,"published":1,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ ----------------------------------------------------------------------------------------\n\/\/\t\"Load Custom Textures\" by Antoine Clappier - March 2015\n\/\/\n\/\/\tLicensed under a Creative Commons Attribution-ShareAlike 4.0 International License\n\/\/\thttp:\/\/creativecommons.org\/licenses\/by-sa\/4.0\/\n\/\/ ----------------------------------------------------------------------------------------\n\n\/\/ Image credits:\n\/\/  Nasa, http:\/\/visibleearth.nasa.gov\/\n\n\n\/*\n\nA simple method to load custom image textures in Shadertoy!\n-----------------------------------------------------------\n\nThe idea is to call directly the SetTexture function found in Shadertoy js code.\n\nHere is how to loads the three textures needed for this shader:\n - Open the javascript console of your browser:\n\t\t\t\t   Mac      \/     Windows\n\tChrome:  cmd + opt + J  \/  ctrl + shift J\n\tFirefox: cmd + opt + K  \/  ctrl + shift K\n    IE:          na         \/  F12   \n\n- Then copy the following lines in the console to load custom 2048x2048 textures:\n\ngShaderToy.SetTexture(0, {mSrc:'https:\/\/dl.dropboxusercontent.com\/s\/88u2uo8dxdmgzxo\/world2.jpg?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\ngShaderToy.SetTexture(1, {mSrc:'https:\/\/dl.dropboxusercontent.com\/s\/5rdhhnvnr5mochq\/cloud2.jpg?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\ngShaderToy.SetTexture(2, {mSrc:'https:\/\/dl.dropboxusercontent.com\/s\/ojl5zoxgbdn5w5s\/light2.jpg?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n\n- Or, the following lines for 1024x1024 textures:\n\ngShaderToy.SetTexture(0, {mSrc:'https:\/\/dl.dropboxusercontent.com\/s\/0j4q7p4x0upj40q\/world1.jpg?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\ngShaderToy.SetTexture(1, {mSrc:'https:\/\/dl.dropboxusercontent.com\/s\/26xr0l2ly68xgzh\/cloud1.jpg?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\ngShaderToy.SetTexture(2, {mSrc:'https:\/\/dl.dropboxusercontent.com\/s\/b67udjdsw4gzf99\/light1.jpg?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n\n- hit return to execute and load the textures.\n\n\nUsing your own images:\n - The first argument of gShaderToy.SetTexture() is the iChannel index from 0 to 3\n - The second argument defines the url and additional parameters of the texture.\n - Your images must be hosted on a server (such as Dropbox) that allows direct link \n   from a different domain in javascript. Otherwise, you will get an error message:\n   \"'example.com has been blocked from loading by Cross-Origin Resource Sharing policy\"\n\n*\/\n\n\n\n\n#define Pi 3.14159265359\n#define d2r(a) ((a)*180.0\/Pi)\n#define RGB(r,g,b) pow(vec3(float(r), float(g), float(b))\/255.0, vec3(2.22))\n\n#define R0 1.0000\t\/\/ Nomralized Earth radius (6360 km)\n#define R1 1.0094\t\/\/ Atmosphere radius (6420 km) \n\nvec3 Render(in vec2 uv)\n{\n    vec3 Color = vec3(0.0);\n    float t = 1.0*iTime;\n\n    \/\/ Sun:\n    vec3 L0 = vec3(cos(0.1*t), 0.0, sin(0.1*t));\n    float cs = cos(d2r(90.0 + 23.4)), sn = sin(d2r(90.0 + 23.4));\n    vec3 LightDir = vec3(cs*L0.x + sn*L0.y, cs*L0.y - sn*L0.x, L0.z);\n\n    vec2 SunC = -5.0*LightDir.xy\/LightDir.z - uv;\n    float Halo = max(0.0, dot(LightDir, normalize(vec3(uv.x, uv.y, -5.0))));\n\tfloat SunRay = pow(texture(iChannel1, vec2(0.1*t, atan(SunC.x,SunC.y))).xyz, vec3(2.22)).x;\n    float Sun = 0.05*(1.0 + SunRay)*pow(Halo, 1000.0)*smoothstep(0.85, 1.3, length(SunC+uv));\n   \n    \/\/ Sphere hit:\n    float z = 1.0 - dot(uv, uv);\n    if(z < 0.0)\n    {\n        Sun += 1.5*pow(Halo, 10000.0);\n        return Sun*RGB(255,250,230);\n    }\n    \n    \/\/ Intersection:\n    vec3 Normal     = vec3(uv.x, uv.y, sqrt(z));\n    vec3 Reflection = reflect(vec3(0.0, 0.0, 1.0), Normal);\n\n\n    \/\/ Textures:\n\tfloat U = 1.0-atan(Normal.z, Normal.x) \/ (2.0*Pi);\n\tfloat V = 1.0-(atan(length(Normal.xz), Normal.y)) \/ Pi;\n \tvec3 Ground = pow(texture(iChannel0, vec2(U-t\/80.0, V)).xyz, vec3(2.22));\n\tvec3 Cloud  = pow(texture(iChannel1, vec2(U-t\/75.0, V)).xyz, vec3(2.22));\n\tvec3 Cloud2 = pow(texture(iChannel1, vec2(U-t\/75.0+0.001, V)).xyz, vec3(2.22));\n\tvec3 KsMap  = pow(texture(iChannel1, vec2( -t\/200.0, 0.8)).xyz, vec3(2.22));\n\tvec3 Night  = pow(texture(iChannel2, vec2(U-t\/80.0, V)).xyz, vec3(2.22));\n\t\n    \/\/ Shading\n\tfloat Diffuse     = max(0.0, dot(Normal, LightDir));\n\tfloat Specular    = max(0.0, dot(-Reflection, LightDir));\n    float Scatter     = 4.0*pow((sqrt(R1 - dot(uv, uv)) - Normal.z) \/ sqrt(R1-R0), 1.35);\n    float Extinct     = pow(1.0 - Diffuse, 4.0);\n    float Sea         = smoothstep(1.0, 0.0, 100.0*length(Ground - RGB(2,5,20)));\n    float Shadow      = 1.0 - pow(Cloud2.x, 0.2);\n    \n    vec3 Light = mix(vec3(1.0), RGB(255, 150, 40), Extinct);\n \n    Color = Shadow*(Ground + 0.8*Sea*RGB(19,35,60));\n    Color = mix(Color, vec3(1.0), 2.0*Cloud);\n    Color *= Light*Diffuse;\n    Color += 2.0*Light*Diffuse*(0.3 + 0.7*KsMap.x)*mix(0.03, 0.4, Sea)*pow(Specular, (0.8 + 0.2*KsMap.x)*mix(9.0, 200.0, Sea));\n    Color += pow(max(0.0, dot(Normal, -LightDir)), 2.0)*Night*(1.0-pow(Cloud.x, 0.2));\n    Color *= mix(vec3(1.0), RGB(255-58,255-72,255-90), 1.0*Scatter);\n    Color += 4.0*Diffuse*(1.0 + Sea)*Scatter*RGB(58,72,90);\n\n    Color += Sun*RGB(255,250,230);\n    \n    return Color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 In )\n{\n\tvec2 uv = (2.0*In.xy - iResolution.xy) \/ iResolution.y;\n    vec3 Color = pow(Render(1.05*uv),  vec3(0.45));\n\tfragColor = vec4(Color, 1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"Xl2XWt","date":"1447366097","viewed":13289,"name":"SDF Tutorial 1 : box & balloon","username":"cabbibo","description":"Building a tutorial for shader toy that is understandable by mere mortals like me :)\nMore Tutorials coming soon to http:\/\/tree.is \n\nPlease comment for questions, concerns, or improvments!\nAlso, hit me up @cabbibo, or @vrtree to chat about anything!","likes":145,"published":1,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[],"code":"\/*\n\n    CC0 1.0\n\n\t@vrtree\n\twho@tree.is\n\thttp:\/\/tree.is\n\t\n\t\n\tI dont know if this is going to work, or be interesting, \n\tor even understandable, But hey! Why not try!\n\n\tTo start, get inspired by some MAGICAL creations made by raytracing:\n\n\tVolcanic by IQ\n\thttps:\/\/www.shadertoy.com\/view\/XsX3RB\n\n\tRemnant X by Dave_Hoskins ( Audio Autoplay warnings )\n\thttps:\/\/www.shadertoy.com\/view\/4sjSW1\n\n\tCloud Ten by Nimitz\n\thttps:\/\/www.shadertoy.com\/view\/XtS3DD\n\n\tSpectacles by MEEEEEE\n    https:\/\/www.shadertoy.com\/view\/4lBXWt\n\n\t[2TC 15] Mystery Mountains by Dave_Hoskins\n\thttps:\/\/www.shadertoy.com\/view\/llsGW7\n\n\tRaytracing graphics is kinda like baking cakes. \n\t\n\tI want yall to first see how magical \n\tthe cake can be before trying to learn how to make it, because the thing we \n\tmake at first isn't going to be one of those crazy 10 story wedding cakes. its just\n\tgoing to be some burnt sugar bread. \n\t\n\tMaking art using code can be so fufilling, and so infinite, but to get there you \n\tneed to learn some techniques that might not seem that inspiring. To bake a cake,\n\tyou first need to turn on an oven, and need to know what an oven even is. In this\n\ttutorial we are going to be learning how to make the oven, how to turn it on, \n\tand how to mix ingredients. as you can see on our left, our cake isn't very pretty\n\tbut it is a cake. and thats pretty crazy for just one tutorial!\n\n\tOnce you have gone through this tutorial, you can see a 'minimized' version\n\there: https:\/\/www.shadertoy.com\/view\/Xt2XDt\n\n\twhere I've rewritten it using the varibles and functions that\n\tare used alot throughout shadertoy. The inspiration examples above\n\tprobably seem completely insane, because of all the single letter variable\n\tnames, but keep in mind, that they all start with most of the same ingredients \n\tand overn that we will learn about right now!\n\n\t\n\tI've tried to break up the code into 'sections'\n\twhich have the 'SECTION 'BLAH'' label above them. Not sure\n\tif thats gonna help or not, but please leave comments \n\tif you think something works or doesn't work, slash you \n\thave any questions!!!\n\n\tor contact me at @vrtree || @cabbibo\n\n\n\tCheat sheet for vectors:\n\n    x = left \/ right\n\ty = up \/ down\n\tz = forwards \/ backwards\n\n\talso, for vectors labeled 'color'\n\n\tx = red\n\ty = green\n\tz = blue\n\n\n\n\t\/\/---------------------------------------------------\n    \/\/ SECTION 'A' : ONE PROGRAM FOR EVERY PIXEL!\n    \/\/---------------------------------------------------\n\n\tThe best metaphor that I can think of for raytracing is\n\tthat the rectangle to our left is actually just a small window\n\tinto a fantastic world. We need to describe that world, \n\tso that we can see it. BUT HOW ?!?!?!\n\n\tWhat we are doing below is describing what color each pixel\n\tof the window is, however because of the way that shader \n\tprograms work, we need to give the same instruction to every\n\tsingle PIXEL ( or in shadertoy terms, FRAGMENT )\n\tin the window. This is where the term SIMD comes \n\tfrom : Same Instruction Multiple Data \n\n\tIn this case, the same instruction is the program below,\n\tand the multiple data is the marvelous little piece of magic\n\tcalled 'fragCoord' which is just the position of the pixel in \n\twindow. lets rename some things to look prettier.\n\n\t\n\t\/\/---------------------------------------------------\n    \/\/ SECTION 'B' : BUILDING THE WINDOW\n    \/\/---------------------------------------------------\n\n\tIf you think about what happens with an actual window, you \n\tcan begin to get an idea of how the magic of raytracing works\n\tbasically a bunch of rays come from the sun ( and or other\n\tlight sources ) , bounce around a bunch ( or a little ), and\n\teventually make it through the window, and into our eyes.\n\n\tNow the number of rays are masssiveeee that come from the sun\n\tand alot of them that are bouncing around, will end up going \n\tdirections that aren't even close to the window, or maybe\n\twill hit the wall instead of the window. \n\n\tWe only care about the rays that go through the window \n\tand make it to our eyeballs!\n\n\tThis means that we can be a bit intelligent. Instead of \n\tfiguring out the rays that come from the sun and bounce around\n\tlets start with out eyes, and work backwards!!!!\n\n\n\t\/\/---------------------------------------------------\n    \/\/ SECTION 'C' : NAVIGATING THE WORLD\n    \/\/---------------------------------------------------\n\n\tAfter setting up all the neccesary ray information,\n\twe FINALLY get to start building the scene. Up to this point, \n\twe've only built up the window, and the rays that go from our\n\teyes through the window, but now we need to describe to the rays\n    if they hit anything and what they hit!\n\n\n\tNow this part has some pretty scary code in it ( whenever I look\n\tat it at least, my eyes glaze over ), so feel free to skip over \n\tthe checkRayHit function. I tried to explain it as best as I could\n\tdown below, and you might want to come back to it after going\n\tthrought the rest of the tutorial, but the important thing to\n\tremember is the following:\n\n\n\tThese 'rays' that we've been talking about will move through the\n\tscene along their direction. They do this iteratively, and at each\n\tstep will basically ask the question :\n\t\n\t'HOW CLOSE AM I TO THINGS IN THE WORLD???'\n\n\tbecause well, rays are lonely, and want to be closer to things in\n\tthe world. We provide them an answer to that question using our\n\tdescription of the world, and they use this information to tell\n\tthem how much further along their path they should move. If the\n\tanswer to the question is:\n\t\t\n\t'Lovely little ray, you are actually touching a thing in the world!'\n\t\n\tWe know what that the ray hit something, and can begin with our next\n\tstep!\n\t\n\tThe tricky part about this is that we have to as accuratly as \n\tpossible provide them an answer to their question 'how close??!!'\n\t\n\n\n\t\/\/--------------------------------------------------------------\n    \/\/ SECTION 'D' : MAPPING THE WORLD , AKA 'SDFS ARE AWESOME!!!!'\n    \/\/--------------------------------------------------------------\n\n\tTo answer the above concept, we are going to use this magical \n\tconcept called: \n\n\t'Signed Distance Fields'\n\t-----------------------\n\n\tThese things are the best, and very basically can be describe as \n\ta function that takes in a position, and feeds back a value of\n\thow close you are to a thing. If the value of this distance is negative\n\tyou are inside the thing, if it is positive, you are outside the thing\n\tand if its 0 you are at the surface of the thing! This positive or negative\n\tgives us the 'Signed' in 'Signed Distance Field'\n\n\tFor a super intensive description of many of the SDFs out there\n\tcheck out Inigo Quilez's site:\n\n\thttps:\/\/iquilezles.org\/articles\/distfunctions\n\n\tAlso, if you want a deep dive into why these functions are the \n\tultimate magic, check out this crazy paper by the geniouses\n\tover at Media Molecule about their new game: 'DREAMS' \n\n    http:\/\/media.lolrus.mediamolecule.com\/AlexEvans_SIGGRAPH-2015.pdf\n\n\tNeedless to say, these lil puppies are super amazing, and are\n\there to free us from the tyranny of polygons.\n\n\n\t---------\n\n\tWe are going to put all of our SDFs into a single function called\n\t\n\t'mapTheWorld' \n\t\n\twhich will take in a position, and feed back two values.\n\tThe first value is the Distance of Signed Distance Field, and the\n\tsecond value will tell us what we are closest too, so that if \n\twe actually hit something, we can tell what it is. We will denote this\n\tby an 'ID' value.\n\n\tThe hardest part for me to wrap my head around for this was the fact that\n\tthese fields do not just describe where the surface of an object is,\n\tthey actually describe how far you are from the object from ANYWHERE \n\tin the world. \n\n\tFor example, if I was hitting a round ballon ( AKA a sphere :) ) \n\tI wouldn't just know if I was on the surface of the ballon, I would have\n\tto know how close I was to the balloon from anywhere in space.\n\n\tCheck out the 'TAG : BALLOON' in the mapTheWorld function for more detail :)\n\n\tI've also made a function for a box, that is slightly more complex, and to be\n\thonest, I don't exactly understand the math of it, but the beauty of programming\n\tis that someone else ( AKA Inigo ) does, and I can steal his knowledge, just by\n\tlooking at the functions from his website!\n\t\n\t---------\n\n\tOne of the magical properties of SDFs is how easily they can be combined \n\tcontorted, and manipulated. They are just these lil functions that take \n\tin a position and give back a distance value, so we can do things like play with the\n\tinput position, play with the output distance value, or just about anything\n\telse.\n\n\tWe'll start by combining two SDFs by asking the simple question\n\t\n\t'Which thing am I closer to?'\n\t\n\twhich is as simple as a '>' because we already know exactly how close we are \n\tto each thing!\n\n\tcheck out 'TAG : WHICH AM I CLOSER TO?'  for more enough\n\n\tWe use these function to create a map of the world for the rays to navigate,\n\tand than pass that map to the checkRayHit, which propates the rays throughout\n\tthe world and tells us what they hit.\n\n\tOnce they know that, we can FINALLY do our last step:\n\n\n\t\/\/--------------------------------------------------------------\n    \/\/ SECTION 'E' : COLORING THE WORLD!\n    \/\/--------------------------------------------------------------\n\n\tAt the end of our checkRayHit function we return a vec2 with two values:\n\t.x is the distance that our ray traveled before hitting\n\t.y is the ID of the thing that we hit.\n\n\tif .y is less that 0.0 that means that our ray went as far as we allowed it\n\tto go without hitting anything. thats one lonely ray :(\n\t\n\thowever, that doesn't mean that the ray didn't hit anything. It just meant \n\tthat it is part of the background. \n\t\n\tThanks little ray! \n\tYou told us important information about our scene, \n\tand your hard work is helping to create the world!\n\n\tWe can get reallly crazy with how we color the background of the scene,\n\tbut for this tutorial lets just keep it black, because who doesn't love \n\tthe void.\n\n\twe will use the function 'doBackgroundColor' to accomplish this task!\n\n\tThat tells us about the background, but what if .y is greater than 0.0?\n\tthen we get to make some stuff in the scene!\n\n\tif the ID is equal to balloon id, then we 'doBalloonColor'\n\tand if the ID is equal to the box , then we 'doBoxColor'\n\t\n\tThis is all that we need if we want to color simple solid objects,\n\tbut what if we want to add some shading, by doing what we originally\n\ttalked about, that is, following the ray to the sun?\n\n\tFor this first tutorial, we will keep it to a very naive approach,\n\tbut once you get the basics of sections A - D, we can get SUPER crazy\n\twith this 'color' the world section. \n\n\tFor example, we could reflect the\n\tray off the surface, and than repeat the checkRayHit with this new information\n\tcontinuing to follow this ray through more and more of the world. we could \n\trepeat this process again and again, and even though our gpu would hate us\n\twe could continue bouncing around until we got to a light source! \n\n\tIn a later tutorial we will do exactly this, but for now, \n\twe are going to do 1 simple task:\n\n\n\tSee how much the surface that we hit, faces the sun.\n\n\n\tto do that we need to do 2 things. \n\n\tFirst, determine which way the surface faces\n\tSecond, determine which way rays go from the surface to get to the sun\n\n\t1) To determine the way that the surface faces, we will use a function called\n\t'getNormalOfSurface' This function will either make 100% sense, or 0% sense\n\tdepending on how often you have played with fields, but it made 0% sense to me\n\tfor many years, so don't worry if you don't get it! Whats important is that\n\tit gives us the direction that the surface faces, which we call its 'Normal'\n\tYou can think of it as a vector that is perpendicular to the surface at a specific point\n\t\n\tSo that it is easier to understand what this value is, we are actually going to color our\n\tbox based on this value. We will map the X value of the normal to red, the Y value of the \n\tnormal to green and the Z value of the normal to blue. You can see this more in the \n\t'doBoxColor' function\n\n\t\n\t2) To get the direction the rays go to get to the sun, we just need to subtract the sun\n\tposition from the position of where we hit. This will provide us a direction from the sun\n\tto the position. Look inside the doBalloonColor to see this calculation happen.\n\tthis will give us the direction of the rays from the sun to the surface!\n\n\n\tNow that we have these 2 pieces of information, the last thing we need to do is see \n\thow much the two vectors ( the normal and the light direction ) 'Face' each other. \n\t\n\tthat word 'Face', might not make much sense in this context, but think about it this way.\n\n\tIf you have a table, and a light above the table, the top of the table will 'Face',\n\tthe light, and the bottom of the table will 'Face' away from the light. The surface\n\tthat 'Faces' the light will get hit by the rays from the light, while the surface\n\tthat 'Faces' away from the light will be totally dark!\n\n\tso how do we get this 'Face' value ( pun intended :p ) ?\n\n\tThere is a magical function called a 'dot product' which does exactly this. you \n\tcan read more here:\n\n\thttps:\/\/en.wikipedia.org\/wiki\/Dot_product\n\n\tbasically this function takes in 2 vectors, and feeds back a value from -1 -> 1.\n\n\tif the value is -1 , the two vectors face in exact opposite directions, and if\n\tthe value is 1 , the two vectors face in exactly the same direction. if the value is\n\t0, than they are perpendicular!\n\n\tBy using the dot product, we take get the ballon's 'Face' value and color it depending\n\ton this value!\n\n\tcheck out the doBallonColor to see all this craziness in action\n\n\n\t\/\/--------------------------------------------------------------\n    \/\/ SECTION 'F' : Wrapping up\n    \/\/--------------------------------------------------------------\n\n\tWhat a journey it has been. Remember back when we were talking about\n\tsending rays through the window? Remember them moving all through the \n\tworld trying to be closer to things?\n\n\tSo much has happened, and at the end of that journey, we got a color for each ray!\n\n\tnow all we need to do is output that color onto the screen , which is a single call,\n\tand we've made our world.\n\n\n\tI know this stuff might seem too dry or too complex at times, too confusing, \n\ttoo frustrating, but I promise, if you stick with it, you'll soon be making some of the\n\tother magical structures you see throughout the rest of this site.\n\n\tI'll be trying to do some more of these tutorials, and you'll see that VERY\n\tquickly, you get from this hideous monstrosity to our left, to marvelous worlds\n\tfilled with lights, colors, and love.\n\n\tThanks for staying around, and please contact me:\n\n\t@vrtree , @cabbibo with questions, concerns , and improvments. Or just comment!\n\n\n\n*\/\n\n\n\n\/\/---------------------------------------------------\n\/\/ SECTION 'B' : BUILDING THE WINDOW\n\/\/---------------------------------------------------\n\n\/\/ Most of this is taken from many of the shaders\n\/\/ that @iq have worked on. Make sure to check out\n\/\/ more of his magic!!!\n\n\n\/\/ This calculation basically gets a way for us to \n\/\/ transform the rays coming out of our eyes and going through the window.\n\/\/ If it doesn't make sense, thats ok. It doesn't make sense to me either :)\n\/\/ Whats important to remember is that this basically gives us a way to position\n\/\/ our window. We could you it to make the window look north, south, east, west, up, down\n\/\/ or ANYWHERE in between!\nmat3 calculateEyeRayTransformationMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n\n\n\n\n\n\n\/\/--------------------------------------------------------------\n\/\/ SECTION 'D' : MAPPING THE WORLD , AKA 'SDFS ARE AWESOME!!!!'\n\/\/--------------------------------------------------------------\n\n\n\/\/'TAG: BALLOON'\nvec2 sdfBalloon( vec3 currentRayPosition ){\n  \n  \/\/ First we define our balloon position\n  vec3 balloonPosition = vec3( 0. , 0. , -.4);\n    \n  \/\/ than we define our balloon radius\n  float balloonRadius = .9;\n    \n  \/\/ Here we get the distance to the center of the balloon\n  float distanceToBalloon = length( currentRayPosition - balloonPosition );\n    \n  \/\/ finally we get the distance to the balloon surface\n  \/\/ by substacting the balloon radius. This means that if\n  \/\/ the distance to the balloon is less than the balloon radius\n  \/\/ the value we get will be negative! giving us the 'Signed' in\n  \/\/ Signed Distance Field!\n  float distanceToBalloonSurface = distanceToBalloon - balloonRadius;\n    \n  \n  \/\/ Finally we build the full balloon information, by giving it an ID\n  float balloonID = 1.;\n    \t\n  \/\/ And there we have it! A fully described balloon!\n  vec2 balloon = vec2( distanceToBalloonSurface,  balloonID );\n    \n  return balloon;\n    \n}\n\n\nvec2 sdfBox( vec3 currentRayPosition ){\n  \n  \/\/ First we define our box position\n  vec3 boxPosition = vec3( -.8 , -.4 , 0.2 );\n    \n  \/\/ than we define our box dimensions using x , y and z\n  vec3 boxSize = vec3( .4 , .3 , .2 );\n    \n  \/\/ Here we get the 'adjusted ray position' which is just\n  \/\/ writing the point of the ray as if the origin of the \n  \/\/ space was where the box was positioned, instead of\n  \/\/ at 0,0,0 . AKA the difference between the vectors in\n  \/\/ vector format.\n  vec3 adjustedRayPosition = currentRayPosition - boxPosition;\n    \n  \/\/ finally we get the distance to the box surface.\n  \/\/ I don't get this part very much, but I bet Inigo does!\n  \/\/ Thanks for making code for us IQ !\n  vec3 distanceVec = abs( adjustedRayPosition ) - boxSize;\n  float maxDistance = max( distanceVec.x , max( distanceVec.y , distanceVec.z ) ); \n  float distanceToBoxSurface = min( maxDistance , 0.0 ) + length( max( distanceVec , 0.0 ) );\n  \n  \/\/ Finally we build the full box information, by giving it an ID\n  float boxID = 2.;\n    \t\n  \/\/ And there we have it! A fully described box!\n  vec2 box = vec2( distanceToBoxSurface,  boxID );\n    \n  return box;\n    \n}\n\n\n\/\/ 'TAG : WHICH AM I CLOSER TO?'\n\/\/ This function takes in two things\n\/\/ and says which is closer by using the \n\/\/ distance to each thing, comparing them\n\/\/ and returning the one that is closer!\nvec2 whichThingAmICloserTo( vec2 thing1 , vec2 thing2 ){\n \n   vec2 closestThing;\n    \n   \/\/ Check out the balloon function\n   \/\/ and remember how the x of the returned\n   \/\/ information is the distance, and the y \n   \/\/ is the id of the thing!\n   if( thing1.x <= thing2.x ){\n       \n   \t   closestThing = thing1;\n       \n   }else if( thing2.x < thing1.x ){\n       \n       closestThing = thing2;\n       \n   }\n \n   return closestThing;\n    \n}\n\n    \n\n\/\/ Takes in the position of the ray, and feeds back\n\/\/ 2 values of how close it is to things in the world\n\/\/ what thing it is closest two in the world.\nvec2 mapTheWorld( vec3 currentRayPosition ){\n\n\n  vec2 result;\n  \n  \/\/ extra credit: uncomment to repeat\n \/\/ currentRayPosition.x = mod(currentRayPosition.x , 4.) - 2.;  \n \/\/ currentRayPosition.y = mod(currentRayPosition.y , 4.) - 2.;\n \/\/currentRayPosition.z = mod(currentRayPosition.z , 4.) - 2.;\n\n    \n  vec2 balloon = sdfBalloon( currentRayPosition );\n  vec2 box     = sdfBox( currentRayPosition );\n        \n  result = whichThingAmICloserTo( balloon , box );\n    \n  return result;\n\n\n}\n\n\n\n\/\/---------------------------------------------------\n\/\/ SECTION 'C' : NAVIGATING THE WORLD\n\/\/---------------------------------------------------\n\n\/\/ We want to know when the closeness to things in the world is\n\/\/ 0.0 , but if we wanted to get exactly to 0 it would take us\n\/\/ alot of time to be that precise. Here we define the laziness\n\/\/ our navigation function. try chaning the value to see what it does!\n\/\/ if you are getting too low of framerates, this value will help alot,\n\/\/ but can also make your scene look very different\n\/\/ from how it should\nconst float HOW_CLOSE_IS_CLOSE_ENOUGH = 0.001;\n\n\/\/ This is basically how big our scene is. each ray will be shot forward\n\/\/ until it reaches this distance. the smaller it is, the quicker the \n\/\/ ray will reach the edge, which should help speed up this function\nconst float FURTHEST_OUR_RAY_CAN_REACH = 10.;\n\n\/\/ This is how may steps our ray can take. Hopefully for this\n\/\/ simple of a world, it will very quickly get to the 'close enough' value\n\/\/ and stop the iteration, but for more complex scenes, this value\n\/\/ will dramatically change not only how good the scene looks\n\/\/ but how fast teh scene can render. \n\n\/\/ remember that for each pixel we are displaying, the 'mapTheWorld' function\n\/\/ could be called this many times! Thats ALOT of calculations!!!\nconst int HOW_MANY_STEPS_CAN_OUR_RAY_TAKE = 100;\n\n\nvec2 checkRayHit( in vec3 eyePosition , in vec3 rayDirection ){\n\n  \/\/First we set some default values\n \n  \n  \/\/ our distance to surface will get overwritten every step,\n  \/\/ so all that is important is that it is greater than our\n  \/\/ 'how close is close enough' value\n  float distanceToSurface \t\t\t= HOW_CLOSE_IS_CLOSE_ENOUGH * 2.;\n    \n  \/\/ The total distance traveled by the ray obviously should start at 0\n  float totalDistanceTraveledByRay \t= 0.;\n    \n  \/\/ if we hit something, this value will be overwritten by the\n  \/\/ totalDistance traveled, and if we don't hit something it will\n  \/\/ be overwritten by the furthest our ray can reach,\n  \/\/ so it can be whatever!\n  float finalDistanceTraveledByRay \t= -1.;\n    \n  \/\/ if our id is less that 0. , it means we haven't hit anything\n  \/\/ so lets start by saying we haven't hit anything!\n  float finalID = -1.;\n\n    \n    \n  \/\/here is the loop where the magic happens\n  for( int i = 0; i < HOW_MANY_STEPS_CAN_OUR_RAY_TAKE; i++ ){\n      \n    \/\/ First off, stop the iteration, if we are close enough to the surface!\n    if( distanceToSurface < HOW_CLOSE_IS_CLOSE_ENOUGH ) break;\n      \n    \/\/ Second off, stop the iteration, if we have reached the end of our scene! \n    if( totalDistanceTraveledByRay > FURTHEST_OUR_RAY_CAN_REACH ) break;\n    \n    \/\/ To check how close we are to things in the world,\n    \/\/ we need to get a position in the scene. to do this, \n    \/\/ we start at the rays origin, AKA the eye\n    \/\/ and move along the ray direction, the amount we have already traveled.\n    vec3 currentPositionOfRay = eyePosition + rayDirection * totalDistanceTraveledByRay;\n    \n    \/\/ Distance to and ID of things in the world\n    \/\/--------------------------------------------------------------\n\t\/\/ SECTION 'D' : MAPPING THE WORLD , AKA 'SDFS ARE AWESOME!!!!'\n\t\/\/--------------------------------------------------------------\n    vec2 distanceAndIDOfThingsInTheWorld = mapTheWorld( currentPositionOfRay );\n      \n      \n \t\/\/ we get out the results from our mapping of the world\n    \/\/ I am reassigning them for clarity\n    float distanceToThingsInTheWorld = distanceAndIDOfThingsInTheWorld.x;\n    float idOfClosestThingInTheWorld = distanceAndIDOfThingsInTheWorld.y;\n     \n    \/\/ We save out the distance to the surface, so that\n    \/\/ next iteration we can check to see if we are close enough \n    \/\/ to stop all this silly iteration\n    distanceToSurface           = distanceToThingsInTheWorld;\n      \n    \/\/ We are also finalID to the current closest id,\n    \/\/ because if we hit something, we will have the proper\n    \/\/ id, and we can skip reassigning it later!\n    finalID = idOfClosestThingInTheWorld;  \n     \n    \/\/ ATTENTION: THIS THING IS AWESOME!\n   \t\/\/ This last little calculation is probably the coolest hack\n    \/\/ of this entire tutorial. If we wanted too, we could basically \n    \/\/ step through the field at a constant amount, and at every step\n    \/\/ say 'am i there yet', than move forward a little bit, and\n    \/\/ say 'am i there yet', than move forward a little bit, and\n    \/\/ say 'am i there yet', than move forward a little bit, and\n    \/\/ say 'am i there yet', than move forward a little bit, and\n    \/\/ say 'am i there yet', than move forward a little bit, and\n    \/\/ that would take FOREVER, and get really annoying.\n      \n    \/\/ Instead what we say is 'How far until we are there?'\n    \/\/ and move forward by that amount. This means that if\n    \/\/ we are really far away from everything, we can make large\n    \/\/ movements towards the surface, and if we are closer\n    \/\/ we can make more precise movements. making our marching functino\n    \/\/ faster, and ideally more precise!!\n      \n    \/\/ WOW!\n      \n    totalDistanceTraveledByRay += distanceToThingsInTheWorld;\n      \n\n  }\n\n  \/\/ if we hit something set the finalDirastnce traveled by\n  \/\/ ray to that distance!\n  if( totalDistanceTraveledByRay < FURTHEST_OUR_RAY_CAN_REACH ){\n  \tfinalDistanceTraveledByRay = totalDistanceTraveledByRay;\n  }\n    \n    \n  \/\/ If the total distance traveled by the ray is further than\n  \/\/ the ray can reach, that means that we've hit the edge of the scene\n  \/\/ Set the final distance to be the edge of the scene\n  \/\/ and the id to -1 to make sure we know we haven't hit anything\n  if( totalDistanceTraveledByRay > FURTHEST_OUR_RAY_CAN_REACH ){ \n  \tfinalDistanceTraveledByRay = FURTHEST_OUR_RAY_CAN_REACH;\n    finalID = -1.;\n  }\n\n  return vec2( finalDistanceTraveledByRay , finalID ); \n\n}\n\n\n\n\n\n\n\n\/\/--------------------------------------------------------------\n\/\/ SECTION 'E' : COLORING THE WORLD\n\/\/--------------------------------------------------------------\n\n\n\n\/\/ Here we are calcuting the normal of the surface\n\/\/ Although it looks like alot of code, it actually\n\/\/ is just trying to do something very simple, which\n\/\/ is to figure out in what direction the SDF is increasing.\n\/\/ What is amazing, is that this value is the same thing \n\/\/ as telling you what direction the surface faces, AKA the\n\/\/ normal of the surface. \nvec3 getNormalOfSurface( in vec3 positionOfHit ){\n    \n\tvec3 tinyChangeX = vec3( 0.001, 0.0, 0.0 );\n    vec3 tinyChangeY = vec3( 0.0 , 0.001 , 0.0 );\n    vec3 tinyChangeZ = vec3( 0.0 , 0.0 , 0.001 );\n    \n   \tfloat upTinyChangeInX   = mapTheWorld( positionOfHit + tinyChangeX ).x; \n    float downTinyChangeInX = mapTheWorld( positionOfHit - tinyChangeX ).x; \n    \n    float tinyChangeInX = upTinyChangeInX - downTinyChangeInX;\n    \n    \n    float upTinyChangeInY   = mapTheWorld( positionOfHit + tinyChangeY ).x; \n    float downTinyChangeInY = mapTheWorld( positionOfHit - tinyChangeY ).x; \n    \n    float tinyChangeInY = upTinyChangeInY - downTinyChangeInY;\n    \n    \n    float upTinyChangeInZ   = mapTheWorld( positionOfHit + tinyChangeZ ).x; \n    float downTinyChangeInZ = mapTheWorld( positionOfHit - tinyChangeZ ).x; \n    \n    float tinyChangeInZ = upTinyChangeInZ - downTinyChangeInZ;\n    \n    \n\tvec3 normal = vec3(\n         \t\t\ttinyChangeInX,\n        \t\t\ttinyChangeInY,\n        \t\t\ttinyChangeInZ\n    \t \t\t  );\n    \n\treturn normalize(normal);\n}\n\n\n\n\n\n\/\/ doing our background color is easy enough,\n\/\/ just make it pure black. like my soul.\nvec3 doBackgroundColor(){\n\treturn vec3( 0. );\n}\n\n\n\n\nvec3 doBalloonColor(vec3 positionOfHit , vec3 normalOfSurface ){\n    \n    vec3 sunPosition = vec3( 1. , 4. , 3. );\n    \n    \/\/ the direction of the light goes from the sun\n    \/\/ to the position of the hit\n    vec3 lightDirection = sunPosition - positionOfHit;\n   \t\n    \n    \/\/ Here we are 'normalizing' the light direction\n   \t\/\/ because we don't care how long it is, we\n    \/\/ only care what direction it is!\n    lightDirection = normalize( lightDirection );\n    \n    \n    \/\/ getting the value of how much the surface\n    \/\/ faces the light direction\n    float faceValue = dot( lightDirection , normalOfSurface );\n\t\n    \/\/ if the face value is negative, just make it 0.\n    \/\/ so it doesn't give back negative light values\n    \/\/ cuz that doesn't really make sense...\n    faceValue = max( 0. , faceValue );\n    \n    vec3 balloonColor = vec3( 1. , 0. , 0. );\n    \n   \t\/\/ our final color is the balloon color multiplied\n    \/\/ by how much the surface faces the light\n    vec3 color = balloonColor * faceValue;\n    \n    \/\/ add in a bit of ambient color\n    \/\/ just so we don't get any pure black\n    color += vec3( .3 , .1, .2 );\n    \n    \n\treturn color;\n}\n\n\n\n\/\/ Here we are using the normal of the surface,\n\/\/ and mapping it to color, to show you just how cool\n\/\/ normals can be!\nvec3 doBoxColor(vec3 positionOfHit , vec3 normalOfSurface ){\n    \n    vec3 color = vec3( normalOfSurface.x , normalOfSurface.y , normalOfSurface.z );\n    \n    \/\/could also just write color = normalOfSurce\n    \/\/but trying to be explicit.\n    \n\treturn color;\n}\n\n\n\n\n\/\/ This is where we decide\n\/\/ what color the world will be!\n\/\/ and what marvelous colors it will be!\nvec3 colorTheWorld( vec2 rayHitInfo , vec3 eyePosition , vec3 rayDirection ){\n   \n  \/\/ remember for color\n  \/\/ x = red , y = green , z = blue\n  vec3 color;\n    \n  \/\/ THE LIL RAY WENT ALL THE WAY\n  \/\/ TO THE EDGE OF THE WORLD, \n  \/\/ AND DIDN'T HIT ANYTHING\n  if( rayHitInfo.y < 0.0 ){\n      \n  \tcolor = doBackgroundColor();  \n     \n      \n  \/\/ THE LIL RAY HIT SOMETHING!!!!\n  }else{\n      \n      \/\/ If we hit something, \n      \/\/ we also know how far the ray has to travel to hit it\n      \/\/ and because we know the direction of the ray, we can\n      \/\/ get the exact position of where we hit the surface\n      \/\/ by following the ray from the eye, along its direction\n      \/\/ for the however far it had to travel to hit something\n      vec3 positionOfHit = eyePosition + rayHitInfo.x * rayDirection;\n      \n      \/\/ We can then use this information to tell what direction\n      \/\/ the surface faces in\n      vec3 normalOfSurface = getNormalOfSurface( positionOfHit );\n      \n      \n      \/\/ 1.0 is the Balloon ID\n      if( rayHitInfo.y == 1.0 ){\n          \n  \t\tcolor = doBalloonColor( positionOfHit , normalOfSurface ); \n       \n          \n      \/\/ 2.0 is the Box ID\n      }else if( rayHitInfo.y == 2.0 ){\n          \n      \tcolor = doBoxColor( positionOfHit , normalOfSurface );   \n          \n      }\n \n  \n  }\n    \n    \n    return color;\n    \n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \/\/---------------------------------------------------\n    \/\/ SECTION 'A' : ONE PROGRAM FOR EVERY PIXEL!\n    \/\/---------------------------------------------------\n    \n    \/\/ Here we are getting our 'Position' of each pixel\n    \/\/ This section is important, because if we didn't\n    \/\/ divied by the resolution, our values would be masssive\n    \/\/ as fragCoord returns the value of how many pixels over we \n    \/\/ are. which is alot :)\n\tvec2 p = ( -iResolution.xy + 2.0 * fragCoord.xy ) \/ iResolution.y;\n     \n    \/\/ thats a super long name, so maybe we will \n    \/\/ keep on using uv, but im explicitly defining it\n    \/\/ so you can see exactly what those two letters mean\n    vec2 xyPositionOfPixelInWindow = p;\n    \n    \n    \n    \/\/---------------------------------------------------\n    \/\/ SECTION 'B' : BUILDING THE WINDOW\n    \/\/---------------------------------------------------\n    \n    \/\/ We use the eye position to tell use where the viewer is\n    vec3 eyePosition = vec3( 0., 0., 2.);    \n    \n    \/\/extra credit: move camera\n    \/\/vec3 eyePosition = vec3( sin(iTime), 0., 2.);\n\n    \n    \/\/ This is the point the view is looking at. \n    \/\/ The window will be placed between the eye, and the \n    \/\/ position the eye is looking at!\n    vec3 pointWeAreLookingAt = vec3( 0. , 0. , 0. );\n  \n\t\/\/ This is where the magic of actual mathematics\n    \/\/ gives a way to actually place the window.\n    \/\/ the 0. at the end there gives the 'roll' of the transformation\n    \/\/ AKA we would be standing so up is up, but up could be changing \n    \/\/ like if we were one of those creepy dolls whos rotate their head\n    \/\/ all the way around along the z axis\n    mat3 eyeTransformationMatrix = calculateEyeRayTransformationMatrix( eyePosition , pointWeAreLookingAt , 0. ); \n   \n    \n    \/\/ Here we get the actual ray that goes out of the eye\n    \/\/ and through the individual pixel! This basically the only thing\n    \/\/ that is different between the pixels, but is also the bread and butter\n    \/\/ of ray tracing. It should be since it has the word 'ray' in its variable name...\n    \/\/ the 2. at the end is the 'lens length' . I don't know how to best\n    \/\/ describe this, but once the full scene is built, tryin playing with it\n    \/\/ to understand inherently how it works\n    vec3 rayComingOutOfEyeDirection = normalize( eyeTransformationMatrix * vec3( p.xy , 2. ) ); \n\n    \n    \n    \/\/---------------------------------------------------\n\t\/\/ SECTION 'C' : NAVIGATING THE WORLD\n\t\/\/---------------------------------------------------\n    vec2 rayHitInfo = checkRayHit( eyePosition , rayComingOutOfEyeDirection );\n    \n    \n    \/\/--------------------------------------------------------------\n\t\/\/ SECTION 'E' : COLORING THE WORLD\n\t\/\/--------------------------------------------------------------\n\tvec3 color = colorTheWorld( rayHitInfo , eyePosition , rayComingOutOfEyeDirection );\n    \n   \n   \t\/\/--------------------------------------------------------------\n    \/\/ SECTION 'F' : Wrapping up\n    \/\/--------------------------------------------------------------\n\tfragColor = vec4(color,1.0);\n    \n    \n    \/\/ WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW!\n    \/\/ WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    \/\/ WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    \/\/ WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    \/\/ WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    \n    \n}\n\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"csX3RH","date":"1665613021","viewed":13274,"name":"Anti Aliased Texture Sampling","username":"TylerGlaiel","description":"use this to scale pixel art textures!","likes":90,"published":1,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"\/media\/a\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"\/media\/ap\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"\/media\/a\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"\/media\/ap\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/modified from https:\/\/www.shadertoy.com\/view\/ltfXWS, tested a few different versions of this same function and this one seemed to have the nicest results\nvec4 texture2DAA(sampler2D tex, vec2 uv) {\n    vec2 texsize = vec2(textureSize(tex,0));\n    vec2 uv_texspace = uv*texsize;\n    vec2 seam = floor(uv_texspace+.5);\n    uv_texspace = (uv_texspace-seam)\/fwidth(uv_texspace)+seam;\n    uv_texspace = clamp(uv_texspace, seam-.5, seam+.5);\n    return texture(tex, uv_texspace\/texsize);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord\/iResolution.xx*(sin(iTime*.2)+1.5)-vec2(.5, .5);\n    uv *= mat2(sin(iTime * 0.1), cos(iTime * 0.1), -cos(iTime * 0.1), sin(iTime * 0.1));\n\n    if(fragCoord.x\/iResolution.x < .5){\n        fragColor = texture2DAA(iChannel0, uv); \/\/anti aliased scaling (iChannel0 is set to \"linear\" scaling)\n    } else {\n        fragColor = texture(iChannel1, uv); \/\/nearest neighbor scaling (iChannel1 is set to \"nearest\" scaling)\n    }\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"XdyyDV","date":"1523332261","viewed":13251,"name":"Shuto Highway 83","username":"blackjero","description":"An attempt at a city shader. Mouse to look around, 7 cameras, a bit more than a couple of minutes. The roof top coffee break (?) camera has a special look down camera control when standing next to the roof border.","likes":128,"published":3,"flags":0,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Shuto Highway 83 by Jerome Liard, April 2018\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/ https:\/\/www.shadertoy.com\/view\/XdyyDV\n\/\/\n\/\/ An attempt at a city shader. Mouse to look around, 7 cameras, a bit more than a couple of minutes. \n\/\/ The roof top coffee break (?) camera has a special look down camera control when standing next to the roof border.\n\/\/\n\/\/ June 2021 update:\n\/\/ - Replaced the code by the original non preprocessed one.\n\/\/ - Forced more loops (on 2 gradient evals) seems to have shortern shadertoy compilation by a couple seconds.\n\/\/\n\/\/ I tried to go for a Japanese urban look with a mix of modern buildings and traditional tiled houses.\n\/\/ Building arrangements within a grid cell use this https:\/\/www.shadertoy.com\/view\/4tXcRl (that's what they were designed for in the first place)\n\/\/ But this time they are dda+raytraced instead of ray marched, which lifts limitation on height and perf constraints (no need to evaluate neighbors etc.).\n\/\/\n\/\/ Tracing is a nested and composited dda\/raytrace\/raymarch hybrid;\n\/\/\n\/\/   1) raytrace ground infinite plane and highway drivable surface to reduce sdf melting on streets and highway vanishing point\n\/\/   2) 3d DDA trace a regular grid [traceBuildings()]\n\/\/      for each cell entered\n\/\/         partition the cell with a random split arrangements of 4 bounding boxes, 1 per building (or house)\n\/\/         raytrace all 4 bounding boxes (some calculations can be factorized, so it is not quite as bad as it sounds) [rayMarchCellObjects()]\n\/\/            when we hit a box, ray march a house or a building inside [rayMarchParametricBuilding()]\n\/\/            if there was a hit, calculate its normal and ray march for AO there\n\/\/   3) independently of DDA (except for occlusion early return), ray march highways, street lamps, z=0 ground, and march for AO there too (most of this is culled by buildings)\n\/\/   -> composite all the hits above as we go, early return everywhere we can etc. Note AO is not global (but it's ok enough)\n\/\/   4) trace the scene again for shadows (ouch) and lit\n\/\/\n\/\/ Other:\n\/\/\n\/\/   - The sky probe function might be of interest to some (uncomment the test_sky() line to see).\n\/\/     It is a careful manual match of a reference hosek sky probe (see get_sky()) so that we don't have to do atmosphere calculations.\n\/\/     I used a radial gradient curve picking UI (make one in 30 minutes with your favorite imgui), \n\/\/     and found that biexponentials are able to match the r,g,b sky gradients pretty well.\n\/\/   - The distance to curve algorithm (important for the highway and surrounding geom clip planes) might be of interest too, see evalHighway()\n\/\/   - Unhandled divide by zeros occasionally create buggy horizontal lines mid screen, sorry...\n\/\/   - I didn't want to rely on textures too much and was interested in volumetric detail, so it ended up flat-ish look overall\n\/\/   - Building windows use the old trick of tracing a ray past the window, assuming constant floor heights, and return an infinite neon plane on the ceiling. From outside, the infinite neon planes sometimes \"leak\" past real walls, we don't care\n\/\/   - If you look up there are airliners in the sky. \n\/\/     Their silhouette is a pretty close match of and airbus as350 although in the final shader it's just some far away pixel vomit\n\/\/   - No AA so can be a bit flickery... sorry\n\/\/\n\/\/\/ -------------------------------------------------------- turn stuff on and off\n\n\/\/\/ trace building bounding boxes only\n\/\/\/#define DEBUG_BUILDINGS_BOUNDS\n\n\/\/\/ colorful debug showing the structure of the scene\n\/\/\/#define DEBUG_COLORING\n\n#define HIGHWAY_CLIP\n#define BUILDINGS\n#define TILE_PERMUTATIONS\n#define ROOF_OBJECTS\n#define TRY_BALANCE_SIZES\n#define OFFICE_NEON\n#define WINDOWS_GROUND_REFLECTION\n#define HIGHWAYS\n#define WIDE_STREETS_LAMPS\n#define HIGHWAY_LAMPS\n#define LCD_PANELS\n#define SHADOWS\n#define AO\n#define HORIZON_HACK\n\n#define STICKY_MOUSE false\n\n\/\/\/ -------------------------------------------------------- perfs and shader crash raindances\n\n\/\/\/ this shader worked natively everywhere I tested, \n\/\/\/ but webgl takes much longer to build and sometimes crashes, hitting seemingly random resource limits or timeouts\n\/\/\/ there has been cases where I had to force a loop to prevent driver crashes (even natively),\n\/\/\/ and there has been cases where where fiddling with for loops led to important perf variations\n\/\/\/ without ability to check the compiler output it is a bit of a raindance contest\n\n\/\/\/ try bend for loops to our will, this is from Fabrice's excellent page https:\/\/shadertoyunofficial.wordpress.com\/\n#define FORCE_LOOP +min(0,iFrame)\n\n\/\/\/ ----\n\/\/\/ top traceCity loop\n#define FORCE_LOOP_LV0 FORCE_LOOP\n\/\/\/#define FORCE_LOOP_LV0\n\/\/\/#define UNROLL_LOOP0\n\/\/\/ ----\n\/\/\/ dda cell iteration loop\n\/\/\/ if not forcing loop here: compiler once crashed on GTX970 (not webgl), malloc fail\n#define FORCE_LOOP_LV1 FORCE_LOOP\n\/\/\/#define FORCE_LOOP_LV1\n\/\/\/ ----\n\/\/\/ per dda cell iteration on 4 buildings\n\/\/\/ force loop was a little bit slower on radeon 5670 at some point in the past\n#define FORCE_LOOP_LV2 FORCE_LOOP\n\/\/\/#define FORCE_LOOP_LV2\n\/\/\/ UNROLL_LOOP2: manual unroll (GTX970 got much slower at some point in the past)\n\/\/\/#define UNROLL_LOOP2\n\/\/\/ ----\n\/\/\/ sd_ParametricBuilding sdf ray march loop\n#define FORCE_LOOP_LV3 FORCE_LOOP\n\/\/\/#define FORCE_LOOP_LV3\n\/\/\/ ----\n\n\/\/\/ ----\n\/\/\/ ao loop\n#define FORCE_LOOP_AO FORCE_LOOP\n\/\/\/#define FORCE_LOOP_AO\n\/\/\/ ----\n\n\/\/\/ ----\n\/\/\/ sdf bits loop\n#define FORCE_LOOP_S FORCE_LOOP\n\/\/\/#define FORCE_LOOP_S\n\/\/\/ ----\n\n\/\/\/ ----\n\/\/\/ airliners loop\n#define FORCE_LOOP_B FORCE_LOOP\n\/\/\/#define FORCE_LOOP_B\n\/\/\/ ----\n\n\/\/ those defines weren't in the first version of the shader \n\/\/ they cut a few seconds of compilation time on shadertoy\n#define FORCE_GRAD_LOOP_BUILDING\n#define FORCE_GRAD_LOOP_SCENE\n\n\/\/ -------------------------------------------------------- lib stuff\n\n#define PI 3.141592654\n#define FLT_MAX \/* FLT_MAX *\/1000000. \n#define SQR2 1.414213562\n\n#define RED\tvec3( 1, 0, 0 )\n#define GREEN vec3( 0, 1, 0 )\n#define BLUE vec3( 0, 0, 1 )\n#define MAGENTA vec3( 1, 0, 1 )\n#define BLEU_ARDOISE vec3( 0.32, 0.38, 0.47 )\n#define GRIS_ARDOISE vec3( 0.35, 0.36, 0.41 )\n\nvec3 zset( vec3 p, float v ) { return vec3( p.x, p.y, v );}\n\n#define IMPL_SATURATE(type) type saturate( type x ) { return clamp( x, type(0.0), type(1.0) ); }\n\nIMPL_SATURATE( float )\nIMPL_SATURATE( vec4 )\n\nfloat exp_decay( float x ) { return 1. - exp( -x ); }\n\/\/ for rcp_decay, max x with something < 0 to prevent infinity and cull the other side\nfloat rcp_decay( float x ) { return x \/ ( 1. + x ); }\nfloat smoothstep_unchecked( float x ) { return ( x * x ) * ( 3.0 - x * 2.0 ); }\nfloat linearstep( float a, float b, float x ) { return saturate( ( x - a ) \/ ( b - a ) ); }\nfloat exp_bell( float x, float r ) { x *= ( 1. \/ r ); return exp( -x * x ); }\nfloat smoothbump( float a, float r, float x ) { return 1.0 - smoothstep_unchecked( min( abs( x - a ), r ) \/ r ); }\nfloat smoothbump( float x, float s1, float e1, float s2, float e2 ) { return smoothstep( s1, e1, x ) * smoothstep( e2, s2, x ); }\nfloat cosbump( float x, float x0, float r ) { return ( 1. + cos( min( abs( ( x - x0 ) \/ r ), 1. ) * PI ) ) * 0.5; }\n\/\/ like smoothstep, but takes a center and a radius instead\nfloat smoothstep_c( float x, float c, float r ) { return smoothstep( c - r, c + r, x ); }\n\/\/ band, centered at 0... like smoothstep_c but different semantics\nfloat smoothband( float x, float r, float raa ) { return 1. - smoothstep_c( abs( x ), r, raa ); }\n\/\/ range start,end\nfloat smoothband( float x, float s, float e, float raa ) { return smoothband( x - ( e + s ) * 0.5, ( e - s ) * 0.5, raa ); }\nvec2 perp( vec2 v ) { return vec2( -v.y, v.x ); }\n\/\/ return range -pi,pi\nfloat calc_angle( vec2 v ) { return atan( v.y, v.x ); }\nfloat calc_angle( vec2 a, vec2 b ) { return calc_angle( vec2( dot( a, b ), dot( perp( a ), b ) ) ); }\nvec3 contrast( vec3 x, vec3 s ) { return ( x - 0.5 ) * s + 0.5; }\nfloat pow2( float x ) { return x * x; }\nvec3 pow2( vec3 x ) { return x * x; }\nvec4 pow2( vec4 x ) { return x * x; }\nfloat pow5( float x ) { float x2 = x * x; return x2 * x2 * x; }\n\/\/ in soft min don't go too crazy with small values of k\n\/\/ those are not real min\/max (returned values can exceed input values)\nfloat soft_min2( float a, float b, float k ) { return -log2( exp2( -k * a ) + exp2( -k * b ) ) \/ k; }\nfloat soft_max2( float a, float b, float k ) { return -soft_min2( -a, -b, k ); }\nfloat powerful_scurve( float x, float p1, float p2 ) { return pow( 1.0 - pow( 1.0 - clamp( x, 0.0, 1.0 ), p2 ), p1 ); }\nfloat maxcomp( float x ) { return x; }\nfloat maxcomp( vec2 v ) { return max( v.x, v.y ); }\nfloat maxcomp( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat mincomp( float x ) { return x; }\nfloat mincomp( vec2 v ) { return min( v.x, v.y ); }\nfloat mincomp( vec3 v ) { return min( min( v.x, v.y ), v.z ); }\nvec3 luminance( vec3 c ) { return vec3( dot( vec3( 0.2989, 0.5866, 0.1145 ), c ) ); }\nfloat sum( vec3 v ) { return v.x + v.y + v.z; }\n\/\/ symmetrize\/mirror x around a\nfloat fold( float x, float a ) { return x + 2. * min( 0., a - x ); }\nvec2 fold( vec2 p, vec2 o, vec2 n ) { float a = dot( p - o, n ); return p - 2. * min( a, 0. ) * n; }\n\/\/ acos overflow bugs (subtle ot not) are the worse\nfloat safe_acos( float x ) { return acos( clamp( x, -1., 1. ) ); }\nvec4 safe_acos( vec4 x ) { return acos( clamp( x, vec4(-1.), vec4(1.) ) ); }\n\n\/\/\/ CLOSEST_POINT_TANGENT_TO_FUNC_21 calculates the distance to a 1d curve\n\/\/\/ input:\n\/\/\/  a_p               eval pos\n\/\/\/  a_func            the R->R function to evaluate, first guess (iteration start point) is vec2(a_p.x,a_func(a_p.x))\n\/\/\/                    a_func can be a macro, it seems\n\/\/\/  a_epsilon         epsilon used for derivative evaluation, must scale roughly with your working dimensions\n\/\/\/                    else the distance estimation will disolve as your epsilon disappears in floating point additions\n\/\/\/  a_num_iterations  num iterations - check actual quality of result to set this, often we just use 2\n\/\/\/  a_t0              the iteraton parameter start value, affects iteration speed a lot\n\/\/\/                    for a regular 1d function we use a_p.x\n\/\/\/                    for a polar function start at calc_angle(a_p)\n\/\/\/ output:\n\/\/\/  a_ret             the return value is a vec4 where .xy is vector to closest point on curve and .zw the derivative (tangent at the closest point)\n\/\/\/\n\/\/\/ - a_func(t) returns vec2(t,your1dfunc(t)) for 1d functions\n\/\/\/ - a_func(t) returns (yourpolarfunc(x)*unit_vector2(x)) for polar functions\n\/\/\/ a_func can be a macro\n\n#define CLOSEST_POINT_TANGENT_TO_FUNC_21( a_ret, a_p, a_func, a_epsilon, a_num_iterations ) \\\n{ \\\n\t\/* we use this method for distance to curve: http:\/\/www.geometrie.tugraz.at\/wallner\/sproj.pdf *\/ \\\n\t\/* it is a bit different from https:\/\/iquilezles.org\/articles\/distance in that since it is iterative there is a potential quality\/perf trade off *\/ \\\n\tvec2 _p = a_p, _c, _dc; \\\n\tfloat _epsilon = a_epsilon; \\\n\tfloat _t = _p.x; \/* t0, could be a parameter if the user knows better *\/ \\\n\tfor ( int _i = 0; _i < a_num_iterations; ++_i ) { \\\n\t\t_c = a_func( _t ); \\\n\t\t_dc = ( a_func( _t + _epsilon ) - _c ) * ( 1. \/ _epsilon ); \\\n\t\t_t += dot( _p.xy - _c, _dc ) \/ dot( _dc, _dc ); \/* simplification of _t += dot( _dc, _q - _c ) \/ dot( _dc, _dc ); where _q is _p.xy projected on (_c,_dc) line *\/ \\\n\t} \\\n\ta_ret = vec4( _c - _p, _dc ); \\\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/smin\n\/\/ polynomial smooth min (k = 0.1);\nfloat smin_pol( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5 * ( b - a ) \/ k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k * h * ( 1.0 - h );\n}\n\n\/\/ https:\/\/mynameismjp.wordpress.com\/2016\/10\/09\/sg-series-part-2-spherical-gaussians-101\/\n\/\/ v is the eval direction, v and axis assumed normalized and cos_v_axis = dot(v,axis)\nfloat spherical_gaussian( float cos_v_axis, float amplitude, float sharpness ) { return amplitude * exp( ( cos_v_axis - 1. ) * sharpness ); }\nvec3 spherical_gaussian( float cos_v_axis, vec3 amplitude, vec3 sharpness ) { return amplitude * exp( ( cos_v_axis - 1. ) * sharpness ); }\nvec3 spherical_gaussian( float cos_v_axis, vec3 amplitude, float sharpness ) { return amplitude * exp( ( cos_v_axis - 1. ) * sharpness ); }\n\n\/\/ https:\/\/iquilezles.org\/articles\/functions\nfloat impulse( float a, float x ) { float ax = a * x; return ax * exp( 1. - ax ); }\nvec2 impulse( vec2 a, vec2 x ) { vec2 ax = a * x; return ax * exp( vec2( 1. ) - ax ); }\n\nfloat biexp2( float x, float a, float b ) { return ( ( a * b ) \/ ( a - b ) ) * ( exp2( -b * x ) - exp2( -a * x ) ); }\nvec3 biexp2( vec3 x, vec3 a, vec3 b ) { return ( ( a * b ) \/ ( a - b ) ) * ( exp2( -b * x ) - exp2( -a * x ) ); }\n\n\/\/https:\/\/www.shadertoy.com\/view\/MsS3Wc\nvec3 hsv2rgb( in vec3 c )\n{\n\tvec3 rgb = clamp( abs( mod( c.x * 6.0 + vec3( 0.0, 4.0, 2.0 ), 6.0 ) - 3.0 ) - 1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3( 1.0 ), rgb, c.y );\n}\n\n#define DECL_BOUNDS( btype, type, booltype ) \\\nstruct btype { type pmin; type pmax; }; \\\nbtype mkbounds_unchecked( type amin, type amax ) { btype ret; ret.pmin = amin; ret.pmax = amax; return ret; } \\\ntype size( btype b ) { return b.pmax - b.pmin; } \\\ntype center( btype b ) { return 0.5 * ( b.pmax + b.pmin ); } \\\n\/* grid multiplier range *\/ \\\n\/* bounds b is cell \"0,0\" *\/ \\\n\/* min_xs is pmin offset (in multiples of bounds size) *\/ \\\n\/* max_xs is pmax offset (in multiples of bounds size) *\/ \\\nbtype mkbounds_unchecked_gx( btype b, type min_xs, type max_xs ) { type s = size( b ); btype ret = b; ret.pmin += s * min_xs; ret.pmax += s * max_xs; return ret; }\n\nDECL_BOUNDS( bounds1, float, bool )\nDECL_BOUNDS( bounds2, vec2, bvec2 )\nDECL_BOUNDS( bounds3, vec3, bvec3 )\n\n#define REPEAT_FUNCTIONS( type, btype ) \\\ntype repeat( type x, type len ) { return len * fract( x * ( type( 1.0 ) \/ len ) ); }\\\ntype repeat_mirror( type x, type len ) { return len * abs( type( -1.0 ) + 2.0 * fract( ( ( x * ( type( 1.0 ) \/ len ) ) - type( -1.0 ) ) * 0.5 ) ); }\\\n\/* return identity in range start,start+len, and repeat mirror elsewhere *\/\\\ntype repeat_mirror_l( type x, type start, type len ) { return start + repeat_mirror( x - start, len ); }\\\ntype repeat_mirror_e( type x, type start, type end ) { return start + repeat_mirror( x - start, end - start ); }\\\n\/* return identity in range start,start+len, and repeat elsewhere *\/\\\ntype repeat_e( type x, type start, type end ) { return start + repeat( x - start, end - start ); }\\\ntype repeat_b( type x, btype b ) { return b.pmin + repeat( x - b.pmin, b.pmax - b.pmin ); }\\\n\nREPEAT_FUNCTIONS( float, bounds1 )\nREPEAT_FUNCTIONS( vec2, bounds2 )\nREPEAT_FUNCTIONS( vec3, bounds3 )\n\n#define TRI_FUNCTIONS(type,btype) \\\n\/* function returns 0 at x = half_width *\/ \\\ntype tri_p( type x, type half_width, type half_period )\t{ return half_width - repeat_mirror( x, half_period ); } \\\n\/* function returns 0 at x = half_width *\/ \\\ntype tri_s( type x, type half_width, type half_spacing ) { return half_width - repeat_mirror( x, half_width + half_spacing ); } \\\n\/* tri_b repeats bounds1 [s1,e1] inside a repeated bounds0 [s0,e0] *\/ \\\n\/* be careful, it is *not* equivalent to using repeat_b on b0 and sd_bounds b1 inside that, unless b1 is centered *\/ \\\n\/* use tri_b or sd_bounds_repeat_* to correctly repeat bounds sdf *\/ \\\ntype tri_b( type p, type s0, type e0, type s1, type e1) { type c = s0 + ( e1 + s1 ) * 0.5; return -tri_p( p - c, ( e1 - s1 ) * 0.5, ( e0 - s0 ) * 0.5 ); } \\\n\/* same as above but with bounds *\/ \\\ntype tri_b( type p, btype b0, btype b1) { return tri_b( p, b0.pmin, b0.pmax, b1.pmin, b1.pmax ); }\n\nTRI_FUNCTIONS( float, bounds1 )\nTRI_FUNCTIONS( vec2, bounds2 )\nTRI_FUNCTIONS( vec3, bounds3 )\n\n\/\/ like smoothband() but repeated, using smoothstep as poor AA\n\/\/ - r is the half width of the stripes\n\/\/ - raa is the half size of the edge\/aa smoothstep (ex: pixel_size)\n\/\/ - period is the distance between 2 consecutive stripes\nfloat stripes( float x, float period, float r, float raa ) { return smoothstep( r + raa, r - raa, repeat_mirror( x, period * 0.5 ) ); }\nvec2 stripes( vec2 x, vec2 period, vec2 r, vec2 raa ) { return smoothstep( r + raa, r - raa, repeat_mirror( x, period * 0.5 ) ); }\n\/\/ variation of stripes where multiple period overlap (stripes not centered on 0)\nfloat stripes2( float x, float period, float r, float raa ) { return smoothstep( r + raa, r - raa, repeat_mirror( x - r, period * 0.5 ) ); }\n\n\/\/ hash functions from David Hoskins's https:\/\/www.shadertoy.com\/view\/4djSRW using \"integer stepped ranges\" settings\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nfloat hash11( float p ) { vec3 p3  = fract( vec3( p ) * HASHSCALE1 ); p3 += dot( p3, p3.yzx  + 19.19 ); return fract( ( p3.x + p3.y ) * p3.z ); }\nvec3 hash32( vec2 p ) { vec3 p3 = fract( vec3( p.xyx ) * HASHSCALE3 ); p3 += dot( p3, p3.yxz  + 19.19 ); return fract( ( p3.xxy  + p3.yzz  ) * p3.zyx ); }\n\n\/\/ hopefully stable hash (across gpus and\/or webgl) functions, munged from iq's version https:\/\/www.shadertoy.com\/view\/XlXcW\n\nvec4 hash44_( ivec4 x0 )\n{\n\tuint k = 1103515245U;  \/\/ GLIB C\n\tuvec4 x = uvec4( x0 );\n\tx = (( x >> 13U ) ^ x.yzwx ) * k;\n\tx = (( x >> 13U ) ^ x.zwxy ) * k;\n\/\/\tx = (( x >> 13U ) ^ x.wxyz ) * k; \/\/ can't really tell the difference \n\treturn vec4( x ) * ( 1.0 \/ float( 0xffffffffU ));\n}\n\nvec4 hash42_( ivec2 x0 )\n{\n\tuint k = 1103515245U;  \/\/ GLIB C\n\tuvec4 x = uvec4( x0, x0 * 0x8da6b343 );\n\tx = (( x >> 13U ) ^ x.yzwx ) * k;\n\tx = (( x >> 13U ) ^ x.zwxy ) * k;\n\/\/\tx = (( x >> 13U ) ^ x.wxyz ) * k; \/\/ can't really tell the difference \n\treturn vec4( x ) * ( 1.0 \/ float( 0xffffffffU ));\n}\n\nvec2 hash22_( ivec2 p ) { return hash42_( p ).xy; }\nvec2 hash24_( ivec4 p ) { return hash44_( p ).xy; }\n\n#define V45 vec2( 0.707106781, 0.707106781 )\n#define V60 vec2( 0.5, 0.866025403 )\n\n\/\/ return a unit vector, or an angle (it's the same thing)\nvec2 unit_vector2( float angle ) { return vec2( cos( angle ), sin( angle ) ); }\n\/\/ note that if point p is also a unit vector, rotate_with_unit_vector returns the same as doing unit_vector2 on the sum of the angles (obvious but)\nvec2 rotate_with_unit_vector( vec2 p, vec2 cs ) { return vec2( cs.x * p.x - cs.y * p.y, cs.y * p.x + cs.x * p.y ); }\nvec2 rotate_with_unit_vector_neg( vec2 p, vec2 cs ) { return vec2( cs.x * p.x + cs.y * p.y, -cs.y * p.x + cs.x * p.y ); }\nvec2 rotate_with_angle( vec2 p, float a_angle ) { return rotate_with_unit_vector( p, unit_vector2( a_angle ) ); }\n\/\/ theta is the angle with the z axis, range [0,pi]\n\/\/ phi is the angle with x vectors on z=0 plane, range [0,2pi]\nvec3 zup_spherical_coords_to_vector( float theta, float phi ) { vec2 theta_vec = unit_vector2( theta ); return vec3( theta_vec.y * unit_vector2( phi ), theta_vec.x ); }\nvec3 yup_spherical_coords_to_vector( float theta, float phi ) { return zup_spherical_coords_to_vector( theta, phi ).yzx; }\n\nmat4 yup_spherical_coords_to_matrix( float theta, float phi )\n{\n\tvec3 y = yup_spherical_coords_to_vector( theta, phi );\n\tvec3 z = yup_spherical_coords_to_vector( theta + PI * 0.5, phi );\n\tvec3 x = cross( y, z );\n\treturn mat4( vec4( x, 0.0 ), vec4( y, 0.0 ), vec4( z, 0.0 ), vec4( 0, 0, 0, 1 ) );\n}\n\nmat4 z_rotation( float angle ) { vec2 v = unit_vector2( angle ); return mat4( vec4( v.x, v.y, 0.0, 0.0 ), vec4( -v.y, v.x, 0.0, 0.0 ), vec4( 0, 0, 1, 0 ), vec4( 0, 0, 0, 1 ) ); }\n\nstruct Ray { vec3 o; vec3 d; };\n\nRay mkray( vec3 o, vec3 d ) { Ray tmp; tmp.o = o; tmp.d = d; return tmp; }\nRay get_view_ray( vec2 normalized_pos, float z, float aspect, float tan_half_fovy ) { vec3 p = vec3( normalized_pos * vec2( aspect, 1.0 ) * tan_half_fovy, -1.0 ) * z; return mkray( p, normalize( p ) ); }\n\nmat4 lookat( vec3 eye, vec3 center, vec3 up ) { vec3 z = normalize( eye - center ); vec3 x = normalize( cross( up, z ) ); vec3 y = cross( z, x ); return mat4( vec4( x, 0.0 ), vec4( y, 0.0 ), vec4( z, 0.0 ), vec4( eye, 1.0 ) ); }\n\nfloat plane_trace_z( Ray ray, float base, float epsilon ) { return abs( ray.d.z ) > epsilon ? ( base - ray.o.z ) \/ ray.d.z : FLT_MAX; }\n\n\/\/ build a little quadric so that y'(0)=0, y(r)=r, y'(r)=1 here\nfloat her2( float x, float r ) { return 0.5 * ( ( 1.0 \/ r ) * x * x + r ); }\n\n\/\/ customize max of f(x)=0 and f(x)=x in the x in [ -r,r] interval\nfloat curved_max_vfunc_hard_bevel( float x, float r ) { return max( r, abs( x ) ); }\nfloat curved_max_vfunc_weld_quadric( float x, float r ) { x = abs( x ); if ( x > r ) return x; return her2( x, r ); }\n\/\/ rr in 0,1, set < 1 if you want to see a flat bit\n\/\/ rr == 1 gives a soft bevel, slightly different shape and a bit more expensive than curved_max_vfunc_weld_quadric\nfloat curved_max_vfunc_round_bevel( float x, float r, float rr )\n{\n\tx = abs( x );\n\tif ( x > r ) return x;\n\tfloat a = rr * r; \/\/ make bevel radius relative to r (so rr is a 0,1 value, if you go above 1 yo get a discontinuity at 0)\n\tfloat cr = a * SQR2; \/\/ this is the radius of the circle used to make the round bevel\n\tvec2 c = vec2( r - a, r + a ); \/\/ center of round bevel is at (r-a,r+a) (on a y=1-x line that emanates from (r,r))\n\treturn c.y - sqrt( cr * cr - pow2( max( 0.0, x - c.x ) ) );\n}\n\n\/\/ max\nfloat opI( float d1, float d2 ) { return max( d1, d2 ); }\nfloat opI_soft2( float a, float b, float k ) { return soft_max2( a, b, k ); }\nfloat opI_hard_bevel( float a, float b, float r ) { float c = ( a + b ) * 0.5; return c + curved_max_vfunc_hard_bevel( a - c, r ); }\nfloat opI_round_bevel( float a, float b, float r, float rr ) { float c = ( a + b ) * 0.5; return c + curved_max_vfunc_round_bevel( a - c, r, rr ); }\nfloat opU( float d1, float d2 ) { return -max( -d1, -d2 ); }\nfloat opU_hard_bevel( float a, float b, float r ) { return -opI_hard_bevel( -a, -b, r ); }\nfloat opS( float d1, float d2 ) { return max( -d2, d1 ); }\nfloat opS_hard_bevel( float a, float b, float r ) { return opI_hard_bevel( -b, a, r ); }\nfloat opI( float d1, float d2, float d3 ) { return max( max( d1, d2 ), d3 ); }\n\/\/ Band\/border operations (extract a band from an sdf)\n\/\/ band c-r,c+r\nfloat opB_rc( float d, float r, float c ) { return abs( d - c ) - r; }\n\/\/ band -w,0\nfloat opB_inside( float d, float w ) { float r = w * 0.5; return opB_rc( d, r, -r ); }\n\/\/ band 0,w\nfloat opB_outside( float d, float w ) { float r = w * 0.5; return opB_rc( d, r, r ); }\n\/\/ band mi,ma\n\/\/ should be same as sd_bounds_range(d,mi,ma)\nfloat opB_range( float d, float mi, float ma ) { return opB_rc( d, ( ma - mi ) * 0.5, ( mi + ma ) * 0.5 ); }\n\n\/\/ trying many apis to see what sticks.\n\nfloat sd_bounds_range_round( vec2 p, vec2 mi, vec2 ma, float r )\n{\n\tvec2 h = ( ma - mi ) * 0.5;\n\tp = abs( p - ( mi + ma ) * 0.5 );\n\tvec2 c = h - r;\n\tfloat mask = max( step( c.x, p.x ), step( c.y, p.y ) );\n\treturn mix( -r + max( ( p - c ).x, ( p - c ).y ), length( max( p - c, 0.0 ) ) - r, mask );\n}\n\nfloat sd_bounds_half_size( float p, float h ) { p = abs( p ) - h; return p; }\nfloat sd_bounds_half_size( vec2 p, vec2 h ) { p = abs( p ) - h; return opI( p.x, p.y ); }\nfloat sd_bounds_half_size( vec3 p, vec3 h ) { p = abs( p ) - h; return opI( p.x, p.y, p.z ); }\nfloat sd_bounds_range( vec2 p, vec2 mi, vec2 ma ) { vec2 hmi = mi * 0.5; vec2 hma = ma * 0.5; return sd_bounds_half_size( p - ( hma + hmi ), hma - hmi ); }\n\/\/ those bounds repeat might be good after all, since they centering and lead to a correct repeat...\nfloat sd_bounds_range( float p, float mi, float ma ) { return sd_bounds_half_size( p - ( ( ma + mi ) * 0.5 ), ( ma - mi ) * 0.5 ); }\nfloat sd_bounds_range( vec3 p, vec3 mi, vec3 ma ) { return sd_bounds_half_size( p - ( ( ma + mi ) * 0.5 ), ( ma - mi ) * 0.5 ); }\nfloat sd_bounds( vec2 p, bounds2 b ) { return sd_bounds_range( p, b.pmin, b.pmax ); }\nfloat sd_bounds( vec3 p, bounds3 b ) { return sd_bounds_range( p, b.pmin, b.pmax ); }\n\/\/ see sd_bounds_repeat_range_range instead of sd_bounds_repeat_size_margin\nfloat sd_bounds_repeat_size_margin( float p, float size, float margin ) { return sd_bounds_range( repeat( p, size ), margin, size - margin ); }\nfloat sd_bounds_repeat_size_margin( vec2 p, vec2 size, vec2 margin ) { return sd_bounds_range( repeat( p, size ), margin, size - margin ); }\nfloat sd_bounds_repeat_size_margin( vec3 p, vec3 size, vec3 margin ) { return sd_bounds_range( repeat( p, size ), margin, size - margin ); }\n\/\/ repeat bounds with margin, (mi1,ma1) is included inside (mi,ma)\nfloat sd_bounds_repeat_range_range( float p, float mi, float ma, float mi1, float ma1 ) { return maxcomp( tri_b( p, mi, ma, mi1, ma1 ) ); }\nfloat sd_bounds_repeat_range_range( vec2 p, vec2 mi, vec2 ma, vec2 mi1, vec2 ma1 ) { return maxcomp( tri_b( p, mi, ma, mi1, ma1 ) ); }\n\n\/\/ https:\/\/learnopengl.com\/#!PBR\/Theory\n\/\/ http:\/\/graphicrants.blogspot.jp\/\n\/\/ alpha = roughness*roughness and \"m stands for the microfacet normal... in practice you input the half vector for m\"\n\/\/ Trowbridge-Reitz\nfloat D_GGX( float m_dot_n, float alpha ) { float alpha_sqr = alpha * alpha; return alpha_sqr \/ ( PI * pow2( pow2( m_dot_n ) * ( alpha_sqr - 1. ) + 1. ) ); }\nfloat G_kelemen( float n_dot_l, float n_dot_v, float v_dot_h ) { return n_dot_l * n_dot_v \/ pow2( v_dot_h ); }\nfloat F_none( float v_dot_h, float F0 ) { return F0; }\nfloat F_schlick( float v_dot_h, float F0 ) { return F0 + ( 1. - F0 ) * pow5( 1. - v_dot_h ); }\n\n\/\/ I am not going to pretend anything is physically realistic here, but at least try to use standardized functions\n\/\/ v = wi\nvec3 add_light_contrib( vec3 albedo, vec3 l, vec3 n, vec3 v, vec3 Li, float dwi, float kdiffuse, float kspecular, float roughness )\n{\n\tfloat F0 = 0.08;\n\tfloat alpha = roughness * roughness;\n\tvec3 h = normalize( l + v );\n\tfloat eps = 1e-4; \/\/ else divides by zero\n\tfloat n_dot_l = max( eps, dot( n, l ) );\n\tfloat n_dot_v = max( eps, dot( n, v ) );\n\tfloat n_dot_h = max( eps, dot( n, h ) );\n\tfloat v_dot_h = max( eps, dot( h, v ) );\n\tfloat D = D_GGX( n_dot_h, alpha ); \/\/ n_dot_h should probably be clamped to >=0\n\tfloat G = G_kelemen( n_dot_l, n_dot_v, v_dot_h );\n\/\/\tfloat F = F_none( n_dot_v, F0 );\n\tfloat F = F_schlick( n_dot_v, F0 );\n\/\/\tfloat F = F_schlick( n_dot_h, F0 ); \/\/ can't be right\n\treturn ( ( kdiffuse * albedo * ( 1. \/ PI )\n\t\t\t   + kspecular * ( D * F * G ) \/ ( 4. * n_dot_l * n_dot_v ) ) ) * Li * n_dot_l * dwi;\n}\n\n\/\/http:\/\/www.cs.utah.edu\/~reinhard\/cdrom\/tonemap.pdf\nvec3 tonemap_reinhard( vec3 x ) { return x \/ ( 1. + x ); }\n\nvec3 gamma_correction( vec3 L ) { return pow( L, vec3( 0.45 ) ); }\n\/\/ mentioned in http:\/\/resources.mpi-inf.mpg.de\/tmo\/logmap\/ , more dark tones friendly than just pow(L,0.45)\nvec3 gamma_correction_itu( vec3 L ) { return mix( 4.5061986 * L, 1.099 * pow( L, vec3( 0.45 ) ) - 0.099, step( vec3( 0.018 ), L ) ); }\n\n\/\/ returns 0 if v component is zero, rcp else, pass s = sign( v ) (values for s are -1, 0, 1)\nvec3 zrcp( vec3 v, vec3 s ) { s = abs( s ); return s \/ ( ( s - vec3( 1. ) ) + v ); }\n\n\/\/ encapsulate dda iteration a little bit for readability\nstruct DDA3\n{\n\tvec3 start, v; \/\/ v = end - start\n\tvec3 s; \/\/ sign(v)\n\tvec3 f1; \/\/ spacing (as a fraction of v, not distance) between 2 grid lines, to be multiplied by v to get a vector\n\tvec3 f; \/\/ segment intersects unit grid at points i = dda.start + ( dda.t[k] + i * dda.t1[k] ) * dda.v\n\tvec3 c; \/\/ cell index we entered (coords of bottom left corner)\n\tint done; \/\/ iteration end condition\n\tvec3 am; \/\/ argmin used during iteration\n\tvec3 p; \/\/ which point we entered the cell from, or start, or end\n};\n\n\/\/ iterate on p = dda.start + ( dda.end - dda.start ) * dda.alpha such that p intersect canonical dda.a\n\/\/ supporting arbitrary cell size is not much more expensive so we do it\nDDA3 dda_init( vec3 a_start, vec3 a_end, vec3 a_size, bool a_finite )\n{\n\tDDA3 dda;\n\tdda.start = a_start;\n\tdda.v = a_end - a_start;\n\tdda.s = sign( dda.v ); \/\/ -1, 0, 1\n#if 0\n\tvec3 v_zrcp = zrcp( dda.v, dda.s );\n#else\n\tvec3 v_zrcp = vec3( 1. ) \/ dda.v; \/\/ divide by zero\n#endif\n\tvec3 cell_size_rcp = vec3( 1. ) \/ a_size;\n\tdda.c = floor( a_start * cell_size_rcp ); \/\/ start cell\n\tdda.f = ( ( dda.c + ( dda.s + vec3( 1. ) ) * 0.5 ) * a_size - a_start ) * v_zrcp; \/\/ go positive or negative direction, initial fractional t\n\n\t\/\/ do this only for dda_step_segment\n\tif ( a_finite ) dda.f = min( vec3( 1. ), dda.f + 1. - abs( dda.s ) ); \/\/ if the sign is 0, set t to 1, meaning we are done on this axis\n\n\tdda.f1 = dda.s * v_zrcp * a_size; \/\/ per axis grid steping as a fraction of v\n\tdda.done = 0;\n\tdda.am = vec3( 0. );\n\tdda.p = dda.start;\n\treturn dda;\n}\n\n\/\/ returns 1,0,0 if x is the min, 0,1,0 if y is the min, 0,0,1 if z is the min (function code is from iq's shader)\n\/\/ very good for shader because we don't have to use random access which is sometimes borked in surprising ways\nvec3 argminv( vec3 v ) { return step( v.xyz, v.yxy ) * step( v.xyz, v.zzx ); }\n\n\/\/ iterate on all cells intersecting the input segment\n\/\/ make sure you called dda_init with a_finite = true\n\/\/ dda.done == 1 is the loop exit condition\n\/\/void dda_step_segment( inout DDA3 dda )\n\/\/{\n\/\/\tif ( sum( dda.f ) == 3. ) ++dda.done; \/\/ all 1. means we covered v and we should be at the end point\n\/\/\telse\n\/\/\t{\n\/\/\t\tdda.am = argminv( dda.f );\n\/\/\t\tdda.p = dda.start + sum( dda.am * dda.f ) * dda.v;\n\/\/\t\tdda.c += dda.am * dda.s;\n\/\/\t\tdda.f = min( dda.f + dda.am * dda.f1, vec3( 1. ) ); \/\/ next dda.f\n\/\/\t}\n\/\/}\n\n\/\/ iterate forever - if you don't care about iterating exactly the segment length, a bunch of things can be skipped\n\/\/ make sure you called dda_init with a_finite = false\nvoid dda_step_infinite( inout DDA3 dda )\n{\n\tdda.am = argminv( dda.f );\n\tdda.p = dda.start + sum( dda.am * dda.f ) * dda.v;\n\tdda.c += dda.am * dda.s;\n\tdda.f = dda.f + dda.am * dda.f1; \/\/ next dda.f\n}\n\nvec3 dda_point( in DDA3 dda, float f ) { return dda.start + dda.v * f; }\n\n\/\/ t0, t1 are t ranges along rays on each dimension, returns (union min, union max) range, ray intersects iff .y > .x\nvec2 intersect_ranges( vec3 t0, vec3 t1 )\n{\n\treturn vec2( maxcomp( vec3( min( t0.x, t1.x ), min( t0.y, t1.y ), min( t0.z, t1.z ) ) ),\n\t\t\t\t mincomp( vec3( max( t0.x, t1.x ), max( t0.y, t1.y ), max( t0.z, t1.z ) ) ) );\n}\n\nstruct Ranges_x4\n{\n\tvec2 rA, rB, rC, rD; \/\/ ranges along the ray, for each bound b[i]\n\tbounds3 bA, bB, bC, bD; \/\/ we could store bounds2 + height\n};\n\n\/\/ factorize and pack a few terms used in raytracing of 4 children bounds\n\nstruct Split4bSetup\n{\n\tvec3 drcp;\n\tfloat dz;\n\tvec3 dmargin;\n\tvec2 dmin, dmax;\n};\n\nSplit4bSetup setup_Split4b( Ray ray, vec2 amin, vec2 amax, vec2 margin )\n{\n\tSplit4bSetup set;\n\tset.drcp = vec3( 1. ) \/ ray.d; \/\/ divide by zero\n\tset.dmin = ( amin - ray.o.xy ) * set.drcp.xy;\n\tset.dmax = ( amax - ray.o.xy ) * set.drcp.xy;\n\tset.dz = ray.o.z * set.drcp.z;\n\tset.dmargin = vec3( margin * set.drcp.xy, 0. );\n\treturn set;\n}\n\n\/\/ --------------\n\/\/ |   |   | D  |\n\/\/ | A | B |----| amix.z\n\/\/ |   |   | C  |\n\/\/ --------------\n\/\/   amix.x amix.y\n\nvoid trace_Split4b_xxy( inout Ranges_x4 ret, Ray ray, in Split4bSetup set, vec3 amix, vec4 h )\n{\n\tvec3 set_dmix = ( amix - ray.o.xxy ) * set.drcp.xxy; \/\/ split axis described in amix are x,x,y\n\tret.rA = intersect_ranges( vec3( set.dmin.x, set.dmin.y, -set.dz ) + set.dmargin, vec3( set_dmix.x, set.dmax.y, h.x * set.drcp.z - set.dz ) - set.dmargin );\n\tret.rB = intersect_ranges( vec3( set_dmix.x, set.dmin.y, -set.dz ) + set.dmargin, vec3( set_dmix.y, set.dmax.y, h.y * set.drcp.z - set.dz ) - set.dmargin );\n\tret.rC = intersect_ranges( vec3( set_dmix.y, set.dmin.y, -set.dz ) + set.dmargin, vec3( set.dmax.x, set_dmix.z, h.z * set.drcp.z - set.dz ) - set.dmargin );\n\tret.rD = intersect_ranges( vec3( set_dmix.y, set_dmix.z, -set.dz ) + set.dmargin, vec3( set.dmax.x, set.dmax.y, h.w * set.drcp.z - set.dz ) - set.dmargin );\n}\n\nvoid bound_Split4b_xxy( inout Ranges_x4 ret, Ray ray, vec2 amin, vec2 amax, vec3 amix, vec4 h, vec2 margin )\n{\n\tvec3 m = vec3( margin, 0. );\n\tret.bA = mkbounds_unchecked( vec3( amin.x, amin.y, 0. ) + m, vec3( amix.x, amax.y, h.x ) - m );\n\tret.bB = mkbounds_unchecked( vec3( amix.x, amin.y, 0. ) + m, vec3( amix.y, amax.y, h.y ) - m );\n\tret.bC = mkbounds_unchecked( vec3( amix.y, amin.y, 0. ) + m, vec3( amax.x, amix.z, h.z ) - m );\n\tret.bD = mkbounds_unchecked( vec3( amix.y, amix.z, 0. ) + m, vec3( amax.x, amax.y, h.w ) - m );\n}\n\n\/\/ -----------------\n\/\/ |   |   |   |   |\n\/\/ | A | B | C | D |\n\/\/ |   |   |   |   |\n\/\/ -----------------\n\/\/   amix.x amix.y amix.z\n\nvoid trace_Split4b_xxx( inout Ranges_x4 ret, Ray ray, in Split4bSetup set, vec3 amix, vec4 h )\n{\n\tvec3 set_dmix = ( amix - ray.o.xxx ) * set.drcp.xxx; \/\/ split axis described in amix are x,x,x\n\tret.rA = intersect_ranges( vec3( set.dmin.x, set.dmin.y, -set.dz ) + set.dmargin, vec3( set_dmix.x, set.dmax.y, h.x * set.drcp.z - set.dz ) - set.dmargin );\n\tret.rB = intersect_ranges( vec3( set_dmix.x, set.dmin.y, -set.dz ) + set.dmargin, vec3( set_dmix.y, set.dmax.y, h.y * set.drcp.z - set.dz ) - set.dmargin );\n\tret.rC = intersect_ranges( vec3( set_dmix.y, set.dmin.y, -set.dz ) + set.dmargin, vec3( set_dmix.z, set.dmax.y, h.z * set.drcp.z - set.dz ) - set.dmargin );\n\tret.rD = intersect_ranges( vec3( set_dmix.z, set.dmin.y, -set.dz ) + set.dmargin, vec3( set.dmax.x, set.dmax.y, h.w * set.drcp.z - set.dz ) - set.dmargin );\n}\n\nvoid bound_Split4b_xxx( inout Ranges_x4 ret, Ray ray, vec2 amin, vec2 amax, vec3 amix, vec4 h, vec2 margin )\n{\n\tvec3 m = vec3( margin, 0. );\n\tret.bA = mkbounds_unchecked( vec3( amin.x, amin.y, 0. ) + m, vec3( amix.x, amax.y, h.x ) - m );\n\tret.bB = mkbounds_unchecked( vec3( amix.x, amin.y, 0. ) + m, vec3( amix.y, amax.y, h.y ) - m );\n\tret.bC = mkbounds_unchecked( vec3( amix.y, amin.y, 0. ) + m, vec3( amix.z, amax.y, h.z ) - m );\n\tret.bD = mkbounds_unchecked( vec3( amix.z, amin.y, 0. ) + m, vec3( amax.x, amax.y, h.w ) - m );\n}\n\n\/\/        -----------\n\/\/        |  C |    |\n\/\/ amix.y |----| D  |\n\/\/        |  A |----| amix.z\n\/\/        |    | B  |\n\/\/        -----------\n\/\/           amix.x\n\nvoid trace_Split4b_xyy( inout Ranges_x4 ret, Ray ray, in Split4bSetup set, vec3 amix, vec4 h )\n{\n\tvec3 set_dmix = ( amix - ray.o.xyy ) * set.drcp.xyy; \/\/ split axis described in amix are x,x,y\n\tret.rA = intersect_ranges( vec3( set.dmin.x, set.dmin.y, -set.dz ) + set.dmargin, vec3( set_dmix.x, set_dmix.y, h.x * set.drcp.z - set.dz ) - set.dmargin );\n\tret.rB = intersect_ranges( vec3( set_dmix.x, set.dmin.y, -set.dz ) + set.dmargin, vec3( set.dmax.x, set_dmix.z, h.y * set.drcp.z - set.dz ) - set.dmargin );\n\tret.rC = intersect_ranges( vec3( set.dmin.x, set_dmix.y, -set.dz ) + set.dmargin, vec3( set_dmix.x, set.dmax.y, h.z * set.drcp.z - set.dz ) - set.dmargin );\n\tret.rD = intersect_ranges( vec3( set_dmix.x, set_dmix.z, -set.dz ) + set.dmargin, vec3( set.dmax.x, set.dmax.y, h.w * set.drcp.z - set.dz ) - set.dmargin );\n}\n\nvoid bound_Split4b_xyy( inout Ranges_x4 ret, Ray ray, vec2 amin, vec2 amax, vec3 amix, vec4 h, vec2 margin )\n{\n\tvec3 m = vec3( margin, 0. );\n\tret.bA = mkbounds_unchecked( vec3( amin.x, amin.y, 0. ) + m, vec3( amix.x, amix.y, h.x ) - m );\n\tret.bB = mkbounds_unchecked( vec3( amix.x, amin.y, 0. ) + m, vec3( amax.x, amix.z, h.y ) - m );\n\tret.bC = mkbounds_unchecked( vec3( amin.x, amix.y, 0. ) + m, vec3( amix.x, amax.y, h.z ) - m );\n\tret.bD = mkbounds_unchecked( vec3( amix.x, amix.z, 0. ) + m, vec3( amax.x, amax.y, h.w ) - m );\n}\n\n\/\/  -------------\n\/\/  |   | D |   |\n\/\/  |   |   |   |\n\/\/  | A |---| C | amix.y\n\/\/  |   | B |   |\n\/\/  -------------\n\/\/  amix.x amix.z\n\nvoid trace_Split4b_xyx( inout Ranges_x4 ret, Ray ray, in Split4bSetup set, vec3 amix, vec4 h )\n{\n\tvec3 set_dmix = ( amix - ray.o.xyx ) * set.drcp.xyx; \/\/ split axis described in amix are x,x,y\n\tret.rA = intersect_ranges( vec3( set.dmin.x, set.dmin.y, -set.dz ) + set.dmargin, vec3( set_dmix.x, set.dmax.y, h.x * set.drcp.z - set.dz ) - set.dmargin );\n\tret.rB = intersect_ranges( vec3( set_dmix.x, set.dmin.y, -set.dz ) + set.dmargin, vec3( set_dmix.z, set_dmix.y, h.y * set.drcp.z - set.dz ) - set.dmargin );\n\tret.rC = intersect_ranges( vec3( set_dmix.z, set.dmin.y, -set.dz ) + set.dmargin, vec3( set.dmax.x, set.dmax.y, h.z * set.drcp.z - set.dz ) - set.dmargin );\n\tret.rD = intersect_ranges( vec3( set_dmix.x, set_dmix.y, -set.dz ) + set.dmargin, vec3( set_dmix.z, set.dmax.y, h.w * set.drcp.z - set.dz ) - set.dmargin );\n}\n\nvoid bound_Split4b_xyx( inout Ranges_x4 ret, Ray ray, vec2 amin, vec2 amax, vec3 amix, vec4 h, vec2 margin )\n{\n\tvec3 m = vec3( margin, 0. );\n\tret.bA = mkbounds_unchecked( vec3( amin.x, amin.y, 0. ) + m, vec3( amix.x, amax.y, h.x ) - m );\n\tret.bB = mkbounds_unchecked( vec3( amix.x, amin.y, 0. ) + m, vec3( amix.z, amix.y, h.y ) - m );\n\tret.bC = mkbounds_unchecked( vec3( amix.z, amin.y, 0. ) + m, vec3( amax.x, amax.y, h.z ) - m );\n\tret.bD = mkbounds_unchecked( vec3( amix.x, amix.y, 0. ) + m, vec3( amix.z, amax.y, h.w ) - m );\n}\n\n\/\/ turn n relative sizes (unit don't matter, only respective sizes do) into n-1 unit size offsets\nvec2 fractions( vec3 r ) { float sum_f_xy = r.x + r.y; float sum_f_xyz = sum_f_xy + r.z; return vec2( r.x, sum_f_xy ) \/ sum_f_xyz; }\nvec3 fractions( vec4 r ) { float sum_f_xy = r.x + r.y; float sum_f_xyz = sum_f_xy + r.z; float sum_f_xyzw = sum_f_xyz + r.w; return vec3( r.x, sum_f_xy, sum_f_xyz ) \/ sum_f_xyzw; }\n\n\/\/ -------------------------------------------------------- shader begin\n\n\/\/\/ expression is true when shadow has found a hit and is no longer interested in tracing the rest of everything - this helps quite a bit\n#define SHADOW_EARLY_RET(a_t) (shadow_trace&&((a_t)!=FLT_MAX))\n\/\/\/#define SHADOW_EARLY_RET(a_t) false\n\/\/\/ tweak this value to minimize grainy artifacts due to distance to highway center line (used for many things, facades, highway objects etc)\n#define CURVE_DISTANCE_EPSILON_OF_DEATH 0.001\n\n\/\/\/ the number of iterations we need to trace in a dda cell is a bit less than a would be full scene trace,\n\/\/\/ since we are already close to the surface thanks to the preliminary raytrace\n\/\/\/ but there is no magic, and if you are standing on a roof top you need more steps to close parallel planes\n\/\/\/ what we do is we give ebough steps (~70) but early return past a certain distance if there was no hit\n#define DDA_CELL_SDF_MARCH_MAX_ITERATIONS 70\n\/\/\/ ...which is fine because DDA cell have an intrinsic max trace distance anyway, and we need to use it as it is a big optim (regardless of trace holes when we stand on roof tops)\n\/\/\/ fun anecdote: I overlooked that *major* optimization and bumped into it by chance during final tuning when trying to fix the roof top coffee break camera :-) \n#define ENABLE_MAX_DDA_TRACE_DISTANCE\n\n#define MAX_DDA_ITER 37\n#define MAX_DDA_TRACE 640. \n#define MAX_HIGHWAY_TRACE 640. \n#define FADE_START 480. \n\n\/\/\/ dda cell size, each cell is a tile then split into 4 children each containing a building\n#define CELL_SIZE vec3( 8., 8., 100. ) \n\/\/\/ x = small spacing (back streets), y = large spacing (roads)\n#define CELL_SPACING vec2( 0.47, 1.3 ) \n\n\/\/\/ TYPE_BUILDING: 0.,1.,2.,3 (=0+tile_child_index)\n\/\/\/ TYPE_HOUSE: 4.,5.,6.,7 (=4+tile_child_index)\n#define TYPE_HIGHWAY 8.\n#define TYPE_ROAD 9. \n#define TYPE_SKY 10. \n\n#define MAX_BUILDING_HEIGHT 14.3 \n\n#define AO_BEGIN() \\\n\t{ \/* ao algo from https:\/\/iquilezles.org\/www\/material\/nvscene2008\/rwwtt.pdf macrofified to avoid repetition *\/ \\\n\t\tfloat _delta = 0.1, _a = 0.0, _b = 1.0; \\\n\t\tfor ( int _i = 0; _i < 5 FORCE_LOOP_AO; _i++ ) \\\n\t\t{ \\\n\t\t\tfloat _fi = float( _i ); \\\n\t\t\tfloat _ao_t = _delta * _fi; \\\n\n\/\/\/\t\t\tfloat d = sd_Object( p + delta * fi * n, 0, _t, _view_ray, ... ); \/\/ example\n\n#define AO_END(_ao_result) \\\n\t\t\t_a += ( _ao_t  - d ) * _b; \\\n\t\t\t_b *= 0.5; \\\n\t\t} \\\n\t\t_ao_result = max( 1.0 - 1.2 * _a, 0.0 ); \\\n\t} \\\n\nfloat sd_SurfaceFacade7( vec3 p, float dAll )\n{\n\tdAll -= -0.142857149;\n\tvec3 _p1 = p; vec2 _ci1 = vec2( 0.649999976, 0.375 ); vec2 _hp1 = vec2( 0.625, 0.300000011 ); vec2 _hw1 = vec2( 0.150000005, 0.074999988 ); vec2 _2hp1_rcp = vec2( 0.800000011, 1.666666626 ); _p1.xy -= _ci1; _p1.xy = -tri_p( _p1.xy, _hw1, _hp1 ); float _d1 = maxcomp( _p1.xy ); _d1 = opI( _d1, opB_range( p.z, -0.171428576, 0. ) );\n\tvec3 _p2 = p; vec2 _ci2 = vec2( 0.400000005, 0.234999999 ); vec2 _hp2 = vec2( 0.5, 0.300000011 ); vec2 _hw2 = vec2( 0.400000005, 0.015 ); vec2 _2hp2_rcp = vec2( 1, 1.666666626 ); _p2.xy -= _ci2; float _d2 = -tri_p( _p2.y, 0.015, 0.300000011 ); _d2 = opI( _d2, opB_range( p.z, -0.142857149, -0.128571435 ) );\n\tdAll = opS_hard_bevel( dAll, _d1, 0.007805752 );\n\tdAll = opU( dAll, _d2 );\n\treturn dAll;\n}\n\n#define FLOOR_HEIGHT \/*FLOOR_HEIGHT*\/0.6\n\nfloat sd_SurfaceFacade10( vec3 p, float dAll )\n{\n\tvec3 _p1 = p; vec2 _ci1 = vec2( 0.570779979, 0.031555999 ); vec2 _hp1 = vec2( 0.569999992, 0.029999999 ); vec2 _hw1 = vec2( 0.560779988, 0.021556001 ); vec2 _2hp1_rcp = vec2( 0.877192974, 16.666667938 ); _p1.xy -= _ci1; _p1.xy = -tri_p( _p1.xy, _hw1, _hp1 ); float _d1 = maxcomp( _p1.xy ); _d1 = opI( _d1, opB_range( p.z, -0.028571428, 0.100000001 ) );\n\tdAll = opS_hard_bevel( dAll, _d1, 0.003604186 );\n\treturn dAll; \/\/ return vec3(dAll,-0.028571428,0.100000001);\n}\n\nvec2 sd_SurfaceFacade0( vec3 p, float dAll )\n{\n\tdAll -= -0.100000001;\n\tvec3 _p2 = p; vec2 _ci2 = vec2( 0.25, 0.362500011 ); vec2 _hp2 = vec2( 1., 0.300000011 ); vec2 _hw2 = vec2( 0.75, 0.137500002 ); vec2 _2hp2_rcp = vec2( 0.5, 1.666666626 ); _p2.xy -= _ci2; _p2.xy = -tri_p( _p2.xy, _hw2, _hp2 ); float _d2 = maxcomp( _p2.xy ); _d2 = opI( _d2, opB_range( p.z, -0.200000002, 0. ) );\n\tvec3 _p3 = p; vec2 _ci3 = vec2( -0.75, 0.300000011 ); vec2 _hp3 = vec2( 1., 0.300000011 ); vec2 _hw3 = vec2( 0.112500011, 0.300000011 ); vec2 _2hp3_rcp = vec2( 0.5, 1.666666626 ); _p3.xy -= _ci3; float _d3 = -tri_p( _p3.x, 0.112500011, 1. ); _d3 = opI( _d3, opB_range( p.z, -0.200000002, 0. ) );\n\tvec3 _p1 = p; vec2 _ci1 = vec2( 0.75, 0.362499982 ); vec2 _hp1 = vec2( 0.25, 0.300000011 ); vec2 _hw1 = vec2( 0.25, 0.147500008 ); vec2 _2hp1_rcp = vec2( 2, 1.666666626 ); _p1.xy -= _ci1; _p1.xy = -tri_p( _p1.xy, _hw1, _hp1 ); float _d1 = maxcomp( _p1.xy ); \/*band*\/_d1 = opB_rc( _d1, 0.008236314, 0.0 ); _d1 = opI( _d1, opB_range( p.z, -0.200000002, -0.19428572 ) );\n\tdAll = opS_hard_bevel( dAll, _d2, 0.007714285 );\n\tdAll = opU_hard_bevel( dAll, _d3, 0.009999996 );\n\tdAll = opU_hard_bevel( dAll, _d1, 0.005900437 );\n\treturn vec2( dAll, p.z + 0.200000002 ); \/\/ return vec3(dAll,0,0.200000002);\n}\n\nvec2 sd_SurfaceFacade8( vec3 p, float dAll )\n{\n\tvec3 _p3 = p; vec2 _ci3 = vec2( 0.200000002, 0.685000002 ); vec2 _hp3 = vec2( 0.354999989, 0.459999978 ); vec2 _hw3 = vec2( 0.149999991, 0.115000009 ); vec2 _2hp3_rcp = vec2( 1.408450722, 1.08695662 ); _p3.xy -= _ci3; _p3.xy = -tri_p( _p3.xy, _hw3, _hp3 ); float _d3 = maxcomp( _p3.xy ); _d3 = opI( _d3, opB_range( p.z, -0.057142857, 0.014285714 ) );\n\tvec3 _p1 = p; vec2 _ci1 = vec2( 0.200000002, 0.685000002 ); vec2 _hp1 = vec2( 0.354999989, 0.459999978 ); vec2 _hw1 = vec2( 0.149999991, 0.115000009 ); vec2 _2hp1_rcp = vec2( 1.408450722, 1.08695662 ); _p1.xy -= _ci1; _p1.xy = -tri_p( _p1.xy, _hw1, _hp1 ); float _d1 = maxcomp( _p1.xy ); \/*band*\/_d1 = opB_rc( _d1, 0.002559998, 0.0 ); _d1 = opI( _d1, opB_range( p.z, -0.071428574, 0. ) );\n\tvec3 _p2 = p; vec2 _ci2 = vec2( 0.287499994, 0.684999942 ); vec2 _hp2 = vec2( 0.354999989, 0.459999978 ); vec2 _hw2 = vec2( 0.057500004, 0.109999984 ); vec2 _2hp2_rcp = vec2( 1.408450722, 1.08695662 ); _p2.xy -= _ci2; _p2.xy = -tri_p( _p2.xy, _hw2, _hp2 ); float _d2 = maxcomp( _p2.xy ); \/*band*\/_d2 = opB_rc( _d2, 0.003154247, 0.0 ); _d2 = opI( _d2, opB_range( p.z, -0.085714288, -0.028571428 ) );\n\tdAll = opS_hard_bevel( dAll, _d3, 0.000975659 );\n\tdAll = opU_hard_bevel( dAll, _d1, 0.000975659 );\n\tdAll = opU_hard_bevel( dAll, _d2, 0.000138338 );\n\treturn vec2( dAll, p.z + 0.057142857 ); \/\/ return vec3(dAll,-0.085714288,0.014285714);\n}\n\n\/\/ function used to make roof tiles\n\/\/ a1 is the slope of curve going up (1.)\n\/\/ a2 is the slope of curve going down (-2.)\n\/\/ p is the period\nfloat hard_waves( float x, float a1, float a2, float p ) { x = repeat( x, p ); x = min( a1 * x, a2 * x - a2 * p ); return x; }\n\n\/\/ roof tiles height field (hf)\nfloat hf_SurfaceRoofTiles( vec2 p ) { return ( 0.4 * hard_waves( p.y, 0.3, -1.6, 0.19 ) + 0.02 * abs( sin( p.x * 30. ) ) ); }\n\n\/\/ build diagonal scopes on the top edges of a bounds b \"extruded\" by h\n\/\/ they can be used as support planes for roof surface\n\/\/ return value is a 3d point local to those symetrized diagonal plane spaces, that can be used to map the roof surface\n\/\/ return value's .z is the distance to plane\n\/\/ slope_ctrl controls the steepness of the roof planes, 1. for identity\n\/\/ h is height of base house walls\n\/\/ b is base\/ground 2d scope bounds\n\/\/ p is input world pos\n\/\/ we don't return a scope because we are mirroring things here, Scope's .b and .dcc would have no sense\nvec3 getRoofLocalX( vec3 p, float slope_ctrl, bounds2 b, float h )\n{\n\t\/\/ gable roof with tiled surface\n\tfloat hw = ( b.pmax.x - b.pmin.x ) * 0.5; \/\/ half width\n\tfloat cx = ( b.pmax.x + b.pmin.x ) * 0.5; \/\/ center\n\tfloat h2 = hw * slope_ctrl; \/\/ roof height\n\tvec2 v = vec2( abs( p.x - cx ), p.z - ( h + h2 ) );\n\tvec2 yy = normalize( vec2( hw, -h2 ) );\n\treturn vec3( p.y, dot( v, yy ), dot( v, perp( yy ) ) );\n}\n\nvec3 getRoofLocalY( vec3 p, float slope_ctrl, bounds2 b, float h )\n{\n\t\/\/ gable roof with tiled surface\n\tfloat hw = ( b.pmax.y - b.pmin.y ) * 0.5; \/\/ half width\n\tfloat cy = ( b.pmax.y + b.pmin.y ) * 0.5; \/\/ center\n\tfloat h2 = hw * slope_ctrl; \/\/ roof height\n\tvec2 v = vec2( abs( p.y - cy ), p.z - ( h + h2 ) );\n\tvec2 yy = normalize( vec2( hw, -h2 ) );\n\treturn vec3( p.x, dot( v, yy ), dot( v, perp( yy ) ) );\n}\n\n\/\/ rudimentary concept of \"scope\" for facade, roof surfaces etc.\nstruct Scope\n{\n\tvec3 p; \/\/ point in scope space, plane at p.z = 0\n\tbounds2 b; \/\/ bounds of scope shape, for clipping\/shape cast\n\tfloat dcc; \/\/ df of scope shape (\"cookie cutter\"), for clipping\/shape cast, should be included in .b for consistancy\n\tfloat t; \/\/ marching distance, used for error thresholds, \"inflating\" detail etc.\n};\n\nScope getScopeFacadeX( Scope base, float h, int select_side )\n{\n\tScope facade;\n\tfacade.b = mkbounds_unchecked( vec2( base.b.pmin.y, 0.0 ), vec2( base.b.pmax.y, h ) );\n\t\/\/ note: we just flip the sign of p.x for the other side, it will horizontally flip the content but most often we don't care\n\tif ( select_side == ( 1 | 2 ) ) facade.p = vec3( base.p.y, base.p.z, abs( base.p.x - center( base.b ).x ) - size( base.b ).x * 0.5 );\n\telse if ( select_side == 1 ) facade.p = vec3( base.p.y, base.p.z, base.p.x - base.b.pmax.x );\n\telse if ( select_side == 2 ) facade.p = vec3( base.p.y, base.p.z, -base.p.x + base.b.pmin.x );\n\tfacade.dcc = sd_bounds( facade.p.xy, facade.b );\n\treturn facade;\n}\n\nScope getScopeFacadeY( Scope base, float h, int select_side )\n{\n\tScope facade;\n\tfacade.b = mkbounds_unchecked( vec2( base.b.pmin.x, 0.0 ), vec2( base.b.pmax.x, h ) );\n\t\/\/ note: we just flip the sign of p.x for the other side, it will horizontally flip the content but most often we don't care\n\tif ( select_side == ( 1 | 2 ) ) facade.p = vec3( base.p.x, base.p.z, abs( base.p.y - center( base.b ).y ) - size( base.b ).y * 0.5 );\n\telse if ( select_side == 1 ) facade.p = vec3( base.p.x, base.p.z, base.p.y - base.b.pmax.y );\n\telse if ( select_side == 2 ) facade.p = vec3( base.p.x, base.p.z, -base.p.y + base.b.pmin.y );\n\tfacade.dcc = sd_bounds( facade.p.xy, facade.b );\n\treturn facade;\n}\n\nfloat sd_RoofTopObject2( float dsofar, Scope roof, float h, vec3 rnd )\n{\n\th *= 0.6 + 0.4 * mod( rnd.y, 4. ) * ( 1. \/ 3.333 );\n\tfloat roof_geom_max_height = 0.025; \/\/ a rough but conservative estimate of roof geometry height\n\th = max( 0., h - roof_geom_max_height ); \/\/ fixme: hack: make sure h is bounding height instead\n\t\/\/ select a small bounds b0 as a fraction of b, that we are going to repeat\n\tbounds2 b0 = mkbounds_unchecked_gx( roof.b, vec2( 0.1, 0.1 ), vec2( -0.7, -0.7 ) );\n\t\/\/ select a subgrid, range of b0 we want to keep, store range in b3\n\tvec2 gridsize = vec2( 1. + mod( rnd.x, 4. ), 1. );\n\tbounds2 b3 = mkbounds_unchecked_gx( b0, vec2( 0., 0. ), gridsize - vec2( 1. ) );\n\n\/\/\tif ( dsofar < sd_bounds_range( roof.p, vec3( b3.pmin, 0. ), vec3( b3.pmax, h ) ) || roof.p.z < 0. ) return dsofar; \/\/ early return if the roof object is further than dsofar, not necesserarily a win...\n\n\t\/\/ inside that select a centered bounds b1\n\tbounds2 b1 = mkbounds_unchecked_gx( b0, vec2( 0.1, 0.1 ), vec2( -0.1, -0.1 ) );\n\tvec3 p2 = roof.p;\n\tp2.xy = repeat_b( p2.xy, b0 ); \/\/ remember: b1 must be centered inside b0!\n\n\tScope base = roof;\n\tbase.p = p2;\n\tbase.b = b1;\n\tbase.dcc = sd_bounds( base.p.xy, base.b );\n\tbase.dcc = opI( base.dcc, sd_bounds( roof.p.xy, b3 ) ); \/\/ only keep b3 area\n\n\t\/\/ select a subgrid (clip against)\n\tfloat d = opI( base.p.z - h, base.dcc );\n\td = opI( -base.p.z, d );\n\/\/\td = opI( d, sd_bounds( roof.p.xy, mkbounds_unchecked_gx( b0, vec2( 0, 0 ), vec2( 2, 1 ) ) ) );\n\n\t{\n\t\t\/\/ facade\n\t\tScope facade = getScopeFacadeY( base, h, 3 );\n\t\tvec3 p3 = facade.p;\n\t\tp3.xy *= 2.; float d2 = sd_SurfaceFacade10( p3, facade.p.z );\n\t\td = opI( d2, d );\n\t}\n\n\t{\n\t\t\/\/ roof small border wall on top of object\n\t\tScope roof2 = base;\n\t\troof2.p.z -= h;\n\t\tfloat small_roof_border = opB_inside( roof2.dcc, 0.01 );\n\t\tsmall_roof_border = opI( small_roof_border, opB_inside( -roof2.p.z, roof_geom_max_height ) );\n\t\td = opU( d, small_roof_border );\n\t}\n\n\treturn opI( d, roof.dcc );\n}\n\nfloat sd_JPBuildingRoofTopWithObjects( float d, Scope roof, float roof_geom_max_height, bool enable_objects, vec3 rnd )\n{\n\t\/\/ roof small border wall\n\tfloat dborder = opB_inside( roof.dcc, 0.02 );\n\tdborder = opI( dborder, opB_inside( -roof.p.z, 0.05 ) );\n\t\/\/ roof ground tiles, perhaps this should be textured but never mind. we get more detail\n\tfloat tile_size = 0.05;\n\tfloat dtiles = -mincomp( tri_s( roof.p.xy, vec2( tile_size * 0.5 ), vec2( 0.005 ) ) );\n\tdtiles = opI( roof.dcc + 0.05, dtiles ) + roof.t * 0.004; \/\/ add t in spacing so we can see it from far away\n\tdtiles = opI_round_bevel( dtiles, opB_range( roof.p.z, -0.001, 0.0025 ), 0.00125, 0.75 );\n\td = opU( d, opU( dtiles, dborder ) );\n\tif ( enable_objects )\n\t{\n\t\t\/\/ parametric model for small features on roof\n\t\tScope roof_object_scope = roof;\n\t\tfloat droof_object = FLT_MAX;\n\t\tdroof_object = sd_RoofTopObject2( d, roof_object_scope, roof_geom_max_height, rnd );\n\/\/\t\tdroof_object = opI( droof_object, -roof.p.z ); \/\/ cut all the bits below roof object level\n\t\td = opU( d, droof_object );\n\t}\n\treturn d;\n}\n\n#define ROAD_HALFWIDTH (1.)\n#define ROAD_WIDTH (ROAD_HALFWIDTH*2.)\n\n\/\/ distance to highway center line requires special care in this shader\nstruct NearestHighwayRetval\n{\n\tvec2 p; \/\/ query point\n\tvec2 pr; \/\/ query point in y repeat space\n\tfloat d; \/\/ distance to center line == length(d2f.xy)\n\tvec4 d2f; \/\/ .xy is vector to closest point, .zw is the tangent at closest point\n\tvec2 o_clip, n_clip; \/\/ clip plane so we can build clean clip facades for buildings in contact with the highway\n};\n\n\/\/ building sdf eval return value\nstruct ParametricBuildingRetval\n{\n\tfloat d, droof; \/\/ distance to building and distance to closest roof point for coloring\n\tvec3 windr; \/\/ distance to window in .x, windows 2d orientation in .zw (orientation is for better categorizing of pixels)\n};\n\n\/\/ modern buildings, most often square but can be clipped by nearby highways\nParametricBuildingRetval sd_Building( float t, vec3 p, bounds2 b, float h, NearestHighwayRetval nh, vec3 rnd )\n{\n\tfloat roof_geom_max_height = 0.3; \/\/ a rough but conservative estimate of roof geometry height\n\th -= roof_geom_max_height; \/\/ fixme: hack: make sure h is bounding height instead\n\n\t\/\/ some building base scope\n\tScope base;\n\tbase.p = p;\n\tbase.b = b;\n\tbase.dcc = sd_bounds( base.p.xy, base.b );\n\tbase.t = t;\n\n\tfloat d = -FLT_MAX; \/\/ opI( base.p.z - h, base.dcc ) is the base block, if you want to visualize it for debug\n\n\tvec3 windr = vec3( FLT_MAX );\n\n\t{\n\t\t\/\/ front facade\n\t\tScope facade = getScopeFacadeX( base, h, 3 );\n\t\tvec2 d1 = sd_SurfaceFacade0( facade.p, facade.p.z );\n\t\td = opI( d1.x, d );\n\t\twindr = vec3( d1.y, vec2( 1., 0. ) );\n\t}\n\n\t{\n\t\t\/\/ back facade with flat windows\n\t\tScope facade = getScopeFacadeY( base, h, 3 );\n\t\tfloat d2 = sd_SurfaceFacade7( facade.p, facade.p.z );\n\t\td = opI( d2, d );\n\t}\n\n\t#ifdef HIGHWAY_CLIP\n\tif ( nh.d != FLT_MAX )\n\t{\n\t\t\/\/ highway facing facade using nearest highway clip plane\n\t\tfloat d10 = dot( p.xy - nh.o_clip, nh.n_clip ) - ROAD_HALFWIDTH * 1.3;\n\t\tvec3 pr = vec3( dot( p.xy, perp( nh.n_clip ) ), p.z, -d10 ); \/\/ pr is the point in 2d facade space\n\t\tvec2 d3 = sd_SurfaceFacade0( pr, pr.z );\n\t\td = opI( d3.x, d );\n\n\t\t\/\/ pick this window if it's closest\n\t\twindr = mix( windr, vec3( d3.y, nh.n_clip ), step( abs( d3.y ), abs( windr.x ) ) );\n\t}\n\t#endif\n\n\tfloat droof = d; \/\/ save d before we clamped base on h, that will give us a consistent base dcc to build the roof on\n\td = opI( d, base.p.z - h );\n\n\t#ifdef ROOF_OBJECTS\n\t{\n\t\tScope roof = base;\n\t\troof.p.z -= h;\n\t\troof.dcc = droof;\n\t\td = sd_JPBuildingRoofTopWithObjects( d, roof, roof_geom_max_height, true, rnd ); \/\/ roof with border + objects on it\n\t}\n\t#endif\n\n\tParametricBuildingRetval ret;\n\tret.d = d;\n\tret.windr = windr;\n\tret.droof = FLT_MAX;\n\treturn ret;\n}\n\n\/\/ house with a tiled roof (Kyoto has lots of those, though the roof type is different and here is just a super crude abstracted version)\nParametricBuildingRetval sd_House( vec3 p, float t, bounds2 b, float h, NearestHighwayRetval nh )\n{\n\th -= 1.4; \/\/ fixme: hack: make sure h is bounding height instead\n\tvec2 inset = size( b ) * 0.01; \/\/ b is conservative, the house must be included inside it\n\tb.pmin += inset; \/\/ we want roof to hang over a bit so shrink the base a bit\n\tb.pmax -= inset;\n\t\/\/ some building base scope\n\tScope base;\n\tbase.p = p;\n\tbase.b = b;\n\tbase.dcc = sd_bounds( base.p.xy, base.b );\n\tbase.t = t;\n\t\/\/ the base block, if you want to visualize it for debug\n\/\/\tfloat d = opI( base.p.z - h, base.dcc );\n\t\/\/ highway facing facade clipped using nearest highway clip plane\n\t#ifdef HIGHWAY_CLIP\n\tfloat d10 = nh.d != FLT_MAX ? dot( p.xy - nh.o_clip, nh.n_clip ) - ROAD_HALFWIDTH * 0.6 : FLT_MAX;\n\t#else\n\tfloat d10 = FLT_MAX;\n\t#endif\n\tbase.dcc = opI( -d10, base.dcc  ); \/\/ clip the base shape so that we still get a bit of roof hang over\n\n\tParametricBuildingRetval ret;\n\tfloat slope_ctrl = 0.7;\n\t\/\/ hip roof with tiled surface\n\tvec3 prfx = getRoofLocalX( p, slope_ctrl, base.b, h );\n\tfloat rfxd = opS( prfx.z - hf_SurfaceRoofTiles( prfx.xy ), prfx.z - ( -0.03 ) );\n\trfxd = opI( base.dcc - 0.15, rfxd ); \/\/ vertical cookie cut, wider for roof geom\n\tvec3 prfy = getRoofLocalY( p, slope_ctrl, base.b, h );\n\tfloat rfyd = opS( prfy.z - hf_SurfaceRoofTiles( prfy.xy ), prfy.z - ( -0.03 ) );\n\trfyd = opI( base.dcc - 0.15, rfyd ); \/\/ vertical cookie cut, wider for roof geom\n\t\/\/ add windows\n\tfloat dbottom = opI( base.dcc, opI( prfx.z, prfy.z ) );\n\tScope wall_s = getScopeFacadeY( base, h, 3 );\n\tvec3 pf = vec3( wall_s.p.xy * 1.0 - vec2( 0., -0.28 ), wall_s.p.z * 2. );\n\tvec2 df8 = sd_SurfaceFacade8( pf, dbottom );\n\tdbottom = opI( wall_s.dcc, df8.x ); \/\/ base + window carved in\n\tdbottom = opI( -d10, dbottom  ); \/\/ clip the base shape so that we still get a bit of roof hang over\n\tret.windr = vec3( df8.y, vec2( 0., 1. ) );\n\t\/\/ hip roof + roof surface\n\tret.droof = opU( opI( rfyd, prfx.z ), opI( rfxd, prfy.z ) ); \/\/ just roof surface\n\tret.d = opU( ret.droof, dbottom );\n\t\/\/ fill the empty bit under the roof (due to hang hover modeling),\n\t\/\/ which is visible when we did a highway clip\n\tfloat dz = ( p.z - h ) \/ slope_ctrl;\n\tret.d = opU( ret.d, opI( base.dcc + max( dz, 0. ), -dz ) );\n\treturn ret;\n}\n\n\/\/ highway curve as seem from above... wanted to do more complicated but stuck to the test curve instead\nvec2 sd_HighwayCurveXY( float x ) { float xt = repeat_mirror_e( x, -20., 20. ); return vec2( x, smoothstep( 0., 15., xt ) * 8. ); }\nvec3 sd_CameraCurveXY( float x ) { return vec3( x, sd_HighwayCurveXY( x ).y, 2.18 ); }\n\n\/\/ highways are repeated on y axis\nNearestHighwayRetval evalHighwaySetup( vec2 p )\n{\n\tNearestHighwayRetval hret;\n\thret.p = p.xy;\n\thret.pr = p.xy;\n\thret.pr.y = repeat_e( hret.pr.y, -35., 35. ); \/\/ note: mirror repeat wouldn't work\n\treturn hret;\n}\n\n\/\/ do the actual distance to highway evaluation\nNearestHighwayRetval evalHighway( vec2 p )\n{\n\tNearestHighwayRetval hret = evalHighwaySetup( p );\n\tvec4 ret;\n\tCLOSEST_POINT_TANGENT_TO_FUNC_21( ret, hret.pr.xy, sd_HighwayCurveXY, CURVE_DISTANCE_EPSILON_OF_DEATH * p.x, 2 );\n\thret.d = length( ret.xy ); \/\/ distance to center line, used in several places so cache\n\thret.d2f = ret;\n\treturn hret;\n}\n\n#define HIGHWAY_HEIGHT 2.\n\n\/\/ used for lamp top silhouette\nfloat crochet( float x, float s2, float s1, float a, float b, float ym ) { return max( min( 0., ( -( x - b ) ) * s1 ), ym ) + min( 0., ( x - a ) * s2 ); }\n\n\/\/ street lamp object\n\/\/ hw is the road half width\n\/\/ p2.xy is cross section along u\n\/\/ p2.y is already symmetric (distance to center)\nvec2 sd_Lamps( float u, vec2 p2, float hw, float lw, float lamp_height, float period )\n{\n\tvec2 p3 = p2.xy - vec2( hw, lamp_height ); \/\/ center to lamp corner\n\tfloat dline = opI( -dot( p3.xy, -V60 ), p3.x ); \/\/ lamp line\n\tfloat width = 0.04; \/\/ pole width\n\tfloat dslice = sd_bounds_repeat_range_range( u, 0., period, 0., width ); \/\/ slice\n\tdslice = opI( dslice, -p2.y ); \/\/ keep upper bit only\n\tfloat dpolebit = opB_outside( dline, 0.015 ); \/\/ only keep outside band\n\tdpolebit = opI( dpolebit, -p3.x - lw ); \/\/ subtract center bit\n\tfloat shrink = 0.004;\n\tfloat dlampbit = opB_inside( dline - shrink, 0.02 ); \/\/ only keep outside band, offset by shrink to ensure lamp geom stays in contact\n\tdlampbit = opI( dlampbit, -p3.x - lw ); \/\/ subtract center bit\n\tdlampbit = opI( dlampbit, -p2.y + lamp_height * 1.025 ); \/\/ only keep bit the top lamp bit (cut bottom)\n\tdlampbit += shrink; \/\/ make lamp geom smaller\n\tfloat d = opU( dpolebit, dlampbit );\n\td = opI( d, dslice - crochet( p3.x, 0.1, 0.75, -0.1, -0.05, -0.01 ) ); \/\/ extract a slice, and also make the slice slightly triangular\n\treturn vec2( d, dlampbit );\n}\n\n\/\/ there will be SIGN_N-1 signs visible per period (because of clipping in curvy bits)\n#define SIGN_N (3.)\n\/\/ pick a periodicity that doesn't expose the dodginess of the sdf in curvy sections\n#define SIGN_PERIOD (2.*20.\/SIGN_N)\n#define LDC_HEIGHT 0.3\n\n\/\/ highway signs (LCD screens)\nvec2 sd_HighwaySigns( float u, vec2 p2, float hw )\n{\n\tu = repeat_mirror_e( u, -20., 20. ); \/\/ same repeat as sd_HighwayCurveXY\n\tfloat period = SIGN_PERIOD;\n\tu += period * 0.5;\n\tfloat width = 0.04;\n\tfloat h2 = 1.2; \/\/ sign start h\n\tfloat h3 = LDC_HEIGHT; \/\/ sign end h\n\tfloat dslice = sd_bounds_repeat_range_range( u, 0., period, 0., width ); \/\/ slice\n\tdslice = opI( dslice, -p2.y ); \/\/ keep upper bit only\n\tvec2 p3 = p2.xy - vec2( hw, h2 ); \/\/ center to lamp corner\n\tfloat d8 = opB_outside( p3.x, 0.015 ); \/\/ only keep outside band\n\td8 = opI( d8, p3.y );\n\td8 = opU( d8, sd_bounds_range( p3, vec2( -hw, 0. ), vec2( 0.05, h3 ) ) );\n\treturn vec2( opI( d8, dslice ), FLT_MAX );\n}\n\n#define HIGHWAY_PAVEMENT_RATIO 0.5\n\n\/\/ ray marched city bits, this is global and has nothing to do with the dda\n\/\/ return value: .x closest distance, .y closest distance to light emitter material\nvec3 sd_RayMarchedCityBits( vec3 p, int lod )\n{\n\tfloat d = p.z - 0.; \/\/ zero ground\n\n\tNearestHighwayRetval hret = evalHighway( p.xy );\n\n\tfloat hw = ROAD_HALFWIDTH; \/\/ r1 is the half width\n\tfloat h = HIGHWAY_HEIGHT;\n\n\tvec3 crvp = vec3( hret.d, p.z, ( hret.pr + hret.d2f.xy ).x ); \/\/ curve 3d pos\n\n\tfloat d2 = sd_bounds_range( crvp.xy, vec2( 0.0, h - 0.05 ), vec2( hw, h ) ); \/\/ highway cross section main block\n\tfloat d3 = sd_bounds_range( crvp.xy, vec2( hw * 0.9, h - 0.01 ), vec2( hw * 1.01, h + 0.2 * 1.4 ) ); \/\/ highway cross section border bit\n\td = opU( d, opU_hard_bevel( d3, d2, 0.05 ) );\n\n\t\/\/ supporting column\n\tvec2 ppp = vec2( h - p.z, hret.d );\n\tfloat d4 = ppp.y - ( 0.2 + 0.2 * pow( 1. - saturate( ppp.x * 2. ), 4. ) );\n\td4 = opI( -h + p.z, d4 );\n\td4 = opI( d4, sd_bounds_repeat_range_range( crvp.z, 0., 2., 0.5, 0.9 ) ); \/\/ subtract space between supporting columns\n\td =  opU( d, d4 );\n\n\tvec2 dlamps = vec2( FLT_MAX );\n\tvec2 dlamps2 = vec2( FLT_MAX );\n\n\t#ifdef HIGHWAY_LAMPS\n\tdlamps = sd_Lamps( crvp.z, vec2( hret.d, p.z - h ), hw, 0.25, 1.2, 3.2 );\n\td = opU( d, dlamps.x );\n\t#endif\n\t\/\/ add billboard signs on highways\n\tvec2 dsigns = sd_HighwaySigns( crvp.z, vec2( hret.d, p.z - h ), hw );\n\td = opU( d, dsigns.x );\n\n\t\/\/ add ground and pavements\n\tvec3 pp = p;\n\tpp.xy = repeat_mirror_l( p.xy, vec2( 0., 0. ), CELL_SIZE.xy );\n\tvec2 extra = -vec2( 0.15 ); \/\/ expand pavement a bit\n\t\/\/ for pavement we just repeat a round box with left, bottom side using wide road width and top, right sides using small road width\n\tfloat dpavement = sd_bounds_range_round( pp.xy, CELL_SPACING.yy * 0.5 + extra, CELL_SIZE.xy - CELL_SPACING.xx - extra, 0.075 );\n\tdpavement = opS( dpavement, ( hret.d - ROAD_HALFWIDTH * HIGHWAY_PAVEMENT_RATIO ) ); \/\/ empty the bit below the highway... that makes roadmarkings worse\n\tdpavement = opI_hard_bevel( dpavement, pp.z - 0.025, 0.02 ); \/\/ hard bevel to create border, clip with pavement top plane\n\td = opU( dpavement, d ); \/\/ add pavement\n\n\t#ifdef WIDE_STREETS_LAMPS\n\t\/\/ add lamps on wide roads\n\tfloat period = CELL_SIZE.x \/ 5.;\n\t\/\/ offset by peroid\/2 to avoid putting lamps on crossing road (so we don't have to mask)\n\tdlamps2 = sd_Lamps( p.y + period * 0.5, vec2( repeat_mirror_l( p.x, 0., CELL_SIZE.x ), p.z )\n\t\t\t\t\t\t, CELL_SPACING.x * 1.3 \/\/ go on the pavement a bit\n\t\t\t\t\t\t, 0.08, 0.65, period );\n\td = opU( d, dlamps2.x );\n\t#endif\n\n\treturn vec3( d, opU( dlamps.y, dlamps2.y ), dsigns.x );\n}\n\nvec3 l2g( vec3 v ) { return pow( v, vec3( 1. \/ 2.22 ) ); }\nvec3 g2l( vec3 v ) { return pow( v, vec3( 2.22 ) ); }\n\nvec3 biexp2( float x, vec4 r, vec4 g, vec4 b ) { return biexp2( x * vec3( r.x, g.x, b.x ), vec3( r.y, g.y, b.y ), vec3( r.z, g.z, b.z ) ) * vec3( r.w, g.w, b.w ); }\n\n\/\/ manual match of one of the probes at http:\/\/cgg.mff.cuni.cz\/projects\/SkylightModelling\/HosekWilkie_SkylightModel_SIGGRAPH2012_Supplement.pdf\nvec3 get_sky( vec3 v, float sun_cos_theta, float cheat_glow_scale )\n{\n\tvec3 l = vec3( sqrt( 1. - sun_cos_theta * sun_cos_theta ), 0., sun_cos_theta );\n\tfloat theta = safe_acos( v.z ); \/\/ in theory we don't need safe on normalized value, in practice you just never know\n#if 0\n\tvec2 u = vec2( 0.5 ) + normalize( v.xy ) * theta \/ PI;\n\tu = -perp( u ); \/\/ sun is on +x axis\n\tvec3 ref = g2l( texture( iChannel0, u ).xyz );\n\tif ( u.x > 0.5 ) return ref; \/\/ show reference image we try to match\n\/\/\treturn BLUE;\n#endif\n\tfloat sd = dot( v, l );\n\tvec3 sky_top_color = vec3( 0.0182, 0.040, 0.076 ) * 0.95; \/\/ top sky color in linear space\n\tvec3 sky_top = sky_top_color;\n\/\/\treturn ref - sky_top; \/\/ show remnant signal to match\n\tfloat x = ( 1. - theta \/ ( PI * 0.5 ) ) * 0.5;\n\tvec3 sky_radial = biexp2( x, vec4( 7.5, 15., 2., 0.1 ), vec4( 7.5, 10., 1.7, 0.14 ), vec4( 4., 5., 5.5, 0.075 ) ); \/\/ south curve\n\/\/\treturn ref - sky_top - sky_radial; \/\/ show remnant signal to match\n\t\/\/ maching the sun glow is more awkward\n\tvec3 sun_glow = \/\/ note: this affects lighting a lot as we sample sun center color for the main light\n\t\tspherical_gaussian( sd, vec3( 0.8, 0.6, 0.3 ) * 1., 27. ) + \n\t\tspherical_gaussian( sd, vec3( 0.8, 0.4, 0.1 ) * 0.3, 8. );\n\tsun_glow *= cheat_glow_scale;\n\/\/\treturn sun_glow;\n\/\/\treturn ref - sky_top - sky_radial - sun_glow; \/\/ show remnant signal to match... should be black excepy for sun glow\n\treturn max( vec3( 0. ), ( sky_top + sky_radial + sun_glow ) ) * 1.;\n}\n\n\/\/ align sky probe with l direction\nvec3 get_sky( vec3 v, vec3 l, float cheat_glow_scale ) \n{ \n\tif ( l.z != 0. ) v.xy = rotate_with_unit_vector_neg( v.xy, normalize( l.xy ) );\n\treturn get_sky( v, l.z, cheat_glow_scale ); \n}\n\nvec3 test_sky( vec2 fragCoord, vec3 l )\n{\n\tvec2 u = fragCoord.xy \/ min( iResolution.x, iResolution.y );\n\tfloat theta = length( u - vec2( 0.5 ) ) * PI;\n\tfloat phi = calc_angle( u - vec2( 0.5 ) );\n\tvec3 v = zup_spherical_coords_to_vector( theta, phi );\n\tif ( theta > PI * 0.5 ) return MAGENTA;\n\treturn l2g( get_sky( v, l, 1. ) );\n}\n\n\/\/ tentative japanese city building palette\nvec3 get_building_palette( vec2 h )\n{\n\tvec3 ivory = vec3( 1, 0.85, 0.7 ); \/\/ c11\n\tvec3 white = vec3( 1., 1., 1. ); \/\/ c01\n\tvec3 c = mix( mix( BLEU_ARDOISE, GRIS_ARDOISE * 0.5, h.x ), mix( white, ivory, h.x ), h.y );\n\/\/\tvec3 c = mix( mix( c00, c10, h.x ), mix( c01, c11, h.x ), h.y );\n\treturn c = mix( c, vec3( 0.6, 0.2, 0.2 ), smoothband( h.y - 0.5, 0.045, 0.01 ) * h.x * h.x * h.x ); \/\/ add rare reddish colors for occasional red tiles building\n}\n\nstruct NumberArg { float h; vec2 s; float r; float w; float m; };\n\n\/\/ only works with 3 and 8 because those are easy :-)\nfloat sd_Number3or8( vec2 p, int num, NumberArg a )\n{\n\ta.s *= 0.5;\n\tp.y = abs( p.y );\n\tfloat d = sd_bounds_range_round( p, vec2( -a.s.x + a.w + a.m, a.w * 0. ), a.s - a.w - a.m, a.r );\n\td = opB_range( d, -a.w, a.w );\n\tif ( num == 3 ) d = opS( d, sd_bounds_range( p, vec2( -a.s.x - a.w, -a.w ), vec2( 0., a.s.y * a.h ) ) );\n\treturn d;\n}\n\n\/\/ http:\/\/www.airbus.com\/aircraft\/passenger-aircraft\/a350xwb-family\/a350-900.html\n\/\/ -10,10 -> 64m\n\/\/ the silhouette is pretty accurate, modeled on top of blueprint\n\/\/ in this shader it just becomes pixel vomit covering a few pixels but I couldn't let go\nfloat sd_airliner_a350( vec2 p )\n{\n\tp.y = abs( p.y ); \/\/ vertical symmetry\n\tfloat db1 = p.y - 0.98 * rcp_decay( max( -0.666, -( p.x - 10. ) ) ); \/\/ fuselage front\n\tfloat db2 = p.y - 0.98 * rcp_decay( max( -0.666, p.x - -7.8 ) ); \/\/ fuselage back\n\tfloat db = opI( db1, db2 ); \/\/ fuselage\n\tfloat dw1 = -( curved_max_vfunc_weld_quadric( p.x + 3.85, 0.85 ) * 2.3 - ( 9.7 - p.y ) ); \/\/ back wing curve\n\tfloat dw2 = curved_max_vfunc_weld_quadric( p.x + 3.45, 0.85 ) * 1.26 - ( 9.2 - p.y ); \/\/ front wing curve\n\tfloat d3 = -( p.x - ( -0.8 ) ); \/\/ back wing curve flat bit\n\tdw1 = opU( dw1, d3 );\n\tfloat dw = opI( opI( dw1, dw2 ), -( p.x + 4. ) ); \/\/ wing\n\tfloat ds = -( ( smoothstep( -6.5, -9.8, p.x ) ) * 2.55 - p.y ); \/\/ stabilizer\n\tds = opI( ds, ( p.x + 6.5 ) );\n\tds = opS( ds, ( p.x + 8.94 + p.y * 0.4 ) ); \/\/ final tail bit\n\tfloat dt = opI( p.x + 8., p.y - 0.45 * rcp_decay( max( -0.666, ( p.x - -9.75 ) * 1. ) ) );\n\tds = opU( dt, ds ); \/\/ cut garbage\n\tvec2 pe = p - vec2( 1.5, 2.77 ); \/\/ engine pos\n\tfloat de = abs( pe.y ) - 0.8 * min( powerful_scurve( pe.x, 0.5, 4. ), powerful_scurve( 1. - ( pe.x - 1. ), 0.1, 4. ) ) + 0.3; \/\/ engine\n\treturn opU( de, opU( ds, opU( dw, db ) ) );\n}\n\n#define IS_LAMP 1\n#define IS_SIGN 2\n#define IS_WINDOW 4\n#define IS_ROOF 8\n\n\/\/ another blob of stuff, yey\nstruct TraceCityRetval\n{\n\tfloat t; \/\/ fixme: t or p. pick one? they might not be consistent\n\tvec3 p, n; \/\/ position, normal\n\tfloat ao;\n\tvec2 tile_index; \/\/ mostly for debug purpose\n\tfloat split_case; \/\/ split case [0,3] for coloring and randomization\n\tfloat sub_id; \/\/ children id in the 4 split\n\tint type;\n};\n\n#define is_equal_as_float( type, val ) (((type)!=(val))?0.:1.)\n\nvoid pack_info( inout TraceCityRetval ct, vec2 tile_index, float split_case, float sub_id ) { ct.tile_index = tile_index; ct.split_case = split_case; ct.sub_id = sub_id; }\nvoid pack_info1( inout TraceCityRetval ct, float t, vec3 p, vec3 n, float ao, int type ) { ct.t = t; ct.p = p; ct.n = n; ct.ao = ao; ct.type = type; }\n\n\/\/ to easily make a polar coords heart, draw the heart you want, lay out r(theta) in cartesian space, and manual curve match it\nfloat heart( float x ) { x = abs( repeat_e( x, -PI, PI ) ); return exp_decay( x * 1.2 ) * 0.7 + pow( max( x - PI * 0.5, 0. ) \/ ( PI * 0.5 ), 10. ) * 0.3; }\n\nfloat heart_grid( vec2 sp, vec2 c )\n{\n\tvec3 h = hash32( floor( sp \/ c ) );\n\tfloat s = 12. - 5. + 10. * h.z;\n\tvec2 sp3 = repeat( sp, c ) - c * 0.2 * h.xy;\n\tvec2 beat = impulse( vec2( 10. ), repeat( vec2( iTime, iTime + 0.08 ), vec2( 1.2 ) ) );\n\tfloat r = length( ( sp3 - c * 0.5 ) \/ ( 1. + beat * vec2( 0.3, 0.4 ) ) );\n\tfloat l = heart( calc_angle( sp3 - c * 0.5 ) );\n\treturn step( r, l * s );\n}\n\n\/\/ ika is japanese for squid\nfloat ika( vec2 p, float anim )\n{\n\tvec2 p2 = p.xy;\n\tp2.y += 0.25;\n\tp2.x = abs( p.x );\n\tfloat d = opI_soft2( dot( p2 - vec2( 0., 1. ), V45 ), -p2.y - 0.1, 6. );\n\td = opI_soft2( d, p2.y - 1., 10. );\n\tfloat a = calc_angle( p.xy );\n\tfloat r = length( p.xy );\n\ta = abs( repeat_e( a, -PI * 0.5, PI * 0.5 ) );\n\tfloat d3 = r - ( 0.3 + spherical_gaussian( cos( a - PI * mix( 0.4, 0.5, anim ) ), 0.8, 40. )\n\t\t\t\t\t + spherical_gaussian( cos( a - PI * mix( 0.1, 0.4, anim ) ), 1.1, 40. ) );\n\td3 = opI_soft2( p2.y, d3, 8. );\n\td = opU( d, d3 );\n\td = opS( d, length( ( p2 - vec2( 0.2 - anim * 0.075, 0.15 ) ) * vec2( 1. + anim * 0.5, 1. ) ) - 0.16 * ( 1. + anim * 0.4 ) ); \/\/ eyes\n\treturn d;\n}\n\nfloat ika_grid( vec2 sp, float anim, vec2 c ) { return ika( repeat_e( sp, -c, c ) * 0.1, 1. - anim ); }\n\nfloat star( vec2 p )\n{\n\tvec2 n = normalize( vec2( 1., 0.4 ) ); \/\/ slope controls\n\tp.x = abs( p.x );\n\tp = fold( p, vec2( 0. ), vec2( -0.309016994, 0.951056516 ) ); \/\/ perp(90-72=18)\n\tp = fold( p, vec2( 0. ), vec2( -0.809016994, 0.587785252 ) ); \/\/ perp(90-72\/2=54)\n\tvec2 v = p - vec2( 0., 1 );\n\treturn opI( dot( v, n ), dot( v, vec2( -n.x, n.y ) ) );\n}\n\nfloat star_trail( vec2 p, out vec2 uv )\n{\n\tp = rotate_with_angle( p, radians( -25. ) * p.x );\n\tp.y *= exp( p.x * 2. );\n\tp.x *= exp( p.y * 1. );\n\tvec2 pmin = vec2( -0.4, -0.1 );\n\tvec2 pmax = vec2( 0.4, 0.1 );\n\tuv = ( p - pmin ) \/ ( pmax - pmin );\n\treturn sd_bounds_range( p, pmin, pmax );\n}\n\nvoid surfaceColor( TraceCityRetval ct, inout vec3 albedo, inout vec3 emitter, inout float road_marking_material )\n{\n\tif (  ct.type == IS_ROOF ) albedo = max( vec3( 0. ), contrast( albedo, vec3( 1.75 ) ) ); \/\/ enhance disparity of roof colors\n\n\tfloat aa = 0.003; \/\/ sorry...\n\tNearestHighwayRetval nh;\n\tfloat is_highway_columns_zone = 0.; \/\/ just columns\n\tfloat d_pavement_below_highway = FLT_MAX;\n\tfloat d_highway_columns_zone = FLT_MAX;\n\n\tif ( ( ct.sub_id == TYPE_HIGHWAY ) || ( ct.sub_id == TYPE_ROAD ) )\n\t{\n\t\tnh = evalHighway( ct.p.xy );\n\t\td_pavement_below_highway = nh.d - ROAD_HALFWIDTH * HIGHWAY_PAVEMENT_RATIO;\n\t\td_highway_columns_zone = nh.d - ROAD_HALFWIDTH * 0.25;\n\t\tis_highway_columns_zone = smoothstep_c( -d_highway_columns_zone, 0., 0.005 ); \/\/ account for the bevel (mask of road flat bit)\n\t}\n\n\tvec3 road_base_color0 = vec3( 0.5, 0.53, 0.65 );\n\n\tif ( ( ct.sub_id == TYPE_HIGHWAY ) && true )\n\t{\n\t\t\/\/ roadmarkings on top of highway\n\n\t\tfloat hd = nh.d - ROAD_HALFWIDTH;\n\t\tfloat highway_road_bit_mask = 1. - smoothstep_c( nh.d, ROAD_HALFWIDTH - 0.2, 0.005 ); \/\/ account for the bevel (mask of road flat bit)\n\n\t\tvec2 u = ( nh.pr + nh.d2f.xy ); \/\/ works better\n\t\tu.y = nh.d;\n\t\tfloat snhd = nh.d * sign( nh.d2f.y ); \/\/ signed distance accross road when we need to distinguish ledft\/right\n\n\t\tfloat curvature = smin_pol( abs( nh.d2f.w ) * 1.2, 1., 0.5 );\n\n\t\tfloat diagstripes0 = step( ( ROAD_HALFWIDTH * 0.9 - nh.d ) * sign( nh.d2f.y ), curvature );\n\t\tfloat diagstripes = diagstripes0 * smoothband( snhd, ROAD_HALFWIDTH * 0.1, ROAD_HALFWIDTH * 0.7, 0.005 ); \/\/ select road v band, sign( nh.d2f.y ) tells us which side of the road we are on\n\n\/\/\/ a few aliases - all those operate on floats\n\t\t#define SYMLINES(c,r) ( smoothband( abs( u.y ) - ROAD_WIDTH * c, r, aa ) )\n\t\t#define STRIPES(_k,period,len) ( stripes( u._k, period, len, aa ) )\n\t\t#define STRIPES2(_k,period,len) ( stripes2( u._k, period, len, aa ) )\n\t\t#define DIAGONALSTRIPES(period,len) ( stripes( u.x + hd * sign( nh.d2f.y ) * 1.5, period,len, aa ) )\n\t\t#define DOTTEDLINE(r,period,len) ( smoothband( u.y, r, aa ) * STRIPES2( x, period, len ) )\n\t\t#define ARROWS(center,period,len,width,slope) ( ( stripes2( u.x - fold(snhd, ROAD_WIDTH*(center))*(slope), period,len, aa ) ) * smoothband( snhd- ROAD_WIDTH*(center), (width)*0.5, aa ) )\n\t\t#define ADD( _col, _factor ) albedo_markings = mix( albedo_markings, _col, _factor )\n\n\t\tvec3 road_marking_color_white = vec3( 1. ) * 3.;\n\t\tvec3 road_marking_color_yellow = vec3( 1., 1., 0. ) * 2.;\n\t\tvec3 albedo_markings = vec3( 0. );\n\n\t\tADD( road_marking_color_white, SYMLINES( 0.18, 0.016 ) * STRIPES2( x, 0.4, 0.1 ) * ( 1. - diagstripes ) );\n\t\tADD( mix( road_marking_color_yellow, road_marking_color_white, 1. ), highway_road_bit_mask * STRIPES( y, 0.75, 0.016 ) * ( 1. - diagstripes ) );\n\n\t\t\/\/ the wide warning stripes\n\t\tADD( road_marking_color_white, diagstripes * DIAGONALSTRIPES(  0.15 * 1.8, 0.05 ) );\n\t\tADD( road_marking_color_white, ARROWS( -0.28, 0.4 * 16., 0.1 * 12., 0.24, 0.5 ) * ARROWS( -0.28, 0.4, 0.1, 0.24, 0.5 ) * ( 1. - diagstripes ) );\n\n\t\t{\n\t\t\t\/\/ highway road marking number\n\t\t\tvec2 np = ( ct.p.xy ); \/\/ vec2( u.x, nh.d2f.y );\n\t\t\tnp.x = repeat_e( np.x, -20., 20. );\n\t\t\tnp = ( perp( np ) + vec2( 0.25, 9. ) ) * vec2( 3.5, 0.75 );\n\t\t\tNumberArg args;\n\t\t\targs.h = 0.7;\n\t\t\targs.s = vec2( 1., 2. ) * 0.5;\n\t\t\targs.r = 0.1;\n\t\t\targs.w = 0.045;\n\t\t\targs.m = 0.025;\n\t\t\tfloat dn = sd_Number3or8( np, 8, args );\n\t\t\tdn = opU( dn, sd_Number3or8( np + vec2( -args.s.x * 1., 0. ), 3, args ) );\n\t\t\tif ( sign( nh.d2f.y ) > 0. ) dn = FLT_MAX;\n\t\t\tADD( road_marking_color_yellow, smoothstep( aa, -aa, dn ) );\n\t\t}\n\n\t\t\/\/ make sure roadmarkings are only on top highway surface\n\t\tfloat space_filter = step( HIGHWAY_HEIGHT, ct.p.z ) \/\/ must be above highway height\n\t\t\t* step( 0., ct.n.z ) \/\/ surface must be pointing up\n\t\t\t* step( ct.p.z, HIGHWAY_HEIGHT + 0.5 ); \/\/ not higher than highway border walls\n\n\t\t{\n\t\t\tfloat blend = maxcomp( albedo_markings ) * space_filter;\n\t\t\talbedo = mix( albedo, min( albedo_markings + road_base_color0 * 0.70, vec3( 1. ) ), blend );\n\t\t\troad_marking_material = max( road_marking_material, blend );\n\t\t}\n\n\t\t#ifdef LCD_PANELS\n\t\tif ( ct.type == IS_SIGN )\n\t\t{\n\t\t\t\/\/ render stuff on LCD panels... shadertoy within shadertoy, hehe\n\t\t\talbedo_markings = vec3( 0. );\n\n\t\t\tfloat h2 = 1.2; \/\/ sign start h\n\t\t\tfloat h3 = LDC_HEIGHT; \/\/ sign end h\n\n\t\t\tif ( ct.p.z > HIGHWAY_HEIGHT + h2 - 0.0  )\n\t\t\t{\n\t\t\t\tfloat screenpixel = 0.01; \/\/ highway panel pizel size, in world size\n\t\t\t\tvec2 gp = ct.p.yz;\n\t\t\t\tgp.x = snhd;\n\t\t\t\tgp.y -= ( HIGHWAY_HEIGHT + h2 ); \/\/ make botton line be pixel coord y=0\n\n\t\t\t\tfloat d = sd_bounds_repeat_size_margin( gp, vec2( screenpixel ), vec2( 0.001 ) );\n\t\t\t\tfloat margin = step( d, 0. );\n\n\t\t\t\t\/\/ I don't AA properly because I suck, but at least tone the grid down\n\t\t\t\tmargin = mix( margin, 1., ( 1. - exp( -max( ct.t - 6., 0. ) ) * 0.7 ) );\n\n\t\t\t\tvec2 sp = floor( gp \/ screenpixel ); \/\/ screen pixel\n\n\t\t\t\t\/\/ bottom margin x top margin x sides component\n\t\t\t\tfloat is_ldc_surface = step( 1., sp.y ) * step( sp.y, floor( LDC_HEIGHT \/ screenpixel ) - 2. ) * step( 0.5, abs( ct.n.x ) );\n\n\t\t\t\tmargin *= is_ldc_surface;\n\n\t\t\t\tfloat index = floor( u.x \/ SIGN_PERIOD ); \/\/ same repeat as sd_HighwaySigns\n\t\t\t\tindex = mod( index, 4. );\n\n\t\t\t\t#define ADD_EMITTER(c,v) emitter+=(c)*(v)*margin*1.;\n\n\t\t\t\tif ( index == 0.  )\n\t\t\t\t{\n\t\t\t\t\t\/\/ airliners\n\t\t\t\t\tvec2 c = vec2( 110., 110. );\n\t\t\t\t\tvec2 sp3 = rotate_with_unit_vector( sp, -V60 ) + vec2( -iTime * 100., 0. );\n\t\t\t\t\tsp3 = repeat( sp3, c );\n\t\t\t\t\tfloat d3 = sd_airliner_a350( ( sp3 - c * 0.5 ) * 0.2 );\n\t\t\t\t\tADD_EMITTER( vec3( 1. ), step( d3, 0. ) );\n\t\t\t\t}\n\t\t\t\telse if ( index == 1.  )\n\t\t\t\t{\n\t\t\t\t\t\/\/ hearts\n\t\t\t\t\tfloat hg = heart_grid( -perp( sp ) + vec2( sin( iTime * 3. ) * 8., 6. + iTime * 40. ), vec2( 32., 40. ) );\n\t\t\t\t\tADD_EMITTER( vec3( 1., 0., 0. ), hg );\n\t\t\t\t\tfloat hg2 = heart_grid( ( rotate_with_unit_vector( -sp, V45 ) * 2. ) + vec2( -iTime * 18., 6. ), vec2( 30., 30. ) );\n\t\t\t\t\tADD_EMITTER( vec3( 0., 1., 1. ), hg2 * ( 1. - hg ) );\n\t\t\t\t}\n\t\t\t\telse if ( index == 2.  )\n\t\t\t\t{\n\t\t\t\t\t\/\/ rainbow stars\n\t\t\t\t\tvec2 sp3 = sp;\n\t\t\t\t\tsp3 *= 1.;\n\t\t\t\t\tsp3.y -= 100.;\n\t\t\t\t\tsp3 = rotate_with_angle( sp3, iTime );\n\t\t\t\t\tfloat a = calc_angle( sp3 );\n\t\t\t\t\tfloat r = length( sp3 );\n\t\t\t\t\tfloat r0 = 30.;\n\t\t\t\t\tfloat arclen0 = r0 * 2.; \/\/ use a rough sie ratio\n\t\t\t\t\tfloat ri = floor( r \/ r0 );\n\t\t\t\t\tfloat R = ri * r0;\n\t\t\t\t\tfloat numarc = floor( 2. * PI * R \/ arclen0 );\n\t\t\t\t\tfloat da = ( 2. * PI \/ numarc );\n\t\t\t\t\tfloat dai = floor( a \/ da );\n\t\t\t\t\tvec2 y = unit_vector2( da * ( dai + 0.5 ) );\n\t\t\t\t\tvec2 x = -perp( y );\n\t\t\t\t\tvec2 c = y * ( ri + 0.5 ) * r0;\n\t\t\t\t\tsp3 = vec2( dot( x, sp3 - c ), dot( y, sp3 - c ) );\n\t\t\t\t\tsp3 *= 0.025;\n\t\t\t\t\tsp3.y = -sp3.y;\n\t\t\t\t\tfloat d1 = star( sp3.xy * 3. );\n\t\t\t\t\tvec2 trail_uv;\n\t\t\t\t\tfloat d2 = star_trail( sp3.xy - vec2( -0.6, -0.1 ), trail_uv );\n\t\t\t\t\tvec3 rainbow = hsv2rgb( vec3( trail_uv.y, 1., 1. ) );\n\t\t\t\t\tvec3 c2 = vec3( 0. );\n\t\t\t\t\tif ( d2 < 0. ) c2 = rainbow;\n\t\t\t\t\tif ( d1 < 0. ) c2 = vec3( 1., 1., 0. );\n\t\t\t\t\tADD_EMITTER( c2, max( step( d1, 0. ), step( d2, 0. ) ) );\n\t\t\t\t}\n\t\t\t\telse if ( index == 3.  )\n\t\t\t\t{\n\t\t\t\t\t\/\/ 2 layers of swimming squids or something\n\t\t\t\t\tfloat anim1 = ( sin( iTime * 8. ) + 1. ) * 0.5;\n\t\t\t\t\tvec2 sp1 = rotate_with_unit_vector( sp, -V45 ) + vec2( 0., 18. - iTime * 20. + anim1 * 4. );\n\t\t\t\t\tfloat l1 = step( ika_grid( sp1, anim1, vec2( 15., 15. ) ), 0. );\n\t\t\t\t\tADD_EMITTER( vec3( 0., 1., 1. ), l1 );\n\t\t\t\t\tfloat anim2 = ( sin( iTime * 9. ) + 1. ) * 0.5;\n\t\t\t\t\tvec2 sp2 = rotate_with_unit_vector( sp, -V45 ) + vec2( 5., 9. - iTime * 35. + anim1 * 4. );\n\t\t\t\t\tfloat l2 = step( ika_grid( sp2, anim2, vec2( 40., 40. ) ), 0. );\n\t\t\t\t\tADD_EMITTER( vec3( 1., 0., 0. ), l2 * ( 1. - l1 ) );\n\t\t\t\t}\n\n\t\t\t\talbedo = mix( albedo, albedo * 0.3, is_ldc_surface );\n\t\t\t}\n\t\t}\n\t\t#endif\n\t}\n\n\tif ( ( ct.sub_id == TYPE_ROAD ) && true )\n\t{\n\t\t\/\/ regular streets road markings\n\t\tNearestHighwayRetval nh = evalHighway( ct.p.xy );\n\t\tvec2 pp = repeat_mirror_l( ct.p.xy, vec2( 0., 0. ), CELL_SIZE.xy ); \/\/ road cells\n\t\tvec2 extra = -vec2( 0.15 );\n\t\tvec2 mina = CELL_SPACING.yy * 0.5 + extra;\n\t\tvec2 minb = CELL_SIZE.xy - CELL_SPACING.xx - extra;\n\t\tfloat d1 = sd_bounds_range_round( pp, mina, minb, 0.075 );\n\t\tfloat is_pure_road = step( 0., d1 );\n\t\td1 = opS( d1, d_pavement_below_highway ); \/\/ empty the bit below the highway\n\t\tfloat is_road_or_below_highway_road = step( 0., d1 );\n\t\tvec2 is_wide_road = step( pp, mina );\n\t\tvec2 is_small_road = step( minb, pp );\n\t\tfloat is_wide_road_crossing = is_wide_road.x * is_wide_road.y;\n\t\tfloat is_small_road_crossing = is_small_road.x * is_small_road.y;\n\t\tfloat is_small_wide_road_crossing =  min( is_wide_road.x * is_small_road.y + is_wide_road.y * is_small_road.x, 1. );\n\t\tfloat crossing = min( is_small_road_crossing + is_wide_road_crossing + is_small_wide_road_crossing, 1. );\n\t\tvec3 road_marking_color_white = vec3( 1. ) * 2.;\n\t\tvec3 road_marking_color_yellow = vec3( 1., 1., 0. ) * 2.;\n\t\tvec3 albedo_markings = vec3( 0. );\n\t\t\/\/ white lines all around\n\t\tADD( road_marking_color_white, smoothband( d1, 0.05, 0.05 + 0.02, aa ) );\n\t\t\/\/ wide roads markings\n\t\tADD( road_marking_color_white, smoothband( pp.x, 0.01, aa ) * is_wide_road.x * ( 1. - crossing ) ); \/\/DOTTEDLINE\n\t\tADD( road_marking_color_white, smoothband( pp.y, 0.01, aa ) * is_wide_road.y * ( 1. - crossing ) ); \/\/DOTTEDLINE\n\t\t\/\/ small road markings\n\t\tADD( road_marking_color_white, smoothband( pp.x - CELL_SIZE.x, 0.01, aa ) * stripes( pp.y - CELL_SIZE.y, 0.2, 0.05, aa ) * ( 1. - crossing ) ); \/\/DOTTEDLINE\n\t\tADD( road_marking_color_white, smoothband( pp.y - CELL_SIZE.y, 0.01, aa ) * stripes( pp.x - CELL_SIZE.x, 0.2, 0.05, aa ) * ( 1. - crossing ) ); \/\/DOTTEDLINE\n\t\t\/\/ yellow strips alongside highway columns\n\t\tADD( road_marking_color_yellow, smoothband( d_highway_columns_zone, 0.05, aa )* ( 1. - is_wide_road.x ) * ( 1. - is_small_road.x ) );\n\n\t\t{\n\t\t\t\/\/ pedestrian crossings on large roads\n\t\t\tfloat crossing_width = 0.24;\n\t\t\tfloat dd = 0.5; \/\/ where do start crossing from\n\t\t\tvec2 pedestrian_crossingmask = stripes( pp - ( mina + vec2( dd ) ), minb - mina - vec2( dd ) * 2., vec2( crossing_width ), vec2( aa ) );\n\t\t\tvec2 pedestrian_crossingmask2 = stripes( pp - ( mina + vec2( dd ) ), minb - mina - vec2( dd ) * 2., vec2( crossing_width * 1.2 ), vec2( aa ) );\n\t\t\tpedestrian_crossingmask *= is_pure_road * ( 1. - is_highway_columns_zone );\n\t\t\tpedestrian_crossingmask2 *= is_pure_road * ( 1. - is_highway_columns_zone );\n\t\t\talbedo_markings *= ( 1. - pedestrian_crossingmask2.x ) * ( 1. - pedestrian_crossingmask2.y );\n\t\t\tADD( road_marking_color_white, stripes( pp.y, 0.1, 0.025, aa ) * pedestrian_crossingmask.x );\n\t\t\tADD( road_marking_color_white, stripes( pp.x, 0.1, 0.025, aa ) * pedestrian_crossingmask.y );\n\t\t}\n\n\t\tfloat blend = maxcomp( albedo_markings ) * is_road_or_below_highway_road * ( 1. - is_highway_columns_zone );\n\t\talbedo = mix( albedo, min( albedo_markings + road_base_color0 * 0.75, vec3( 1. ) ), blend );\n\t\troad_marking_material = max( road_marking_material, blend );\n\t}\n}\n\nvec3 shadeCity( TraceCityRetval ct, vec3 e, vec3 v, vec3 l, float shadow\n\t\t\t\t, float airliner, float a_contrast, vec2 uv, float aspect, float ground_ao )\n{\n\tvec3 col = vec3( 0. );\n\tvec3 emitter = vec3( 0. );\n\n\tfloat is_sky = is_equal_as_float( ct.sub_id, TYPE_SKY );\n\n#ifdef HORIZON_HACK\n\t\/\/ hack stretch sky horizon so it matches our trace horizon (means the sun position won't quite match with real sun position)\n\tfloat gamma = -e.z \/ MAX_DDA_TRACE; \/\/=cos(PI\/2.+beta)=sin(beta), beta is the extra angle that goes into the ground\n\tfloat alpha = -1. \/ ( gamma - 1. );\n\tvec3 v_hacked = vec3( v.xy, 1. + ( v.z - 1. ) * mix( alpha, 1., 0. ) ); \/\/ mix control how much hack correction (alpha) we want on horizon\n\tvec3 skycol_view = get_sky( normalize( v_hacked ), l, 0.4 );\n#else\n\tvec3 skycol_view = get_sky( v, l, 0.4 );\n#endif\n\/\/\tif ( ct.t > MAX_DDA_TRACE ) return GREEN;\n\n\t\/\/ sun disk\n\tfloat sun0 = dot( l, v );\n\n\tif ( ct.sub_id == TYPE_SKY )\n\t{\n\t\tcol = skycol_view;\n\n\t\t\/\/ we don't need to add a disk... let get_sky do it (also we messed with horizon and therefore sun position)\n\/\/\t\tcol += vec3( pow( sun, 20. ) * is_sky * 100. ); \/\/ sun disk (not flare\/not glow, just the sun disk)\n\n\t\tfloat d_airliners = 1. - pow( max( 0., sun0 ), 8. ); \/\/ airliners\n\t\tcol = mix( col, vec3( airliner ) + d_airliners * skycol_view * 2., airliner * 0.5 );\n\n\t\t#ifdef DEBUG_COLORING\n\t\tcol = vec3( 0.0,0.1,0.8 );\n\t\t#endif\n\t}\n\telse\n\t{\n\t\tivec4 ch = ivec4( ct.split_case, ct.sub_id, ct.tile_index );\n\t\tvec3 albedo = get_building_palette( hash24_( ch ) * mix( 1., 0.2, is_equal_as_float( ct.type, IS_ROOF ) ) ); \/\/ roof tiles use bottom left part of the 2d palette (ardoise)\n\n\t\tfloat road_marking_material = 0.;\n\t\tsurfaceColor( ct, albedo, emitter, road_marking_material );\n\n\t\t#ifdef DEBUG_COLORING\n\t\tif ( ct.type == IS_WINDOW ) return vec3( 0.7 );\n\t\tif ( ct.type == IS_LAMP ) return vec3( 1., 1., 0. );\n\t\tif ( ct.type == IS_ROOF ) return BLEU_ARDOISE;\n\t\tif ( ct.type == IS_SIGN ) return vec3( 0., 1., 1. );\n\t\treturn mix( albedo, hash44_( ch ).xyz, 0.5 );\n\t\t#endif\n\n\t\tfloat kdiffuse = mix( 0.75, 1., road_marking_material );\n\t\tfloat kspecular = mix( 0.15, 0.8, road_marking_material ) * shadow;\n\t\tfloat roughness = mix( 0.62, 0.1, road_marking_material );\n\n\t\tif ( ct.type == IS_ROOF ) { kspecular = 0.7; roughness = 0.2; }\n\n\t\tfloat Li_sky_color_saturation = 0.65; \/\/ how much we blend sky color in\n\n\t\tvec3 skycol_top = get_sky( vec3( 0., 0., 1. ), l, 1. );\n\t\tvec3 skycol_sun = get_sky( l, l, 1. );\n\n\t\tvec3 lr = vec3( -l.xy, l.z ); \/\/ sun light reflected from buildings from behind (\"1 bounce\")\n\t\tvec3 l2 = vec3( perp( l.xy ), l.z );\n\t\tvec3 l3 = vec3( -l2.xy, l.z );\n\n\t\tvec3 Li_sky_top = mix( skycol_top, vec3( luminance( skycol_top ) ), Li_sky_color_saturation );\n\n\t\tfloat s2 = mix( 0.8, 1., shadow );\n#if 1\n\t\t\/\/ only add ambient on shadows\n\t\tcol += 0.005 * ( 1. - shadow );\n#endif\n#if 1\n\t\t\/\/ skydome top light (highlights rooftops, too)\n\t\tcol += s2 * add_light_contrib( albedo, vec3( 0., 0., 1. ), ct.n, -v, Li_sky_top, 5., kdiffuse, kspecular, roughness );\n#endif\n#if 1\n\t\t\/\/ a couple of lateral directions, pretend Li_sky_top, this works well for our axis aligned scene...\n\t\tcol += s2 * add_light_contrib( albedo, l2, ct.n, -v, Li_sky_top, 1., kdiffuse, 0., roughness );\n\t\tcol += s2 * add_light_contrib( albedo, l3, ct.n, -v, Li_sky_top, 1., kdiffuse, 0., roughness );\n#endif\n#if 1\n\t\t\/\/ sun light reflected by \"buildings from behind\" (1 bounce-ish) tip from iq's https:\/\/iquilezles.org\/articles\/outdoorslighting\n\t\tvec3 Li_sky_sun_back = 0.2 * mix( skycol_sun, vec3( luminance( skycol_sun ) ), Li_sky_color_saturation );\n\t\t\/\/ fade the highest positions as they don't get that much reflected light as there are no taller buildings, also that gives a bit of gradient\n\t\tLi_sky_sun_back *= 1. - min( ct.p.z \/ ( MAX_BUILDING_HEIGHT * 0.8 ), 1. );\n\t\tcol += s2 * add_light_contrib( albedo, lr, ct.n, -v, Li_sky_sun_back, 0.5, kdiffuse, .0, roughness );\n#endif\n#if 1\n\t\t#ifdef AO\n\t\tcol *= ct.ao * ct.ao * ct.ao * mix( ground_ao, 1., exp_decay( ct.p.z * 0.5 ) ); \/\/ we add a simple vertical occlusion term in addition to he marched ao\n\t\t#endif\n#endif\n#if 1\n\t\t\/\/ direct sun light (post ao!)\n\t\tvec3 Li_sky_sun_front = mix( skycol_sun, vec3( luminance( skycol_sun ) ), Li_sky_color_saturation );\n\t\tcol += shadow * add_light_contrib( albedo, l, ct.n, -v, Li_sky_sun_front, 1., kdiffuse, kspecular, roughness );\n#endif\n\/\/\t\tcol = mix( vec3( 1., 0., 0. ), col, shadow );\n\n\t\tif ( ct.type == IS_WINDOW )\n\t\t{\n\t\t\tvec3 vr = reflect( v, ct.n );\n\n\t\t\t \/\/ windows sky reflections, assumes sky fades to black in lower hemisphere\n\t\t\tcol += get_sky( vr, l, 1. ) * mix( 0.5, 1., shadow );\n\n\t\t\t#if 0\n\t\t\t\/\/ extra sun disk\/glow? (get_sky has no sun disk)\n\t\t\tfloat sun1 = dot( l, vr ); \/\/ note: not hemisphere clamped\n\t\t\tcol += skycol_sun * vec3( pow( ( sun1 + 1. )* 0.5, 70. ) )* mix( 0.15,1.f,shadow );\n\t\t\t#endif\n\n\t\t\t\/\/ make windows a bit reflective in bottom hemisphere too\n\t\t\t\/\/ just reflect a constant \"ground color\", fading with distance\n\t\t\t#ifdef WINDOWS_GROUND_REFLECTION\n\t\t\tif ( v.z < 0. )\n\t\t\t{\n\t\t\t\tfloat wt = plane_trace_z( mkray( e, vr ), 0., 1.e-6 );\n\t\t\t\tif ( wt > 0. && wt != FLT_MAX )\n\t\t\t\t{\n\/\/\t\t\t\t\tcol += RED * exp( -wt * 0.09 ); \/\/ red is kind of cool too :-)\n\t\t\t\t\tcol += BLEU_ARDOISE * exp( -wt * 0.09 ) * 0.25; \/\/ reflect a city ground color, maybe this gradient could be a function of building height\n\t\t\t\t}\n\t\t\t}\n\t\t\t#endif\n\n\t\t\t\/\/ upper hemisphere window reflections (sky and office neon)\n\t\t\t#ifdef OFFICE_NEON\n\t\t\tif ( v.z > 0. )\n\t\t\t{\n\t\t\t\t\/\/ cheap but efficient neon hack\n\t\t\t\tRay vr = mkray( e, v );\n\t\t\t\tfloat wt = plane_trace_z( vr, ceil( ct.p.z \/ FLOOR_HEIGHT ) * FLOOR_HEIGHT, 1.e-6 ); \/\/ infinite neon plane\n\t\t\t\tif ( wt > 0. && wt != FLT_MAX )\n\t\t\t\t{\n\t\t\t\t\tvec3 wp = vr.o + vr.d * wt;\n\t\t\t\t\tfloat neondepth = dot( ct.p - wp, ct.n );\n\t\t\t\t\tvec2 y = normalize( ct.n.xy );\n\t\t\t\t\tvec2 x = -perp( y );\n\t\t\t\t\tfloat dneon = sd_bounds_repeat_range_range( wp.x * x + wp.y * y, vec2( 0., 0. ), vec2( 0.8, 0.3 ) \/\/ neon periodicity\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t, vec2( 0., 0. ), vec2( 0.34, 0.05 ) ); \/\/ neon size\n\t\t\t\t\tcol += step( dneon, 0. ) * exp2( -neondepth * 2.8 );\n\t\t\t\t}\n\t\t\t}\n\t\t\t#endif\n\t\t}\n\n\t\tcol += is_equal_as_float( ct.type, IS_LAMP ) * 0.9;\n\t\tcol += emitter;\n\n\/\/\t\tvec3 fog_color = mix( RED, GREEN, pow( ( sun0 + 1. ) * 0.5, mix( 7., 40., shadow ) ) );\n\t\tvec3 fog_color = mix( skycol_top * 1.5, skycol_sun, pow( ( sun0 + 1. ) * 0.5, mix( 7., 5., shadow ) ) ); \/\/ skycol_top color is a bit weak so boost it a bit\n\t\tcol += fog_color * 0.55 * exp_decay( ct.t * 0.002 + ct.p.z * 0.007  ); \/\/ some kind of inscatter (so we add), along view distance and world height\n\n\t\tcol = mix( col, skycol_view, smoothstep( FADE_START, MAX_DDA_TRACE, ct.t ) ); \/\/ fade with background\n\n\/\/\t\tif ( ct.t > FADE_START ) return RED;\n\/\/\t\treturn skycol_view;\n\/\/\t\treturn skycol_top * 8.;\n\/\/\t\treturn skycol_sun;\n\/\/\t\treturn col;\n\t}\n\n\tcol = 3.5 * tonemap_reinhard( col ); \/\/ expose\n\/\/\tcol = max( vec3( 0. ), contrast( col, vec3( a_contrast ) ) ); \/\/ post process\n\tcol *= .2 + 0.8 * pow( 20. * uv.x * uv.y * ( 1. - uv.x ) * ( 1. - uv.y ), 0.075 ); \/\/ vignette\n\tcol = gamma_correction_itu( col );\n\n\/\/\tif ( v.z < 0. ) col = RED; \/\/ view real horizon\n\n\treturn col;\n}\n\n\/\/ building heights distribution function\nvec4 icdf( vec4 x ) { return mix( saturate( safe_acos( vec4( 1. ) - 4. * x ) \/ PI ), (x - vec4( 0.5 )) * 0.1, step( 0.5, x ) ); }\n\nParametricBuildingRetval sd_ParametricBuilding( float t, vec3 p, float building_type, bounds2 b2, float height, NearestHighwayRetval nh, vec3 rnd )\n{\n\tif ( building_type == 0. ) return sd_House( p, t, b2, min( height, HIGHWAY_HEIGHT ), nh );\n\treturn sd_Building( t, p, b2, height, nh, rnd );\n}\n\nstruct ParametricBuildingHit\n{\n\tfloat t;\n\tfloat tile_child_index;\n\tfloat building_type; \/\/ 0:house 1:building (could use 0. and 4. instead)\n\tfloat height;\n\tbounds2 b2;\n\tfloat d;\n\tvec3 windr;\n\tfloat is_roof;\n\tRay ray2; \/\/ potentially permuted ray\n\tbool permuted;\n\tNearestHighwayRetval nh;\n\tvec3 rnd;\n};\n\nvoid rayMarchParametricBuilding( Ray ray2, bool permuted, vec2 ri, bounds3 bi, float kk, inout ParametricBuildingHit hit, vec2 cell_index )\n{\n\tif ( ri.y <= ri.x || ri.y < 0. ) return; \/\/ no hit\n\n\tri.x = max( ri.x, 0. );\n\n\t\/\/ warning: if you fiddle with early return here, check what happens to the shadow term!\n\n\tbounds2 b2 = mkbounds_unchecked( bi.pmin.xy, bi.pmax.xy ); \/\/ b2 is in maybe permuted space and contains the object\n\n\tvec2 base_size = size( b2 ); \/\/ this is the base size with x and y maybe permuted\n\n\/\/\tif ( base_size.x <= 0. || base_size.y <= 0. ) return; \/\/ doesn't seem to contribute to the image... and is slower?\n\n\tNearestHighwayRetval nh;\n\n\tnh.d = FLT_MAX; \/\/ disable the clip plane\n\n\t#ifdef HIGHWAY_CLIP\n\t#ifdef HIGHWAYS\n\t{\n\t\t\/\/ some basic layout intersection tests outside marching loop... tedious block of code\n\n\t\tvec2 b2c = center( b2 );\n\t\tvec2 b2s = base_size; \/\/ size( b2 )\n\n\t\tif ( permuted ) \/\/ remember: b2 is in permuted space, dont use it in calculations below\n\t\t{\n\t\t\tb2c = b2c.yx; \/\/ back to world\n\t\t\tb2s = b2s.yx;\n\t\t}\n\n\t\tnh = evalHighway( b2c );\n\n\t\tnh.o_clip = nh.p + nh.d2f.xy; \/\/ closest highway center line point (b2c==nh.p)\n\t\tnh.n_clip = normalize( perp( nh.d2f.zw ) ); \/\/ can't use hret2.d2f.xy as it may be null\n\n\/\/\t\tfloat b2cd = dot( b2c - nh.o_clip, nh.n_clip ); \/\/ distance to higway center line, signed\n\t\tfloat b2cd = dot( -nh.d2f.xy, nh.n_clip ); \/\/ should be same as above, saves a sub (lol)\n\n\t\tnh.n_clip *= sign( b2cd ); \/\/ orient the clip normal so we can build a facade (box center is on positive side)\n\n\t\tb2cd = abs( b2cd ); \/\/ now we are on the positive side\n\n\t\tfloat ml = length( b2s );\n\n\t\tif ( b2cd > ( ml + ROAD_WIDTH ) * 0.5 ) nh.d = FLT_MAX; \/\/ building far away enough regardless of rotation, disable the clip plane\n\t\t#ifdef TRY_BALANCE_SIZES\n\t\telse \n\t\t{\n\t\t\tfloat l = b2s.y; \/\/ (fixme: corrected with slope) if we can assume horizonal ish roads\n\t\t\tfloat clipped_l = ( b2cd + l * 0.5 ) - max( b2cd - l * 0.5, ROAD_HALFWIDTH ); \/\/ size left after clipping\n\n\t\t\tbase_size = b2s;\n\t\t\tbase_size.y = clipped_l;\n\n\t\t\t\/\/ if the building was ultra thin to begin with, clipping is not going to make things any better\n\t\t\t\/\/ that filters out some garbage thin buildings\n\t\t\tif ( maxcomp( base_size ) > 10. * mincomp( base_size ) ) return;\n\t\t}\n\t\t#endif\n\n\/\/\t\tnh.d = FLT_MAX; \/\/ uncomment to check actual size of building if they weren't clipped\n\n\t\tif ( permuted )\n\t\t{\n\t\t\t\/\/ back to permuted space\n\t\t\tnh.p = nh.p.yx;\n\t\t\tnh.pr = nh.pr.yx;\n\t\t\tnh.d2f = nh.d2f.yxwz;\n\t\t\tnh.n_clip = nh.n_clip.yx;\n\t\t\tnh.o_clip = nh.o_clip.yx;\n\t\t}\n\t}\n\t#endif\n\t#endif\n\n\tfloat height = bi.pmax.z; \/\/ pmax.z awkward?\n\n\t\/\/ make height not bigger than n times the smallest dimension on the 2d base, not that base_size may be permuted, we only care about the min dimension\n\t#ifdef TRY_BALANCE_SIZES\n\theight = min( height, 8. * mincomp( base_size ) );\n\t#endif\n\n\tfloat building_type = height < 3.4 ? 0. : 1.;\n\n\tif ( building_type == 1. ) height = ( 0.5 + floor( height \/ FLOOR_HEIGHT - 0.5 ) ) * FLOOR_HEIGHT; \/\/ make building height a multiple of floor height\n\n\tfloat t = ri.x; \/\/ start marching from first hit point\n\n\tvec3 rnd = vec3( cell_index, kk );\n\n\tfor ( int j = 0; j < DDA_CELL_SDF_MARCH_MAX_ITERATIONS FORCE_LOOP_LV3; ++j )\n\t{\n#ifdef ENABLE_MAX_DDA_TRACE_DISTANCE\n\t\t\/\/ no need to trace further than max cell size == massive win\n\t\t\/\/ we then have to pick a max trace distance, for that cell 2d diagonal size would be a start\n\t\t\/\/ but since cell height is higher than max building height, we use max building height instead\n\t\tif ( t - ri.x > MAX_BUILDING_HEIGHT ) break;\n#endif\n\n\t\tvec3 p = ray2.o + t * ray2.d;\n\n\t\tParametricBuildingRetval ddd = sd_ParametricBuilding( t, p, building_type, b2, height, nh, rnd );\n\t\tfloat d = ddd.d;\n\n\t\tif ( abs( d ) <= 0.001 * t )\n\t\t{\n\t\t\tif ( t < hit.t ) \/\/ we need to check vs other objects in the cell\n\t\t\t{\n\t\t\t\t\/\/ record a few things we need to do extra evals deriving from the final hit\n\t\t\t\thit.t = t;\n\t\t\t\thit.tile_child_index = kk;\n\t\t\t\thit.building_type = building_type;\n\t\t\t\thit.b2 = b2;\n\t\t\t\thit.height = height;\n\t\t\t\thit.d = d;\n\t\t\t\thit.windr = ddd.windr;\n\t\t\t\thit.is_roof = step( abs( d - ddd.droof ), 0.001 );\n\t\t\t\thit.ray2 = ray2;\n\t\t\t\thit.permuted = permuted;\n\t\t\t\thit.nh = nh;\n\t\t\t\thit.rnd = rnd;\n\t\t\t}\n\n\t\t\tbreak; \/\/ \"return\" is slower on radeon: 29ms -> 31ms (ancient wip timings)\n\t\t}\n\n\t\tfloat dt = d;\n\/\/\t\tfloat dt = d * TFRAC; \/\/ shadows a bit better with this\n\/\/\t\tfloat dt = abs( d ); \/\/ *TFRAC \/\/ only move forward (see inside of buildings...)\n\n\t\tt += dt;\n\/\/\t\tp += dt * ray2.d; \/\/ do not do this, instead increment t and reevaluate p fully (loss of precision else)\n\t}\n}\n\nvoid rayMarchCellObjects( Ray ray2, Ranges_x4 iv, bool permuted, inout ParametricBuildingHit hit, vec2 cell_index, bool shadow_trace )\n{\n#ifdef DEBUG_BUILDINGS_BOUNDS\n\n\t#define BLD_BOX( rX, bX, idval ) \\\n\tif ( iv.rX.y > iv.rX.x && hit.t > iv.rX.x && iv.rX.x > 0. ) \\\n\t{ \\\n\t\thit.t = iv.rX.x; \\\n\t\t\/*b4 = iv.bX;*\/ \\\n\t\thit.tile_child_index = idval; \\\n\t\thit.ray2 = ray2; \\\n\t\thit.permuted = permuted; \\\n\t}\n\n\tBLD_BOX( rA, bA, 0. )\n\tBLD_BOX( rB, bB, 1. )\n\tBLD_BOX( rC, bC, 2. )\n\tBLD_BOX( rD, bD, 3. )\n\t\n#else\n\t\n#ifndef UNROLL_LOOP2\n\/\/\/ same cost as manually unroll (stable 29ms, vs 28,29ms for manually unrolled, old wip figures)\n\/\/\/ would like to also try prevent unroll but...\n\tvec2 ranges[4] = vec2[4]( iv.rA, iv.rB, iv.rC, iv.rD );\n\tbounds3 b4s[4] = bounds3[4]( iv.bA, iv.bB, iv.bC, iv.bD );\n\tfor ( int i = 0; i< ( 4 FORCE_LOOP_LV2 ); ++i )\n\t{\n\t\trayMarchParametricBuilding( ray2, permuted, ranges[i], b4s[i], float( i ), hit, cell_index );\n\t}\n#else\n\t\/\/ manual unroll 74ms -> 69ms old radeon :-\/ (old wip figures)\n\trayMarchParametricBuilding( ray2, permuted, iv.rA, iv.bA, 0., hit, cell_index );\n\tif ( !SHADOW_EARLY_RET( hit.t ) ) rayMarchParametricBuilding( ray2, permuted, iv.rB, iv.bB, 1., hit, cell_index );\n\tif ( !SHADOW_EARLY_RET( hit.t ) ) rayMarchParametricBuilding( ray2, permuted, iv.rC, iv.bC, 2., hit, cell_index );\n\tif ( !SHADOW_EARLY_RET( hit.t ) ) rayMarchParametricBuilding( ray2, permuted, iv.rD, iv.bD, 3., hit, cell_index );\n#endif\n\n#endif\n}\n\n\/\/ ray march buildings in a cell\nvoid traceBuildings( Ray a_ray, inout TraceCityRetval ct, float split_cells_spacing, bool shadow_trace )\n{\n\tfloat maxh = MAX_BUILDING_HEIGHT;\n\tfloat minh = 2.;\n\n\tfloat rmin = -0.1;\n\tfloat rmax = max( 1., maxh );\n\n\t\/\/ we only dda trace the rmin, rmax z range\n\tfloat tbottom = plane_trace_z( a_ray, rmin, 1e-6 );\n\tfloat ttop = plane_trace_z( a_ray, rmax, 1e-6 );\n\n\tvec2 r0 = vec2( 0., MAX_DDA_TRACE );\n\tvec2 r1 = vec2( min( ttop, tbottom ), max( ttop, tbottom ) );\n\tvec2 r2 = vec2( max( r0.x, r1.x ), min( r0.y, r1.y ) ); \/\/ intersection of r0 and r1\n\n\/\/\tif ( r2.y <= r2.x ) return; \/\/ non sensical per drop if we return...\n\tr2 *= step( r2.x, r2.y ); \/\/ ...so instead do a zero length iteration\n\n\tfloat start_t = r2.x; \/\/ remember initial jump to return something along a_ray\n\n\tRay ray = mkray( a_ray.o + a_ray.d * start_t, a_ray.d ); \/\/ warp to tmin\n\tvec3 ray_end = a_ray.o + a_ray.d * r2.y;\n\n\tDDA3 dda = dda_init( ray.o, ray_end, CELL_SIZE, false );\n\n\t\/\/ trace within dda traversed cell\n\tParametricBuildingHit hit;\n\thit.t = FLT_MAX;\n\tfloat split_case = -1.;\n\n\t\/\/ dda traverse\n\tfor ( int i = 0; i < ( MAX_DDA_ITER FORCE_LOOP_LV1 )\n\t\t  && dot( dda.p - a_ray.o, dda.p - a_ray.o ) < r2.y * r2.y; ++i )\n\t{\n\t\t\/\/ raytrace 4 boxes inside each cell\n\t\tbounds2 b = mkbounds_unchecked( dda.c.xy * CELL_SIZE.xy, ( dda.c.xy + vec2( 1., 1. ) ) * CELL_SIZE.xy ); \/\/ cell bounds\n\t\tivec2 index = ivec2( dda.c.xy );\n\t\tvec4 a; a.xy = CELL_SPACING.xy * 0.5; a.zw = a.xy;\n\t\tif ( ( index.x & 1 ) == 0 ) a.xy = a.yx;\n\t\tif ( ( index.y & 1 ) == 0 ) a.zw = a.wz;\n\t\tb.pmin.xy += a.xz; \/\/ shrink cell bounds according to street margins (we alternate wide and narrow streets hence logic above)\n\t\tb.pmax.xy -= a.yw;\n\n\t\tvec2 margin = vec2( split_cells_spacing * 0.5 + 0.2 );\n\n\t\tvec2 r55 = hash22_( index ); \/\/ split type, permute\n\n\t\tRay ray2 = ray;\n\t\tbool permuted = false;\n\n\t\t#ifdef TILE_PERMUTATIONS\n\t\tif ( r55.y > 0.5 )\n\t\t{\n\t\t\t\/\/ random permutations, else default patterns look more or less all aligned\n\t\t\tray2.o.xyz = ray.o.yxz;\n\t\t\tray2.d.xyz = ray.d.yxz;\n\t\t\tb.pmin.xy = b.pmin.yx;\n\t\t\tb.pmax.xy = b.pmax.yx;\n\t\t\tpermuted = true;\n\t\t}\n\t\t#endif\n\n\t\tvec4 r4 = icdf( hash42_( index * 0x8da6b343 ) ); \/\/ heights hash\n\t\tvec4 rheights = mix( vec4( minh ), vec4( maxh ), r4 );\n\t\tvec4 r3 = hash42_( index * 0xb68f63e4 ); \/\/ split hash\n\t\tvec4 r3_0 = r3;\n\n\t\tr3.xyw = mix( vec3( 1. ), vec3( 5. ), r3.xyw ); \/\/ ratio of smallest to largest size\n\t\tr3.xy = fractions( r3.xyw ); \/\/ use r3.xyw as relative unit sizes\n\t\tr3.z = mix(  0.2,  0.8, r3.z );\n\n\t\tRanges_x4 iv;\n\n\t\tSplit4bSetup s4su = setup_Split4b( ray2, b.pmin.xy, b.pmax.xy, margin );\n\n\t\t\/\/ select a tile split pattern\n\t\tif ( r55.x > 0.75 )\n\t\t{\n\t\t\tbound_Split4b_xxy( iv, ray2, b.pmin.xy, b.pmax.xy, mix( b.pmin.xxy, b.pmax.xxy, r3.xyz ), rheights, margin );\n\t\t\ttrace_Split4b_xxy( iv, ray2, s4su, mix( b.pmin.xxy, b.pmax.xxy, r3.xyz ), rheights );\n\t\t\tsplit_case = 0.;\n\t\t}\n\t\telse if ( r55.x > 0.5 )\n\t\t{\n\t\t\tr3.xyz = fractions( mix( vec4( 2. ), vec4( 3. ), r3_0 ) );\n\n\t\t\tbound_Split4b_xxx( iv, ray2, b.pmin.xy, b.pmax.xy, mix( b.pmin.xxx, b.pmax.xxx, r3.xyz ), rheights, margin );\n\t\t\ttrace_Split4b_xxx( iv, ray2, s4su, mix( b.pmin.xxx, b.pmax.xxx, r3.xyz ), rheights );\n\t\t\tsplit_case = 1.;\n\t\t}\n\t\telse if ( r55.x > 0.25 )\n\t\t{\n\t\t\tbound_Split4b_xyy( iv, ray2, b.pmin.xy, b.pmax.xy, mix( b.pmin.xyy, b.pmax.xyy, r3.zxy ), rheights, margin );\n\t\t\ttrace_Split4b_xyy( iv, ray2, s4su, mix( b.pmin.xyy, b.pmax.xyy, r3.zxy ), rheights );\n\t\t\tsplit_case = 2.;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbound_Split4b_xyx( iv, ray2, b.pmin.xy, b.pmax.xy, mix( b.pmin.xyx, b.pmax.xyx, r3.xzy ), rheights, margin );\n\t\t\ttrace_Split4b_xyx( iv, ray2, s4su, mix( b.pmin.xyx, b.pmax.xyx, r3.xzy ), rheights );\n\t\t\tsplit_case = 3.;\n\t\t}\n\n\t\thit.t = FLT_MAX;\n\t\thit.tile_child_index = -1.; \/\/ no hit\n\n\t\trayMarchCellObjects( ray2, iv, permuted, hit, dda.c.xy, shadow_trace );\n\n\t\tif ( hit.t != FLT_MAX ) break; \/\/ we have hit, gtfo and fill other extra bits out of the loop\n\/\/\t\tif ( hit.t > ct.t ) return; \/\/ fixme: no point in continuing, but we should just set dda end point instead\n\n\t\tdda_step_infinite( dda ); \/\/ make sure you set a_finite to false in dda_init when calling this version\n\t}\n\n\tif ( hit.t >= ct.t ) return; \/\/ ct.t might be FLT_MAX so >= is important here\n\n\t\/\/ we hit a building\n\tct.p = ray.o + hit.t * ray.d;\n\tct.t = start_t + hit.t; \/\/ remember that we jumped at start\n\n\tif ( shadow_trace ) return; \/\/ we don't need normal, ao, material... gtfo\n\n\t\/\/ house type will use type index [0,3], building type will use index [4,7]\n\tpack_info( ct, dda.c.xy, split_case, hit.tile_child_index + hit.building_type * 4. );\n\n\tvec3 p = hit.ray2.o + hit.t * hit.ray2.d;\n\n#ifndef DEBUG_BUILDINGS_BOUNDS\n\t\n\tvec3 h = vec3( 0.01, 0., 0. ); \/\/ h.x *= hit.t; \/\/ grainy normals tweak\n\n\t#ifdef FORCE_GRAD_LOOP_BUILDING\n\tvec3 dcomp;\n\tfor ( int comp = 0 FORCE_LOOP; comp < 3; ++comp )\n\t{\n\t\tvec3 dp = p;\n\t\tdp[comp] += h.x;\n\t\tdcomp[comp] = sd_ParametricBuilding( hit.t, dp, hit.building_type, hit.b2, hit.height, hit.nh, hit.rnd ).d;\n\t}\n\tct.n = normalize( dcomp - vec3( hit.d ) );\n\t#else\n\tct.n = normalize( vec3( sd_ParametricBuilding( hit.t, p + h.xyz, hit.building_type, hit.b2, hit.height, hit.nh, hit.rnd ).d,\n\t\t\t\t\t\t\tsd_ParametricBuilding( hit.t, p + h.zxy, hit.building_type, hit.b2, hit.height, hit.nh, hit.rnd ).d,\n\t\t\t\t\t\t\tsd_ParametricBuilding( hit.t, p + h.yzx, hit.building_type, hit.b2, hit.height, hit.nh, hit.rnd ).d )\n\t\t\t\t\t  - hit.d ); \/\/ hit.d should be equal to sd_ParametricBuilding( hit.t, p, hit.building_type, hit.b2, hit.height, hit.nh, hit.rnd ).d\n\t#endif\n\n\t\/\/ do ao in permuted space\n\t#ifdef AO\n\t{\n\t\tRay ao_ray = mkray( p, ct.n );\n\t\tAO_BEGIN()\n\t\t\tfloat d = sd_ParametricBuilding( _ao_t, ao_ray.o + _ao_t * ao_ray.d, hit.building_type, hit.b2, hit.height, hit.nh, hit.rnd ).d;\n\t\tAO_END( ct.ao )\n\t}\n\t#else\n\tct.ao = 1.;\n\t#endif\n\n\tif ( hit.is_roof > 0. ) ct.type = IS_ROOF;\n\n\tif ( ( abs( hit.d - hit.windr.x ) < 0.001 ) \/\/ distance must be close to windows plane, stored in hit.windr.x\n\t\t && ( 0.01 < abs( dot( hit.windr.yz, ct.n.xy ) ) ) \/\/ normal must match window orientation\n\t\t \/\/ normal must be vertical\n\t\t && ( abs( ct.n.z ) < 0.005 ) ) ct.type = IS_WINDOW;\n\n\tif ( hit.permuted ) ct.n.xy = ct.n.yx;\n\n#endif\n}\n\nTraceCityRetval traceCity( Ray ray, bool shadow_trace )\n{\n\tTraceCityRetval ct;\n\tpack_info1( ct, FLT_MAX, vec3( 0. ), vec3( 0. ), 1., 0 );\n\tpack_info( ct, vec2( 0. ), 0., TYPE_SKY );\n\n\tfloat split_cells_spacing = 0.025;\n\n#if 1\n\t{\n\t\t\/\/ raytrace ground to close the horizon, only matters at street level (in bird view buildings occlude everything so it's useless) and traceBuildings needs its own ground for AO\n\t\tfloat t = plane_trace_z( ray, 0., 1e-6 );\n\t\tif ( 0. < t && t < ct.t && t < MAX_DDA_TRACE ) \/\/ use a max distance so the infinite plane doesn't extend beyond buildings horizon\n\t\t{\n\t\t\tpack_info1( ct, t, vec3( ( ray.o + t * ray.d ).xy, 0. ), vec3( 0., 0., 1. ), 1., 0 );\n\t\t\tpack_info( ct, vec2( 0. ), 0., TYPE_ROAD );\n\t\t}\n\t}\n#endif\n\n#if 1\n\t#ifdef HIGHWAYS\n\tif ( !SHADOW_EARLY_RET( ct.t ) )\n\t{\n\t\t\/\/ assuming highway is at constant height, we can raytrace that too and close a lot of the sdf marching hole at vanishing point\n\t\tfloat t = plane_trace_z( ray, HIGHWAY_HEIGHT, 1e-6 );\n\t\tif ( 0. < t && t < ct.t && t < MAX_HIGHWAY_TRACE )\n\t\t{\n\t\t\tvec3 p = ray.o + t * ray.d; \/\/ hit point\n\t\t\tif ( evalHighway( p.xy ).d < ROAD_HALFWIDTH )\n\t\t\t{\n\t\t\t\tpack_info1( ct, t, p, vec3( 0., 0., 1. ), 1., 0 );\n\t\t\t\tpack_info( ct, vec2( 0. ), 0., TYPE_HIGHWAY );\n\t\t\t}\n\t\t}\n\t}\n\t#endif\n#endif\n\n\t#ifdef BUILDINGS\n\tif ( !SHADOW_EARLY_RET( ct.t ) ) traceBuildings( ray, ct, split_cells_spacing, shadow_trace );\n\t#endif\n\n\t#ifdef HIGHWAYS\n\tif ( !SHADOW_EARLY_RET( ct.t ) )\n\t{\n\t\t\/\/ ray marched scene component\n\t\tfloat t = 0.;\n\t\tbool hit = false;\n\t\tvec3 p, dd;\n\t\t\/\/ narrow fov need 200\n\t\tfor ( int j = 0; j < 110 FORCE_LOOP_S; ++j )\n\t\t{\n\t\t\tp = ray.o + t * ray.d;\n\n\t\t\tdd = sd_RayMarchedCityBits( p, 0 );\n\n\t\t\tbool has_hit = abs( dd.x ) <= 0.001 * t; \/\/ no need to trace further than first building hit, or ground hit\n\t\t\tbool too_far = t > MAX_HIGHWAY_TRACE || t > ct.t; \/\/ hide glitter artifact in the distance, saves some ms too\n\n\t\t\tif ( has_hit || too_far )\n\t\t\t{\n\t\t\t\thit = has_hit;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tt += dd.x; \/\/ *TFRAC\n\t\t}\n\n\t\tif ( t < ct.t && hit )\n\t\t{\n\t\t\tct.p = p;\n\t\t\tct.t = t;\n\n\t\t\tif ( !shadow_trace ) \/\/ doubt it makes a difference, anyway shadow only need t\n\t\t\t{\n\t\t\t\tpack_info( ct, vec2( 0. ), 0., p.z < 0.004 * t ? TYPE_ROAD : TYPE_HIGHWAY );\n\n\t\t\t\tvec3 h = vec3( 0.01, 0., 0. );\n\t\t\/\/\t\th.x *= t; \/\/ grainy normals tweak => but that inflate pavement edges weirdly\n\n\t\t\t\t#ifdef FORCE_GRAD_LOOP_SCENE\n\t\t\t\tvec3 dcomp;\n\t\t\t\tfor ( int comp = 0 FORCE_LOOP; comp < 3; ++comp )\n\t\t\t\t{\n\t\t\t\t\tvec3 dp = ct.p;\n\t\t\t\t\tdp[comp] += h.x;\n\t\t\t\t\tdcomp[comp] = sd_RayMarchedCityBits( dp, 0 ).x;\n\t\t\t\t}\n\t\t\t\tct.n = normalize( dcomp - vec3(dd.x) );\n\t\t\t\t#else\n\t\t\t\tct.n = normalize( vec3( sd_RayMarchedCityBits( ct.p + h.xyz, 0 ).x,\n\t\t\t\t\t\t\t\t\t\t  sd_RayMarchedCityBits( ct.p + h.zxy, 0 ).x,\n\t\t\t\t\t\t\t\t\t\t  sd_RayMarchedCityBits( ct.p + h.yzx, 0 ).x )\n\t\t\t\t\t\t\t\t\t- dd.x );\n\t\t\t\t#endif\n\t\t\t\t\n\t\t\t\t#ifdef AO\n\t\t\t\t{\n\t\t\t\t\tRay ao_ray = mkray( ct.p, ct.n );\n\t\t\t\t\tAO_BEGIN()\n\t\t\t\t\t\tfloat d = sd_RayMarchedCityBits( ao_ray.o + _ao_t * ao_ray.d, 0 ).x;\n\t\t\t\t\tAO_END( ct.ao )\n\t\t\t\t}\n\t\t\t\t#else \n\t\t\t\tct.ao = 1.;\n\t\t\t\t#endif\n\n\t\t\t\tct.type = 0;\n\n\t\t\t\tif ( abs( dd.y - dd.x ) < 0.0000007 ) ct.type = IS_LAMP;\n\t\t\t\tif ( abs( dd.z - dd.x ) < 0.0000007 ) ct.type = IS_SIGN;\n\t\t\t}\n\t\t}\n\t}\n\t#endif\n\n\tct.ao = min( ct.ao, 1. ); \/\/ apparently this goes above 1 and whitens far away pixel... so clamp\n\n\treturn ct;\n}\n\nstruct CameraPosAndTangent { vec3 eye; vec2 tangent; };\nstruct CameraRet { vec3 eye; vec3 target; float roll; float pitch; };\n\nCameraRet init_cam() { CameraRet cam; cam.roll = 0.; cam.pitch = 0.; return cam; }\n\nmat4 look_around_mouse_control( mat4 camera, float pitch, float tan_half_fovy, float look_at_the_abyss )\n{\n\tfloat mouse_ctrl = 1.0;\n\tvec2 mm_offset = vec2( 0.0, pitch );\n\tvec2 mm = vec2( 0.0, 0.0 );\n\n#ifndef EXTRA_3D_CAMERA\n\tif ( iMouse.z > 0.0 || STICKY_MOUSE ) mm = ( iMouse.xy - iResolution.xy * 0.5 ) \/ ( min( iResolution.x, iResolution.y ) * 0.5 );\n#endif\n\n\tfloat mm_y = mm.y;\n\n\tmm.x = -mm.x;\n\tmm = sign( mm ) * pow( abs( mm ), vec2( 0.9 ) );\n\tmm *= PI * tan_half_fovy * mouse_ctrl;\n\tmm += mm_offset;\n\n\tif ( mm_y < 0. )\n\t{\n\t\t\/\/ very special case camera control for getRoofTopCoffeeBreakCamera\n\t\tvec3 v = camera[2].xyz;\n\t\tv.xy = rotate_with_angle( v.xy, mm.x );\n\t\tcamera[3].xyz += v * mm.y * look_at_the_abyss;\n\t}\n\n\treturn camera * yup_spherical_coords_to_matrix( mm.y, mm.x );\n}\n\nCameraPosAndTangent getDriveCameraPosAndTangent( float t, float lateral_move_amplitude )\n{\n\/\/\tt -= 200. * iSlider0;\n\tfloat x = t * 4.;\n\tfloat e = 1e-2;\n\tvec3 p1 = sd_CameraCurveXY( x );\n\tvec3 p2 = sd_CameraCurveXY( x + e );\n\tvec2 tangent = ( p2.xy - p1.xy ) \/ e;\n\tCameraPosAndTangent ret;\n\tret.eye = p1;\n\tret.tangent = tangent;\n\tret.eye.xy += lateral_move_amplitude * perp( tangent ) * sin( 2. * PI * t \/ 5. ) * ROAD_HALFWIDTH * 0.5 * abs( tangent.y );\n\treturn ret;\n}\n\n\/\/ we use those for drive camera vibrations\nfloat noise( float x ) { float xi = floor( x ); return mix( hash11( xi ), hash11( xi + 1. ), smoothstep_unchecked( x - xi ) ); }\nfloat noisem11( float x ) { return 2. * ( noise( x ) - 0.5 ); }\nfloat fbm( float x ) { return noisem11( x ) + noisem11( x * 2. ) * 0.5 + noisem11( x * 4. ) * 0.25 + noisem11( x * 8. ) * 0.125; }\n\nCameraRet getDriveCamera( float t )\n{\n\tfloat lateral_move_amplitude = 1.;\n\tCameraPosAndTangent cam0 = getDriveCameraPosAndTangent( t, lateral_move_amplitude );\n\n\tCameraRet cam = init_cam();\n\tcam.eye = cam0.eye;\n\n\t\/\/ those 2 evals are for camera acceleration effects and target eval\n\tCameraPosAndTangent camnext1 = getDriveCameraPosAndTangent( t - 1.0, lateral_move_amplitude );\n\tCameraPosAndTangent camnext2 = getDriveCameraPosAndTangent( t + 0.5, lateral_move_amplitude );\n\n\t{\n\t\t\/\/ for road vibrations we must be close enough to road surface\n\t\tfloat driving_vibrations = max( smoothbump( HIGHWAY_HEIGHT, 4., cam.eye.z ), smoothbump( 0., 4., cam.eye.z ) );\n\t\tcam.eye.xy += driving_vibrations * perp( cam0.tangent ) * fbm( 100. + t * 0.1 ) * 0.3;\n\t\tcam.eye.z += driving_vibrations * fbm( t ) * 0.015; \/\/ road roughness\n\t}\n\n\tcam.roll = ( camnext2.tangent.y - camnext1.tangent.y ) * 0.3; \/\/ roll\n\n\tcam.target = camnext2.eye;\n\n\t\/\/ drift logic\n\tfloat tr = repeat_e( t, 0., 30. );\n\tcam.target.xy = cam.eye.xy + rotate_with_unit_vector( cam.target.xy - cam.eye.xy, unit_vector2( PI * smoothstep( 5., 10., tr ) + \/\/ 180 = flying looking backward for a while\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tPI * smoothstep( 15., 20., tr ) ) ); \/\/ 360 = back to travel direction\n\treturn cam;\n}\n\nvec3 getStraightFlightCameraPos( float time )\n{\n\ttime += 200.;\n\tvec2 v = unit_vector2( -time * 0.05 );\n\treturn vec3( v * 100. + 50. * log( 1. + time ), 15. );\n}\n\nCameraRet getStraightFlightCamera( float t, inout float tan_half_fovy, float duration )\n{\n\tfloat u = t \/ duration;\n\tt += 8.;\n\tCameraRet cam = init_cam();\n\tcam.eye = getStraightFlightCameraPos( t );\n\tcam.target = getStraightFlightCameraPos( t + 1. );\n\tcam.target.xy = cam.eye.xy + rotate_with_unit_vector( cam.target.xy - cam.eye.xy, unit_vector2( -PI * smoothstep( 1., 0., u ) ) );\n\ttan_half_fovy = 0.5;\n\tcam.pitch = radians( -20. );\n\treturn cam;\n}\n\n\/\/ get position of a point that travelled at constant speed a long a log spiral, starting from theta0\nvec2 log_spiral( float d, float theta0, float a, float b )\n{\n\/\/\td( theta ) = integral of a * exp( b * theta ) dtheta = ( exp( b * theta ) - exp( b * theta0 ) ) * a \/ b;\n\tfloat theta = log( d * ( b \/ a ) + exp( b * theta0 ) ) \/ b;\n\treturn a * exp( b * theta ) * unit_vector2( theta );\n}\n\nvec3 getRoofTopCoffeeBreakCameraPos( float u )\n{\n\tvec2 v = log_spiral( (u)*4.3, 0., 1., 1. );\n\tv -= normalize( v ) * 1.;\n\tv.xy *= vec2( 0.51, 0.95 );\n\treturn vec3(v.xy,0.) + vec3(593.983276,-76.936417,8.693137); \/\/ add start position\n}\n\n\/\/ walk on a roof top and lookup at airliner\nCameraRet getRoofTopCoffeeBreakCamera( float t, inout float tan_half_fovy, float duration, inout float look_at_the_abyss )\n{\n\tCameraRet cam = init_cam();\n\tvec3 start_pos = vec3(593.983276,-76.936417,8.693137);\n\tfloat u = saturate( t \/ duration );\n\tcam.eye = getRoofTopCoffeeBreakCameraPos( u );\n\tcam.eye.z += ( ( 1. + sin( u * 95. ) ) * 0.5 ) * 0.001; \/\/ walk\n\tfloat ra = mix( -radians( 1.5 ), PI * 1.17, smoothstep( 0.2, 1., u ) );\n\tcam.target = cam.eye + vec3( unit_vector2( ra ), 0. );\n\tcam.pitch = smoothbump( u, 0.6, 0.75, 0.82, 1.01 ) * PI * 0.5 * 0.75;\n\tlook_at_the_abyss = 0.2 * smoothstep( 0.8, 0.6, u );\n\treturn cam;\n}\n\n\/\/ ( offset x, offset y, angle, time offset )\n\/\/#define LSFC vec4(iSlider2,iSlider3,iSlider4,iSlider5)\n#define LSFC vec4(0.,0.35,0.2214,0.0928)\n\nvec3 getLogSpiralCameraFlyPos( float t, inout float pitch )\n{\n\t#if 0\n\t\/\/ old camera, a bit long\n\tfloat dz = exp_bell( t -35.5, 5. );\n\tpitch = radians( -18. );\n\tpitch -= dz * radians( 3.5 );\n\t#else\n\tfloat dz = exp_bell( t -15.5, 5. ) * 0.5;\n\tpitch = radians( -18. );\n\tpitch -= dz * radians( 3.5 );\n\t#endif\n\treturn vec3( vec2( -100. ) + 200. * LSFC.xy, 8.3 )\n\t\t   + vec3( rotate_with_angle( log_spiral( LSFC.w * 200. + t * 1.2, 0.1, 1., 1. )\n\t\t\t\t\t\t\t\t\t  , -LSFC.z * PI * 2. ), dz * 3. );\n}\n\n\/\/ fly along a log spiral with constant roll\nCameraRet getLogSpiralCameraFly( float t, inout float tan_half_fovy )\n{\n\tCameraRet cam = init_cam();\n\tcam.eye = getLogSpiralCameraFlyPos( t, cam.pitch );\n\tcam.target = getLogSpiralCameraFlyPos( t + 1., cam.pitch );\n\tcam.roll = radians( 10. );\n\ttan_half_fovy = 0.53;\n\treturn cam;\n}\n\n\/\/ goes through p1,p2\nvoid catmullrom( out vec3 point, out vec3 derivative, float t, vec3 p0, vec3 p1, vec3 p2, vec3 p3 )\n{\n\tfloat t2 = t * t;\n\tfloat t3 = t2 * t;\n\tvec3 a1 = -p0 + p2;\n\tvec3 a2 = 2. * p0 - 5. * p1 + 4. * p2 - p3;\n\tvec3 a3 = -p0 + 3. * p1 - 3. * p2 + p3;\n\tpoint = 0.5 * ( ( 2. * p1 ) + a1 * t + a2 * t2 + a3 * t3 );\n\tderivative = 0.5 * ( a1 + a2 * 2. * t + a3 * 3. * t2 ); \/\/ whilst we are at it\n}\n\n\/\/ goes through p1,p2,p3\nvoid catmullrom( out vec3 point, out vec3 derivative, float t, vec3 p0, vec3 p1, vec3 p2, vec3 p3, vec3 p4 )\n{\n\tif ( t < 0.5 ) catmullrom( point, derivative, t * 2., p0, p1, p2, p3 );\n\telse catmullrom( point, derivative, 2. * ( t - 0.5 ), p1, p2, p3, p4 );\n}\n\n\/\/#define UTBSC vec2(iSlider0,iSlider1)\n\/\/#define UTBSC vec2(0.585714,0.35)\n#define UTBSC vec2(0.585714,0.707143) \/\/ best\n\nCameraRet getUnderTheBridgeStreetCamera( float t, inout float tan_half_fovy, float duration )\n{\n\tCameraRet cam = init_cam();\n\tfloat u = saturate( t \/ duration );\n\tvec3 o = vec3( floor( UTBSC.x * 100. ) * 80. * 2., \n\t\t\t\t   floor( UTBSC.y * 100. ) * CELL_SIZE.y, 0. );\n\tvec3 p0 = o + vec3( -80.457870, -10.903438, 0.591591 );\n\tvec3 p1 = o + vec3( -80.274940, -3.2, 0.517319 );\n\tvec3 p2 = o + vec3( -79.289925, 2.674706, 1.934119 );\n\tvec3 p3 = o + vec3( -74.650077819, 3.327467679, 3.193379163 );\n\tvec3 p4 = o + vec3( -71.289779663, 4.606474399, 3.521366834 );\n\tvec3 derivative;\n\tcatmullrom( cam.eye, derivative, u, p0, p1, p2, p3, p4 );\n\tcam.target = cam.eye + derivative;\n\tcam.pitch = mix( radians( -22. ), 0., u );\n\tcam.roll = mix( radians( 0. ), radians( -8. ), smoothstep( 0.2, 0.8, u ) );\n\treturn cam;\n}\n\n\/\/#define IFC vec3(iSlider0,iSlider1,iSlider2)\n#define IFC vec3(0.6,0.62,0.328)\n\nCameraRet getIsoFlyCamera( float t, inout float tan_half_fovy, float duration )\n{\n\tCameraRet cam = init_cam();\n\tvec2 travel_dir = normalize( vec2( -1.8, 1.4 ) );\n\tcam.eye = vec3( travel_dir * t * 4., 65. );\n\tcam.eye += vec3( IFC.x * 200., IFC.y * 200., 0. );\n\tcam.target = cam.eye + vec3( perp( travel_dir ), 0. );\n\tcam.pitch = radians( -60. * IFC.z );\n\ttan_half_fovy = 0.1;\n\treturn cam;\n}\n\n\/\/ get close to a LCD panel that shows the squid invaders things\nCameraRet getLCDScreenCloseUpCamera( float t, inout float tan_half_fovy, float duration )\n{\n\tCameraRet cam = init_cam();\n\tcam.eye = vec3( -5.514656066, -0.541317582, 2.770161151 );\n\tcam.target = cam.eye + vec3( -1., 0., 0. );\n\tvec3 a = vec3( -6.56, -0.8, 3.3 );\n\tvec3 b = vec3( -6.56, 0.8, 3.3 );\n\tcam.eye.x += 1.5;\n\tcam.eye.z -= 0.5;\n\tfloat u = saturate( t \/ duration );\n\tvec3 c = mix( a, b, u );\n\tc.x += 0.8;\n\tcam.eye = mix( cam.eye, c - vec3( 0., 0., 0.5 ), u );\n\tcam.target = mix( cam.target, mix( a, b, 0.8 ), pow( u, 2. ) );\n\ttan_half_fovy = mix( 0.47, 0.4, u );\n\treturn cam;\n}\n\nmat4 getCamera( inout float tan_half_fovy, inout float fade, inout float a_contrast, vec3 l, inout float time, inout float ground_ao )\n{\n\tfloat total = 0.;\n\t\/\/ per camera time range: array of start, duration (yes I am aware of the syntax that pretends we can have arrays)\n\tvec2 r1 = vec2( total, 41. ); total += r1.y;\n\tvec2 r2 = vec2( total, 20. ); total += r2.y;\n\tvec2 r3 = vec2( total, 20. ); total += r3.y;\n\tvec2 r4 = vec2( total, 8.5 ); total += r4.y;\n\tvec2 r5 = vec2( total, 12. ); total += r5.y;\n\tvec2 r6 = vec2( total,  8. ); total += r6.y;\n\tvec2 r7 = vec2( total, 22. ); total += r7.y;\n\n\ttime = mod( time, total ); \/\/ cycle through all cameras\n\n\/\/\tvec2 r = r2; \/\/ <= select a specific camera to test here\n\/\/\ttime = r.x + mod( time, r.y );\n\/\/  time = r.x + 1.;\n\n\tfloat tr = 0.7; \/\/ fade half durations\n\tfade *= 1. -( max( cosbump( time, 0., tr ), cosbump( time, total, tr )) \/\/ those 2 overlap\n\t\t\t\t + cosbump( time, r2.x, tr )+ cosbump( time, r3.x, tr )\n\t\t\t\t + cosbump( time, r4.x, tr )+ cosbump( time, r5.x, tr )\n\t\t\t\t + cosbump( time, r6.x, tr )+ cosbump( time, r7.x, tr ));\n\n\tfloat look_at_the_abyss = 0.;\n\n\tCameraRet cam;\n\n\t     if ( time < r1.x + r1.y ) { time -= r1.x; cam = getDriveCamera( time ); }\n\telse if ( time < r2.x + r2.y ) { time -= r2.x; cam = getLogSpiralCameraFly( time, tan_half_fovy ); ground_ao = 0.7; }\n\telse if ( time < r3.x + r3.y ) { time -= r3.x; cam = getRoofTopCoffeeBreakCamera( time, tan_half_fovy, r3.y, look_at_the_abyss ); ground_ao = 0.375; }\n\telse if ( time < r4.x + r4.y ) { time -= r4.x; cam = getUnderTheBridgeStreetCamera( time, tan_half_fovy, r4.y ); }\n\telse if ( time < r5.x + r5.y ) { time -= r5.x; cam = getStraightFlightCamera( time, tan_half_fovy, r5.y ); ground_ao = 0.7; }\n\telse if ( time < r6.x + r6.y ) { time -= r6.x; cam = getLCDScreenCloseUpCamera( time, tan_half_fovy, r6.y ); }\n\telse                           { time -= r7.x; cam = getIsoFlyCamera( time, tan_half_fovy, r7.y ); ground_ao = 0.375; }\n\n\tmat4 camera = lookat( cam.eye, cam.target, vec3( 0., 0., 1. ) ) * z_rotation( cam.roll );\n\treturn look_around_mouse_control( camera, cam.pitch, tan_half_fovy, look_at_the_abyss );\n}\n\n\/\/ trace the silhouette of an a350 airliner, alt = 10000 at cruising altitude\nfloat get_airliner( Ray view_ray, float alt, float cruising_speed_fraction, float d, vec2 mv \/\/ normalized please\n\t\t\t\t\t, float tan_half_fovy, float time_offset, float direction, float trail_fade, float time )\n{\n\/\/\tcruising_speed_fraction *= 5.; \/\/ DEBUG\n\tfloat airliner_cruising_speed = cruising_speed_fraction * ( 950000. \/ ( 60. * 60. ) ); \/\/ m\/s\n\tfloat R1 = 5. * alt * tan_half_fovy; \/\/ make all trajectory disks roughly same radius from ground\n\tfloat R2 = R1 * 1.4;\n\tfloat fade_time = 1.;\n\tfloat h1 = sqrt( R1 * R1 - d * d );\n\tfloat h2 = sqrt( R2 * R2 - d * d );\n\tvec2 O = vec2( 0., 0 );\n\tvec2 c = O + mv * d;\n\tvec2 travel_direction = perp( mv ) * direction;\n\tfloat looptime = 2. * h2 \/ airliner_cruising_speed;\n\tfloat rt = mod( time + time_offset, looptime );\n\tfloat u = rt * airliner_cruising_speed;\n\tvec3 plane_pos = vec3( c + travel_direction * ( u - h2 ), alt );\n\tfloat t = plane_trace_z( view_ray, alt, 0. ); \/\/ epsilon zero, we don't care it's in the sky\n\tvec3 it = view_ray.o + view_ray.d * t;\n\tfloat dd = length( it.xy );\n\tfloat x = dot( it.xy - plane_pos.xy, -travel_direction ) - 47.;\n\tfloat y = abs( dot( it.xy - plane_pos.xy, perp( travel_direction ) ) );\n\tfloat fade = smoothstep( h2, h1, abs( u - h2 ) );\n\tfloat trail_disk_fade = smoothstep( R2, R1, dd );\n\t\/\/ note: y is already symmetrized\n\tfloat trail_half_spacing = 9.;\n\tfloat dc = exp_decay( x * 0.02 );\n\tfloat engine_trail = ( x < 0. ? 0. : smoothstep( 2., -1., abs( y - trail_half_spacing ) - dc * 4. ) )\n\t\/\/ trail distance decay\n\t\t* exp( -x * 0.00175 );\n\tfloat trail = engine_trail * fade * trail_disk_fade * trail_fade;\n\tfloat debug = 0.;\n\tvec2 uv = ( it - plane_pos ).xy * ( 20. \/ 64. ); \/\/ plane outline sdf to scale\n\tif ( length( uv ) > 12. ) return debug + trail + 0.; \/\/ outside plane sdf's disk\n\treturn debug + trail + fade * smoothstep( 0.1, -0.1, sd_airliner_a350( rotate_with_unit_vector( uv, vec2( travel_direction.x, -travel_direction.y ) ) ) ); \/\/ plane\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat aspect = iResolution.x \/ iResolution.y;\n\tvec2 u = fragCoord.xy \/ iResolution.xy;\n\tfragColor.a = 1.;\n\tfloat a_contrast = 1.;\n\tfloat fade = 1.;\n\tfloat ground_ao = 1.; \/\/ 1. == no ground ao... a bit of ground ao helps in flight cameras\n\n#if 1\n\tvec3 l = normalize( vec3( 0.8, 0.025, 0.125 ) ); \/\/ sun direction\n#else\n\/\/ sun is meant to be at a sunset-ish position, looks bad else\n\tvec3 l = zup_spherical_coords_to_vector( PI * 0.5 * (1. - iSlider0), 2. * PI * (iSlider1 - 0.5) ); \/\/ sun direction\n#endif\n\n\/\/\tfragColor.rgb = test_sky( fragCoord, l ); return; \/\/ contemplate sky probe, for the interested reader\n\/\/\tfragColor.rgb = get_building_palette( fragCoord.xy \/ min( iResolution.x, iResolution.y ) ); return; \/\/ for the curious\n\n\tfloat time = iTime + 20.;\n\n#ifdef EXTRA_3D_CAMERA\n\tfloat tan_half_fovy = iTanHalfFovy;\n\tmat4 camera = mat4( iCamera[0], iCamera[1], iCamera[2], iCamera[3] );\n#else\n\tfloat tan_half_fovy = 0.6; \/\/ fovy 61 deg\n\tmat4 camera = getCamera( tan_half_fovy, fade, a_contrast, l, time, ground_ao );\n#endif\n\n\tRay view_ray = get_view_ray( ( u - vec2( 0.5 )) * 2.0, 0.1, aspect, tan_half_fovy );\n\tview_ray = mkray( camera[3].xyz, ( camera * vec4( view_ray.d, 0.0 )).xyz );\n\tview_ray.d.z += 1e-5; \/\/ divide by zero quick workaround\n\n#if defined(UNROLL_LOOP0)||!defined(SHADOWS)\n\tTraceCityRetval ct = traceCity( view_ray, false );\n\tfloat shadow = 1.;\n#ifdef SHADOWS\n\tRay sray = mkray( ct.p + ct.n * 0.0025 * ct.t, l );\n\tTraceCityRetval ct_shadow = traceCity( sray, true );\n\tshadow = step( FLT_MAX, ct_shadow.t );\n#endif\n#else\n\t\/\/ do view ray and shadow ray in a loop in hope to reduce chance of hitting webgl crashes\n\tRay r = view_ray;\n\tTraceCityRetval ct;\n\tfloat shadow = 1.;\n\tfor ( int i = 0; i < 2 FORCE_LOOP_LV0 ; ++i )\n\t{\n\t\tTraceCityRetval ctr = traceCity( r, i == 1 );\n\t\tr = mkray( ctr.p + ctr.n * 0.0025 * ctr.t, l ); \/\/ set shadow ray for second pass\n\t\tif ( i == 0 ) ct = ctr;\n\t\tshadow = step( FLT_MAX, ctr.t ); \/\/ only relevant at end of second pass\n\t}\n#endif\n\n#if 0\n\t\/\/ raytrace one last thing... only a tiny little thin one (actually, 3 tiny little thin ones)\n\tfloat airliner = 0.;\n\tairliner = max( airliner, get_airliner( view_ray, 1000., 0.3, 2000.,          V45, tan_half_fovy, 15.,  1., 1. , time ) ); \/\/ set time to 673 for debug\n\tairliner = max( airliner, get_airliner( view_ray, 5000., 0.8, 500. ,  vec2(1.,0.), tan_half_fovy, 45., -1., 1. , time ) );\n\tairliner = max( airliner, get_airliner( view_ray, 1500., 0.4, 0.   , vec2(-1.,0.), tan_half_fovy, 40., -1., 0.7, time ) );\n#else\n\t\/\/ unrolling is cleaner than this horrible mess but I wanted the option to try force a loop\n\tfloat airliner = 0.;\n\tfor ( int i = 0; i < 3 FORCE_LOOP_B; ++i )\n\t{\n\t\tfloat airliner_alt = 1000. + (i == 1 ? 4000. : 0.) + (i == 2 ? 500. : 0.);\n\t\tfloat airliner_cruising_speed_fraction = 0.3 + (i == 1 ? 0.5 : 0.) + (i == 2 ? 0.1 : 0.);\n\t\tfloat airliner_d = float(2-i) * 500. + (i == 0 ? 1000. : 0.);\n\t\tvec2 mv = (i == 0 ? V45 : vec2( 0. )) + (i == 1 ? vec2( 1., 0. ) : vec2( 0. )) + (i == 2 ? vec2( -1., 0. ) : vec2( 0. ));\n\t\tfloat time_offset = 15. + (i == 1 ? 30. : 0.) + (i == 2 ? 25. : 0.);\n\t\tfloat direction = (i == 0 ? 1. : -1.);\n\t\tfloat trail_fade = (i == 2 ? 0.7 : 1.);\n\t\tairliner = max( airliner, get_airliner( view_ray, airliner_alt, airliner_cruising_speed_fraction, airliner_d, mv, tan_half_fovy, time_offset, direction, trail_fade, time ) );\n\t}\n#endif\n\n\tfragColor.rgb = fade * shadeCity( ct, view_ray.o, view_ray.d, l, shadow, airliner, a_contrast, u, aspect, ground_ao );\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"XsXGRS","date":"1372545053","viewed":13204,"name":"The Blob","username":"4rknova","description":"Balls are touching.","likes":101,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ by nikos papadopoulos, 4rknova \/ 2013\n\/\/ Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define AA 4.\n\n#define CI vec3(.3,.5,.6)\n#define CO vec3(0.0745, 0.0862, 0.1058)\n#define CM vec3(.0)\n#define CE vec3(.8,.7,.5)\n\nfloat metaball(vec2 p, float r)\n{\n\treturn r \/ dot(p, p);\n}\n\nvec3 samplef(in vec2 uv)\n{\n\tfloat t0 = sin(iTime * 1.9) * .46;\n\tfloat t1 = sin(iTime * 2.4) * .49;\n\tfloat t2 = cos(iTime * 1.4) * .57;\n\n\tfloat r = metaball(uv + vec2(t0, t2), .33) *\n\t\t\t  metaball(uv - vec2(t0, t1), .27) *\n\t\t\t  metaball(uv + vec2(t1, t2), .59);\n\n\tvec3 c = (r > .4 && r < .7)\n\t\t\t  ? (vec3(step(.1, r*r*r)) * CE)\n\t\t\t  : (r < .9 ? (r < .7 ? CO: CM) : CI);\n\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy \/ iResolution.xy * 2. - 1.)\n\t\t\t* vec2(iResolution.x \/ iResolution.y, 1) * 1.25;\n\n    vec3 col = vec3(0);\n\n#ifdef AA\n    \/\/ Antialiasing via supersampling\n    float e = 1. \/ min(iResolution.y , iResolution.x);    \n    for (float i = -AA; i < AA; ++i) {\n        for (float j = -AA; j < AA; ++j) {\n    \t\tcol += samplef(uv + vec2(i, j) * (e\/AA)) \/ (4.*AA*AA);\n        }\n    }\n#else\n    col += samplef(uv);\n#endif \/* AA *\/\n    \n    fragColor = vec4(clamp(col, 0., 1.), 1);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"ltXSDB","date":"1439341322","viewed":13163,"name":"Bezier - Signed Distance","username":"ajs15822","description":"Analytical signed distance to a quadratic bezier curve. Click and drag to move the center control point.","likes":138,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Signed Distance to a Quadratic Bezier Curve\n\/\/ - Adam Simmons (@adamjsimmons) 2015\n\/\/\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\/\/\n\/\/ Inspired by http:\/\/www.pouet.net\/topic.php?which=9119\n\/\/ and various shaders by iq, T21, and demofox\n\/\/ \n\/\/ I needed the -signed- distance to a quadratic bezier\n\/\/ curve but couldn't find any examples online that\n\/\/ were both fast and precise. This is my solution.\n\/\/\n\/\/ v1 - Initial release\n\/\/ v2 - Faster and more robust sign computation\n\/\/\n\n\/\/ Test if point p crosses line (a, b), returns sign of result\nfloat testCross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n\/\/ Determine which side we're on (using barycentric parameterization)\nfloat signBezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{ \n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) \/ (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0, \n        step(testCross(A, B, p) * testCross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * testCross(A, C, B);\n}\n\n\/\/ Solve cubic equation for roots\nvec3 solveCubic(float a, float b, float c)\n{\n    float p = b - a*a \/ 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) \/ 27.0 + c;\n    float d = q*q + 4.0*p3 \/ 27.0;\n    float offset = -a \/ 3.0;\n    if(d >= 0.0) { \n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) \/ 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0\/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 \/ p3) * q \/ 2.0) \/ 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p \/ 3.0) + offset;\n}\n\n\/\/ Find the signed distance from a point to a bezier curve\nfloat sdBezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{    \n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) \/ dot(b,b);      \n    vec3 t = clamp(solveCubic(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * signBezier(A, B, C, p);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)\/iResolution.y;\n    vec2 m = mix((2.0*iMouse.xy-iResolution.xy)\/iResolution.y,\n        vec2(cos(iTime * 1.2) * 0.8, 0.0), step(iMouse.z, 0.0));\n    \n    \/\/ Define the control points of our curve\n    vec2 A = vec2(0.0, -0.6), C = vec2(0.0, +0.6), B = (4.0 * m - A - C) \/ 2.0;\n    \n    \/\/ Render the control points\n    float d = min(distance(p, A),(min(distance(p, m),distance(p, C))));\n    if (d < 0.04) { fragColor = vec4(1.0 - smoothstep(0.025, 0.034, d)); return; }\n    \n    \/\/ Get the signed distance to bezier curve\n    d = sdBezier(A, B, C, p);\n    \n    \/\/ Visualize the distance field using iq's orange\/blue scheme\n    fragColor = vec4(1.0) - sign(d)*vec4(0.1,0.4,0.7,1.0);\n    fragColor *= (1.0 - exp(-4.0*abs(d))) * (0.8 + 0.2*cos(140.*d));\n    fragColor = mix(fragColor, vec4(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"3lcSW2","date":"1581674127","viewed":13099,"name":"shader01","username":"monodnb","description":"turbulent","likes":1,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\/\/\tSimplex 3D Noise \n\/\/\tby Ian McEwan, Ashima Arts\n\/\/\nvec4 permute(vec4 x){return mod(((x*65.0)+5.0)*x, 350.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n    const vec2  C = vec2(1.0\/6.0, 1.0\/3.0) ;\n    const vec4  D = vec4(0.0, 0.0, 1.0, 2.3);\n\n\/\/ First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n\/\/ Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    \/\/  x0 = x0 - 0. + 0.0 * C \n    vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n    vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n    vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n\/\/ Permutations\n    i = mod(i, 350.0 ); \n    vec4 p = permute( permute( permute( \n                         i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                     + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n                     + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n\/\/ Gradients\n\/\/ ( N*N points uniformly over a square, mapped onto an octahedron.)\n    float n_ = 1.0\/7.0; \/\/ N=7\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  \/\/  mod(p,N*N)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    \/\/ mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n\/\/Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n\/\/ Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat fbm( vec3 p ) {\n        float f = 0.0;\n        f += 0.772*snoise( p ); p = p*2.02;\n        f += 0.25*snoise( p ); p = p*2.03;\n        f += 0.1250*snoise( p ); p = p*2.01;\n        f += 0.0625*snoise( p );\n        return f\/0.9375;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord \/ iResolution.xy;\n    float mouseRatio = smoothstep(100.0, 0.0, length(iMouse.xy - fragCoord.xy));\n    float noise = 0.25 + fbm(vec3(uv * 12.0 + (iMouse.xy - fragCoord.xy) * mouseRatio * 0.05, iTime * 0.18 + 0.5 * mouseRatio));\n    noise *= 0.25 + snoise(vec3(uv * 4.0 + 1.5, iTime * 0.15));\n    fragColor = vec4(1.0, 1.0, 1.0, noise);\n}\n\n\/** SHADERDATA\n{\n\t\"title\": \"shader1\",\n\t\"description\": \"turbulent\",\n\t\"model\": \"nothing\"\n}\n*\/","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"XtjSDK","date":"1446586286","viewed":13095,"name":"Sculpture III","username":"iq","description":"Another sine\/cosine deformation of a sphere.","likes":201,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"\/media\/a\/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"\/media\/ap\/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Copyright Inigo Quilez, 2015 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work neither\n\/\/ as it is or altered, here on Shadertoy or anywhere else, in any\n\/\/ form including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it or train a neural\n\/\/ network with it without permission. I share this Work for educational\n\/\/ purposes, and you can link to it, through an URL, proper attribution\n\/\/ and unmodified screenshot, as part of your educational material. If\n\/\/ these conditions are too restrictive please contact me and we'll\n\/\/ definitely work it out.\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2  \/\/ Set AA to 1 if your machine is too slow\n#endif\n\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat hash1( in vec2 f ) \n{ \n    return fract(sin(f.x+131.1*f.y)*43758.5453123); \n}\n\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float PHI = 1.6180339887498948482045868343656;\n\nvec3 forwardSF( float i, float n) \n{\n    float phi = 2.0*PI*fract(i\/PHI);\n    float zi = 1.0 - (2.0*i+1.0)\/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\nvec4 grow = vec4(1.0);\n\nvec3 mapP( vec3 p )\n{\n    p.xyz += 1.000*sin(  2.0*p.yzx )*grow.x;\n    p.xyz += 0.500*sin(  4.0*p.yzx )*grow.y;\n    p.xyz += 0.250*sin(  8.0*p.yzx )*grow.z;\n    p.xyz += 0.050*sin( 16.0*p.yzx )*grow.w;\n    return p;\n}\n\nfloat map( vec3 q )\n{\n    vec3 p = mapP( q );\n    float d = length( p ) - 1.5;\n\treturn d * 0.05;\n}\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 7.0;\n\n\tfloat precis = 0.001;\n    float h = 1.0;\n    float t = 1.0;\n    for( int i=0; i<1256; i++ )\n    {\n        if( (h<precis) || (t>maxd) ) break;\n\t    h = map( ro+rd*t );\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n\treturn t;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.005,0.0,0.0);\n\treturn normalize( vec3(\n           map(pos+eps.xyy) - map(pos-eps.xyy),\n           map(pos+eps.yxy) - map(pos-eps.yxy),\n           map(pos+eps.yyx) - map(pos-eps.yyx) ) );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, in vec2 pix )\n{\n\tfloat ao = 0.0;\n    for( int i=0; i<64; i++ )\n    {\n        vec3 ap = forwardSF( float(i), 64.0 );\n\t\tap *= sign( dot(ap,nor) ) * hash1(float(i));\n        ao += clamp( map( pos + nor*0.05 + ap*1.0 )*32.0, 0.0, 1.0 );\n    }\n\tao \/= 64.0;\n\t\n    return clamp( ao*ao, 0.0, 1.0 );\n}\n\nfloat calcAO2( in vec3 pos, in vec3 nor, in vec2 pix )\n{\n\tfloat ao = 0.0;\n    for( int i=0; i<32; i++ )\n    {\n        vec3 ap = forwardSF( float(i), 32.0 );\n\t\tap *= sign( dot(ap,nor) ) * hash1(float(i));\n        ao += clamp( map( pos + nor*0.05 + ap*0.2 )*100.0, 0.0, 1.0 );\n    }\n\tao \/= 32.0;\n\t\n    return clamp( ao, 0.0, 1.0 );\n}\n\nvec4 texCube( sampler2D sam, in vec3 p, in vec3 n, in float k )\n{\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n    vec3 w = pow( abs(n), vec3(k) );\n\treturn (x*w.x + y*w.y + z*w.z) \/ (w.x+w.y+w.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t#define ZERO (min(iFrame,0))\n    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        \/\/ pixel coordinates\n        vec2 o = vec2(float(m),float(n)) \/ float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)\/iResolution.y;\n\t\tvec2 q = (fragCoord+o)\/iResolution.xy;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)\/iResolution.y;\n\t\tvec2 q = fragCoord\/iResolution.xy;\n#endif\n\n    \n        grow = smoothstep( 0.0, 1.0, (iTime-vec4(0.0,1.0,2.0,3.0))\/3.0 );\n\n\n        \/\/-----------------------------------------------------\n        \/\/ camera\n        \/\/-----------------------------------------------------\n\n        float an = 1.1 + 0.05*(iTime-10.0);\n\n        vec3 ro = vec3(4.5*sin(an),1.0,4.5*cos(an));\n        vec3 ta = vec3(0.0,0.2,0.0);\n        \/\/ camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n        \/\/ create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n\n        \/\/-----------------------------------------------------\n        \/\/ render\n        \/\/-----------------------------------------------------\n\n        vec3 col = vec3(0.07)*clamp(1.0-length(q-0.5),0.0,1.0);\n\n        \/\/ raymarch\n        float t = intersect(ro,rd);\n\n        if( t>0.0 )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            vec3 ref = reflect( rd, nor );\n            vec3 sor = nor;\n\n            vec3 q = mapP( pos );\n            float occ = calcAO( pos, nor, fragCoord ); occ = occ*occ;\n\n            \/\/ materials\n            col = vec3(0.04);\n            float ar = clamp(1.0-0.7*length(q-pos),0.0,1.0);\n            col = mix( col, vec3(2.1,2.0,1.2), ar);\n            col  *= 0.3;          \n            col *= mix(vec3(1.0,0.4,0.3), vec3(0.8,1.0,1.3), occ);\n            float occ2 = calcAO2( pos, nor, fragCoord );\n\n\n            col *= 1.0*mix( vec3(2.0,0.4,0.2), vec3(1.0), occ2*occ2*occ2 );\n            float ks = texCube( iChannel0, pos*1.5, nor, 4.0 ).x;\n            ks = 0.5 + 1.0*ks;\n            ks *= (1.0-ar);\n\n            \/\/ lighting\n            float sky = 0.5 + 0.5*nor.y;\n            float fre = clamp( 1.0 + dot(nor,rd), 0.0, 1.0 );\n            float spe = pow(max( dot(-rd,nor),0.0),8.0);\n            \/\/ lights\n            vec3 lin  = vec3(0.0);\n                 lin += 3.0*vec3(0.7,0.80,1.00)*sky*occ;\n                 lin += 1.0*fre*vec3(1.2,0.70,0.60)*(0.1+0.9*occ);\n            col += 0.3*ks*4.0*vec3(0.7,0.8,1.00)*smoothstep(0.0,0.2,ref.y)*(0.05+0.95*pow(fre,5.0))*(0.5+0.5*nor.y)*occ;\n            col += 4.0*ks*1.5*spe*occ*col.x;\n            col += 2.0*ks*1.0*pow(spe,8.0)*occ*col.x;\n            col = col * lin;\n\n            \/\/ dust\n            col = mix( col, 0.2*fre*fre*fre+0.6*vec3(0.6,0.55,0.5)*sky*(0.8+0.4*texCube( iChannel0, pos*8.0, nor, 4.0 ).xyz), 0.6*smoothstep(0.3,0.7,nor.y)*sqrt(occ) );\n\n            col *= 2.6*exp(-0.2*t);\n        }\n\n        col = pow(col,vec3(0.4545));\n        \n        tot += col;\n#if AA>1\n    }\n    tot \/= float(AA*AA);\n#endif\n\n    tot = pow( tot, vec3(1.0,1.0,1.4) ) + vec3(0.0,0.02,0.14);\n    \n    tot += (1.0\/255.0)*hash1( fragCoord );\n    \n    fragColor = vec4( tot, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"Xs33Df","date":"1452775785","viewed":13095,"name":"Desert Canyon","username":"Shane","description":"Traversing a desert canyon.","likes":290,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"\/media\/a\/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"\/media\/ap\/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"\/media\/a\/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"\/media\/ap\/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/*\n\tDesert Canyon\n\t-------------\n\n\tJust a simple canyon fly through. Since the laws of physics aren't adhered to (damn stray floating \n\trocks), you can safely assume the setting is a dry, rocky desert on a different planet... in an \n\talternate reality. :)\n\n\tI thought I'd do a daytime scene for a change. I like the way they look, but I find they require\n\tmore effort to light up correctly. In this particular example, I had to find the balance between\n\tindoor and outdoor lighting, but keep it simple enough to allow reasonable frame rates for swift \n\tcamera movement. For that reason, I was really thankful to have some of Dave Hoskins's and IQ's \n\texamples to refer to.\n\n\tThe inspiration for this particular scene came from Dr2's flyby examples. This is obviously less\n\tcomplicated, since his involve flybys with actual planes. Really cool, if you've never seen them.\n\n\tAnyway, I'll put up a more interesting one at a later date.\n\t\n\n\tOutdoor terrain shaders:\n\n\tElevated - iq\n\thttps:\/\/www.shadertoy.com\/view\/MdX3Rr\n\tBased on his (RGBA's) famous demo, Elevated.\n\thttp:\/\/www.pouet.net\/prod.php?which=52938\n\n\t\/\/ How a canyon's really done. :)\n\tCanyon - iq\n\thttps:\/\/www.shadertoy.com\/view\/MdBGzG\n\n\t\/\/ Too many good ones to choose from, but here's one.\n\t\/\/ Mountains - Dave_Hoskins\n\thttps:\/\/www.shadertoy.com\/view\/4slGD4\n\n\t\/\/ Awesome.\n    River Flight - Dr2\n    https:\/\/www.shadertoy.com\/view\/4sSXDG\n\n*\/\n\n\/\/ The far plane. I'd like this to be larger, but the extra iterations required to render the \n\/\/ additional scenery starts to slow things down on my slower machine.\n#define FAR 65.\n\n\/\/ Frequencies and amplitudes of the \"path\" function, used to shape the tunnel and guide the camera.\nconst float freqA = .15\/3.75;\nconst float freqB = .25\/2.75;\nconst float ampA = 20.;\nconst float ampB = 4.;\n\n\/\/ 2x2 matrix rotation. Angle vector, courtesy of Fabrice.\nmat2 rot2( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n\/\/ 1x1 and 3x1 hash functions.\nfloat hash(float n){ return fract(cos(n)*45758.5453); }\nfloat hash(vec3 p){ return fract(sin(dot(p, vec3(7, 157, 113)))*45758.5453); }\n\n\/\/ Grey scale.\nfloat getGrey(vec3 p){ return dot(p, vec3(0.299, 0.587, 0.114)); }\n\n\/*\n\/\/ IQ's smooth minium function. \nfloat sminP(float a, float b , float s){\n    \n    float h = clamp(.5 + .5*(b - a)\/s, 0., 1.);\n    return mix(b, a, h) - h*(1.0-h)*s;\n}\n*\/\n\n\/\/ Smooth maximum, based on the function above.\nfloat smaxP(float a, float b, float s){\n    \n    float h = clamp(.5 + .5*(a - b)\/s, 0., 1.);\n    return mix(b, a, h) + h*(1. - h)*s;\n}\n\n\/\/ The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ return vec2(ampA*sin(z * freqA), ampB*cos(z * freqB) + 3.*(sin(z*0.025)  - 1.)); }\n\n\/\/ The canyon, complete with hills, gorges and tunnels. I would have liked to provide a far\n\/\/ more interesting scene, but had to keep things simple in order to accommodate slower machines.\nfloat map(in vec3 p){\n    \n    \/\/ Indexing into the pebbled texture to provide some rocky surface detatiling. I like this\n    \/\/ texture but I'd much rather produce my own. From what I hear, Shadertoy will be providing\n    \/\/ fixed offscreen buffer sizes (like 512 by 512, for instance) at a later date. When that\n    \/\/ happens, I'll really be able to do some damage. :)\n    float tx = textureLod(iChannel0, p.xz\/16. + p.xy\/80., 0.).x;\n  \n    \/\/ A couple of sinusoidal layers to produce the rocky hills.\n    vec3 q = p*.25;\n    float h = dot(sin(q)*cos(q.yzx), vec3(.222)) + dot(sin(q*1.5)*cos(q.yzx*1.5), vec3(.111));\n    \n    \n    \/\/ The terrain, so to speak. Just a flat XZ plane, at zero height, with some hills added.\n    float d = p.y + h*6.;\n  \n    \/\/ Reusing \"h\" to provide an undulating base layer on the tunnel walls.\n    q = sin(p*.5 + h);\n    h = q.x*q.y*q.z;\n  \n\t\/\/ Producing a single winding tunnel. If you're not familiar with the process, this is it.\n    \/\/ We're also adding some detailing to the walls via \"h\" and the rocky \"tx\" value.\n    p.xy -= path(p.z);\n    float tnl = 1.5 - length(p.xy*vec2(.33, .66)) + h + (1. - tx)*.25;\n\n\t\/\/ Smoothly combine the terrain with the tunnel - using a smooth maximum - then add some\n    \/\/ detailing. I've also added a portion of the tunnel term onto the end, just because\n    \/\/ I liked the way it looked more. \n    return smaxP(d, tnl, 2.) - tx*.5 + tnl*.8; \n\n}\n\n\n\/\/ Log-Bisection Tracing\n\/\/ https:\/\/www.shadertoy.com\/view\/4sSXzD\n\/\/\n\/\/ Log-Bisection Tracing by nimitz (twitter: @stormoid)\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/ Contact: nmz@Stormoid.com\n\/\/\n\/\/ Notes: This is a trimmed down version of Nitmitz's original. If you're interested in the function \n\/\/ itself, refer to the original function in the link above. There, you'll find a good explanation as to \n\/\/ how it works too.\n\/\/\n\/\/ For what it's worth, I've tried most of the standard raymarching methods around, and for difficult \n\/\/ surfaces to hone in on, like the one in this particular example, \"Log Bisection\" is my favorite.\n\nfloat logBisectTrace(in vec3 ro, in vec3 rd){\n\n\n    float t = 0., told = 0., mid, dn;\n    float d = map(rd*t + ro);\n    float sgn = sign(d);\n\n    for (int i=0; i<96; i++){\n\n        \/\/ If the threshold is crossed with no detection, use the bisection method.\n        \/\/ Also, break for the usual reasons. Note that there's only one \"break\"\n        \/\/ statement in the loop. I heard GPUs like that... but who knows?\n        if (sign(d) != sgn || d < 0.001 || t > FAR) break;\n \n        told = t;\n        \n        \/\/ Branchless version of the following:   \n        \/\/ if(d>1.) t += d; else t += log(abs(d) + 1.1);     \n        t += step(d, 1.)*(log(abs(d) + 1.1) - d) + d;\n        \/\/t += log(abs(d) + 1.1);\n        \/\/t += d;\/\/step(-1., -d)*(d - d*.5) + d*.5;\n        \n        d = map(rd*t + ro);\n    }\n    \n    \/\/ If a threshold was crossed without a solution, use the bisection method.\n    if (sign(d) != sgn){\n    \n        \/\/ Based on suggestions from CeeJayDK, with some minor changes.\n\n        dn = sign(map(rd*told + ro));\n        \n        vec2 iv = vec2(told, t); \/\/ Near, Far\n\n        \/\/ 6 iterations seems to be more than enough, for most cases...\n        \/\/ but there's an early exit, so I've added a couple more.\n        for (int ii=0; ii<8; ii++){ \n            \/\/Evaluate midpoint\n            mid = dot(iv, vec2(.5));\n            float d = map(rd*mid + ro);\n            if (abs(d) < 0.001)break;\n            \/\/ Suggestion from movAX13h - Shadertoy is one of those rare\n            \/\/ sites with helpful commenters. :)\n            \/\/ Set mid to near or far, depending on which side we're on.\n            iv = mix(vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn));\n        }\n\n        t = mid; \n        \n    }\n    \n\n    return min(t, FAR);\n}\n\n\n\/\/ Tetrahedral normal, courtesy of IQ.\nvec3 normal(in vec3 p)\n{  \n    vec2 e = vec2(-1, 1)*.001;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\n\n\/\/ Tri-Planar blending function. Based on an old Nvidia writeup:\n\/\/ GPU Gems 3 - Ryan Geiss: http:\/\/http.developer.nvidia.com\/GPUGems3\/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n   \n    n = max(n*n, .001);\n    n \/= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n\n\/\/ Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor){\n   \n    const float eps = .001;\n    vec3 grad = vec3( getGrey(tex3D(tex, vec3(p.x - eps, p.y, p.z), nor)),\n                      getGrey(tex3D(tex, vec3(p.x, p.y - eps, p.z), nor)),\n                      getGrey(tex3D(tex, vec3(p.x, p.y, p.z - eps), nor)));\n    \n    grad = (grad - getGrey(tex3D(tex, p, nor)))\/eps; \n            \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize(nor + grad*bumpfactor);\n\t\n}\n\n\/\/ The iterations should be higher for proper accuracy, but in this case, I wanted less accuracy, just to leave\n\/\/ behind some subtle trails of light in the caves. They're fake, but they look a little like light streaming \n\/\/ through some cracks... kind of.\nfloat softShadow(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\n\n    float shade = 1.;\n    \/\/ Increase this and the shadows will be more accurate, but the wispy light trails in the caves will disappear.\n    \/\/ Plus more iterations slow things down, so it works out, in this case.\n    const int maxIterationsShad = 10; \n\n    \/\/ The \"start\" value, or minimum, should be set to something more than the stop-threshold, so as to avoid a collision with \n    \/\/ the surface the ray is setting out from. It doesn't matter how many times I write shadow code, I always seem to forget this.\n    \/\/ If adding shadows seems to make everything look dark, that tends to be the problem.\n    float dist = start;\n    float stepDist = end\/float(maxIterationsShad);\n\n    \/\/ Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    \/\/ number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n        \/\/ End, or maximum, should be set to the distance from the light to surface point. If you go beyond that\n        \/\/ you may hit a surface not between the surface and the light.\n        float h = map(ro + rd*dist);\n        \/\/shade = min(shade, k*h\/dist);\n        shade = min(shade, smoothstep(0., 1., k*h\/dist));\n        \n        \/\/ What h combination you add to the distance depends on speed, accuracy, etc. To be honest, I find it impossible to find \n        \/\/ the perfect balance. Faster GPUs give you more options, because more shadow iterations always produce better results.\n        \/\/ Anyway, here's some posibilities. Which one you use, depends on the situation:\n        \/\/ +=max(h, 0.001), +=clamp( h, 0.01, 0.25 ), +=min( h, 0.1 ), +=stepDist, +=min(h, stepDist*2.), etc.\n        \n        \/\/ In this particular instance the light source is a long way away. However, we're only taking a few small steps\n        \/\/ toward the light and checking whether anything \"locally\" gets in the way. If a part of the scene a long distance away\n        \/\/ is between our hit point and the light source, it won't be accounted for. Technically that's not correct, but the local\n        \/\/ shadows give that illusion... kind of.\n        dist += clamp(h, .2, stepDist*2.);\n        \n        \/\/ There's some accuracy loss involved, but early exits from accumulative distance function can help.\n        if (abs(h)<.001 || dist > end) break; \n    }\n\n    \/\/ I usually add a bit to the final shade value, which lightens the shadow a bit. It's a preference thing. Really dark shadows \n    \/\/ look too brutal to me.\n    return min(max(shade, 0.) + .1, 1.); \n}\n\n\n\n\n\n\/\/ Ambient occlusion, for that self shadowed look. Based on the original by XT95. I love this \n\/\/ function and have been looking for an excuse to use it. For a better version, and usage, \n\/\/ refer to XT95's examples below:\n\/\/\n\/\/ Hemispherical SDF AO - https:\/\/www.shadertoy.com\/view\/4sdGWN\n\/\/ Alien Cocoons - https:\/\/www.shadertoy.com\/view\/MsdGz2\nfloat calculateAO( in vec3 p, in vec3 n, float maxDist )\n{\n\tfloat ao = 0., l;\n\tconst float nbIte = 6.;\n\t\/\/const float falloff = .9;\n    for(float i=1.; i< nbIte+.5; i++){\n    \n        l = (i + hash(i))*.5\/nbIte*maxDist;\n        \n        ao += (l - map( p + n*l))\/(1. + l);\/\/ \/ pow(1.+l, falloff);\n    }\n\t\n    return clamp(1. - ao\/nbIte, 0., 1.);\n}\n\n\/\/ More concise, self contained version of IQ's original 3D noise function.\nfloat noise3D(in vec3 p){\n    \n    \/\/ Just some random figures, analogous to stride. You can change this, if you want.\n\tconst vec3 s = vec3(7, 157, 113);\n\t\n\tvec3 ip = floor(p); \/\/ Unique unit cell ID.\n    \n    \/\/ Setting up the stride vector for randomization and interpolation, kind of. \n    \/\/ All kinds of shortcuts are taken here. Refer to IQ's original formula.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tp -= ip; \/\/ Cell's fractional component.\n\t\n    \/\/ A bit of cubic smoothing, to give the noise that rounded look.\n    p = p*p*(3. - 2.*p);\n    \n    \/\/ Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\n    \/\/ then interpolating along X. There are countless ways to randomize, but this is\n    \/\/ the way most are familar with: fract(sin(x)*largeNumber).\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\t\n    \/\/ Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    \/\/ Interpolating along Z, and returning the 3D noise value.\n    return mix(h.x, h.y, p.z); \/\/ Range: [0, 1].\n\t\n}\n\n\/\/ Simple fBm to produce some clouds.\nfloat fbm(in vec3 p){\n    \n    \/\/ Four layers of 3D noise.\n    return .5333*noise3D(p) + .2667*noise3D(p*2.02) + .1333*noise3D(p*4.03) + .0667*noise3D(p*8.03);\n\n}\n\n\n\/\/ Pretty standard way to make a sky. \nvec3 getSky(in vec3 ro, in vec3 rd, vec3 sunDir){\n\n\t\n\tfloat sun = max(dot(rd, sunDir), 0.); \/\/ Sun strength.\n\tfloat horiz = pow(1.0-max(rd.y, 0.), 3.)*.35; \/\/ Horizon strength.\n\t\n\t\/\/ The blueish sky color. Tinging the sky redish around the sun. \t\t\n\tvec3 col = mix(vec3(.25, .35, .5), vec3(.4, .375, .35), sun*.75);\/\/.zyx;\n    \/\/ Mixing in the sun color near the horizon.\n\tcol = mix(col, vec3(1, .9, .7), horiz);\n    \n    \/\/ Sun. I can thank IQ for this tidbit. Producing the sun with three\n    \/\/ layers, rather than just the one. Much better.\n\tcol += .25*vec3(1, .7, .4)*pow(sun, 5.);\n\tcol += .25*vec3(1, .8, .6)*pow(sun, 64.);\n\tcol += .2*vec3(1, .9, .7)*max(pow(sun, 512.), .3);\n    \n    \/\/ Add a touch of speckle, to match up with the slightly speckly ground.\n    col = clamp(col + hash(rd)*.05 - .025, 0., 1.);\n\t\n\t\/\/ Clouds. Render some 3D clouds far off in the distance. I've made them sparse and wispy,\n    \/\/ since we're in the desert, and all that.\n\tvec3 sc = ro + rd*FAR*100.; sc.y *= 3.;\n    \n    \/\/ Mix the sky with the clouds, whilst fading out a little toward the horizon (The rd.y bit).\n\treturn mix( col, vec3(1, .95, 1), .5*smoothstep(.5, 1., fbm(.001*sc)) * clamp(rd.y*4., 0., 1.) );\n\t\n\n}\n\n\/\/ Cool curve function, by Shadertoy user, Nimitz.\n\/\/\n\/\/ It gives you a scalar curvature value for an object's signed distance function, which \n\/\/ is pretty handy for all kinds of things. Here's it's used to darken the crevices.\n\/\/\n\/\/ From an intuitive sense, the function returns a weighted difference between a surface \n\/\/ value and some surrounding values - arranged in a simplex tetrahedral fashion for minimal\n\/\/ calculations, I'm assuming. Almost common sense... almost. :)\n\/\/\n\/\/ Original usage (I think?) - Cheap curvature: https:\/\/www.shadertoy.com\/view\/Xts3WM\n\/\/ Other usage: Xyptonjtroz: https:\/\/www.shadertoy.com\/view\/4ts3z2\nfloat curve(in vec3 p){\n\n    const float eps = .05, amp = 4., ampInit = .5;\n\n    vec2 e = vec2(-1, 1)*eps; \/\/ 0.05->3.5 - 0.04->5.5 - 0.03->10.->0.1->1.\n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return clamp((t1 + t2 + t3 + t4 - 4.*map(p))*amp + ampInit, 0., 1.);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n\t\n\t\/\/ Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*.5)\/iResolution.y;\n\t\n\t\/\/ Camera Setup.\n\tvec3 lookAt = vec3(0, 0, iTime*8.);  \/\/ \"Look At\" position.\n\tvec3 ro = lookAt + vec3(0, 0, -.25); \/\/ Camera position, doubling as the ray origin.\n \n\t\/\/ Using the Z-value to perturb the XY-plane.\n\t\/\/ Sending the camera and \"look at\" vectors down the tunnel. The \"path\" function is \n\t\/\/ synchronized with the distance function.\n\tlookAt.xy += path(lookAt.z);\n\tro.xy += path(ro.z);\n\n    \/\/ Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159\/3.; \/\/ FOV - Field of view.\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(vec3(forward.z, 0, -forward.x )); \n    vec3 up = cross(forward, right);\n\n    \/\/ rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*u.x*right + FOV*u.y*up);\n    \n    \/\/ Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    \/\/ Naturally, it's synchronized with the path in some kind of way.\n\trd.xy = rot2( path(lookAt.z).x\/64. )*rd.xy;\n    \n    \n\t\n    \/\/ Usually, you'd just make this a unit directional light, and be done with it, but I\n    \/\/ like some of the angular subtleties of point lights, so this is a point light a\n    \/\/ long distance away. Fake, and probably not advisable, but no one will notice.\n    vec3 lp = vec3(FAR*.5, FAR, FAR) + vec3(0, 0, ro.z);\n \n\n\t\/\/ Raymarching, using Nimitz's \"Log Bisection\" method. Very handy on stubborn surfaces. :)\n\tfloat t = logBisectTrace(ro, rd);\n    \n    \/\/ Standard sky routine. Worth learning. For outdoor scenes, you render the sky, then the\n    \/\/ terrain, then mix together with a fog falloff. Pretty straight forward.\n    vec3 sky = getSky(ro, rd, normalize(lp - ro));\n    \n    \/\/ The terrain color. Can't remember why I set it to sky. I'm sure I had my reasons.\n    vec3 col = sky;\n    \n    \/\/ If we've hit the ground, color it up.\n    if (t < FAR){\n    \n        vec3 sp = ro+t*rd; \/\/ Surface point.\n        vec3 sn = normal(sp); \/\/ Surface normal.\n\n        \n        \/\/ Light direction vector. From the sun to the surface point. We're not performing\n        \/\/ light distance attenuation, since it'll probably have minimal effect.\n        vec3 ld = lp-sp;\n        ld \/= max(length(ld), 0.001); \/\/ Normalize the light direct vector.\n\n        \n        \/\/ Texture scale factor.        \n        const float tSize1 = 1.\/6.;\n        \n        \/\/ Bump mapping with the sandstone texture to provide a bit of gritty detailing.\n        \/\/ This might seem counter intuitive, but I've turned off mip mapping and set the\n        \/\/ texture to linear, in order to give some grainyness. I'm dividing the bump\n        \/\/ factor by the distance to smooth it out a little. Mip mapped textures without\n        \/\/ anisotropy look too smooth at certain viewing angles.\n        sn = doBumpMap(iChannel1, sp*tSize1, sn, .007\/(1. + t\/FAR));\/\/max(1.-length(fwidth(sn)), .001)*hash(sp)\/(1.+t\/FAR)\n        \n        float shd = softShadow(sp, ld, .05, FAR, 8.); \/\/ Shadows.\n        float curv = curve(sp)*.9 +.1; \/\/ Surface curvature.\n        float ao = calculateAO(sp, sn, 4.); \/\/ Ambient occlusion.\n        \n        float dif = max( dot( ld, sn ), 0.); \/\/ Diffuse term.\n        float spe = pow(max( dot( reflect(-ld, sn), -rd ), 0. ), 5.); \/\/ Specular term.\n        float fre = clamp(1.0 + dot(rd, sn), 0., 1.); \/\/ Fresnel reflection term.\n\n       \n\n        \/\/ Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        \/\/ so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        \/\/ used to give a hard clay consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat fre2 = mix(.2, 1., Schlick);  \/\/F0 = .2 - Hard clay... or close enough.\n       \n        \/\/ Overal global ambience. Without it, the cave sections would be pretty dark. It's made up,\n        \/\/ but I figured a little reflectance would be in amongst it... Sounds good, anyway. :)\n        float amb = fre*fre2 + .06*ao;\n        \n        \/\/ Coloring the soil - based on depth. Based on a line from Dave Hoskins's \"Skin Peeler.\"\n        col = clamp(mix(vec3(.8, .5, .3), vec3(.5, .25, .125),(sp.y+1.)*.15), vec3(.5, .25, .125), vec3(1));\n        \n        \/\/ Give the soil a bit of a sandstone texture. This line's made up.\n        col =  smoothstep(-.5, 1., tex3D(iChannel1, sp*tSize1, sn))*(col + .25);\n        \/\/ One thing I really miss when using Shadertoy is anisotropic filtering, which makes mapped \n        \/\/ textures appear far more crisp. It requires just a few lines in the backend code, and doesn't \n        \/\/ appear to effect frame rate, but I'm assuming the developers have their reasons. Anyway, this\n        \/\/ line attempts to put a little definition back in, but it's definitely not the same thing. :)     \n        col = clamp(col + noise3D(sp*48.)*.3 - .15, 0., 1.);\n        \n        \/\/ Edit: This shader needs gamma correction, so I've hacked this and a postprocessing line\n        \/\/ in to counter the dark shading... I'll do it properly later.\n        col = pow(col, vec3(1.5));\n        \n        \/\/ Tweaking the curvature value a bit, then using it to color in the crevices with a \n        \/\/ brownish color... in a lame attempt to make the surface look dirt-like.\n        curv = smoothstep(0., .7, curv);\n        col *= vec3(curv, curv*.95, curv*.85);\n \n        \n        \/\/ A bit of sky reflection. Not really accurate, but I've been using fake physics since the 90s. :)\n        col += getSky(sp, reflect(rd, sn), ld)*fre*fre2*.5;\n        \n        \n        \/\/ Combining all the terms from above. Some diffuse, some specular - both of which are\n        \/\/ shadowed and occluded - plus some global ambience. Not entirely correct, but it's\n        \/\/ good enough for the purposes of this demonstation.        \n        col = (col*(dif + .1) + fre2*spe)*shd*ao + amb*col;\n       \n        \n    }\n    \n    \n    \/\/ Combine the terrain with the sky using some distance fog. This one is designed to fade off very\n    \/\/ quickly a few units out from the horizon. Account for the clouds, change \"FAR - 15.\" to zero, and \n    \/\/ the fog will be way more prominent. You could also use \"1.\/(1 + t*scale),\" etc.\n    col = mix(col, sky, sqrt(smoothstep(FAR - 15., FAR, t)));\n    \n\n    \/\/ Edit: This shader needs gamma correction, so I've hacked this and a line above in\n    \/\/ to counter the dark shading... I'll do it properly later.\n    col = pow(max(col, 0.), vec3(.75));\n\n    \n    \/\/ Standard way to do a square vignette. Note that the maxium value value occurs at \"pow(0.5, 4.) = 1.\/16,\" \n    \/\/ so you multiply by 16 to give it a zero to one range. This one has been toned down with a power\n    \/\/ term to give it more subtlety.\n    u = fragCoord\/iResolution.xy;\n    col *= pow(16.*u.x*u.y*(1. - u.x)*(1. - u.y) , .0625);\n\n    \/\/ Done.\n\tfragColor = vec4(clamp(col, 0., 1.), 1);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"MdcXzn","date":"1457308311","viewed":13088,"name":"Geomechanical","username":"Bers","description":"Generative, smooth edged hexagonal prism primitive, shaded with arithmetic PBR Lights.","likes":204,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Author : Sebastien Berube\n\/\/ Created : March 2015\n\/\/ Modified : Jan 2016\n\/\/ \n\/\/ Composition made from a repeated hexagon prism pattern.\n\/\/ Hexagon prism distance function had to be modified to smooth out vertical edges.\n\/\/\n\/\/ Sources:\n\/\/ Inigo Quilez\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\n\/\/ https:\/\/iquilezles.org\/articles\/raymarchingdf\n\/\/ For those interested in the origin of sphere tracing:\n\/\/ Sphere Tracing: A Geometric Method for the Antialiased Ray Tracing of Implicit Surfaces (1994)\n\/\/ http:\/\/citeseer.ist.psu.edu\/viewdoc\/summary?doi=10.1.1.48.3825\n\/\/ Spline\n\/\/ http:\/\/www.lighthouse3d.com\/tutorials\/maths\/catmull-rom-spline\/\n\/\/\n\/\/ License : Creative Commons Non-commercial (NC) license\n\/\/\n\n\/\/----------------------\n\/\/ Constants\nconst float PI = 3.14159;\nconst float SCALE = 1.0;\nconst float MAX_DIST = 1000.0;\nconst float FLOOR_HEIGHT  = 0.0;\nconst float X_REPEAT_DIST = 0.90*SCALE;\nconst float Z_REPEAT_DIST = 1.05*SCALE;\nconst float PRIM_HEIGHT    = 1.0;\nconst float HEX_HALF_WIDTH = 0.26*SCALE;\nconst float GEOMETRY_DISPLACEMENT = 1.00;\nfloat g_time;\n\nstruct AnimationChannels\n{\n    float material_roughness;   \/\/[0-1 range]\n    float geometry_width;       \/\/[0-1 range]\n    float geometry_scale;       \/\/[0-1 range]\n    float geometry_displacement;\/\/[0-1 range]\n\tfloat geometry_smoothness;  \/\/[0-1 range]\n    vec3 camPos;                \/\/[IR range]\n    vec3 camLookAt;             \/\/[IR range]\n};\nAnimationChannels g_animationChannels;\n\n\/\/Material ID enum\nconst int MATERIALID_NONE      = 0;\nconst int MATERIALID_FLOOR     = 1;\nconst int MATERIALID_SKY       = 2;\nconst int MATERIALID_PLASTIC   = 3;\nconst int MATERIALID_METAL     = 4;\n\n\/\/Debug flag enum\nconst int DEBUG_RAYLEN  = 0;\nconst int DEBUG_GEODIST = 1;\nconst int DEBUG_NORMAL  = 2;\nconst int DEBUG_MATID   = 3;\n\nfloat fDEBUG = 0.1;\n\n\/\/Defines\n#define saturate(x) clamp(x,0.0,1.0)\n\/\/----------------------\n\/\/ Camera\nstruct Cam { vec3 R; vec3 U; vec3 D; vec3 o; float lens; float zoom; }; \/\/Right, Up, Direction, origin\nCam    CAM_lookAt(vec3 target, float pitchAngleRad, float dist, float theta);\nCam    CAM_mouseLookAt(vec3 at, float dst);\nCam    CAM_animate(vec2 uv, float fTime);\nvec3   CAM_getRay(Cam cam, vec2 uv);\n\n\/\/----------------------\n\/\/ Post Process\nvec3 POST_ProcessFX(vec3 c, vec2 uv);\n\n\/\/----------------------\n\/\/ Analytic Intersections\nfloat RAYINTERSEC_plane(vec3 o, vec3 d, vec3 po, vec3 pn)\n{\n    return dot(po-o,pn)\/dot(d,pn); \n}\n\nstruct repeatInfo\n{\n    vec3 smpl; \/\/object-space, cyclic\n    vec3 anchor; \/\/world space\n};\n    \n#define normalized_wave(a) (0.5*a+0.5)\nrepeatInfo DF_repeatHex(vec3 p)\n{\n    \/\/Repetition\n    float xRepeatDist = X_REPEAT_DIST;\n    float zRepeatDist = Z_REPEAT_DIST*0.5;\n    float latticeX = (fract(p.x\/xRepeatDist+0.5)-0.5)*xRepeatDist;\n    float latticeY = (fract(p.z\/zRepeatDist+0.5)-0.5)*zRepeatDist;\n    vec2 anchorPosXZ = p.xz-vec2(latticeX,latticeY);\n    p.x = latticeX; \/\/Cyclic coords.\n    p.z = latticeY;\n    \n    \/\/Variation\n    float period = fract(g_time\/30.)*3.0;\n    float theta = period*2.0*PI;\n    float overallAmplitude = normalized_wave(-cos(theta)); \/\/Overall amplitude modulation\n    float waveAmplitude = g_animationChannels.geometry_displacement\n                         *normalized_wave(sin(anchorPosXZ.x+anchorPosXZ.y+theta*4.0));\n    float primHeight = FLOOR_HEIGHT+overallAmplitude*waveAmplitude;\n     \n    repeatInfo outData;\n    outData.anchor = vec3(anchorPosXZ[0], primHeight, anchorPosXZ[1]);\n    outData.smpl = p;\n    \n    return outData;\n}\n\n#define zclamp(a) max(a,0.0) \/\/Clamp negative values at zero\nfloat DF_RoundedHex( vec3 p, float width, float height)\n{\n    \/\/Modified version (smooth edges) of the exagon prism found here:\n    \/\/https:\/\/iquilezles.org\/articles\/distfunctions\n    float smoothRadius = g_animationChannels.geometry_smoothness*0.2;\n    width -= smoothRadius*2.0;\n    \n    \/\/Hexagon prism constructed using X,Y,Z symmetry.\n    \/\/Only quadrant 1 needs to be solved, but the joining diagonal to quadrant IV is also\n    \/\/required for distance blending (see db).\n    p = abs(p);\n    \n    \/\/Hexagonal edge distances :\n    \/\/Note : [.8666,0.5] = [sin(PI\/3,cos(PI\/3)] -> Hexagon edges rotation coeff (60 degrees).\n    float da = (p.x*0.866025+p.z*0.5)-width; \/\/quadrant I diagonal edge distance\n    float db = (p.x*0.866025-p.z*0.5)-width; \/\/quadrant IV diagonal edge distance (needed for blending)\n    float dc = p.z-width; \/\/upper distance\n    \n    vec3 d = zclamp(vec3(da,db,dc));\n    \/\/Note: this is not an euclidian length, therefore this operation slightly distorts our distance field.\n    \/\/Yet, it is harmless to convergence, and does the smoothing job quite well.\n    float dw = length(d)-smoothRadius; \/\/hexagonal part smoothness (blending at 60 deg)\n    float dh = p.y-height;\n    \n    \/\/Now that we have xz distance(dw) and y distance (dh), we can compute the distance \n    \/\/for the given isovalue (the smoothing radius).\n    \/\/Note : internal distance (maxX,maxY,maxZ) is also used to genereate internal signed dist,\n    \/\/       helping convergence when overstepping (very frequent with domain repetition).\n    float externalDistance = length(zclamp(vec2(dh,dw)))-smoothRadius; \/\/Smoothed, unsigned\n\tfloat internalDistance = max(max(da,dc),dh); \/\/Sharp, signed.\n    return min(externalDistance,internalDistance);\n}\n\nstruct DF_out\n{\n    float d;\n    int matID;\n    vec3 objectPos;\n};\n    \n\/\/The distance field composition.\n\/\/::DF_composition\nDF_out DF_composition( in vec3 pos )\n{\n    \/\/Explanation:\n    \/\/https:\/\/iquilezles.org\/articles\/distfunctions\n    DF_out oFloor;\n    DF_out oHexA;\n    DF_out oHexB;\n    \n    oHexA.matID = MATERIALID_PLASTIC;\n    repeatInfo infoA = DF_repeatHex(pos-vec3(0));\n\toHexA.objectPos = infoA.anchor;\n    oHexA.d = DF_RoundedHex( infoA.smpl-vec3(0,infoA.anchor.y,0),\n\t                         g_animationChannels.geometry_width*HEX_HALF_WIDTH, PRIM_HEIGHT );\n    \n    oHexB.matID = MATERIALID_PLASTIC;\n    repeatInfo infoB = DF_repeatHex(pos-vec3(X_REPEAT_DIST*0.5,0, Z_REPEAT_DIST*0.25));\n\toHexB.objectPos = infoB.anchor;\n    oHexB.d = DF_RoundedHex( infoB.smpl-vec3(0,infoB.anchor.y,0),\n\t                         g_animationChannels.geometry_width*HEX_HALF_WIDTH, PRIM_HEIGHT );\n    \n    if(oHexA.d<oHexB.d)\n        return oHexA;\n    else\n        return oHexB;\n}\n\n\/\/The distance field gradient\nvec3 DF_gradient( in vec3 p )\n{\n    \/\/The field gradient is the distance derivative along each axis.\n    \/\/The surface normal follows the direction where this variation is strongest.\n\tconst float d = 0.001;\n\tvec3 grad = vec3(DF_composition(p+vec3(d,0,0)).d-DF_composition(p-vec3(d,0,0)).d,\n                     DF_composition(p+vec3(0,d,0)).d-DF_composition(p-vec3(0,d,0)).d,\n                     DF_composition(p+vec3(0,0,d)).d-DF_composition(p-vec3(0,0,d)).d);\n\treturn grad\/(2.0*d);\n}\n\n#define OVERSTEP_COMPENSATION 1\n\n\/\/o = ray origin, d = direction, t = distance travelled along ray, starting from origin\nfloat RAYMARCH_isosurface( vec3 o, vec3 d, float isoSurfaceValue)\n{\n    \/\/Learned from Inigo Quilez DF ray marching :\n    \/\/https:\/\/iquilezles.org\/articles\/raymarchingdf\n    \/\/Original articles (interesting read) :\n    \/\/Sphere Tracing: A Geometric Method for the Antialiased Ray Tracing of Implicit Surfaces (1989)\n    \/\/http:\/\/mathinfo.univ-reims.fr\/IMG\/pdf\/hart94sphere.pdf\n    \/\/John C. Hart Sphere Tracing: A Geometric Method for the Antialiased Ray Tracing of Implicit Surfaces (1994)\n    \/\/http:\/\/citeseer.ist.psu.edu\/viewdoc\/summary?doi=10.1.1.48.3825 p. 5.75-5.85\n    \n    const float tolerance = 0.0001;\n    float t = 0.0;\n    float dist = MAX_DIST;\n    #if OVERSTEP_COMPENSATION\n    for( int i=0; i<30; i++ )\n    {\n        dist = DF_composition( o+d*t ).d;\n        dist -= isoSurfaceValue;\n        \n        if( abs(dist)<tolerance*100.0 ) break;\n        t += dist;\n    }\n    \n    t -= Z_REPEAT_DIST\/2.0;\n    \n    for( int i=0; i<30; i++ )\n    {\n        dist = DF_composition( o+d*t ).d;\n        dist -= isoSurfaceValue;\n        \n        if( abs(dist)<tolerance ) break;\n        \n        t += min(dist,Z_REPEAT_DIST\/5.0);\n    }\n    #else\n    for( int i=0; i<70; i++ )\n    {\n        dist = DF_composition( o+d*t ).d;\n        dist -= isoSurfaceValue;\n        \n        if( abs(dist)<tolerance ) break;\n        t += dist;\n    }\n    #endif\n    \n    return t;\n}\n\n#define saturate(x) clamp(x,0.0,1.0)\nfloat RAYMARCH_DFSS( vec3 o, vec3 L, float coneWidth )\n{\n    \/\/Variation of the Distance Field Soft Shadow from : https:\/\/www.shadertoy.com\/view\/Xds3zN\n    \/\/Initialize the minimum aperture (angle tan) allowable with this distance-field technique\n    \/\/(45deg: sin\/cos = 1:1)\n    float minAperture = 1.0; \n    float t = 0.0; \/\/initial travel distance, from geometry surface (usually, pretty close)\n    float dist = 10.0;\n    for( int i=0; i<7; i++ )\n    {\n        vec3 p = o+L*t; \/\/Sample position = ray origin + ray direction * travel distance\n        float dist = DF_composition( p ).d;\n        dist = min(dist,t);\n        float curAperture = dist\/t; \/\/Aperture ~= cone angle tangent (sin=dist\/cos=travelDist)\n        minAperture = min(minAperture,curAperture);\n        \/\/Step size : limit range (0.02-0.42)\n        t += 0.02+min(dist,0.4);\n    }\n    \n    \/\/The cone width controls shadow transition. The narrower, the sharper the shadow.\n    return saturate(minAperture\/coneWidth); \/\/Should never exceed [0-1]. 0 = shadow, 1 = fully lit.\n}\n\nfloat RAYMARCH_DFAO( vec3 o, vec3 N, float isoSurfaceValue)\n{\n    \/\/Variation of DFAO from : https:\/\/www.shadertoy.com\/view\/Xds3zN\n    \/\/Interesting reads:\n    \/\/https:\/\/docs.unrealengine.com\/latest\/INT\/Engine\/Rendering\/LightingAndShadows\/DistanceFieldAmbientOcclusion\/index.html#howdoesitwork?\n    \/\/Implementation notes:\n    \/\/-Doubling step size at each iteration\n    \/\/-Allowing negative distance field values to contribute, making cracks much darker\n    \/\/-Not reducing effect with distance (specific to this application)\n    float MaxOcclusion = 0.0;\n    float TotalOcclusion = 0.0;\n    const int nSAMPLES = 4;\n    float stepSize = 0.11\/float(nSAMPLES);\n    for( int i=0; i<nSAMPLES; i++ )\n    {\n        float t = 0.01 + stepSize;\n        \/\/Double distance each iteration (only valid for small sample count, e.g. 4)\n        stepSize = stepSize*2.0;\n        float dist = DF_composition( o+N*t ).d-isoSurfaceValue;\n        \/\/Occlusion factor inferred from the difference between the \n        \/\/distance covered along the ray, and the distance from other surrounding geometry.\n        float occlusion = zclamp(t-dist);\n        TotalOcclusion += occlusion;\/\/Not reducing contribution on each iteration\n        MaxOcclusion += t;\n    }\n    \n    \/\/Here, TotalOcclusion can actually exceed MaxOcclusion, where the rays\n    \/\/get inside the shape and grab negative occlusion values. It does look good\n    \/\/that way IMHO (much darker in the cracks), therefore the maximum occlusion is bumped\n    \/\/25% to allow those cracks to get darker.\n    return saturate(1.0-TotalOcclusion\/(MaxOcclusion*1.25));\n}\n\nstruct TraceData\n{\n    float rayLen;  \/\/Ray travel distance\n    vec3  rayDir;  \/\/Ray direction\n    float geoDist; \/\/Distance to geometry (error on final position)\n    vec3  normal;  \/\/Geometry normal\n    vec3  objectPos; \/\/Object position (center)\n    int   matID;     \/\/Material ID\n};\n    \nTraceData new_TraceData()\n{\n    TraceData td;\n    td.rayLen = 0.;\n    td.rayDir = vec3(0);\n    td.geoDist = 0.;\n    td.normal = vec3(0);\n    td.objectPos = vec3(0);\n    td.matID = MATERIALID_NONE;\n    return td;\n}\n\nvec3 PBR_HDRremap(vec3 c)\n{\n    float fHDR = smoothstep(2.900,3.0,c.x+c.y+c.z);\n    return mix(c,1.3*vec3(4.5,3.5,3.0),fHDR);\n}\n\n\/\/http:\/\/refractiveindex.info\/?shelf=3d&book=liquids&page=water\nconst float F_DIELECTRIC_PLASTIC = 1.49; \/\/@550nm\nconst float F_DIELECTRIC_WATER   = 1.33; \/\/@550nm\nconst float F_DIELECTRIC_DIAMOND = 2.42; \/\/@550nm\n\n\/\/ior = index of refraction\n\/\/n = refraction index\nvec3 PBR_Fresnel_Schlick_Dielectric(vec3 n, float VdotH)\n{\n\t\/\/<Source : https:\/\/en.wikipedia.org\/wiki\/Schlick%27s_approximation>\n\tvec3 F0 = abs ((1.0 - n) \/ (1.0 + n));\n\treturn F0 + (1.-F0) * pow( 1. - VdotH, 5.);\n    \/\/<\/Source : https:\/\/en.wikipedia.org\/wiki\/Schlick%27s_approximation>\n}\n\nvec3 PBR_ABL_Equation(vec3 V, vec3 L, vec3 N, float roughness, float metallic, vec3 ior_n, vec3 ior_k)\n{\n    roughness = max(roughness,0.01);\n    \n\tvec3 H = normalize(L+V);\n\tfloat NdotH = dot(N,H);\/\/Nn.H;\n\tfloat NdotL = dot(N,L);\/\/Nn.Ln;\n\tfloat VdotH = dot(V,H);\/\/Vn.H;\n    float NdotV = dot(N,V);\/\/Nn.Vn;\n    \n    \/\/Distribution term\n    \/\/This D value is an approximation of the probability for a given light to bounce into the viewing vector direction.\n\t\/\/It is not necessarily 100% mathematically\/physically correct : this is still just a function which has a curve that decently\n    \/\/matches the physical distribution.\n    \/\/<Source: https:\/\/de45xmedrsdbp.cloudfront.net\/Resources\/files\/2013SiggraphPresentationsNotes-26915738.pdf p.3\/59>\n    float PI = 3.14159;\n    float alpha2 = roughness * roughness;\n    float NoH2 = NdotH * NdotH;\n    float den = NoH2*(alpha2-1.0)+1.0;\n    float D = (NdotH>0.)?alpha2\/(PI*den*den):0.0;\n\t\/\/<\/https:\/\/de45xmedrsdbp.cloudfront.net\/Resources\/files\/2013SiggraphPresentationsNotes-26915738.pdf p.3\/59>\n    \n    \/\/Fresnel term\n    vec3 F = PBR_Fresnel_Schlick_Dielectric(ior_n, VdotH);\n    \n    \/\/Geometric term\n    \/\/<Source: https:\/\/de45xmedrsdbp.cloudfront.net\/Resources\/files\/2013SiggraphPresentationsNotes-26915738.pdf p.3\/59>\n    float Gk = (roughness+1.)*(roughness+1.)\/8.; \/\/<-Disney's modification for ABL\n    float Gl = max(NdotL,0.)\/(NdotL*(1.0-Gk)+Gk);\n    float Gv = max(NdotV,0.)\/(NdotV*(1.0-Gk)+Gk);\n    float G = Gl*Gv;\n    \/\/<\/https:\/\/de45xmedrsdbp.cloudfront.net\/Resources\/files\/2013SiggraphPresentationsNotes-26915738.pdf p.3\/59>\n    \n    \/\/The PBR equation seen pretty much everywhere:\n    \/\/<Source : https:\/\/seblagarde.wordpress.com\/2015\/07\/14\/siggraph-2014-moving-frostbite-to-physically-based-rendering\/ p.14>\n    \/\/<Source : http:\/\/www.codinglabs.net\/article_physically_based_rendering_cook_torrance.aspx>\n    float softTr = 0.2; \/\/ Valid range : [0.001-0.25]. Will reduce reflexivity on edges if too high.\n    \/\/Personal addition : This parameter softens up the transition at grazing angles (otherwise too sharp IMHO).\n    vec3 Rs = D*F*G \/ (4.*NdotV*NdotL*(1.0-softTr)+softTr);\n    \/\/<Source : http:\/\/www.codinglabs.net\/article_physically_based_rendering_cook_torrance.aspx>\n    \n\treturn Rs;\n}\n\n#define saturate(x) clamp(x,0.0,1.0)\nvec3 MAT_Plastic(TraceData traceData, vec3 cDiff, vec3 N, vec3 V, vec3 L0, vec3 L1, float dfao, float dfss0, float dfss1)\n{\n    vec3 col = vec3(0);\n    \n    float fRoughness = g_animationChannels.material_roughness;\n    \n    \/\/Ambient directional contribution (3x):\n    \/\/           color*directionalContribution(<normal,ambientDir>)\n    \/\/This give a basic \"ambient\" shading, which varies with normal angle\n    vec3 cAmb  = vec3(0.26,0.24,0.23)*vec3(0.5+0.5*dot(traceData.normal,vec3(+0.08,1,+0.1)))\n               + vec3(0.25,0.25,0.30)*vec3(0.5+0.5*dot(traceData.normal,vec3(-0.28,1,-0.17)))\n               + vec3(0.19,0.25,0.30)*vec3(0.5+0.5*dot(traceData.normal,vec3(+0.28,1,-0.27)));\n    \/\/2 x PBR lights\n    vec3 CL0  = PBR_HDRremap(vec3(1))*PBR_ABL_Equation(V,L0,traceData.normal, fRoughness, 0., vec3(F_DIELECTRIC_PLASTIC), vec3(0));\n    vec3 CL1  = PBR_HDRremap(vec3(1))*PBR_ABL_Equation(V,L1,traceData.normal, fRoughness, 0., vec3(F_DIELECTRIC_PLASTIC), vec3(0));\n    \n    col = cAmb*dfao;\n    col *= saturate(0.30+fRoughness*0.5+0.2*(dfss0+dfss1));\n    col += (dfss0+fRoughness*0.25)*CL0;\n    col += (dfss1+fRoughness*0.25)*CL1;\n    \n    return col*0.75;\n}\n\nfloat SAMPLER_trilinear(vec3 p)\n{\n    \/\/Noise layering trick from Inigo Quilez.\n    \/\/See this for more explanation: https:\/\/www.shadertoy.com\/view\/Ms3SRr\n    const float TEXTURE_RES = 256.0; \/\/Noise texture resolution\n    p *= TEXTURE_RES;   \/\/Computation in pixel space (1 unit = 1 pixel)\n    vec3 pixCoord = floor(p);\/\/Pixel coord, integer [0,1,2,3...256...]\n    vec3 t = p-pixCoord;     \/\/Pixel interpolation position, linear range [0-1] (fractional part)\n    t = (3.0 - 2.0 * t) * t * t; \/\/interpolant easing function : linear->cubic\n    vec2 layer_translation = -pixCoord.y*vec2(37.0,17.0)\/TEXTURE_RES; \/\/noise volume stacking trick : g layer = r layer shifted by (37x17 pixels -> this is no keypad smashing, but the actual translation embedded in the noise texture).\n    vec2 layer1_layer2 = texture(iChannel0,layer_translation+(pixCoord.xz+t.xz+0.5)\/TEXTURE_RES,-100.0).xy; \/\/Note : +0.5 to fall right on pixel center\n    return mix( layer1_layer2.x, layer1_layer2.y, t.y ); \/\/Layer interpolation (trilinear\/volumetric)\n}\n\nfloat MAT_remap_angle_probability(float x_01)\n{\n    \/\/cos(jitter) is used to alter probabilty distribution : \n    \/\/it remaps an evenly distributed function into another \n    \/\/one where closer angles are more probable, and wider\n    \/\/angles are less probable.\n    return (1.0-cos(x_01*PI\/2.0));\n}\n\nvec3 MAT_addFog(float travelDist, in vec3 color, in vec3 p, in vec3 c_atmosphere)\n{\n    float a = 0.08;\n    float NORMALIZATION_TERM = log((1.+a)\/a);\n    float da = travelDist\/50.0;\n    da = log((da+a)\/a)\/NORMALIZATION_TERM;\n    vec3 FinalColor = mix(color,c_atmosphere,saturate(da));\n    return FinalColor;\n}\n\n\/\/::MAT_apply\nvec4 MAT_apply(vec3 pos, TraceData traceData)\n{\n    vec3 c_atmosphere = mix(vec3(0.87,0.94,1.0),vec3(0.6,0.80,1.0),clamp(3.0*pos.y\/length(pos.xz),0.,1.));\n    \n    if(traceData.matID==MATERIALID_SKY)\n    {\n        return vec4(c_atmosphere,1.0);\n    }\n    \n    vec4 col = vec4(0);\n    vec3 N = traceData.normal;\n    vec3 V = normalize(-traceData.rayDir);\n    vec3 L0 = normalize(vec3(0.5,1.2,0.3));\n    vec3 L1 = normalize(vec3(-L0.x,L0.y,-L0.z+0.5));\n    \n    \/\/<Jittered AO Samples around Y axis, to reduce artifacts associated with closely repeated geometry>\n    float fNoiseAmplitude = 0.4;\n    float jitter_01 = SAMPLER_trilinear(pos*10.0+g_time*50.0);\n    float t = MAT_remap_angle_probability(jitter_01)*fNoiseAmplitude;\n    vec3 Na = vec3(N.xz*mat2(cos(t),sin(t),-sin(t),cos(t)),N.y).xzy; \/\/Rotate(t)\n    jitter_01 = SAMPLER_trilinear(5.0+pos*9.11);\n    t = MAT_remap_angle_probability(jitter_01)*fNoiseAmplitude;\n    vec3 Nb = vec3(N.xz*mat2(cos(t),-sin(t),sin(t),cos(t)),N.y).xzy; \/\/Rotate(-t)\n    float dfaoA = RAYMARCH_DFAO( pos, Na, 0.02);\n    float dfaoB = RAYMARCH_DFAO( pos, Nb, 0.02);\n    float dfaoAveraged = 0.5*(dfaoA+dfaoB);\n    \/\/<\/Jittered AO Samples>\n    \n    float dfss0 = RAYMARCH_DFSS( pos+L0*0.01, L0, 0.2);\n    float dfss1 = RAYMARCH_DFSS( pos+L1*0.01, L1, 0.2);\n    \n    if(traceData.matID==MATERIALID_PLASTIC)\n    {\n        col.rgb = MAT_Plastic(traceData, vec3(1), N, V, L0, L1, dfaoAveraged, dfss0, dfss1);\n    }\n    \n    col.rgb = MAT_addFog(traceData.rayLen*0.3, col.rgb, pos, c_atmosphere);\n    \n    return col;\n}\n\nfloat TRACE_zprime(vec3 o, vec3 d)\n{\n    float geometryCeiling = FLOOR_HEIGHT+PRIM_HEIGHT\n\t                       +g_animationChannels.geometry_displacement*GEOMETRY_DISPLACEMENT;\n    float t = RAYINTERSEC_plane(o, d, vec3(0,geometryCeiling,0), vec3(0,1,0));\n    return (t<0.0)?MAX_DIST:t;\n    return t;\n}\n\n\/\/o=ray origin, d=ray direction\n\/\/::TRACE_geometry\nTraceData TRACE_geometry(vec3 o, vec3 d)\n{\n    \/\/Raymarching (the expensive function)\n    TraceData dfTrace;\n    float rayLen = RAYMARCH_isosurface(o,d,0.0);\n    vec3 dfHitPosition = o+rayLen*d;\n    \n    \/\/Additional sample, to gather material ID and other info\n    \/\/(we want that stuff coompiled out of the raymarching loop, it clutters the code and might slow things down)\n    DF_out compInfo = DF_composition( dfHitPosition );\n    rayLen += compInfo.d;\n    dfHitPosition = o+rayLen*d;\n        \n    dfTrace.rayLen     = rayLen;\n    dfTrace.matID      = compInfo.matID;\n    dfTrace.objectPos  = compInfo.objectPos;\n    dfTrace.geoDist    = compInfo.d;\n    dfTrace.rayDir     = d;\n    dfTrace.normal     = normalize(DF_gradient(dfHitPosition));\n    \n    return dfTrace;\n}\n\nvec3 TRACE_debug(TraceData traceData, int elemID)\n{\n    if(elemID==DEBUG_RAYLEN)  return vec3(log(traceData.rayLen)*0.2);\n    if(elemID==DEBUG_GEODIST) return vec3(traceData.geoDist);\n    if(elemID==DEBUG_NORMAL)  return traceData.normal;\n    if(elemID==DEBUG_MATID)   return traceData.matID==MATERIALID_PLASTIC?vec3(1):\n                                     vec3(traceData.matID==MATERIALID_FLOOR?1:0,\n                                          traceData.matID==MATERIALID_METAL?1:0,\n                                          traceData.matID==MATERIALID_SKY?1:0);\n    return vec3(0);\n}\n\nconst int SPLINE_POINT_COUNT = 8;\nstruct SPLINE_CtrlPts\n{\n    vec4 p[SPLINE_POINT_COUNT];\n};\nvec4 SPLINE_PointArray(int i, SPLINE_CtrlPts ctrlPts)\n{\n    \/\/Just a way to get around the fact global arrays do not support random index access.\n    \/\/(only texture\/resources)\n    if(i==0 || i==SPLINE_POINT_COUNT  ) return ctrlPts.p[0];\n    if(i==1 || i==SPLINE_POINT_COUNT+1) return ctrlPts.p[1];\n    if(i==2 || i==SPLINE_POINT_COUNT+2) return ctrlPts.p[2];\n    if(i==3) return ctrlPts.p[3];\n    if(i==4) return ctrlPts.p[4];\n    if(i==5) return ctrlPts.p[5];\n    if(i==6) return ctrlPts.p[6];\n    if(i==7) return ctrlPts.p[7];\n    return vec4(0);\n}\n\nvec4 SPLINE_catmullRom(float fTime, SPLINE_CtrlPts ctrlPts)\n{\n    float t = fract(fTime);\n    const float n = float(SPLINE_POINT_COUNT);\n    \n    int idxOffset = int(t*n);\n    vec4 p1 = SPLINE_PointArray(idxOffset,ctrlPts);\n    vec4 p2 = SPLINE_PointArray(idxOffset+1,ctrlPts);\n    vec4 p3 = SPLINE_PointArray(idxOffset+2,ctrlPts);\n    vec4 p4 = SPLINE_PointArray(idxOffset+3,ctrlPts);\n    \n    \/\/For some reason, fract(t) returns garbage on my machine with small values of t.\n    \/\/return fract(n*t);\n    \/\/Using this below yields the same results, minus the glitches.\n    t *= n;\n    t = (t-float(int(t)));\n    \n    \/\/A classic catmull-rom\n    \/\/e.g.\n    \/\/http:\/\/steve.hollasch.net\/cgindex\/curves\/catmull-rom.html\n    \/\/http:\/\/www.lighthouse3d.com\/tutorials\/maths\/catmull-rom-spline\/\n    vec4 val = 0.5 * ((-p1 + 3.*p2 -3.*p3 + p4)*t*t*t\n               + (2.*p1 -5.*p2 + 4.*p3 - p4)*t*t\n               + (-p1+p3)*t\n               + 2.*p2);\n    return val;\n}\n\nvoid ANIM_main(float fTime)\n{\n    float t1 = 0.010*fTime;\n    float t2 = 0.010*fTime+0.03;\n    \n    SPLINE_CtrlPts cameraPosKeyFrames; \/\/100 sec cycle.\n    \/\/                    DATA: PosX,PosY,PosZ,Tilt\n    cameraPosKeyFrames.p[1] = vec4(10.0,2.70,05.0,1.90); \/\/t=00.0s\n    cameraPosKeyFrames.p[2] = vec4(16.0,3.30,08.5,1.00); \/\/t=12.5s\n    cameraPosKeyFrames.p[3] = vec4(20.0,6.80,05.0,2.97); \/\/t=25.0s\n    cameraPosKeyFrames.p[4] = vec4(40.0,3.40,17.5,0.82); \/\/t=37.5s\n    cameraPosKeyFrames.p[5] = vec4(30.0,3.10,27.5,1.97); \/\/t=50.0s\n    cameraPosKeyFrames.p[6] = vec4(25.0,3.20,22.5,1.93); \/\/t=62.5s\n    cameraPosKeyFrames.p[7] = vec4(15.0,3.00,24.5,1.95); \/\/t=75.0s\n    cameraPosKeyFrames.p[0] = vec4(05.0,2.80,12.5,1.20); \/\/t=87.5s\n    vec4 cameraPos = SPLINE_catmullRom(t1,cameraPosKeyFrames);\n    vec4 cameraDir = normalize(SPLINE_catmullRom(t2,cameraPosKeyFrames)-cameraPos);\n        \n    SPLINE_CtrlPts geometryKeyFrames; \/\/25 sec cycle.\n    \/\/                      DATA: round,width,roughness,displacement\n\tgeometryKeyFrames.p[1] = vec4(0.070,1.000,0.30,1.000); \/\/t=00.0s\n    geometryKeyFrames.p[2] = vec4(0.090,0.900,0.50,0.900); \/\/t=01.25s\n    geometryKeyFrames.p[3] = vec4(0.080,1.000,0.20,1.000); \/\/t=02.50s\n    geometryKeyFrames.p[4] = vec4(0.150,0.970,0.50,0.990); \/\/t=03.75s\n    geometryKeyFrames.p[5] = vec4(0.090,0.820,0.50,0.820); \/\/t=05.00s\n    geometryKeyFrames.p[6] = vec4(0.110,0.970,0.50,0.990); \/\/t=06.25s\n    geometryKeyFrames.p[7] = vec4(0.050,0.930,0.50,0.930); \/\/t=07.50s\n    geometryKeyFrames.p[0] = vec4(0.120,0.950,0.50,0.980); \/\/t=08.75s\n    vec4 geoPose = SPLINE_catmullRom(t1*25.0,geometryKeyFrames);\n    \n    g_animationChannels.camPos    = cameraPos.xyz;\n    g_animationChannels.camLookAt = cameraPos.xyz+cameraDir.xyz-vec3(0,cameraPos.w,0);\n    g_animationChannels.geometry_smoothness = geoPose[0];\n    g_animationChannels.material_roughness = 0.45;\n    g_animationChannels.geometry_width = geoPose[1];\n    g_animationChannels.geometry_displacement = GEOMETRY_DISPLACEMENT;\n}\n\nvec3 TRACE_main( vec3 o, vec3 dir, vec2 uv)\n{ \n    float fRemainingAlpha = 1.0;\n    float zStart = TRACE_zprime(o, dir);\n    vec3 pt = o+dir*zStart;\n    vec3 ptGeo = vec3(0);\n    \n    TraceData geometryTraceData;\n    if(zStart< MAX_DIST)\n    {\n        geometryTraceData = TRACE_geometry(pt, dir);\n        geometryTraceData.rayLen += zStart;\n        ptGeo = o+dir*geometryTraceData.rayLen;\n    }\n    else\n    {\n        geometryTraceData.rayLen     = MAX_DIST;\n    \tgeometryTraceData.matID      = MATERIALID_SKY;\n    \tgeometryTraceData.objectPos  = pt;\n    \tgeometryTraceData.geoDist    = 0.0;\n    \tgeometryTraceData.rayDir     = dir;\n        ptGeo = pt;\n    }\n    \n    \/\/return TRACE_debug(geometryTraceData, DEBUG_RAYLEN);  \/\/OK\n    \/\/return TRACE_debug(geometryTraceData, DEBUG_GEODIST); \/\/OK\n    \/\/return TRACE_debug(geometryTraceData, DEBUG_NORMAL);  \/\/OK\n    \/\/return TRACE_debug(geometryTraceData, DEBUG_MATID);   \/\/OK\n    \n    vec4 cFinal = MAT_apply(ptGeo,geometryTraceData);\n        \n    return cFinal.rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    g_time = iTime+2.6; \/\/Time offset for better preview\n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy) \/ iResolution.xx;\n    \n    float fTime = g_time+2.1;\n    ANIM_main(fTime);\n    \n    Cam cam = CAM_animate(uv,fTime);\n    vec3 d = CAM_getRay(cam,uv);\n    vec3 c = TRACE_main(cam.o, d, uv);\n    \n    \/\/No supersampling required for most PostProcessFX.\n    c = POST_ProcessFX(c,uv);\n    \n    fragColor = vec4(c,1.0);\n}\n\nvec3 POST_ProcessFX(vec3 c, vec2 uv)\n{\n    \/\/Vignetting\n    float lensRadius = 0.65;\n    uv \/= lensRadius;\n    float sin2 = uv.x*uv.x+uv.y*uv.y;\n    float cos2 = 1.0-min(sin2*sin2,1.0);\n    float cos4 = cos2*cos2;\n    c *= cos4;\n    \n    \/\/Gamma\n    c = pow(c,vec3(0.4545));\n    return c;\n}\n\n\/\/----------------------\n\/\/ Camera\n\/\/::CAM\nCam CAM_animate(vec2 uv, float fTime)\n{\n    Cam cam;\n    cam.o = g_animationChannels.camPos;\n    cam.D = normalize(g_animationChannels.camLookAt-cam.o);\n\tcam.R = normalize(cross(cam.D,vec3(0,1,0)));\n    cam.U = normalize(cross(cam.R,cam.D));\n    cam.lens = 1.2+0.3*sin(fTime*0.1);\n    cam.zoom = 3.0+sin(fTime*0.1)\/cam.lens;\n\treturn cam;\n}\n\nvec3 CAM_getRay(Cam cam,vec2 uv)\n{\n    uv = cam.lens*uv\/(cam.lens-length(uv)*length(uv));\n    uv *= cam.zoom;\n    return normalize(uv.x*cam.R+uv.y*cam.U+cam.D);\n}","name":"Image","description":"","type":"image"}]}];    var gUseScreenshots = piIsMobile();
    var gThemeName = "classic";



    </script>
</head>

<!-- <body onload="resultsInit(12,null,null)"> -->
<body onload="resultsInitStatic(12,null,null)">

<!-- header =================================================================================== -->


<div id="header">

    <div id="headerBlock1">
        <a href="/" id="headerTitle">Shadertoy</a>
        <form name="formSearch" action="/results" method="get" style="display:inline-block;">
        <div  id="headerSearch">
            <input type="search" id="mySearch" name="query" placeholder="Search..." value=""/>
        </div>
        </form>
    </div>

    <div id="headerBlock2">
            <a class="headerLinks" href="/browse">Browse</a>
        <a class="headerLinks" href="/new">New</a>
        <a class="headerLinks" href="/signin">Sign In</a>
        </div>
</div>
<!-- content ================================================================================== -->

<div id="content">

  <div id="controls">
    <div>
      <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
      Sort:      </div>
      <div class="controlOptions"><div class="pageButtonsCurrent" href="/results?query=&sort=popular&filter=">Popular</div><a class="pageButtons" href="/results?query=&sort=newest&filter=">Newest</a><a class="pageButtons" href="/results?query=&sort=love&filter=">Love</a><a class="pageButtons" href="/results?query=&sort=hot&filter=">Hot</a></div>
    </div>

    <div id="controlFilter">
      <div style="display:flex;margin-right:8px;align-items:center;">Filter:</div>
      <div class="controlOptions"> <a class="pageButtons" href="/results?query=&sort=popular&filter=multipass">Multipass</a><a class="pageButtons" href="/results?query=&sort=popular&filter=soundoutput">GPU Sound</a><a class="pageButtons" href="/results?query=&sort=popular&filter=vr">VR</a><a class="pageButtons" href="/results?query=&sort=popular&filter=soundinput">Microphone</a><a class="pageButtons" href="/results?query=&sort=popular&filter=musicstream">Soundcloud</a><a class="pageButtons" href="/results?query=&sort=popular&filter=webcam">Webcam</a></div>
    </div>

    <div>
        <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
        View:</div>
        <div><a class="pageButtons" href="/slideshow?query=&sort=popular">Slideshow</a></div>
    </div>

    <div class="navigation" id="navTop" ><span style="padding-right:8px;">Results (74098):</span><div class="controlOptions"><a id="pageButtonFirst" class="pageButtons" href="results?query=&sort=popular&from=0&num=12">1</a><span>...</span><a id="pageButton"0 class="pageButtons" href="results?query=&sort=popular&from=468&num=12">40</a><a id="pageButton"1 class="pageButtons" href="results?query=&sort=popular&from=480&num=12">41</a><div id="pageButton"2 class="pageButtonsCurrent" href="results?query=&sort=popular&from=492&num=12">42</div><a id="pageButton"3 class="pageButtons" href="results?query=&sort=popular&from=504&num=12">43</a><a id="pageButton"4 class="pageButtons" href="results?query=&sort=popular&from=516&num=12">44</a><span>...</span><a id="pageButtonLast" class="pageButtons" href="results?query=&sort=popular&from=74088&num=12">6175</a></div>
</div>
  </div>


  <div id="shaderGrid">
    <div class='searchResult'><div class='searchResultContainer' id='Preview_0_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_0_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_0_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_0_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_0_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_0_Thumnail'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_0_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_0_Info'>  <span class='previewText'  id='Preview_0_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_0_TextUser'></span>  <span class='previewStats' id='Preview_0_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_1_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_1_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_1_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_1_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_1_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_1_Thumnail'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_1_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_1_Info'>  <span class='previewText'  id='Preview_1_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_1_TextUser'></span>  <span class='previewStats' id='Preview_1_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_2_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_2_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_2_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_2_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_2_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_2_Thumnail'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_2_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_2_Info'>  <span class='previewText'  id='Preview_2_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_2_TextUser'></span>  <span class='previewStats' id='Preview_2_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_3_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_3_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_3_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_3_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_3_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_3_Thumnail'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_3_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_3_Info'>  <span class='previewText'  id='Preview_3_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_3_TextUser'></span>  <span class='previewStats' id='Preview_3_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_4_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_4_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_4_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_4_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_4_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_4_Thumnail'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_4_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_4_Info'>  <span class='previewText'  id='Preview_4_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_4_TextUser'></span>  <span class='previewStats' id='Preview_4_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_5_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_5_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_5_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_5_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_5_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_5_Thumnail'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_5_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_5_Info'>  <span class='previewText'  id='Preview_5_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_5_TextUser'></span>  <span class='previewStats' id='Preview_5_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_6_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_6_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_6_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_6_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_6_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_6_Thumnail'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_6_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_6_Info'>  <span class='previewText'  id='Preview_6_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_6_TextUser'></span>  <span class='previewStats' id='Preview_6_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_7_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_7_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_7_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_7_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_7_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_7_Thumnail'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_7_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_7_Info'>  <span class='previewText'  id='Preview_7_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_7_TextUser'></span>  <span class='previewStats' id='Preview_7_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_8_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_8_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_8_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_8_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_8_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_8_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_8_Thumnail'>        <img class='previewThumbnailImage' id='Preview_8_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_8_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_8_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_8_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_8_Info'>  <span class='previewText'  id='Preview_8_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_8_TextUser'></span>  <span class='previewStats' id='Preview_8_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_9_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_9_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_9_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_9_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_9_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_9_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_9_Thumnail'>        <img class='previewThumbnailImage' id='Preview_9_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_9_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_9_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_9_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_9_Info'>  <span class='previewText'  id='Preview_9_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_9_TextUser'></span>  <span class='previewStats' id='Preview_9_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_10_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_10_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_10_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_10_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_10_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_10_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_10_Thumnail'>        <img class='previewThumbnailImage' id='Preview_10_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_10_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_10_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_10_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_10_Info'>  <span class='previewText'  id='Preview_10_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_10_TextUser'></span>  <span class='previewStats' id='Preview_10_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_11_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_11_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_11_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_11_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_11_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_11_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_11_Thumnail'>        <img class='previewThumbnailImage' id='Preview_11_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_11_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_11_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_11_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_11_Info'>  <span class='previewText'  id='Preview_11_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_11_TextUser'></span>  <span class='previewStats' id='Preview_11_Stats'></span></div></div>  </div>
  <br>
  <div class="navigation" id="navBottom" ><span style="padding-right:8px;">Results (74098):</span><div class="controlOptions"><a id="pageButtonFirst" class="pageButtons" href="results?query=&sort=popular&from=0&num=12">1</a><span>...</span><a id="pageButton"0 class="pageButtons" href="results?query=&sort=popular&from=468&num=12">40</a><a id="pageButton"1 class="pageButtons" href="results?query=&sort=popular&from=480&num=12">41</a><div id="pageButton"2 class="pageButtonsCurrent" href="results?query=&sort=popular&from=492&num=12">42</div><a id="pageButton"3 class="pageButtons" href="results?query=&sort=popular&from=504&num=12">43</a><a id="pageButton"4 class="pageButtons" href="results?query=&sort=popular&from=516&num=12">44</a><span>...</span><a id="pageButtonLast" class="pageButtons" href="results?query=&sort=popular&from=74088&num=12">6175</a></div>
</div>  <br>      
</div>

<!-- footer ================================================================================== -->

<div id="footer">
    
    <div><span style="color:#ffffff;">Community Forums</span>
      <ul>
      <li><a class="regular" href="/events">Official Events</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/147749602472741">In Facebook (english)</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/1339783682699494">In Facebook (korean)</a></li>
      <li><a class="regular" href="https://discord.gg/XtmMN6E">In Discord</a> (<a class="regular" href="https://discordapp.com/channels/578696555612209173/579531723348639754">direct link</a>)</li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Feedback and Support</span>
      <ul>
      <li><a class="regular" href="https://www.facebook.com/Shadertoy">Facebook</a></li>
      <li><a class="regular" href="https://twitter.com/shadertoy">Twitter</a></li>
      <li><a class="regular" href="https://www.patreon.com/shadertoy">Patreon</a></li>
      <li><a class="regular" href="https://trello.com/b/5hM0CjId">Roadmap</a></li>

      
      </ul>
    </div>

    <div><span style="color:#ffffff;">Shadertoy</span>
      <ul>
      <li><a class="regular" href="/store">Store</a></li>
      <li><a class="regular" href="/howto">Documentation</a></li>
      <li><a class="regular" href="/terms">Terms & Privacy</a></li>
      <li><a class="regular" href="/about">About</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Apps and Plugins</span>
      <ul>
      <li><a class="regular" href="https://itunes.apple.com/us/app/shadertoy/id717961814">Official iPhone App</a> by <a class="user" href="/user/reinder">Reinder</a></li>
      <li><a class="regular" href="https://steamcommunity.com/sharedfiles/filedetails/?id=1726697188">Screensaver</a> by <a class="user" href="/user/kosro">Kosro</a></li>
      <li><a class="regular" href="https://chrome.google.com/webstore/detail/shadertoy-unofficial-plug/ohicbclhdmkhoabobgppffepcopomhgl">Shadertoy plugin</a> by <a class="user" href="/user/patu">Patu</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Tutorials</span>
      <ul>
      <li><a class="regular" href="https://www.youtube.com/watch?v=0ifChJ0nJfM">Shader coding intro</a> by <a class="user" href="/user/iq">iq</a></li>
      <li><a class="regular" href="https://shadertoyunofficial.wordpress.com/">Shadertoy Unofficial</a> by <a class="user" href="/user/FabriceNeyret2">FabriceNeyret2</a></li>
      </ul>
    </div>

</div>

<div id="compliance" style="padding-bottom:6px;visibility:hidden;left:0;top:0px;width:100%;background-color:rgb(200,120,20,0.93);position:absolute;color:#FFFFFF">
    <div style="text-align: center; margin-top:8px">
        We use cookies to give you the best experience on our website. If you continue using Shadertoy, we'll assume that you are happy to receive all cookies on this website. 
        For more information, please review our <a class="regular" href="/terms">Terms & Privacy</a>.
    </div> 
    <div style="text-align: center;margin-top:6px">
        <button type="button" style="width:100px;font-size:inherit" onclick="acceptCompliance()">Accept</button>
    </div>
</div>

<script>
(function runCompliance() 
{
    let showCompliance = 1;
    let allcookies = document.cookie;
    let cookiearray = allcookies.split(';');
    for (var i=0; i<cookiearray.length; i++)
    {
        let name  = cookiearray[i].split('=')[0];
        let value = cookiearray[i].split('=')[1];
        if (name.trim() == "scmp") 
        {
            showCompliance = value;
            break;
        }
    }

    if (showCompliance === 1) 
    {
        var ve = document.getElementById("compliance");
        ve.style.visibility="visible";
    }
})();

function acceptCompliance()
{
    let now = new Date();
    now.setTime( now.getTime() + (5*365*24*60*60*1000) );
    document.cookie="scmp=0;expires=" + now.toUTCString() + ";";

    var ve = document.getElementById("compliance");
    ve.style.visibility="hidden";
}
</script>

</body>
</html>
