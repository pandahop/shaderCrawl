<!DOCTYPE HTML>
<html lang="en">
<head>

    
<script async src="https://www.googletagmanager.com/gtag/js?id=G-7SYLWGZYJ2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-7SYLWGZYJ2');
</script>

<title>Browse (40) - Shadertoy BETA</title>
<meta charset="utf-8" />
<meta name="Keywords" content="shadertoy, shader toy, quilez, inigo, jeremias, pol, fractals, demoscene, computer graphics, mathematics, rendering, demo, 3D, realtime, shader, raytracing, raymarching, webgl, glsl" />
<meta name="Description" content="Build shaders, share them, and learn from the best community." />
<meta name="Author" content="Beautypi" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<link rel="image_src" href="https://www.shadertoy.com/img/logo.png" />
<link rel="apple-touch-icon" href="/img/launch_icon_57.png"/>
<link rel="apple-touch-icon" sizes="72x72" href="/img/launch_icon_72.png"/>
<link rel="apple-touch-icon" sizes="114x114" href="/img/launch_icon_114.png"/>
<link rel="shortcut icon" href="/img/favicon.ico"/>

<style>::-webkit-scrollbar {
    height: 8px;
    width: 8px;
    background: #404040;
}

::-webkit-scrollbar-thumb
{
    background: #909090;
    border-radius: 0ex;
}

::-webkit-scrollbar-corner
{
    background: #000;
}

::-webkit-input-placeholder
{
	font-style:italic;
}
input:-moz-placeholder, textarea:-moz-placeholder
{
	font-style:italic;
}
input.placeholder-text, textarea.placeholder-text
{
	font-style:italic;
}

pre 
{
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
    white-space: -pre-wrap;
    white-space: -o-pre-wrap;
    word-wrap: break-word;
}

@font-face
{
    font-family: Lobster;
    src: url("/img/lobster.otf") format("opentype");
}

div#centerScreen
{
    left: 50%;
    top: 50%;
    position: absolute;
}

a.headerLinks:hover
{
    background-color:#505050;
    color : #ff8020;
}

body
{
    color: #000000;
    font-size:12px;
    font-style:normal;
    font-family:Tahoma,Arial;
    background-repeat: no-repeat;
    //background-attachment: fixed;
    padding:0px;
    margin:0px;
    text-align: left;
    background-color: #d0d0d0;
    background-repeat: repeat;
    user-select: text;
}

a,
a:hover,
a:visited
{
  color : inherit;
}

div#content {
    width: 95%;
    overflow: hidden;
    margin: auto;
    padding: 0px;
    min-height: calc(100vh - 80px);
    //box-sizing: border-box;
}


.notificationCount
{
 background-color:#ff0000;
 padding-left:3px;
 padding-right:1px;
 padding-top:1px;
 padding-bottom:1px;
}

div#header
{
    background-color: #404040;
    top: 0px;
    left: 0px;
    width: 100%;
    padding: 0;
    margin: 0;
    color: #ffffff;
    display: flex;
    flex-direction:row;
}

#headerBlock1
{
    width: 50%;
    display:flex;
    align-items:center;
}

a#headerTitle
{
    font-size: 2.25em;
    font-family: Lobster,Tahoma,Arial;
    text-decoration: none;
    padding-left:32px;
    padding-right:32px;
}

#headerSearch
{
    display: inline-block;
    color: #000000;
    width: 300px;
}

input[type=search]#mySearch
{
    width: 100%;
    border-radius: 6px;
    border: 1px solid black;
    padding:12px;
}

#headerBlock2
{
    width: 50%;
    margin-left: auto;
    display: flex;
    justify-content: flex-end;
}


a#headerTitle:hover
{
    color : #ff8020;
}

a.headerLinks
{
    font-weight: bold;
    padding-top: 14px;
    padding-bottom: 14px;
    padding-left: 14px;
    padding-right: 14px;
    margin:0px;
    text-decoration: none;
    transition: background-color 0.15s linear, color 0.15s linear;
}

#footer
{
    background-color: rgba(64,64,64,0.25);
    color: #000000;
    padding: 0px;
    margin: 0px;
    width: 100%;
    display: flex;
    justify-content: space-between;
    flex-wrap: wrap;
}

#footer div
{
    padding-top:10px;
    padding-bottom:0px;
    padding-left:16px;
    padding-right:16px;
}

#footer div ul
{
    margin-left:0px;
    padding-left:16px;
}

#footer div ul li
{
    padding-top:6px;
}

a.regular
{
    font-weight:bold;
    text-decoration:none
}

a.regular:hover
{
  color : #ff8020;
}

a.user
{
    font-weight:bold;
    text-decoration:none;
}

a.user:hover
{
  color : #ff8020;
  text-decoration: underline;
}

.uiButton
{
    border: none;
    outline: none;
    margin: 0px;
    padding: 0px;
    width: 22px;
    height: 22px;
    position: absolute;
    cursor: pointer;
    border-radius: 4px;
}

.uiButton:hover
{
    box-shadow: inset 0px 0px 1px 1px #808080, 0px 0px 1px 1px #808080;
}

.uiDivBUtton
{
    cursor:pointer;
}

.uiDivBUtton:hover
{
    color: #ffffff;
}


.dialog
{
    display: block;
    background-color: #e0e0e0;
    color: #000000;
    border:1px solid #000;
    padding:0px;
    margin:0px;
    text-align:left;
    border-radius: 4px;
    box-shadow:4px 4px 6px 0px rgba(0,0,0,0.5);
    overflow: hidden;
    z-index:1000;
    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;
}

.dialogHeader
{
    left:0px;
    top: 0px;
    width:100%;
    height:32px;
    position: absolute;
    background-color: #808080;
    cursor:move;
}

.dialogTitle
{
    left: 12px;
    top: 4px;
    position: absolute;
    padding: 0px;
    margin: 0px;
    color:#000000;
    font-size:1.5em;
    text-align: left;
    user-select: none;
    -moz-user-select: -moz-none;
    -webkit-user-select: none;
}

.dialogOverlay
{
    z-index:1000;

    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;

    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    width:100%;
    height:100%;
    position:absolute;

    background-color:rgba(0,0,0,.4);
}

.viewsIcon, .likesIcon
{
    border: none;
    outline: none;
    display:inline-block;
    background-repeat:no-repeat;
    top:0px;
    left:0px;
    padding:0px;
    padding-right: 2px;
    margin:0px;
    position:relative;
}

.userPictureSmall
{
    background-color:#808080;
    border: 1px solid #000000;
    width:32px;
    height:32px;
}

.dialogCloseButton
{
    right:8px;
    top: 4px;
    width:22px;
    height:22px;
    position: absolute;
    background-image: url("/img/close.png");
    cursor: pointer;
    border-radius: 4px;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContentButtons
{
     padding:0;
     border:0;
     text-align: justify;
     left: 24px;
     bottom:40px;
     position:absolute;
}

.dialogButton
{
    text-align: center;
    vertical-align: middle;
    display: inline-block;
    border-radius: 4px;
    font-weight: bold;
    cursor: pointer;
    padding-bottom:5px;
    padding-top:4px;
    padding-left: 8px;
    padding-right: 8px;
    margin-left:4px;
    margin-right:4px;
    text-decoration: none;
    color:#000000;
    width: 80px;
    -moz-transition:    background-color 0.15s linear, color 0.15s linear;
    -webkit-transition: background-color 0.15s linear, color 0.15s linear;
    transition:         background-color 0.15s linear, color 0.15s linear;
}

.dialogButton:hover
{
  background-color:#808080;
  color : #ff8020;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContent
{
    color: inherit;
    overflow: auto;
    width:100%;
    height:100%;
    left: 0px;
    top: 32px;
    position:absolute
}

.dialogContentBody
{
    color: inherit;
    width:100%;
    height:auto;
    padding-top:24px;
    padding-bottom:24px;
    padding-left:24px;
    padding-right:24px;
    text-align: left;
}

.formButton
{
    font-weight:bold;
	color:#ffffff;
	border:none;
    text-align:center;
	background-color:#808080;
    border-radius: 4px;
	padding-left:8px;
	padding-right:8px;
	padding-top:4px;
	padding-bottom:4px;
    cursor:pointer;
    min-width:80px;
    box-sizing: border-box;
}
.formInput {
    border-radius: 6px;
    border: 1px solid black;
    padding: 4px;
    border: none;
}
.formButton:hover {
    background-color: #e0e0e0;
}
.formButton:disabled
{
	color:#b0b0b0;
	background-color:#808080;
}

.formButtonSmall
{
    color:#ffffff;
    border:none;
    text-align:center;
    background-color:#808080;
    border-radius: 4px;
    padding-left:2px;
    padding-right:2px;
    padding-top:2px;
    padding-bottom:2px;
    cursor:pointer;
    min-width:40px;
}

.formButtonSmall:hover
{
    background-color: #e0e0e0;
}

.formButtonSmall:disabled
{
    color:#b0b0b0;
    background-color:#808080;
}

.formButtonSmall.disabled2,
.formButton.disabled2 { color:#b0b0b0; background-color:#808080; pointer-events: none; }

.inputForm
{
    padding-left:2%;
    padding-right:2%;
    resize: none;
    text-align: left;
    background-color:#e0e0e0;
    outline: none;
    border-radius: 4px;
    border: 1px solid #808080;
    color:inherit;
    box-sizing: border-box;
}

.inputForm:focus
{
    border: 1px solid #AFCDD8;
    background-color: #EBF2F4;
}

.transparentPannel
{
    background-color:rgba(64,64,64,0.1);
    padding:16px;
}

.comment, .commentSelf, .commentNew
{
    border-radius: 4px;
    width: 100%;
    margin-left: 0px;
    margin-right: 0px;
    margin-top: 0px;
    margin-bottom: 6px;

    padding: 14px;
    box-sizing: border-box;
    display: grid;
    grid-template-columns: 32px auto 8px;
    grid-template-rows: 1fr;
    grid-gap:8px;
}

.comment:nth-child(even)
{
    background-color: rgba(64,64,64,0.1);
}

.comment:nth-child(odd)
{
    background-color: rgba(128,128,128,0.1);
}

.commentSelf
{
    background-color: rgba(240,160,64,0.1);
}

.commentNew
{
    padding-right: 0px;
    grid-template-columns: 40px auto;
}

.commentContent
{
    vertical-align: top;
    text-align: left;
    word-break: break-all;
    word-break: break-word;
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
}


/* ----------------------- media resolutions ------------------------ */

@media screen and (max-width:799px)
{
    div#header {flex-direction:column; }
    #headerBlock1 { width:100%; }
    #headerBlock2 { width:100%; justify-content: space-around;}
    div#headerSearch {width:200px;}
    input#mySearch { width:200px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:10px; }
}

@media screen and (min-width:800px) and (max-width:1279px)
{
    body { font-size: 9px; }
    div#headerSearch {width: 250px;}
    input#mySearch { width:250px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:11px; }
}

@media screen and (min-width:1280px) and (max-width:1439px)
{
    body { font-size: 10px; }
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1440px) and (max-width:1919px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1920px) and (max-width:2559px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}

@media screen and (min-width:2560px) 
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}
body
{
    background-image: url("/img/themes/classic/background.jpg");
}
</style>

    <script>"use strict"

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piCamera
//
//==============================================================================

function piCamera()
{
    var mMatrix = setIdentity();
    var mMatrixInv = setIdentity();

    var mPosition = [0.0,0.0,0.0];
    var mXRotation = 0.0;
    var mYRotation = 0.0;

    var mPositionTarget = [0.0,0.0,0.0];
    var mXRotationTarget = 0.0;
    var mYRotationTarget = 0.0;

    var me = {};
/*
    me.Set = function( pos, dir, roll) 
             {
                 mMatrix    = setLookat( pos, add(pos,dir), [Math.sin(roll),Math.cos(roll),Math.sin(roll)] );
                 mMatrixInv = invertFast( mMatrix );
             };
*/
    me.SetPos = function(pos)
                {
                    mPosition = pos;
                    //mMatrix[ 3] = -(mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                    //mMatrix[ 7] = -(mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                    //mMatrix[11] = -(mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                };
/*
    me.GlobalMove = function(pos)
                    {
                        mMatrix[ 3] -= (mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                        mMatrix[ 7] -= (mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                        mMatrix[11] -= (mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                        mMatrixInv = invertFast(mMatrix);
                    };
*/
    me.LocalMove = function( dis )
                    {
                        dis = matMulvec( setRotationY(-mYRotation), dis);
                        mPositionTarget = sub(mPositionTarget,dis)
                    };

    me.RotateXY = function( x, y)
                  {
                    mXRotationTarget -= x;
                    mYRotationTarget -= y;
                    mXRotationTarget = Math.min( Math.max( mXRotationTarget, -Math.PI/2), Math.PI/2 );
                  };


    me.CameraExectue = function( dt )
    {
        // smooth position
        mXRotation += (mXRotationTarget-mXRotation) * 12.0*dt;
        mYRotation += (mYRotationTarget-mYRotation) * 12.0*dt;
        mPosition = add(mPosition, mul( sub(mPositionTarget, mPosition), 12.0*dt));

        // Make Camera matrix
        mMatrix = matMul( matMul(setRotationX(mXRotation), 
                                 setRotationY(mYRotation)),  
                                 setTranslation(mPosition));
        mMatrixInv = invertFast(mMatrix);

    }

    me.GetMatrix = function() { return mMatrix; };
    me.GetMatrixInverse = function() { return mMatrixInv; };
    me.SetMatrix = function( mat ) 
                    {
                        mMatrix = mat;
                        mMatrixInv = invertFast(mMatrix);

                        mPosition = getXYZ(matMulpoint(mat, [0.0,0.0,0.0]));
                        mPositionTarget = mPosition;
                    };

    me.GetPos = function() { return getXYZ(matMulpoint(mMatrixInv, [0.0,0.0,0.0])); }
    me.GetDir = function() { return getXYZ(normalize(matMulvec(mMatrixInv, [0.0,0.0,-1.0]))); }

    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piFile
//
//==============================================================================

function piFile( binaryDataArrayBuffer )
{
    // private
    //var mDataView = new DataView( binaryDataArrayBuffer, 0 );
    var mDataView = binaryDataArrayBuffer;
    var mOffset = 0;

    // public members
    var me = {};
    me.mDummy = 0;
/*
    // public functions
    me.Seek = function( off ) { mOffset = off - 3; };
    me.ReadUInt16 = function()  { var res = mDataView.getUint16( mOffset ); mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = mDataView.getUint32( mOffset ); mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = mDataView.getFloat32( mOffset ); mOffset+=4; return res; };
*/

    me.Seek = function( off ) { mOffset = off; };
    me.ReadUInt8  = function()  { var res = (new Uint8Array(mDataView,mOffset))[0]; mOffset+=1; return res; };
    me.ReadUInt16 = function()  { var res = (new Uint16Array(mDataView,mOffset))[0]; mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = (new Uint32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = (new Float32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadFloat32Array = function(n) 
                          { 
                              var src = new Float32Array(mDataView, mOffset);
                              var res = [];  for( var i=0; i<n; i++ ) { res[i] = src[i]; }
                              mOffset += 4*n;
                              return res;
                          };
    me.ReadFloat32ArrayNative = function(n) { var src = new Float32Array(mDataView, mOffset); mOffset += 4*n; return src; };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piMesh
//
//==============================================================================

function piMesh()
{
    this.mChunks = [];
    this.mPrimitiveType = 0;
    this.mVertexFormat = null;
}

/*
piMesh.prototype.normalize = function( ppos, npos )
{
    var numv = this.mVertexData.length;
    var numt = this.mIndices.length;

    for( var i=0; i<numv; i++ )
    {
        //float *v = (float*)piMesh_GetVertexData( me, i, npos );
        //v[0] = 0.0f;
        //v[1] = 0.0f;
        //v[2] = 0.0f;
        this.mVerts[8 * i + 3] = 0.0;
        this.mVerts[8 * i + 4] = 0.0;
        this.mVerts[8 * i + 5] = 0.0;
    }

    for( var i=0; i<numt; i++ )
    {
        piMeshFace *face = me->mFaceData.mIndexArray[0].mBuffer + i;

        const int ft = face->mNum;
        
        vec3 nor = vec3( 0.0f, 0.0f, 0.0f );
        for( int j=0; j<ft; j++ )
        {
            const vec3 va = *((vec3*)piMesh_GetVertexData( me, face->mIndex[ j      ], ppos ));
            const vec3 vb = *((vec3*)piMesh_GetVertexData( me, face->mIndex[(j+1)%ft], ppos ));

            nor += cross( va, vb );
        }

        for( int j=0; j<ft; j++ )
        {
            vec3 *n = (vec3*)piMesh_GetVertexData( me, face->mIndex[j], npos );
            n->x += nor.x;
            n->y += nor.y;
            n->z += nor.z;
        }
    }

    for( var i=0; i<numv; i++ )
    {
        vec3 *v = (vec3*)piMesh_GetVertexData( me, i, npos );
        *v = normalize( *v );
    }
}
*/

piMesh.prototype.createCube = function(renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([ -1.0, -1.0, -1.0,
                                       1.0, -1.0, -1.0,
                                      -1.0,  1.0, -1.0,
                                       1.0,  1.0, -1.0,
                                      -1.0, -1.0,  1.0,
                                       1.0, -1.0,  1.0,
                                      -1.0,  1.0,  1.0,
                                       1.0,  1.0,  1.0 ]),

                        mIndices : new Uint16Array([ 0, 2, 1,   1, 2, 3,   5, 1, 3,   5, 3, 7,   4, 5, 7,   4, 7, 6,   4, 6, 2,   4, 2, 0,   6, 7, 3,   6, 3, 2,   4, 0, 1,   4, 1, 5 ]),
                        mNumVertices : 8,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };

    this.mVertexFormat = { mStride:12, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}

piMesh.prototype.createCubeSharp = function (renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 1.0,
                                    -1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 0.0,

                                     1.0, 1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 0.0,

                                     1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 1.0,
                                    -1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   1.0, 1.0,
                                     1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   1.0, 0.0,

                                    -1.0, 1.0, 1.0,  -1.0, 0.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0,-1.0,  -1.0, 0.0, 0.0,   0.0, 1.0,
                                    -1.0,-1.0,-1.0,  -1.0, 0.0, 0.0,   1.0, 1.0,
                                    -1.0,-1.0, 1.0,  -1.0, 0.0, 0.0,   1.0, 0.0 ]),

                        mIndices : new Uint16Array([0,1,2, 0,2,3,   4,5,6, 4,6,7,    8,9,10,8,10,11,   12,13,14,12,14,15,   16,17,18,16,18,19,   20,21,22,20,22,23]),
                        mNumVertices : 24,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };


    this.mVertexFormat = { mStride:32, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}


piMesh.prototype.createUnitQuad = function (renderer)
{
    this.mPrimitiveType = 0;
    this.mVertexFormat = { mStride:8, mChannels: [ {mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false} ] };

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0,  1.0, 1.0,  1.0]),
                        mIndices : new Uint16Array([0, 2, 1, 1, 2, 3]),
                        mNumVertices : 4,
                        mNumFaces : 2, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };
 
    return true;
}




piMesh.prototype.destroy = function()
{
    //delete this.mVerts;   this.mVerts = null;
    //delete this.mIndices; this.mIndices = null;
}

piMesh.prototype.scale = function (x, y, z)
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] *= x;
            this.mChunks[j].mVerts[stride * i + 1] *= y;
            this.mChunks[j].mVerts[stride * i + 2] *= z;
        }
    }
}

piMesh.prototype.translate = function (x, y, z) 
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] += x;
            this.mChunks[j].mVerts[stride * i + 1] += y;
            this.mChunks[j].mVerts[stride * i + 2] += z;
        }
    }
}

piMesh.prototype.GPULoad = function (renderer)
{
    for( var i=0; i<this.mChunks.length; i++ )
    {
        var vbo = renderer.CreateVertexArray(this.mChunks[i].mVerts, renderer.BUFTYPE.STATIC );
        if (vbo == null)
            return false;

        var ibo = renderer.CreateIndexArray(this.mChunks[i].mIndices, renderer.BUFTYPE.STATIC);
        if (ibo == null)
            return false;

        this.mChunks[i].mVBO = vbo;
        this.mChunks[i].mIBO = ibo;
    }
    return true;
}

piMesh.prototype.GPURender = function (renderer, positions )//, matPrj, matCam )
{
    //renderer.SetShaderConstantMat4F("unMPrj", matPrj, false );

    var num = this.mChunks.length;
    for( var i=0; i<num; i++ )
    {
        //var mat =  matMul( matCam, this.mChunks[i].mTransform );
        //renderer.SetShaderConstantMat4F("unMMod", mat, false);

        renderer.AttachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat, positions );
        renderer.AttachIndexArray(this.mChunks[i].mIBO );
        renderer.DrawPrimitive(renderer.PRIMTYPE.TRIANGLES, this.mChunks[i].mNumFaces * 3, true, 1);
        renderer.DetachIndexArray(this.mChunks[i].mIBO);
        renderer.DetachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat );
    }
}
//==============================================================================
//
// piLibs 2014-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piRenderer
//
//==============================================================================

function piRenderer()
{
    // private members

    var mGL = null;
    var mBindedShader = null;
    var mIs20 = false;
    var mFloat32Textures;
    var mFloat32Filter;
    var mFloat16Textures;
    var mDrawBuffers;
    var mDepthTextures;
    var mDerivatives;
    var mFloat16Filter;
    var mShaderTextureLOD;
    var mAnisotropic;
    var mRenderToFloat32F;
    var mDebugShader;
    var mAsynchCompile;

    var mVBO_Quad = null;
    var mVBO_Tri = null;
    var mVBO_CubePosNor = null;
    var mVBO_CubePos = null;
    var mShaderHeader = ["",""];
    var mShaderHeaderLines = [0,0];

    // public members
    var me = {};

    me.CLEAR      = { Color: 1, Zbuffer : 2, Stencil : 4 };
    me.TEXFMT     = { C4I8 : 0, C1I8 : 1, C1F16 : 2, C4F16 : 3, C1F32 : 4, C4F32 : 5, Z16 : 6, Z24 : 7, Z32 : 8, C3F32:9 };
    me.TEXWRP     = { CLAMP : 0, REPEAT : 1 };
    me.BUFTYPE    = { STATIC : 0, DYNAMIC : 1 };
    me.PRIMTYPE   = { POINTS : 0, LINES : 1, LINE_LOOP : 2, LINE_STRIP : 3, TRIANGLES : 4, TRIANGLE_STRIP : 5 };
    me.RENDSTGATE = { WIREFRAME : 0, FRONT_FACE : 1, CULL_FACE : 2, DEPTH_TEST : 3, ALPHA_TO_COVERAGE : 4 };
    me.TEXTYPE    = { T2D : 0, T3D : 1, CUBEMAP : 2 };
    me.FILTER     = { NONE : 0, LINEAR : 1, MIPMAP : 2, NONE_MIPMAP : 3 };
    me.TYPE       = { UINT8 : 0, UINT16 : 1, UINT32 : 2, FLOAT16: 3, FLOAT32 : 4, FLOAT64: 5 };

    // private functions

    var iFormatPI2GL = function( format )
    {
        if( mIs20 )
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA8,           mGLExternal: mGL.RGBA,             mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.R8,              mGLExternal: mGL.RED,              mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.R16F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA16F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.R32F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA32F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C3F32) return { mGLFormat: mGL.RGB32F,          mGLExternal: mGL.RGB,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT16, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z24)   return { mGLFormat: mGL.DEPTH_COMPONENT24, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z32)   return { mGLFormat: mGL.DEPTH_COMPONENT32F, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        }
        else
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.RED,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT, mGLExternal: mGL.DEPTH_COMPONENT, mGLType: mGL.UNSIGNED_SHORT }
        }

        return null;
     }

    // public functions

    me.Initialize = function( gl )
                    {
                        mGL = gl;

                        mIs20 = !(gl instanceof WebGLRenderingContext);

                        if( mIs20 )
                        {
                            mFloat32Textures  = true;
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = true;
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = true;
                            mDrawBuffers      = true;
                            mDepthTextures    = true;
                            mShaderTextureLOD = true;
                            mAnisotropic = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mGL.getExtension( 'EXT_color_buffer_float');
                            mDebugShader = mGL.getExtension('WEBGL_debug_shaders');
                            mAsynchCompile = mGL.getExtension('KHR_parallel_shader_compile');

							mGL.hint( mGL.FRAGMENT_SHADER_DERIVATIVE_HINT, mGL.NICEST);
                        }
                        else
                        {
                            mFloat32Textures  = mGL.getExtension( 'OES_texture_float' );
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = mGL.getExtension( 'OES_texture_half_float' );
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = mGL.getExtension( 'OES_standard_derivatives' );
                            mDrawBuffers      = mGL.getExtension( 'WEBGL_draw_buffers' );
                            mDepthTextures    = mGL.getExtension( 'WEBGL_depth_texture' );
                            mShaderTextureLOD = mGL.getExtension( 'EXT_shader_texture_lod' );
                            mAnisotropic      = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mFloat32Textures;
                            mDebugShader      = null;
                            mAsynchCompile    = null;
							
							if( mDerivatives !== null) mGL.hint( mDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, mGL.NICEST);
                        }
                        
                        
                        var maxTexSize = mGL.getParameter( mGL.MAX_TEXTURE_SIZE );
                        var maxCubeSize = mGL.getParameter( mGL.MAX_CUBE_MAP_TEXTURE_SIZE );
                        var maxRenderbufferSize = mGL.getParameter( mGL.MAX_RENDERBUFFER_SIZE );
                        var extensions = mGL.getSupportedExtensions();
                        var textureUnits = mGL.getParameter( mGL.MAX_TEXTURE_IMAGE_UNITS );
                        console.log("WebGL (2.0=" + mIs20 + "):" +
                                    " Asynch Compile: "  + ((mAsynchCompile !==null) ? "yes" : "no") +
                                    ", Textures: F32 ["   + ((mFloat32Textures !==null) ? "yes" : "no") +
                                    "], F16 ["   + ((mFloat16Textures !==null) ? "yes" : "no") +
                                    "], Depth [" + ((mDepthTextures   !==null) ? "yes" : "no") +
                                    "], LOD ["    + ((mShaderTextureLOD!==null) ? "yes" : "no") +
                                    "], Aniso ["   + ((mAnisotropic     !==null) ? "yes" : "no") +
                                    "], Units [" + textureUnits +
                                    "], Max Size [" + maxTexSize +
                                    "], Cube Max Size [" + maxCubeSize +
                                    "], Targets: MRT ["            + ((mDrawBuffers     !==null) ? "yes" : "no") +
                                    "], F32 ["     + ((mRenderToFloat32F!==null) ? "yes" : "no") +
                                    "], Max Size [" + maxRenderbufferSize + "]");

                        // create a 2D quad Vertex Buffer
                        var vertices = new Float32Array( [ -1.0, -1.0,   1.0, -1.0,    -1.0,  1.0,     1.0, -1.0,    1.0,  1.0,    -1.0,  1.0] );
                        mVBO_Quad = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                        mGL.bufferData( mGL.ARRAY_BUFFER, vertices, mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 2D triangle Vertex Buffer
                        mVBO_Tri = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0,   3.0, -1.0,    -1.0,  3.0] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePosNor = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0, -1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                               1.0,  1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                               1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                               1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                               1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0,  1.0, -1.0,   0.0,  0.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePos = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0,  1.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        //-------------------------------------------------------------------

                        mShaderHeader[0] = "";
                        mShaderHeaderLines[0] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[0] += "#version 300 es\n" +
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[0] += 6;
                        }
                        else
                        {
                            mShaderHeader[0] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "#endif\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+                                                
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[0] += 26;
                        }

                        //-------------------------------------------------------

                        mShaderHeader[1] = "";
                        mShaderHeaderLines[1] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[1] += "#version 300 es\n"+
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[1] += 6;
                        }
                        else
                        {
                            if( mDerivatives ) { mShaderHeader[1] += "#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n"; mShaderHeaderLines[1]+=3; }
                            if( mShaderTextureLOD  ) { mShaderHeader[1] += "#extension GL_EXT_shader_texture_lod : enable\n"; mShaderHeaderLines[1]++; }
                            mShaderHeader[1] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "#endif\n"+ 
                                                "vec4 texture(     sampler2D   s, vec2 c)                   { return texture2D(s,c); }\n"+
                                                "vec4 texture(     sampler2D   s, vec2 c, float b)          { return texture2D(s,c,b); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c )                  { return textureCube(s,c); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c, float b)          { return textureCube(s,c,b); }\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[1] += 30;
                            if( mShaderTextureLOD )
                            {
                            mShaderHeader[1] += "vec4 textureLod(  sampler2D   s, vec2 c, float b)          { return texture2DLodEXT(s,c,b); }\n";
                            mShaderHeader[1] += "vec4 textureGrad( sampler2D   s, vec2 c, vec2 dx, vec2 dy) { return texture2DGradEXT(s,c,dx,dy); }\n";
                            mShaderHeaderLines[1] += 2;

                            //mShaderHeader[1] += "vec4 texelFetch( sampler2D s, ivec2 c, int l) { return texture2DLodEXT(s,(vec2(c)+0.5)/vec2(800,450),float(l)); }\n";
                            //mShaderHeaderLines[1] += 1;
                            }
                        }

                        return true;
                    };

        me.GetCaps =    function ()
                        {   
                            return { mIsGL20 : mIs20,
                                     mFloat32Textures: mFloat32Textures != null,
                                     mFloat16Textures: mFloat16Textures != null,
                                     mDrawBuffers: mDrawBuffers != null,
                                     mDepthTextures: mDepthTextures != null,
                                     mDerivatives: mDerivatives != null,
                                     mShaderTextureLOD: mShaderTextureLOD != null };
                        };

        me.GetShaderHeaderLines = function (shaderType)
                        {   
                            return mShaderHeaderLines[shaderType];
                        };

        me.CheckErrors = function()
                         {
                                var error = mGL.getError();
                                if( error != mGL.NO_ERROR ) 
                                { 
                                    for( var prop in mGL ) 
                                    {
                                        if( typeof mGL[prop] == 'number' ) 
                                        {
                                            if( mGL[prop] == error )
                                            {
                                                console.log( "GL Error " + error + ": " + prop );
                                                break;
                                            }
                                        }
                                    }
                                }
                         };

        me.Clear =  function( flags, ccolor, cdepth, cstencil )
                    {
                        var mode = 0;
                        if( flags & 1 ) { mode |= mGL.COLOR_BUFFER_BIT;   mGL.clearColor( ccolor[0], ccolor[1], ccolor[2], ccolor[3] ); }
                        if( flags & 2 ) { mode |= mGL.DEPTH_BUFFER_BIT;   mGL.clearDepth( cdepth ); }
                        if( flags & 4 ) { mode |= mGL.STENCIL_BUFFER_BIT; mGL.clearStencil( cstencil ); }
                        mGL.clear( mode );
                    };


        me.CreateTexture = function ( type, xres, yres, format, filter, wrap, buffer)
                           {
                                if( mGL===null ) return null;

                                var id = mGL.createTexture();

                                var glFoTy = iFormatPI2GL( format );
                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                if( type===me.TEXTYPE.T2D )
                                {
                                    mGL.bindTexture( mGL.TEXTURE_2D, id );
//if( buffer==null )
    //mGL.texStorage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres);
//else
                                    mGL.texImage2D( mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap );

                                    if (filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                }
                                else if( type===me.TEXTYPE.T3D )
                                {
                                    if( mIs20 )
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_3D, id );
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_BASE_LEVEL, 0);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAX_LEVEL, Math.log2(xres));
                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_3D);
                                        }
                                        mGL.texImage3D( mGL.TEXTURE_3D, 0, glFoTy.mGLFormat, xres, yres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap );

                                        if (filter === me.FILTER.MIPMAP)
                                            mGL.generateMipmap( mGL.TEXTURE_3D );
                                        mGL.bindTexture( mGL.TEXTURE_3D, null );
                                    }
                                    else 
                                    {
                                        return null;
                                    }
                                }
                                else 
                                {
                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );

                                    // this works great if we know the number of required mipmaps in advance (1, or other)
                                   //mGL.texStorage2D( mGL.TEXTURE_CUBE_MAP, 1, glFoTy.mGLFormat, xres, yres );

                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                    if( filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                    }

                                    if (filter === me.FILTER.MIPMAP)
                                        mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );

                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                }
                        return { mObjectID: id, mXres: xres, mYres: yres, mFormat: format, mType: type, mFilter: filter, mWrap: wrap, mVFlip:false };
                        };

        me.CreateTextureFromImage = function ( type, image, format, filter, wrap, flipY) 
                                {
                                    if( mGL===null ) return null;

                                    var id = mGL.createTexture();

                                    var glFoTy = iFormatPI2GL( format );

                                    var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                    if( type===me.TEXTYPE.T2D )
                                    {
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);

                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.pixelStorei(mGL.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                                        if( mIs20 ) mGL.pixelStorei(mGL.UNPACK_COLORSPACE_CONVERSION_WEBGL, mGL.NONE );

                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);

                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);

                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if( filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                    }
                                    else if( type===me.TEXTYPE.T3D )
                                    {
                                        return null;
                                    }
                                    else 
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );

                                        if( filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                    }
                                    return { mObjectID: id, mXres: image.width, mYres: image.height, mFormat: format, mType: type, mFilter: filter, mWrap:wrap, mVFlip:flipY };
                                };

        me.SetSamplerFilter = function (te, filter, doGenerateMipsIfNeeded) 
                            {
                                if (te.mFilter === filter) return;

                                if (te.mType === me.TEXTYPE.T2D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_3D, null);

                                }
                                else
                                {
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }


                                te.mFilter = filter;
                            };

        me.SetSamplerWrap = function (te, wrap)
                            {
                                if (te.mWrap === wrap) return;

                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, id);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, id);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_3D, null);
                                }

                                te.mWrap = wrap;
                            };

        me.SetSamplerVFlip = function (te, vflip, image)
                            {
                                if (te.mVFlip === vflip) return;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    if( image != null)
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                }
                                else if (te.mType === me.TEXTYPE.CUBEMAP)
                                {
                                    if( image != null)
                                    {
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei( mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
        
                                }

                                te.mVFlip = vflip;
                            };

        me.CreateMipmaps =  function (te)
                            {
                                if( te.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);
                                    mGL.generateMipmap(mGL.TEXTURE_2D);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);
                                }
                                else if( te.mType===me.TEXTYPE.CUBEMAP )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);
                                    mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }
                            };

        me.UpdateTexture =  function( tex, x0, y0, xres, yres, buffer )
                            {
                                var glFoTy = iFormatPI2GL( tex.mFormat );
                                if( tex.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture( mGL.TEXTURE0);
                                    mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                    mGL.texSubImage2D( mGL.TEXTURE_2D, 0, x0, y0, xres, yres, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                }
                            };

        me.UpdateTextureFromImage = function( tex, image )
                                {
                                    var glFoTy = iFormatPI2GL( tex.mFormat );
                                    if( tex.mType===me.TEXTYPE.T2D )
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                        mGL.texImage2D(  mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image );
                                        mGL.bindTexture( mGL.TEXTURE_2D, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                };

        me.DestroyTexture = function( te )
                            {
                                 mGL.deleteTexture( te.mObjectID );
                            };

        me.AttachTextures = function (num, t0, t1, t2, t3) 
                            {
                                if (num > 0 && t0 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                         if (t0.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t0.mObjectID);
                                }

                                if (num > 1 && t1 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE1);
                                         if (t1.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t1.mObjectID);
                                }

                                if (num > 2 && t2 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE2);
                                         if (t2.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t2.mObjectID);
                                }

                                if (num > 3 && t3 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE3);
                                         if (t3.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t3.mObjectID);
                                }
                            };

        me.DettachTextures = function()
                             {
                                mGL.activeTexture(mGL.TEXTURE0);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE1);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE2);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE3);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                             };

        me.CreateRenderTarget = function ( color0, color1, color2, color3, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);

                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_2D, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.DestroyRenderTarget = function ( tex )
                                 {
                                     mGL.deleteFramebuffer(tex.mObjectID);
                                 };

        me.SetRenderTarget = function (tex)
                             {
                                if( tex===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, tex.mObjectID);

                                //mGL.drawBuffers([mGL.COLOR_ATTACHMENT0, mGL.COLOR_ATTACHMENT1]);
                             };

        me.CreateRenderTargetNew = function ( wantColor0, wantZbuffer, xres, yres, samples )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if( wantZbuffer===true )
                                    {
                                        var zb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);

                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.DEPTH_COMPONENT16, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                    }

                                    if( wantColor0 )
                                    {
                                        var cb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, cb);
                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.RGBA8, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.RGBA8, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.RENDERBUFFER, cb);
                                    }

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                    {
                                        return null;
                                    }
                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mXres: xres, mYres:yres, mTex0: color0 };
                                };

        me.CreateRenderTargetCubeMap = function ( color0, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);
                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.SetRenderTargetCubeMap = function (fbo, face)
                             {
                                if( fbo===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                {
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, fbo.mObjectID);
                                    mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X+face, fbo.mTex0.mObjectID, 0);
                                }
                             };


        me.BlitRenderTarget = function( dst, src )
                                {
                                    mGL.bindFramebuffer(mGL.READ_FRAMEBUFFER, src.mObjectID);
                                    mGL.bindFramebuffer(mGL.DRAW_FRAMEBUFFER, dst.mObjectID);
                                    mGL.clearBufferfv(mGL.COLOR, 0, [0.0, 0.0, 0.0, 1.0]);
                                    mGL.blitFramebuffer( 0, 0, src.mXres, src.mYres,
                                                         0, 0, src.mXres, src.mYres,
                                                         mGL.COLOR_BUFFER_BIT, mGL.LINEAR
                                    );
                                };

        me.SetViewport = function( vp )
                         {
                              mGL.viewport( vp[0], vp[1], vp[2], vp[3] );
                         };

        me.SetWriteMask = function( c0, c1, c2, c3, z )
                          {
                              mGL.depthMask(z);
                              mGL.colorMask(c0,c0,c0,c0);
                          };

        me.SetState = function( stateName, stateValue )
                      {
                            if (stateName === me.RENDSTGATE.WIREFRAME)
                            {
                                if( stateValue ) mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.LINE );
                                else             mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.FILL );
                            }
                            else if (stateName === me.RENDSTGATE.FRONT_FACE)
                            {
                                if( stateValue ) mGL.cullFace( mGL.BACK );
                                else             mGL.cullFace( mGL.FRONT );
                            }
                            else if (stateName === me.RENDSTGATE.CULL_FACE)
                            {
                                if( stateValue ) mGL.enable( mGL.CULL_FACE );
                                else             mGL.disable( mGL.CULL_FACE );
                            }
                            else if (stateName === me.RENDSTGATE.DEPTH_TEST)
                            {
                                if( stateValue ) mGL.enable( mGL.DEPTH_TEST );
                                else             mGL.disable( mGL.DEPTH_TEST );
                            }
                            else if (stateName === me.RENDSTGATE.ALPHA_TO_COVERAGE)
                            {
                                if( stateValue ) { mGL.enable(  mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                                else             { mGL.disable( mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                            }
                      };

        me.SetMultisample = function( v)
                    {
                        if( v===true )
                        {
                            mGL.enable(mGL.SAMPLE_COVERAGE);
                            mGL.sampleCoverage(1.0, false);
                        }
                        else
                        {
                            mGL.disable(mGL.SAMPLE_COVERAGE);
                        }
                    };

        me.GetTranslatedShaderSource = function (shader) 
                          {
                            if( mGL===null ) return null;
                            if( mDebugShader===null ) return null;
                            let vfs = mGL.getAttachedShaders(shader.mProgram);
                            let str = mDebugShader.getTranslatedShaderSource(vfs[1]);
                            let parts = str.split("GLSL END"); str = (parts.length<2) ? str : parts[1];
                            return str;
                          };

        me.CreateShader = function (vsSource, fsSource, preventCache, forceSynch, onResolve) 
                          {
                            if( mGL===null ) return;

                            var vs = mGL.createShader( mGL.VERTEX_SHADER   );
                            var fs = mGL.createShader( mGL.FRAGMENT_SHADER );

                            vsSource = mShaderHeader[0] + vsSource;
                            fsSource = mShaderHeader[1] + fsSource;

                            if( preventCache )
                            {
                                let vran = Math.random().toString(36).substring(7);
                                let fran = Math.random().toString(36).substring(7);
                                vsSource += "\n#define K" + vran + "\n";
                                fsSource += "\n#define K" + fran + "\n";
                            }

                            var timeStart = getRealTime();

                            mGL.shaderSource(vs, vsSource);
                            mGL.shaderSource(fs, fsSource);
                            mGL.compileShader(vs);
                            mGL.compileShader(fs);

                            var pr = mGL.createProgram();
                            mGL.attachShader(pr, vs);
                            mGL.attachShader(pr, fs);
                            mGL.linkProgram(pr);

                            //-------------
                            let checkErrors = function()
                            {
                                if (!mGL.getProgramParameter(pr, mGL.LINK_STATUS))
                                {
                                    // vs error
                                    if (!mGL.getShaderParameter(vs, mGL.COMPILE_STATUS))
                                    {
                                        let vsLog = mGL.getShaderInfoLog(vs);
                                        onResolve(false, { mErrorType: 0, mErrorStr: vsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // fs error
                                    else if (!mGL.getShaderParameter(fs, mGL.COMPILE_STATUS))
                                    {
                                        let fsLog = mGL.getShaderInfoLog(fs);
                                        onResolve(false, { mErrorType: 1, mErrorStr: fsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // link error
                                    else
                                    {
                                        let infoLog = mGL.getProgramInfoLog(pr);
                                        onResolve(false, { mErrorType: 2, mErrorStr: infoLog });
                                        mGL.deleteProgram(pr);
                                    }
                                }
                                // no errors
                                else
                                {
                                    let compilationTime = getRealTime() - timeStart;
                                    onResolve(true, { mProgram: pr, mTime: compilationTime });
                                }
                            };

                            // check compilation
                            if (mAsynchCompile === null || forceSynch===true )
                            {
                                checkErrors();
                            }
                            else
                            {
                                let loopCheckCompletion = function ()
                                {
                                    if( mGL.getProgramParameter(pr, mAsynchCompile.COMPLETION_STATUS_KHR) === true )
                                        checkErrors();
                                    else
                                        setTimeout(loopCheckCompletion, 10);
                                };
                                setTimeout(loopCheckCompletion, 10);
                            }
                        };

        me.AttachShader = function( shader )
                          {
                                if( shader===null )
                                {
                                    mBindedShader = null;
                                    mGL.useProgram( null );
                                }
                                else
                                {
                                    mBindedShader = shader;
                                    mGL.useProgram(shader.mProgram);
                                }
                          };

        me.DetachShader = function ()
                        {
                            mGL.useProgram(null);
                        };

        me.DestroyShader = function( tex )
                        {
                            mGL.deleteProgram(tex.mProgram);
                        };

        me.GetAttribLocation = function (shader, name)
                        {
                            return mGL.getAttribLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantLocation = function (shader, name)
                        {
                            return mGL.getUniformLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantMat4F = function( uname, params, istranspose )
                        {
                            var program = mBindedShader;

                            let pos = mGL.getUniformLocation( program.mProgram, uname );
                            if( pos===null )
                                return false;

                            if( istranspose===false )
                            {
                                var tmp = new Float32Array( [ params[0], params[4], params[ 8], params[12],
                                                              params[1], params[5], params[ 9], params[13],
                                                              params[2], params[6], params[10], params[14],
                                                              params[3], params[7], params[11], params[15] ] );
	                            mGL.uniformMatrix4fv(pos,false,tmp);
                            }
                            else
                                mGL.uniformMatrix4fv(pos,false,new Float32Array(params) );
                            return true;
                        };

        me.SetShaderConstant1F_Pos = function(pos, x)
                        {
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1FV_Pos = function(pos, x)
                        {
                            mGL.uniform1fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant1F = function( uname, x )
                        {
                            var pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1I = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1i(pos, x);
                            return true;
                        };
        me.SetShaderConstant1I_Pos = function(pos, x)
                        {
                            mGL.uniform1i(pos, x);
                            return true;
                        };


        me.SetShaderConstant2F = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform2fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant3F = function(uname, x, y, z)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform3f(pos, x, y, z);
                            return true;
                        };

        me.SetShaderConstant1FV = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1fv(pos, new Float32Array(x));
                            return true;
                        };

        me.SetShaderConstant3FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform3fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderConstant4FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform4fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderTextureUnit = function( uname, unit )
                        {
                            var program = mBindedShader;
                            let pos = mGL.getUniformLocation(program.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform1i(pos, unit);
                            return true;
                        };

        me.CreateVertexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, id);
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.CreateIndexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, id );
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.DestroyArray = function( tex )
                        {
                            mGL.destroyBuffer(tex.mObject);
                        };

        me.AttachVertexArray = function( tex, attribs, pos )
                        {
                            let shader = mBindedShader;

                            mGL.bindBuffer( mGL.ARRAY_BUFFER, tex.mObject);

                            var num = attribs.mChannels.length;
                            var stride = attribs.mStride;

                            var offset = 0;
                            for (var i = 0; i < num; i++)
                            {
                                var id = pos[i];
                                mGL.enableVertexAttribArray(id);
                                var dtype = mGL.FLOAT;
                                var dsize = 4;
                                     if( attribs.mChannels[i].mType === me.TYPE.UINT8   ) { dtype = mGL.UNSIGNED_BYTE;  dsize = 1; }
                                else if( attribs.mChannels[i].mType === me.TYPE.UINT16  ) { dtype = mGL.UNSIGNED_SHORT; dsize = 2; }
                                else if( attribs.mChannels[i].mType === me.TYPE.FLOAT32 ) { dtype = mGL.FLOAT;          dsize = 4; }
                                mGL.vertexAttribPointer(id, attribs.mChannels[i].mNumComponents, dtype, attribs.mChannels[i].mNormalize, stride, offset);
                                offset += attribs.mChannels[i].mNumComponents * dsize;
                            }
                        };

        me.AttachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, tex.mObject);
                        };

        me.DetachVertexArray = function (tex, attribs)
                        {
                            let num = attribs.mChannels.length;
                            for (let i = 0; i < num; i++)
                                mGL.disableVertexAttribArray(i);
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, null);
                        };

        me.DetachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, null);
                        };

        me.DrawPrimitive = function( typeOfPrimitive, num, useIndexArray, numInstances )
                        {
                            let glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.POINTS ) glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.LINES ) glType = mGL.LINES;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_LOOP ) glType = mGL.LINE_LOOP;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_STRIP ) glType = mGL.LINE_STRIP;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLES ) glType = mGL.TRIANGLES;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLE_STRIP ) glType = mGL.TRIANGLE_STRIP;

                            if( numInstances<=1 )
                            {
  	                            if( useIndexArray ) mGL.drawElements( glType, num, mGL.UNSIGNED_SHORT, 0 );
	                            else                mGL.drawArrays( glType, 0, num );
                            }
                            else
                            {
                                mGL.drawArraysInstanced(glType, 0, num, numInstances);
                                mGL.drawElementsInstanced( glType, num, mGL.UNSIGNED_SHORT, 0, numInstances);
                            }
                        };


        me.DrawFullScreenTriangle_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 3 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };


        me.DrawUnitQuad_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 6 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };

        me.DrawUnitCube_XYZ_NOR = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                            mGL.vertexAttribPointer( vpos[0], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.vertexAttribPointer( vpos[1], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos[0] );
                            mGL.enableVertexAttribArray( vpos[1] );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos[0] );
                            mGL.disableVertexAttribArray( vpos[1] );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.DrawUnitCube_XYZ = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                            mGL.vertexAttribPointer( vpos, 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.SetBlend = function( enabled )
                    {
                        if( enabled )
                        {
                            mGL.enable( mGL.BLEND );
                            mGL.blendEquationSeparate( mGL.FUNC_ADD, mGL.FUNC_ADD );
                            mGL.blendFuncSeparate( mGL.SRC_ALPHA, mGL.ONE_MINUS_SRC_ALPHA, mGL.ONE, mGL.ONE_MINUS_SRC_ALPHA );
                        }
                        else
                        {
                            mGL.disable( mGL.BLEND );
                        }
                    };

        me.GetPixelData = function( data, offset, xres, yres )
                        {
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.UNSIGNED_BYTE, data, offset);
                        };

        me.GetPixelDataRenderTarget = function( obj, data, xres, yres )
                        {
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, obj.mObjectID);
                            mGL.readBuffer(mGL.COLOR_ATTACHMENT0);
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.FLOAT, data, 0);
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                        };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piShading
//
//==============================================================================

function smoothstep(a, b, x)
{
    x = (x - a) / (b - a);
    if (x < 0) x = 0; else if (x > 1) x = 1;
    return x * x * (3.0 - 2.0 * x);
}

function clamp01(x)
{
    if( x < 0.0 ) x = 0.0;
    if( x > 1.0 ) x = 1.0;
    return x;
}

function clamp(x, a, b)
{
    if( x < a ) x = a;
    if( x > b ) x = b;
    return x;
}

function screen(a, b)
{
    return 1.0 - (1.0 - a) * (1.0 - b);
}

function parabola(x)
{
    return 4.0 * x * (1.0 - x);
}

function min(a, b)
{
    return (a < b) ? a : b;
}

function max(a, b)
{
    return (a > b) ? a : b;
}

function noise( x )
{
    function grad(i, j, x, y)
    {
        var h = 7 * i + 131 * j;
        h = (h << 13) ^ h;
        h = (h * (h * h * 15731 + 789221) + 1376312589);

        var rx = (h & 0x20000000) ? x : -x;
        var ry = (h & 0x10000000) ? y : -y;

        return rx + ry;
    }

    var i = [ Math.floor(x[0]), Math.floor(x[1]) ];
    var f = [ x[0] - i[0], x[1] - i[1] ];
    var w = [ f[0]*f[0]*(3.0-2.0*f[0]), f[1]*f[1]*(3.0-2.0*f[1]) ];

    var a = grad( i[0]+0, i[1]+0, f[0]+0.0, f[1]+0.0 );
    var b = grad( i[0]+1, i[1]+0, f[0]-1.0, f[1]+0.0 );
    var c = grad( i[0]+0, i[1]+1, f[0]+0.0, f[1]-1.0 );
    var d = grad( i[0]+1, i[1]+1, f[0]-1.0, f[1]-1.0 );

    return a + (b-a)*w[0] + (c-a)*w[1] + (a-b-c+d)*w[0]*w[1];
}//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piVecTypes
//
//==============================================================================


function vec3( a, b, c )
{
    return [ a, b, c ];
}

function add( a, b )
{
    return [ a[0]+b[0], a[1]+b[1], a[2]+b[2] ];
}

function sub( a, b )
{
    return [ a[0]-b[0], a[1]-b[1], a[2]-b[2] ];
}

function mul( a, s ) 
{
    return [ a[0]*s, a[1]*s, a[2]*s ];
}

function cross( a, b )
{
    return [ a[1]*b[2] - a[2]*b[1],
             a[2]*b[0] - a[0]*b[2],
             a[0]*b[1] - a[1]*b[0] ];
}

function dot( a, b ) 
{
    return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
}

function normalize( v ) 
{
    var is = 1.0 / Math.sqrt( v[0]*v[0] + v[1]*v[1] + v[2]*v[2] );
    return [ v[0]*is, v[1]*is, v[2]*is ];
}

function createCirclePoint( cen, uuu, vvv, rad, s, t )
{
    return [ cen[0] + rad*(uuu[0]*s + vvv[0]*t),
             cen[1] + rad*(uuu[1]*s + vvv[1]*t),
             cen[2] + rad*(uuu[2]*s + vvv[2]*t) ];
}

function createTangent( a, b, c )
{
    var cb = normalize( [ c[0]-b[0], c[1]-b[1], c[2]-b[2] ] );
    var ba = normalize( [ b[0]-a[0], b[1]-a[1], b[2]-a[2] ] );
    return normalize( [ ba[0]+cb[0], ba[1]+cb[1], ba[2]+cb[2] ] );

}

//===================================

function vec4( a, b, c, d )
{
    return [ a, b, c, d ];
}

function getXYZ( v )
{
    return [ v[0], v[1], v[2] ];
}

//===================================

function setIdentity()
{
    return [ 1.0, 0.0, 0.0, 0.0,
             0.0, 1.0, 0.0, 0.0,
             0.0, 0.0, 1.0, 0.0,
             0.0, 0.0, 0.0, 1.0 ];
}

function setRotationX( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ 1.0,   0.0,   0.0, 0.0,
             0.0,  cost, -sint, 0.0, 
             0.0,  sint,  cost, 0.0,
             0.0,   0.0,   0.0, 1.0 ];
}

function setRotationY( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ cost, 0.0, -sint, 0.0,
              0.0, 1.0,   0.0, 0.0, 
             sint, 0.0,  cost, 0.0,
              0.0, 0.0,   0.0, 1.0 ];
}

function extractRotationEuler( m)
{
    var res = [];
    if (m[0] == 1.0)
    {
        res[0] = Math.atan2(m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;

    }
    else if (m[0] == -1.0)
    {
        res[0] = Math.atan2( m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;
    }
    else
    {
        res[0] = Math.atan2( -m[9], m[10]);
        res[1] = Math.atan2( m[8], Math.sqrt(m[9]*m[9] + m[10]*m[10]));
        res[2] = Math.atan2( m[4], m[0]);
    }
    return res;
}

function setFromQuaternion( q )
{
    var ww = q[3]*q[3];
    var xx = q[0]*q[0];
    var yy = q[1]*q[1];
    var zz = q[2]*q[2];

    return [ ww+xx-yy-zz,                   2.0*(q[0]*q[1] - q[3]*q[2]), 2.0*(q[0]*q[2] + q[3]*q[1]), 0.0,
               2.0*(q[0]*q[1] + q[3]*q[2]),   ww-xx+yy-zz,                 2.0*(q[1]*q[2] - q[3]*q[0]), 0.0,
               2.0*(q[0]*q[2] - q[3]*q[1]),   2.0*(q[1]*q[2] + q[3]*q[0]), ww-xx-yy+zz,                 0.0,
               0.0,                           0.0,                         0.0,                         1.0 ];
}

function setPerspective( fovy, aspect, znear, zfar )
{
    var tan = Math.tan(fovy * Math.PI/180.0);
    var x = 1.0 / (tan*aspect);
    var y = 1.0 / (tan);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0 * zfar * znear) / (zfar - znear);

    return [ x,    0.0,  0.0,  0.0,
             0.0,  y,    0.0,  0.0,
             0.0,  0.0,  c,     d,
             0.0,  0.0, -1.0,  0.0 ];
}

function setLookAt( eye, tar, up )
{
    var dir = [ -tar[0]+eye[0], -tar[1]+eye[1], -tar[2]+eye[2] ];

	var m00 = dir[2]*up[1] - dir[1]*up[2]; 
    var m01 = dir[0]*up[2] - dir[2]*up[0];
    var m02 = dir[1]*up[0] - dir[0]*up[1];
    var im = 1.0/Math.sqrt( m00*m00 + m01*m01 + m02*m02 );
    m00 *= im;
    m01 *= im;
    m02 *= im;

	var m04 = m02*dir[1] - m01*dir[2]; 
    var m05 = m00*dir[2] - m02*dir[0];
    var m06 = m01*dir[0] - m00*dir[1];
    im = 1.0/Math.sqrt( m04*m04 + m05*m05 + m06*m06 );
    m04 *= im;
    m05 *= im;
    m06 *= im;

	var m08 = dir[0];
	var m09 = dir[1];
	var m10 = dir[2];
    im = 1.0/Math.sqrt( m08*m08 + m09*m09 + m10*m10 );
    m08 *= im;
    m09 *= im;
    m10 *= im;

	var m03 = -(m00*eye[0] + m01*eye[1] + m02*eye[2] );
	var m07 = -(m04*eye[0] + m05*eye[1] + m06*eye[2] );
	var m11 = -(m08*eye[0] + m09*eye[1] + m10*eye[2] );

    return [ m00, m01, m02, m03,
             m04, m05, m06, m07,
             m08, m09, m10, m11,
             0.0, 0.0, 0.0, 1.0 ];
}


function setOrtho( left, right, bottom, top, znear, zfar )
{
   var x = 2.0 / (right - left);
   var y = 2.0 / (top - bottom);
   var a = (right + left) / (right - left);
   var b = (top + bottom) / (top - bottom);
   var c = -2.0 / (zfar - znear);
   var d = -(zfar + znear) / ( zfar - znear);

   return [  x, 0.0, 0.0,   a,
           0.0,   y, 0.0,   b,
           0.0, 0.0,   c,   d,
           0.0, 0.0, 0.0, 1.0 ];
}

function setTranslation( p )
{
    return [ 1.0, 0.0, 0.0, p[0],
             0.0, 1.0, 0.0, p[1],
             0.0, 0.0, 1.0, p[2],
             0.0, 0.0, 0.0, 1.0 ];
}

function setScale( s )
{
    return [ s[0], 0.0,  0.0,  0.0,
             0.0,  s[1], 0.0,  0.0,
             0.0,  0.0,  s[2], 0.0,
             0.0,  0.0,  0.0,  1.0];
}

function setProjection( fov, znear, zfar )
{
    var x = 2.0 / (fov[3]+fov[2]);
    var y = 2.0 / (fov[0]+fov[1]);
    var a = (fov[3]-fov[2]) / (fov[3]+fov[2]);
    var b = (fov[0]-fov[1]) / (fov[0]+fov[1]);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0*zfar*znear) / (zfar - znear);
    return [   x, 0.0,    a, 0.0,
             0.0,   y,    b, 0.0,
             0.0, 0.0,    c,   d,
             0.0, 0.0, -1.0, 0.0 ];
   // inverse is:
   //return mat4x4( 1.0/x, 0.0f,  0.0f,   a/x,
   //               0.0f,  1.0/y, 0.0f,   b/x,
   //               0.0f,  0.0f,  0.0f,   -1.0,
   //               0.0f,  0.0f,  1.0f/d, c/d );
}


function invertFast( m )
{
    var inv = [
   
             m[5]  * m[10] * m[15] - 
             m[5]  * m[11] * m[14] - 
             m[9]  * m[6]  * m[15] + 
             m[9]  * m[7]  * m[14] +
             m[13] * m[6]  * m[11] - 
             m[13] * m[7]  * m[10],

             -m[1]  * m[10] * m[15] + 
              m[1]  * m[11] * m[14] + 
              m[9]  * m[2] * m[15] - 
              m[9]  * m[3] * m[14] - 
              m[13] * m[2] * m[11] + 
              m[13] * m[3] * m[10],

             m[1]  * m[6] * m[15] - 
             m[1]  * m[7] * m[14] - 
             m[5]  * m[2] * m[15] + 
             m[5]  * m[3] * m[14] + 
             m[13] * m[2] * m[7] - 
             m[13] * m[3] * m[6],

             -m[1] * m[6] * m[11] + 
              m[1] * m[7] * m[10] + 
              m[5] * m[2] * m[11] - 
              m[5] * m[3] * m[10] - 
              m[9] * m[2] * m[7] + 
              m[9] * m[3] * m[6],

             -m[4]  * m[10] * m[15] + 
              m[4]  * m[11] * m[14] + 
              m[8]  * m[6]  * m[15] - 
              m[8]  * m[7]  * m[14] - 
              m[12] * m[6]  * m[11] + 
              m[12] * m[7]  * m[10],

             m[0]  * m[10] * m[15] - 
             m[0]  * m[11] * m[14] - 
             m[8]  * m[2] * m[15] + 
             m[8]  * m[3] * m[14] + 
             m[12] * m[2] * m[11] - 
             m[12] * m[3] * m[10],

             -m[0]  * m[6] * m[15] + 
              m[0]  * m[7] * m[14] + 
              m[4]  * m[2] * m[15] - 
              m[4]  * m[3] * m[14] - 
              m[12] * m[2] * m[7] + 
              m[12] * m[3] * m[6],


             m[0] * m[6] * m[11] - 
             m[0] * m[7] * m[10] - 
             m[4] * m[2] * m[11] + 
             m[4] * m[3] * m[10] + 
             m[8] * m[2] * m[7] - 
             m[8] * m[3] * m[6],


             m[4]  * m[9] * m[15] - 
             m[4]  * m[11] * m[13] - 
             m[8]  * m[5] * m[15] + 
             m[8]  * m[7] * m[13] + 
             m[12] * m[5] * m[11] - 
             m[12] * m[7] * m[9],



             -m[0]  * m[9] * m[15] + 
              m[0]  * m[11] * m[13] + 
              m[8]  * m[1] * m[15] - 
              m[8]  * m[3] * m[13] - 
              m[12] * m[1] * m[11] + 
              m[12] * m[3] * m[9],

              m[0]  * m[5] * m[15] - 
              m[0]  * m[7] * m[13] - 
              m[4]  * m[1] * m[15] + 
              m[4]  * m[3] * m[13] + 
              m[12] * m[1] * m[7] - 
              m[12] * m[3] * m[5],

              -m[0] * m[5] * m[11] + 
               m[0] * m[7] * m[9] + 
               m[4] * m[1] * m[11] - 
               m[4] * m[3] * m[9] - 
               m[8] * m[1] * m[7] + 
               m[8] * m[3] * m[5],

              -m[4]  * m[9] * m[14] + 
               m[4]  * m[10] * m[13] +
               m[8]  * m[5] * m[14] - 
               m[8]  * m[6] * m[13] - 
               m[12] * m[5] * m[10] + 
               m[12] * m[6] * m[9],

              m[0]  * m[9] * m[14] - 
              m[0]  * m[10] * m[13] - 
              m[8]  * m[1] * m[14] + 
              m[8]  * m[2] * m[13] + 
              m[12] * m[1] * m[10] - 
              m[12] * m[2] * m[9],

              -m[0]  * m[5] * m[14] + 
               m[0]  * m[6] * m[13] + 
               m[4]  * m[1] * m[14] - 
               m[4]  * m[2] * m[13] - 
               m[12] * m[1] * m[6] + 
               m[12] * m[2] * m[5],

              m[0] * m[5] * m[10] - 
              m[0] * m[6] * m[9] - 
              m[4] * m[1] * m[10] + 
              m[4] * m[2] * m[9] + 
              m[8] * m[1] * m[6] - 
              m[8] * m[2] * m[5] ];

    var det = m[0] * inv[0] + m[1] * inv[4] + m[2] * inv[8] + m[3] * inv[12];

    det = 1.0/det;

    for( var i = 0; i<16; i++ ) inv[i] = inv[i] * det;

    return inv;
}

function matMul( a, b )
{
    var res = [];
    for( var i=0; i<4; i++ )
    {
        var x = a[4*i+0];
        var y = a[4*i+1];
        var z = a[4*i+2];
        var w = a[4*i+3];

        res[4*i+0] = x * b[ 0] + y * b[ 4] + z * b[ 8] + w * b[12];
        res[4*i+1] = x * b[ 1] + y * b[ 5] + z * b[ 9] + w * b[13];
        res[4*i+2] = x * b[ 2] + y * b[ 6] + z * b[10] + w * b[14];
        res[4*i+3] = x * b[ 3] + y * b[ 7] + z * b[11] + w * b[15];
    }

    return res;
}

function matMulpoint( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2] + m[ 3],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2] + m[ 7],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] + m[11] ];
}

function matMulvec( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] ];
}


function bound3( infi )
{
    return [ infi, -infi, infi, -infi, infi, -infi ];
}

function bound3_include( a, p )
{
    return [
        (p[0]<a[0]) ? p[0] : a[0],
        (p[0]>a[1]) ? p[0] : a[1],
        (p[1]<a[2]) ? p[1] : a[2],
        (p[1]>a[3]) ? p[1] : a[3],
        (p[2]<a[4]) ? p[2] : a[4],
        (p[2]>a[5]) ? p[2] : a[5] ];
}

function bound3_center( b )
{
    return [ 0.5*(b[0]+b[1]),
             0.5*(b[2]+b[3]),
             0.5*(b[4]+b[5]) ];
}

function bound3_radius( b )
{
    return [ 0.5*(b[1]-b[0]),
             0.5*(b[3]-b[2]),
             0.5*(b[5]-b[4]) ];
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebVR
//
//==============================================================================

function WebVR( isVREnabledCallback, canvasElement )
{
    isVREnabledCallback(false);
    /*


    this.mSupportVR = false;
    this.mHMD = null;

    var me = this;
    var listVRDisplays = function (vrdevs) {
        for (var i = 0; i < vrdevs.length; i++)
        {
            if (vrdevs[i] instanceof VRDisplay)
            {
                me.mHMD = vrdevs[i];
                console.log("WebVR is available.");
                console.log(me.mHMD);
                break;
            }
        }

        isVREnabledCallback(true);
        me.mSupportVR = true;
    }

    if (navigator.getVRDisplays)
    {
        navigator.getVRDisplays().then(listVRDisplays);
    }

    isVREnabledCallback(false);
    this.mCanvas = canvasElement;
    */
}

WebVR.prototype.IsSupported = function()
{
    return false;
    //return this.mSupportVR;
}

WebVR.prototype.GetData = function( id )
{
    return {};
    /*
    var frameData = new VRFrameData();
    var s = this.mHMD.getFrameData(frameData);
    var ss = frameData.pose;
    
    var fovL = this.mHMD.getEyeParameters("left");
    var fovR = this.mHMD.getEyeParameters( "right" );

    // camera info
    var cPos = vec3(0.0, 0.0, 0.0);
    if (ss.position)
        cPos = vec3(-ss.position[0], -ss.position[1], -ss.position[2]);
    var rot = vec4(0.0, 0.0, 0.0, 0.0);
    if (ss.orientation)
        rot = vec4(ss.orientation[0], ss.orientation[1], ss.orientation[2], ss.orientation[3]);
    var cRot = setFromQuaternion(rot);
    var cTra = setTranslation(cPos);
    var cMat = matMul(invertFast(cRot), cTra);
    
    // per eye info
    var lTra = setTranslation( vec3(-fovL.offset[0], -fovL.offset[1], -fovL.offset[2]) );
    var lMat = matMul(lTra, cMat);
    var lPrj = [ Math.tan( fovL.fieldOfView.upDegrees * Math.PI/180.0),
                 Math.tan(fovL.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.rightDegrees * Math.PI / 180.0)];

    var rTra = setTranslation(vec3(-fovR.offset[0], -fovR.offset[1], -fovR.offset[2]));
    var rMat = matMul(rTra, cMat);
    var rPrj = [Math.tan(fovR.fieldOfView.upDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.rightDegrees * Math.PI / 180.0)];

    return {
        mCamera   : { mCamera: cMat },
        mLeftEye  : { mVP:[0,0,fovL.renderWidth,fovL.renderHeight], mProjection:lPrj, mCamera:lMat },
        mRightEye : { mVP:[fovR.renderWidth/2,0,fovR.renderWidth,fovR.renderHeight], mProjection:rPrj, mCamera:rMat }
           };
    */
}

WebVR.prototype.Enable = function( id )
{
    /*
    this.mHMD.requestPresent([{ source: this.mCanvas }]).then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : requestPresent failed.");
        }
    );
    */
}

WebVR.prototype.Disable = function( id )
{
    /*
    if (!this.mHMD.isPresenting)
    {
        return;
    }

    this.mHMD.exitPresent().then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : exitPresent failed.");
        }
    );
    */
}

WebVR.prototype.RequestAnimationFrame = function (id)
{
    //this.mHMD.requestAnimationFrame(id);
}

WebVR.prototype.IsPresenting = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        return true;
    }
    */
    return false;
}

WebVR.prototype.Finish = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        this.mHMD.submitFrame();
    }
    */
}

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebUtils
//
//==============================================================================


// RequestAnimationFrame
window.requestAnimFrame = ( function () { return window.requestAnimationFrame    || window.webkitRequestAnimationFrame ||
                                                 window.mozRequestAnimationFrame || window.oRequestAnimationFrame ||
                                                 window.msRequestAnimationFrame  || function( cb ) { window.setTimeout(cb,1000/60); };
                                        } )();

// performance.now
window.getRealTime = ( function() { if ("performance" in window ) return function() { return window.performance.now(); }
                                                                  return function() { return (new Date()).getTime(); }
                                  } )();

window.URL = window.URL || window.webkitURL;

navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;

function htmlEntities(str) 
{
    return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g,'&apos;');
}

function piDisableTouch()
{
    document.body.addEventListener('touchstart', function(e){ e.preventDefault(); });
}

var piGetTime = function ( timestamp )
{
    if (timestamp == 0)
        return "";
    return new Date(timestamp * 1000).toISOString().substr(0, 10);
}

function piGetCoords( obj )
{
    var x = 0;
    var y = 0; 
    do
    {
         x += obj.offsetLeft;
         y += obj.offsetTop;
    }while( obj = obj.offsetParent );

    return { mX:x, mY:y };
}

function piGetMouseCoords( ev, canvasElement )
{
    var pos = piGetCoords(canvasElement );
    var mcx =                        (ev.pageX - pos.mX) * canvasElement.width / canvasElement.offsetWidth;
    var mcy = canvasElement.height - (ev.pageY - pos.mY) * canvasElement.height / canvasElement.offsetHeight;

    return { mX: mcx, mY: mcy };

}

function piGetSourceElement( e )
{
    var ele = null;
    if( e.target )     ele = e.target;
    if( e.srcElement ) ele = e.srcElement;
    return ele;
}

function piRequestFullScreen( ele )
{
    if( ele==null ) ele =   document.documentElement;
         if( ele.requestFullscreen       ) ele.requestFullscreen();
    else if( ele.msRequestFullscreen     ) ele.msRequestFullscreen();
    else if( ele.mozRequestFullScreen    ) ele.mozRequestFullScreen();
    else if( ele.webkitRequestFullscreen ) ele.webkitRequestFullscreen( Element.ALLOW_KEYBOARD_INPUT );
}

function piIsFullScreen()
{
    return document.fullscreen || document.mozFullScreen || document.webkitIsFullScreen || document.msFullscreenElement || false;
}

function piExitFullScreen()
{
       if( document.exitFullscreen       ) document.exitFullscreen();
  else if( document.msExitFullscreen     ) document.msExitFullscreen();
  else if( document.mozCancelFullScreen  ) document.mozCancelFullScreen();
  else if( document.webkitExitFullscreen ) document.webkitExitFullscreen();
}

function piIsMobile()
{
    return (navigator.userAgent.match(/Android/i) ||
            navigator.userAgent.match(/webOS/i) ||
            navigator.userAgent.match(/iPhone/i) ||
            navigator.userAgent.match(/iPad/i) ||
            navigator.userAgent.match(/iPod/i) ||
            navigator.userAgent.match(/BlackBerry/i) ||
            navigator.userAgent.match(/Windows Phone/i)) ? true : false;
}

function piCreateGlContext( cv, useAlpha, useDepth, usePreserveBuffer, useSupersampling )
{
    var opts = { alpha: useAlpha, 
                 depth: useDepth, 
                 stencil: false, 
                 premultipliedAlpha: false, 
                 antialias: useSupersampling, 
                 preserveDrawingBuffer: usePreserveBuffer, 
                 powerPreference: "high-performance" }; // "low_power", "high_performance", "default"

    var gl = null;
    if( gl === null) gl = cv.getContext( "webgl2", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl2", opts );
    if( gl === null) gl = cv.getContext( "webgl", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl", opts );

    return gl;
}

function piCreateAudioContext()
{
    var res = null;
    try
    {
        if( window.AudioContext ) res = new AudioContext();
        if( res==null && window.webkitAudioContext ) res = new webkitAudioContext();
    }
    catch( e )
    {
        res = null;
    }
    return res;
}

function piHexColorToRGB(str) // "#ff3041"
{
    var rgb = parseInt(str.slice(1), 16);
    var r = (rgb >> 16) & 255;
    var g = (rgb >> 8) & 255;
    var b = (rgb >> 0) & 255;
    return [r, g, b];
}

function piCreateFPSCounter()
{
    var mFrame;
    var mTo;
    var mFPS;

    var iReset = function( time )
    {
        mFrame = 0;
        mTo = time;
        mFPS = 60.0;
    }

    var iCount = function( time )
    {
        mFrame++;

        if( (time-mTo)>500.0 )
        {
            mFPS = 1000.0*mFrame/(time-mTo);
            mFrame = 0;
            mTo = time;
            return true;
        }
        return false;
    }

    var iGetFPS = function()
    {
        return mFPS;
    }
    
    return { Reset : iReset, Count : iCount, GetFPS : iGetFPS };
}

function piCanMediaRecorded(canvas)
{
    if (typeof window.MediaRecorder !== 'function' || typeof canvas.captureStream !== 'function') {
        return false;
    }
    return true;
}

function piCreateMediaRecorder(isRecordingCallback, canvas) 
{
    if (piCanMediaRecorded(canvas) == false)
    {
        return null;
    }
    
    var options = { audioBitsPerSecond : 0, videoBitsPerSecond : 8000000 }; 
	     if (MediaRecorder.isTypeSupported('video/webm;codecs=h264')) options.mimeType = 'video/webm;codecs=h264';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9' )) options.mimeType = 'video/webm;codecs=vp9';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8' )) options.mimeType = 'video/webm;codecs=vp8';
    else                                                              options.mimeType = 'video/webm;';

    var mediaRecorder = new MediaRecorder(canvas.captureStream(), options);
    var chunks = [];
    
    mediaRecorder.ondataavailable = function(e) 
    {
        if (e.data.size > 0) 
        {
            chunks.push(e.data);
        }
    };
 
    mediaRecorder.onstart = function(){ 
        isRecordingCallback( true );
    };
    
    mediaRecorder.onstop = function()
    {
         isRecordingCallback( false );
         let blob     = new Blob(chunks, {type: "video/webm"});
         chunks       = [];
         let videoURL = window.URL.createObjectURL(blob);
         let url      = window.URL.createObjectURL(blob);
         let a        = document.createElement("a");
         document.body.appendChild(a);
         a.style      = "display: none";
         a.href       = url;
         a.download   = "capture.webm";
         a.click();
         window.URL.revokeObjectURL(url);
     };
    
    return mediaRecorder;
}

function piExportToEXR(width, height, numComponents, type, bytes)
{
    var bytesPerComponent = 0;
    if      (type=="Uint")   bytesPerComponent = 4; 
    else if (type=="Half")   bytesPerComponent = 2;
    else if (type=="Float")  bytesPerComponent = 4;

    var tHeader = 258 + (18 * numComponents + 1);
    var tTable = 8 * height;
    var tScanlines = height * (4 + 4 + (numComponents * bytesPerComponent * width));
    var tTotal = tHeader + tTable + tScanlines;

    //console.log("    header size = " + tHeader);
    //console.log("    table size = " + tTable);
    //console.log("    scanlines size = " + tScanlines);
    //console.log("    total = " + tTotal);

    var buffer = new ArrayBuffer(tTotal); 
    var data = new DataView(buffer);

    // Header
    {
        // Header : 4 bytes -> 0x76, 0x2f, 0x31, 0x01
        var c = 0;
        data.setUint8 (c++, 0x76);
        data.setUint8 (c++, 0x2f);
        data.setUint8 (c++, 0x31);
        data.setUint8 (c++, 0x01);

        // Version : 4 bytes -> 2, 0, 0, 0
        data.setUint8 (c++, 0x02);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        
        // Write channel info
        // Write attribute name : "channels"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x73);
            data.setUint8 (c++, 0x0);

            // Write attribute type : "chlist"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : 18 x 3 + 1 = 55
            var attribSize = 18 * numComponents + 1;
            data.setUint8 (c++, attribSize); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            var i;
            for (i = 0; i < numComponents; i++)
            {
                // Attribute : "B" (42) "G" (47) "R" (52)
                if (i==0)       data.setUint8 (c++, 0x42);
                else if (i==1)  data.setUint8 (c++, 0x47);
                else if (i==2)  data.setUint8 (c++, 0x52);
                data.setUint8 (c++, 0x00);
                
                // Value : Float (2), Half (1), Uint (0)
                if      (type=="Uint")   data.setUint8 (c++, 0x00); 
                else if (type=="Half")   data.setUint8 (c++, 0x01);
                else if (type=="Float")  data.setUint8 (c++, 0x02);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);

                // Plinear
                data.setUint8 (c++, 0x01);

                // Reserved
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 

                // X sampling
                data.setUint8 (c++, 0x01); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                
                // Y sampling
                data.setUint8 (c++, 0x01);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
            }
            // End attribute
            data.setUint8 (c++, 0x00);
    
        // Write attribute name : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute type : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : "1"
            data.setUint8 (c++, 0x01); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // Write attribute value : "0" (None)
            data.setUint8 (c++, 0x00);

        // datawindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00); 

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00);

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 

            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // displayWindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x79); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00);

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00); 

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // size
            data.setUint8 (c++, 0x01);
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);
            
            // value 
            data.setUint8 (c++, 0x00);

        // PixelAspectRatio
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x41); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x52); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x00); 

            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);
        
            // size 4
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 1.0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);
        
        // screenWindowCenter
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63);
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x43); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e);
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00);

            // v2f
            data.setUint8 (c++, 0x76); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x00);

            // size 8
            data.setUint8 (c++, 0x08); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

        // screenWindowWidth
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x00); 
            
            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00); 

            // size
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);

            // value
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);

        // End of header
        data.setUint8 (c++, 0x00);
    }
    //console.log("header size = " + c);

    // Scanline table
    var initc = c + height * 8;
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        var jump = initc + scanline * (8 + width * bytesPerComponent * numComponents); 
        data.setUint32 (c, jump, true);
        c += 4; 

        data.setUint32 (c, 0x00, true);
        c += 4;
    }
    //console.log("header + scanlines table size = " + c);

    // Scanlines
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        // Scanline
        data.setUint32(c, scanline, true);
        c += 4;

        // size 24
        var size = width * numComponents * bytesPerComponent; 
        data.setUint32(c, size, true);
        c += 4;

        var numComponentsSource = 4; // number of components in the SOURCE image
        for (var component = 0; component < numComponents ; component ++) 
        {
            for (var pixel = 0 ; pixel < width ; pixel ++) 
            {
                // flip vertical, so we read OpenGL buffers without JS image flipping
                var v = bytes[(height-1-scanline) * width *numComponentsSource + pixel * numComponentsSource + (2-component)];
                if      (type=="Float") data.setFloat32(c, v, true);
                else if (type=="Half")  data.setUint16(c, v, true);

                c += bytesPerComponent;
            }
        }
    }
    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}


function piExportToWAV(numSamples, rate, bits, numChannels, words)
{
    let numBytes = numSamples * numChannels * bits/8;

    let buffer = new ArrayBuffer(44 + numBytes); 
    let data = new DataView(buffer);

    {
        data.setUint32( 0, 0x46464952, true );  // RIFF
        data.setUint32( 4, numBytes + 36, true);
        {
            data.setUint32( 8, 0x45564157, true );  // WAV_WAVE
            data.setUint32( 12, 0x20746D66, true );  // WAV_FMT
            {
                data.setUint32( 16, 16, true);
                data.setUint16( 20, 1, true ); // WAV_FORMAT_PCM
                data.setUint16( 22, numChannels, true);
                data.setUint32( 24, rate, true);
                data.setUint32( 28, rate*numChannels*bits / 8, true);
                data.setUint16( 32, numChannels*bits / 8, true);
                data.setUint16( 34, bits, true);
            }

            data.setUint32( 36, 0x61746164, true);  // WAV_DATA
            {
                data.setUint32( 40, numBytes, true);
                let numWords = numSamples * numChannels;
                for(let i=0; i<numWords; i++ )
                {
                    data.setInt16( 44 + i*2, words[i], true );
                }
            }
        }
    }


    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}

function piTriggerDownload(name, blob)
{
    let url = URL.createObjectURL(blob);
    let aElement = document.createElement("a");
    aElement.href     = url;
    aElement.target   = "_self";
    aElement.download = name;
    document.body.appendChild(aElement);
    aElement.click();
    document.body.removeChild(aElement);
}</script>
    <script>"use strict"

function bufferID_to_assetID( id )
{
    if( id===0 ) return '4dXGR8';
    if( id===1 ) return 'XsXGR8';
    if( id===2 ) return '4sXGR8';
    if( id===3 ) return 'XdfGR8';
    return 'none';
}
function assetID_to_bufferID( id )
{
    if( id==='4dXGR8' ) return 0;
    if( id==='XsXGR8' ) return 1;
    if( id==='4sXGR8' ) return 2;
    if( id==='XdfGR8' ) return 3;
    return -1;
}

function assetID_to_cubemapBuferID( id )
{
    if( id==='4dX3Rr' ) return 0;
    return -1;
}
function cubamepBufferID_to_assetID( id )
{
    if( id===0 ) return '4dX3Rr';
    return 'none';
}

function EffectPass( renderer, is20, isLowEnd, hasShaderTextureLOD, callback, obj, forceMuted, forcePaused, outputGainNode, copyProgram, id, effect  )
{
    this.mID = id;
    this.mInputs  = [null, null, null, null ];
    this.mOutputs = [null, null, null, null ];
    this.mSource = null;

    this.mGainNode = outputGainNode;
    this.mSoundShaderCompiled = false;

    this.mEffect = effect;
    this.mRenderer = renderer;
    this.mProgramCopy = copyProgram; 
    this.mCompilationTime = 0;

    this.mType = "none";
    this.mName = "none";
    this.mFrame = 0;

    this.mShaderTextureLOD = hasShaderTextureLOD;
    this.mIs20 = is20;
    this.mIsLowEnd = isLowEnd;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mForceMuted = forceMuted;
    this.mForcePaused = forcePaused;
}

EffectPass.prototype.MakeHeader_Image = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        // old API
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                   header += "uniform sampler2D iChannel" + i + ";\n";

        // new API (see shadertoy.com/view/wtdGW8)
        header += "uniform struct {\n";
             if( inp===null )                  header += "  sampler2D";
        else if( inp.mInfo.mType==="cubemap" ) header += "  samplerCube";
        else if( inp.mInfo.mType==="volume"  ) header += "  sampler3D";
        else                                  header += "  sampler2D";
        header +=        " sampler;\n";
        header += "  vec3  size;\n";
        header += "  float time;\n";
        header += "  int   loaded;\n";
        header += "}iCh" + i + ";\n";
    }
	header += "void mainImage( out vec4 c, in vec2 f );\n";
    header += "void st_assert( bool cond );\n";
    header += "void st_assert( bool cond, int v );\n";

    if( this.mIs20 ) 
    {
        header += "\nout vec4 shadertoy_out_color;\n" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)shadertoy_out_color.x=-1.0;else if(v==1)shadertoy_out_color.y=-1.0;else if(v==2)shadertoy_out_color.z=-1.0;else shadertoy_out_color.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)shadertoy_out_color.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "shadertoy_out_color = vec4(1.0,1.0,1.0,1.0);" + 
            "vec4 color = vec4(1e20);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "if(shadertoy_out_color.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(shadertoy_out_color.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(shadertoy_out_color.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(shadertoy_out_color.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "shadertoy_out_color = vec4(color.xyz,1.0);" +
        "}";
    }
    else
    {
        header += "" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)gl_FragColor.x=-1.0;else if(v==1)gl_FragColor.y=-1.0;else if(v==2)gl_FragColor.z=-1.0;else gl_FragColor.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)gl_FragColor.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "gl_FragColor = vec4(0.0,0.0,0.0,1.0);" + 
            "vec4 color = vec4(1e20);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "color.w = 1.0;" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(gl_FragColor.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "gl_FragColor = vec4(color.xyz,1.0);"+
        "}";
    }
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 ) 
        this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "void main( void )" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );" +
        "color.w = 1.0;"
    if( this.mIs20 ) 
        this.mImagePassFooterVR +=  "outColor = color;}";
    else
        this.mImagePassFooterVR +=  "gl_FragColor = color;}";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Buffer = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                  header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainImage( out vec4 c,  in vec2 f );\n"

    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +
        "mainImage( color, gl_FragCoord.xy );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
    this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        this.mImagePassFooterVR +="outColor = color; }";
    else
        this.mImagePassFooterVR +="gl_FragColor = color; }";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Cubemap = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                   header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainCubemap( out vec4 c, in vec2 f, in vec3 ro, in vec3 rd );\n"

    header += "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainCubemap( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Sound = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform float     iChannelTime[4];\n" +
              "uniform float     iTimeOffset;\n" +
              "uniform int       iSampleOffset;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n";

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp!==null && inp.mInfo.mType==="cubemap" )
            header += "uniform samplerCube iChannel" + i + ";\n";
        else
            header += "uniform sampler2D iChannel" + i + ";\n";
    }
    header += "\n";
    header += "vec2 mainSound( in int samp, float time );\n";

    if( this.mIs20 )
    {
        header += "out vec4 outColor; void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "int   s = iSampleOffset + int(gl_FragCoord.y-0.2)*512 + int(gl_FragCoord.x-0.2);" +
            "vec2 y = mainSound( s, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "outColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    else
    {
        header += "void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "vec2 y = mainSound( 0, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "gl_FragColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    header += "\n";
    this.mHeader = header;
    this.mHeaderLength = 0;
}


EffectPass.prototype.MakeHeader_Common = function ()
{
    let header = "";
    let headerlength = 0;

    header += "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n";
    headerlength += 2;

    if (this.mIs20)
    {
        header += "out vec4 outColor;\n";
        headerlength += 1;
    }
    header += "void main( void )\n";
    headerlength += 1;

    if (this.mIs20)
        header += "{ outColor = vec4(0.0); }";
    else
        header += "{ gl_FragColor = vec4(0.0); }";
    headerlength += 1;
    header += "\n";
    headerlength += 1;

    this.mHeader = header;
    this.mHeaderLength = headerlength;
}

EffectPass.prototype.MakeHeader = function()
{
         if( this.mType==="image" ) this.MakeHeader_Image();
    else if( this.mType==="sound" ) this.MakeHeader_Sound();
    else if( this.mType==="buffer") this.MakeHeader_Buffer();
    else if( this.mType==="common") this.MakeHeader_Common();
    else if( this.mType==="cubemap") this.MakeHeader_Cubemap();
    else console.log("ERROR 4");
}

EffectPass.prototype.Create_Image = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}
EffectPass.prototype.Destroy_Image = function( wa )
{
}

EffectPass.prototype.Create_Buffer = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}

EffectPass.prototype.Destroy_Buffer = function( wa )
{
}

EffectPass.prototype.Create_Cubemap = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
}

EffectPass.prototype.Destroy_Cubemap = function( wa )
{
}

EffectPass.prototype.Create_Common = function( wa )
{
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.MakeHeader();
}
EffectPass.prototype.Destroy_Common = function( wa )
{
}

EffectPass.prototype.Create_Sound = function (wa)
{
    this.MakeHeader();

    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    this.mSampleRate = 44100;
    this.mPlayTime = 60*3;
    this.mPlaySamples = this.mPlayTime*this.mSampleRate;
    this.mBuffer = wa.createBuffer( 2, this.mPlaySamples, this.mSampleRate );

    //-------------------
    this.mTextureDimensions = 512;
    this.mRenderTexture = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D, 
                                                       this.mTextureDimensions, this.mTextureDimensions,
                                                       this.mRenderer.TEXFMT.C4I8,
                                                       this.mRenderer.FILTER.NONE,
                                                       this.mRenderer.TEXWRP.CLAMP, null);
    this.mRenderFBO = this.mRenderer.CreateRenderTarget(this.mRenderTexture, null, null, null, null, false);

    //-----------------------------

    // ArrayBufferView pixels;
    this.mTmpBufferSamples = this.mTextureDimensions*this.mTextureDimensions;
    this.mData = new Uint8Array( this.mTmpBufferSamples*4 );

    this.mPlaying = false;
}

EffectPass.prototype.Destroy_Sound = function( wa )
{
    if( this.mPlayNode!==null ) this.mPlayNode.stop();
    this.mPlayNode = null;
    this.mBuffer = null;
    this.mData = null;

    this.mRenderer.DestroyRenderTarget(this.mRenderFBO);
    this.mRenderer.DestroyTexture(this.mRenderTexture);
}

EffectPass.prototype.Create = function( passType, wa )
{
    this.mType = passType;
    this.mSource = null;

         if( passType==="image" ) this.Create_Image( wa );
    else if( passType==="sound" ) this.Create_Sound( wa );
    else if( passType==="buffer") this.Create_Buffer( wa );
    else if( passType==="common") this.Create_Common( wa );
    else if( passType==="cubemap") this.Create_Cubemap( wa );
    else alert("ERROR 1");
}

EffectPass.prototype.SetName = function (passName)
{
    this.mName = passName;
}

EffectPass.prototype.SetCode = function (src)
{
    this.mSource = src;
}

EffectPass.prototype.Destroy = function( wa )
{
    this.mSource = null;
         if( this.mType==="image" ) this.Destroy_Image( wa );
    else if( this.mType==="sound" ) this.Destroy_Sound( wa );
    else if( this.mType==="buffer") this.Destroy_Buffer( wa );
    else if( this.mType==="common") this.Destroy_Common( wa );
    else if( this.mType==="cubemap") this.Destroy_Cubemap( wa );
    else alert("ERROR 2");
}

EffectPass.prototype.NewShader_Sound = function( shaderCode, commonShaderCodes)
{
    let vsSource = null;

    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for( let i=0; i<commonShaderCodes.length; i++ )
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    this.mSoundShaderCompiled = false;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader_Image = function ( shaderCode, commonShaderCodes )
{
    this.mSupportsVR = false;

    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    return [vsSource, fsSource];


    /*
    let n1 = shaderCode.indexOf("mainVR(");
    let n2 = shaderCode.indexOf("mainVR (");
    let n3 = shaderCode.indexOf("mainVR  (");
    if( n1>0 || n2>0 || n3>0 )
    {
        let vsSourceVR;
        if( this.mIs20 )
            vsSourceVR = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        else
            vsSourceVR = "attribute in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

        let fsSourceVR = this.mHeader;
        for (let i = 0; i < commonShaderCodes.length; i++) {
            fsSourceVR += commonShaderCodes[i];
        }
        fsSourceVR += shaderCode;
        fsSourceVR += this.mImagePassFooterVR;

        let res = this.mRenderer.CreateShader(vsSource, fsSourceVR, preventCache);
        if( res.mResult == false )
        {
            return res.mInfo;
        }
        if( this.mProgramVR != null )
            this.mRenderer.DestroyShader( this.mProgramVR );

        this.mSupportsVR = true;
        this.mProgramVR = res;
    }
    */
}

EffectPass.prototype.NewShader_Cubemap = function( shaderCode, commonShaderCodes )
{
    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }

    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;

    fsSource += shaderCode;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader_Common = function (shaderCode )
{
    let vsSource = null;
    if (this.mIs20)
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader + shaderCode;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader = function ( commonSourceCodes, preventCache, onResolve)
{
    if( this.mRenderer===null ) return;

    let vs_fs = null;

         if( this.mType==="sound"  ) vs_fs = this.NewShader_Sound(   this.mSource, commonSourceCodes );
    else if( this.mType==="image"  ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="buffer" ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="common" ) vs_fs = this.NewShader_Common(  this.mSource,                   );
    else if( this.mType==="cubemap") vs_fs = this.NewShader_Cubemap( this.mSource, commonSourceCodes );
    else { console.log("ERROR 3: \"" + this.mType + "\""); return; }

    let me = this;
    this.mRenderer.CreateShader(vs_fs[0], vs_fs[1], preventCache, false,
        function (worked, info)
        {
            if (worked === true)
            {
                if (me.mType === "sound")
                {
                    me.mSoundShaderCompiled = true;
                }

                me.mCompilationTime = info.mTime;
                me.mError = false;
                me.mErrorStr = "No Errors";
                if (me.mProgram !== null)
                    me.mRenderer.DestroyShader(me.mProgram);
                me.mTranslatedSource = me.mRenderer.GetTranslatedShaderSource(info);
                me.mProgram = info;
            }
            else
            {
                me.mError = true;
                me.mErrorStr = info.mErrorStr;
            }
            onResolve();
        });
}

EffectPass.prototype.DestroyInput = function( id )
{
    if( this.mInputs[id]===null ) return;

    if( this.mInputs[id].mInfo.mType==="texture" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    if( this.mInputs[id].mInfo.mType==="volume" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="webcam" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video.src = "";

        if( this.mInputs[id].video.srcObject!==null )
        {
        let tracks = this.mInputs[id].video.srcObject.getVideoTracks();
        if( tracks ) tracks[0].stop();
        }
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="video" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="music" || this.mInputs[id].mInfo.mType==="musicstream")
    {
        this.mInputs[id].audio.pause();
        this.mInputs[id].audio.mSound.mFreqData = null;
        this.mInputs[id].audio.mSound.mWaveData = null;
        this.mInputs[id].audio = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="cubemap" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="keyboard" )
    {
        //if( this.mInputs[id].globject != null )
          //  this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="mic" )
    {
        this.mInputs[id].mic = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }

    this.mInputs[id] = null;
}

EffectPass.prototype.TooglePauseInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        else
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.audio.mPaused )
        {
            if( inp.loaded )
            {
                inp.audio.play();
            }
            inp.audio.mPaused = false;
        }
        else
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }

    return null;
}

EffectPass.prototype.StopInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused === false )
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused === false )
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.ResumeInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused )
        {
            inp.audio.play();
            inp.audio.mPaused = false;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.RewindInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp==null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.loaded )
        {
            inp.video.currentTime = 0;
        }
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.loaded )
        {
            inp.audio.currentTime = 0;
        }
    }
}

EffectPass.prototype.MuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = true;
        inp.video.mMuted = true;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 0.0;
        inp.audio.mMuted = true;
    }
}

EffectPass.prototype.UnMuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = false;
        inp.video.mMuted = false;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 1.0;
        inp.audio.mMuted = false;
    }
}

EffectPass.prototype.ToggleMuteInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];
    if( inp===null ) return null;

    if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.video.mMuted;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if( inp.audio.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.audio.mMuted;
    }

    return null;
}

EffectPass.prototype.UpdateInputs = function( wa, forceUpdate, keyboard )
{
   for (let i=0; i<this.mInputs.length; i++ )
   {
        let inp = this.mInputs[i];

        if( inp===null )
        {
            if( forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, null, false, 0, 0, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.image, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mPreview, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if( inp.loaded && forceUpdate )
            {
                if( this.mTextureCallbackFun!==null )
                {
                    let img = (assetID_to_cubemapBuferID(inp.mInfo.mID)===-1) ? inp.image[0] : inp.mImage;
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, img, true, 2, 1, -1.0, this.mID );
                }
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:keyboard.mIcon,mData:keyboard.mData}, false, 6, 0, -1.0, this.mID );
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, -1, this.mID );
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
              if( inp.loaded && inp.audio.mPaused === false && inp.audio.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                      inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                  }

                  if (this.mTextureCallbackFun!==null)
                  {
                           if (inp.mInfo.mType === "music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData}, false, 4, 1, inp.audio.currentTime, this.mID);
                      else if (inp.mInfo.mType === "musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData, info: inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                  }
              }
              else if( inp.loaded===false )
              {
                  if (this.mTextureCallbackFun!==null)
                      this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:null}, false, 4, 0, -1.0, this.mID);
              }
        }
        else if( inp.mInfo.mType==="mic" )
        {
              if( inp.loaded && inp.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                      inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
                  }
                  if( this.mTextureCallbackFun!==null )
                      this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave: ((wa==null)?null:inp.mFreqData) }, false, 5, 1, 0, this.mID );
              }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:null}, true, 9, 1, -1.0, this.mID );
            }
        }
    }
}

EffectPass.prototype.Sampler2Renderer = function (sampler)
{
    let filter = this.mRenderer.FILTER.NONE;
    if (sampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
    if (sampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
    let wrap = this.mRenderer.TEXWRP.REPEAT;
    if (sampler.wrap === "clamp") wrap = this.mRenderer.TEXWRP.CLAMP;
    let vflip = false;
    if (sampler.vflip === "true") vflip = true;

    return { mFilter: filter, mWrap: wrap, mVFlip: vflip };
}

EffectPass.prototype.GetSamplerVFlip = function (id)
{
    let inp = this.mInputs[id];
    return inp.mInfo.mSampler.vflip;
}

EffectPass.prototype.GetTranslatedShaderSource = function ()
{
    return this.mTranslatedSource;
}

EffectPass.prototype.SetSamplerVFlip = function (id, str) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = false;
    if (str === "true") filter = true;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, null);
            inp.mInfo.mSampler.vflip = str;
        }
    }
}

EffectPass.prototype.GetAcceptsVFlip = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return false;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return false;
    return true;
}

EffectPass.prototype.GetSamplerFilter = function (id)
{
    let inp = this.mInputs[id];
    if( inp===null) return;
    return inp.mInfo.mSampler.filter;
}

EffectPass.prototype.SetSamplerFilter = function (id, str, buffers, cubeBuffers) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = renderer.FILTER.NONE;
    if (str === "linear") filter = renderer.FILTER.LINEAR;
    if (str === "mipmap") filter = renderer.FILTER.MIPMAP;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0)
            {
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[0], filter, true);
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[1], filter, true);
                inp.mInfo.mSampler.filter = str;
            }
            else
            {
                renderer.SetSamplerFilter(inp.globject, filter, true);
                inp.mInfo.mSampler.filter = str;
            }
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[0], filter, true);
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[1], filter, true);
        inp.mInfo.mSampler.filter = str;
    }
    else if (inp.mInfo.mType === "keyboard")
    {
        inp.mInfo.mSampler.filter = str;
    }
}

EffectPass.prototype.GetAcceptsMipmapping = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetAcceptsLinear = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return true;
    if (inp.mInfo.mType === "musicstream") return true;
    if (inp.mInfo.mType === "mic")  return true;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return true;
    return false;
}

EffectPass.prototype.GetAcceptsWrapRepeat = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return false;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetSamplerWrap = function (id)
{
    return this.mInputs[id].mInfo.mSampler.wrap;
}

EffectPass.prototype.SetSamplerWrap = function (id, str, buffers)
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let restr = renderer.TEXWRP.REPEAT;
    if (str === "clamp") restr = renderer.TEXWRP.CLAMP;

    if (inp === null) 
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "video") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap") 
    {
        if (inp.loaded)
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "webcam") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[0], restr);
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[1], restr);
        inp.mInfo.mSampler.wrap = str;
    }
}


EffectPass.prototype.GetTexture = function( slot )
{
    let inp = this.mInputs[slot];
    if( inp===null ) return null;
    return inp.mInfo;
}

EffectPass.prototype.SetOutputs = function( slot, id )
{
    this.mOutputs[slot] = id;
}

EffectPass.prototype.SetOutputsByBufferID = function( slot, id )
{
    if( this.mType==="buffer" )
    {
        this.mOutputs[slot] = bufferID_to_assetID( id );

        this.mEffect.ResizeBuffer( id, this.mEffect.mXres, this.mEffect.mYres, false );
    }
    else if( this.mType==="cubemap" )
    {
        this.mOutputs[slot] = cubamepBufferID_to_assetID( id );
        this.mEffect.ResizeCubemapBuffer(id, 1024, 1024 );
    }
}

EffectPass.prototype.NewTexture = function( wa, slot, url, buffers, cubeBuffers, keyboard )
{
    var me = this;
    var renderer = this.mRenderer;

    if( renderer===null ) return;

    let texture = null;

    if( url===null || url.mType===null )
    {
        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( this.mTextureCallbackObj, slot, null, true, 0, 0, -1.0, me.mID );
        me.DestroyInput( slot );
        me.mInputs[slot] = null;
        me.MakeHeader();
        return { mFailed:false, mNeedsShaderCompile:false };
    }
    else if( url.mType==="texture" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.image = new Image();
        texture.image.crossOrigin = '';
        texture.image.onload = function()
        {
            let rti = me.Sampler2Renderer(url.mSampler);

            // O.M.G. FIX THIS
            let channels = renderer.TEXFMT.C4I8;
            if (url.mID === "Xdf3zn" || url.mID === "4sf3Rn" || url.mID === "4dXGzn" || url.mID === "4sf3Rr")
                channels = renderer.TEXFMT.C1I8;
            
            texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.image, channels, rti.mFilter, rti.mWrap, rti.mVFlip);

            texture.loaded = true;
            if( me.mTextureCallbackFun!==null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.image, true, 1, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="volume" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mImage = { mData:null, mXres:1, mYres:0, mZres:0 };
        texture.mPreview = new Image();
        texture.mPreview.crossOrigin = '';

	    var xmlHttp = new XMLHttpRequest();
        if( xmlHttp===null ) return { mFailed:true };

        xmlHttp.open('GET', url.mSrc, true);
        xmlHttp.responseType = "arraybuffer";
        xmlHttp.onerror = function()
        {
            console.log( "Error 1 loading Volume" );
        }
        xmlHttp.onload = function()
        {
            let data = xmlHttp.response;
            if (!data ) { console.log( "Error 2 loading Volume" ); return; }

            let file = piFile(data);

            let signature = file.ReadUInt32();
            texture.mImage.mXres = file.ReadUInt32();
            texture.mImage.mYres = file.ReadUInt32();
            texture.mImage.mZres = file.ReadUInt32();
            let binNumChannels = file.ReadUInt8();
            let binLayout = file.ReadUInt8();
            let binFormat = file.ReadUInt16();
            let format = renderer.TEXFMT.C1I8;
                 if( binNumChannels===1 && binFormat===0 )  format = renderer.TEXFMT.C1I8;
            else if( binNumChannels===2 && binFormat===0 )  format = renderer.TEXFMT.C2I8;
            else if( binNumChannels===3 && binFormat===0 )  format = renderer.TEXFMT.C3I8;
            else if( binNumChannels===4 && binFormat===0 )  format = renderer.TEXFMT.C4I8;
            else if( binNumChannels===1 && binFormat===10 ) format = renderer.TEXFMT.C1F32;
            else if( binNumChannels===2 && binFormat===10 ) format = renderer.TEXFMT.C2F32;
            else if( binNumChannels===3 && binFormat===10 ) format = renderer.TEXFMT.C3F32;
            else if( binNumChannels===4 && binFormat===10 ) format = renderer.TEXFMT.C4F32;
            else return;

            let buffer = new Uint8Array(data, 20); // skip 16 bytes (header of .bin)

            let rti = me.Sampler2Renderer(url.mSampler);

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T3D, texture.mImage.mXres, texture.mImage.mYres, format, rti.mFilter, rti.mWrap, buffer);

            if( texture.globject===null )
            {
                console.log( "Error 4: loading Volume" ); 
                return { mFailed:true };
            }

            if (me.mTextureCallbackFun !== null)
            {
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }

            texture.loaded = true;

            // load icon for it
            texture.mPreview.onload = function()
            {
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }
            texture.mPreview.src = url.mPreviewSrc;
        }
        xmlHttp.send("");


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="volume")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="cubemap" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        let rti = me.Sampler2Renderer(url.mSampler);

        if( assetID_to_cubemapBuferID(url.mID)!==-1 )
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 2, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/cubemap00.png";

            this.mEffect.ResizeCubemapBuffer(0, 1024, 1024 );

        }
        else
        {
            texture.image = [ new Image(), new Image(), new Image(), new Image(), new Image(), new Image() ];

            let numLoaded = 0;
            for (var i=0; i<6; i++ )
            {
                texture.image[i].mId = i;
                texture.image[i].crossOrigin = '';
                texture.image[i].onload = function()
                {
                    var id = this.mId;
                    numLoaded++;
                    if( numLoaded===6 )
                    {
                        texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.CUBEMAP, texture.image, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                        texture.loaded = true;
                        if (me.mTextureCallbackFun !== null)
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, texture.image[0], true, 2, 1, -1.0, me.mID);
                    }
                }

                if( i === 0) 
                {
                    texture.image[i].src = url.mSrc;
                } 
                else 
                {
                    let n = url.mSrc.lastIndexOf(".");
                    texture.image[i].src = url.mSrc.substring(0, n) + "_" + i + url.mSrc.substring(n, url.mSrc.length);
                }
            }
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="cubemap")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="webcam" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        texture.video = document.createElement('video');
    	texture.video.width = 320;
    	texture.video.height = 240;
    	texture.video.autoplay = true;
    	texture.video.loop = true;
        texture.mForceMuted = this.mForceMuted;
        texture.mImage = null;

        let rti = me.Sampler2Renderer(url.mSampler);

        var loadImageInsteadOfWebCam = function()
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.mImage, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 7, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/webcam.png";
        }
        
        loadImageInsteadOfWebCam();

        if( typeof navigator.getUserMedia !== "undefined"  && texture.mForceMuted===false )
        {
            texture.video.addEventListener("canplay", function (e)
            {
				try
				{
                    texture.mImage = null;
                    if( texture.globject != null )
                        renderer.DestroyTexture( texture.globject );
					texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
					texture.loaded = true;
                }
                catch(e)
                {
                    loadImageInsteadOfWebCam();
	                alert( 'Your browser can not transfer webcam data to the GPU.');
                }
            } );

            navigator.mediaDevices.getUserMedia( 
                                { "video": { width: 1280, height: 720 }, "audio": false } )
                                .then( function(stream)
                                       {
                                            texture.video.srcObject = stream;
    	                               } )
                                .catch( function(error)
                                        {
                                            loadImageInsteadOfWebCam();
    		                                alert( 'Unable to capture WebCam. Please reload the page.' );
    	                                } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="mic" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mForceMuted = this.mForceMuted;
        texture.mAnalyser = null;
        let num = 512;
        texture.mFreqData = new Uint8Array( num );
        texture.mWaveData = new Uint8Array( num );

        if( wa === null || typeof navigator.getUserMedia === "undefined" )
        {
            if( !texture.mForceMuted ) alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.mForceMuted = true; 
        }

        if( texture.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, num, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)
            texture.loaded = true;
        }
        else
        {
        navigator.getUserMedia( { "audio": true },
                                function(stream)
                                {
                                  texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, null)
                                  texture.mic = wa.createMediaStreamSource(stream);
                                  texture.mAnalyser = wa.createAnalyser();
                                  texture.mic.connect( texture.mAnalyser );
                                  texture.loaded = true;
    	                        },
                                function(error)
                                {
    		                        alert( 'Unable open Mic. Please reload the page.' );
    	                        } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="video" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.video = document.createElement('video');
    	texture.video.loop = true;
        texture.video.preload = "auto";
        texture.video.mPaused = this.mForcePaused;
        texture.video.mMuted = true;//this.mForceMuted;
    	texture.video.muted  = true;//this.mForceMuted;
        if( this.mForceMuted===true )
            texture.video.volume = 0;
    	texture.video.autoplay = false;
        texture.video.hasFalled = false;
        
        let rti = me.Sampler2Renderer(url.mSampler);

        texture.video.addEventListener("canplay", function (e)
        {
            texture.video.play().then( function()
                                       {
                                           texture.video.mPaused = false;

                                           texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                                           texture.loaded = true;
            
                                           if( me.mTextureCallbackFun!=null )
                                               me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.video, true, 3, 1, -1.0, me.mID );
                                        } )
                               .catch( function(error)
                                       {
                                           console.log( error );
                                       }
                                );
        } );

        texture.video.addEventListener( "error", function(e)
        {
               if( texture.video.hasFalled===true ) { alert("Error: cannot load video" ); return; }
               let str = texture.video.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".mp4";
               texture.video.src = str;
               texture.video.hasFalled = true;
        } );

        texture.video.src = url.mSrc;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="music" || url.mType==="musicstream" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.audio = document.createElement('audio');
    	texture.audio.loop = true;
        texture.audio.mMuted = this.mForceMuted;
        texture.audio.mForceMuted = this.mForceMuted;
        texture.audio.muted = this.mForceMuted;
        if( this.mForceMuted===true )
            texture.audio.volume = 0;
        texture.audio.autoplay = false;
        texture.audio.hasFalled = false;
        texture.audio.mPaused = false;
        texture.audio.mSound = {};

        if( this.mForceMuted===false )
        {
            if(url.mType==="musicstream" && SC === null)
            {
                alert( "Shadertoy: Soundcloud could not be reached" );
                texture.audio.mForceMuted = true;
            }
            }

        if( wa === null && this.mForceMuted===false )
        {
            alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.audio.mForceMuted = true;
        }

        if( texture.audio.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null);
            let num = 512;
            texture.audio.mSound.mFreqData = new Uint8Array( num );
            texture.audio.mSound.mWaveData = new Uint8Array( num );
            texture.loaded = true;
        }

        texture.audio.addEventListener( "canplay", function()
        {
            if( texture===null || texture.audio===null ) return;
            if( this.mForceMuted  ) return;
            if( texture.loaded === true ) return;

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)

            texture.audio.mSound.mSource   = wa.createMediaElementSource( texture.audio );
            texture.audio.mSound.mAnalyser = wa.createAnalyser();
            texture.audio.mSound.mGain     = wa.createGain();

            texture.audio.mSound.mSource.connect(   texture.audio.mSound.mAnalyser );
            texture.audio.mSound.mAnalyser.connect( texture.audio.mSound.mGain );
            texture.audio.mSound.mGain.connect(me.mGainNode);

            texture.audio.mSound.mFreqData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );
            texture.audio.mSound.mWaveData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );

            if( texture.audio.mPaused )
            {
                texture.audio.pause();
            }
            else
            {
                texture.audio.play().then( function() {} ).catch( function(e){console.log("error " + e);} );
            }
            texture.loaded = true;
        } );

        texture.audio.addEventListener( "error", function(e)
        {
               if( this.mForceMuted  ) return;

               if( texture.audio.hasFalled===true ) { return; }
               let str = texture.audio.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".ogg";
               texture.audio.src = str;
               texture.audio.hasFalled = true;
        } );

        if( !texture.audio.mForceMuted )
        {
            if(url.mType==="musicstream")
            {
                SC.resolve(url.mSrc, 
                    function(song) 
                    {
                        if( song.streamable===true )
                        {
                            texture.audio.crossOrigin = 'anonymous';
                            texture.audio.src = song.stream_url;
                            texture.audio.soundcloudInfo = song;
                        }
                        else
                        {
                            alert('Shadertoy: Soundcloud 3 - This track cannot be streamed' );
                        }
                    },
                    function(error)
                    {
                        if (me.mTextureCallbackFun!==null)
                        {
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
                        }
                    } );
            } 
            else
            {
                texture.audio.src = url.mSrc;
            }
        }

        if (me.mTextureCallbackFun!==null)
        {
            if (url.mType === "music")            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
            else if (url.mType === "musicstream") me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null, info: texture.audio.soundcloudInfo}, false, 8, 0, -1.0, me.mID);
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="keyboard" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = true;

        texture.keyboard = {};

        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {mImage: keyboard.mIcon, mData: keyboard.mData}, false, 6, 1, -1.0, me.mID );

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="buffer" )
    {
        texture = {};
        texture.mInfo = url;

        texture.image = new Image();
        texture.image.onload = function()
        {
            if( me.mTextureCallbackFun!==null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {texture: texture.image, data:null}, true, 9, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;
        texture.id = assetID_to_bufferID( url.mID );
        texture.loaded = true;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;

        this.mEffect.ResizeBuffer(texture.id, this.mEffect.mXres, this.mEffect.mYres, false );

        this.SetSamplerFilter(slot, url.mSampler.filter, buffers, cubeBuffers, true);
        this.SetSamplerVFlip(slot, url.mSampler.vflip);
        this.SetSamplerWrap(slot, url.mSampler.wrap, buffers);

        this.MakeHeader();
        return returnValue;
    }
    else
    {
        alert( "input type error" );
        return { mFailed: true };
    }

    return { mFailed: true };
}

EffectPass.prototype.Paint_Image = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];

    //------------------------
    
    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];
    let texIsLoaded = [0, 0, 0, 0 ];
    let texID = [ null, null, null, null];

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
            texIsLoaded[i] = 1;
            resos[3*i+0] = 256;
            resos[3*i+1] = 3;
            resos[3*i+2] = 1;
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;

                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                }
            }
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {

                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                texIsLoaded[i] = 0;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    times[i] = 10.0 + time;
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            let id = inp.id;
            if( inp.loaded===true  )
            {
                texID[i] = buffers[id].mTexture[ buffers[id].mLastRenderDone ];
                texIsLoaded[i] = 1;
                resos[3*i+0] = xres;
                resos[3*i+1] = yres;
                resos[3*i+2] = 1;
                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID[i], filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    let prog = this.mProgram;

    //if( vrData!=null && this.mSupportsVR ) prog = this.mProgramVR;

    this.mRenderer.AttachShader(prog);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F("iFrameRate", fps);

    this.mRenderer.SetShaderConstant1F(  "iCh0.time", times[0] );
    this.mRenderer.SetShaderConstant1F(  "iCh1.time", times[1] );
    this.mRenderer.SetShaderConstant1F(  "iCh2.time", times[2] );
    this.mRenderer.SetShaderConstant1F(  "iCh3.time", times[3] );
    this.mRenderer.SetShaderConstant3F(  "iCh0.size", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iCh1.size", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iCh2.size", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iCh3.size", resos[9], resos[10], resos[11] );
    this.mRenderer.SetShaderConstant1I(  "iCh0.loaded", texIsLoaded[0] );
    this.mRenderer.SetShaderConstant1I(  "iCh1.loaded", texIsLoaded[1] );
    this.mRenderer.SetShaderConstant1I(  "iCh2.loaded", texIsLoaded[2] );
    this.mRenderer.SetShaderConstant1I(  "iCh3.loaded", texIsLoaded[3] );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    if( (vrData !== null) && this.mSupportsVR )
    {
        for (let i=0; i<2; i++ )
        {
            let ei = (i===0) ? vrData.mLeftEye : vrData.mRightEye;

            let vp = [i * xres / 2, 0, xres / 2, yres];

            this.mRenderer.SetViewport(vp);

            let fov = ei.mProjection;
            let corA = [ -fov[2], -fov[1], -1.0 ];
            let corB = [  fov[3], -fov[1], -1.0 ];
            let corC = [  fov[3],  fov[0], -1.0 ];
            let corD = [ -fov[2],  fov[0], -1.0 ];
            let apex = [ 0.0, 0.0, 0.0 ];

            let ma = invertFast( ei.mCamera );
            corA = matMulpoint( ma, corA ); 
            corB = matMulpoint( ma, corB ); 
            corC = matMulpoint( ma, corC ); 
            corD = matMulpoint( ma, corD ); 
            apex = matMulpoint( ma, apex ); 

            let corners = [ corA[0], corA[1], corA[2], 
                            corB[0], corB[1], corB[2], 
                            corC[0], corC[1], corC[2], 
                            corD[0], corD[1], corD[2],
                            apex[0], apex[1], apex[2]];

            this.mRenderer.SetShaderConstant3FV("unCorners", corners);
            this.mRenderer.SetShaderConstant4FV("unViewport", vp);

            this.mRenderer.DrawUnitQuad_XY(l1);
        }
    }
    else 
    {
        this.mRenderer.SetViewport([0, 0, xres, yres]);
        this.mRenderer.DrawFullScreenTriangle_XY( l1 );
    }

    this.mRenderer.DettachTextures();
}

EffectPass.prototype.iRenderSound = function(d, callback )
{
    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds() ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    this.mRenderer.SetRenderTarget(this.mRenderFBO);

    this.mRenderer.SetViewport([0, 0, this.mTextureDimensions, this.mTextureDimensions]);
    this.mRenderer.AttachShader(this.mProgram);
    this.mRenderer.SetBlend( false );

    let texID = [null, null, null, null];
    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
    }

    this.mRenderer.AttachTextures(4, texID[0], texID[1], texID[2], texID[3]);

    let l2 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iTimeOffset");
    let l3 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iSampleOffset");
    this.mRenderer.SetShaderConstant4FV("iDate", dates);
    this.mRenderer.SetShaderConstant3FV("iChannelResolution", resos);
    this.mRenderer.SetShaderConstant1F("iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit("iChannel0", 0);
    this.mRenderer.SetShaderTextureUnit("iChannel1", 1);
    this.mRenderer.SetShaderTextureUnit("iChannel2", 2);
    this.mRenderer.SetShaderTextureUnit("iChannel3", 3);

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    //--------------------------------
    let numSamples = this.mTmpBufferSamples;
    let numBlocks = this.mPlaySamples / numSamples;
    for (let j=0; j<numBlocks; j++ )
    {
        let off = j*numSamples;
        
        this.mRenderer.SetShaderConstant1F_Pos(l2, off / this.mSampleRate);
        this.mRenderer.SetShaderConstant1I_Pos(l3, off );
        this.mRenderer.DrawUnitQuad_XY(l1);

        this.mRenderer.GetPixelData(this.mData, 0, this.mTextureDimensions, this.mTextureDimensions);

        callback( off, this.mData, numSamples );
    }

    this.mRenderer.DetachShader();
    this.mRenderer.DettachTextures();
    this.mRenderer.SetRenderTarget(null);
}

EffectPass.prototype.Paint_Sound = function( wa, d )
{
    let bufL = this.mBuffer.getChannelData(0); // Float32Array
    let bufR = this.mBuffer.getChannelData(1); // Float32Array

    this.iRenderSound( d, function(off, data, numSamples)
                         {
                            for( let i=0; i<numSamples; i++ )
                            {
                                bufL[off+i] = -1.0 + 2.0*(data[4*i+0]+256.0*data[4*i+1])/65535.0;
                                bufR[off+i] = -1.0 + 2.0*(data[4*i+2]+256.0*data[4*i+3])/65535.0;
                            }
                         }
                     );
}

EffectPass.prototype.SetUniforms = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    //------------------------
    
    let texID = [ null, null, null, null];

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
        }
        else if( inp.mInfo.mType=="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
    
                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                }
            }

        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
           if( inp.loaded===true )
           { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                times[i] = 10.0 + time;
            }

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = buffers[inp.id].mTexture[ buffers[inp.id].mLastRenderDone ];
                resos[3*i+0] = buffers[inp.id].mResolution[0];
                resos[3*i+1] = buffers[inp.id].mResolution[1];
                resos[3*i+2] = 1;
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    this.mRenderer.AttachShader(this.mProgram);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F(  "iFrameRate", fps );

    this.mRenderer.SetShaderConstant1F(  "iChannel[0].time",       times[0] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[1].time",       times[1] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[2].time",       times[2] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[3].time",       times[3] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[0].resolution", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[1].resolution", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[2].resolution", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[3].resolution", resos[9], resos[10], resos[11] );
}

EffectPass.prototype.ProcessInputs = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
        }
        else if( inp.mInfo.mType==="volume" )
        {
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );
                }
                else if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                if( inp.audio.mForceMuted === true )
                {
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                let id = inp.id;
                let texID = buffers[id].mTexture[ buffers[id].mLastRenderDone ];

                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID, filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
				let id = inp.id;
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }
}

EffectPass.prototype.Paint_Cubemap = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face )
{
    this.ProcessInputs(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
    this.SetUniforms(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    let vp = [0, 0, xres, yres];

    this.mRenderer.SetViewport(vp);

    let corA = [-1.0, -1.0, -1.0];
    let corB = [ 1.0, -1.0, -1.0];
    let corC = [ 1.0,  1.0, -1.0];
    let corD = [-1.0,  1.0, -1.0];
    let apex = [ 0.0,  0.0,  0.0];

         if( face===0 ) { corA=[ 1.0,  1.0,  1.0]; corB=[ 1.0,  1.0, -1.0]; corC=[ 1.0, -1.0, -1.0]; corD=[ 1.0, -1.0,  1.0]; }
    else if( face===1 ) { corA=[-1.0,  1.0, -1.0]; corB=[-1.0,  1.0,  1.0]; corC=[-1.0, -1.0,  1.0]; corD=[-1.0, -1.0, -1.0]; }
    else if( face===2 ) { corA=[-1.0,  1.0, -1.0]; corB=[ 1.0,  1.0, -1.0]; corC=[ 1.0,  1.0,  1.0]; corD=[-1.0,  1.0,  1.0]; }
    else if( face===3 ) { corA=[-1.0, -1.0,  1.0]; corB=[ 1.0, -1.0,  1.0]; corC=[ 1.0, -1.0, -1.0]; corD=[-1.0, -1.0, -1.0]; }
    else if( face===4 ) { corA=[-1.0,  1.0,  1.0]; corB=[ 1.0,  1.0,  1.0]; corC=[ 1.0, -1.0,  1.0]; corD=[-1.0, -1.0,  1.0]; }
    else if( face===5 ) { corA=[ 1.0,  1.0, -1.0]; corB=[-1.0,  1.0, -1.0]; corC=[-1.0, -1.0, -1.0]; corD=[ 1.0, -1.0, -1.0]; }

    let corners = [ corA[0], corA[1], corA[2], 
                    corB[0], corB[1], corB[2], 
                    corC[0], corC[1], corC[2], 
                    corD[0], corD[1], corD[2],
                    apex[0], apex[1], apex[2]];

    this.mRenderer.SetShaderConstant3FV("unCorners", corners);
    this.mRenderer.SetShaderConstant4FV("unViewport", vp);

    this.mRenderer.DrawUnitQuad_XY(l1);

    this.mRenderer.DettachTextures();
}

EffectPass.prototype.Paint = function( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, bufferNeedsMimaps, buffers, cubeBuffers, keyboard, effect )
{
    if( this.mType==="sound" )
    {
        if (this.mSoundShaderCompiled === true)
        {
            // make sure all textures are loaded
            for (let i=0; i<this.mInputs.length; i++ )
            {
                let inp = this.mInputs[i];
                if (inp === null) continue;

                if (inp.mInfo.mType === "texture" && !inp.loaded) return;
                if (inp.mInfo.mType === "cubemap" && !inp.loaded) return;
            }

            this.Paint_Sound(wa, da);
            this.mSoundShaderCompiled = false;
        }
        if (this.mFrame === 0)
        {
            if (this.mPlaying===true)
            {
                this.mPlayNode.disconnect();
                this.mPlayNode.stop();
                this.mPlayNode = null;
            }
            this.mPlaying = true;

            this.mPlayNode = wa.createBufferSource();
            this.mPlayNode.buffer = this.mBuffer;
            this.mPlayNode.connect(this.mGainNode);
            this.mPlayNode.start(0);
        }
        this.mFrame++;
    }
    else if( this.mType==="image" )
    {
        this.mRenderer.SetRenderTarget( null );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );
        this.mFrame++;
    }
    else if( this.mType==="common" )
    {
    }
    else if( this.mType==="buffer" )
    {
        this.mEffect.ResizeBuffer(bufferID, this.mEffect.mXres, this.mEffect.mYres, false );

        let buffer = buffers[bufferID];

        let dstID = 1 - buffer.mLastRenderDone;

        this.mRenderer.SetRenderTarget( buffer.mTarget[dstID] );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }

        // make thumbnail
        //if( this.mTextureCallbackFun != null )
        /*
        {
            this.mRenderer.SetRenderTarget( buffer.mThumbnailRenderTarget );
            let v = [0, 0, buffer.mThumbnailRes[0], buffer.mThumbnailRes[1]];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            this.mRenderer.SetShaderConstant4FV("v", v);
            this.mRenderer.AttachTextures(1, buffer.mTexture[dstID], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);
            this.mRenderer.DettachTextures();
            this.mRenderer.DetachShader();
            this.mRenderer.GetPixelData( new Uint8Array(buffer.mThumbnailBuffer.data.buffer), buffer.mThumbnailRes[0], buffer.mThumbnailRes[1] );
            this.mRenderer.SetRenderTarget(null);
        }
        */
        buffers[bufferID].mLastRenderDone = 1 - buffers[bufferID].mLastRenderDone;
        this.mFrame++;
    }
    else if( this.mType==="cubemap" )
    {
        this.mEffect.ResizeCubemapBuffer(bufferID, 1024, 1024, false );

        let buffer = cubeBuffers[bufferID];

        xres = buffer.mResolution[0];
        yres = buffer.mResolution[1];
        let dstID = 1 - buffer.mLastRenderDone;
        for( let face=0; face<6; face++ )
        {
            this.mRenderer.SetRenderTargetCubeMap( buffer.mTarget[dstID], face );
            this.Paint_Cubemap( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
        }
        this.mRenderer.SetRenderTargetCubeMap( null, 0 );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }
        cubeBuffers[bufferID].mLastRenderDone = 1 - cubeBuffers[bufferID].mLastRenderDone;

        this.mFrame++;
    }
}

EffectPass.prototype.StopOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;
    this.mPlayNode.disconnect();
}

EffectPass.prototype.ResumeOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;

    wa.resume()
    this.mPlayNode.connect( this.mGainNode );
}

EffectPass.prototype.StopOutput_Image = function( wa )
{
}

EffectPass.prototype.ResumeOutput_Image = function( wa )
{
}

EffectPass.prototype.StopOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.StopInput(j);

    if( this.mType==="sound" )
         this.StopOutput_Sound( wa );
    else
         this.StopOutput_Image( wa );
}

EffectPass.prototype.ResumeOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.ResumeInput(j);

    if( this.mType==="sound" )
         this.ResumeOutput_Sound( wa );
    else
         this.ResumeOutput_Image( wa );
}

EffectPass.prototype.GetCompilationTime = function()
{
    return this.mCompilationTime;
}

//============================================================================================================
function Screenshots()
{
    // private
    let mTexture = null;
    let mTarget = null;
    let mXres = 0;
    let mYres = 0;
    let mCubemapToEquirectProgram;
    let mRenderer = null;

    // public
    var me = {};

    me.Initialize = function(renderer)
    {
        mRenderer = renderer;
        let caps = mRenderer.GetCaps();
        let is20 = caps.mIsGL20;

        let vsSourceC, fsSourceC;
        if( is20 )
        {
            vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; out vec4 outColor; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); outColor = texture(t, rd); }";
        }
        else
        {
            vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); gl_FragColor = texture(t, rd); }";
        }

        let compileShader = function (worked, info)
        {
            if (worked === false)
            {
                console.log("Failed to compile cubemap resample shader (" + errorType + "): " + log);
            }
            else
            {
                mCubemapToEquirectProgram = info;
            }
        }
        mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, compileShader);

        return true;
    };

    me.Allocate = function( xres, yres )
    {
        if( xres>mXres || yres>mYres )
        {
            let texture = mRenderer.CreateTexture(mRenderer.TEXTYPE.T2D, xres, yres, mRenderer.TEXFMT.C4F32, mRenderer.FILTER.NONE, mRenderer.TEXWRP.CLAMP, null);
            let target = mRenderer.CreateRenderTarget( texture, null, null, null, null, false);

            if( mXres!==0 )
            {
                mRenderer.DestroyTexture(mTexture);
                mRenderer.DestroyRenderTarget(mTarget);
            }

            mTexture = texture;
            mTarget = target;
            mXres = xres;
            mYres = yres;
        }
    };

    me.GetProgram = function()
    {
        return mCubemapToEquirectProgram;
    };
    me.GetTarget = function()
    {
        return mTarget;
    };

    return me;
};

//============================================================================================================

function Effect(vr, ac, canvas, callback, obj, forceMuted, forcePaused, resizeCallback, crashCallback )
{
    let xres = canvas.width;
    let yres = canvas.height;

    let me = this;
    this.mCanvas = canvas;
    this.mCreated = false;
    this.mRenderer = null;
    this.mAudioContext = ac;
    this.mGLContext = null;
    this.mWebVR = vr;
    this.mRenderingStereo = false;
    this.mXres = xres;
    this.mYres = yres;
    this.mForceMuted = forceMuted;
    if( ac===null ) this.mForceMuted = true;
    this.mForcePaused = forcePaused;
    this.mGainNode = null;
    this.mPasses = [];
    this.mFrame = 0;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mMaxBuffers = 4;
    this.mMaxCubeBuffers = 1;
    this.mMaxPasses = this.mMaxBuffers + 1 + 1 + 1 + 1; // some day decouple passes from buffers (4 buffers + common + Imagen + sound + cubemap)
    this.mBuffers = [];
    this.mCubeBuffers = [];
    this.mScreenshotSytem = null;
    this.mCompilationTime = 0;
    this.mIsLowEnd = piIsMobile();

    this.mGLContext = piCreateGlContext(canvas, false, false, true, false); // need preserve-buffe to true in order to capture screenshots
    if (this.mGLContext === null)
    {
        return;
    }

    canvas.addEventListener("webglcontextlost", function (event)
        {
            event.preventDefault();
            crashCallback();
        }, false);

    this.mRenderer = piRenderer();
    if (!this.mRenderer.Initialize(this.mGLContext))
        return;

    this.mScreenshotSytem = Screenshots();
    if (!this.mScreenshotSytem.Initialize(this.mRenderer))
        return;

    var caps = this.mRenderer.GetCaps();
    this.mIs20 = caps.mIsGL20;
    this.mShaderTextureLOD = caps.mShaderTextureLOD;
    //-------------
    if( ac!==null )
    {   
        this.mGainNode = ac.createGain();
        if( !forceMuted )
        {
            this.mGainNode.connect( ac.destination);
        }
        if (this.mForceMuted )
            this.mGainNode.gain.value = 0.0;
        else
            this.mGainNode.gain.value = 1.0;
    }

    //-------------
    let vsSourceC, fsSourceC;
    if( this.mIs20 )
    {
        vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { outColor = textureLod(t, gl_FragCoord.xy / v.zw, 0.0); }";
    }
    else
    {
        vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; void main() { gl_FragColor = texture2D(t, gl_FragCoord.xy / v.zw, -100.0); }";
    }

    this.mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, function(worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to copy buffers : " + info.mErrorStr);
            else me.mProgramCopy = info;
        });

    let vsSourceD, fsSourceD;
    if( this.mIs20 )
    {
        vsSourceD = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { vec2 uv = gl_FragCoord.xy / v.zw; outColor = texture(t, vec2(uv.x,1.0-uv.y)); }";
    }
    else
    {
        vsSourceD = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; void main() { vec2 uv = gl_FragCoord.xy / v.zw; gl_FragColor = texture2D(t, vec2(uv.x,1.0-uv.y)); }";
    }

    this.mRenderer.CreateShader(vsSourceD, fsSourceD, false, true, function (worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to downscale buffers : " + info.mErrorStr);
            else me.mProgramDownscale = info;
        });


    // set all buffers and cubemaps to null
    for( let i=0; i<this.mMaxBuffers; i++ )
    {
        this.mBuffers[i] = { mTexture: [null, null], 
                             mTarget:  [null, null], 
                             mResolution: [0, 0],
                             mLastRenderDone: 0,
                             mThumbnailRenderTarget: null,
                             mThumbnailTexture: null,
                             mThumbnailBuffer:  null,
                             mThumbnailRes: [0, 0] };
    }

    for( let i=0; i<this.mMaxCubeBuffers; i++ )
    {
        this.mCubeBuffers[i] = { mTexture: [null, null], 
                                mTarget:  [null, null], 
                                mResolution: [0, 0],
                                mLastRenderDone: 0,
                                mThumbnailRenderTarget: null,
                                mThumbnailTexture: null,
                                mThumbnailBuffer:  null,
                                mThumbnailRes: [0, 0] };
    }

    //-------

    let keyboardData = new Uint8Array( 256*3 );
    for (let j=0; j<(256*3); j++ ) { keyboardData[j] = 0; }
    let kayboardTexture = this.mRenderer.CreateTexture( this.mRenderer.TEXTYPE.T2D, 256, 3, this.mRenderer.TEXFMT.C1I8, this.mRenderer.FILTER.NONE, this.mRenderer.TEXWRP.CLAMP, null);
    let keyboardImage = new Image();
    if( callback!==null )
        keyboardImage.src = "/img/keyboard.png"; // don't load PNG if no UI 
    this.mKeyboard = { mData: keyboardData, mTexture: kayboardTexture, mIcon: keyboardImage };

    let iResize = function( xres, yres )
    {
        me.mCanvas.width = xres;
        me.mCanvas.height = yres;
        me.mXres = xres;
        me.mYres = yres;
        me.ResizeBuffers(xres, yres);
        resizeCallback(xres, yres);
    };

    let bestAttemptFallback = function()
    {
        let devicePixelRatio = window.devicePixelRatio || 1;
        let xres = Math.round(me.mCanvas.offsetWidth  * devicePixelRatio) | 0;
        let yres = Math.round(me.mCanvas.offsetHeight * devicePixelRatio) | 0;
        iResize(xres, yres);
    };

    if(!window.ResizeObserver)
    {
        console.log("WARNING: This browser doesn't support ResizeObserver.");
        bestAttemptFallback();
        window.addEventListener("resize", bestAttemptFallback);
    }
    else
    {
        this.mRO = new ResizeObserver( function(entries, observer)
        {
            var entry = entries[0];
            if (!entry['devicePixelContentBoxSize'])
            {
                observer.unobserve(me.mCanvas);
                console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (2)");
                bestAttemptFallback();
                window.addEventListener("resize", bestAttemptFallback);
            }
            else
            {
                let box = entry.devicePixelContentBoxSize[0];
                let xres = box.inlineSize;
                let yres = box.blockSize;
                iResize(xres, yres);
            }
        });
        try
        {
            this.mRO.observe(this.mCanvas, { box: ["device-pixel-content-box"] });
            //this.mRO.observe(this.mCanvas);
        }
        catch (e)
        {
            console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (1)");
            bestAttemptFallback();
            window.addEventListener("resize", bestAttemptFallback);
        }
    }

    this.mCreated = true;
}

Effect.prototype.ResizeCubemapBuffer = function(i, xres, yres )
{
    let oldXres = this.mCubeBuffers[i].mResolution[0];
    let oldYres = this.mCubeBuffers[i].mResolution[1];

    if( this.mCubeBuffers[i].mTexture[0]===null || oldXres !== xres || oldYres !== yres )
    {
        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);
        let target1 = this.mRenderer.CreateRenderTargetCubeMap( texture1, null, false);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target2 = this.mRenderer.CreateRenderTargetCubeMap( texture2, null, false);

        // Store new buffers
        this.mCubeBuffers[i].mTexture = [texture1,texture2], 
        this.mCubeBuffers[i].mTarget =  [target1, target2 ], 
        this.mCubeBuffers[i].mLastRenderDone = 0;
        this.mCubeBuffers[i].mResolution[0] = xres;
        this.mCubeBuffers[i].mResolution[1] = yres;
    }
}

Effect.prototype.ResizeBuffer = function( i, xres, yres, skipIfNotExists )
{
    if( skipIfNotExists && this.mBuffers[i].mTexture[0]===null ) return;

    let oldXres = this.mBuffers[i].mResolution[0];
    let oldYres = this.mBuffers[i].mResolution[1];

    if( oldXres !== xres || oldYres !== yres )
    {
        let needCopy = (this.mBuffers[i].mTexture[0]!==null);

        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[0].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[0].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[1].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[1].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target1 = this.mRenderer.CreateRenderTarget( texture1, null, null, null, null, false);
        let target2 = this.mRenderer.CreateRenderTarget( texture2, null, null, null, null, false);

        if( needCopy )
        {
            let v = [0, 0, Math.min(xres, oldXres), Math.min(yres, oldYres)];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            let vOld = [0, 0, oldXres, oldYres];
            this.mRenderer.SetShaderConstant4FV("v", vOld);

            // Copy old buffers 1 to new buffer
            this.mRenderer.SetRenderTarget(target1);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[0], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Copy old buffers 2 to new buffer
            this.mRenderer.SetRenderTarget(target2);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[1], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Deallocate old memory
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[0]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[0]);
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[1]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[1]);
            //this.mRenderer.DestroyTexture(this.mBuffers[i].thumbnailTexture);
        }

        // Store new buffers
        this.mBuffers[i].mTexture = [texture1,texture2], 
        this.mBuffers[i].mTarget =  [target1, target2 ], 
        this.mBuffers[i].mLastRenderDone = 0;
        this.mBuffers[i].mResolution[0] = xres;
        this.mBuffers[i].mResolution[1] = yres;
    }
}

Effect.prototype.saveScreenshot = function(passid)
{
    let pass = this.mPasses[passid];

    if( pass.mType === "buffer" )
    {
        let bufferID = assetID_to_bufferID( this.mPasses[passid].mOutputs[0] );

        let texture = this.mBuffers[bufferID].mTarget[ this.mBuffers[bufferID].mLastRenderDone ];

        let numComponents = 3;
        let width = texture.mTex0.mXres;
        let height = texture.mTex0.mYres;
        let type = "Float"; // Other options Float, Half, Uint
        let bytes = new Float32Array(width * height * 4 );//numComponents);
        this.mRenderer.GetPixelDataRenderTarget( texture, bytes, width, height );
        let blob = piExportToEXR(width, height, numComponents, type, bytes);

        // Offer download automatically to the user
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "cubemap" )
    {
        let xres = 4096;
        let yres = 2048;
        this.mScreenshotSytem.Allocate( xres, yres );

        let cubeBuffer = this.mCubeBuffers[0];

        let target = this.mScreenshotSytem.GetTarget();
        this.mRenderer.SetRenderTarget( target );

        let program = this.mScreenshotSytem.GetProgram();

        this.mRenderer.AttachShader(program);
        let l1 = this.mRenderer.GetAttribLocation(program, "pos");
        this.mRenderer.SetViewport( [0, 0, xres, yres] );
        this.mRenderer.AttachTextures(1, cubeBuffer.mTexture[ cubeBuffer.mLastRenderDone ], null, null, null);
        this.mRenderer.DrawUnitQuad_XY(l1);
        this.mRenderer.DettachTextures();
        this.mRenderer.SetRenderTarget( null );

        let data = new Float32Array(xres*yres*4);
        this.mRenderer.GetPixelDataRenderTarget( target, data, xres, yres );

        let blob = piExportToEXR(xres, yres, 3, "Float", data );
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "sound" )
    {
        let offset = 0;
        const bits = 16;
        const numChannels = 2;
        let words = new Int16Array(60*pass.mSampleRate*numChannels );

        pass.iRenderSound( new Date(), function(off, data, numSamples)
                                         {
                                            for( let i=0; i<numSamples; i++ )
                                            {
                                                words[offset++] = (data[4*i+0]+256.0*data[4*i+1]) - 32767;
                                                words[offset++] = (data[4*i+2]+256.0*data[4*i+3]) - 32767;
                                            }
                                         }
                                     );

        let blob = piExportToWAV( 60*pass.mSampleRate, pass.mSampleRate, bits, numChannels, words);

        piTriggerDownload("sound.wav", blob);
    }    
}

Effect.prototype.ResizeBuffers = function(xres, yres)
{
    for (let i=0; i<this.mMaxBuffers; i++ )
    {
        this.ResizeBuffer(i, xres, yres, true);
    }
}

Effect.prototype.IsEnabledVR = function ()
{
    if (this.mRenderingStereo) return true;
    return false;
}

Effect.prototype.EnableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( this.mRenderingStereo ) return;

    this.mRenderingStereo = true;
    this.mWebVR.Enable();
}

Effect.prototype.DisableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( !this.mRenderingStereo ) return;

    this.mRenderingStereo = false;
    this.mWebVR.Disable();
}

Effect.prototype.GetTexture = function( passid, slot ) { return this.mPasses[passid].GetTexture( slot ); }
Effect.prototype.NewTexture = function (passid, slot, url) { return this.mPasses[passid].NewTexture( this.mAudioContext, slot, url, this.mBuffers, this.mCubeBuffers, this.mKeyboard ); }
Effect.prototype.SetOutputs = function( passid, slot, url ) { this.mPasses[passid].SetOutputs( slot, url ); }
Effect.prototype.SetOutputsByBufferID = function( passid, slot, id ) { this.mPasses[passid].SetOutputsByBufferID( slot, id ); }
Effect.prototype.GetAcceptsLinear = function (passid, slot) { return this.mPasses[passid].GetAcceptsLinear(slot); }
Effect.prototype.GetAcceptsMipmapping = function (passid, slot) { return this.mPasses[passid].GetAcceptsMipmapping(slot); }
Effect.prototype.GetAcceptsWrapRepeat = function (passid, slot) { return this.mPasses[passid].GetAcceptsWrapRepeat(slot); }
Effect.prototype.GetAcceptsVFlip = function (passid, slot) { return this.mPasses[passid].GetAcceptsVFlip(slot); }
Effect.prototype.SetSamplerFilter = function (passid, slot, str) { this.mPasses[passid].SetSamplerFilter(slot, str, this.mBuffers, this.mCubeBuffers); }
Effect.prototype.GetTranslatedShaderSource = function (passid) { return this.mPasses[passid].GetTranslatedShaderSource(); }
Effect.prototype.GetSamplerFilter = function (passid, slot) { return this.mPasses[passid].GetSamplerFilter(slot); }
Effect.prototype.SetSamplerWrap = function (passid, slot, str) { this.mPasses[passid].SetSamplerWrap(slot, str, this.mBuffers); }
Effect.prototype.GetSamplerWrap = function (passid, slot) { return this.mPasses[passid].GetSamplerWrap(slot); }
Effect.prototype.SetSamplerVFlip = function (passid, slot, str) { this.mPasses[passid].SetSamplerVFlip(slot, str); }
Effect.prototype.GetSamplerVFlip = function (passid, slot) { return this.mPasses[passid].GetSamplerVFlip(slot); }

Effect.prototype.GetHeaderSize = function (passid)
{
    return this.mPasses[passid].mHeaderLength + 
           this.mRenderer.GetShaderHeaderLines(1);
}

Effect.prototype.ToggleVolume = function()
{
    this.mForceMuted = !this.mForceMuted;

    // outp
    if (this.mForceMuted)
        this.mGainNode.gain.value = 0.0;
    else
        this.mGainNode.gain.value = 1.0;

    // inp
    let num = this.mPasses.length;
    for( let j=0; j<num; j++ )
    {
        for( let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            if( this.mForceMuted )
                this.mPasses[j].MuteInput( this.mAudioContext, i );
            else
                this.mPasses[j].UnMuteInput( this.mAudioContext, i );
        }
    }

    return this.mForceMuted;
}

Effect.prototype.SetKeyDown = function( passid, k )
{
    if( this.mKeyboard.mData[ k + 0*256 ] == 255 ) return;

    this.mKeyboard.mData[ k + 0*256 ] = 255;
    this.mKeyboard.mData[ k + 1*256 ] = 255;
    this.mKeyboard.mData[ k + 2*256 ] = 255 - this.mKeyboard.mData[ k + 2*256 ];
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }
}

Effect.prototype.SetKeyUp = function( passid, k )
{
    this.mKeyboard.mData[ k + 0*256 ] = 0;
    this.mKeyboard.mData[ k + 1*256 ] = 0;
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }
}

Effect.prototype.StopOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].StopOutput( wa );
    }
}

Effect.prototype.ResumeOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].ResumeOutput( wa );
    }
}

Effect.prototype.PauseInput = function( passid, id )
{
    return this.mPasses[passid].TooglePauseInput( this.mAudioContext, id );
}

Effect.prototype.ToggleMuteInput = function( passid, id )
{
    return this.mPasses[passid].ToggleMuteInput( this.mAudioContext, id );
}

Effect.prototype.RewindInput = function( passid, id )
{
    this.mPasses[passid].RewindInput( this.mAudioContext, id );
}

Effect.prototype.UpdateInputs = function( passid, forceUpdate )
{
   this.mPasses[passid].UpdateInputs( this.mAudioContext, forceUpdate, this.mKeyboard );
}

Effect.prototype.ResetTime = function()
{
    this.mFrame = 0;
    this.mAudioContext.resume()

    let num = this.mPasses.length;
    for( let i=0; i<num; i++ )
    {
        this.mPasses[i].mFrame = 0;
        for( let j=0; j<this.mPasses[i].mInputs.length; j++ )
            this.mPasses[i].RewindInput(this.mAudioContext, j)
    }
}

Effect.prototype.RequestAnimationFrame = function (id)
{
    if (this.mRenderingStereo && this.mWebVR.IsPresenting())
    {
        this.mWebVR.RequestAnimationFrame(id);
    }
    else
    {
        requestAnimFrame(id);
    }
}

Effect.prototype.Paint = function(time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, isPaused)
{
    let wa = this.mAudioContext;
    let da = new Date();
    let vrData = null; if (this.mRenderingStereo) vrData = this.mWebVR.GetData();
    let xres = this.mXres / 1;
    let yres = this.mYres / 1;

    if( this.mFrame===0 )
    {
        for( let i=0; i<this.mMaxBuffers; i++ )
        {
            if( this.mBuffers[i].mTexture[0]!==null )
            {
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[0] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[1] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
				
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[0] );
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[1] );
            }
        }
        for( let i=0; i<this.mMaxCubeBuffers; i++ )
        {
            if( this.mCubeBuffers[i].mTexture[0]!==null )
            {
                for( let face=0; face<6; face++ )
                {
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[0], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[1], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
					this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[0] );
				    this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[1] );
                }
            }
        }
    }

    let num = this.mPasses.length;

    // render sound first
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "sound" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "buffer" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;
        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="buffer" && inp.id === bufferID && inp.mInfo.mSampler.filter === "mipmap")
                {
                    needMipMaps = true;
                    break;
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render cubemap buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "cubemap" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = 0;//assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;

        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="cubemap" )
                {
                    if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0 && inp.mInfo.mSampler.filter === "mipmap" )
                    {
                        needMipMaps = true;
                        break;
                    }
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render image last
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "image" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }   

    // erase keypresses
    for (let k=0; k<256; k++ )
    {
       this.mKeyboard.mData[ k + 1*256 ] = 0;
    }
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    if( this.mRenderingStereo ) this.mWebVR.Finish();

    this.mFrame++;
}

Effect.prototype.NewShader = function( passid, preventCache, onResolve )
{
    let commonSourceCodes = [];
    for (let i=0; i<this.mPasses.length; i++ )
    {
        if( this.mPasses[i].mType==="common")
        {
            commonSourceCodes.push(this.mPasses[i].mSource);
        }
    }

    this.mPasses[passid].NewShader(commonSourceCodes, preventCache, onResolve );
}

Effect.prototype.GetNumPasses = function()
{
    return this.mPasses.length;
}

Effect.prototype.GetNumOfType = function(passtype)
{
    let id = 0;
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType===passtype )
        {
            id++;
        }
    }
    return id;
}

Effect.prototype.GetPassType = function( id ) { return this.mPasses[id].mType; }
Effect.prototype.GetPassName = function( id ) { return this.mPasses[id].mName; }
Effect.prototype.GetCode = function( id ) { return this.mPasses[id].mSource; }
Effect.prototype.SetCode = function( id, source ) { this.mPasses[id].SetCode(source); }
Effect.prototype.GetError = function (id) { return this.mPasses[id].mError; }
Effect.prototype.GetErrorStr = function (id) { return this.mPasses[id].mErrorStr; }
Effect.prototype.GetErrorGlobal = function()
{
    for (let i = 0; i < this.mPasses.length; i++)
    {
        if (this.mPasses[i].mError)
        {
            return true;
        }
    }
    return false;
}

Effect.prototype.Load = function (jobj )
{
    if (jobj.ver !== "0.1")
    {
        console.log("Wrong Format");
        return false;
    }

    let numPasses = jobj.renderpass.length;

    if( numPasses<1 || numPasses>this.mMaxPasses )
    {
        console.log("Corrupted Shader - " + numPasses);
        return false;
    }

    this.mPasses = [];
    for (let j = 0; j < numPasses; j++)
    {
        let rpass = jobj.renderpass[j];

        // skip sound passes if in thumbnail mode
        if( this.mForceMuted && rpass.type === "sound" ) continue;

        let wpass = new EffectPass(this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                   this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode,
                                   this.mProgramDownscale, j, this);

        wpass.Create(rpass.type, this.mAudioContext);

        let numInputs = rpass.inputs.length;

        for (let i = 0; i < 4; i++)
        {
            wpass.NewTexture(this.mAudioContext, i, null, null, null);
        }
        for (let i = 0; i < numInputs; i++)
        {
            let lid  = rpass.inputs[i].channel;
            let styp = rpass.inputs[i].type;
            let sid  = rpass.inputs[i].id;
            let ssrc = rpass.inputs[i].filepath;
            let psrc = rpass.inputs[i].previewfilepath;
            let samp = rpass.inputs[i].sampler;

            wpass.NewTexture(this.mAudioContext, lid, { mType: styp, mID: sid, mSrc: ssrc, mSampler: samp, mPreviewSrc: psrc }, this.mBuffers, this.mCubeBuffers, this.mKeyboard);
        }

        for (let i = 0; i < 4; i++)
        {
            wpass.SetOutputs(i, null);
        }

        let numOutputs = rpass.outputs.length;
        for (let i = 0; i < numOutputs; i++)
        {
            let outputID = rpass.outputs[i].id;
            let outputCH = rpass.outputs[i].channel;
            wpass.SetOutputs(outputCH, outputID);
        }

        // create some hardcoded names. This should come from the DB
        let rpassName = "";
        if (rpass.type === "common" ) rpassName = "Common";
        if (rpass.type === "sound"  ) rpassName = "Sound";
        if (rpass.type === "image"  ) rpassName = "Image";
        if (rpass.type === "buffer") rpassName = "Buffer " + String.fromCharCode(65 + assetID_to_bufferID(wpass.mOutputs[0]));
        if (rpass.type === "cubemap") rpassName = "Cube A";// " + String.fromCharCode(65 + assetID_to_bufferID(this.mPasses[j].mOutputs[0]));
        wpass.SetName(rpassName);
        wpass.SetCode(rpass.code);

        this.mPasses.push(wpass);
    }
    return true;
}

Effect.prototype.CompileSome = function ( passes, preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    for (let j = 0; j < passes.length; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(passes[j], preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < me.mPasses.length; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.Compile = function (preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(j, preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < numPasses; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.GetCompilationTime = function( id )
{
    return this.mPasses[id].GetCompilationTime()/1000.0;
}
Effect.prototype.GetTotalCompilationTime = function()
{
    return this.mCompilationTime/1000.0;
}

Effect.prototype.DestroyPass = function( id )
{
   this.mPasses[id].Destroy( this.mAudioContext );
   this.mPasses.splice(id, 1);
}

Effect.prototype.AddPass = function( passType, passName, onResolve )
{
    let shaderStr = null;

    if( passType==="sound"   ) shaderStr = "vec2 mainSound( int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n}";
    if( passType==="buffer"  ) shaderStr = "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}";
    if( passType==="common"  ) shaderStr = "vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}";
    if( passType==="cubemap" ) shaderStr = "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rayDir;\n\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}";

    let id = this.GetNumPasses();
    this.mPasses[id] = new EffectPass( this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                       this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode, 
                                       this.mProgramDownscale, id, this );

    this.mPasses[id].Create( passType, this.mAudioContext );
    this.mPasses[id].SetName( passName );
    this.mPasses[id].SetCode( shaderStr );
    this.NewShader(id, false, function ()
    {
        onResolve();
    });

    return { mId : id, mShader : shaderStr };
}

// this should be removed once we have MultiPass 2.0 and passes render to arbitrary buffers
Effect.prototype.IsBufferPassUsed = function( bufferID )
{
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType !== "buffer" ) continue;
        if( this.mPasses[j].mOutputs[0] === bufferID_to_assetID(bufferID) ) return true;
    }
    return false;
}

Effect.prototype.Save = function()
{
    var result = {};

    result.ver = "0.1";

    result.renderpass = [];

    let numPasses = this.mPasses.length;
    for (let j=0; j<numPasses; j++ )
    {
        result.renderpass[j] = {};

        result.renderpass[j].outputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            let outputID = this.mPasses[j].mOutputs[i];
            if( outputID===null ) continue;
            result.renderpass[j].outputs.push( { channel: i, id: outputID } );
        }
        result.renderpass[j].inputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            if( this.mPasses[j].mInputs[i]===null ) continue;
            result.renderpass[j].inputs.push( {channel: i,
                                               type    : this.mPasses[j].mInputs[i].mInfo.mType,
                                               id      : this.mPasses[j].mInputs[i].mInfo.mID,
                                               filepath: this.mPasses[j].mInputs[i].mInfo.mSrc,
                                               sampler : this.mPasses[j].mInputs[i].mInfo.mSampler });
        }

        result.renderpass[j].code = this.mPasses[j].mSource;
        result.renderpass[j].name = this.mPasses[j].mName
        result.renderpass[j].description = "";
        result.renderpass[j].type = this.mPasses[j].mType;
    }

    result.flags = this.calcFlags();

    return result;
}

Effect.prototype.calcFlags = function ()
{
    let flagVR = false;
    let flagWebcam = false;
    let flagSoundInput = false;
    let flagSoundOutput = false;
    let flagKeyboard = false;
    let flagMultipass = false;
    let flagMusicStream = false;

    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        let pass = this.mPasses[j];

        if (pass.mType === "sound") flagSoundOutput = true;
        if (pass.mType === "buffer") flagMultipass = true;

        for (let i = 0; i < 4; i++)
        {
            if (pass.mInputs[i] === null) continue;

            if (pass.mInputs[i].mInfo.mType === "webcam") flagWebcam = true;
            else if (pass.mInputs[i].mInfo.mType === "keyboard") flagKeyboard = true;
            else if (pass.mInputs[i].mInfo.mType === "mic") flagSoundInput = true;
            else if (pass.mInputs[i].mInfo.mType === "musicstream") flagMusicStream = true;
        }

        let n1 = pass.mSource.indexOf("mainVR(");
        let n2 = pass.mSource.indexOf("mainVR (");
        if (n1 > 0 || n2 > 0) flagVR = true;
    }

    return {
        mFlagVR: flagVR,
        mFlagWebcam: flagWebcam,
        mFlagSoundInput: flagSoundInput,
        mFlagSoundOutput: flagSoundOutput,
        mFlagKeyboard: flagKeyboard,
        mFlagMultipass: flagMultipass,
        mFlagMusicStream: flagMusicStream
    };
}</script>
    <script>"use strict"

const kMaxCompileTime = 10.0;

function iReportCrash(shaderID)
{
    let req = new XMLHttpRequest();
    req.onload = function ()
    {
        let jsn = req.response;
        if (jsn === null) return;
        if (jsn.result === 0)
        {
            // yep
        }
    };
    req.open("POST", "/shadertoy", true);
    req.responseType = "json";
    req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    req.send( "s=" + shaderID + "&r=2" );
}
</script>
    <script>"use strict"

var gActive = -1;
var mShaders = [];
var gNumCanvases = 0;

function myrefresh( id, slot, img, forceFrame, gui, guiID, renderID, time )
{
    if( mShaders[id].mReady===false ) return;
    if( forceFrame )
    {
        if (mShaders[id].mScreenshot === false)
        {
            mShaders[id].gEffect.Paint(mShaders[id].mTime / 1000.0, 1.0 / 60.0, 60.0, 0, 0, 0, 0, false);
        }
    }
}

function startRendering()
{
    if( gActive<0 ) return;
    if( mShaders[gActive].mReady===false ) return;
    if( mShaders[gActive].mScreenshot===true ) return;

    let time = getRealTime();

    mShaders[gActive].mFPS.Count( time );
    mShaders[gActive].mTime = mShaders[gActive].mTime0 + (time - mShaders[gActive].mTo);
    let dtime = 1000.0/60.0;
    mShaders[gActive].gEffect.Paint( mShaders[gActive].mTime/1000.0, dtime/1000.0, mShaders[gActive].mFPS.GetFPS(), 0,0,0,0, false);

    requestAnimFrame( startRendering );
}

function iLoadAndCompile(jsn, i )
{
    var shaderObj = jsn[i];
    if (shaderObj === null) return;

    var resizeCB = function (xres, yres) { myrefresh(i, 0, null, true, false, 0, -1.0) };
    var crashCB = function () { alert('crash');/*iReportCrash(gShaderIDs[i])*/ };
    mShaders[i].gEffect = new Effect(null, null, mShaders[i].mPreview.mCanvas, myrefresh, i, true, true, resizeCB, crashCB);

    if (!mShaders[i].gEffect.Load(shaderObj)) return;

    mShaders[i].gEffect.Compile(false, function (worked)
    {
        if (worked === true)
        {
            previewShowRender(mShaders[i].mPreview);

            mShaders[i].mScreenshot = false;
            mShaders[i].mReady = true;
            mShaders[i].mTime = 10.0 * 1000.0;
            mShaders[i].mTime0 = 0.0;
            mShaders[i].mTo = 0.0;
            mShaders[i].mFPS = piCreateFPSCounter();
            mShaders[i].mPreview.mCanvas.addEventListener("mouseout", function (ev) { gActive = -1; }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseover", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.add('isVisible'); }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseout", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.remove('isVisible'); }, true);
            mShaders[i].mPreview.mCanvas.addEventListener("mouseover", function (ev)
            {
                let ele = piGetSourceElement(ev);
                if (ele.mId === undefined) return;

                gActive = ele.mId;
                if (!mShaders[gActive].mReady) return;
                let time = getRealTime();
                mShaders[gActive].mTo = time;
                mShaders[gActive].mTime0 = mShaders[gActive].mTime;
                mShaders[gActive].mFPS.Reset(time);

                startRendering();
            }, true);


            /*
            let compilationTime = mShaders[i].gEffect.GetTotalCompilationTime();
            if (compilationTime > kMaxCompileTime)
            {
                iReportCrash(mShaders[i].mShaderID);
            }*/

            myrefresh(i, null, null, true, false, 0, -1.0);
        }
        else
        {
            mShaders[i].mReady = false;
            previewShowError(mShaders[i].mPreview);
        }
    });
};


function iProcessShader( jsn, i )
{
    var shaderObj = jsn[i];
    if( shaderObj===null ) return;

    if ((shaderObj.info.usePreview === 0 && !gUseScreenshots) || (mShaders[i].mPreviewReady !== 1))
    {
        iLoadAndCompile(jsn, i);
    }
    else
    {
        mShaders[i].mScreenshot = true;
        if( shaderObj.info.usePreview === 1 )
            previewShowScreenshot(mShaders[i].mPreview, 1); // comp
        else if (gUseScreenshots)
            previewShowScreenshot(mShaders[i].mPreview, 2); // sett
    }

    if( i<(jsn.length-1) ) setTimeout( function(){iProcessShader(jsn,i+1);}, 10 );
}

function iInitUI(numCanvases, uiCallback, windowTitle)
{
    gNumCanvases = numCanvases;
    document.getElementById("mySearch").focus();

    //-----------------------------------------------------------------
    // window
    //-----------------------------------------------------------------
    if (windowTitle !== null) {
        document.title = windowTitle;
    }

    //-----------------------------------------------------------------
    // ui
    //-----------------------------------------------------------------
    var num = Math.min(gShaders.length, gNumCanvases);

    //var base = document.getElementsByClassName( "searchResult" );

    for (let i = 0; i < gNumCanvases; i++)
    {
        let pv = createPreview(i);

        if (i >= num) {
            previewHide(pv);
            continue;
        }

        let shaderID = gShaders[i].info.id;
        
        if (pv.mUI !== null && uiCallback !== null) {
            pv.mUI.addEventListener('click', function (ev) {
                uiCallback(shaderID);
                ev.preventDefault();
            }, false);
        }
        
        previewShowLoading(pv);
        
        mShaders[i] = {};
        mShaders[i].mShaderID = shaderID;
        mShaders[i].mPreview = pv;
        mShaders[i].mScreenshot = false;
        mShaders[i].mPreview.mLink.href = "/view/" + shaderID;
        mShaders[i].mPreviewReady = 0;
        mShaders[i].mReady = false;
        mShaders[i].gEffect = null;

        previewLoadScreenshot(mShaders[i].mPreview,
            function () { mShaders[i].mPreviewReady = 1; if (mShaders[i].mReady === false) previewShowScreenshot(mShaders[i].mPreview, 0); },
            function () { mShaders[i].mPreviewReady = 2; },
            shaderID);
    }

    if (num <= 0) {
        return;
    }
}

function iInitShaders(jsn)
{
    for (let i = 0; i < jsn.length; i++)
    {
        let shaderObj = jsn[i];
        if (shaderObj === null) continue;
        let inf = shaderObj.info;
        mShaders[i].mPreview.mTextA.textContent = inf.name;
        mShaders[i].mPreview.mTextB.innerHTML = "<a class='user' href='/user/" + htmlEntities(inf.username) + "'>" + htmlEntities(inf.username) + "</a>";
        mShaders[i].mPreview.mTextC.innerHTML = "<img src='/img/themes/" + gThemeName + "/views.png' class='viewsIcon'></img>" + inf.viewed + "    &nbsp;&nbsp;  <img src='/img/themes/" + gThemeName + "/likes.png' class='likesIcon'></img>" + inf.likes;
    }

    setTimeout(function () { iProcessShader(jsn, 0); }, 10);
}

function resultsInitStatic(numCanvases, uiCallback, windowTitle)
{
    iInitUI(numCanvases, uiCallback, windowTitle);

    iInitShaders(gShaders);
}

function resultsInit(numCanvases, uiCallback, windowTitle)
{	
    iInitUI(numCanvases, uiCallback, windowTitle);

    var num = Math.min(gShaderIDs.length, gNumCanvases);

    var mHttpReq = new XMLHttpRequest();

    mHttpReq.abort();

    var str = "{ \"shaders\" : [";
    for( let i=0; i<num; i++ )
    {
         str += "\"" + gShaderIDs[i] + "\"";
         if( i!==(num-1) ) str += ", ";
    }
    str += "] }";

    str = "s=" + encodeURIComponent( str ) + "&nt=0&nl=0&np=0";

    mHttpReq.open( "POST", "/shadertoy", true );
    mHttpReq.responseType = "json";
    mHttpReq.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    mHttpReq.onload = function ()
    {
        let jsn = this.response;
        if( jsn===null )
        {
            console.log( "Could not load shaders" );
            return;
        }

        iInitShaders(jsn);
    }
    mHttpReq.send( str );
}</script>
    <style>
    .shaderPreview
    {
    display: block;
    background-color: #000000;
    background-image: url("/img/loading.gif");
    background-repeat: no-repeat;
    background-position: center;
    padding: 0px;
    margin: 0px;
    border: 0px solid #000000;
    border-radius: 8px;
    width:100%;
    height:100%;
    position: absolute;
    overflow:hidden;
    }

    .previewInfo
    {
    width: 100%;
    left: 0px;
    top: 2px;
    position: relative;
    visibility: hidden;
    }

    .previewCanvas
    {
    left: 0px;
    top: 0px;
    padding: 0px;
    margin: 0px;
    position: absolute;
    cursor: pointer;
    width:100%;
    height:100%;
    border-radius: 8px;
    border: 0px solid #000000;
    backgroundColor: transparent;
visibility: hidden;
opacity:0;
transition: opacity 1.0s ease;
    }

    .previewText
    {
        text-overflow: ellipsis;
    white-space: nowrap;
    padding-right: 1px;
    }

    .previewTextUser
    {
    text-overflow: ellipsis;
    white-space: nowrap;
    padding-left: 3px;
    }

    .previewStats
    {
    padding-right: 1px;
    right: 0px;
    top: 0px;
    position: absolute;
    }

    .previewErrorContainer
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    visibility:hidden;
    }

    .previewErrorMessage
    {
    top:50%;
    position:absolute;
    width:100%;
    text-align:center;
    padding:0;
    margin:auto;
    color:#ff0000;
    font-size:2em;
    font-style:italic;
    }

    .previewNoGLContainter
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    position:absolute;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    pointer-events:none;
    visibility:hidden;
    font-size:2em;
    }

    .previewNoGLMessage
    {
    width:86%;
    height:90%;
    padding-left:7%;
    padding-right:7%;
    padding-top:10%;
    padding-bottom:0px;
    color:#ff0000;
    position:absolute;
    visibility:hidden;
    }

    .previewThumbnailContainer
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    visibility:hidden;
    border-radius:8px;
    border:0px solid #000000;
    }

    .previewThumbnailImage
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    border-radius:8px;
    border:0px solid #000000;
opacity: 0.0;
transition: opacity 1.0s ease;
    }

    .previewThumbnailIcon
    {
    width:64px;
    height:32px;
    left:0px;
    top:0px;
    padding:0px;
    padding-top:12px;
    margin:0px;
    position:absolute;
    color:#ffffff;
    background-color:#ff8020;
    font-weight:bold;
    border-radius:0px 0px 8px 0px;
    text-align:center;
    //visibility:hidden;
    }


    .previewUIContainter
    {
    display: block;
    right:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    //cursor:pointer;
    //pointer-events:none;
    //visibility:hidden;
    }
</style>

<script>
    function previewHide(me)
    {
    me.mBase.style.visibility = "hidden";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";
    }

    function previewShowRender(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "visible";
me.mCanvas.style.opacity = 1.0;
    me.mCanvas.style.borderRadius ="8px;";
//  me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    }

    function previewShowScreenshot(me, message)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "visible";
me.mThumbnailImg.style.opacity = 1.0;
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    me.mThumbnailWar1.style.visibility = (message===1)?"visible":"hidden";
    me.mThumbnailWar2.style.visibility = (message===2)?"visible":"hidden";
    }

    function previewShowLoading(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";

    me.mLink.style.visibility = "visible";
    me.mBase.style.backgroundColor = "#ff0000;"
    me.mCont.style.visibility = "visible";
    }

    function previewShowNoWebGL(me, shaderID)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "visible";
    me.mError.style.visibility = "visible";
    me.mThumbnailImgNoWebGL.onerror = function(ev) 
                                      { 
                                            me.mThumbnailImgNoWebGL.style.visibility="hidden"; 
                                            me.mMessageNoWebGL.style.visibility="visible"; 
                                      };
    me.mThumbnailImgNoWebGL.src = "/media/shaders/" + shaderID + ".jpg";
    }

    function previewShowError(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "visible";
    me.mCont.style.visibility = "visible";
    }

    function previewLoadScreenshot( me, cbSuccess, cbError, shaderID )
    {
    var url = "/media/shaders/" + shaderID + ".jpg";
    me.mThumbnailImg.onload = cbSuccess;
    me.mThumbnailImg.onerror = function(ev) { cbError(); };
    me.mThumbnailImg.src = url;
    }
        
    function createPreview(id)
    {
        var bar = document.getElementById( "Preview_"+id+"_Canvas" );
        bar.width = bar.offsetWidth;
        bar.height = bar.offsetHeight;
        bar.mId = id;

        return { mBase: document.getElementById( "Preview_"+id+"_Container" ),
        mLink: document.getElementById( "Preview_"+id+"_Link" ),
        mCanvas: bar,
        mCont: document.getElementById( "Preview_"+id+"_Info" ),
        mTextA: document.getElementById( "Preview_"+id+"_Text" ),
        mTextB: document.getElementById( "Preview_"+id+"_TextUser" ),
        mTextC: document.getElementById( "Preview_"+id+"_Stats" ),
        mNoWebGL: document.getElementById( "Preview_"+id+"_NoWebGL" ),
        mError: document.getElementById( "Preview_"+id+"_Error" ),
        mCanvas2D: document.getElementById( "Preview_"+id+"_Thumnail" ),
        mThumbnailImg: document.getElementById( "Preview_"+id+"_ThumnailImage" ),
        mThumbnailWar1: document.getElementById( "Preview_"+id+"_ThumnailWarning1" ),
        mThumbnailWar2: document.getElementById( "Preview_"+id+"_ThumnailWarning2" ),
        mThumbnailImgNoWebGL: document.getElementById( "Preview_"+id+"_ThumnailImageNoWebGL" ),
        mMessageNoWebGL: document.getElementById( "Preview_"+id+"_MessageNoWebGL"),
        mUI: document.getElementById( "Preview_"+id+"_UI" )
        };
    }
</script>

    <style>

    div#shaderGrid
    {
        width:100%;
        padding:0px;
        margin:0px;
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        grid-template-rows: repeat(3, 1fr);
        grid-column-gap: 64px;
        grid-row-gap: 24px;
    }
    .searchResult
    {
        margin: 0px;
        padding: 0px;
        width: 100%;
    }
    .searchResultContainer
    {
        width: 100%;
        padding-bottom:56.25%;
        height: 0;
        position: relative;
    }
    .navigation
    {
        display:flex;
        align-items:center;
    }
    div#navBottom
    {
        display:none;
        justify-content:center;
    }
    a.pageButtons, .pageButtonsCurrent
    {
        border-style: solid;
        border-width: 1px;
        border-color: #808080;
        text-align: center;
        vertical-align: middle;
        margin-left: 12px;
        display: inline-block;
        border-radius: 4px;
		font-weight:bold;
        cursor: pointer;
        padding-bottom:5px;
        padding-top:4px;
        padding-left: 8px;
        padding-right: 8px;
        margin:8px;
    }
    a.pageButtons
    {
        text-decoration: none;
        -moz-transition:    background-color 0.15s linear, color 0.15s linear;
        -webkit-transition: background-color 0.15s linear, color 0.15s linear;
        transition:         background-color 0.15s linear, color 0.15s linear;
    }
    a.pageButtons:hover
    {
      background-color:#808080;
      color : #ff8020;
    }
    .pageButtonsCurrent
    {
        background-color: #808080;
        color:#000000;
    }
    div#controls
    {
        width:100%;
        padding-top:16px;
        padding-bottom:16px;
        display:flex;
        justify-content:space-between; 
        flex-wrap:wrap;
    }
    div#controls > div
    {
        display:inline-flex;
    }
    .controlOptions
    {
        display:inline-block;
    }

    /* ----------------------- media resolutions ------------------------ */

    @media screen and (max-width:799px) 
    {
        div#shaderGrid  { grid-template-columns: 1fr; grid-template-rows: repeat(12, 1fr); grid-column-gap: 0px; grid-row-gap: 16px; }
        div#controls
        {
            width:100%;
            display:flex;
            justify-content:flex-start; 
            flex-wrap:wrap;
        }
        div#controls > div
        {
            display:inline-flex;
            width:100%;
            margin-left: 0px;
            margin-right: 0px;
            padding-bottom:16px;
        }
        div#navBottom
        {
            display: flex;
        }
    }
    
    </style>
    <script>
    var gShaders=[{"ver":"0.1","info":{"id":"XlsGRs","date":"1424377905","viewed":14120,"name":"jetstream","username":"srtuss","description":"something i made some moths ago, when i was experimenting with volumetric stuff.","likes":331,"published":1,"flags":0,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\/\/ srtuss, 2015\n\/\/\n\/\/ Volumetric cloud tunnel, a single light source, lightning and raindrops.\n\/\/\n\/\/ The code is a bit messy, but in this case it's visuals that count. :P\n\n\n#define pi 3.1415926535897932384626433832795\n\nstruct ITSC\n{\n\tvec3 p;\n\tfloat dist;\n\tvec3 n;\n    vec2 uv;\n};\n\nITSC raycylh(vec3 ro, vec3 rd, vec3 c, float r)\n{\n\tITSC i;\n\ti.dist = 1e38;\n\tvec3 e = ro - c;\n\tfloat a = dot(rd.xy, rd.xy);\n\tfloat b = 2.0 * dot(e.xy, rd.xy);\n\tfloat cc = dot(e.xy, e.xy) - r;\n\tfloat f = b * b - 4.0 * a * cc;\n\tif(f > 0.0)\n\t{\n\t\tf = sqrt(f);\n\t\tfloat t = (-b + f) \/ (2.0 * a);\n\t\t\n\t\tif(t > 0.001)\n\t\t{\n\t\t\ti.dist = t;\n\t\t\ti.p = e + rd * t;\n\t\t\ti.n = -vec3(normalize(i.p.xy), 0.0);\n\t\t}\n\t}\n\treturn i;\n}\n\nvoid tPlane(inout ITSC hit, vec3 ro, vec3 rd, vec3 o, vec3 n, vec3 tg, vec2 si)\n{\n    vec2 uv;\n    ro -= o;\n    float t = -dot(ro, n) \/ dot(rd, n);\n    if(t < 0.0)\n        return;\n    vec3 its = ro + rd * t;\n    uv.x = dot(its, tg);\n    uv.y = dot(its, cross(tg, n));\n    if(abs(uv.x) > si.x || abs(uv.y) > si.y)\n        return;\n    \n    \/\/if(t < hit.dist)\n    {\n        hit.dist = t;\n        hit.uv = uv;\n    }\n    return;\n}\n\n\nfloat hsh(float x)\n{\n    return fract(sin(x * 297.9712) * 90872.2961);\n}\n\nfloat nseI(float x)\n{\n    float fl = floor(x);\n    return mix(hsh(fl), hsh(fl + 1.0), smoothstep(0.0, 1.0, fract(x)));\n}\n\nvec2 rotate(vec2 p, float a)\n{\n\treturn vec2(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));\n}\n\nfloat nse3d(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f * f * (3.0 - 2.0 * f);\n\tvec2 uv = (p.xy + vec2(37.0, 17.0) * p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+.5)\/256., 0.).yx;\n\treturn mix(rg.x, rg.y, f.z);\n}\n\nfloat nse(vec2 p)\n{\n    return texture(iChannel0, p).x;\n}\n\nfloat density2(vec2 p, float z, float t)\n{\n    float v = 0.0;\n    float fq = 1.0, am = 0.5, mvfd = 1.0;\n    vec2 rnd = vec2(0.3, 0.7);\n    for(int i = 0; i < 7; i++)\n    {\n        rnd = fract(sin(rnd * 14.4982) * 2987253.28612);\n        v += nse(p * fq + t * (rnd - 0.5)) * am;\n        fq *= 2.0;\n        am *= 0.5;\n        mvfd *= 1.3;\n    }\n    return v * exp(z * z * -2.0);\n}\n\nfloat densA = 1.0, densB = 2.0;\n\nfloat fbm(vec3 p)\n{\n    vec3 q = p;\n    \/\/q.xy = rotate(p.xy, iTime);\n    \n    p += (nse3d(p * 3.0) - 0.5) * 0.3;\n    \n    \/\/float v = nse3d(p) * 0.5 + nse3d(p * 2.0) * 0.25 + nse3d(p * 4.0) * 0.125 + nse3d(p * 8.0) * 0.0625;\n    \n    \/\/p.y += iTime * 0.2;\n    \n    float mtn = iTime * 0.15;\n    \n    float v = 0.0;\n    float fq = 1.0, am = 0.5;\n    for(int i = 0; i < 6; i++)\n    {\n        v += nse3d(p * fq + mtn * fq) * am;\n        fq *= 2.0;\n        am *= 0.5;\n    }\n    return v;\n}\n\nfloat fbmHQ(vec3 p)\n{\n    vec3 q = p;\n    q.xy = rotate(p.xy, iTime);\n    \n    p += (nse3d(p * 3.0) - 0.5) * 0.4;\n    \n    \/\/float v = nse3d(p) * 0.5 + nse3d(p * 2.0) * 0.25 + nse3d(p * 4.0) * 0.125 + nse3d(p * 8.0) * 0.0625;\n    \n    \/\/p.y += iTime * 0.2;\n    \n    float mtn = iTime * 0.2;\n    \n    float v = 0.0;\n    float fq = 1.0, am = 0.5;\n    for(int i = 0; i < 9; i++)\n    {\n        v += nse3d(p * fq + mtn * fq) * am;\n        fq *= 2.0;\n        am *= 0.5;\n    }\n    return v;\n}\n\nfloat density(vec3 p)\n{\n    vec2 pol = vec2(atan(p.y, p.x), length(p.yx));\n    \n    float v = fbm(p);\n    \n    float fo = (pol.y - 1.5);\/\/(densA + densB) * 0.5);\n    \/\/fo *= (densB - densA);\n    v *= exp(fo * fo * -5.0);\n    \n    float edg = 0.3;\n    return smoothstep(edg, edg + 0.1, v);\n}\n\nfloat densityHQ(vec3 p)\n{\n    vec2 pol = vec2(atan(p.y, p.x), length(p.yx));\n    \n    float v = fbmHQ(p);\n    \n    float fo = (pol.y - 1.5);\/\/(densA + densB) * 0.5);\n    \/\/fo *= (densB - densA);\n    v *= exp(fo * fo * -5.0);\n    \n    float edg = 0.3;\n    return smoothstep(edg, edg + 0.1, v);\n}\n\nvec2 drop(inout vec2 p)\n{\n    vec2 mv = iTime * vec2(0.5, -1.0) * 0.15;\n    \n    float drh = 0.0;\n    float hl = 0.0;\n    \n    vec4 rnd = vec4(0.1, 0.2, 0.3, 0.4);\n    for(int i = 0; i < 20; i++)\n    {\n        rnd = fract(sin(rnd * 2.184972) * 190723.58961);\n        float fd = fract(iTime * 0.2 + rnd.w);\n        fd = exp(fd * -4.0);\n        float r = 0.025 * (rnd.w * 1.5 + 1.0);\n        float sz = 0.35;\n        \n        \n        vec2 q = (fract((p - mv) * sz + rnd.xy) - 0.5) \/ sz;\n        mv *= 1.06;\n        \n        q.y *= -1.0;\n        float l = length(q + pow(abs(dot(q, vec2(1.0, 0.4))), 0.7) * (fd * 0.2 + 0.1));\n        if(l < r)\n        {\n        \tfloat h = sqrt(r * r - l * l);\n        \tdrh = max(drh, h * fd);\n        }\n        hl += exp(length(q - vec2(-0.02, 0.01)) * -30.0) * 0.4 * fd;\n    }\n    p += drh * 5.0;\n    return vec2(drh, hl);\n}\n\n\nfloat hash1(float p)\n{\n\treturn fract(sin(p * 172.435) * 29572.683) - 0.5;\n}\n\nfloat hash2(vec2 p)\n{\n\tvec2 r = (456.789 * sin(789.123 * p.xy));\n\treturn fract(r.x * r.y * (1.0 + p.x));\n}\n\nfloat ns(float p)\n{\n\tfloat fr = fract(p);\n\tfloat fl = floor(p);\n\treturn mix(hash1(fl), hash1(fl + 1.0), fr);\n}\n\nfloat fbm(float p)\n{\n\treturn (ns(p) * 0.4 + ns(p * 2.0 - 10.0) * 0.125 + ns(p * 8.0 + 10.0) * 0.025);\n}\n\nfloat fbmd(float p)\n{\n\tfloat h = 0.01;\n\treturn atan(fbm(p + h) - fbm(p - h), h);\n}\n\nfloat arcsmp(float x, float seed)\n{\n\treturn fbm(x * 3.0 + seed * 1111.111) * (1.0 - exp(-x * 5.0));\n}\n\nfloat arc(vec2 p, float seed, float len)\n{\n\tp *= len;\n\t\/\/p = rotate(p, iTime);\n\tfloat v = abs(p.y - arcsmp(p.x, seed));\n\tv += exp((2.0 - p.x) * -4.0);\n\tv = exp(v * -60.0) + exp(v * -10.0) * 0.6;\n\t\/\/v += exp(p.x * -2.0);\n\tv *= smoothstep(0.0, 0.05, p.x);\n\treturn v;\n}\n\nfloat arcc(vec2 p, float sd)\n{\n\tfloat v = 0.0;\n\tfloat rnd = fract(sd);\n\tfloat sp = 0.0;\n\tv += arc(p, sd, 1.0);\n\tfor(int i = 0; i < 4; i ++)\n\t{\n\t\tsp = rnd + 0.01;\n\t\tvec2 mrk = vec2(sp, arcsmp(sp, sd));\n\t\tv += arc(rotate(p - mrk, fbmd(sp)), mrk.x, mrk.x * 0.4 + 1.5);\n\t\trnd = fract(sin(rnd * 195.2837) * 1720.938);\n\t}\n\treturn v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    \n    uv = 2.0 * uv - 1.0;\n    uv.x *= iResolution.x \/ iResolution.y;\n    \n    vec2 drh = drop(uv);\n    \n    float camtm = iTime * 0.15;\n    vec3 ro = vec3(cos(camtm), 0.0, camtm);\n    vec3 rd = normalize(vec3(uv, 1.2));\n    rd.xz = rotate(rd.xz, sin(camtm) * 0.4);\n    rd.yz = rotate(rd.yz, sin(camtm * 1.3) * 0.4);\n    \n    vec3 sun = normalize(vec3(0.2, 1.0, 0.1));\n    \n    float sd = sin(fragCoord.x * 0.01 + fragCoord.y * 3.333333333 + iTime) * 1298729.146861;\n    \n    vec3 col;\n    float dacc = 0.0, lacc = 0.0;\n    \n    vec3 light = vec3(cos(iTime * 8.0) * 0.5, sin(iTime * 4.0) * 0.5, ro.z + 4.0 + sin(iTime));\n    \n    ITSC tunRef;\n    #define STP 15\n    for(int i = 0; i < STP; i++)\n    {\n        ITSC itsc = raycylh(ro, rd, vec3(0.0), densB + float(i) * (densA - densB) \/ float(STP) + fract(sd) * 0.07);\n        float d = density(itsc.p);\n        vec3 tol = light - itsc.p;\n        float dtol = length(tol);\n        tol = tol * 0.1 \/ dtol;\n        \n        float dl = density(itsc.p + tol);\n        lacc += max(d - dl, 0.0) * exp(dtol * -0.2);\n        dacc += d;\n        tunRef = itsc;\n    }\n    dacc \/= float(STP);\n    ITSC itsc = raycylh(ro, rd, vec3(0.0), 4.0);\n    vec3 sky = vec3(0.6, 0.3, 0.2);\n    sky *= 0.9 * pow(fbmHQ(itsc.p), 2.0);\n    lacc = max(lacc * 0.3 + 0.3, 0.0);\n    vec3 cloud = pow(vec3(lacc), vec3(0.7, 1.0, 1.0) * 1.0);\n    col = mix(sky, cloud, dacc);\n    col *= exp(tunRef.dist * -0.1);\n    col += drh.y;\n    \n    vec4 rnd = vec4(0.1, 0.2, 0.3, 0.4);\n    float arcv = 0.0, arclight = 0.0;\n    for(int i = 0; i < 3; i++)\n    {\n        float v = 0.0;\n        rnd = fract(sin(rnd * 1.111111) * 298729.258972);\n        float ts = rnd.z * 4.0 * 1.61803398875 + 1.0;\n        float arcfl = floor(iTime \/ ts + rnd.y) * ts;\n        float arcfr = fract(iTime \/ ts + rnd.y) * ts;\n        \n        ITSC arcits;\n        arcits.dist = 1e38;\n        float arca = rnd.x + arcfl * 2.39996;\n        float arcz = ro.z + 1.0 + rnd.x * 12.0;\n        tPlane(arcits, ro, rd, vec3(0.0, 0.0, arcz), vec3(0.0, 0.0, -1.0), vec3(cos(arca), sin(arca), 0.0), vec2(2.0));\n\n        float arcseed = floor(iTime * 17.0 + rnd.y);\n        if(arcits.dist < 20.0)\n        {\n            arcits.uv *= 0.8;\n            v = arcc(vec2(1.0 - abs(arcits.uv.x), arcits.uv.y * sign(arcits.uv.x)) * 1.4, arcseed * 0.033333);\n        }\n\t\tfloat arcdur = rnd.x * 0.2 + 0.05;\n        float arcint = smoothstep(0.1 + arcdur, arcdur, arcfr);\n        v *= arcint;\n        arcv += v;\n        arclight += exp(abs(arcz - tunRef.p.z) * -0.3) * fract(sin(arcseed) * 198721.6231) * arcint;\n    }\n    vec3 arccol = vec3(0.9, 0.7, 0.7);\n    col += arclight * arccol * 0.5;\n    col = mix(col, arccol, clamp(arcv, 0.0, 1.0));\n    col = pow(col, vec3(1.0, 0.8, 0.5) * 1.5) * 1.5;\n    col = pow(col, vec3(1.0 \/ 2.2));\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"lsXGz8","date":"1362214766","viewed":14048,"name":"Input - Time","username":"iq","description":"Simple realtime, real time, watch. The background changes with the time of day - dark grey at night, and blue during the day :)","likes":110,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[],"code":"\/\/ Created by inigo quilez - iq\/2013\n\/\/   https:\/\/www.youtube.com\/c\/InigoQuilez\n\/\/   https:\/\/iquilezles.org\/\n\/\/ I share this piece (art and code) here in Shadertoy and through its Public API, only for educational purposes. \n\/\/ You cannot use, sell, share or host this piece or modifications of it as part of your own commercial or non-commercial product, website or project.\n\/\/ You can share a link to it or an unmodified screenshot of it provided you attribute \"by Inigo Quilez, @iquilezles and iquilezles.org\". \n\/\/ If you are a teacher, lecturer, educator or similar and these conditions are too restrictive for your needs, please contact me and we'll work it out.\n\n\n\/\/ See also:\n\/\/\n\/\/ Input - Keyboard    : https:\/\/www.shadertoy.com\/view\/lsXGzf\n\/\/ Input - Microphone  : https:\/\/www.shadertoy.com\/view\/llSGDh\n\/\/ Input - Mouse       : https:\/\/www.shadertoy.com\/view\/Mss3zH\n\/\/ Input - Sound       : https:\/\/www.shadertoy.com\/view\/Xds3Rr\n\/\/ Input - SoundCloud  : https:\/\/www.shadertoy.com\/view\/MsdGzn\n\/\/ Input - Time        : https:\/\/www.shadertoy.com\/view\/lsXGz8\n\/\/ Input - TimeDelta   : https:\/\/www.shadertoy.com\/view\/lsKGWV\n\/\/ Inout - 3D Texture  : https:\/\/www.shadertoy.com\/view\/4llcR4\n\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nvec3 line( in vec3 buf, in vec2 a, in vec2 b, in vec2 p, in vec2 w, in vec4 col )\n{\n   float f = sdLine( p, a, b );\n   float g = fwidth(f)*w.y;\n   return mix( buf, col.xyz, col.w*(1.0-smoothstep(w.x-g, w.x+g, f)) );\n}\n\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*43758.5453123); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ get time\n    float mils = fract(iDate.w);\n\tfloat secs = mod( floor(iDate.w),        60.0 );\n\tfloat mins = mod( floor(iDate.w\/60.0),   60.0 );\n\tfloat hors = mod( floor(iDate.w\/3600.0), 24.0 );\n    \n    \/\/ enable this for subsecond resolution\n    \/\/secs += mils;\n\n\tvec2 uv = (2.0*fragCoord.xy-iResolution.xy)\/min(iResolution.y,iResolution.x);\n\n\tfloat r = length( uv );\n\tfloat a = atan( uv.y, uv.x )+3.1415926;\n    \n\t\/\/ background color\n\tvec3 nightColor = vec3( 0.2, 0.2, 0.2 ) + 0.1*uv.y;\n\tvec3 dayColor   = vec3( 0.5, 0.6, 0.7 ) + 0.2*uv.y;\n\tvec3 col = mix( nightColor, dayColor, smoothstep( 5.0, 7.0, hors ) - \n\t\t\t\t                          smoothstep(19.0,21.0, hors ) );\n\n    \/\/ inner watch body\t\n\tcol = mix( col, vec3(0.9-0.4*pow(r,4.0)), 1.0-smoothstep(0.94,0.95,r) );\n\n    \/\/ 5 minute marks\t\n\tfloat f = abs(2.0*fract(0.5+a*60.0\/6.2831)-1.0);\n\tfloat g = 1.0-smoothstep( 0.0, 0.1, abs(2.0*fract(0.5+a*12.0\/6.2831)-1.0) );\n\tfloat w = fwidth(f);\n\tf = 1.0 - smoothstep( 0.1*g+0.05-w, 0.1*g+0.05+w, f );\n\tf *= smoothstep( 0.85, 0.86, r+0.05*g ) - smoothstep( 0.94, 0.95, r );\n\tcol = mix( col, vec3(0.0), f );\n\n\t\/\/ seconds hand\n\tvec2 dir;\n\tdir = vec2( sin(6.2831*secs\/60.0), cos(6.2831*secs\/60.0) );\n    col = line( col, vec2(0.0), dir*0.9, uv+0.05, vec2(0.005,4.0), vec4(0.0,0.0,0.0,0.2) );\n    col = line( col, vec2(0.0), dir*0.0, uv+0.05, vec2(0.055,4.0), vec4(0.0,0.0,0.0,0.2) ); \n    col = line( col, vec2(0.0), dir*0.9, uv,      vec2(0.005,1.0), vec4(0.5,0.0,0.0,1.0) );\n\n\t\/\/ minutes hand\n\tdir = vec2( sin(6.2831*mins\/60.0), cos(6.2831*mins\/60.0) );\n    col = line( col, vec2(0.0), dir*0.7, uv+0.05, vec2(0.015,4.0), vec4(0.0,0.0,0.0,0.2) );\n    col = line( col, vec2(0.0), dir*0.7, uv,      vec2(0.015,1.0), vec4(0.0,0.0,0.0,1.0) );\n\n    \/\/ hours hand\n\tdir = vec2( sin(6.2831*hors\/12.0), cos(6.2831*hors\/12.0) );\n    col = line( col, vec2(0.0), dir*0.4, uv+0.05, vec2(0.015,4.0), vec4(0.0,0.0,0.0,0.2) );\n    col = line( col, vec2(0.0), dir*0.4, uv,      vec2(0.015,1.0), vec4(0.0,0.0,0.0,1.0) );\n\n    \/\/ center mini circle\t\n\tcol = mix( col, vec3(0.5), 1.0-smoothstep(0.050,0.055,r) );\n\tcol = mix( col, vec3(0.0), 1.0-smoothstep(0.005,0.01,abs(r-0.055)) );\n\n    \/\/ border of watch\n\tcol = mix( col, vec3(0.0), 1.0-smoothstep(0.01,0.02,abs(r-0.95)) );\n\n    \/\/ dithering    \n    col += (1.0\/255.0)*hash3(uv.x+13.0*uv.y);\n\n\tfragColor = vec4( col,1.0 );\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"wlVSDK","date":"1584688580","viewed":14048,"name":"Danger Noodle","username":"BigWIngs","description":"Watch fullscreen with sound. Use mouse to look around.","likes":211,"published":3,"flags":64,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"\/media\/a\/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"\/media\/ap\/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"\/media\/a\/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"\/media\/ap\/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XtS3DR","filepath":"https:\/\/soundcloud.com\/extasis_demencial\/jungle-sounds","previewfilepath":"https:\/\/soundcloud.com\/extasis_demencial\/jungle-sounds","type":"musicstream","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0},{"id":"4tS3DR","filepath":"https:\/\/soundcloud.com\/liam-seagrave\/pandemic-prologue-slow-strings-suspense-music-original-horror-piano-composition","previewfilepath":"https:\/\/soundcloud.com\/liam-seagrave\/pandemic-prologue-slow-strings-suspense-music-original-horror-piano-composition","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ \"Danger Noodle\" by Martijn Steinrucken aka BigWings\/CountFrolic - 2020\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/ \n\/\/ Email: countfrolic@gmail.com\n\/\/ Twitter: @The_ArtOfCode\n\/\/ YouTube: youtube.com\/TheArtOfCodeIsCool\n\/\/\n\/\/ Ever since I did a snake scale effect as one of my first ShaderToys\n\/\/ I have been wanting to do a snake, so here it is.\n\/\/\n\/\/ Watch full screen with sound!\n\n#define MAX_STEPS 200\n#define MAX_DIST 60.\n#define SURF_DIST .01\n\n#define CAM_MOVE 1.\n\n#define S smoothstep\n\n#define MAT_TONGUE 1.\n#define MAT_HEAD 2.\n#define MAT_BODY 3.\n#define MAT_EYE 4.\n\n\/\/ From Dave Hoskins\nvec2 Hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat Hash21(vec2 p) {\n\tp = fract(p*vec2(123.1031, 324.1030));\n    p += dot(p, p+33.33);\n    return fract(p.x*p.y);\n}\n\nfloat sabs(float x,float k) {\n    float a = (.5\/k)*x*x+k*.5;\n    float b = abs(x);\n    return b<k ? a : b;\n}\n\nvec2 RaySphere(vec3 ro, vec3 rd, vec4 s) {\n\tfloat t = dot(s.xyz-ro, rd);\n    vec3 p = ro + rd * t;\n    \n    float y = length(s.xyz-p);\n    \n    vec2 o = vec2(MAX_DIST,MAX_DIST);\n    \n    if(y<s.w) {\n    \tfloat x = sqrt(s.w*s.w-y*y);\n        o.x = t-x;\n        o.y = t+x;\n    }\n    \n    return o;\n}\n\n\/\/ From IQ\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)\/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k) {\n\treturn smin(a, b, -k);\n}\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias) {\n\tp *= scale;\n    return abs(dot(sin(p), cos(p.zxy))+bias)\/scale - thickness;\n}\n\nfloat sdSph(vec3 p, vec3 pos, vec3 squash, float r) {\n    squash = 1.\/squash;\n\tp = (p-pos)*squash;\n    return (length(p)-r)\/max(squash.x, max(squash.y, squash.z));\n}\n\n\nvec4 Scales(vec2 uv, float overlap, float skew, float point, float blur) {\n    \n    vec2 gv = fract(uv*5.)-.5;\n    vec2 id = floor(uv*5.);\n    \n    float m = 0.;\n    \n    gv.y = sabs(gv.y,point);\n    \n    float w = .5+overlap;\n    vec2 p1 = (gv+vec2(overlap,-gv.x*skew))*vec2(1,1.8);\n    float a1 = atan(p1.x-w, p1.y);\n    \n    float waveAmp = .02;\n    float waves = 10.;\n    float w1 = sin(a1*waves);\n    float s1 = S(w, w*blur, length(p1)+w1*waveAmp);\n    s1 +=  w1*.1*s1;\n    s1 *= mix(1., .5-gv.x, overlap*2.);\n    \n    gv.x -= 1.;\n    vec2 p2 = (gv+vec2(overlap,-gv.x*skew))*vec2(1,1.8);\n    float a2 = atan(p2.x-w, p2.y);\n    float w2 = sin(a2*waves);\n    float s2 = S(w, w*blur, length(p2)+w2*waveAmp);\n    s2 += w2*.1*s2;\n    \n    s2 *= mix(1., .5-gv.x, overlap*2.);\n    \n    if(s1>s2) {\n    \tm += s1;\n        m -= dot(p1,p1);\n    } else {\n        m += s2;\n        m -= dot(p2,p2);\n        id.x += 1.;\n    }\n\n    return vec4(1.-m, 0., id);\n}\n\nvec4 ScaleTex(vec2 uv, float overlap, float skew, float point, float blur) {\n\n    uv *= 2.;\n    vec4 s1 = Scales(uv, overlap, skew, point, blur);\n    vec4 s2 = Scales(uv+.1, overlap, skew, point, blur);\n    s2.zw -= .5;\n    \n    return s1.x<s2.x ? s1 : s2;\n}\n\n\nvec3 sdBody(vec3 p) {\n    float t = iTime*.3;\n    float neckFade = S(3., 10., p.z);\n   \n    p.x += sin(p.z*.15-t)*neckFade*4.;\n    p.y += sin(p.z*.1-t)*neckFade;\n    \n    vec2 st = vec2(atan(p.x, p.y), p.z);\n    \n    float body = length(p.xy)-(.86+S(2., 15., p.z)*.6-p.z*.01);\n    body = max(.8-p.z, body);   \n    \n    vec4 scales = vec4(0);\n    if(body<.1) {\n        vec2 uv = vec2(-st.y*.25, st.x\/6.2832+.5);\n        float a = sin(st.x+1.57)*.5+.5;\n        float fade = a;\n        a = S(.1, .4, a);\n\n        uv.y = 1.-abs(uv.y*2.-1.);\n        uv.y *= (uv.y-.2)*.4;\n        scales = ScaleTex(uv*1.3, .3*a, .3*a, .01, .8);\n        body += scales.x*.02*(fade+.2);\n    }\n    \n    body += S(-.4, -.9, p.y)*.2;\t\/\/ flatten bottom\n    return vec3(body, scales.zw);\n}\n\nfloat GetHeadScales(vec3 p, vec3 eye, vec3 mouth, float md) {    \n    float t = iTime;\n  \n    float jitter = .5;\n    jitter *= S(.1, .3, abs(md));\n    jitter *= S(1.2, .5, p.z);\n    \n    p.z += .5;\n    p.z *= .5;\n    \n    p.yz *= Rot(.6);\n    float y = atan(p.y, p.x);\n    vec2 gv = vec2(p.z*5., y*3.);\n\n    vec2 id = floor(gv);\n    \n    gv = fract(gv)-.5;\n    \n    float d=MAX_DIST;\n    for(float y=-1.; y<=1.; y++) {\n        for(float x=-1.; x<=1.; x++) {\n            vec2 offs = vec2(x, y);\n\n            vec2 n = Hash22(id+offs);\n            vec2 p = offs+sin(n*6.2831)*jitter;\n            p -= gv;\n            \n            float cd = dot(p,p);\n            if(cd<d) d = cd;\n        }\n    }\n    \n    d += sin(d*20.)*.02;    \n    d *= S(.0, .5, length(p.xy)-.1);\n    return d*.06;\n}\n\nfloat sdHead(vec3 p) {    \n    p.x = abs(p.x*.9);\n    float d = sdSph(p, vec3(0,-.05,.154), vec3(1,1,1.986),1.14); \n    d = smax(d, length(p-vec3(0,7.89,.38))-8.7, .2);\n    d = smax(d, length(p-vec3(0,-7.71,1.37))-8.7, .15); \/\/ top\n    \n    d = smax(d, 8.85-length(p-vec3(9.16,-1.0,-3.51)), .2);\t\/\/ cheeks\n    \n    vec3 ep = p-vec3(.54,.265,-.82);\n    float eye = length(ep)-.35;\n    float brows = S(.1, .8, p.y-(p.z+.9)*.5);\n    brows *= brows*brows;\n    brows *= S(.3, -.2, eye);\n   \td -= brows*.5;\n    d += S(.1, -.2, eye)*.1;\n    \n    vec2 mp = p.yz-vec2(3.76+S(-.71, -.14, p.z)*(p.z+.5)*.2, -.71); \n    float mouth = length(mp)-4.24;\n    d += S(.03,.0,abs(mouth))*S(.59,.0, p.z)*.03;\n    \n   \td += GetHeadScales(p, ep, mp.xyy, mouth);\n    \n    d = min(d, eye);\n    \n    float nostril = length(p.zy-vec2(-1.9-p.x*p.x, .15))-.05;\n    d = smax(d, -nostril,.05);\n    return d;\n}\n\nfloat sdTongue(vec3 p) {\n\tfloat t = iTime*3.;\n   \n    float inOut = S(.7, .8, sin(t*.5));\n    \n    if(p.z>-2.||inOut==0.) return MAX_DIST;\t\t\/\/ early out\n    \n    float zigzag = (abs(fract(t*2.)-.5)-.25)*4.; \/\/ flicker\n    float tl = 2.5;\t\/\/ length\n    \n    p+=vec3(0,0.27,2);\n    p.z *= -1.;\n    float z = p.z;\n    p.yz *= Rot(z*.4*zigzag);\n    p.z -= inOut*tl;\n    \n    float width = S(0., -1., p.z);\n    float fork = 1.-width;\n    \n    float r = mix(.05, .02, fork);\n\t\n    p.x = sabs(p.x, .05*width*width);\n    p.x -= r+.01;\n    p.x -= fork*.2*inOut;\n\n    return length(p-vec3(0,0,clamp(p.z, -tl, 0.)))-r;\n}\n\nfloat GetDist(vec3 P) {\n    \n    vec3 p = P;\n    p.xz *= Rot(sin(iTime*.3)*.1*S(1., 0., p.z));\n    float d = sdTongue(p)*.7;\n    d = min(d, sdHead(p));\n    d = smin(d, sdBody(P).x, .13);\n    \n    return d;\n}\n\nvec3 GetMat(vec3 p) {    \n    float d = MAX_DIST;\n    \n    float tongue = sdTongue(p)*.7;\n    float head = sdHead(p);\n    vec3 body = sdBody(p);\n    \n    float closest = min(tongue, min(head, body.x));\n    if(closest == tongue) {\n        return vec3(MAT_TONGUE, 0, 0);\n    } else if(closest==head) {\n        p.x = abs(p.x*.9);\n        vec3 ep = p-vec3(.54,.265,-.82);\n        float eye = length(ep)-.35;\n        if(eye<SURF_DIST)\n        \treturn vec3(MAT_EYE, ep.yz);\n        else\n            return vec3(MAT_BODY, 0, 0);\n            \n    }else if(closest==body.x) {\n        return vec3(MAT_BODY, body.yz);\n    }\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\n\/\/ From Nimitz\nvec4 GetNormalAndCurvature(in vec3 p, float eps) {\n    vec2 e = vec2(-1., 1.)*eps;   \n    float t1 = GetDist(p + e.yxx), t2 = GetDist(p + e.xxy);\n    float t3 = GetDist(p + e.xyx), t4 = GetDist(p + e.yyy);\n\n    float c = .25\/e.y*(t1 + t2 + t3 + t4 - 4.0*GetDist(p));\n    vec3 n = normalize(e.yxx*t1 + e.xxy*t2 + e.xyx*t3 + e.yyy*t4);\n    \n    return vec4(n, c);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\nvec4 Material(vec3 ro, vec3 rd, float d) {\n    vec3 p = ro + rd * d;\n    vec4 n = GetNormalAndCurvature(p, mix(.01, .03, S(8., 20., d)));\n\n    p.xz *= Rot(sin(iTime*.3)*.1*S(1., 0., p.z));\n    vec3 mat = GetMat(p);\n    \n    vec3 col = vec3(n.y*.5+.5);  \t\/\/ diffuse\n\tcol *= 1.-max(0., .3-n.w);\t\t\/\/ curvature shadow\n    \n    vec3 h = normalize(-rd + vec3(1,1,1));\n    float spe = pow(clamp(dot(h, n.xyz), 0.0, 1.0), 32.0);\n\t\n    vec3 ref = reflect(rd, n.xyz);\n    vec3 r = texture(iChannel0, ref).rgb;\n    \n    if(mat.x==MAT_EYE) {\n        vec2 sph = RaySphere(\n            vec3(abs(p.x*.9),p.yz), \n            vec3(-abs(rd.x), rd.yz), \n            vec4(.3,.265,-.82, .52)\n        );\n\n        vec3 sp = p+rd*sph.x;\n        mat.yz = sp.yz-vec2(.265,-.82)+.05;\n\n        float t = iTime*.2;\n        vec2 p1 = sin(floor(t)*vec2(20., 31.));\n        vec2 p2 = sin(floor(t+1.)*vec2(20., 31.));\n        p1 = mix(p1, p2, S(.45, .5, fract(t)));\n        mat.yz += p1*vec2(.01, .03)*1.;\n        float a = atan(mat.y, mat.z);\n\n        float d = abs(mat.z)+mat.y*mat.y;\n        col *= vec3(1,1,.1);\n        col += S(.1, .0, length(mat.yz*vec2(1,2))-.1)*.1;\n        \n        float z = S(.7, 1., rd.z*rd.z)*.05;\n        col *= S(.02-z, .03+z, d);\n        \n        vec3 gp = vec3(a, mat.yz)*20.;\n        float gyroid = (abs(dot(sin(gp), cos(gp.zxy))));\n        col *= 1.+gyroid*.1;\n        \n        col += r*r*r*.3;\n        col += pow(spe, 6.);\n    } else if(mat.x==MAT_BODY) {\n        float x = mat.y;\n        float y = mat.z;\n        float wave = S(2., 0., abs(y-2.+sin(x*.5)*1.));\n        wave *= S(2., 3., p.z);\n        \n        float t = iTime*.3;\n        float neckFade = S(3., 10., p.z);\n        p.y += sin(p.z*.1-t)*neckFade;\n        \n        vec3 baseCol = mix(vec3(1., 1., .2), vec3(.3, .8, .1), S(-.55, -.1, p.y));\n        col *= mix(baseCol, vec3(.2,.4,.2)*.5, wave);\n        col += spe*pow(1.-abs(n.w), 5.)*.3;\n        \n        r = texture(iChannel1, ref).rgb;\n        col += r*r*.05;\n    } else if(mat.x==MAT_TONGUE) {\n    \tcol *= vec3(.4, .1, .2);\n        col += pow(min(1., spe*5.), 5.);\n    }\n    \n    return vec4(col, 1);\n}\n\nvec3 Render(vec2 uv, vec2 m, float t) {\n    vec3 ro = vec3(0, 0, -3)*(8.+sin(t*.2)*2.*CAM_MOVE);\n    ro.yz *= Rot(-m.y*3.14+sin(t*.03)*CAM_MOVE*.2);\n    ro.xz *= Rot(-m.x*6.2831*2.+sin(t*.05)*CAM_MOVE);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0,sin(t*.11)), 6.);\n    \n    float d = RayMarch(ro, rd);\n    \n    vec3 col = vec3(0);\n    \n    vec2 env = RaySphere(ro, rd, vec4(0,0,0,20));\n    \n    if(d<MAX_DIST) {\n        vec4 snake = Material(ro, rd, d);\n    \tsnake.rgb *= S(60., 10., d);\n        col = mix(col, snake.rgb, snake.a);\n    } else {\n    \tcol = (rd.y*.5+.5)*vec3(.4, 1.,.2);\n        col *= texture(iChannel0, rd).rgb;\n        col *= 1.-S(.8, 1., rd.z);\n        \n        if(env.y>0.)\t\/\/ vines behind\n            col *= S(0., 1.1, sdGyroid(ro + env.y*rd, .4, .1, .0))*.5+.5;\n    }\n    \n    if(env.x>0.)\t\/\/ vines in front\n        col *= S(0., .25, sdGyroid(ro + env.x*rd, .25, .1, .0));\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)\/iResolution.y;\n\tvec2 m = (iMouse.xy-.5*iResolution.xy)\/iResolution.xy;    \n    if(m.x<-.49 && m.y<-.49) m*=0.;\n    \n    vec3 col = Render(uv, m, iTime);\n    \n    col *= 1.5;\t\t\t\t\t\t\/\/ exposure adjustment\n    col = pow(col, vec3(.4545));\t\/\/ gamma correction\n    col *= 1.-dot(uv,uv)*.3;\t\t\/\/ vignette\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4sc3z2","date":"1450771042","viewed":13977,"name":"Noise Lab (3D)","username":"candycat","description":"try to fake http:\/\/www.noisemachine.com\/talk1\/19.html in 3D.","likes":162,"published":1,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/#define Use_Perlin\n\/\/#define Use_Value\n#define Use_Simplex\n\n\/\/ ========= Hash ===========\n\nvec3 hashOld33(vec3 p)\n{   \n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n    \n    return -1.0 + 2.0 * fract(sin(p)*43758.5453123);\n}\n\nfloat hashOld31(vec3 p)\n{\n    float h = dot(p,vec3(127.1,311.7, 74.7));\n    \n    return -1.0 + 2.0 * fract(sin(h)*43758.5453123);\n}\n\n\/\/ Grab from https:\/\/www.shadertoy.com\/view\/4djSRW\n#define MOD3 vec3(.1031,.11369,.13787)\n\/\/#define MOD3 vec3(443.8975,397.2973, 491.1871)\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n\/\/ ========= Noise ===========\n\nfloat value_noise(vec3 p)\n{\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return \tmix(\n        \t\tmix(\n        \t\t\tmix(hash31(pi + vec3(0, 0, 0)), hash31(pi + vec3(1, 0, 0)), w.x),\n        \t\t\tmix(hash31(pi + vec3(0, 0, 1)), hash31(pi + vec3(1, 0, 1)), w.x), \n                    w.z),\n        \t\tmix(\n                    mix(hash31(pi + vec3(0, 1, 0)), hash31(pi + vec3(1, 1, 0)), w.x),\n        \t\t\tmix(hash31(pi + vec3(0, 1, 1)), hash31(pi + vec3(1, 1, 1)), w.x), \n                    w.z),\n        \t\tw.y);\n}\n\nfloat perlin_noise(vec3 p)\n{\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return \tmix(\n        \t\tmix(\n                \tmix(dot(pf - vec3(0, 0, 0), hash33(pi + vec3(0, 0, 0))), \n                        dot(pf - vec3(1, 0, 0), hash33(pi + vec3(1, 0, 0))),\n                       \tw.x),\n                \tmix(dot(pf - vec3(0, 0, 1), hash33(pi + vec3(0, 0, 1))), \n                        dot(pf - vec3(1, 0, 1), hash33(pi + vec3(1, 0, 1))),\n                       \tw.x),\n                \tw.z),\n        \t\tmix(\n                    mix(dot(pf - vec3(0, 1, 0), hash33(pi + vec3(0, 1, 0))), \n                        dot(pf - vec3(1, 1, 0), hash33(pi + vec3(1, 1, 0))),\n                       \tw.x),\n                   \tmix(dot(pf - vec3(0, 1, 1), hash33(pi + vec3(0, 1, 1))), \n                        dot(pf - vec3(1, 1, 1), hash33(pi + vec3(1, 1, 1))),\n                       \tw.x),\n                \tw.z),\n    \t\t\tw.y);\n}\n\nfloat simplex_noise(vec3 p)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n    \n    \/\/ thx nikita: https:\/\/www.shadertoy.com\/view\/XsX3zB\n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n\tvec3 i1 = e * (1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    \n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n    \n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n    \n    return dot(vec4(31.316), n);\n}\n\nfloat noise(vec3 p) {\n#ifdef Use_Perlin\n    return perlin_noise(p * 2.0);\n#elif defined Use_Value\n    return value_noise(p * 2.0);\n#elif defined Use_Simplex\n    return simplex_noise(p);\n#endif\n    \n    return 0.0;\n}\n\n\/\/ ========== Different function ==========\n\nfloat noise_itself(vec3 p)\n{\n    return noise(p * 8.0);\n}\n\nfloat noise_sum(vec3 p)\n{\n    float f = 0.0;\n    p = p * 4.0;\n    f += 1.0000 * noise(p); p = 2.0 * p;\n    f += 0.5000 * noise(p); p = 2.0 * p;\n\tf += 0.2500 * noise(p); p = 2.0 * p;\n\tf += 0.1250 * noise(p); p = 2.0 * p;\n\tf += 0.0625 * noise(p); p = 2.0 * p;\n    \n    return f;\n}\n\nfloat noise_sum_abs(vec3 p)\n{\n    float f = 0.0;\n    p = p * 3.0;\n    f += 1.0000 * abs(noise(p)); p = 2.0 * p;\n    f += 0.5000 * abs(noise(p)); p = 2.0 * p;\n\tf += 0.2500 * abs(noise(p)); p = 2.0 * p;\n\tf += 0.1250 * abs(noise(p)); p = 2.0 * p;\n\tf += 0.0625 * abs(noise(p)); p = 2.0 * p;\n    \n    return f;\n}\n\nfloat noise_sum_abs_sin(vec3 p)\n{\n    float f = noise_sum_abs(p);\n    f = sin(f * 2.5 + p.x * 5.0 - 1.5);\n    \n    return f ;\n}\n\n\n\/\/ ========== Draw ==========\n\nvec3 draw_simple(float f)\n{\n    f = f * 0.5 + 0.5;\n    return f * vec3(25.0\/255.0, 161.0\/255.0, 245.0\/255.0);\n}\n\nvec3 draw_cloud(float f)\n{\n    f = f * 0.5 + 0.5;\n    return mix(\tvec3(8.0\/255.0, 65.0\/255.0, 82.0\/255.0),\n              \tvec3(178.0\/255.0, 161.0\/255.0, 205.0\/255.0),\n               \tf*f);\n}\n\nvec3 draw_fire(float f)\n{\n    f = f * 0.5 + 0.5;\n    return mix(\tvec3(131.0\/255.0, 8.0\/255.0, 0.0\/255.0),\n              \tvec3(204.0\/255.0, 194.0\/255.0, 56.0\/255.0),\n               \tpow(f, 3.));\n}\n\nvec3 draw_marble(float f)\n{\n    f = f * 0.5 + 0.5;\n    return mix(\tvec3(31.0\/255.0, 14.0\/255.0, 4.0\/255.0),\n              \tvec3(172.0\/255.0, 153.0\/255.0, 138.0\/255.0),\n               \t1.0 - pow(f, 3.));\n}\n\nvec3 draw_circle_outline(vec2 p, float radius, vec3 col)\n{\n    p = 2.0 * p - vec2(iResolution.x\/iResolution.y, 1.0);\n    return \tmix(vec3(0.0), col, smoothstep(0.0, 0.02, abs(length(p) - radius)));\n        \t\n}\n\n\/\/ ========= Marching ===========\n#define FAR 30.0\n#define PRECISE 0.001\n#define SPEED 0.05\n\nfloat map(vec3 pos)\n{\n    return length(pos - (vec3(0.0, 0.0, 1.5) + iTime * vec3(0.0, 0.0, SPEED))) - 1.0;\n}\n\nvec3 normal(vec3 pos) {\n    vec2 eps = vec2(0.001, 0.0);\n    return normalize(vec3(\tmap(pos + eps.xyy) - map(pos - eps.xyy),\n                    \t\tmap(pos + eps.yxy) - map(pos - eps.yxy),\n                         \tmap(pos + eps.yyx) - map(pos - eps.yyx)));\n}\n\nvec3 getBackground(vec2 uv, vec2 split)\n{\n    vec3 pos = vec3(uv * vec2(iResolution.x\/iResolution.y, 1.0), iTime * SPEED);\n    float f;\n    if (uv.x < split.x && uv.y > split.y) {\n        f = noise_itself(pos);\n    } else if (uv.x < split.x && uv.y <= split.y) {\n        f = noise_sum(pos);\n    } else if (uv.x >= split.x && uv.y < split.y) {\n        f = noise_sum_abs(pos);\n    } else {\n        f = noise_sum_abs_sin(pos);\n    }\n    \n    return vec3(f * 0.5 + 0.5);\n}\n\nvec3 getColor(vec2 uv, vec3 pos, vec3 rd, vec2 split)\n{\n    vec3 nor = normal(pos);\n    vec3 light = normalize(vec3(0.5, 1.0, -0.2));\n        \n    float diff = dot(light, nor);\n    diff = diff * 0.5 + 0.5;\n    \n    vec3 col;\n    float f;\n    if (uv.x < split.x && uv.y > split.y) {\n        f = noise_itself(pos);\n        col = draw_simple(f);\n    } else if (uv.x < split.x && uv.y <= split.y) {\n        f = noise_sum(pos);\n        col = draw_cloud(f);\n    } else if (uv.x >= split.x && uv.y < split.y) {\n        f = noise_sum_abs(pos);\n        col = draw_fire(f);\n    } else {\n        f = noise_sum_abs_sin(pos);\n        col = draw_marble(f);\n    }\n    \n    vec3 edge = col * pow((1.0 - clamp(dot(nor, -rd), 0.0, 1.0)), 5.0);\n    \n    return col + edge;\n}\n\nvec3 marching(vec3 ro, vec3 rd, vec2 uv, vec2 split)\n{\n    float t = 0.0;\n    float d = 1.0;\n    vec3 pos;\n    for (int i = 0; i < 50; i++) {\n        pos = ro + rd * t;\n        d = map(pos);\n        t += d;\n        if (d < PRECISE || t > FAR) break;\n    }\n \n    vec3 col = getBackground(uv, split);\n    \n    if (t < FAR) {\n        pos = ro + rd * t;\n        col = getColor(uv, pos, rd, split);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy \/ iResolution.xy;\n    vec2 split = vec2(0.5, 0.5);\n    if (iMouse.z > 0.0) {\n        split += 2.0 * iMouse.xy\/iResolution.xy - 1.0;\n    }\n    \n    vec3 col = vec3(0.0, 0.0, 0.0);\n    \n    vec3 ro = vec3(0.0, 0.0, 0.0) + iTime * vec3(0.0, 0.0, SPEED);\n    vec3 rd = vec3((p * 2.0 - 1.0) * vec2(iResolution.x\/iResolution.y, 1.0), 1.0);\n    col = marching(ro, rd, p, split);\n\t\n    col = draw_circle_outline(p * vec2(iResolution.x\/iResolution.y, 1.0), 0.9, col);\n    col = mix(vec3(0.3, 0.0, 0.0), col, smoothstep(0.0, 0.005, abs(p.x - split.x)));\n    col = mix(vec3(0.3, 0.0, 0.0), col, smoothstep(0.0, 0.005*iResolution.x\/iResolution.y, abs(p.y - split.y)));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"WtSBzh","date":"1611688746","viewed":13964,"name":"prism liquid","username":"louis_C","description":"little doodeling with liquid","likes":207,"published":1,"flags":40,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n      vec2 uv = fragCoord\/iResolution.xy;\n    vec3 col = vec3(0.);\n    float b = sqrt(64.);\n    float v1 = distance(uv.y,0.5)*0.005+0.0002;\n    for(float i = -0.5*b;i<=0.5*b;i++)\n    for(float j=-0.5*b;j<=0.5*b;j++)\n    {\n    col += texture(iChannel0,uv+vec2(i,j)*v1).xyz;\n    }\n    col\/=64.;\n    float m = (1.-distance(uv.x,0.5))*(1.-distance(uv.y,0.5));\n    fragColor = vec4(pow(col,vec3(mix(2.,1.,m))),1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvec2 isphe ( in vec3 ro, in vec3 rd, in vec3 cen , in float rad)\n{\nro -= cen;\nfloat b = dot(rd,ro);\nfloat c =dot(ro,ro)-rad*rad;\nfloat h = b*b-c;\nif(h<0.)return vec2(-1.);\nh = sqrt(h);\nreturn vec2(-b-h,-b+h);\n}\nfloat pi = 3.141592653589793;\nvoid moda(inout vec2 p, float r){\nfloat pe = (2.*pi)\/r;float a=atan(p.y,p.x);\na = mod(a,pe)-pe*0.5; p = vec2(cos(a),sin(a))*length(p);\n}\nvec3 rore(vec3 p, float r){\nfloat pe = (2.*3.14)\/r;\nfloat a = atan (p.z,p.x);\na = mod (a,pe)-pe*0.5;\nvec2 pp = vec2 (cos(a),sin(a))*length(p.xz);\nreturn vec3(pp.x,p.y,pp.y);}\nfloat ov(float a, float b){return a<0.5? (2.*a*b) : (1.-2.*(1.-a)*(1.-b));}\nvec3 ov (vec3 a, vec3 b) {return vec3(ov(a.x,b.x),ov(a.y,b.y),ov(a.z,b.z));}\nmat2 rot (float t){float c=cos(t);float s=sin(t);return mat2(c,-s,s,c);}\nfloat oc (vec3 p, float s){p = abs(p);return (p.x+p.y+p.z-s)*0.57735027;}\nfloat cap (vec3 p, vec3 a, vec3 b, float r){\nvec3 pa = p-a; vec3 ba = b-a; float h = clamp(dot(pa,ba)\/dot(ba,ba),0.,1.);\nreturn length(pa-ba*h)-r;}\nfloat smin (float a, float b, float f){float h=clamp(0.5+0.5*(b-a)\/f,0.,1.);\nreturn mix(b,a,h)-f*h*(1.-h);}\nfloat rd(float t) { return fract(sin(dot(floor(fract(t*0.05)*20.),84.259))*7846.236);}\nfloat no (float t){return mix(rd(t),rd(t+1.),smoothstep(0.,1.,fract(t)));}\nfloat it(float t){float r=0.;float a=0.5;for(int i =0; i<5;i++){\nr +=no(t\/a)*a;a*=0.5;\n}return r;}\nfloat rd(vec2 t) { return fract(sin(dot(floor(t),vec2(957.23,84.259)))*7846.236);}\nfloat hs(vec2 t) { return fract(sin(dot((t),vec2(957.23,84.259)))*7846.236);}\nfloat hs2(vec2 t) { return fract(sin(dot((t),vec2(957.23,84.259)))*7846.236+iTime*3.);}\nfloat no(vec2 t) {vec2 e= vec2(1.,0.);float a =rd(t);float b=rd(t+e.xy);float c=rd(t+e.yx);float d=rd(t+e.xx);\nvec2 h = smoothstep(0.,1.,fract(t));return mix(mix(a,b,h.x),mix(c,d,h.x),h.y);}\nfloat it(vec2 t){float r=0.;float a=0.5;for(int i =0; i<4;i++){\nr +=no(t\/a)*a;a*=0.5;\n}return r;}\nfloat rd2(vec2 t) { return fract(sin(dot(floor(t),vec2(957.23,84.259)))*7846.236+iTime*2.);}\nfloat no2(vec2 t) {vec2 e= vec2(1.,0.);float a =rd2(t);float b=rd2(t+e.xy);float c=rd2(t+e.yx);float d=rd2(t+e.xx);\nvec2 h = smoothstep(0.,1.,fract(t));return mix(mix(a,b,h.x),mix(c,d,h.x),h.y);}\nfloat it2(vec2 t){float r=0.;float a=0.5;for(int i =0; i<4;i++){\nr +=no2(t\/a)*a;a*=0.5;\n}return r;}\nfloat vt = 0.;\nfloat t2 = 0.;\nfloat map(vec3 p){\nfloat vrt = smoothstep(0.2,1.,pow(it(iTime*0.7),2.))*30.+1.; \n\/\/float vrt = 15.;\nfloat tt = iTime*1.1;\nvec3 p2 = p*vec3(1.,0.8,1.);\np2.xz *= rot(iTime*1.1);\nmoda (p2.xz,vrt);\nfloat s1 = oc(p2,3.);\nt2 = ov(it(p2.xz*1.2),mix(rd(p2.xz*100.),0.5,0.8));\nvec3 p3 = p;\np3.xz*=rot(p.y*it((p.x+p.z+tt*0.1)*0.3)*0.2);\np3.y += (it(p.x*0.3+tt)+it(p.z*0.3+tt))*-1.;\nmoda (p3.xz,vrt);\nfloat s2 =length(p3);\nfor (int i =0;i<18;i ++){\nfloat v1 = no(tt+float(i)*98.236);\nfloat v2 = no(tt+float(i)*15.76);\nfloat v3 = no(tt+float(i)*125.236);\nfloat vr = iTime+float(i)*26.265+v3;\nfloat cc = cap (p3 , vec3(sin(vr)*3.,v3,cos(vr)*3.5),vec3(sin(vr+v1*0.5)*3.5,v2,cos(vr+v1*0.5)*3.),v1*0.2);\nfloat cc2 = length (p3+vec3(sin(tt+float(i)*48.236+v2)*3.5,v3,cos(tt+float(i)*48.236+v2)*3.5))-v3*0.2;\ns2 = smin (s2,cc,0.8);\ns2 = smin(s2,cc2,0.8);\n\n}\nvt =s2;\nreturn min(s1,s2);}\nvec3 nor( vec3 p ){ vec2 e = vec2(0.01,0.);return normalize(map(p)-vec3(map(p-e.xyy),map(p-e.yxy),map(p-e.yyx)));}\nvec3 sky (vec3 p){return max(smoothstep(-1.,1.,dot(p,vec3(1,0.,0.)))*vec3(0.2,0.4,0.4),smoothstep(0.5,0.8,dot(p,vec3(0,1.,0.))));}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \nfloat time = iTime;\nfloat tau = 6.28318530717958647692;\n    vec2 uv = -1. + 2. * fragCoord\/iResolution.xy;\n    uv.x*= iResolution.x\/iResolution.y;\n    float t1 = time;\n    vec3 e = vec3(0.,0.,-6.);\n    vec3 r = normalize(vec3(uv,1.));\n    float vm1 = (it(time*0.7)-0.4)*0.5;\n    e.yz *= rot(vm1);\n    r.yz *= rot(vm1);\n    vec3 p = e;\n   \n    float side =sign(map(p));\n    vec3 col ;\n    float dd = 0.;\n    float prod  = 1.;\n    vec2 vol = isphe (e,r,vec3(0.,0.8,0.), 4.);\n    if(vol.y>0.0)\n    {\n    for (int i = 0; i< 48; i ++){\n    float d = map(p)*side;\n    if(dd>20.){dd = 20.;break;}\n    if(d<0.001){\n    float tex = mix(0.9,1.,smoothstep(0.3,0.8,t2));\n    vec3 n = nor(p)*side;\n    float opa = smoothstep(0.1,0.,vt);\n     vec3 l1 = sky(reflect(r,n*tex))*0.8;\n     \/\/float oc =mix(smoothstep(-1.,1.,map(p+n*0.3)\/0.3),1.,opa);\n     \/\/l1*=oc;\n     \/\/vec3 r1 = mix(sky(r),l1*0.8,1.-clamp(map(p),0.,1.));\n     col = l1;\n    side=-side;\n    d=0.01;\n    r = refract(r,n,1.+0.1*side);\n    \/\/prod *= 0.;\n    if(opa==0.)break;\n    \/\/break;\n    }\n    p += r*d;\n    dd +=d;\n    }\n    }\n    else {dd = 20.;}\n  \n     \/\/vec3 col = nor(p);\n     \/\/vec3 l1 = sky(reflect(r,col))*0.5;\n     \/\/l1 += smoothstep(.8,-0.5,pow(dot(col,-r),0.3));\n     \/\/float m = clamp(map(p),0.,1.);\n     \n     \n     float m = smoothstep(0.,15.,dd);\n     vec3 c2 = mix(col,(3.*abs(1.-2.*fract(m*2.5+vec3(0.,-1.\/3.,1.\/3.)))-1.)*col,0.07);\n     vec3 r1 = mix(c2*0.8,sky(r),m);\n     vec3 gr = vec3(hs2(uv),hs2(uv+59.236),hs2(uv+958.236));\n     vec3 r2 = ov(r1,mix(vec3(0.5),gr,0.2));\n     vec3 f1 = pow(r2,vec3(0.5));\n    float fno = it2(uv*5.);\n    float fo1 = smoothstep(0.75,0.9,fno);\n    float fo2 = smoothstep(0.78,0.9,fno);\n    float rgo = smoothstep(0.3,1.,it(time*5.));\n    float fo3 = (fo1-fo2)+0.5-fo2*0.5;\n    vec3 f2 =ov(f1,vec3(mix(0.5,1.-fo3,rgo*0.7)));\n    fragColor = vec4(f2,1.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float rd(float t) { return fract(sin(dot(floor(fract(t*0.05)*20.),84.259))*7846.236);}\nfloat no (float t){return mix(rd(t),rd(t+1.),smoothstep(0.,1.,fract(t)));}\nfloat it(float t){float r=0.;float a=0.5;for(int i =0; i<5;i++){\nr +=no(t\/a)*a;a*=0.5;\n}return r;}\nfloat hash(float x){return fract(sin(x) * 897612.531);}\nfloat voc(float t, float f, float ft,float t2){float x = fract(t * f) \/ f;\nfloat a=(sin(x*6.5*ft)*.4+sin(x*13.*ft)+sin(x*24.*ft)*.2);\n   return a* min(x * 1000., 1.) * exp(x * -200.);}\nvec2 inst2(float t, float var,float t2){\n    vec2 v = vec2(0., 0.);\n    for(int i = 0; i < 16; ++i){\n        float h = float(i);\n       \tfloat m = voc(t + h \/ 3., 50. + pow(2.01, (h - 8.) * .2), var,t2);\n        float pan = hash(h);\n        v.x += m * pan;\n        v.y += m * (1. - pan);\n    }\n    return v * .1;\n}\nvec2 sons ( float time) {float tt = time*1.1;\n    float vrt = smoothstep(0.2,1.,pow(it(time*0.7),2.))*30.+1.;\n    float bt = pow(fract(vrt\/3.14),0.2);\n    float v = sin(bt*50.)*it(time*24.);\n    \n    float v2 =  (fract(sin(dot(time,84.259))*7846.236)-0.5);\n    float v3 = v2 * smoothstep(0.,1.,(1.-pow(fract(vrt\/3.14),0.1))); \n    float v4 = sin(time*250.)*(smoothstep(1.,0.,sin(vrt)*0.5+0.5));\n    float f1 = sin(time*200.+it(tt*0.1)*300.)*it(tt*0.3)  ;\n    float va = 50.+50.*no(time*0.5);\n    return vec2((v4+v*0.05+v3*0.05)+f1*0.5)+ inst2(time,va,time)*0.25;}\nvec2 mainSound( in int samp, float time )\n{\n    \n     float ta = 0.01;    \n    vec2 rev = vec2(0.);\n    float sum = 0.;\n    for(float t = 0.; t<2.;t +=ta){      \n    float rand = fract(120.*sin(t*1000.));\n    float t2 = t + ta*rand*5.;\n    float amp = exp2(-t2);\n    rev += sons( time - t2 ) * amp;\n    sum += amp;}\n    rev \/= sum;    \n    rev *= 10.; \n    vec2 s2 = sons(time);\n    vec2 f =  clamp(mix(vec2(s2.x,rev.x),vec2(rev.y,s2.y),it(time*18.)),-1.,1.);\n    return clamp(f*1.5,0.,1.);\n}","name":"Sound","description":"","type":"sound"}]},{"ver":"0.1","info":{"id":"4tXcRl","date":"1505881974","viewed":13938,"name":"Simple Greeble - Split4","username":"blackjero","description":"Manual unroll of so called shape grammar split (for \"man made\" tech detail) applied to a rough procedural reconstruction of the first few seconds of the death star trench sequence.\nMouse to look around (2 camera paths) ","likes":108,"published":3,"flags":0,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Simple Greeble - Split4 by Jerome Liard, August 2017\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/ https:\/\/www.shadertoy.com\/view\/4tXcRl\n\n\/\/ Manual unroll of so called shape grammar split (for \"man made\" tech detail)\n\/\/ applied to a rough procedural reconstruction of the first few seconds of the death star trench sequence.\n\/\/ Mouse to look around (2 camera paths)\n\n\/\/ I was initially working on split\/subdivided tiles for something else,\n\/\/ but as it started to look familiar I pushed in the fan art direction.\n\/\/\n\/\/ The tiles use several hardcoded quad split variants (all resulting in 4 children),\n\/\/ and we recurse down 1 level on a couple of them (max 10 leaves).\n\/\/\n\/\/ I find the lack of motion blur disturbing, but time was spent on other futile things instead.\n\n#if 1\n#define TIME_OFFSET 0.0\n#define CAM2_TIME_OFFSET 0.0\n#else\n#define TIME_OFFSET 54.0\n#define CAM2_TIME_OFFSET 7.0\n#endif\n#define CAMERA_REPEAT\n\/\/ tile eval count (x1 x2 x4 (max)... to deal with cell boundaries), the more evals the less artifacts but it also depend on a ton of other things - use 1 or 2 really\n#define NUM_TILE_EVALS 1\n\/\/ warp first iteration with raytracing to reduce trace iteration count, affects lighting a bit\n#define RAYTRACE_FIRST_MARCH_DISTANCE\n\/\/ small trace optim that creates color disparity as a side effect (a bug promoted into a feature)\n#define RAYMARCH_WITH_LOD\n\/\/ allow proper shadows close to us, expensive and doesn't contribute that much... disable\n\/\/#define TRACED_SHADOW\n\/\/ do the main cast shadow analytically\n#define ANALYTICAL_SHADOW\n\/\/ worry not, it's not screenspace\n#define AO\n\/\/ color tiles (debug)\n\/\/#define COLOR_TILES\n#define STARFIELD\n#define SUN\n\/\/ scene type\n\/\/#define PRIMITIVES\n#define SORT_OF_MOON\n#define LASERS\n\/\/ max marching iterations\n#define MAX_ITERATIONS 140\n\/\/ tweak for perfs vs quality etc\n#define DBREAK 0.00125\n#define TMAX 200.0\n#define TFRAC 0.5\n\n\/\/ threshold distance used by RAYMARCH_WITH_LOD and RAYTRACE_FIRST_MARCH_DISTANCE\n#define ROUGH_SHELL_D 0.45\n\n#define FLYING_SPEED 10.0\n#define TRENCH_DEPTH 4.8\n#define TRENCH_HALF_WIDTH 2.0\n\nfloat PI = 3.141592654;\n\n#ifndef FLT_MAX\n#define FLT_MAX 1000000.0\n#endif\n\nvec3 RED\t = vec3( 1, 0, 0 );\nvec3 GREEN\t = vec3( 0, 1, 0 );\nvec3 BLACK\t = vec3( 0, 0, 0 );\n\nvec2 xset( vec2 p, float v ) { return vec2( v, p.y );}\nvec2 yset( vec2 p, float v ) { return vec2( p.x, v );}\nvec3 xset( vec3 p, float v ) { return vec3( v, p.y, p.z );}\nvec3 yset( vec3 p, float v ) { return vec3( p.x, v, p.z );}\nvec3 zset( vec3 p, float v ) { return vec3( p.x, p.y, v );}\n\n#define IMPL_SATURATE(type) type saturate( type x ) { return clamp( x, type(0.0), type(1.0) ); }\nIMPL_SATURATE( float )\nIMPL_SATURATE( vec2 )\nIMPL_SATURATE( vec3 )\nIMPL_SATURATE( vec4 )\n\nfloat smoothstep_unchecked( float x ) { return ( x * x ) * ( 3.0 - x * 2.0 ); }\nvec2 smoothstep_unchecked( vec2 x ) { return ( x * x ) * ( 3.0 - x * 2.0 ); }\nvec3 smoothstep_unchecked( vec3 x ) { return ( x * x ) * ( 3.0 - x * 2.0 ); }\n\/\/ cubicstep is a generic smoothstep where you can set in and out slopes\n\/\/ slope at x=0 is df0\n\/\/ slope at x=1 is df1\n\/\/ smoothstep_unchecked(x) == cubicstep(x,0,0)\nfloat cubicstep( float x, float df0, float df1 ) { float b = 3.0 - df1 - 2.0 * df0; float a = 1.0 - df0 - b; return ( ( a * x + b ) * x + df0 ) * x; }\nfloat linearstep( float a, float b, float x ) { return saturate( ( x - a ) \/ ( b - a ) ); }\nfloat smoothbump( float a, float r, float x ) { return 1.0 - smoothstep_unchecked( min( abs( x - a ), r ) \/ r ); }\nvec2 perp( vec2 v ) { return vec2( -v.y, v.x ); }\nfloat calc_angle( vec2 v ) { return atan( v.y, v.x ); }\nfloat calc_angle( vec2 a, vec2 b ) { return calc_angle( vec2( dot( a, b ), dot( perp( a ), b ) ) ); }\nvec3 contrast( vec3 x, vec3 s ) { return ( x - 0.5 ) * s + 0.5; }\nfloat lensqr( vec2 v ) { return dot( v, v ); }\nfloat lensqr( vec3 v ) { return dot( v, v ); }\nfloat lensqr( vec4 v ) { return dot( v, v ); }\nfloat pow2( float x ) { return x * x; }\nfloat pow4( float x ) { x *= x; x *= x; return x; }\nvec4 pow2( vec4 x ) { return x * x; }\nvec4 pow4( vec4 x ) { x *= x; x *= x; return x; }\nfloat pow5( float x ) { float x2 = x * x; return x2 * x2 * x; }\nfloat maxcomp( float x ) { return x; }\nfloat maxcomp( vec2 v ) { return max( v.x, v.y ); }\nfloat maxcomp( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat mincomp( float x ) { return x; }\nfloat mincomp( vec2 v ) { return min( v.x, v.y ); }\nfloat mincomp( vec3 v ) { return min( min( v.x, v.y ), v.z ); }\nfloat box( float x ) { return abs( x ) < 1.0 ? 1.0 : 0.0; }\nvec3 chrominance( vec3 c ) { return c \/ max( c.r, max( c.g, c.b ) ); }\nvec3 luminance( vec3 c ) { return vec3( dot( vec3( 0.2989, 0.5866, 0.1145 ), c ) ); }\n\n\/\/ project this on line (O,d), d is assumed to be unit length for project_on_line1\n\/\/ project_on_liney: d = 0,1,0\n#define PROJECT_ON_LINE1(type) \\\ntype project_on_liney( type P, type O ) { O.y += ( P - O ).y; return O; } \/* d = vec3(0,1,0) *\/\n\nPROJECT_ON_LINE1( vec2 )\nPROJECT_ON_LINE1( vec3 )\n\n#define DECL_BOUNDS( btype, type, booltype ) \\\nstruct btype { type pmin; type pmax; }; \\\n\/* min,max constructor*\/ \\\nbtype mkbounds_unchecked( type amin, type amax ) { btype ret; ret.pmin = amin; ret.pmax = amax; return ret; } \\\n\/*btype mkbounds_unchecked_invalid() { btype ret; ret.pmin = FLT_MAX; ret.pmax = -FLT_MAX; return ret; }*\/ \\\ntype size( btype b ) { return b.pmax - b.pmin; } \\\ntype center( btype b ) { return 0.5 * ( b.pmax + b.pmin ); } \\\ntype closest( btype b, type p ) { return min( max( p, b.pmin ), b.pmax ); } \\\nbool inside( btype b, type p ) { return all_( \/*booltype*\/( p == closest( b, p ) ) ); }\n\nbool all_( bool value ) { return value; } \/\/ not defined in glsl, apparently + can't use same name else some compilers barf\nbool all_( bvec2 value ) { return all( value ); }\nbool all_( bvec3 value ) { return all( value ); }\n\nDECL_BOUNDS( bounds1, float, bool )\nDECL_BOUNDS( bounds2, vec2, bvec2 )\nDECL_BOUNDS( bounds3, vec3, bvec3 )\n\nbounds3 mkbounds_unchecked( bounds2 b, float height )\n{\n\tbounds3 ret;\n\tret.pmin = vec3( b.pmin.xy, 0 );\n\tret.pmax = vec3( b.pmax.xy, height );\n\treturn ret;\n}\nbounds2 xy( bounds3 b ) { return mkbounds_unchecked( b.pmin.xy, b.pmax.xy  ); }\nbounds2 xy( bounds2 b ) { return b; }\n\n#define REPEAT_FUNCTIONS( type, btype ) \\\ntype repeat( type x, type len ) { return len * fract( x * ( type( 1.0 ) \/ len ) ); }\\\ntype repeat_mirror( type x, type len ) { return len * abs( type( -1.0 ) + 2.0 * fract( ( ( x * ( type( 1.0 ) \/ len ) ) - type( -1.0 ) ) * 0.5 ) ); }\n\nREPEAT_FUNCTIONS( float, bounds1 )\nREPEAT_FUNCTIONS( vec2, bounds2 )\nREPEAT_FUNCTIONS( vec3, bounds3 )\n\n#define TRI_FUNCTIONS(type,btype) \\\n\/* y=1-x on 0,1, output 0,1 *\/ \\\ntype tri0( type x ) { return abs( fract( x * 0.5 ) - type(0.5) ) * 2.0; } \\\n\/* function returns 0 at x = half_width *\/ \\\ntype tri_p( type x, type half_width, type half_period )\t{ return half_width - repeat_mirror( x, half_period ); }\n\nTRI_FUNCTIONS( float, bounds1 )\nTRI_FUNCTIONS( vec2, bounds2 )\nTRI_FUNCTIONS( vec3, bounds3 )\n\nfloat spaced_tri( float x, float period, float half_width ) { period *= 0.5; x \/= period; return max( 0.0, 1.0 + ( tri0( x ) - 1.0 ) * ( period \/ half_width ) ); }\nfloat spaced_bumps( float x, float s, float r ) { return smoothstep_unchecked( spaced_tri( x, s, r ) ); }\n\n\/\/ hash functions from David Hoskins's https:\/\/www.shadertoy.com\/view\/4djSRW\n\n\/\/ *** Change these to suit your range of random numbers..\n\n\/\/ *** Use this for integer stepped ranges, ie Value-Noise\/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\n\/\/ For smaller input rangers like audio tick or 0-1 UVs use these...\n\/\/#define HASHSCALE3 443.8975\n\/\/#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n\/\/#define HASHSCALE3 vec3(443.897, 441.423, 437.195, 444.129)\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  2 out, 1 in...\nvec2 hash21( float p )\n{\n\tvec3 p3 = fract( vec3( p ) * HASHSCALE3 );\n\tp3 += dot( p3, p3.yzx  + 19.19 );\n\treturn fract( ( p3.xx  + p3.yz  ) * p3.zy  );\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/\/  2 out, 2 in...\nvec2 hash22( vec2 p )\n{\n\tvec3 p3 = fract( vec3( p.xyx  ) * HASHSCALE3 );\n\tp3 += dot( p3, p3.yzx  + 19.19 );\n\treturn fract( ( p3.xx  + p3.yz  ) * p3.zy  );\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/\/  3 out, 2 in...\nvec3 hash32( vec2 p )\n{\n\tvec3 p3 = fract( vec3( p.xyx ) * HASHSCALE3 );\n\tp3 += dot( p3, p3.yxz  + 19.19 );\n\treturn fract( ( p3.xxy  + p3.yzz  ) * p3.zyx );\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ 4 out, 2 in...\nvec4 hash42( vec2 p )\n{\n\tvec4 p4 = fract( vec4( p.xyxy  ) * HASHSCALE4 );\n\tp4 += dot( p4, p4.wzxy  + 19.19 );\n\treturn fract( ( p4.xxyz + p4.yzzw ) * p4.zywx );\n\n}\n\nvec2 V30 = vec2( 0.866025403, 0.5 );\nvec2 V45 = vec2( 0.707106781, 0.707106781 );\n\nvec2 unit_vector2( float angle ) { return vec2( cos( angle ), sin( angle ) ); }\nvec2 rotate_with_unit_vector( vec2 p, vec2 cs ) { return vec2( cs.x * p.x - cs.y * p.y, cs.y * p.x + cs.x * p.y ); }\nvec2 rotate_with_angle( vec2 p, float a_angle ) { return rotate_with_unit_vector( p, unit_vector2( a_angle ) ); }\n\n\/\/ theta is angle with the z axis, range [0,pi].\n\/\/ phi is angle with x vectors on z=0 plane, range [0,2pi].\nvec3 zup_spherical_coords_to_vector( float theta, float phi )\n{\n\tvec2 theta_vec = unit_vector2( theta );\n\tvec2 phi_vec = unit_vector2( phi );\n\treturn vec3( theta_vec.y * phi_vec, theta_vec.x );\n}\n\nvec3 yup_spherical_coords_to_vector( float theta, float phi ) { return zup_spherical_coords_to_vector( theta, phi ).yzx; }\n\nmat4 yup_spherical_offset( float theta, float phi )\n{\n\tvec3 y = yup_spherical_coords_to_vector( theta, phi );\n\tvec3 z = yup_spherical_coords_to_vector( theta + PI * 0.5, phi );\n\tvec3 x = cross( y, z );\n\treturn mat4( vec4( x, 0.0 ), vec4( y, 0.0 ), vec4( z, 0.0 ), vec4( 0, 0, 0, 1 ) );\n}\n\n\/\/ debug visualization\nvec3 viridis_quintic( float x )\n{\n\tx = saturate( x );\n\tvec4 x1 = vec4( 1.0, x, x * x, x * x * x ); \/\/ 1 x x2 x3\n\tvec4 x2 = x1 * x1.w * x; \/\/ x4 x5 x6 x7\n\treturn vec3(\n\t\tdot( x1.xyzw, vec4( +0.280268003, -0.143510503, +2.225793877, -14.815088879 ) ) + dot( x2.xy, vec2( +25.212752309, -11.772589584 ) ),\n\t\tdot( x1.xyzw, vec4( -0.002117546, +1.617109353, -1.909305070, +2.701152864 ) ) + dot( x2.xy, vec2( -1.685288385, +0.178738871 ) ),\n\t\tdot( x1.xyzw, vec4( +0.300805501, +2.614650302, -12.019139090, +28.933559110 ) ) + dot( x2.xy, vec2( -33.491294770, +13.762053843 ) ) );\n}\n\nstruct Ray { vec3 o; vec3 d; };\n\nRay get_view_ray( vec2 normalized_pos, float z, float aspect, float tan_half_fovy )\n{\n\tRay view_ray;\n\tview_ray.o = vec3( normalized_pos * vec2( aspect, 1.0 ) * tan_half_fovy, -1.0 ) * z;\n\tview_ray.d = normalize( view_ray.o );\n\treturn view_ray;\n}\n\nmat4 lookat( vec3 eye, vec3 center, vec3 up )\n{\n\tvec3 z = normalize( eye - center );\n    vec3 x = normalize( cross( up, z ) );\n\treturn mat4( vec4( x, 0.0 ), vec4( cross( z, x ), 0.0 ), vec4( z, 0.0 ), vec4( eye, 1.0 ) );\n}\n\nfloat opU( float d1, float d2 ) { return -max( -d1, -d2 ); }\nfloat opS( float d1, float d2 ) { return max( -d2, d1 );}\nfloat opI( float d1, float d2 ) { return max( d1, d2 ); }\nfloat opI( float d1, float d2, float d3 ) { return max( max( d1, d2 ), d3 ); }\n\nfloat sd_bounds_half_size( float p, float h ) { p = abs( p ) - h; return p; }\nfloat sd_bounds_half_size( vec2 p, vec2 h ) { p = abs( p ) - h; return opI( p.x, p.y ); }\nfloat sd_bounds_half_size( vec3 p, vec3 h ) { p = abs( p ) - h; return opI( p.x, p.y, p.z ); }\nfloat sd_bounds_range( vec2 p, vec2 mi, vec2 ma ) { vec2 hmi = mi * 0.5; vec2 hma = ma * 0.5; return sd_bounds_half_size( p - ( hma + hmi ), hma - hmi ); }\nfloat sd_bounds_range( float p, float mi, float ma ) { return sd_bounds_half_size( p - ( ( ma + mi ) * 0.5 ), ( ma - mi ) * 0.5 ); }\nfloat sd_bounds_range( vec3 p, vec3 mi, vec3 ma ) { return sd_bounds_half_size( p - ( ( ma + mi ) * 0.5 ), ( ma - mi ) * 0.5 ); }\nfloat sd_bounds( vec2 p, bounds2 b ) { return sd_bounds_range( p, b.pmin, b.pmax ); }\nfloat sd_bounds( vec3 p, bounds3 b ) { return sd_bounds_range( p, b.pmin, b.pmax ); }\n\nstruct Plane2 { vec2 base; vec2 normal; };\nstruct Plane { vec3 base; vec3 normal; };\n\nPlane2 mkplane2( vec2 base, vec2 normal ) { Plane2 plane; plane.base = base; plane.normal = normal; return plane; }\nPlane mkplane( vec3 base, vec3 normal ) { Plane plane; plane.base = base; plane.normal = normal; return plane; }\n\n\/\/ a few tediously hardcoded subdivisions that generates 4 children\n\n#define SPLIT4_BOUNDS\n\nstruct Split4\n{\n#ifdef SPLIT4_BOUNDS\n\tbounds2 b00;\n\tbounds2 b01;\n\tbounds2 b10;\n\tbounds2 b11;\n#endif\n\tvec4 d;\n};\n\nvec4 get_distances( vec2 p, Split4 split )\n{\n#if 1\n\treturn split.d;\n#else\n\/\/ should be same result\n\tvec4 d;\n\td.x = sd_bounds_range( p, split.b00.pmin, split.b00.pmax );\n\td.y = sd_bounds_range( p, split.b01.pmin, split.b01.pmax );\n\td.z = sd_bounds_range( p, split.b10.pmin, split.b10.pmax );\n\td.w = sd_bounds_range( p, split.b11.pmin, split.b11.pmax );\n\treturn d;\n#endif\n}\n\nSplit4 sd_Split_b_xxx( vec2 p, vec2 mi, vec2 ma, vec3 s )\n{\n\/\/  -------------------------\n\/\/  |     |\t    |     |     |\n\/\/  | b00 | b01 | b10 | b11 |\n\/\/  |     |\t    |     |     |\n\/\/  -------------------------\n\/\/     x10     x0    x11\n\n\tfloat x0 = mix( mi.x, ma.x, s.x );\n\tfloat x10 = mix( mi.x, x0, s.y );\n\tfloat x11 = mix( x0, ma.x, s.z );\n\n#if 0\n\/\/ diagonal features\n\tfloat dx = linearstep( 0.4, 0.6, ( p.y - mi.y ) \/ ( ma.y - mi.y ) ) * ( ma.x - mi.x ) * 0.15;\n\tx0 += dx;\n\tx10 += dx;\n\tx11 += dx;\n#endif\n\n\tSplit4 split;\n\t\/\/\n#ifdef SPLIT4_BOUNDS\n\tsplit.b00 = mkbounds_unchecked( mi, xset( ma, x10 ) );\n\tsplit.b01 = mkbounds_unchecked( xset( mi, x10 ), xset( ma, x0 ) );\n\tsplit.b10 = mkbounds_unchecked( xset( mi, x0 ), xset( ma, x11 ) );\n\tsplit.b11 = mkbounds_unchecked( xset( mi, x11 ), ma );\n#endif\n\t\/\/\n\tfloat d = sd_bounds_range( p, mi, ma );\n\tfloat a = p.x - x0;\n\tfloat d0 = opI( a, d );\n\tfloat d1 = opI( -a, d );\n\tfloat b = p.x - x10;\n\tsplit.d.x = opI( d0, b );\n\tsplit.d.y = opI( d0, -b );\n\tfloat c = p.x - x11;\n\tsplit.d.z = opI( d1, c );\n\tsplit.d.w = opI( d1, -c );\n\t\/\/\n\treturn split;\n}\n\nSplit4 sd_Split_b_xyy( vec2 p, vec2 mi, vec2 ma, vec3 s )\n{\n\/\/     ---------------\n\/\/     | \t  |      |\n\/\/     | b01  |  b11 |\n\/\/ y10 | -----|      |\n\/\/     | \t  |------| y11\n\/\/     | b00  |  b10 |\n\/\/     ---------------\n\/\/            x0\n\n\tfloat x0 = mix( mi.x, ma.x, s.x );\n\tfloat y10 = mix( mi.y, ma.y, s.y );\n\tfloat y11 = mix( mi.y, ma.y, s.z );\n\n#if 1\n\/\/ diagonal features\n\tfloat dx = linearstep( 0.4, 0.6, ( p.y - mi.y ) \/ ( ma.y - mi.y ) ) * ( ma.x - mi.x ) * 0.15;\n\tx0 += dx;\n#endif\n\n\tSplit4 split;\n\t\/\/\n#ifdef SPLIT4_BOUNDS\n\tsplit.b00 = mkbounds_unchecked( mi, vec2( x0, y10 ) );\n\tsplit.b01 = mkbounds_unchecked( yset( mi, y10 ), xset( ma, x0 ) );\n\tsplit.b10 = mkbounds_unchecked( xset( mi, x0 ), yset( ma, y11 ) );\n\tsplit.b11 = mkbounds_unchecked( vec2( x0, y11 ), ma );\n#endif\n\t\/\/\n\tfloat d = sd_bounds_range( p, mi, ma );\n\tfloat a = p.x - x0;\n\tfloat d0 = opI( a, d );\n\tfloat d1 = opI( -a, d );\n\tfloat b = p.y - y10;\n\tsplit.d.x = opI( d0, b );\n\tsplit.d.y = opI( d0, -b );\n\tfloat c = p.y - y11;\n\tsplit.d.z = opI( d1, c );\n\tsplit.d.w = opI( d1, -c );\n\t\/\/\n\treturn split;\n}\n\nSplit4 sd_Split_b_xyx( vec2 p, vec2 mi, vec2 ma, vec3 s )\n{\n\/\/ \t   ------------------\n\/\/     | b01 |     |    |\n\/\/ y10 | ----| b10 | b11|\n\/\/     | b00 |     |    |\n\/\/ \t   ------------------\n\/\/ \t        x0    x11\n\n\tfloat x0 = mix( mi.x, ma.x, s.x );\n\n#if 0\n\/\/ diagonal features (a bit too much)\n\tfloat dx = linearstep( 0.4, 0.6, ( p.y - mi.y ) \/ ( ma.y - mi.y ) ) * ( ma.x - mi.x ) * 0.15;\n\tx0 += dx;\n#endif\n\n\tfloat y10 = mix( mi.y, ma.y, s.y );\n\tfloat x11 = mix( x0, ma.x, s.z );\n\n#if 0\n\/\/ diagonal feature (a bit too much)\n\tfloat dx = linearstep( 0.4, 0.6, ( p.y - mi.y ) \/ ( ma.y - mi.y ) ) * ( ma.x - mi.x ) * 0.15;\n\tx11 += dx;\n#endif\n\n\t\/\/\n\tSplit4 split;\n#ifdef SPLIT4_BOUNDS\n\tsplit.b00 = mkbounds_unchecked( mi, vec2( x0, y10 ) );\n\tsplit.b01 = mkbounds_unchecked( yset( mi, y10 ), xset( ma, x0 ) );\n\tsplit.b10 = mkbounds_unchecked( xset( mi, x0 ), xset( ma, x11 ) );\n\tsplit.b11 = mkbounds_unchecked( xset( mi, x11 ), ma );\n#endif\n\t\/\/\n\tfloat d = sd_bounds_range( p, mi, ma );\n\tfloat a = p.x - x0;\n\tfloat d0 = opI( a, d );\n\tfloat d1 = opI( -a, d );\n\tfloat b = p.y - y10;\n\tsplit.d.x = opI( d0, b );\n\tsplit.d.y = opI( d0, -b );\n\tfloat c = p.x - x11;\n\tsplit.d.z = opI( d1, c );\n\tsplit.d.w = opI( d1, -c );\n\t\/\/\n\treturn split;\n}\n\n\/\/ that one can't be expressed as a 2 levels split, but as an incomplete level 3 (we only store 4 bounds)\nSplit4 sd_Split_b_H( vec2 p, vec2 mi, vec2 ma, vec3 s )\n{\n\/\/   --------------------\n\/\/   |     |  b10 |     |\n\/\/   |     |\t  |     |\n\/\/   | b00 |------| b11 | y20\n\/\/   |     |\t  |     |\n\/\/   |     |  b01 |     |\n\/\/   --------------------\n\/\/         x0    x10\n\n\t\/\/ note: we sort s.x and s.z, it make this function easier to use\n\tfloat x0 = mix( mi.x, ma.x, min( s.x, s.z ) );\n\tfloat y20 = mix( mi.y, ma.y, s.y );\n\tfloat x10 = mix( x0, ma.x, max( s.x, s.z ) );\n\tSplit4 split;\n\t\/\/\n#ifdef SPLIT4_BOUNDS\n\tsplit.b00 = mkbounds_unchecked( mi, xset( ma, x0 ) );\n\tsplit.b01 = mkbounds_unchecked( xset( mi, x0 ), vec2( x10, y20 ) );\n\tsplit.b10 = mkbounds_unchecked( vec2( x0, y20 ), xset( ma, x10 ) );\n\tsplit.b11 = mkbounds_unchecked( xset( mi, x10 ), ma );\n#endif\n\t\/\/\n\tfloat d = sd_bounds_range( p, mi, ma );\n\tfloat d0 = opI( p.x - x0, d );\n\tfloat d1 = opI( -p.x + x0, d );\n\tfloat d20 = opI( p.x - x10, d1 );\n\tfloat d21 = opI( -p.x + x10, d1 );\n\tsplit.d.x = opI( d0, p.x - x0 );\n\tsplit.d.y = opI( d20, -p.y + y20 );\n\tsplit.d.z = opI( d20, p.y - y20 );\n\tsplit.d.w = opI( d21, -p.x + x10 );\n\t\/\/\n\treturn split;\n}\n\nstruct TechTilesArgs\n{\n\tvec4 height0, height10, height11;\n\tvec3 size0, size10, size11; \/\/relative\n\tbool sub10, sub11; \/\/ recurse or not\n};\n\n\/\/ d stores 4 df for 4 boxes, h stored boxes height\nfloat getDist4( float z, vec4 d, vec4 h )\n{\n\tvec4 v = vec4( z ) - h;\n\treturn opU( opU( opI( v.x, d.x ), opI( v.y, d.y ) ),\n\t\t\t\topU( opI( v.z, d.z ), opI( v.w, d.w ) ) );\n}\n\n\/\/ 4 scopes output + recurse 2 of them\nfloat sd_TechTilesTestsSub( vec3 p, int lod, float t, TechTilesArgs args, float e )\n{\n\tvec4 d = vec4( FLT_MAX );\n\tvec4 heights = args.height0;\n\n\/\/\tSplit4 b = sd_Split_b_xxx( p.xy, vec2( 0, 0 ), vec2( 1, 1 ), args.size0 );\n\/\/\tSplit4 b = sd_Split_b_xyy( p.xy, vec2( 0, 0 ), vec2( 1, 1 ), args.size0 );\n\tSplit4 b = sd_Split_b_xyx( p.xy, vec2( 0, 0 ), vec2( 1, 1 ), args.size0 );\n\/\/\tSplit4 b = sd_Split_b_H( p.xy,vec2( 0, 0 ), vec2( 1, 1 ), args.size0 );\n\n\td = get_distances( p.xy, b ) + e;\n\n#ifdef SPLIT4_BOUNDS\n\tif ( args.sub10 )\n\t{\n\t\t\/\/ do one more level\n\t\tSplit4 b2 = sd_Split_b_xyy( p.xy, b.b01.pmin, b.b01.pmax, args.size10 );\n\t\tvec4 d2 = get_distances( p.xy, b2 ) + e;\n\t\td.y = getDist4( p.z, d2, args.height10 );\n\t\theights = max( heights, args.height10 );\n\t}\n#endif\n\n#ifdef SPLIT4_BOUNDS\n\tif ( args.sub11 )\n\t{\n\t\t\/\/ do one more level\n\t\tSplit4 b2 = sd_Split_b_xxx( p.xy, b.b11.pmin, b.b11.pmax, args.size11 );\n\t\tvec4 d2 = get_distances( p.xy, b2 ) + e;\n\t\td.w = getDist4( p.z, d2, args.height11 );\n\t\theights = max( heights, args.height11 );\n\t}\n#endif\n\n\treturn getDist4( p.z, d, heights );\n}\n\nstruct TechTilesArgs0\n{\n\tfloat hmin;\n\tfloat hmax;\n\tfloat hdetail; \/\/ the height of sub detail\n};\n\nfloat sd_TechTilesTestsSub0( vec3 p, int lod, float t, Ray ray, vec2 index, TechTilesArgs0 targs )\n{\n\tfloat d = FLT_MAX;\n\n\/\/\td = opI( p.z - 1.0, sd_bounds_range( p.xy, vec2( 0, 0 ), vec2( 1, 1 ) ) );\n\/\/\treturn d;\n\n\tfloat e0 = 0.0125 * 2.0;\n\tfloat e = e0 + t * 0.001; \/\/ else e becomes 0 as far as tracing is concerned... increases cost\n\n\tTechTilesArgs args;\n\n\tvec4 ha = hash42( index );\n\tvec4 hb = hash42( index + 100.0 );\n\n\tfloat rnd_type_and_rotation = ha.w;\n\tvec3 size0_hash = ha.xyz;\n\tvec4 height0_hash = hb;\n\n\targs.sub10 = rnd_type_and_rotation < 0.6;\n\targs.sub11 = rnd_type_and_rotation < 0.3;\n\n\tfloat rota = fract( rnd_type_and_rotation * 3.0 );\n\tif ( rota < 0.25 ) p.xy = p.yx;\n\telse if ( rota < 0.5 ) p.xy = vec2( 1.0 - p.y, p.x );\n\n\tfloat m1 = 0.15;\n\targs.size0 = m1 + ( 1.0 - m1 * 2.0 ) * size0_hash; \/\/ hash32 expensive\n\n\targs.size10 = vec3( 0.25, 0.5, 0.75 );\n\targs.height10 = vec4( 1.0 );\n\/\/\targs.height10 = hash42( index + 80.0 ) * 0.25; \/\/ don't hash all... leave splits is interesting too\n\n\targs.size11 = vec3( 0.25, 0.5, 0.5 );\n\targs.height11 = vec4( 1.0 );\n\/\/\targs.height11 = hash42( index + 85.0 ) * 0.25;\n\n\targs.height0 = mix( vec4( targs.hmin ), vec4( targs.hmax ), height0_hash );\n\n\targs.height10 = args.height0 + targs.hdetail * args.height10;\n\targs.height11 = args.height0 + targs.hdetail * args.height11;\n\n\td = sd_TechTilesTestsSub( p, lod, t, args, e );\n\n\t\/\/ bevel\n\td = opI( d, dot( p - vec3( 0, 0, 0.1 ), vec3( -V45.x, 0, V45.y ) ) );\n\td = opI( d, dot( p - vec3( 0, 0, 0.1 ), vec3( 0, -V30.x, V30.y ) ) );\n\n\treturn d;\n}\n\n\/\/ feature max height will be hscale*2\nfloat sd_TechTiles( vec3 p, int lod, float t, Ray ray, TechTilesArgs0 targs, float e )\n{\n#if ( NUM_TILE_EVALS == 2 )\n\n\t\/\/ we do 2 evals in alternate checker patterns, \"only\" x2 cost and relatively clean\n\t\/\/ it still has corner cases (ha..ha..) but help in some situations\n\n\tfloat d = FLT_MAX;\n\n\tvec2 index0 = floor( p.xy );\n\tvec2 indexi = index0;\n\tfloat m = mod( indexi.x + indexi.y, 2.0 );\n\n\tvec2 dd;\n\n\tfor ( int k = 0; k < 2; k += 1 )\n\t{\n\t\tvec3 p2 = p;\n\t\tvec2 index = index0;\n\t\tp2.xy = p.xy - index;\n\n\t\tif ( m == float( k ) )\n\t\t{\n\t\t\tvec2 offset = vec2( 0.0 );\n\t\t\tvec2 rp2 = p2.xy - 0.5;\n\t\t\tif ( abs( rp2.y ) > abs( rp2.x ) ) offset.y += rp2.y > 0.0 ? 1.0 : -1.0;\n\t\t\telse offset.x += rp2.x > 0.0 ? 1.0 : -1.0;\n\t\t\tindex += offset;\n\t\t\tp2.xy -= offset;\n\t\t}\n\n\t\tfloat ddd = sd_TechTilesTestsSub0( p2, lod, t, ray, index, targs );\n#if 0\n\t\tdd[k] = ddd; \/\/ gpu hangs on desktop (GTX 970)\n#else\n\t\tif ( k == 0 ) dd.x = ddd;\n\t\telse  dd.y = ddd;\n#endif\n\n\/\/\t\td = ddd; \/\/ compiler bug? doesn't work on laptop...\n\t}\n\n\td = opU( dd.x, dd.y );\n\n#else\n\n\tvec3 p2 = p;\n\tvec2 index = floor( p.xy );\n\tp2.xy = p.xy - index;\n\treturn sd_TechTilesTestsSub0( p2, lod, t, ray, index, targs  ); \/\/ only 1 eval\n\n#endif\n\n}\n\nfloat sd_DeathStarTrench( vec3 p, int lod, float t, Ray ray )\n{\n\tfloat d = FLT_MAX;\n\tfloat hw = TRENCH_HALF_WIDTH;\n\n#ifdef RAYMARCH_WITH_LOD\n\td = opU( d, p.x + TRENCH_HALF_WIDTH );\n\td = opU( d, -p.x + TRENCH_HALF_WIDTH );\n\td = opU( d, p.z + TRENCH_DEPTH );\n\td = opI( d, p.z );\n\tif ( abs( d ) > ROUGH_SHELL_D ) return d;\n#endif\n\n\tTechTilesArgs0 targs;\n\ttargs.hmin = 0.025;\n\ttargs.hmax = 0.30;\n\ttargs.hdetail = 0.05;\n\n\t\/\/ tiles for vertical walls\n\tTechTilesArgs0 targs_walls;\n\ttargs_walls.hmin = 0.01;\n\ttargs_walls.hmax = 0.22;\n\ttargs_walls.hdetail = 0.05;\n\n#if 1\n\t\/\/ the shallow trench rows perpendicular to the main one\n\tif ( mod( floor( p.y ), 7.0 ) == 0.0 )\n\t{\n\t\ttargs.hmax *= 0.3;\n\t\ttargs.hmin *= 0.3;\n\t\ttargs_walls.hmax *= 0.3;\n\t\ttargs_walls.hmin *= 0.3;\n\t}\n#endif\n\n\tfloat h03 = 0.0; \/\/ surface trench clamp control\n\tfloat h00 = ( targs.hmax + targs.hdetail ); \/\/ wall tile top clamp control\n\tfloat h0 = h00;\n\tfloat h1 = ( targs_walls.hmax + targs_walls.hdetail );\n\n\t\/\/ inflate more for tracing\n\th0 *= 2.0;\n\th1 *= 2.0;\n\n\tbounds2 bsides = mkbounds_unchecked( vec2( hw - h1, -TRENCH_DEPTH ), vec2( hw, h0 ) );\n\tbounds2 trench_xz = mkbounds_unchecked( vec2( -hw, -TRENCH_DEPTH ), vec2( hw, 10 ) );\n\n\tfloat e = 0.15; \/\/ 51%\n\/\/\tfloat e = 0.25; \/\/ 75%\n\n\tbool top_layer = ( p.z > 0.0 ) && ( p.z < h0 );\n\tbool bottom_layer = ( p.z < -TRENCH_DEPTH + h0 );\n\n\tbool top_layer2 = top_layer && ( abs( p.x ) > hw - h03 );\n\tbool bottom_layer2 = bottom_layer && ( abs( p.x ) <= hw );\n\n\tfloat hoffset = top_layer2 ? 0.0 : -TRENCH_DEPTH;\n\n\ttargs.hmin += hoffset;\n\ttargs.hmax += hoffset;\n\n\t{\n\t\tfloat d1 = sd_TechTiles( p, lod, t, ray, targs, e );\n\t\td = opS( p.z, sd_bounds( p.xz, trench_xz ) );\n\n\t\tif ( top_layer2 || bottom_layer2 ) d = opU( d, d1 );\n\t}\n\n\tif ( inside( bsides, xset( p.xz, abs( p.x ) ) ) ) \/\/ perf culling\n\t{\n\t\tvec3 p2 = p.yzx;\n\t\tp2.z = abs( p2.z );\n\t\tp2.z -= hw;\n\t\tp2.z = -p2.z;\n\t\tp2.xy *= 2.0;\n\n\t\tfloat d1 = opI( p.z - TRENCH_DEPTH, sd_TechTiles( p2, lod, t, ray, targs_walls, e ) );\n\t\td1 = opI( d1, p.z - h00 * 0.45 ); \/\/ clamp top\n\t\td = opU( d1, d );\n\t}\n\n\treturn d;\n}\n\nfloat sindecay( float x, vec3 args ) { return exp( -args.x * x ) * sin( x * args.y ) * args.z; }\nfloat sindecay_derivative( float x, vec3 args ) { return ( args.y * cos( args.y * x ) - args.x * sin( args.y * x ) ) * exp( -args.x * x ) * args.z; }\n\n\/\/ function used in overshoot steps, d is the derivative of the curve at x=0, only x>0 bit is used\nfloat overshoot( float x, vec3 args, float df0 )\n{\n\tif ( x > 1.0 ) return 1.0 - sindecay( x - 1.0, args );\n\treturn cubicstep( x, df0, -sindecay_derivative( 0.0, args ) );\n}\n\n\/\/ first test, with an anticipation bump\nfloat overshootstep1( float x, vec3 args )\n{\n\tfloat df0 = 6.0;\n\tfloat s = 0.5;\n\tif ( x > 0.0 ) return 1.0 - ( 1.0 - overshoot( x, args, df0 ) ) * s;\n\treturn 1.0 - ( 1.0 + ( 1.0 - cubicstep( max( x, -1.0 ) + 1.0, 0.0, df0 ) ) ) * s;\n}\n\n\/\/ dive_step_expin_a from y0+1.0 to 0.0\n\/\/ df0 is the derivative at x=0 if we don't scale by 1\/(1+y0)\n\/\/ the real derivative at 0 is a\/(a+df0)\n\/\/ a controls the rate of ease in exp dive\n\/\/ same as dive_step_expin_y0( x, df0, df0\/a )\nfloat overshootstep2( float x, float df0, float a, vec3 args )\n{\n\tfloat y0 = df0 \/ a; \/\/ calculate y0 such that the derivative at x=0 becomes df0\n\tfloat y = x > 0.0 ? overshoot( x, args, df0 ) : -( 1.0 - exp( x * a ) ) * y0; \/\/ look there is a smiley in that calculation\n\treturn ( y + y0 ) \/ ( 1.0 + y0 ); \/\/ the step goes from y0 to 1, normalize so it is 0 to 1\n}\n\n\/\/ like overshootstep2 but from -inf to 1 instead of 0 to 1 (steep turn)\nfloat overshootstep3( float x, float df0, float a, vec3 args )\n{\n\tfloat y0 = df0 \/ a; \/\/ calculate y0 such that the derivative at x=0 becomes df0\n\tfloat y = x > 0.0 ? overshoot( x, args, df0 ) : 1.0 - exp( -df0 * x );\n\treturn ( y + y0 ) \/ ( 1.0 + y0 ); \/\/ the step goes from y0 to 1, normalize so it is 0 to 1\n}\n\nfloat oversteer( float x, float a, float b, float x0 ) { return exp( -pow2( x ) * 3.0 ) - exp( -pow2( x - x0 ) * 3.0 ) * 0.5; }\n\nstruct CameraRet { vec3 eye; float roll; float pitch; vec4 debug_color; float exposure; };\n\nCameraRet init_cam()\n{\n\tCameraRet cam;\n\tcam.pitch = 0.0;\n\tcam.roll = 0.0;\n\tcam.exposure = 1.0;\n\tcam.debug_color = vec4( 0.0 );\n\treturn cam;\n}\n\nmat4 look_around_mouse_control( mat4 camera, float pitch, float tan_half_fovy )\n{\n\tfloat mouse_ctrl = 1.0;\n\tvec2 mm_offset = vec2( 0.0, pitch );\n\tvec2 mm = vec2( 0.0, 0.0 );\n\n#ifndef EXTRA_3D_CAMERA\n\tif ( iMouse.z > 0.0 )\n\t\tmm = ( iMouse.xy - iResolution.xy * 0.5 ) \/ ( min( iResolution.x, iResolution.y ) * 0.5 );\n#endif\n\n\tmm.x = -mm.x;\n\tmm = sign( mm ) * pow( abs( mm ), vec2( 0.9 ) );\n\tmm *= PI * tan_half_fovy * mouse_ctrl;\n\tmm += mm_offset;\n\treturn camera * yup_spherical_offset( mm.y, mm.x );\n}\n\n\/\/ awkwardly reproduce a camera path similar to the one in the movie\nCameraRet get_camera1_movie_dive_path( float t )\n{\n\tCameraRet cam = init_cam();\n\n\t\/\/ approach curves\n\n\t\/\/ turn curve\n\tfloat x = overshootstep3( t * 0.55 - 1.4, 2.2, 6.0, vec3( 1.1, 3.0, 0.5 ) ) - 1.0;\n\n\t\/\/ descent curve\n\tfloat zz = 1.0 - overshootstep2( t * 1.0 - 2.0, 0.8, 4.0, vec3( 1.0, 1.0, 0.4 ) );\n\tfloat z = -TRENCH_DEPTH * 0.75 + zz * 5.0;\n\n\tcam.eye = vec3( -x, t * FLYING_SPEED, z );\n\n\tfloat pp = ( 1.0 - smoothstep( 0.0, 2.4, t ) );\n\tcam.pitch = -PI * 0.18 * pp;\n\/\/\tcam.debug_color = vec4( GREEN.rgb, pp * 0.5 );\n\n\tfloat rr = oversteer( ( t - 2.7 ), 0.3, 0.3, 1.0 );\n\tcam.roll -= -rr * PI * 0.2;\n\/\/\tcam.debug_color = vec4( RED.rgb, rr*0.5 );\n\n\tcam.eye.z += 0.2 * sin( t * 2.0 );\n\n\tcam.eye.x += ( 0.4 * TRENCH_HALF_WIDTH * sin( t * 1.0 ) ); \/\/ left right amplitude\n\/\/\tcam.roll -= 0.2 * cos( t * 1.0 + 0.25 ); \/\/ steering roll (anticipates, derivative)\n\tcam.roll += 0.05 * sin( t * 2.0 ); \/\/ noise roll\n\n\t\/\/ occasional jumps\n\tcam.eye.z += ( 1.0 - ( 1.0 + cos( PI * spaced_tri( t * 0.2, 4.0, 0.5 ) ) ) * 0.5 ) * 7.0;\n\n\tcam.exposure = mix( 0.57*7., 0.18*7., smoothstep( -1.0, 2.0, cam.eye.z ) );\n\treturn cam;\n}\n\nmat4 get_camera1_movie_dive( mat4 camera, float tan_half_fovy, float t, inout vec4 debug_color, inout float exposure )\n{\n\tvec3 center = get_camera1_movie_dive_path( t + 0.05 ).eye;\n\tCameraRet cam = get_camera1_movie_dive_path( t );\n\tvec3 eye = cam.eye;\n\tvec3 up = vec3( 0, 0, 1 );\n\tup.xz = rotate_with_angle( up.xz, cam.roll );\n\tcamera = lookat( eye, center, up );\n\texposure = cam.exposure;\n\tdebug_color = cam.debug_color;\n\treturn look_around_mouse_control( camera, cam.pitch, tan_half_fovy );\n}\n\nCameraRet get_camera2_path( float t )\n{\n\tt *= 0.4; \/\/ slow down\n\tCameraRet cam = init_cam();\n\tcam.exposure = 0.35*7.;\n\tcam.roll -= cos( t + 0.25 ) * 0.175;\n\tcam.pitch -= PI * 0.2;\n\tfloat xpos_max = 2.5;\n\tfloat ypos = t * FLYING_SPEED;\n\txpos_max += ( 1.0 + sin( t * 0.05 ) * 0.5 ) * 2.0;\n\tcam.eye = vec3( xpos_max * sin( t ), ypos, 2.75 );\n\treturn cam;\n}\n\nmat4 get_camera2( mat4 camera, float tan_half_fovy, float t, inout vec4 debug_color, inout float exposure )\n{\n\tvec3 center = get_camera2_path( t + 0.02 ).eye;\n\tCameraRet cam = get_camera2_path( t );\n\tvec3 eye = cam.eye;\n\tvec3 up = vec3( 0, 0, 1 );\n\tup.xz = rotate_with_angle( up.xz, cam.roll );\n\tcamera = lookat( eye, center, up );\n\texposure = cam.exposure;\n\tdebug_color = cam.debug_color;\n\treturn look_around_mouse_control( camera, cam.pitch - PI * 0.08, tan_half_fovy );\n}\n\n\/\/ plane base 0,0,pz plane normal 0,0,nz\nvec2 intersect_plane2_nz( Ray ray, float pz, float nz )\n{\n\tfloat epsilon = 1e-4;\n\tfloat vdotn = ray.d.z * nz;\n\tfloat d = ( ray.o.z - pz ) * nz;\n\tfloat t = ( abs( vdotn ) <= epsilon ? FLT_MAX : -d \/ vdotn );\n\treturn vec2( t, d );\n}\n\n\/\/ plane base 0,0,px plane normal 0,0,nx\nvec2 intersect_plane2_nx( Ray ray, float px, float nx )\n{\n\tfloat epsilon = 1e-4;\n\tfloat vdotn = ray.d.x * nx;\n\tfloat d = ( ray.o.x - px ) * nx;\n\tfloat t = ( abs( vdotn ) <= epsilon ? FLT_MAX : -d \/ vdotn );\n\treturn vec2( t, d );\n}\n\n\/\/ turn t (result of intersect_plane* functions) into a negative space range\nvec2 mm3( vec2 t ) { return t.y * t.x > 0.0 ? vec2( t.x, FLT_MAX ) : vec2( -FLT_MAX, t.x ); }\n\n\/\/ intersect 2 negative space ranges, assume convex\nvec2 mm4( vec2 a, vec2 b ) { return vec2( max( a.x, b.x ), min( a.y, b.y ) ); }\n\n\/\/ raytrace to get a better first march distance\nfloat warpTrace( Ray ray )\n{\n\tvec2 t0 = intersect_plane2_nz( ray, ROUGH_SHELL_D, 1.0 );\n\tvec2 t1 = intersect_plane2_nx( ray, -TRENCH_HALF_WIDTH + ROUGH_SHELL_D, 1.0 );\n\tvec2 t2 = intersect_plane2_nx( ray, TRENCH_HALF_WIDTH - ROUGH_SHELL_D, -1.0 );\n\tvec2 t3 = intersect_plane2_nz( ray, -TRENCH_DEPTH + ROUGH_SHELL_D, 1.0 );\n\tfloat d = opU( opU( opI( t0.y, t1.y ), opI( t0.y, t2.y ) ), t3.y );\n\tif ( d < 0.0 ) return 0.0; \/\/ we are inside... do nothing and gtfo\n\tvec2 r0 = mm3( t0 );\n\tvec2 r01 = mm4( r0, mm3( t1 ) );\n\tvec2 r02 = mm4( r0, mm3( t2 ) );\n\tvec3 dd = vec3( FLT_MAX );\n\tif ( r01.x != FLT_MAX && r01.y > r01.x && r01.x > 0.0 ) dd.x = r01.x;\n\tif ( r02.x != FLT_MAX && r02.y > r02.x && r02.x > 0.0 ) dd.y = r02.x;\n\tif ( t3.x != FLT_MAX && t3.x > 0.0 ) dd.z = t3.x;\n\treturn mincomp( dd );\n}\n\nfloat sd_Scene( vec3 p, int lod, float t, Ray ray )\n{\n\tfloat d1 = FLT_MAX;\n\tfloat d2 = FLT_MAX;\n#ifdef PRIMITIVES\n\/\/ was for simple check lighting (need disable shadow hacks)\n\td1 = opU( sd_bounds_range( p, -vec3( 1. ), vec3( 1. ) ), length( p - vec3( 0., 3., 0. ) ) - 1. );\n#endif\n#ifdef SORT_OF_MOON\n\td2 = sd_DeathStarTrench( p, lod, t, ray );\n#endif\n\treturn opU( d1, d2 );\n}\n\nstruct TraceOutput\n{\n\tfloat t; \/\/ ray travel distance\n\tfloat num_iterations;\n\tfloat dist; \/\/ \"hit\" point distance to surface\n\tfloat shadow;\n};\n\nvec3 sd_SceneGrad( vec3 p, int lod, TraceOutput to, Ray ray )\n{\n\t\/\/ if p is far away the epsilon will vanish in the addition and normal calculation will be broken\n\t\/\/ this was to keep the gradient working even at large-ish distances...\n\/\/\tvec3 h = max( vec3( 0.006 ), abs( p ) * 1e-6 );\n\tvec3 h = vec3( 0.001 );\n\tvec3 n = normalize( vec3( sd_Scene( p + vec3( h.x, 0.0, 0.0 ), lod, to.t, ray ),\n\t\t\t\t\t\t\t  sd_Scene( p + vec3( 0.0, h.y, 0.0 ), lod, to.t, ray ),\n\t\t\t\t\t\t\t  sd_Scene( p + vec3( 0.0, 0.0, h.z ), lod, to.t, ray ) ) - to.dist ); \/\/ to.dist == sd_Scene( p, lod, to.t, ray ), our last eval \n\t\/\/ if the normal is backfacing, our point p is likely behind an occluded object (a thin object or an edge we accidentally traced through)\n\t\/\/ this creates distracting salt noise that makes certain lighting components unstable (fresnel)\n\t\/\/ if we care the simplest hack to do that attenuates the artifacts in our scene is to negate\n\treturn dot( n, ray.d ) > 0.0 ? -n : n;\n}\n\nTraceOutput traceScene( Ray ray, int lod, float shadow_sharpness, float tmax, bool warp_trace, float max_iterations )\n{\n\tTraceOutput to;\n\tto.t = 0.0;\n\tto.num_iterations = 0.0;\n\tto.dist = 0.0;\n\tto.shadow = 1.0;\n\n#ifdef RAYTRACE_FIRST_MARCH_DISTANCE\n\tif ( warp_trace ) { to.t += warpTrace( ray ); if ( to.t == FLT_MAX ) return to; } \/\/ jump close to first hit\n#endif\n\n\tfor ( int i = 0; i < MAX_ITERATIONS; ++i )\n\t{\n\t\tfloat d = sd_Scene( ray.o + to.t * ray.d, lod, to.t, ray );\n\t\tto.dist = d;\n\t\tif ( ( abs( to.dist ) <= DBREAK * to.t ) || to.t > tmax ) break;\n\t\tto.shadow = min( to.shadow, shadow_sharpness * to.dist \/ to.t ); \/\/ iq's awesome trick https:\/\/iquilezles.org\/www\/material\/nvscene2008\/rwwtt.pdf for shadows\n\t\tto.t += to.dist * TFRAC;\n\t\tto.num_iterations += 1.0;\n\t\tif ( to.num_iterations >= max_iterations ) break;\n\t}\n\n\tto.shadow = max( 0.0, to.shadow ); \/\/ fixes some artifacts\n\treturn to;\n}\n\nfloat star_glare( float x, float e, float c ) { return exp2( -pow( x, e ) * c ); }\n\n\/\/ black body color adapted from Fabrice Neyret's https:\/\/www.shadertoy.com\/view\/4tdGWM\n\/\/ T absolute temperature (K), m1 is a 0,1 param that controls output scale\nvec3 black_body( float T, float m1 )\n{\n\tfloat m = .01 + 5. * m1;\n\tvec3 f = vec3( 1. ) + 0.5 * vec3( 0., 1., 2. );\n\tfloat Trcp = 1. \/ T;\n\treturn ( 10. \/ m * ( f * f * f ) ) \/ ( exp( ( 19e+3 * f * Trcp ) ) - 1. );  \/\/ Planck law\n}\n\n\/\/ assumes x 0,1 maps to 24e+2, 30e+3\n#define FF 24.\n\/\/ vaguely use this distribution there https:\/\/en.wikipedia.org\/wiki\/Stellar_classification\nfloat Tprob2( float x ) { return exp( -x * FF ); }\nfloat Tprob2_int( float x ) { return -exp( -x * FF ) * ( 1.0 \/ FF ); }\nfloat Tprob2_int_inv( float x ) { return -log( -x * FF ) * ( 1.0 \/ FF ); }\n#if 0\nfloat cdf( float x ) { return Tprob2_int( x ) - Tprob2_int( 0. );}\nfloat cdf_inv( float x ) { return Tprob2_int_inv( x + Tprob2_int( 0. ) ); }\n#else\nfloat cdf( float x ) { return Tprob2_int( x ) - ( -1. \/ FF ); } \/\/ hardcode the function\nfloat cdf_inv( float x ) { return Tprob2_int_inv( x + ( -1. \/ FF ) ); }\n#endif\n\nvec3 star_color( float x ) { return black_body( mix( 24e+2, 30e+3, x ), 1. ); }\n\n#ifdef STARFIELD\n\/\/ stars are clamped on their cell borders (we don't bother iterating neighbours)\nvec3 starfield( vec3 viewvec )\n{\n\tvec2 num = vec2( 1.0, 2.0 ) * 250.0;\n\tfloat theta = acos( viewvec.z );\n\tfloat phi = calc_angle( viewvec.xy );\n\tif ( phi < 0.0 ) phi += 2.0 * PI;\n\tvec2 sc = vec2( theta, phi );\n\tvec2 scd = vec2( 1.0, 2.0 ) * PI \/ num;\n\tvec2 sci = floor( sc \/ scd ); \/\/ if ( mod( sci.x + sci.y, 2.0 ) == 1.0 ) return RED;\n\tvec2 scf = ( sc - sci * scd ) \/ scd; \/\/\treturn vec3( scf, 0.0 ); \/\/ view cells\n\/\/\tvec4 r = vec4(0.5); \/\/ aligned stars\n\tvec4 r = hash42( sci ); \/\/\treturn vec3( r ); \/\/ color cell by hash\n\tvec2 scc = ( ( sci + 0.5 ) * scd ); \/\/ cell center\n\tvec2 r2 = hash22( sci ); \/\/\treturn vec3( r2.y ); \/\/ debug \/\/ x: discard probability, y: color distribution uniform input\n\tif ( r2.x > sin( scc.x ) ) return BLACK; \/\/ randomly decimate in sin theta fashion for something uniform-ish\n\/\/\tif ( r2.x > sin( scc.x ) ) return RED; \/\/ visualize the decimation\n\tvec2 sc2 = ( ( sci + r.xy ) * scd ); \/\/ cell center\n\tvec3 v = zup_spherical_coords_to_vector( sc2.x, sc2.y ); \/\/ return v;\n\tv = normalize( v ); \/\/ we also need to renormalize already normal vector here else broken on GTX1060 laptop\n\tfloat c = 1.0 - dot( v, viewvec ); \/\/ return vec3( 1.0 - smoothstep( 0.0, 1.0, c ) ); \/\/ debug: show the full disks (max glow radius) \/\/ 0->2\n\tvec3 col = star_color( cdf_inv( r2.y * cdf( 1. ) ) ); \/\/ return vec3( chrominance( col ) );\n#if 1\n\tc *= 1e+6;\n\tcol = mix( col, vec3( maxcomp( col ) ), 0.5 ); \/\/ after all those efforts we lerp towards monotone... :-]\n\treturn star_glare( c * 0.0095, 0.8, 80.0 ) * col * 1.5; \/\/ fixme: make the radius resolution\/fovy dependent \n\/\/\treturn star_glare( c * 0.01, mix( 0.4, 0.8, r.w ), mix( 30.0, 60.0, r.z ) ) * col * 120.; \/\/ manual glow;\n#else\n\/\/ with larger glares and plausible star colors it starts to look like space photos a bit (maybe)\n\tc *= 6e+4;\n\treturn star_glare( c, mix( 0.3, 0.8, r.w ), mix( 3.0, 6.0, r.z ) ) * col * 80.; \/\/ manual glow;\n#endif\n}\n#endif\n\nvoid build_onb( vec3 z, vec3 x0, out vec3 x, out vec3 y ) { y = normalize( cross( x0, z ) ); x = normalize( cross( z, y ) ); }\n\nvec3 sunval( float sun_dp, vec2 p, vec3 sun_color, vec3 sun_color_c )\n{\n\tfloat r = ( ( -sun_dp + 1. ) * 0.5 ) * 300.0;\n\tfloat f = 0.;\n#if 1\n\/\/ flares\n\tfloat a = calc_angle( p );\n\tfloat da = 2.0 * PI \/ 6.0;\n\tfloat a0 = floor( a * ( 1.0 \/ da ) ) * da;\n\tvec2 va0 = perp( unit_vector2( a0 ) );\n\tvec2 va1 = -perp( unit_vector2( a0 + da ) );\n\tvec2 d = vec2( dot( va0, p ), dot( va1, p ) );\n\tfloat f0 = opU( d.x, d.y );\n\tf = f0 * 8.;\n\tf += 1.0 - exp( -r * 0.01 ) * 0.85;\n\tf = 1. \/ ( 0.01 + f * 50. );\n\tf *= 0.125;\n#endif\n\treturn 2. * sun_color * star_glare( max( 0.0, r - 0.17 ) * 0.075, 0.35, 24.0 ) + f * sun_color_c;\n}\n\n\/\/ I used a bit of pbr reference to see what happens (don't worry it all deteriorates into sad hacks pretty quickly)\n\/\/ https:\/\/learnopengl.com\/#!PBR\/Theory\n\/\/ http:\/\/graphicrants.blogspot.jp\/\n\/\/ alpha = roughness * roughness\nfloat D_blinn_phong( float m_dot_n, float alpha ) { float alpha_sqr = alpha * alpha; return pow( m_dot_n, ( 2. \/ alpha_sqr ) - 2. ) \/ ( PI * alpha_sqr ); }\nfloat D_beckmann( float m_dot_n, float alpha )\n{\n\tfloat alpha_sqr = alpha * alpha;\n\tfloat m_dot_n_sqr = m_dot_n * m_dot_n;\n\treturn exp( ( m_dot_n_sqr - 1. ) \/ ( alpha_sqr * m_dot_n_sqr ) ) \/ ( PI * alpha_sqr * m_dot_n_sqr * m_dot_n_sqr );\n}\n\/\/ Trowbridge-Reitz\nfloat D_GGX( float m_dot_n, float alpha ) { float alpha_sqr = alpha * alpha; return alpha_sqr \/ ( PI * pow2( pow2( m_dot_n ) * ( alpha_sqr - 1. ) + 1. ) ); }\nfloat G_implicit( float n_dot_l, float n_dot_v ) { return n_dot_l * n_dot_v; }\nfloat G_neumann( float n_dot_l, float n_dot_v ) { return n_dot_l * n_dot_v \/ max( n_dot_l, n_dot_v ); }\nfloat G_kelemen( float n_dot_l, float n_dot_v, float v_dot_h ) { return n_dot_l * n_dot_v \/ pow2( v_dot_h ); }\nfloat F_none( float v_dot_h, float F0 ) { return F0; }\nfloat F_schlick( float v_dot_h, float F0 ) { return F0 + ( 1. - F0 ) * pow5( 1. - v_dot_h ); }\n\nvec3 add_light_contrib( vec3 albedo, vec3 l, vec3 n, vec3 v, float Li, float dwi, float kdiffuse, float kspecular )\n{\n\tfloat F0 = 0.08;\n\tfloat roughness = 0.25;\n\tfloat alpha = roughness * roughness;\n\tvec3 h = normalize( l + v );\n\tfloat eps = 1e-4; \/\/ else divides by zero\n\tfloat n_dot_l = max( eps, dot( n, l ) );\n\tfloat n_dot_v = max( eps, dot( n, v ) );\n\tfloat n_dot_h = max( eps, dot( n, h ) );\n\tfloat v_dot_h = max( eps, dot( h, v ) );\n\tfloat l_dot_h = max( eps, dot( l, h ) );\n\n\/\/\tfloat D = D_blinn_phong( n_dot_h, alpha ); \/\/ https:\/\/en.wikipedia.org\/wiki\/Blinn%E2%80%93Phong_shading_model\n\/\/\tfloat D = D_beckmann( n_dot_h, alpha );\n\tfloat D = D_GGX( n_dot_h, alpha ); \/\/ n_dot_h should probably be clamped to >=0\n\n\/\/\tfloat G = G_implicit( n_dot_l, n_dot_v );\n\tfloat G = G_neumann( n_dot_l, n_dot_v );\n\/\/\tfloat G = G_kelemen( n_dot_l, n_dot_v, v_dot_h );\n\n\/\/\tfloat F = F_none( n_dot_v, F0 );\n\tfloat F = F_schlick( n_dot_v, F0 );\n\n\treturn  ( ( kdiffuse * albedo * ( 1.0 \/ PI ) + kspecular * ( D * F * G ) \/ ( 4. * n_dot_l * n_dot_v ) ) ) * Li * n_dot_l * dwi;\n}\n\n\/\/http:\/\/www.cs.utah.edu\/~reinhard\/cdrom\/tonemap.pdf\nvec3 tonemap_reinhard( vec3 x ) { return x \/ ( 1. + x ); }\nvec3 gamma_correction( vec3 L ) { return pow( L, vec3( 0.45 ) ); }\n\/\/ mentioned in http:\/\/resources.mpi-inf.mpg.de\/tmo\/logmap\/\nvec3 gamma_correction_itu( vec3 L ) { return mix( 4.5061986 * L, 1.099 * pow( L, vec3( 0.45 ) ) - 0.099, step( vec3( 0.018 ), L ) ); }\n\nfloat penumbra_sun( float x ) { x = max( x, 0.0 ); return 1.0 - exp2( -x * 1.9 ); } \/\/ darker\/narrower\n\/\/float penumbra_sun( float x ) { x = max( -x, 0.0 ); return exp2( -x * iSlider0 * 10. ); } \/\/ brighter\/wider\nfloat penumbra_bounce( float x ) { x = max( x, 0.0 ); return 1.0 - exp2( -x * 0.2 ); } \/\/ darker\/narrower\n\/\/float penumbra_bounce( float x ) { x = max( x, 0.0 ); return x = exp2( -x * 1.4 ); } \/\/ brighter\/wider\n\n\/\/ e = eye pos, v = vader vector, p = lit point, n = normal, l = sun direction\nvec3 shade( in vec3 e, in vec3 v, mat4 cam, in vec3 p, in vec3 n, vec3 l\n\t\t\t, float traced_shadow, float sun_shadow, float first_bounce\n\t\t\t, TraceOutput to, float ao, float exposure, vec2 uv )\n{\n\tvec3 col = vec3( 0. );\n\tbool sky = to.t > TMAX;\n\n\/\/\treturn sky ? BLACK : ( vec3( 1.0 ) + n ) * 0.5; \/\/ normal debug color\n\/\/\treturn vec3( 1.0 - exp( -to.t * 0.15 ) ); \/\/ distance to hit point\n\/\/\treturn viridis_quintic( to.num_iterations * ( 1.0 \/ float( MAX_ITERATIONS ) ) ); \/\/ visualize the number of iterations\n\/\/\treturn viridis_quintic( to.dist \/ ( DBREAK * to.t ) );\n\/\/\treturn viridis_quintic( to.dist );\n\/\/\treturn viridis_quintic( ao );\n\n\tvec3 sun_color = black_body( 19000.0, 0.8 );\n\tvec3 sun_color_c = chrominance( sun_color );\n\tvec3 albedo = vec3( 0.85, 0.85, 1 );\n#ifdef COLOR_TILES\n\talbedo = mix( vec3( 0.2 ), vec3( 1.0 ), hash32( floor( p.xy ) ) );\n#endif\n\n\tif ( !sky )\n\t{\n\t\tfloat iter = to.num_iterations * ( 1.0 \/ float( MAX_ITERATIONS ) );\n\t\tfloat fog_start = 30.0;\n\t\tfloat fog = exp2( -max( to.t - fog_start, 0.0 ) * 0.02 ); \/\/ this is mostly to fade the horizon\n\t\tfloat ao_z = 1.0 - saturate( abs( p.z * ( 1.0 \/ TRENCH_DEPTH ) ) ); \/\/ vertical occlusion\n\t\tfloat kdiffuse = 0.75;\n\t\tfloat kspecular = 1.0;\n\t\tfloat sunI = 2.2;\n\t\tfloat kambient = 0.005;\n\t\tfloat shadow = min( traced_shadow, sun_shadow );\n\n\/\/\t\treturn vec3( shadow );\n\/\/\t\tn = normalize( n + 0.07 * l ); \/\/ soften a bit\n#if 1\n \/\/ main sun light\n\t\tcol += add_light_contrib( albedo, l, n, -v\n\t\t\t\t\t\t\t\t  , sunI * mix( 0.0, 1., ao_z ) * mix( 0., 1., shadow )\n\t\t\t\t\t\t\t\t  , 1.\n\t\t\t\t\t\t\t\t  , kdiffuse\n\t\t\t\t\t\t\t\t  , kspecular * shadow * ao_z ); \/\/ modulate specular to reduce sparkles\n#endif\n#if 1\n\/\/ dummy secondary source\n\t\tvec3 l2 = normalize( vec3( 5, -5.5, 10 ) );\n\t\tcol += add_light_contrib( albedo, l2, n, -v\n\t\t\t\t\t\t\t\t  , 0.34 * mix( 0.08, 1., ao_z ) * ao\n\t\t\t\t\t\t\t\t  , 1.\n\t\t\t\t\t\t\t\t  , kdiffuse\n\t\t\t\t\t\t\t\t  , kspecular * shadow * ao_z ); \/\/ modulate specular to reduce sparkles\n#endif\n#if 1\n\/\/ first bounce\n\t\tcol += add_light_contrib( albedo, reflect( l, vec3( -1., 0., 0. ) ), n, -v\n\t\t\t\t\t\t\t\t  , first_bounce\n\t\t\t\t\t\t\t\t  , 0.05\n\t\t\t\t\t\t\t\t  , kdiffuse\n\t\t\t\t\t\t\t\t  , kspecular * shadow * ao_z );\n#endif\n#if 1\n\/\/ ambient\n\t\tcol += PI * vec3( kambient * ao_z * ao );\n#endif\n#if 1\n\/\/ random crap\n\t\tcol *= fog * ao * ao * ( 1. - iter * 0.7 );\n#endif\n\t}\n\telse\n\t{\n\t\tcol = vec3( 0. );\n\n#ifdef SUN\n\t\tvec3 sx, sy;\n\t\tbuild_onb( l, cam[0].xyz, sx, sy ); \/\/ we want the flares to be viewspaceish\n\t\tcol += sunval( dot( l, v ), vec2( dot( v, sx ), dot( v, sy ) ), sun_color, sun_color_c );\n#endif\n\n#ifdef STARFIELD\n\t\tcol += starfield( v );\n#endif\n\t}\n\n\tcol = exposure * tonemap_reinhard( col );\n\/\/\tcol = max( vec3( 0. ), contrast( col, vec3( 1.015 ) ) );\n\n\tfloat vignette = .0 + 1. * pow( 20. * uv.x * uv.y * ( 1. - uv.x ) * ( 1. - uv.y ), 0.075 ); \n\tcol *= vignette;\n\n\tcol = gamma_correction_itu( col );\n\/\/\tcol = gamma_correction( col );\n\n\treturn col;\n}\n\n\/\/ black -> green -> white gradient\nvec3 laser_heatmap( float u ) { float r = 0.5; vec3 c = vec3( smoothbump( r * float( 2.0 ), r, u ) ); c.g += smoothbump( r * float( 1.0 ), r, u ); return c; }\n\n#define LASER_LEN 1.5\n#define LASER_LEN_RCP (1.0\/(LASER_LEN))\n#define LASER_SPEED (60.0)\n\/\/ spawn at player + that\n#define LASER_SPAWN_DISTANCE (40.0)\n#define LASER_PERIOD (LASER_SPAWN_DISTANCE*2.0\/(FLYING_SPEED+LASER_SPEED))\n\n\/\/ for lasers capsules...\nvec2 sphere_trace( vec2 O, vec2 d, float radius, vec2 C )\n{\n\tfloat tp = dot( C - O, d ); \/\/ P = project C on line (O,d)\n\tvec2 P = O + d * tp;\n\tfloat h_sqr = lensqr( P - C );\n\tfloat radius_sqr = radius * radius;\n\tif ( h_sqr > radius_sqr ) return vec2( FLT_MAX, FLT_MAX ); \/\/ ray missed the sphere\n\/\/\tbool start_inside = lensqr( O - C ) <= radius_sqr; \/\/ start inside the sphere?\n\tfloat dt = sqrt( radius_sqr - h_sqr ); \/\/ distance from P to In (near hit) and If (far hit)\n\/\/\tif ( start_inside )\treturn vec2(FLT_MAX,tp+dt);\t\/\/ order In->O->If \/\/ record only far hit If\n\/\/\tif ( tp < 0.0 )\treturn vec2(FLT_MAX,FLT_MAX); \/\/ order In->If->O \/\/ O is outside the sphere and beyhond If, no hit\n\treturn vec2( tp - dt, tp + dt ); \/\/ record 2 hits In, If\n}\n\n\/\/ laser code is total bloat, we raytrace infinite cylinders and integrate something\n\/\/ volumetric along a fixed number of steps between the 2 intersections, when they exist\nvec3 lasers( Ray view_ray, float hs, float time, float t0 )\n{\n\tfloat fade = 1.0 - smoothstep( -TRENCH_DEPTH * 0.05, 0.0, view_ray.o.z );\n\tfloat pos = FLYING_SPEED * time; \/\/ camera pos\n\tfloat laser_period = LASER_PERIOD * FLYING_SPEED;\n\tfloat offset = hs * 5.0;\n\tfloat nth = floor( ( pos - offset ) \/ laser_period );\n\tfloat y0 = offset + nth * laser_period + LASER_SPAWN_DISTANCE;\n\tfloat yy_t = ( pos - ( offset + nth * laser_period ) ) * ( 1.0 \/ FLYING_SPEED );\n\tfloat laser_pos = y0 - yy_t * LASER_SPEED;\n\tvec2 orig = hash21( nth * hs );\n\tfloat w2 = TRENCH_HALF_WIDTH * 0.8;\n\torig = mix( vec2( -w2, -TRENCH_DEPTH * 0.9 ), vec2( w2, -TRENCH_DEPTH * 0.3 ), orig );\n\tfloat r = 0.085;\n\tvec3 color = BLACK;\n\n\t\/\/todo: case when we are inside the laser\n\tfloat vzx1len = length( view_ray.d.zx );\n\tvec2 vzx1 = view_ray.d.zx \/ vzx1len;\n\tvec2 st = sphere_trace( view_ray.o.zx, vzx1, r, vec3( orig.x, 0, orig.y ).zx );\n\tif ( st.x == FLT_MAX || \/\/ no hit\n\t\t st.y < 0.0 ) \/\/ hitting behind the camera\n\t\t\t\t\t  \/\/ we don't intersect the laser cylinder, gtfo\n\t\treturn color;\n\n\tvec3 cacc = vec3( 0.0);\n\tfloat aacc = 0.0;\n\n\tfloat vzx1len_rcp = 1.0 \/ vzx1len;\n\tfloat t00 = st.x * vzx1len_rcp;\n\tfloat t11 = st.y * vzx1len_rcp;\n\n#define LASER_ITER 20.0\n\tfor ( float i = 0.0; i <= LASER_ITER; i += 1.0 )\n\t{\n\t\tfloat x = i * ( 1.0 \/ LASER_ITER );\n\t\tfloat t = t00 + ( t11 - t00 ) * cubicstep(  x, 2.5, 2.5 ); \/\/ smaller steps near the center to better capture the gradient\n\t\tvec3 p = view_ray.o + t * view_ray.d;\n\t\tvec3 vzx = p - project_on_liney( p, vec3( orig.x, 0, orig.y ) );\n\t\tvec3 pl = p;\n\t\tpl.y -= laser_pos; \/\/ local\n\t\tfloat ri = length( vzx );\n\t\tif ( pl.y > LASER_LEN - r ) ri = length( pl - vec3( orig.x, LASER_LEN - r, orig.y ) );\n\t\telse if ( pl.y < -LASER_LEN + r ) ri = length( pl - vec3( orig.x, -LASER_LEN + r, orig.y ) );\n\t\tfloat ddx = 1.0 - saturate( ri * ( 1.0 \/ r ) );\n\t\tfloat xxx = pl.y * LASER_LEN_RCP;\n\t\tddx *= box( xxx ) * fade;\n\t\tvec3 emission = laser_heatmap( ddx ) * 0.2;\n\t\tfloat opacity = saturate( ddx * 0.1 );\n\t\tcacc += ( 1.0 - aacc ) * emission;\n\t\taacc += ( 1.0 - aacc ) * opacity; \/\/ http:\/\/developer.download.nvidia.com\/books\/HTML\/gpugems\/gpugems_ch39.html\n\t}\n\n\tcolor = cacc;\n\tcolor = cacc * aacc;\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4( 0., 0., 0., 1 );\n\tfloat aspect = iResolution.x \/ iResolution.y;\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n\n\/\/\tfragColor.xyz = star_color( uv.x ).xyz; return;\n\/\/\tfragColor.xyz = laser_heatmap( uv.x ); return;\n\n\tfloat tan_half_fovy = 0.6;\n\tfloat znear = 0.1;\n\tvec4 debug_color = vec4( 1.0, 1.0, 1.0, 0.0 );\n\tfloat time = iTime + TIME_OFFSET;\n\tfloat fade = 1.0;\n\tfloat exposure = 1.0;\n\tmat4 camera;\n\n#ifdef EXTRA_3D_CAMERA\n\tcamera[0] = iCamera[0];\n\tcamera[1] = iCamera[1];\n\tcamera[2] = iCamera[2];\n\tcamera[3] = iCamera[3];\n\ttan_half_fovy = iTanHalfFovy;\n\texposure = iExposure;\n#else\n\t{\n\t\tfloat time_slice = 30.0;\n#ifdef CAMERA_REPEAT\n\t\tfloat camera_select = mod( floor( time \/ time_slice ), 2.0 );\n\t\tfloat time_slice_r = 0.25;\n\t\tfade = 1.0 - min( spaced_bumps( time, time_slice, time_slice_r ), 1.0 - box( time \/ time_slice_r ) );\n\t\ttime = mod( time, time_slice );\n#else\n\t\tfloat camera_select = 0.0;\n#endif\n\t\tif ( camera_select == 0.0 ) camera = get_camera1_movie_dive( camera, tan_half_fovy, time, debug_color, exposure );\n\t\telse camera = get_camera2( camera, tan_half_fovy, time + CAM2_TIME_OFFSET, debug_color, exposure );\n\t}\n#endif\n\n\tRay view_ray = get_view_ray( ( uv - vec2( 0.5 ) ) * 2.0, znear, aspect, tan_half_fovy );\n\n\tview_ray.o = camera[3].xyz;\n\tview_ray.d = ( camera * vec4( view_ray.d, 0.0 ) ).xyz;\n\tview_ray.d = normalize( view_ray.d ); \/\/ have to renormalize this already normalized (yey!) vector here else lasers are broken (only on laptop GTX1060)\n\n\tTraceOutput to = traceScene( view_ray, 0, 15.0, TMAX, true, float( MAX_ITERATIONS ) );\n\n\tvec3 l = normalize( vec3( -8, 0, 5.2 ) ); \/\/ careful with z, long shadows make the tracing slower\n\tvec3 p = view_ray.o + to.t * view_ray.d;\n\tvec3 n = sd_SceneGrad( p, 0, to, view_ray );\n\n\tfloat ao = 1.0;\n\n#ifdef AO\n\t{\n\t\t\/\/ https:\/\/iquilezles.org\/www\/material\/nvscene2008\/rwwtt.pdf\n\t\tfloat delta = 0.1;\n\t\tfloat a = 0.0;\n\t\tfloat b = 1.0;\n\t\tfor ( int i = 0; i < 5; i++ )\n\t\t{\n\/\/\t\t\tif ( to.t > 30 ) break;\n\t\t\tfloat fi = float( i );\n\t\t\tfloat d = sd_Scene( p + delta * fi * n, 0, to.t, view_ray );\n\t\t\ta += ( delta * fi  - d ) * b;\n\t\t\tb *= 0.5;\n\t\t}\n\t\tao = saturate( 1.0 - 1.2 * a );\n\t\t\/\/ note: had to lower DBREAK inorder to avoid ugly patterns when far away from surface\n\t}\n#endif\n\n\tbool sky = to.t > TMAX;\n\n\tfloat sun_shadow = 1.0; \/\/ shadow\n\tfloat first_bounce = 0.0; \/\/ first light bounce (illuminates the bottom left corner)\n\tfloat traced_shadow = 1.0;\n\n\tif ( !sky )\n\t{\n#ifdef TRACED_SHADOW\n\t\tfloat expensive_shadow_dist = 40.0;\n\t\tif ( to.t < expensive_shadow_dist )\n\t\t{\n\t\t\tRay sray;\n\t\t\tsray.o = p + n * 0.1 * 1.0;\n\t\t\tsray.d = l;\n\n\t\t\tTraceOutput tos = traceScene( sray, 0, 15.0, 10.0, false, 20.0 );\n\t\t\ttraced_shadow = tos.shadow;\n\t\t\ttraced_shadow += smoothstep( expensive_shadow_dist - 2.0, expensive_shadow_dist, to.t );\n\t\t\ttraced_shadow = saturate( traced_shadow );\n\t\t}\n#endif\n\t\tvec2 l2 = normalize( l.xz );\n\t\tvec2 l2r = reflect( l2, vec2( -1, 0 ) );\n\t\tfloat so = 0.0; \/\/ shadow plane offset from z=0\n\t\tPlane2 pl1 = mkplane2( vec2( -TRENCH_HALF_WIDTH, so ), -perp( l2 ) );\n\t\tPlane2 pl2 = mkplane2( vec2( TRENCH_HALF_WIDTH, so ), -perp( l2r ) );\n\t\tPlane2 pl3 = pl2;\n\t\tpl3.normal = -pl3.normal;\n\t\tpl3.base.y += ( l2.y \/ l2.x ) * 2.0 * TRENCH_HALF_WIDTH;\n\n\t\tif ( ( abs( p.x ) < TRENCH_HALF_WIDTH ) && ( p.z < so ) )\n\t\t{\n#ifdef ANALYTICAL_SHADOW\n\t\t\tsun_shadow = penumbra_sun( dot( p.xz - pl1.base, pl1.normal ) );\n#endif\n\t\t\tfirst_bounce = penumbra_bounce( min( dot( p.xz - pl2.base, pl2.normal ),\n\t\t\t\t\t\t\t\t\t\t\t\t dot( p.xz - pl3.base, pl3.normal ) ) );\n\n\t\t\tfirst_bounce *= step( p.x, TRENCH_HALF_WIDTH - 0.5 ) * step( p.z, 0.0 );\n\t\t}\n\t}\n\n\tfragColor.rgb = shade( view_ray.o, view_ray.d, camera, p, n, l\n\t\t\t\t\t\t   , traced_shadow, sun_shadow, first_bounce, to, ao, exposure, uv );\n#ifdef LASERS\n\tfragColor.rgb += lasers( view_ray, 0.0, time, to.t );\n\tfragColor.rgb += lasers( view_ray, 1.0, time, to.t );\n\tfragColor.rgb += lasers( view_ray, -1.0, time, to.t );\n\tfragColor.rgb += lasers( view_ray, -0.5, time, to.t );\n\tfragColor.rgb += lasers( view_ray, +0.5, time, to.t );\n#endif\n\tfragColor.rgb *= fade;\n\tfragColor.rgb = mix( fragColor.rgb, debug_color.rgb, debug_color.a );\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"ltScRG","date":"1508966044","viewed":13917,"name":"Single-pass gaussian blur - fast","username":"FabriceNeyret2","description":"16x acceleration of [url]https:\/\/www.shadertoy.com\/view\/4tSyzy[\/url]\nby applying gaussian at intermediate MIPmap level.\n(classical trick also used on hardware for anisotropic filtering).","likes":95,"published":3,"flags":0,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"\/media\/a\/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"\/media\/ap\/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ 16x acceleration of https:\/\/www.shadertoy.com\/view\/4tSyzy\n\/\/ by applying gaussian at intermediate MIPmap level.\n\nconst int samples = 35,\n          LOD = 2,         \/\/ gaussian done on MIPmap at scale LOD\n          sLOD = 1 << LOD; \/\/ tile size = 2^LOD\nconst float sigma = float(samples) * .25;\n\nfloat gaussian(vec2 i) {\n    return exp( -.5* dot(i\/=sigma,i) ) \/ ( 6.28 * sigma*sigma );\n}\n\nvec4 blur(sampler2D sp, vec2 U, vec2 scale) {\n    vec4 O = vec4(0);  \n    int s = samples\/sLOD;\n    \n    for ( int i = 0; i < s*s; i++ ) {\n        vec2 d = vec2(i%s, i\/s)*float(sLOD) - float(samples)\/2.;\n        O += gaussian(d) * textureLod( sp, U + scale * d , float(LOD) );\n    }\n    \n    return O \/ O.a;\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    O = blur( iChannel0, U\/iResolution.xy, 1.\/iChannelResolution[0].xy );\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"MtBGRt","date":"1434685452","viewed":13837,"name":"Solines","username":"poljere","description":"One more reactive shader in my little collection, in this case just playing around with color and simple shapes.\n * Yellow Manipus [url]https:\/\/www.shadertoy.com\/view\/ltB3RK[\/url]\n * Twisted Rings [url]https:\/\/www.shadertoy.com\/view\/Xtj3DW[\/url]","likes":125,"published":3,"flags":4,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGRr","filepath":"\/presets\/mic.png","previewfilepath":"\/presets\/mic.png","type":"mic","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\/\/ Created by Pol Jeremias - poljere\/2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define SOUND_MULTIPLIER 1.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy \/ iResolution.xy);\n    uv -= vec2(0.5);\n    uv.x *= iResolution.x\/iResolution.y;\n    \n    \/\/ Calculate polar coordinates\n    float r = length(uv);\n    float a = atan(uv.y, uv.x);\n       \n    \/\/ Draw the lines\n    const float it = 5.0;\n    float c = 0.0;\n    for( float i = 0.0 ; i < it ; i += 1.0 )\n    {\n        float i01 = i \/ it;\n        float rnd = texture( iChannel0, vec2(i01)).x;\n        float react = SOUND_MULTIPLIER * texture( iChannel1, vec2(i01, 0.0) ).x;    \n        \n        float c1 = (uv.x + 1.1 + react) * 0.004 * abs( 1.0 \/ sin( (uv.y +0.25) +\n                                                         sin(uv.x * 4.0 * rnd + rnd * 7.0 + iTime * 0.75) *\n                                                                 (0.01 + 0.15*react)) );\n        c = clamp(c + c1, 0.0, 1.0);\n    }\n    \n    float s = 0.0;\n    const float it2 = 20.0;\n    for( float i = 0.0 ; i < it2 ; i += 1.0 )\n    {\n        float i01 = i \/ it2;       \n        float react = SOUND_MULTIPLIER * texture( iChannel1, vec2(i01, 0.0) ).x;  \n        vec2 rnd = texture( iChannel0, vec2(i01)).xy;\n        vec2 rnd2 = rnd - 0.5;\n      \n        rnd2 = vec2(0.85*sin(rnd2.x * 200.0 + rnd2.y * iTime * 0.1), \n                    -0.1 - 0.15 * sin(rnd2.x * rnd2.x * 200.0 + iTime  * rnd2.x * 0.25));\n        \n        float r1 = 1.0 - length(uv - rnd2);\n        float rad = ( 1.0 - clamp(0.03 * rnd.y + react * 0.05, 0.0, 1.0) );\n\n        r1 = smoothstep(rad, rad + 0.015, r1);\n        s += r1;\n    }\n    \n    \n    \/\/ Calculate the final color mixing lines and backgrounds\n    vec3 bg = mix( vec3(0.93, 0.71, 0.62), vec3(0.9, 0.44, 0.44), r);\n    bg = mix(bg, vec3(0.9, 0.91, 0.62), c);\n    bg = mix(bg, vec3(0.9, 0.91, 0.82), s);\n    \n    fragColor = vec4(bg, 1.0);\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"Mdl3Rr","date":"1363453092","viewed":13811,"name":"attic","username":"robertcupisz","description":"Click and drag to rotate the camera.\n\nThe tentacle is a raymarched distance field, the rest of the scene is raycast. The inscattered light\/volumetric shadows is just stepping through the volume and casting a shadow ray at every step.","likes":272,"published":1,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[],"code":"\/\/ Robert Cupisz 2013\n\/\/ Creative Commons Attribution-ShareAlike 3.0 Unported\n\/\/\n\/\/ Bits of code taken from Inigo Quilez, including fbm(), impulse()\n\/\/ and friends, sdCone() and friends; also box() by Simon Green.\n\n#define BRUTE_FORCE_AA 1\n\n#if BRUTE_FORCE_AA\n#define AA_SAMPLES 4\n#define INSCATTER_STEPS 30\n#define NOISE_AMPLITUDE 0.1\n#else\n#define INSCATTER_STEPS 50\n#define NOISE_AMPLITUDE 0.05\n#endif\n\n#define INF 1.0e38\n#define HIT(x) hit = min(hit, x)\n\n\/\/ Shadow rays can make things faster if there are big occluders\n\/\/ but kinda ugly with no #include statement\n\/\/#define HIT(x) if (x < INF) return 0.0\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n\t\t\t  -0.80,  0.36, -0.48,\n\t\t\t  -0.60, -0.48,  0.64 );\n\nfloat hash (float n)\n{\n\treturn fract(sin(n)*43758.5453);\n}\n\nfloat noise (in vec3 x)\n{\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\n\tf = f*f*(3.0-2.0*f);\n\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\n\tfloat res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n\t\t\t\t\t\tmix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n\t\t\t\t\tmix(mix( hash(n+113.0), hash(n+114.0),f.x),\n\t\t\t\t\t\tmix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n\treturn res;\n}\n\nfloat fbm (vec3 p)\n{\n\tfloat f;\n\tf  = 0.5000*noise( p ); p = m*p*2.02;\n\tf += 0.2500*noise( p ); p = m*p*2.03;\n\tf += 0.1250*noise( p ); \/\/p = m*p*2.01;\n\t\/\/f += 0.0625*noise( p );\n\treturn f;\n}\n\nfloat box(vec3 org, vec3 dir, vec3 size, out float far)\n{\n\t\/\/ compute intersection of ray with all six bbox planes\n\tvec3 invR = 1.0 \/ dir;\n\tvec3 tbot = invR * (-0.5*size - org);\n\tvec3 ttop = invR * (0.5*size - org);\n\t\n\t\/\/ re-order intersections to find smallest and largest on each axis\n\tvec3 tmin = min (ttop, tbot);\n\tvec3 tmax = max (ttop, tbot);\n\t\n\t\/\/ find the largest tmin and the smallest tmax\n\tvec2 t0 = max (tmin.xx, tmin.yz);\n\tfloat near;\n\tnear = max (t0.x, t0.y);\n\tt0 = min (tmax.xx, tmax.yz);\n\tfar = min (t0.x, t0.y);\n\n\t\/\/ check for hit\n\treturn near < far && far > 0.0 ? near : INF;\n}\n\nfloat box(vec3 org, vec3 dir, vec3 size)\n{\n\tfloat far;\n\treturn box(org, dir, size, far);\n}\n\nfloat impulse (float k, float x)\n{\n\tfloat h = k * x;\n\treturn h * exp (1.0 - h);\n}\n\nfloat impulse2 (float k0, float k1, float x)\n{\n\tfloat k = k0;\n\tif (x > 1.0\/k0)\n\t{\n\t\tx += 1.0\/k1 - 1.0\/k0;\n\t\tk = k1;\n\t}\n\tfloat h = k * x;\n\treturn h * exp (1.0 - h);\n}\n\nfloat cubicPulse (float w, float x)\n{\n\tx = abs (x);\n\tif (x > w)\n\t\treturn 0.0;\n\tx \/= w;\n\treturn 1.0 - x * x * (3.0 - 2.0 * x);\n}\n\nmat2 rot(float angle)\n{\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\treturn mat2(c,-s,s,c);\n}\n\n\/\/ rd doesn't have to be normalized\nfloat sphere(vec3 ro, vec3 rd, float r)\n{\n\tfloat b = dot(ro, rd);\n\tfloat c = dot(ro, ro) - r * r;\n\tfloat a = dot(rd, rd);\n\t\/\/ Exit if r\u00e2\u20ac\u2122s origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif (c > 0.0 && b > 0.0)\n\t\treturn INF;\n\tfloat discr = b*b - a*c;\n\t\/\/ A negative discriminant corresponds to ray missing sphere\n\tif (discr < 0.0)\n\t\treturn INF;\n\t\/\/ Ray now found to intersect sphere, compute smallest t value of intersection\n\tfloat t = - b - sqrt(discr);\n\tt \/= a;\n\t\/\/ If t is negative, ray started inside sphere so clamp t to zero\n\tt = max(0.0, t);\n\treturn t;\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n\t\/\/ c must be normalized\n\tfloat q = length(p.xy);\n\treturn dot(c,vec2(q,p.z));\n}\n\nfloat sdPlane (vec3 p, vec4 n)\n{\n\t\/\/ n must be normalized\n\treturn dot(p,n.xyz) + n.w;\n}\n\nfloat sdSphere (vec3 p, float s)\n{\n\treturn length(p)-s;\n}\n\nvec3 animateTentacle (vec3 p)\n{\n\tfloat t = 0.8*iTime + 2.6;\n\tfloat pi = 3.1415;\n\tfloat pi4 = pi*4.0;\n\t\n\t\/\/ major up and down\n\tfloat offset = 1.05;\n\tp.z += offset;\n\tfloat a = 0.6;\n\ta += 0.1*sin(1.33*t - 0.7);\n\ta += 0.15*sin(2.0*t);\n\ta -= 1.2*impulse2(3.0, 1.1, mod(pi4 - t, pi4));\n\ta *= 0.8*max(-0.1, p.z) + 0.1;\n\tmat2 m = rot(a);\n\tp = vec3(m*p.yz,p.x).zxy;\n\tp.z -= offset;\n\t\n\t\/\/ ripples\n\tfloat ripplesPos = p.z + 0.5*mod(t, pi4) - 0.3;\n\tfloat ripples = 0.003*sin(80.0*ripplesPos)*cubicPulse(0.15, ripplesPos + 0.7);\n\tp.y += ripples;\n\tp.x += ripples;\n\t\n\t\/\/ whiplash\n\tp.y += 0.06*smoothstep(-0.6, -0.3, p.z)*impulse(25.0, mod(t - 0.01, pi4));\n\t\n\treturn p;\n}\n\nfloat sdTentacle (vec3 p)\n{\n\tp += vec3(-0.6,0.52,-0.06);\n\t\n\t\/\/ bend\n\tp.y -= smoothstep(0.95, 1.1, -p.z)*(p.z + 0.9)*0.5;\n\t\n\t\/\/ animate\n\tp = animateTentacle(p);\n\t\n\t\/\/ wavy\n\tp.y += 0.02*sin(13.0*p.z + iTime + 3.0);\n\tp.x += 0.01*cos(17.0*p.z);\n\t\n\t\/\/ primitives\n\tfloat d = sdCone(p, vec2(0.99, 0.12));\n\td = max(d, -sdPlane(p, vec4(0,0,1,1.135)));\n\td = max(d, -sdPlane(p, vec4(0,0,-1,-0.4)));\n\td = min(d, sdSphere(p + vec3(0.0, 0.0, 0.41), 0.05));\n\t\n\treturn d;\n}\n\nfloat tentacle (vec3 ro, vec3 rd)\n{\n\tfloat far;\n\tvec3 bboxpos = vec3(-0.6,0.51,0.69);\n\tvec3 bboxsize = vec3(0.25, 0.66, 0.79);\n\tfloat near = box (ro + bboxpos, rd, bboxsize);\n\tif(near == INF)\n\t\treturn INF;\n\t\/\/return near;\n\t\n\tnear = max(0.0, near);\n\t\n\tro += near*rd;\n\tfloat t = 0.0;\n\tfloat hit = -1.0;\n\tfor(int i=0; i < 24; i++)\n\t{\n\t\tfloat h = sdTentacle(ro + rd*t);\n\t\t\/\/ We will be overwriting the hit multiple times once\n\t\t\/\/ we're close to the surface, but it actually gives\n\t\t\/\/ a better result than the first below threshold\n\t\t\/\/ and we can't break anyway.\n\t\tif (h < 1e-5)\n\t\t\thit = t;\n\t\tt += h;\n\t}\n\t\n\treturn hit > -1.0 ? hit + near : INF;\n}\n\nfloat roof(vec3 ro, vec3 rd)\n{\n\tfloat hit = -ro.y\/rd.y;\n\t\/\/ An offset, so that shadow rays starting from the roof don't\n\t\/\/ think they're unoccluded\n\tif (hit < -0.1)\n\t\treturn INF;\n\t\n\t\/\/ We've hit the plane. If we've hit the window, but\n\t\/\/ not the beams, return no hit.\n\tvec2 pos = ro.xz + hit*rd.xz;\n\tvec2 window = abs(pos) - 0.81;\n\t\/\/ single beams\n\t\/\/vec2 beams = 0.02 - abs(pos);\n\t\/\/ double beams\n\tvec2 beams = 0.015 - abs(mod(pos, 0.54) - 0.27);\n\tif (max(max(window.x, window.y), max(beams.x, beams.y)) < 0.0)\n\t\treturn INF;\n\n\treturn hit;\n}\n\nfloat monsterBox(vec3 ro, vec3 rd)\n{\n\tfloat hit = INF;\n\tfloat size = 0.33;\n\tfloat halfSize = 0.5*size;\n\tHIT(box (ro, rd, vec3(size)));\n\t\n\tro.y -= halfSize;\n\tro.z += halfSize;\n\tmat2 m = rot(0.017*(sin(iTime) - 48.0));\n\tro.yz = m*ro.yz;\n\trd.yz = m*rd.yz;\n\tro.z -= halfSize;\n\t\n\tHIT(box (ro, rd, vec3(size, 0.04, size)));\n\treturn hit;\n}\n\nfloat ship (vec3 ro, vec3 rd)\n{\n\tfloat pi = 3.1415;\n\tfloat pihalf = 0.5*pi;\n\tfloat t = 0.8*iTime + 3.0;\n\tfloat angle = 0.0;\n\t\n\t\/\/ tilting back and forth\n\tfloat tiltt = t + 0.3;\n\tfloat tiltAmp = - 0.14 * sign(fract((tiltt + pihalf)\/(2.0*pi)) - 0.5);\n\tangle += tiltAmp*cubicPulse(1.2, mod(tiltt + pihalf, pi) - pihalf);\n\t\n\t\/\/ running away\n\tangle += 0.7*impulse(3.0, mod(t + 0.08, 4.0*pi));\n\tfloat post = mod(t, 2.0*pi);\n\tpost += impulse(1.0, mod(t, 4.0*pi));\n\tro += vec3(-0.6, 0.5, 0.3*cos(post) - 0.08);\n\t\n\t\/\/ rotate\n\tmat2 m = rot(angle);\n\tro.yz = m*ro.yz;\n\trd.yz = m*rd.yz;\n\n\t\/\/ intersect\n\tfloat hit = INF;\t\n\tHIT(sphere (ro + vec3(0.0, -0.025, 0.0), rd, 0.05));\n\tfloat flatten = 4.0;\n\tro.y *= flatten;\n\trd.y *= flatten;\n\tHIT(sphere (ro, rd, 0.17));\n\treturn hit;\n}\n\n#define ROOFPOS vec3(0,-1,0.01)\n\nfloat intersect (vec3 ro, vec3 rd)\n{\n\tfloat hit = INF;\n\n\t\/\/ tentacle\n\tHIT(tentacle(ro, rd));\n\t\n\t\/\/ ship\n\tHIT(ship(ro, rd));\n\t\n\t\/\/ stuff\n\tHIT(box (ro + vec3(0.5,0.5,0), rd, vec3(0.4,2,1)));\n\tHIT(sphere (ro + vec3(0.3,0.8,0.65), rd, 0.25));\n\tmat2 m = rot(3.5);\n\tvec3 rorot = ro + vec3(0.4,-0.6,0.3);\n\tvec3 rdrot = rd;\n\trorot.xz = m*rorot.xz;\n\trdrot.xz = m*rdrot.xz;\n\tHIT(box (rorot, rdrot, vec3(0.35,0.2,0.35)));\n\t\n\t\/\/ roof\n\trorot = ro + ROOFPOS;\n\trdrot = rd;\n\t\/\/ reuse the previous rotation matrix\n\trorot.xy = m*rorot.xy;\n\trdrot.xy = m*rdrot.xy;\n\tHIT(roof(rorot, rdrot));\n\n\t\/\/ monster box\n\tm = rot(-0.175);\n\trorot = ro + vec3(-0.6,0.78,1.0);\n\trdrot = rd;\n\trorot.xz = m*rorot.xz;\n\trdrot.xz = m*rdrot.xz;\n\tHIT(monsterBox(rorot, rdrot));\n\t\n\t\/\/ floor\n\tfloat floorHit = -(ro.y + 0.95)\/rd.y;\n\tif (floorHit < 0.0)\n\t\tfloorHit = INF;\n\tHIT(floorHit);\n\n\treturn hit;\n}\n\nfloat particles (vec3 p)\n{\n\tvec3 pos = p;\n\tpos.y -= iTime*0.02;\n\tfloat n = fbm(20.0*pos);\n\tn = pow(n, 5.0);\n\tfloat brightness = noise(10.3*p);\n\tfloat threshold = 0.26;\n\treturn smoothstep(threshold, threshold + 0.15, n)*brightness*90.0;\n}\n\nfloat transmittance (vec3 p)\n{\n\treturn exp (0.4*p.y);\n}\n\nvec3 inscatter (vec3 ro, vec3 rd, vec3 roLight, vec3 rdLight, vec3 lightDir, float hit, vec2 screenPos)\n{\n\tfloat far;\n\tfloat near = box(roLight + vec3(0.0, 1.0, 0.0), rdLight, vec3(1.5, 3.0, 1.5), far);\n\tif(near == INF || hit < near)\n\t\treturn vec3(0);\n\t\n\tfloat distAlongView = min(hit, far) - near;\n\tfloat oneOverSteps = 1.0\/float(INSCATTER_STEPS);\n\tvec3 step = rd*distAlongView*oneOverSteps;\n    vec3 pos = ro + rd*near;\n\tfloat light = 0.0;\n    \n    \/\/ add noise to the start position to hide banding\n    \/\/ TODO: blue noise\n\tpos += rd*noise(vec3(2.0*screenPos, 0.0))*NOISE_AMPLITUDE;\n\n\tfor(int i = 0; i < INSCATTER_STEPS; i++)\n\t{\n\t\tfloat l = intersect(pos, lightDir) == INF ? 1.0 : 0.0;\n\t\tl *= transmittance(pos);\n\t\tlight += l;\n\t\tlight += particles(pos)*l;\n\t\tpos += step;\n\t}\n\n\tlight *= oneOverSteps * distAlongView;\n\treturn light*vec3(0.6);\n}\n\nvec3 rot (vec3 v, vec3 axis, vec2 sincosangle)\n{\n\treturn v*sincosangle.y + cross(axis, v)*sincosangle.x + axis*(dot(axis, v))*(1.0 - sincosangle.y);\n}\n\nvec3 surface(vec2 fragCoord, vec3 ro, vec3 u, vec3 v, vec3 w, vec3 lightRotAxis, vec2 lightAngleSinCos, vec3 lightDir)\n{\n    vec2 q = fragCoord.xy\/iResolution.xy;\n\tvec2 p = -1.0 + 2.0*q;\n\tp.x *= iResolution.x\/iResolution.y;\n\n\tvec3 rd = normalize( p.x*u + p.y*v + 1.5*w );\n\n\t\/\/ raycast the scene\n\tfloat hit = intersect(ro,rd);\n\tvec3 hitPos = ro + hit * rd;\n\t\n\t\/\/ white window\n\tif (hit == INF)\n\t\treturn vec3(1.0);\n\t\n\t\/\/ direct light (screw shading!)\n\tvec3 c = vec3(0.0);\n    float shadowBias = 1.0e-4;\n\tif (intersect(hitPos + lightDir*shadowBias, lightDir) == INF)\n\t\tc = vec3(0.9);\n    \n    lightAngleSinCos.x *= -1.0; \/\/ rev angle\n\tvec3 roLight = rot(ro + ROOFPOS, lightRotAxis, lightAngleSinCos);\n\tvec3 rdLight = rot(rd, lightRotAxis, lightAngleSinCos);\n\tc += inscatter(ro, rd, roLight, rdLight, lightDir, hit, fragCoord);\n    \n    \/\/ color correction - Sherlock color palette ;)\n\tc.r = smoothstep(0.0, 1.0, c.r);\n\tc.g = smoothstep(0.0, 1.0, c.g - 0.1);\n\tc.b = smoothstep(-0.3, 1.3, c.b);\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ camera\n\tvec3 ro = normalize(vec3(1.0,-0.1,0.1));\n\tfloat cameraAngle = iMouse.x\/iResolution.x - 0.5;\n\tif(iMouse.z < 0.5)\n\t\tcameraAngle = 0.5*sin(0.1*iTime);\n\tfloat cca = cos(cameraAngle);\n\tfloat sca = sin(cameraAngle);\n\tmat2  m = mat2(cca,-sca,sca,cca);\n\tro = vec3(m*ro.xz,ro.y).xzy;\n\tvec3 w = -ro;\n\tro *= 2.5;\n\tvec3 u = normalize(cross( vec3(0.0,1.0,0.0), w ));\n\tvec3 v = normalize(cross(w,u));\n    \n    \/\/ light\n    vec3 lightRotAxis = vec3(0.707,0,0.707); \/\/1,0,1 normalized\n\tvec2 lightAngleSinCos = vec2(sin(0.28), cos(0.28));\n\tvec3 lightDir = rot(vec3(0,1,0), lightRotAxis, lightAngleSinCos);\n    \n#if BRUTE_FORCE_AA\n    float invAA = 1.0 \/ float(AA_SAMPLES);\n    vec3 c = vec3(0);\n    vec2 offset = vec2(-0.5, -0.5);\n    for (int i=0; i < AA_SAMPLES; i++)\n    {\n        for (int j=0; j < AA_SAMPLES; j++)\n        {\n            c += surface(fragCoord + offset, ro, u, v, w, lightRotAxis, lightAngleSinCos, lightDir);\n            offset.y += invAA;\n        }\n        offset.x += invAA;\n        offset.y = -0.5;\n    }\n    c *= invAA * invAA;\n#else\n    vec3 c = surface(fragCoord, ro, u, v, w, lightRotAxis, lightAngleSinCos, lightDir);\n#endif\n    \n\tfragColor = vec4(c, 0.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"WsSGWG","date":"1549810341","viewed":13806,"name":"Kaleidoscope Tunnel","username":"kaneta","description":"I was inspired by live VJ","likes":56,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592654\n\nmat2 rot(float x)\n{\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\nvec2 foldRotate(in vec2 p, in float s) {\n    float a = PI \/ s - atan(p.x, p.y);\n    float n = PI * 2. \/ s;\n    a = floor(a \/ n) * n;\n    p *= rot(a);\n    return p;\n}\n\nfloat sdRect( vec2 p, vec2 b )\n{\n  vec2 d = abs(p) - b;\n  return min(max(d.x, d.y),0.0) + length(max(d,0.0));\n}\n\n\/\/ TheGrid by dila\n\/\/ https:\/\/www.shadertoy.com\/view\/llcXWr\nfloat tex(vec2 p, float z)\n{\n    p = foldRotate(p, 8.0);\n    vec2 q = (fract(p \/ 10.0) - 0.5) * 10.0;\n    for (int i = 0; i < 3; ++i) {\n        for(int j = 0; j < 2; j++) {\n        \tq = abs(q) - .25;\n        \tq *= rot(PI * .25);\n        }\n        q = abs(q) - vec2(1.0, 1.5);\n        q *= rot(PI * .25 * z);\n\t\tq = foldRotate(q, 3.0);  \n    }\n\tfloat d = sdRect(q, vec2(1., 1.));\n    float f = 1.0 \/ (1.0 + abs(d));\n    return smoothstep(.9, 1., f);\n}\n\n\/\/ The Drive Home by BigWings\n\/\/ https:\/\/www.shadertoy.com\/view\/MdfBRX\nfloat Bokeh(vec2 p, vec2 sp, float size, float mi, float blur)\n{\n    float d = length(p - sp);\n    float c = smoothstep(size, size*(1.-blur), d);\n    c *= mix(mi, 1., smoothstep(size*.8, size, d));\n    return c;\n}\n\nvec2 hash( vec2 p ){\n\tp = vec2( dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)));\n\treturn fract(sin(p)*43758.5453) * 2.0 - 1.0;\n}\n\nfloat dirt(vec2 uv, float n)\n{\n    vec2 p = fract(uv * n);\n    vec2 st = (floor(uv * n) + 0.5) \/ n;\n    vec2 rnd = hash(st);\n    return Bokeh(p, vec2(0.5, 0.5) + vec2(0.2) * rnd, 0.05, abs(rnd.y * 0.4) + 0.3, 0.25 + rnd.x * rnd.y * 0.2);\n}\n\nfloat sm(float start, float end, float t, float smo)\n{\n    return smoothstep(start, start + smo, t) - smoothstep(end - smo, end, t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x \/ iResolution.y;\n    uv *= 2.0;\n    \n    vec3 col = vec3(0.0);\n    #define N 6\n    #define NN float(N)\n    #define INTERVAL 3.0\n    #define INTENSITY vec3((NN * INTERVAL - t) \/ (NN * INTERVAL))\n    \n\n    float time = iTime;\n    for(int i = 0; i < N; i++) {\n        float t;\n        float ii = float(N - i);\n        t = ii * INTERVAL - mod(time - INTERVAL * 0.75, INTERVAL);\n        col = mix(col, INTENSITY, dirt(mod(uv * max(0.0, t) * 0.1 + vec2(.2, -.2) * time, 1.2), 3.5));\n        \n        t = ii * INTERVAL - mod(time + INTERVAL * 0.5, INTERVAL);\n        col = mix(col, INTENSITY * vec3(0.7, 0.8, 1.0) * 1.3,tex(uv * max(0.0, t), 4.45));\n        \n        t = ii * INTERVAL - mod(time - INTERVAL * 0.25, INTERVAL);\n        col = mix(col, INTENSITY * vec3(1.), dirt(mod(uv * max(0.0, t) * 0.1 + vec2(-.2, -.2) *  time, 1.2), 3.5));\n        \n        t = ii * INTERVAL - mod(time, INTERVAL);\n    \tfloat r = length(uv * 2.0 * max(0.0, t));\n    \tfloat rr = sm(-24.0, -0.0, (r - mod(time * 30.0, 90.0)), 10.0);\n        col = mix(col, mix(INTENSITY * vec3(1.), INTENSITY * vec3(0.7, 0.5, 1.0) * 3.0, rr),tex(uv * 2.0 * max(0.0, t), 0.27 + (2.0 * rr)));\n\n    }\n\n\tfragColor = vec4(col, 0.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"lsBfDz","date":"1500155584","viewed":13804,"name":"[SH17A] Tiny Clouds","username":"stubbe","description":"Two tweet (280 chars) reinterpretation of iq's iconic clouds shader (https:\/\/www.shadertoy.com\/view\/XslGRr).","likes":222,"published":1,"flags":64,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"ldsSzl","filepath":"https:\/\/soundcloud.com\/gloom\/electric-bullet","previewfilepath":"https:\/\/soundcloud.com\/gloom\/electric-bullet","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define T texture(iChannel0,(s*p.zw+ceil(s*p.x))\/2e2).y\/(s+=s)*4.\nvoid mainImage(out vec4 O,vec2 x){\n    vec4 p,d=vec4(.8,0,x\/iResolution.y-.8),c=vec4(.6,.7,d);\n    O=c-d.w;\n    for(float f,s,t=2e2+sin(dot(x,x));--t>0.;p=.05*t*d)\n        p.xz+=iTime,\n        s=2.,\n        f=p.w+1.-T-T-T-T,\n    \tf<0.?O+=(O-1.-f*c.zyxw)*f*.4:O;\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"Md3yRB","date":"1519956349","viewed":13777,"name":"Wythoff explorer","username":"mattz","description":"Everything on the left-hand side is clickable. Arrows above\/below digits set triangle corner angles. You can drag the red dot on the sphere. Space toggles GUI. Have fun! ","likes":307,"published":3,"flags":48,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"\/media\/a\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"\/media\/ap\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/* Wythoff explorer, by mattz\n   License https:\/\/creativecommons.org\/licenses\/by-nc-sa\/3.0\/\n\n   This is an update to my \"Wythoff construction\" shader:\n   https:\/\/www.shadertoy.com\/view\/ldXczX \n\n   I've learned a bit since I wrote that, and was able to add\n   a few new features I couldn't figure out last time:\n\n     - lots more distance functions besides sphere and\n       polyhedron! faceted or ball-and-stick nets, and\n       also polyhedron dilated by sphere \n\n     - user-modifiable polyhedron vertex within triangle\n\n     - lots of cool blending effects\n\n   As usual, I'm indebted to other users on shadertoy for \n   helpful\/inspiring examples, especially:\n \n     - Polyhedron again (knighty)\n       https:\/\/www.shadertoy.com\/view\/XlX3zB\n\n     - 2D Folding (gaz)\n       https:\/\/www.shadertoy.com\/view\/4tX3DS\n\n   These links were helpful when creating this shader:\n\n     - https:\/\/en.wikipedia.org\/wiki\/Wythoff_construction\n     - http:\/\/www.gregegan.net\/APPLETS\/26\/WythoffNotes.html\n     - https:\/\/en.wikipedia.org\/wiki\/List_of_uniform_polyhedra\n\n   If you want to browse the code: this main buffer only does AA \n   and GUI rendering. Buffer A handles mouse interaction and \n   global state updates, and Buffer B handles distance marching \n   and shading the actual polyhedron.\n\n   I'm pretty sure this is the largest shader I've posted on\n   Shadertoy -- apologies for the long compile times!\n\n*\/\n\n\/\/#define DEBUG_HITBOXES\n#define ENABLE_EDGE_AA\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ point-line distance\n\nfloat dline(vec2 p, vec2 a, vec2 b) {\n    \n    vec2 ba = b-a;\n    vec2 n = normalize(vec2(-ba.y, ba.x));\n    \n    return dot(p, n) - dot(a, n);\n    \n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ point-line and point-segment distance\n\nvec2 dline_seg(vec2 p, vec2 a, vec2 b) {\n\n    vec2 ba = b-a;\n    vec2 n = normalize(vec2(-ba.y, ba.x));\n\n    vec2 pa = p-a;\n    \n    float u = clamp(dot(pa, ba)\/dot(ba, ba), 0., 1.);\n    \n    return vec2(dot(a, n) - dot(p, n), length(p-mix(a,b,u)));\n    \n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ distance to character in SDF font texture\n\nfloat font2d_dist(vec2 tpos, float size, vec2 offset) {\n\n    float scl = 0.63\/size;\n      \n    vec2 uv = tpos*scl;\n    vec2 font_uv = (uv+offset+0.5)*(1.0\/16.0);\n    \n    float k = texture(iChannel2, font_uv, -100.0).w + 1e-6;\n    \n    vec2 box = abs(uv)-0.5;\n        \n    return max(k-127.0\/255.0, max(box.x, box.y))\/scl;\n    \n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ distance to triangle for spin box\n\nfloat spin_icon_dist(vec2 pos, float size, bool flip, bool dim) {\n    \n    if (flip) { pos.y = -pos.y; }  \n    pos.x = abs(pos.x);\n    \n    vec2 p0 = vec2(0, -0.7)*text_size;\n    vec2 p1 = vec2(0.35, -0.7)*text_size;\n    vec2 p2 = vec2(0.0, -1.1)*text_size;\n    \n    float d = max(dline(pos, p0, p1), dline(pos, p1, p2));\n    \n    if (dim) { \n        d = abs(d + 0.02*text_size) - 0.02*text_size;\n    }\n    \n    return d;\n       \n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ distance to icon for distance function\n\nfloat dfunc_icon_dist(vec2 p, float sz, int style) {\n    \n    if (style == 0) {\n        \n        return length(p) - sz;\n        \n    } else if (style == 5 || style == 6) {\n\n\t\tp.y = abs(p.y);\n        \n        vec2 vp = p*vec2(1, 0.9);\n        float d = abs(length((vp - vec2(0, 0.6*sz))) - 0.5*sz) - 0.06*sz;\n        \n        float q = length(p - vec2(0, min(p.y, 0.4*sz)))-0.06*sz;\n        float r = box_dist(p, vec4(0, 0, 0.35, 0.7)*sz);\n                    \n        if (style == 6) {\n        \n            q = min(q, box_dist(p, vec4(0, 2.0, 0.06, 0.46)*sz));\n            q = min(q, box_dist(p, vec4(-0.5, 2.4, 0.56, 0.06)*sz));\n            \n        }\n                \n        return min(q, max(d, -r));\n        \n    }\n    \n    p += vec2(0, 0.15*sz);\n    \n    sz *= 0.9;\n    \n    const float k = 0.8660254037844387;\n    \n    p.x = abs(p.x);\n    \n    vec2 m0 = vec2(0, sz);\n    vec2 m1 = vec2(k*sz, -0.5*sz);\n    vec2 m2 = vec2(0, -0.5*sz);\n    \n    vec2 d_ls = min(dline_seg(p, m0, m1),\n                    dline_seg(p, m1, m2));\n    \n    float d_point = min(length(p - m0), length(p - m1));\n    \n    if (style == 1) {\n        return -d_ls.x - 0.5;\n    } else if (style == 2) {\n        return min(d_point - 0.25*sz, abs(d_ls.y)-0.08*sz);\n    } else if (style == 3) {\n        return abs(d_ls.x)-0.15*sz;\n    } else {\n        return min(min(d_ls.y, d_point) - 0.35*sz, -d_ls.x);    \n    }\n    \n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ distance to icon for decorations\n\nfloat decor_icon_dist(vec2 p, float sz, int style) {\n    \n    float s = sign(p.x*p.y);\n    \n    p = abs(p);\n    \n    vec2 a = vec2(0, sz);\n    vec2 b = vec2(sz, 0);\n    \n    float l = dline(p, a, b);\n    float c = length( p - (p.x > p.y ? b : a)*0.8 );\n    \n    if (style == 0) {\n        return c - 0.2*sz;\n    } else if (style == 1) {\n        return abs(l + 0.04*sz) - 0.08*sz;\n    } else if (style == 2) {\n        return min(abs(l), max(min(p.x, p.y), l)) - 0.03*sz;\n    } else {\n        return min(max(min(s*p.x, s*p.y), l), abs(l)-0.03*sz);\n        \n    }\n    \n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ draw color icon (RGB or facet-shaded selectors)\n\nvoid draw_color_icon(vec2 p, float sz, int i, bool enable, inout vec3 color) {\n    \n    const float k = 0.8660254037844387;\n    \n    mat2 R = mat2(-0.5, k, -k, -0.5);\n    \n    vec2 p1 = vec2(k*sz, 0);\n    vec2 p2 = vec2(0, 0.5*sz);\n    \n    mat3 colors;\n    \n    if (i == 0) {\n        colors = mat3(vec3(1, 0, 0),\n                      vec3(1, 1, 0),\n                      vec3(0, 0, 1));\n    } else {\n        colors = mat3(vec3(0.6, 0, 0.6),\n                      vec3(0.7, 0.4, 0.7),\n                      vec3(0.1, 0.5, 0.5));\n    }\n    \n    float ue = enable ? 1. : 0.3;\n    float ds = 1e5;\n    \n    for (int j=0; j<3; ++j) {\n        \n        vec2 ap = vec2(abs(p.x), abs(p.y-0.5*sz));\n        \n        vec2 dls = dline_seg(ap, p2, p1);\n        \n        p = R*p;\n        \n        color = mix(color, colors[j], smoothstep(1.0, 0.0, -dls.x+0.5) * ue);\n        ds = min(ds, dls.y);\n    \n    }\n\n    color = mix(color, vec3(0), smoothstep(1.0, 0.0, ds-0.05*sz) * ue);\n    \n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ draw sphere inset for bottom left corner\n\nvoid draw_sphere_inset(in vec2 p, inout vec3 color) {    \n    \n    float px = inset_scl;\n    \n    float dot_size = max(3.0*px, 0.03);\n    float line_width = max(.25*px, 0.003);\n\n    float lp = length((p - inset_ctr)*px);\n        \n    vec3 sp = sphere_from_gui(p);\n    \n    if (lp < 1.) {\n        \n        color = vec3(1);        \n      \n        float d_tri = 1e5;\n        \n        \n        float d_circ = 1e5;\n        \n        for (int i=0; i<3; ++i) {\n\n            d_circ = min(d_circ, length(sp - tri_verts[i]));\n            d_circ = min(d_circ, length(sp - tri_spoints[i]));\n            \n            d_tri = min(d_tri, dot(sp, tri_edges[i]));\n        }\n        \n        d_circ = min(d_circ, length(sp - tri_spoints[3]));\n                   \n        float d_V = length(sp - poly_vertex);\n                \n        vec3 sp2 = sp;\n        tile_sphere(sp2); \n        \n\n        float d_gray = 1e5;\n        \n        for (int i=0; i<3; ++i) {\n            d_gray = min(d_gray, abs(dot(sp2, tri_edges[i])));\n        }\n        \n        \n        float d_pink = length(sp2 - poly_vertex);\n        \n        color = mix(color, vec3(0.85), smoothstep(px, 0.0, d_gray-2.*line_width));\n\n        color = mix(color, vec3(0.9, 0.5, 0.5), smoothstep(px, 0.0, d_pink-0.7*dot_size));\n\n        color = mix(color, vec3(0.6), smoothstep(px, 0.0, -d_tri));\n        color = mix(color, vec3(0), smoothstep(px, 0.0, abs(d_tri)-line_width));\n\n        color = mix(color, vec3(1), step(d_circ, dot_size));\n        color = mix(color, vec3(0.7, 0, 0), smoothstep(px, 0.0, d_V-dot_size));\n        color = mix(color, vec3(0), smoothstep(px, 0.0, abs(d_circ - dot_size)-line_width));\n\n    \n    }    \n    \n    color = mix(color, vec3(0), smoothstep(px, 0.0, abs(lp - 1.)-line_width));                                                 \n    \n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ was for debugging, now just for fun \n\nvec3 stereographic_polar_diagram(in vec2 p, in vec2 theta) {\n    \n    mat3 R = rotX(-theta.x)*rotY(-theta.y);\n\n    float rad = length(planar_verts[0]);\n    float scl = 8.0*rad \/ iResolution.y;\n    \n    p *= scl;\n\n    float d = 1e5;\n    \n    vec3 Rctr = R * vec3(0, 0, 1);\n    vec3 Rp3d = R * vec3(p, 1);\n    vec2 Rp = Rp3d.xy \/ Rp3d.z;\n        \n    for (int i=0; i<3; ++i) {\n        vec3 tp = (tri_verts[i] * planar_proj * R);\n        d = min(d, length(p - tp.xy \/ tp.z) - 2.*scl);\n    }\n        \n    vec3 pos = sphere_from_planar(Rp) * sign(Rp3d.z);\n    mat3 M = tile_sphere(pos);\n    \n    for (int i=0; i<3; ++i) {\n        vec3 e =  M * tri_edges[i] * planar_proj * R;\n        e \/= length(e.xy);\n        d = min(d, abs(dot(vec3(p, 1), e)));\n    }    \n\n    vec3 pv = M * poly_vertex * planar_proj * R;\n    \n    vec3 color = vec3(1);\n\n    if (length(Rp) < rad) {\n        color = vec3(1, .5, 1);\n    }\n\n    float Mdet = dot(M[0], cross(M[1], M[2]));\n    \n    color *= mix(0.8, 1.0, step(0.0, Mdet));\n    \n    color = mix(color, vec3(0, 0, 1), smoothstep(scl, 0.0, abs(length(Rp)-rad)-.5*scl));\n    color *= smoothstep(0., scl, d-0.25*scl);\n    color = mix(color, vec3(0.7, 0, 0), smoothstep(scl, 0., length(p - pv.xy \/ pv.z)-3.*scl));\n    \n    vec3 e = vec3(0, 0, 1) * R;\n    e \/= length(e.xy);\n    d = abs(dot(vec3(p, 1), e));    \n    color = mix(color, vec3(0.0, 0, 0.5), smoothstep(scl, 0., d-.5*scl));\n    \n    return color;\n    \n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ helper function for drawing icons below\n\nvoid icon_dist_update(inout vec2 blk_gray, \n                      float d, bool enable) {\n    \n    if (enable) {\n        blk_gray.x = min(blk_gray.x, d);\n    } else {\n        blk_gray.y = min(blk_gray.y, d);\n    }\n    \n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ our main image - apply AA to rendered polyhedron and draw GUI\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ set up GUI placement and load in settings from texture A\n    \n    \n    bary_poly_vertex = load3(BARY_COL, TARGET_ROW);\n    spoint_selector = load4(SPSEL_COL, TARGET_ROW);   \n    vec4 theta = load4(THETA_COL, TARGET_ROW);\n    \n    setup_triangle(load3(PQR_COL, TARGET_ROW));\n    \n    vec4 decorations = load4(DECOR_COL, TARGET_ROW);\n    \n    vec4 misc = load4(MISC_COL, TARGET_ROW);\n    bool is_linked = (misc.x != 0.);\n    \n    float gui = load(MISC_COL, CURRENT_ROW).z;\n\n    setup_gui(iResolution.xy, gui);\n    \n#ifdef STEREOGRAPHIC_POLAR    \n    \n    \/\/ render a cool 2D diagram\n    vec3 color = stereographic_polar_diagram(fragCoord.xy - object_ctr, theta.xy);\n    color = mix(vec3(1), color, smoothstep(0.0, 100.0, fragCoord.x-2.*inset_ctr.x));\n    \n#else\n#ifdef ENABLE_EDGE_AA\n\n    \/\/ texture B holds the rendered scene with the ray distance \n    \/\/ stored in the 4th (w) coordinate. \n    \/\/\n    \/\/ note color not yet gamma-corrected so still safe to blend\n\n    ivec2 fc = ivec2(fragCoord);\n\n    \/\/ fetch center texel and four surrounding texels\n    vec4 sa = texelFetch(iChannel1, fc+ivec2(0, 1), 0);\n    vec4 sb = texelFetch(iChannel1, fc+ivec2(-1, 0), 0);\n    vec4 sc = texelFetch(iChannel1, fc, 0);\n    vec4 sd = texelFetch(iChannel1, fc+ivec2(1, 0), 0);\n    vec4 se = texelFetch(iChannel1, fc+ivec2(0, -1), 0);\n    \n    \/\/ blur the center pixel horizontally and vertically\n    const vec3 bcoeff = vec3(0.25, 0.5, 0.25);\n    vec3 hblur = mat3(sb.xyz, sc.xyz, sd.xyz)*bcoeff;\n    vec3 vblur = mat3(sa.xyz, sc.xyz, se.xyz)*bcoeff;\n         \n    \/\/ get the (absolute) gradient of the depth map \n    \/\/ and its (approximate) norm\n    vec2 depth_grad = abs(vec2(sd.w - sb.w, se.w - sa.w));\n    float depth_grad_norm = depth_grad.x + depth_grad.y;\n    \n    \/\/ depth gradient now sums to 1\n    depth_grad \/= max(1e-5, depth_grad_norm);\n    \n    \/\/ compute blur along depth gradient direction\n    vec3 directed_blur = hblur*depth_grad.y + vblur*depth_grad.x;\n\n    \/\/ blend in blur where gradient is large\n    vec3 color = mix(sc.xyz, directed_blur, \n                     smoothstep(0.0, 0.5, depth_grad_norm));\n    \n#else\n    \n    vec3 color = texelFetch(iChannel1, ivec2(fragCoord), 0).xyz;\n    \n#endif            \n#endif\n    \n    \/\/ everything from here down is just UI and gamma correction\n    \n    vec3 pre_gui_color = color;\n            \n    draw_sphere_inset(fragCoord.xy, color);    \n    \n    float d_gray = 1e5;\n    vec2 d_bg = vec2(1e5);\n\n    for (int i=0; i<3; ++i) {\n\n        vec2 text_pos = fragCoord.xy - char_ui_box(i).xy;\n        \n        d_bg.x = min(d_bg.x, font2d_dist(text_pos, text_size, vec2(pqr[i], 12.0)));\n        d_gray = min(d_gray, spin_icon_dist(text_pos, text_size, true, pqr[i] >= 5.));\n        d_gray = min(d_gray, spin_icon_dist(text_pos, text_size, false, pqr[i] <= 2.));\n        \n        text_pos -= vec2(1, 0) * text_size;\n        \n    }\n       \n    float icon_size = 0.35*text_size;\n\n    for (int row=0; row<2; ++row) {\n        \n        vec4 df = load4(!is_linked && row == 0 ? DFUNC0_COL : DFUNC1_COL, TARGET_ROW);\n        \n        for (int i=0; i<5; ++i) {\n                                \n            vec2 p = fragCoord.xy - dfunc_ui_box(i, row).xy;\n            float idist = dfunc_icon_dist(p, icon_size, i);\n            \n            float dfi;\n            if (i == 0) { dfi = 1. - dot(df, vec4(1)); } else { dfi = df[i-1]; }\n            \n            icon_dist_update(d_bg, idist, dfi != 0.);\n            \n        }\n        \n    }\n    \n    for (int i=0; i<4; ++i) {\n        \n        vec2 p = fragCoord.xy - decor_ui_box(i).xy;\n        float idist = decor_icon_dist(p, icon_size, i);\n        \n        icon_dist_update(d_bg, idist, decorations[i] != 0.);\n        \n    }\n    \n    for (int i=0; i<2; ++i) {\n        \n        vec2 p = fragCoord.xy - color_ui_box(i).xy;\n        bool enable = (misc.y == float(i));\n        \n        draw_color_icon(p, icon_size, i, enable, color);\n                \n    }\n    \n    float ldist = dfunc_icon_dist(fragCoord.xy - link_ui_box().xy, \n                                  icon_size, is_linked ? 6 : 5);\n    \n    icon_dist_update(d_bg, ldist, is_linked);\n\n    vec4 rule_box = vec4(inset_ctr.x,\n                         iResolution.y - 2.75*text_size,\n                         0.19 * iResolution.y,\n                         0.25);\n\n    d_gray = min(d_gray, box_dist(fragCoord.xy, rule_box));\n    \n    rule_box.y -= 2.5*text_size;\n    \n    d_gray = min(d_gray, box_dist(fragCoord.xy, rule_box));\n    \n    color = mix(vec3(0), color, smoothstep(0.0, 1.0, d_bg.x));\n    color = mix(vec3(0.4), color, smoothstep(0.0, 1.0, d_bg.y));     \n    color = mix(vec3(0.2), color, smoothstep(0.0, 1.0, d_gray));     \n\n#ifdef DEBUG_HITBOXES\n    \n    float d_hitbox = 1e5;\n    \n    d_hitbox = min(d_hitbox, length(fragCoord.xy - inset_ctr) - 1.\/inset_scl);\n\n    for (int i=0; i<3; ++i) {\n        d_hitbox = min(d_hitbox, box_dist(fragCoord.xy, tri_ui_box(i, -1.)));\n        d_hitbox = min(d_hitbox, box_dist(fragCoord.xy, tri_ui_box(i,  1.)));\n        d_hitbox = min(d_hitbox, box_dist(fragCoord.xy, char_ui_box(i)));\n    }\n    \n    for (int i=0; i<5; ++i) {\n        for (int row=0; row<2; ++row) {\n            d_hitbox = min(d_hitbox, box_dist(fragCoord.xy, dfunc_ui_box(i, row)));\n        }\n    }\n    \n    for (int i=0; i<4; ++i) {\n        d_hitbox = min(d_hitbox, box_dist(fragCoord.xy, decor_ui_box(i)));\n    }\n\n    for (int i=0; i<2; ++i) {\n        d_hitbox = min(d_hitbox, box_dist(fragCoord.xy, color_ui_box(i)));\n    }\n    \n    d_hitbox = min(d_hitbox, box_dist(fragCoord.xy, link_ui_box()));\n    \n    color = mix(vec3(1, 0, 1), color, 0.5+0.5*smoothstep(0., 1., d_hitbox));\n    \n#endif    \n    \n    color = mix(pre_gui_color, color, gui);\n    \n    \/\/ gamma correction\n    color = pow(color, vec3(1.0\/2.2));\n\n    fragColor = vec4(color, 1);\n        \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\/\/ mostly code for triangle setup and coordinate projection\n\/\/ also gui placement\n\nconst float PI = 3.141592653589793;\nconst float TOL = 1e-5;\n\n\/\/ define this to see some interesting visualization\n\/\/ (and to speed up compile!)\n\/\/#define STEREOGRAPHIC_POLAR\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ state storage\n\n#define PQR_COL     0 \n#define THETA_COL   1\n#define BARY_COL    2\n#define SPSEL_COL   3\n#define DFUNC0_COL  4\n#define DFUNC1_COL  5\n#define DECOR_COL   6\n#define MISC_COL    7\n\/\/ link, shade per face, GUI, debugbgcolor\n\n#define TARGET_ROW  0\n#define CURRENT_ROW 1\n\n#define load(x,y) texelFetch(iChannel0, ivec2(x,y), 0)\n#define load4(a,b) load(a,b)\n#define load3(a,b) load(a,b).xyz\n#define load2(a,b) load(a,b).xy\n#define load1(a,b) load(a,b).x\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ triangle layout (see setup_triangle below)\n\nvec3 pqr;\n\nmat3 tri_edges, tri_verts, poly_edges, ortho_proj, planar_proj;\nmat4x3 tri_spoints;\nbvec3 is_face_normal;\n\nmat3x2 planar_verts;\nmat2 bary_mat;\n\nvec3 bary_poly_vertex;\nvec4 spoint_selector = vec4(0);\nvec3 poly_vertex;\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ GUI layout (see setup_gui below)\n\nfloat inset_scl;\nvec2 inset_ctr;\nvec2 object_ctr;\nfloat text_size;\nfloat dfunc_y;\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ stereographic projection\n\nvec2 planar_from_sphere(vec3 q) {\n    \n    q = q * planar_proj;\n    return q.xy \/ q.z;\n    \n}\n\nvec3 sphere_from_planar(vec2 p) {\n    \n    return planar_proj * vec3(p, 1.);\n    \n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ cartesian <-> barycentric\n\nvec3 bary_from_planar(vec2 p) { \n\n    vec2 bxy = bary_mat * (p - planar_verts[2]);\n    return vec3(bxy, 1.-bxy.x-bxy.y);\n    \n}\n\nvec2 planar_from_bary(vec3 b) {\n    return planar_verts * b;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ 3D <-> barycentric (via sterographic projection)\n\nvec3 bary_from_sphere(vec3 q) {    \n    return bary_from_planar(planar_from_sphere(q));\n}\n\n\nvec3 sphere_from_bary(vec3 b) {\n    return tri_verts * b;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ given polyhedron vertex coords as barycentric coords,\n\/\/ compute where it should be on sphere (but first check)\n\/\/ if it should be at a \"special\" point\n\nvoid poly_from_bary() {\n    \n    bool was_select = false;\n    \n    for (int i=0; i<4; ++i) {\n        if (abs(spoint_selector[i] - 1.) < TOL) {\n            poly_vertex = tri_spoints[i];\n            bary_poly_vertex = bary_from_sphere(poly_vertex);\n            was_select = true;\n        }\n    }\n    \n    if (!was_select) {\n        poly_vertex = normalize(sphere_from_bary(bary_poly_vertex.xyz));\n    }\n    \n}    \n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ map 2D position in lower right inset of gui to 3D sphere pos\n\nvec3 sphere_from_gui(in vec2 p) {\n    \n    p -= inset_ctr;\n    p *= inset_scl;\n    \n    float dpp = dot(p, p);\n    \n    if (dpp >= 1.) {\n        return vec3(p\/sqrt(dpp), 0);\n    } else {    \n        vec3 p3d = vec3(p, sqrt(1. - dot(p, p)));\n        return ortho_proj*p3d;\n    }\n    \n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ given PQR and specification of polygon vertex, set up all of the\n\/\/ static info we need to do Wythoff construction later\n\nvoid setup_triangle(in vec3 new_pqr) {\n    \n    pqr = new_pqr;\n    \n    float p = pqr.x;\n    float q = pqr.y;\n    float r = pqr.z;\n\n    float tp = PI \/ p;\n    float tq = PI \/ q;\n    float tr = PI \/ r;\n\n    float cp = cos(tp), sp = sin(tp);\n    float cq = cos(tq);\n    float cr = cos(tr);\n\n    vec3 lr = vec3(1, 0, 0);\n    vec3 lq = vec3(-cp, sp, 0);\n    vec3 lp = vec3(-cq, -(cr + cp*cq)\/sp, 0);\n    \n    lp.z = sqrt(1.0 - dot(lp.xy, lp.xy));\n    \n    tri_edges = mat3(lp, lq, lr);\n    \n    vec3 P = normalize(cross(lr, lq));\n    vec3 R = normalize(cross(lq, lp));\n    vec3 Q = normalize(cross(lp, lr));\n    \n    tri_verts = mat3(P, Q, R);\n    \n    tri_spoints[0] = normalize(cross(lq - lr, lp));\n    tri_spoints[1] = normalize(cross(lr - lp, lq));\n    tri_spoints[2] = normalize(cross(lp - lq, lr));\n    \n    tri_spoints[3] = normalize(cross(lp-lq, lr-lp));\n        \n    ortho_proj[2] = tri_spoints[3];\n    ortho_proj[0] = -normalize(cross(ortho_proj[2], tri_edges[1]));\n    ortho_proj[1] = normalize(cross(ortho_proj[2], ortho_proj[0]));\n    \n    planar_proj[2] = normalize(cross(R-P, Q-P));\n    \n    planar_proj[0] = -normalize(cross(planar_proj[2], tri_edges[1]));\n    planar_proj[1] = normalize(cross(planar_proj[2], planar_proj[0]));\n        \n    for (int i=0; i<3; ++i) {\n        planar_verts[i] = planar_from_sphere(tri_verts[i]);\n    }\n    \n    bary_mat = inverse(mat2(planar_verts[0] - planar_verts[2],\n                            planar_verts[1] - planar_verts[2]));\n    \n\n\tpoly_from_bary();\n    \n    is_face_normal = bvec3(true);\n    \n    for (int i=0; i<3; ++i) {\n        poly_edges[i] = normalize(cross(poly_vertex, tri_edges[i]));\n        for (int j=0; j<2; ++j) {\n            int vidx = (i+j+1)%3;\n            if (abs(dot(tri_verts[vidx], poly_edges[i])) < TOL) {\n                is_face_normal[vidx] = false;\n            }\n        }\n    }\n    \n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ if point p lies opposite m, mirror it. return the transform that\n\/\/ accomplishes this.\n\nmat3 mirror(inout vec3 p, in vec3 m) {\n    \n    float d = dot(p, m);\n    mat3 rval = mat3(1.) - (2. * step(d, 0.)) * outerProduct(m, m);\n        \n    p = rval * p;\n    \n    return rval;\n    \n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ modify the vector m to halve the angle with respect to the y\n\/\/ axis (assume that m.z == 0)\n\nvec3 half_angle(in vec3 m) {\n    return normalize(vec3(m.x - 1.0, m.y, 0.0));\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ use space folding to make sure pos lies in the triangular cone\n\/\/ whose edge planes are given by tri_edges\n\/\/\n\/\/ this function was largely determined by trial and error. possibly\n\/\/ if I understood more about symmetry I would be able to get it \n\/\/ a little simpler\n\nmat3 tile_sphere(inout vec3 pos) {\n    \n    mat3 M = mat3(1.);\n    \n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ part 1: guarantee that the point lives inside\n    \/\/ the cluster of p triangles that share the vertex\n    \/\/ (0, 0, 1)\n    \n    M *= mirror(pos, vec3(1, 0, 0));\n   \n    vec3 m = tri_edges[0];\n\n    for (float i=0.; i<5.; ++i) {\n\n        \/\/ mirror\n        M *= mirror(pos, m);\n        m -= tri_edges[1] * 2.0 * dot(m, tri_edges[1]);\n\n        M *= mirror(pos, m);\n        m -= tri_edges[2] * 2.0 * dot(m, tri_edges[2]);\n\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ part 2: fold in the XY plane to make sure the \n    \/\/ point lives in the triangular cone just to the\n    \/\/ right of the y axis\n       \n    M *= mirror(pos, vec3(1, 0, 0));\n       \n    float p = pqr.x;\n    float k = p >= 5.0 ? 4. : p >= 3.0 ? 2. : 1.;\n    \n    float theta = k * PI \/ p;\n\n    m = vec3(-cos(theta), sin(theta), 0); \/\/ lq\n    \n    if (p >= 5.0) {        \n        M *= mirror(pos, m);\n        m = half_angle(m);\n    }\n    \n    if (p >= 3.0) {\n        M *= mirror(pos, m);\n        m = half_angle(m);\n    }\n    \n    M *= mirror(pos, m);    \n\n    return M;\n        \n}    \n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ rotate about x-axis \n\nmat3 rotX(in float t) {\n    float cx = cos(t), sx = sin(t);\n    return mat3(1., 0, 0, \n                0, cx, sx,\n                0, -sx, cx);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ rotate about y-axis \n\nmat3 rotY(in float t) {\n    float cy = cos(t), sy = sin(t);\n    return mat3(cy, 0, -sy,\n                0, 1., 0,\n                sy, 0, cy);\n\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ GUI box placement functions\n\nfloat box_dist(vec2 p, vec4 b) {\n    \n    p = abs(p - b.xy) - b.zw;\n    return max(p.x, p.y);\n    \n}\n\nvec4 char_ui_box(int idx) {\n    \n    const vec2 digit_rad = vec2(0.35, 0.5);\n    \n    return vec4(inset_ctr.x + (float(idx - 1))*text_size,\n                2.*inset_ctr.y + 1.15*text_size,\n                digit_rad*text_size);\n    \n}\n\nvec4 tri_ui_box(int idx, float delta) {\n    \n    return vec4(char_ui_box(idx).xy + vec2(0, 0.9*delta*text_size), \n                0.4*text_size, 0.3*text_size);\n    \n}\n\nvec4 dfunc_ui_box(int idx, int row) {\n    \n    return vec4(inset_ctr.x + (float(idx - 2))*text_size,\n    \t        dfunc_y - float(1-row)*text_size,\n                vec2(0.45*text_size));\n    \n}\n\nvec4 link_ui_box() {\n    \n    return vec4(inset_ctr.x + 2.85*text_size,\n                dfunc_y - 0.5*text_size,\n                0.3*text_size, 0.5*text_size);\n    \n}\n\nvec4 decor_ui_box(int idx) {\n    \n    return vec4(inset_ctr.x + (float(idx)-1.5)*text_size*1.1,\n                dfunc_y - 2.5*text_size,\n                vec2(0.45*text_size));\n    \n}\n\nvec4 color_ui_box(int idx) {\n    \n    return vec4(inset_ctr.x + (float(idx)-0.5)*text_size,\n                dfunc_y - 3.5*text_size,\n                vec2(0.45*text_size));\n    \n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ set up GUI positions\n\nvoid setup_gui(vec2 res, float gui) {\n    \n    \/\/bool show_gui = gui > 0.99 && res.y > 250.;\n    if (res.y < 250.) { gui = 0.; }\n    \n\n    float inset_sz = 0.20*res.y;\n\n    float margin_px = 6.0;\n\n    text_size = 0.06 * res.y;\n\n    inset_scl = 1.0 \/ inset_sz;\n    inset_sz += margin_px;\n    \n    inset_ctr = vec2(mix(-inset_sz, inset_sz, gui), inset_sz);\n\n    object_ctr = vec2(0.5*res.x + gui*inset_sz, 0.5*res.y);\n\n    dfunc_y = res.y - text_size;\n        \n\n\n}\n    \n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"\/presets\/tex00.jpg","previewfilepath":"\/presets\/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ responsible for handling mouse and setting global states\n\nvec4 data = vec4(0); \/\/ data (fragment color) to write\nivec2 fc; \/\/ current fragment coords \n\n\/\/ how quick to blend to target state\nconst float TARGET_LERP_RATE = 0.08;\n\n\/\/ store a value in the current row (fc.y)\nvoid store(int dst_col, vec4 dst_value) {\n    if (fc.x == dst_col) { data = dst_value; }\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ do these settings represent a valid triangle?    \n\nbool valid_pqr(vec3 pqr) {\n    float s = 1.\/pqr.x + 1.\/pqr.y + 1.\/pqr.z;\n    return s > 1. && s < 1.3;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ helper function for below\n\nvoid update_snap(inout float dmin,\n                 inout int imin,\n                 in int i,\n                 in vec3 q,\n                 in vec3 p) {\n    \n    float d = length(p-q);\n    \n    if (d < dmin) {\n        dmin = d;\n        imin = i;\n    }\n    \n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ given a position q on the sphere, see if it \"snaps\" to one of\n\/\/ three triangle vertices or four \"special points\"\n\nint tri_snap(in vec3 q) {\n\n    float dmin = 1e5;\n    int imin = -1;\n    \n    float ds = 1e5;\n\n    for (int i=0; i<3; ++i) {\n        update_snap(dmin, imin, i, q, tri_verts[i]);\n        update_snap(dmin, imin, i+3, q, tri_spoints[i]);\n        ds = min(ds, length(tri_spoints[i] - tri_spoints[3]));\n    }\n    \n    update_snap(dmin, imin, 6, q, tri_spoints[3]);\n\n    if (dmin < max(0.5*ds, 0.125)) {        \n        return imin;        \n    } else {\n    \treturn -1;\n    }\n    \n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ helper function for below\n\nvoid update_closest(inout vec4 pd, in vec3 pi, in vec3 q) {\n    \n    float di = length(pi-q);\n    \n    if (di < pd.w) { \n        pd.xyz = pi;\n        pd.w = di;\n    }\n    \n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ if q is in the triangle, return q; otherwise return closest point\n\/\/ in triangle to q\n\nvec3 tri_closest(vec3 q) {\n\n    if (min(dot(q, tri_edges[0]), \n            min(dot(q, tri_edges[1]), dot(q, tri_edges[2]))) > 0.) {\n        \n        return q;\n\n    } else {\n\n        vec4 pd = vec4(1e5);\n        \n        for (int i=0; i<3; ++i) {\n            \n            update_closest(pd, tri_verts[i], q);\n\n            int j = (i+1)%3;\n            int k = 3-i-j;\n\n            vec3 Tji = tri_verts[j] - tri_verts[i];\n            \n            float u = clamp(dot(q - tri_verts[i], Tji) \/ dot(Tji, Tji), 0., 1.);\n            vec3 p = normalize(tri_verts[i] + u*Tji);\n            \n            update_closest(pd, p, q);\n\n        }\n        \n        return pd.xyz;\n        \n    }\n\n    \n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ handle clicking in bottom right inset depicting sphere\n\nvoid gui_vertex_update() {    \n\n    if (fc.x != BARY_COL && fc.x != SPSEL_COL) { return; }\n\n    if (length(iMouse.zw - inset_ctr)*inset_scl > 1.) {       \n\n        return; \n        \n    } else {\n\n        vec3 q = sphere_from_gui(iMouse.xy);\n        \n        vec4 spsel;\n        int s = tri_snap(q);\n\n        if (abs(iMouse.zw) == iMouse.xy && s >= 0) {\n            if (s < 3) {\n                if (fc.x == BARY_COL) {\n                    data.xyz = bary_from_sphere( tri_verts[s] );\n                } else {\n                    data = vec4(0);\n                }\n            } else { \n                if (fc.x == BARY_COL) {\n                    data.xyz = bary_from_sphere( tri_spoints[s-3] );\n                } else {\n                    data = vec4(0);\n                    data[s-3] = 1.;\n                }\n            }\n        } else {\n            if (fc.x == BARY_COL) {\n                data.xyz = bary_from_sphere( tri_closest(q) );\n            } else {\n                data = vec4(0);\n            }\n        }\n\n    }\n    \n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ handle clicking triangle spin boxes \n\nvoid gui_pqr_update() {\n    \n    if (fc.x != PQR_COL) { return; }\n    \n    for (int i=0; i<3; ++i) {\n\n        int j = (i+1)%3;\n        int k = 3-i-j;\n\n        for (float delta=-1.; delta <= 1.; delta += 2.) {\n            \n            bool enabled = (delta < 0.) ? data[i] > 2. : data[i] < 5.;\n            if (!enabled) { continue; }\n\n            float d = box_dist(iMouse.xy, tri_ui_box(i, delta));       \n            if (d > 0.) { continue; }\n\n            data[i] += delta;\n            \n            int iopp = delta*data[j] > delta*data[k] ? j : k;\n            \n            for (int cnt=0; cnt<5; ++cnt) {\n                if (valid_pqr(data.xyz)) { continue; }\n                data[iopp] -= delta; \n            }   \n            \n        }\n    }\n\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ handle polyhedron rotation (time based or mouse based)\n\nvoid gui_theta_update() {\n    \n    if (fc.x != THETA_COL) { return; }\n    \n    if (iMouse.z > 2.*inset_ctr.x && iMouse.w > 0.) {\n        \n        \/\/ mouse down somewhere in the pane but not in GUI panel    \n        \n    \tif ( length(iMouse.zw - object_ctr) < 0.45 * iResolution.y) {\n\n            \/\/ down somewhere near object\n            vec2 disp = (iMouse.xy - object_ctr) * 0.01;\n            data.xyz = vec3(-disp.y, disp.x, 1);\n            \n        } else {\n            \n            \/\/ down far from object\n            data.z = 0.;\n            \n        }\n        \n    }\n    \n        \n    if (data.z == 0.) {\n        float t = iTime;\n        data.x = t * 2.*PI\/6.; \n        data.y = t * 2.*PI\/18.;\n    }    \n    \n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ handle clicking on distance function selectors\n\nvoid gui_dfunc_update() {\n    \n    if (!(fc.x == DFUNC0_COL || fc.x == DFUNC1_COL)) { return; }\n        \n    bool is_linked = (load(MISC_COL, TARGET_ROW).x != 0.);\n\n    for (int row=0; row<2; ++row) {  \n\n        int col_for_row = (row == 0 ? DFUNC0_COL : DFUNC1_COL);\n\n        for (int i=0; i<5; ++i) {\n\n            bool update = ( (is_linked && fc.x == DFUNC1_COL) || \n                           (!is_linked && fc.x == col_for_row) );\n\n            if (update) {\n\n                if (box_dist(iMouse.xy, dfunc_ui_box(i, row)) < 0.) {\n                    data = vec4(0);\n                    if (i > 0) { data[i-1] = 1.; }\n                }\n\n            }\n        }\n\n    }\n\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ handle clicking on chain link icon or color selectors\n\nvoid gui_misc_update() {\n    \n    if (fc.x != MISC_COL) { return; }\n        \n    if (box_dist(iMouse.xy, link_ui_box()) < 0.) {\n        data.x = 1. - data.x;\n    }\n    \n    for (int i=0; i<2; ++i) {\n        if (box_dist(iMouse.xy, color_ui_box(i)) < 0.) {\n            data.y = float(i);\n        }\n    }\n    \n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ handle clicking on decoration icons\n\nvoid gui_decor_update() {\n    \n    if (fc.x != DECOR_COL) { return; }\n    \n    for (int i=0; i<4; ++i) {\n        if (box_dist(iMouse.xy, decor_ui_box(i)) < 0.) {\n            data[i] = 1. - data[i];\n        }\n    }\n    \n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ main \"rendering\" function\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    fc = ivec2(fragCoord);\n    \n    data = texelFetch(iChannel0, fc, 0);        \n               \n    vec4 pqrx = load(PQR_COL, TARGET_ROW);\n\n    float gui = 1.0 - texelFetch(iChannel1, ivec2(32, 2), 0).x;\n\n    if (iFrame == 0) {\n\n        \/\/ on first frame, store in default values\n        store(PQR_COL, vec4(5, 3, 2, iTime));\n        store(THETA_COL, vec4(0, 0, 0, 1));\n        store(BARY_COL, vec4(0, 0, 0, 0));\n        store(SPSEL_COL, vec4(0, 0, 0, 1));\n        store(DFUNC1_COL, vec4(0, 1, 0, 0));\n        store(DFUNC0_COL, vec4(0, 0, 0, 1));        \n        store(DECOR_COL, vec4(1));\n        store(MISC_COL, vec4(0, 0, gui, 1));\n\n    } else if (fc.y == TARGET_ROW) {\n        \n    \t\/\/ target values are set by UI    \n        setup_gui(iResolution.xy, gui);\n        setup_triangle(pqrx.xyz);                   \n\n        float cur_mouse_state = min(iMouse.z, iMouse.w) > 0. ? 1. : -1.;\n        bool click = (cur_mouse_state == 1. && pqrx.w <= 0.);       \n\n        if (fc.x == PQR_COL) {\n            data.w = cur_mouse_state * iTime;\n        } \n        if (fc.x == MISC_COL) {\n            data.z = gui;\n        }\n        \n        float current_gui = load(MISC_COL, CURRENT_ROW).z;\n\n        if (current_gui > 0.95) {\n            \n            if (click) { \n                gui_pqr_update(); \n                gui_dfunc_update(); \n                gui_decor_update(); \n                gui_misc_update(); \n            }\n\n            gui_vertex_update();        \n            \n        }\n\n        gui_theta_update();\n            \n        \n    } else {\n        \n        vec4 cpqrx = load(PQR_COL, CURRENT_ROW);\n        float dt = iTime - cpqrx.w;\n        \n        \/\/ current values are set by lerping towards target\n        vec4 target = load(fc.x, TARGET_ROW);         \n        \n        if (dt == 0.) {\n            data = target;\n        } else {\n            data = mix(data, target, TARGET_LERP_RATE);       \n        }\n        \n        if (fc.x == PQR_COL) {\n            data.w = abs(pqrx.w);\n        }\n        \n    }\n        \n    fragColor = data;\n    \n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGzr","filepath":"\/media\/a\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"\/media\/ap\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/\/ distance marches and shades the polyhedron\n\nconst int rayiter = 8;\nvec3 L = normalize(vec3(-0.7, 1.0, -1.0));\n\nconst float dmin = 2.0;\nconst float dmax = 5.0;\n\nvec4 distance_function;\nfloat shade_per_face;\nfloat bg_value;\nvec4 decorations;\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ data structure for polyhedron distance queries\n\nstruct query_t {\n    \n    int vidx; \/\/ index of triangle vertex\n    int eidx; \/\/ index of triangle edge\n    \n    float fdist_vertex; \/\/ 3D distance to closest vertex\n    float fdist_edge;   \/\/ 3D distance to closest edge\/vertex\n    float fdist_face;   \/\/ 3D distance to closest face\/edge\/vertex\n    \n    float pdist_tri;       \/\/ distance to triangle cutting plane\n    float pdist_poly_edge; \/\/ SIGNED distance to polyhedron edge cutting plane (pass thru ctr)\n    float pdist_poly_perp; \/\/ perpendicular distance to polyhedron edge (parallel to face)\n    float pdist_bisector;  \/\/ distance to polyhedron edge bisector cutting plane\n    \n    mat3 M; \/\/ 3D flip to move point inside spherical triangle\n    \n};\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ wythoff construction - the workhorse of the distance estimator.\n\nvoid construct(in vec3 pos, out query_t Q) {     \n    \n    \/\/ flip point to land within spherical triangle\n    Q.M = tile_sphere(pos);\n       \n    \/\/ position relative to vertex\n    vec3 rel_pos = pos - poly_vertex;\n    \n    \/\/ initialize data structure members that get updated \n    \/\/ as the loop progresses\n    Q.fdist_vertex = length(rel_pos);\n    Q.fdist_edge = Q.fdist_vertex;\n    Q.pdist_tri = 1e5;\n             \n    \/\/ for each potential face edge (perpendicular to each tri. edge)\n    for (int eidx=0; eidx<3; ++eidx) {   \n        \n        vec3 tri_edge = tri_edges[eidx];\n        \n        \/\/ update distance to triangle\n        Q.pdist_tri = min(Q.pdist_tri, dot(pos, tri_edge));\n        \n        \/\/ signed distance of polyhedron vertex poly_vertex from edge plane\n        float V_tri_dist = dot(poly_vertex, tri_edge);\n        \n        \/\/ polyhedron edge cut plane (passes thru origin and V, perpendicular\n        \/\/ to triangle edge)\n        vec3 poly_edge = poly_edges[eidx];\n                                \n        \/\/ signed distance from point to face edge\n        float poly_edge_dist = dot(pos, poly_edge);\n\n        \/\/ triangle vertex on the same side of face edge as point\n        int vidx = (eidx + (poly_edge_dist > 0. ? 2 : 1)) % 3;\n        \n        \/\/ see which side of the vertex we are on\n        float rel_tri_dist = dot(rel_pos, tri_edge);\n        \n\t\t\/\/ update distance to edge        \n        Q.fdist_edge = min(Q.fdist_edge, length(rel_pos - min(rel_tri_dist, 0.) * tri_edge));     \n       \n        \/\/ construct at the other polyhedron edge associated with the given\n        \/\/ triangle vertex\n        vec3 other_poly_edge = poly_edges[3-eidx-vidx];\n        \n        \/\/ construct the plane that bisects the two polyhedron edges\n        vec3 bisector = cross(poly_vertex, poly_edge - other_poly_edge);\n        \n        float bisector_dist = dot(pos, bisector);\n             \n        if (bisector_dist > 0.) {\n            \/\/ if we are on the correct side of the associated\n            \/\/ bisector, than we have found the closest triangle\n            \/\/ edge & vertex.\n            \n            Q.pdist_bisector = bisector_dist;\n            Q.pdist_poly_edge = poly_edge_dist;\n            Q.eidx = eidx;\n            Q.vidx = vidx;\n            \n        }\n \n    }\n    \n    \/\/ computing the perpendicular distance away from\n    \/\/ the polyhedron edges was a bit hairy. there\n    \/\/ was probably a better way to do this.\n    \n    \/\/ initialize to zero\n    Q.pdist_poly_perp = 1e5;\n\n    \/\/ for each triangle vertex\n    for (int vidx=0; vidx<3; ++vidx) {\n        \n        if (!is_face_normal[vidx]) { continue; }\n\n        vec3 tri_vertex = tri_verts[vidx];\n\n        \/\/ midpoint of polyhedron face\n        vec3 P = tri_vertex * dot(poly_vertex, tri_vertex);\n\n        \/\/ initial big negative perpendicular distance\n        float pp = -1e5;\n\n        \/\/ for each triangle edge associated with the vertex\n        for (int j=0; j<2; ++j) {\n\n            int eidx = (vidx+j+1)%3;\n\n            \/\/ constructed same as big for loop above\n            vec3 tri_edge = tri_edges[eidx];           \n\n            \/\/ midpoint of polyhedron edge\n            vec3 F = poly_vertex - dot(poly_vertex, tri_edge)*tri_edge;\n\n            \/\/ mix in signed distance perpendicular to edge\n            pp = max(pp, dot(rel_pos, normalize(F - P)));\n\n        }\n\n        Q.pdist_poly_perp = min(Q.pdist_poly_perp, pp); \n        \n    }\n\n    if (Q.pdist_poly_perp < 0.) {\n        \/\/ only use true distance to face if we are \"above\" it\n        Q.fdist_face = dot(rel_pos, tri_verts[Q.vidx]);\n    } else {\n        \/\/ otherwise just use distance to edge\n        Q.fdist_face = Q.fdist_edge;\n    }\n        \n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ distance estimator weighs a linear combination of different\n\/\/ distance functions\n\nvec2 map(in vec3 pos) {\n    \n    query_t Q;\n    \n    construct(pos, Q);\n    \n    mat4x2 tm;\n    \n    \/\/ distance to sphere\n    vec2 sphere = vec2(length(pos)-1., 2);\n    \n    \/\/ distance to polyhedron\n\ttm[0] = vec2(Q.fdist_face, 2);\n    \n    \/\/ distance to ball-and-stick web (cylinders\/spheres)\n    vec2 dv = vec2(Q.fdist_vertex-0.07, 0);\n    vec2 de = vec2(Q.fdist_edge-0.04, 1);    \n    tm[1] = dv.x < de.x ? dv : de;                  \n\n    \/\/ distance to polyhedral net (faceted edges)\n    tm[2] = vec2(max(-(Q.pdist_poly_perp+0.08),\n                     max(Q.fdist_face, -0.08-Q.fdist_face)), 1);\n    \n    \/\/ distance to polyhedron dilated by sphere\n    tm[3] = vec2(Q.fdist_face-0.15, 2);\n          \n    \/\/ sphere coefficient\n    float k = 1.0 - dot(distance_function, vec4(1));\n    \n    \/\/ return final linear combination\n    return (k*sphere + tm * distance_function);\n\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ IQ's normal calculation. \n\nvec3 calcNormal( in vec3 pos ) {\n    vec3 eps = vec3( 0.01, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n    return normalize(nor);\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ IQ's distance marcher. \n\nvec2 castRay( in vec3 ro, in vec3 rd ) {\n\n    const float precis = 0.001;   \n    float h=dmin;\n\n    float t = 0.0;\n    float m = -1.0;\n\n    for( int i=0; i<40; i++ ) {\n\n        if( abs(h)<precis||t>dmax ) continue;\/\/break;\n        t += h;\n        vec2 res = map( ro+rd*t );\n        h = res.x;\n        m = res.y;        \n        \n    }    \n\n    if (t > dmax) {\n        m = -1.0;\n    }\n\n    return vec2(t, m);\n\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ coloring function for surface shading - input is position and\n\/\/ material (0=vertex, 1=edge, 2=face)\n\nvec3 poly_color(vec3 pos, float material) {\n\n    \/\/ do our distance query with the given point\n    query_t Q;\n    construct(pos, Q);\n    \n    \/\/ this would be an odd failure but it happened\n    \/\/ sometimes during debugging\n    if (Q.vidx < 0) {return vec3(0.9); }\n\n    \/\/ \"standard\" blue\/yellow\/red vertex colors\n    const mat3 std_fcolors = mat3(vec3(0, 0, 1),\n                               vec3(1, 1, 0),\n                               vec3(1, 0, 0));\n\n    \/\/ for coloring with faces - gives a nice contrast to \n    \/\/ the bgcolors above\n    const mat3 std_ecolors = mat3(vec3(1, 0.5, 0),\n                              vec3(0.5, 0, 1),\n                              vec3(0, 0.5, 0));\n\n    const vec3 std_vert = vec3(0.1, 0.2, 0.5);\n    \n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ start setting up some AA for face coloring\n    \/\/\n    \/\/ Q.vidx is the index of the triangle vertex that forms\n    \/\/ the normal of this face\n    \/\/\n    \/\/ Q.eidx is the index of the triangle edge perpendicular\n    \/\/ to the polyhedron edge\n    \/\/ \n    \/\/ now we want to find the index of the triangle vertex\n    \/\/ which lies *across* this polyhedron edge (this is for\n    \/\/ anti-aliasing using the \"standard\" color scheme\n    \n    \/\/ start with other vertex on this triangle edge, \n    \/\/ and see if it is also on this polyhedron edge\n    int vidx2 = 3 - Q.vidx - Q.eidx;                    \n\n    vec3 opposite_tri_vertex = tri_verts[vidx2];\n    float opp_on_edge = abs(dot(opposite_tri_vertex, poly_edges[Q.eidx]));\n\n    \/\/ if so, then the same triangle vertex is used as normal\n    \/\/ for both faces (just in an adjacent triangle)\n    if (opp_on_edge < TOL) { vidx2 = Q.vidx; }\n    \n    vec3 tri_vert2 = tri_verts[vidx2];\n\n    if (vidx2 == Q.vidx) {\n         tri_vert2 = reflect(tri_vert2, poly_edges[Q.eidx]);\n    }\n\n    \/\/ hacked scaling factor for antialiasing -- should probably\n    \/\/ be based on ray differentials, but in practice this works fine\n    float s = 2.5\/iResolution.y;\n\n    \/\/ blend coefficient for blending between two different face colors\n    float u_face_aa = smoothstep(-0.5*s, 0.5*s, abs(Q.pdist_poly_edge));\n\n    \/\/ get antialiased standard face color and face normal\n    vec3 std_face_aa = mix(std_fcolors[vidx2], std_fcolors[Q.vidx], u_face_aa);\n    vec3 sph_face_aa = mix(tri_vert2, tri_verts[Q.vidx], u_face_aa);\n    \n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ AA for edge coloring\n\n    \/\/ get blended edge color (probably a smarter way to antialias)\n    vec3 std_edge_aa = mix(std_ecolors*vec3(0.33333), std_ecolors[Q.eidx],\n                           smoothstep(0., s, Q.pdist_bisector));\n\n    \/\/ midpoint of closest polygon edge\n    vec3 edge_midpoint = poly_vertex - dot(tri_edges[Q.eidx], poly_vertex)*tri_edges[Q.eidx];\n\n    \/\/ plane splitting face thru polyhedron vertex and face center\n    vec3 face_split = normalize(cross(tri_verts[Q.vidx], poly_vertex));\n    \n    \/\/ same midpoint across splitline\n    vec3 opp_edge_midpoint = reflect(edge_midpoint, face_split);\n\n    \/\/ edges should blend together at polyhedron vertex\n    vec3 sph_edge_aa = mix(poly_vertex, edge_midpoint,\n                         smoothstep(0., s, Q.pdist_bisector));\n    \n    \/\/ edges should blend together near corners of face\n    sph_edge_aa = mix(opp_edge_midpoint, sph_edge_aa,\n                      smoothstep(-0.5*s, 0.5*s, abs(dot(pos, Q.M*face_split))));\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ now put it all together\n\n    \/\/ blend between standard and spherical shading\n    vec3 face = mix(std_face_aa, 0.5*(Q.M*sph_face_aa)+0.5, shade_per_face);\n    vec3 edge = mix(std_edge_aa, 0.5*(Q.M*sph_edge_aa)+0.5, shade_per_face);\n    vec3 vert = mix(std_vert, 0.25*(Q.M*poly_vertex)+0.75, shade_per_face);\n\n    \/\/ blend face, verts, edges with decorations\n    vec3 color = face;\n    \n    \/\/ vertex and polyhedron edge decorations affect just face\n    float scaled_vertex_distance = length(pos - Q.M*poly_vertex*length(pos));\n    color *= mix(1.0, 0.0, \n                max(decorations.x*smoothstep(s, 0.0, scaled_vertex_distance-0.02),\n                    decorations.y*smoothstep(s, 0.0, abs(Q.pdist_poly_edge)-.5*s)));\n\n    \/\/ edge colors\n    color = mix(color, edge, clamp(2. - material, 0.0, 1.0));\n\n    \/\/ parity & triangle edges affect face & edge\n    float parity = dot(Q.M[0], cross(Q.M[1], Q.M[2]));\n    \n    color *= mix(1.0, 0.8, decorations.w*smoothstep(0.5*s, -0.5*s, parity*Q.pdist_tri));\n    color *= mix(1.0, 0.5, decorations.z*smoothstep(s, 0.0, abs(Q.pdist_tri)));        \n\n    \/\/ vertex colors\n    color = mix(color, vert, clamp(1. - material, 0.0, 1.0));\n    \n    \/\/done\n    return color;\n    \n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ trace ray & determine fragment color\n\nvec4 shade( in vec3 ro, in vec3 rd ){\n\n    vec2 tm = castRay(ro, rd);        \n\n    vec3 c;\n\n    if (tm.y < 0.0) {\n\n        tm.x = dmax;\n        c = vec3(bg_value);\n\n    } else {        \n\n        vec3 pos = ro + tm.x*rd;\n               \n        vec3 n = calcNormal(pos);\n        \n        vec3 color = poly_color(pos, tm.y);\n        \n        vec3 diffamb = (0.9*clamp(dot(n,L), 0.0, 1.0)+0.1) * color;\n        \n        vec3 p = normalize(pos);\n        \n        vec3 refl = 2.0*n*dot(n,L)-L;\n        float spec = 0.4*pow(clamp(-dot(refl, rd), 0.0, 1.0), 20.0);\n        c = diffamb + spec;\n        \n        c *= 0.4*dot(p, n) + 0.6;\n        \n\n    }\n\n    return vec4(c, tm.x);\n\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ generate polyhedron image finally\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n#ifdef STEREOGRAPHIC_POLAR    \n    \n    fragColor = vec4(1, 1, 1, dmax); \n        \n#else    \n    \n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ load in settings from GUI manager\n    \n    \/\/ load triangle shape & rotation from target row (set directly)\n    vec4 pqrx = load4(PQR_COL, TARGET_ROW);        \n    vec4 theta = load4(THETA_COL, TARGET_ROW);  \n\n    vec4 cpqrx = load4(PQR_COL, CURRENT_ROW);\n    float dt = iTime - cpqrx.w;\n    \n    int active_row = CURRENT_ROW;\n    \n    if (dt == 0.) {\n        active_row = TARGET_ROW;\n    }\n\n    \/\/ all other params change continuously\n    bary_poly_vertex = load3(BARY_COL, active_row);\n    spoint_selector = load4(SPSEL_COL, active_row);    \n    vec4 misc = load4(MISC_COL, active_row);\n    vec4 df1 = load4(DFUNC1_COL, active_row);    \n    vec4 df0 = mix(load4(DFUNC0_COL, active_row), df1, misc.x);\n    decorations = load4(DECOR_COL, active_row);\n\n    shade_per_face = misc.y;\n    bg_value = misc.w;\n    \n    distance_function = mix(df0, df1, smoothstep(0.25, 0.75, fragCoord.y\/iResolution.y));\n                        \n    setup_triangle(pqrx.xyz); \n    setup_gui(iResolution.xy, misc.z);\n    \n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ pretty normal raymarcher\/renderer from here on out\n    \/\/ only twist is that emit ray distance along with\n    \/\/ color to final buffer in order to do AA along \n    \/\/ depth discontinuities\n\n    vec2 uv = (fragCoord.xy - object_ctr) * 0.8 \/ (iResolution.y);\n    \n    const vec3 tgt = vec3(0.0, 0.0, 0.0);\n    const vec3 cpos = vec3(0.0, 0.0, 3.25);\n    const vec3 up = vec3(0, 1, 0);\n\n    vec3 rz = normalize(tgt - cpos),\n        rx = normalize(cross(rz,vec3(0,1.,0))),\n        ry = cross(rx,rz);\n\n\n    mat3 Rview = mat3(rx,ry,rz)*rotY(theta.y)*rotX(theta.x); \n    L = Rview*L;\n\n    vec3 rd = Rview*normalize(vec3(uv, 1.));\n    vec3 ro = tgt + Rview*vec3(0,0,-length(cpos-tgt));\n\n    fragColor = shade(ro, rd);\n    \n#endif\n    \n}\n","name":"Buf B","description":"","type":"buffer"}]}];    var gUseScreenshots = piIsMobile();
    var gThemeName = "classic";



    </script>
</head>

<!-- <body onload="resultsInit(12,null,null)"> -->
<body onload="resultsInitStatic(12,null,null)">

<!-- header =================================================================================== -->


<div id="header">

    <div id="headerBlock1">
        <a href="/" id="headerTitle">Shadertoy</a>
        <form name="formSearch" action="/results" method="get" style="display:inline-block;">
        <div  id="headerSearch">
            <input type="search" id="mySearch" name="query" placeholder="Search..." value=""/>
        </div>
        </form>
    </div>

    <div id="headerBlock2">
            <a class="headerLinks" href="/browse">Browse</a>
        <a class="headerLinks" href="/new">New</a>
        <a class="headerLinks" href="/signin">Sign In</a>
        </div>
</div>
<!-- content ================================================================================== -->

<div id="content">

  <div id="controls">
    <div>
      <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
      Sort:      </div>
      <div class="controlOptions"><div class="pageButtonsCurrent" href="/results?query=&sort=popular&filter=">Popular</div><a class="pageButtons" href="/results?query=&sort=newest&filter=">Newest</a><a class="pageButtons" href="/results?query=&sort=love&filter=">Love</a><a class="pageButtons" href="/results?query=&sort=hot&filter=">Hot</a></div>
    </div>

    <div id="controlFilter">
      <div style="display:flex;margin-right:8px;align-items:center;">Filter:</div>
      <div class="controlOptions"> <a class="pageButtons" href="/results?query=&sort=popular&filter=multipass">Multipass</a><a class="pageButtons" href="/results?query=&sort=popular&filter=soundoutput">GPU Sound</a><a class="pageButtons" href="/results?query=&sort=popular&filter=vr">VR</a><a class="pageButtons" href="/results?query=&sort=popular&filter=soundinput">Microphone</a><a class="pageButtons" href="/results?query=&sort=popular&filter=musicstream">Soundcloud</a><a class="pageButtons" href="/results?query=&sort=popular&filter=webcam">Webcam</a></div>
    </div>

    <div>
        <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
        View:</div>
        <div><a class="pageButtons" href="/slideshow?query=&sort=popular">Slideshow</a></div>
    </div>

    <div class="navigation" id="navTop" ><span style="padding-right:8px;">Results (74098):</span><div class="controlOptions"><a id="pageButtonFirst" class="pageButtons" href="results?query=&sort=popular&from=0&num=12">1</a><span>...</span><a id="pageButton"0 class="pageButtons" href="results?query=&sort=popular&from=444&num=12">38</a><a id="pageButton"1 class="pageButtons" href="results?query=&sort=popular&from=456&num=12">39</a><div id="pageButton"2 class="pageButtonsCurrent" href="results?query=&sort=popular&from=468&num=12">40</div><a id="pageButton"3 class="pageButtons" href="results?query=&sort=popular&from=480&num=12">41</a><a id="pageButton"4 class="pageButtons" href="results?query=&sort=popular&from=492&num=12">42</a><span>...</span><a id="pageButtonLast" class="pageButtons" href="results?query=&sort=popular&from=74088&num=12">6175</a></div>
</div>
  </div>


  <div id="shaderGrid">
    <div class='searchResult'><div class='searchResultContainer' id='Preview_0_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_0_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_0_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_0_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_0_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_0_Thumnail'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_0_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_0_Info'>  <span class='previewText'  id='Preview_0_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_0_TextUser'></span>  <span class='previewStats' id='Preview_0_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_1_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_1_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_1_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_1_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_1_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_1_Thumnail'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_1_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_1_Info'>  <span class='previewText'  id='Preview_1_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_1_TextUser'></span>  <span class='previewStats' id='Preview_1_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_2_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_2_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_2_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_2_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_2_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_2_Thumnail'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_2_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_2_Info'>  <span class='previewText'  id='Preview_2_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_2_TextUser'></span>  <span class='previewStats' id='Preview_2_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_3_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_3_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_3_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_3_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_3_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_3_Thumnail'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_3_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_3_Info'>  <span class='previewText'  id='Preview_3_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_3_TextUser'></span>  <span class='previewStats' id='Preview_3_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_4_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_4_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_4_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_4_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_4_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_4_Thumnail'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_4_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_4_Info'>  <span class='previewText'  id='Preview_4_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_4_TextUser'></span>  <span class='previewStats' id='Preview_4_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_5_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_5_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_5_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_5_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_5_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_5_Thumnail'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_5_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_5_Info'>  <span class='previewText'  id='Preview_5_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_5_TextUser'></span>  <span class='previewStats' id='Preview_5_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_6_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_6_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_6_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_6_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_6_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_6_Thumnail'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_6_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_6_Info'>  <span class='previewText'  id='Preview_6_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_6_TextUser'></span>  <span class='previewStats' id='Preview_6_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_7_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_7_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_7_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_7_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_7_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_7_Thumnail'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_7_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_7_Info'>  <span class='previewText'  id='Preview_7_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_7_TextUser'></span>  <span class='previewStats' id='Preview_7_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_8_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_8_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_8_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_8_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_8_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_8_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_8_Thumnail'>        <img class='previewThumbnailImage' id='Preview_8_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_8_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_8_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_8_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_8_Info'>  <span class='previewText'  id='Preview_8_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_8_TextUser'></span>  <span class='previewStats' id='Preview_8_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_9_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_9_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_9_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_9_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_9_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_9_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_9_Thumnail'>        <img class='previewThumbnailImage' id='Preview_9_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_9_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_9_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_9_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_9_Info'>  <span class='previewText'  id='Preview_9_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_9_TextUser'></span>  <span class='previewStats' id='Preview_9_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_10_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_10_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_10_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_10_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_10_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_10_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_10_Thumnail'>        <img class='previewThumbnailImage' id='Preview_10_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_10_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_10_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_10_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_10_Info'>  <span class='previewText'  id='Preview_10_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_10_TextUser'></span>  <span class='previewStats' id='Preview_10_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_11_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_11_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_11_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_11_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_11_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_11_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_11_Thumnail'>        <img class='previewThumbnailImage' id='Preview_11_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_11_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_11_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_11_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_11_Info'>  <span class='previewText'  id='Preview_11_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_11_TextUser'></span>  <span class='previewStats' id='Preview_11_Stats'></span></div></div>  </div>
  <br>
  <div class="navigation" id="navBottom" ><span style="padding-right:8px;">Results (74098):</span><div class="controlOptions"><a id="pageButtonFirst" class="pageButtons" href="results?query=&sort=popular&from=0&num=12">1</a><span>...</span><a id="pageButton"0 class="pageButtons" href="results?query=&sort=popular&from=444&num=12">38</a><a id="pageButton"1 class="pageButtons" href="results?query=&sort=popular&from=456&num=12">39</a><div id="pageButton"2 class="pageButtonsCurrent" href="results?query=&sort=popular&from=468&num=12">40</div><a id="pageButton"3 class="pageButtons" href="results?query=&sort=popular&from=480&num=12">41</a><a id="pageButton"4 class="pageButtons" href="results?query=&sort=popular&from=492&num=12">42</a><span>...</span><a id="pageButtonLast" class="pageButtons" href="results?query=&sort=popular&from=74088&num=12">6175</a></div>
</div>  <br>      
</div>

<!-- footer ================================================================================== -->

<div id="footer">
    
    <div><span style="color:#ffffff;">Community Forums</span>
      <ul>
      <li><a class="regular" href="/events">Official Events</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/147749602472741">In Facebook (english)</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/1339783682699494">In Facebook (korean)</a></li>
      <li><a class="regular" href="https://discord.gg/XtmMN6E">In Discord</a> (<a class="regular" href="https://discordapp.com/channels/578696555612209173/579531723348639754">direct link</a>)</li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Feedback and Support</span>
      <ul>
      <li><a class="regular" href="https://www.facebook.com/Shadertoy">Facebook</a></li>
      <li><a class="regular" href="https://twitter.com/shadertoy">Twitter</a></li>
      <li><a class="regular" href="https://www.patreon.com/shadertoy">Patreon</a></li>
      <li><a class="regular" href="https://trello.com/b/5hM0CjId">Roadmap</a></li>

      
      </ul>
    </div>

    <div><span style="color:#ffffff;">Shadertoy</span>
      <ul>
      <li><a class="regular" href="/store">Store</a></li>
      <li><a class="regular" href="/howto">Documentation</a></li>
      <li><a class="regular" href="/terms">Terms & Privacy</a></li>
      <li><a class="regular" href="/about">About</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Apps and Plugins</span>
      <ul>
      <li><a class="regular" href="https://itunes.apple.com/us/app/shadertoy/id717961814">Official iPhone App</a> by <a class="user" href="/user/reinder">Reinder</a></li>
      <li><a class="regular" href="https://steamcommunity.com/sharedfiles/filedetails/?id=1726697188">Screensaver</a> by <a class="user" href="/user/kosro">Kosro</a></li>
      <li><a class="regular" href="https://chrome.google.com/webstore/detail/shadertoy-unofficial-plug/ohicbclhdmkhoabobgppffepcopomhgl">Shadertoy plugin</a> by <a class="user" href="/user/patu">Patu</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Tutorials</span>
      <ul>
      <li><a class="regular" href="https://www.youtube.com/watch?v=0ifChJ0nJfM">Shader coding intro</a> by <a class="user" href="/user/iq">iq</a></li>
      <li><a class="regular" href="https://shadertoyunofficial.wordpress.com/">Shadertoy Unofficial</a> by <a class="user" href="/user/FabriceNeyret2">FabriceNeyret2</a></li>
      </ul>
    </div>

</div>

<div id="compliance" style="padding-bottom:6px;visibility:hidden;left:0;top:0px;width:100%;background-color:rgb(200,120,20,0.93);position:absolute;color:#FFFFFF">
    <div style="text-align: center; margin-top:8px">
        We use cookies to give you the best experience on our website. If you continue using Shadertoy, we'll assume that you are happy to receive all cookies on this website. 
        For more information, please review our <a class="regular" href="/terms">Terms & Privacy</a>.
    </div> 
    <div style="text-align: center;margin-top:6px">
        <button type="button" style="width:100px;font-size:inherit" onclick="acceptCompliance()">Accept</button>
    </div>
</div>

<script>
(function runCompliance() 
{
    let showCompliance = 1;
    let allcookies = document.cookie;
    let cookiearray = allcookies.split(';');
    for (var i=0; i<cookiearray.length; i++)
    {
        let name  = cookiearray[i].split('=')[0];
        let value = cookiearray[i].split('=')[1];
        if (name.trim() == "scmp") 
        {
            showCompliance = value;
            break;
        }
    }

    if (showCompliance === 1) 
    {
        var ve = document.getElementById("compliance");
        ve.style.visibility="visible";
    }
})();

function acceptCompliance()
{
    let now = new Date();
    now.setTime( now.getTime() + (5*365*24*60*60*1000) );
    document.cookie="scmp=0;expires=" + now.toUTCString() + ";";

    var ve = document.getElementById("compliance");
    ve.style.visibility="hidden";
}
</script>

</body>
</html>
