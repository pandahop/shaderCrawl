<!DOCTYPE HTML>
<html lang="en">
<head>

    
<script async src="https://www.googletagmanager.com/gtag/js?id=G-7SYLWGZYJ2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-7SYLWGZYJ2');
</script>

<title>Browse (62) - Shadertoy BETA</title>
<meta charset="utf-8" />
<meta name="Keywords" content="shadertoy, shader toy, quilez, inigo, jeremias, pol, fractals, demoscene, computer graphics, mathematics, rendering, demo, 3D, realtime, shader, raytracing, raymarching, webgl, glsl" />
<meta name="Description" content="Build shaders, share them, and learn from the best community." />
<meta name="Author" content="Beautypi" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<link rel="image_src" href="https://www.shadertoy.com/img/logo.png" />
<link rel="apple-touch-icon" href="/img/launch_icon_57.png"/>
<link rel="apple-touch-icon" sizes="72x72" href="/img/launch_icon_72.png"/>
<link rel="apple-touch-icon" sizes="114x114" href="/img/launch_icon_114.png"/>
<link rel="shortcut icon" href="/img/favicon.ico"/>

<style>::-webkit-scrollbar {
    height: 8px;
    width: 8px;
    background: #404040;
}

::-webkit-scrollbar-thumb
{
    background: #909090;
    border-radius: 0ex;
}

::-webkit-scrollbar-corner
{
    background: #000;
}

::-webkit-input-placeholder
{
	font-style:italic;
}
input:-moz-placeholder, textarea:-moz-placeholder
{
	font-style:italic;
}
input.placeholder-text, textarea.placeholder-text
{
	font-style:italic;
}

pre 
{
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
    white-space: -pre-wrap;
    white-space: -o-pre-wrap;
    word-wrap: break-word;
}

@font-face
{
    font-family: Lobster;
    src: url("/img/lobster.otf") format("opentype");
}

div#centerScreen
{
    left: 50%;
    top: 50%;
    position: absolute;
}

a.headerLinks:hover
{
    background-color:#505050;
    color : #ff8020;
}

body
{
    color: #000000;
    font-size:12px;
    font-style:normal;
    font-family:Tahoma,Arial;
    background-repeat: no-repeat;
    //background-attachment: fixed;
    padding:0px;
    margin:0px;
    text-align: left;
    background-color: #d0d0d0;
    background-repeat: repeat;
    user-select: text;
}

a,
a:hover,
a:visited
{
  color : inherit;
}

div#content {
    width: 95%;
    overflow: hidden;
    margin: auto;
    padding: 0px;
    min-height: calc(100vh - 80px);
    //box-sizing: border-box;
}


.notificationCount
{
 background-color:#ff0000;
 padding-left:3px;
 padding-right:1px;
 padding-top:1px;
 padding-bottom:1px;
}

div#header
{
    background-color: #404040;
    top: 0px;
    left: 0px;
    width: 100%;
    padding: 0;
    margin: 0;
    color: #ffffff;
    display: flex;
    flex-direction:row;
}

#headerBlock1
{
    width: 50%;
    display:flex;
    align-items:center;
}

a#headerTitle
{
    font-size: 2.25em;
    font-family: Lobster,Tahoma,Arial;
    text-decoration: none;
    padding-left:32px;
    padding-right:32px;
}

#headerSearch
{
    display: inline-block;
    color: #000000;
    width: 300px;
}

input[type=search]#mySearch
{
    width: 100%;
    border-radius: 6px;
    border: 1px solid black;
    padding:12px;
}

#headerBlock2
{
    width: 50%;
    margin-left: auto;
    display: flex;
    justify-content: flex-end;
}


a#headerTitle:hover
{
    color : #ff8020;
}

a.headerLinks
{
    font-weight: bold;
    padding-top: 14px;
    padding-bottom: 14px;
    padding-left: 14px;
    padding-right: 14px;
    margin:0px;
    text-decoration: none;
    transition: background-color 0.15s linear, color 0.15s linear;
}

#footer
{
    background-color: rgba(64,64,64,0.25);
    color: #000000;
    padding: 0px;
    margin: 0px;
    width: 100%;
    display: flex;
    justify-content: space-between;
    flex-wrap: wrap;
}

#footer div
{
    padding-top:10px;
    padding-bottom:0px;
    padding-left:16px;
    padding-right:16px;
}

#footer div ul
{
    margin-left:0px;
    padding-left:16px;
}

#footer div ul li
{
    padding-top:6px;
}

a.regular
{
    font-weight:bold;
    text-decoration:none
}

a.regular:hover
{
  color : #ff8020;
}

a.user
{
    font-weight:bold;
    text-decoration:none;
}

a.user:hover
{
  color : #ff8020;
  text-decoration: underline;
}

.uiButton
{
    border: none;
    outline: none;
    margin: 0px;
    padding: 0px;
    width: 22px;
    height: 22px;
    position: absolute;
    cursor: pointer;
    border-radius: 4px;
}

.uiButton:hover
{
    box-shadow: inset 0px 0px 1px 1px #808080, 0px 0px 1px 1px #808080;
}

.uiDivBUtton
{
    cursor:pointer;
}

.uiDivBUtton:hover
{
    color: #ffffff;
}


.dialog
{
    display: block;
    background-color: #e0e0e0;
    color: #000000;
    border:1px solid #000;
    padding:0px;
    margin:0px;
    text-align:left;
    border-radius: 4px;
    box-shadow:4px 4px 6px 0px rgba(0,0,0,0.5);
    overflow: hidden;
    z-index:1000;
    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;
}

.dialogHeader
{
    left:0px;
    top: 0px;
    width:100%;
    height:32px;
    position: absolute;
    background-color: #808080;
    cursor:move;
}

.dialogTitle
{
    left: 12px;
    top: 4px;
    position: absolute;
    padding: 0px;
    margin: 0px;
    color:#000000;
    font-size:1.5em;
    text-align: left;
    user-select: none;
    -moz-user-select: -moz-none;
    -webkit-user-select: none;
}

.dialogOverlay
{
    z-index:1000;

    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;

    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    width:100%;
    height:100%;
    position:absolute;

    background-color:rgba(0,0,0,.4);
}

.viewsIcon, .likesIcon
{
    border: none;
    outline: none;
    display:inline-block;
    background-repeat:no-repeat;
    top:0px;
    left:0px;
    padding:0px;
    padding-right: 2px;
    margin:0px;
    position:relative;
}

.userPictureSmall
{
    background-color:#808080;
    border: 1px solid #000000;
    width:32px;
    height:32px;
}

.dialogCloseButton
{
    right:8px;
    top: 4px;
    width:22px;
    height:22px;
    position: absolute;
    background-image: url("/img/close.png");
    cursor: pointer;
    border-radius: 4px;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContentButtons
{
     padding:0;
     border:0;
     text-align: justify;
     left: 24px;
     bottom:40px;
     position:absolute;
}

.dialogButton
{
    text-align: center;
    vertical-align: middle;
    display: inline-block;
    border-radius: 4px;
    font-weight: bold;
    cursor: pointer;
    padding-bottom:5px;
    padding-top:4px;
    padding-left: 8px;
    padding-right: 8px;
    margin-left:4px;
    margin-right:4px;
    text-decoration: none;
    color:#000000;
    width: 80px;
    -moz-transition:    background-color 0.15s linear, color 0.15s linear;
    -webkit-transition: background-color 0.15s linear, color 0.15s linear;
    transition:         background-color 0.15s linear, color 0.15s linear;
}

.dialogButton:hover
{
  background-color:#808080;
  color : #ff8020;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContent
{
    color: inherit;
    overflow: auto;
    width:100%;
    height:100%;
    left: 0px;
    top: 32px;
    position:absolute
}

.dialogContentBody
{
    color: inherit;
    width:100%;
    height:auto;
    padding-top:24px;
    padding-bottom:24px;
    padding-left:24px;
    padding-right:24px;
    text-align: left;
}

.formButton
{
    font-weight:bold;
	color:#ffffff;
	border:none;
    text-align:center;
	background-color:#808080;
    border-radius: 4px;
	padding-left:8px;
	padding-right:8px;
	padding-top:4px;
	padding-bottom:4px;
    cursor:pointer;
    min-width:80px;
    box-sizing: border-box;
}
.formInput {
    border-radius: 6px;
    border: 1px solid black;
    padding: 4px;
    border: none;
}
.formButton:hover {
    background-color: #e0e0e0;
}
.formButton:disabled
{
	color:#b0b0b0;
	background-color:#808080;
}

.formButtonSmall
{
    color:#ffffff;
    border:none;
    text-align:center;
    background-color:#808080;
    border-radius: 4px;
    padding-left:2px;
    padding-right:2px;
    padding-top:2px;
    padding-bottom:2px;
    cursor:pointer;
    min-width:40px;
}

.formButtonSmall:hover
{
    background-color: #e0e0e0;
}

.formButtonSmall:disabled
{
    color:#b0b0b0;
    background-color:#808080;
}

.formButtonSmall.disabled2,
.formButton.disabled2 { color:#b0b0b0; background-color:#808080; pointer-events: none; }

.inputForm
{
    padding-left:2%;
    padding-right:2%;
    resize: none;
    text-align: left;
    background-color:#e0e0e0;
    outline: none;
    border-radius: 4px;
    border: 1px solid #808080;
    color:inherit;
    box-sizing: border-box;
}

.inputForm:focus
{
    border: 1px solid #AFCDD8;
    background-color: #EBF2F4;
}

.transparentPannel
{
    background-color:rgba(64,64,64,0.1);
    padding:16px;
}

.comment, .commentSelf, .commentNew
{
    border-radius: 4px;
    width: 100%;
    margin-left: 0px;
    margin-right: 0px;
    margin-top: 0px;
    margin-bottom: 6px;

    padding: 14px;
    box-sizing: border-box;
    display: grid;
    grid-template-columns: 32px auto 8px;
    grid-template-rows: 1fr;
    grid-gap:8px;
}

.comment:nth-child(even)
{
    background-color: rgba(64,64,64,0.1);
}

.comment:nth-child(odd)
{
    background-color: rgba(128,128,128,0.1);
}

.commentSelf
{
    background-color: rgba(240,160,64,0.1);
}

.commentNew
{
    padding-right: 0px;
    grid-template-columns: 40px auto;
}

.commentContent
{
    vertical-align: top;
    text-align: left;
    word-break: break-all;
    word-break: break-word;
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
}


/* ----------------------- media resolutions ------------------------ */

@media screen and (max-width:799px)
{
    div#header {flex-direction:column; }
    #headerBlock1 { width:100%; }
    #headerBlock2 { width:100%; justify-content: space-around;}
    div#headerSearch {width:200px;}
    input#mySearch { width:200px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:10px; }
}

@media screen and (min-width:800px) and (max-width:1279px)
{
    body { font-size: 9px; }
    div#headerSearch {width: 250px;}
    input#mySearch { width:250px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:11px; }
}

@media screen and (min-width:1280px) and (max-width:1439px)
{
    body { font-size: 10px; }
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1440px) and (max-width:1919px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1920px) and (max-width:2559px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}

@media screen and (min-width:2560px) 
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}
body
{
    background-image: url("/img/themes/classic/background.jpg");
}
</style>

    <script>"use strict"

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piCamera
//
//==============================================================================

function piCamera()
{
    var mMatrix = setIdentity();
    var mMatrixInv = setIdentity();

    var mPosition = [0.0,0.0,0.0];
    var mXRotation = 0.0;
    var mYRotation = 0.0;

    var mPositionTarget = [0.0,0.0,0.0];
    var mXRotationTarget = 0.0;
    var mYRotationTarget = 0.0;

    var me = {};
/*
    me.Set = function( pos, dir, roll) 
             {
                 mMatrix    = setLookat( pos, add(pos,dir), [Math.sin(roll),Math.cos(roll),Math.sin(roll)] );
                 mMatrixInv = invertFast( mMatrix );
             };
*/
    me.SetPos = function(pos)
                {
                    mPosition = pos;
                    //mMatrix[ 3] = -(mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                    //mMatrix[ 7] = -(mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                    //mMatrix[11] = -(mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                };
/*
    me.GlobalMove = function(pos)
                    {
                        mMatrix[ 3] -= (mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                        mMatrix[ 7] -= (mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                        mMatrix[11] -= (mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                        mMatrixInv = invertFast(mMatrix);
                    };
*/
    me.LocalMove = function( dis )
                    {
                        dis = matMulvec( setRotationY(-mYRotation), dis);
                        mPositionTarget = sub(mPositionTarget,dis)
                    };

    me.RotateXY = function( x, y)
                  {
                    mXRotationTarget -= x;
                    mYRotationTarget -= y;
                    mXRotationTarget = Math.min( Math.max( mXRotationTarget, -Math.PI/2), Math.PI/2 );
                  };


    me.CameraExectue = function( dt )
    {
        // smooth position
        mXRotation += (mXRotationTarget-mXRotation) * 12.0*dt;
        mYRotation += (mYRotationTarget-mYRotation) * 12.0*dt;
        mPosition = add(mPosition, mul( sub(mPositionTarget, mPosition), 12.0*dt));

        // Make Camera matrix
        mMatrix = matMul( matMul(setRotationX(mXRotation), 
                                 setRotationY(mYRotation)),  
                                 setTranslation(mPosition));
        mMatrixInv = invertFast(mMatrix);

    }

    me.GetMatrix = function() { return mMatrix; };
    me.GetMatrixInverse = function() { return mMatrixInv; };
    me.SetMatrix = function( mat ) 
                    {
                        mMatrix = mat;
                        mMatrixInv = invertFast(mMatrix);

                        mPosition = getXYZ(matMulpoint(mat, [0.0,0.0,0.0]));
                        mPositionTarget = mPosition;
                    };

    me.GetPos = function() { return getXYZ(matMulpoint(mMatrixInv, [0.0,0.0,0.0])); }
    me.GetDir = function() { return getXYZ(normalize(matMulvec(mMatrixInv, [0.0,0.0,-1.0]))); }

    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piFile
//
//==============================================================================

function piFile( binaryDataArrayBuffer )
{
    // private
    //var mDataView = new DataView( binaryDataArrayBuffer, 0 );
    var mDataView = binaryDataArrayBuffer;
    var mOffset = 0;

    // public members
    var me = {};
    me.mDummy = 0;
/*
    // public functions
    me.Seek = function( off ) { mOffset = off - 3; };
    me.ReadUInt16 = function()  { var res = mDataView.getUint16( mOffset ); mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = mDataView.getUint32( mOffset ); mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = mDataView.getFloat32( mOffset ); mOffset+=4; return res; };
*/

    me.Seek = function( off ) { mOffset = off; };
    me.ReadUInt8  = function()  { var res = (new Uint8Array(mDataView,mOffset))[0]; mOffset+=1; return res; };
    me.ReadUInt16 = function()  { var res = (new Uint16Array(mDataView,mOffset))[0]; mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = (new Uint32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = (new Float32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadFloat32Array = function(n) 
                          { 
                              var src = new Float32Array(mDataView, mOffset);
                              var res = [];  for( var i=0; i<n; i++ ) { res[i] = src[i]; }
                              mOffset += 4*n;
                              return res;
                          };
    me.ReadFloat32ArrayNative = function(n) { var src = new Float32Array(mDataView, mOffset); mOffset += 4*n; return src; };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piMesh
//
//==============================================================================

function piMesh()
{
    this.mChunks = [];
    this.mPrimitiveType = 0;
    this.mVertexFormat = null;
}

/*
piMesh.prototype.normalize = function( ppos, npos )
{
    var numv = this.mVertexData.length;
    var numt = this.mIndices.length;

    for( var i=0; i<numv; i++ )
    {
        //float *v = (float*)piMesh_GetVertexData( me, i, npos );
        //v[0] = 0.0f;
        //v[1] = 0.0f;
        //v[2] = 0.0f;
        this.mVerts[8 * i + 3] = 0.0;
        this.mVerts[8 * i + 4] = 0.0;
        this.mVerts[8 * i + 5] = 0.0;
    }

    for( var i=0; i<numt; i++ )
    {
        piMeshFace *face = me->mFaceData.mIndexArray[0].mBuffer + i;

        const int ft = face->mNum;
        
        vec3 nor = vec3( 0.0f, 0.0f, 0.0f );
        for( int j=0; j<ft; j++ )
        {
            const vec3 va = *((vec3*)piMesh_GetVertexData( me, face->mIndex[ j      ], ppos ));
            const vec3 vb = *((vec3*)piMesh_GetVertexData( me, face->mIndex[(j+1)%ft], ppos ));

            nor += cross( va, vb );
        }

        for( int j=0; j<ft; j++ )
        {
            vec3 *n = (vec3*)piMesh_GetVertexData( me, face->mIndex[j], npos );
            n->x += nor.x;
            n->y += nor.y;
            n->z += nor.z;
        }
    }

    for( var i=0; i<numv; i++ )
    {
        vec3 *v = (vec3*)piMesh_GetVertexData( me, i, npos );
        *v = normalize( *v );
    }
}
*/

piMesh.prototype.createCube = function(renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([ -1.0, -1.0, -1.0,
                                       1.0, -1.0, -1.0,
                                      -1.0,  1.0, -1.0,
                                       1.0,  1.0, -1.0,
                                      -1.0, -1.0,  1.0,
                                       1.0, -1.0,  1.0,
                                      -1.0,  1.0,  1.0,
                                       1.0,  1.0,  1.0 ]),

                        mIndices : new Uint16Array([ 0, 2, 1,   1, 2, 3,   5, 1, 3,   5, 3, 7,   4, 5, 7,   4, 7, 6,   4, 6, 2,   4, 2, 0,   6, 7, 3,   6, 3, 2,   4, 0, 1,   4, 1, 5 ]),
                        mNumVertices : 8,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };

    this.mVertexFormat = { mStride:12, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}

piMesh.prototype.createCubeSharp = function (renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 1.0,
                                    -1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 0.0,

                                     1.0, 1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 0.0,

                                     1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 1.0,
                                    -1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   1.0, 1.0,
                                     1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   1.0, 0.0,

                                    -1.0, 1.0, 1.0,  -1.0, 0.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0,-1.0,  -1.0, 0.0, 0.0,   0.0, 1.0,
                                    -1.0,-1.0,-1.0,  -1.0, 0.0, 0.0,   1.0, 1.0,
                                    -1.0,-1.0, 1.0,  -1.0, 0.0, 0.0,   1.0, 0.0 ]),

                        mIndices : new Uint16Array([0,1,2, 0,2,3,   4,5,6, 4,6,7,    8,9,10,8,10,11,   12,13,14,12,14,15,   16,17,18,16,18,19,   20,21,22,20,22,23]),
                        mNumVertices : 24,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };


    this.mVertexFormat = { mStride:32, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}


piMesh.prototype.createUnitQuad = function (renderer)
{
    this.mPrimitiveType = 0;
    this.mVertexFormat = { mStride:8, mChannels: [ {mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false} ] };

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0,  1.0, 1.0,  1.0]),
                        mIndices : new Uint16Array([0, 2, 1, 1, 2, 3]),
                        mNumVertices : 4,
                        mNumFaces : 2, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };
 
    return true;
}




piMesh.prototype.destroy = function()
{
    //delete this.mVerts;   this.mVerts = null;
    //delete this.mIndices; this.mIndices = null;
}

piMesh.prototype.scale = function (x, y, z)
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] *= x;
            this.mChunks[j].mVerts[stride * i + 1] *= y;
            this.mChunks[j].mVerts[stride * i + 2] *= z;
        }
    }
}

piMesh.prototype.translate = function (x, y, z) 
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] += x;
            this.mChunks[j].mVerts[stride * i + 1] += y;
            this.mChunks[j].mVerts[stride * i + 2] += z;
        }
    }
}

piMesh.prototype.GPULoad = function (renderer)
{
    for( var i=0; i<this.mChunks.length; i++ )
    {
        var vbo = renderer.CreateVertexArray(this.mChunks[i].mVerts, renderer.BUFTYPE.STATIC );
        if (vbo == null)
            return false;

        var ibo = renderer.CreateIndexArray(this.mChunks[i].mIndices, renderer.BUFTYPE.STATIC);
        if (ibo == null)
            return false;

        this.mChunks[i].mVBO = vbo;
        this.mChunks[i].mIBO = ibo;
    }
    return true;
}

piMesh.prototype.GPURender = function (renderer, positions )//, matPrj, matCam )
{
    //renderer.SetShaderConstantMat4F("unMPrj", matPrj, false );

    var num = this.mChunks.length;
    for( var i=0; i<num; i++ )
    {
        //var mat =  matMul( matCam, this.mChunks[i].mTransform );
        //renderer.SetShaderConstantMat4F("unMMod", mat, false);

        renderer.AttachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat, positions );
        renderer.AttachIndexArray(this.mChunks[i].mIBO );
        renderer.DrawPrimitive(renderer.PRIMTYPE.TRIANGLES, this.mChunks[i].mNumFaces * 3, true, 1);
        renderer.DetachIndexArray(this.mChunks[i].mIBO);
        renderer.DetachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat );
    }
}
//==============================================================================
//
// piLibs 2014-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piRenderer
//
//==============================================================================

function piRenderer()
{
    // private members

    var mGL = null;
    var mBindedShader = null;
    var mIs20 = false;
    var mFloat32Textures;
    var mFloat32Filter;
    var mFloat16Textures;
    var mDrawBuffers;
    var mDepthTextures;
    var mDerivatives;
    var mFloat16Filter;
    var mShaderTextureLOD;
    var mAnisotropic;
    var mRenderToFloat32F;
    var mDebugShader;
    var mAsynchCompile;

    var mVBO_Quad = null;
    var mVBO_Tri = null;
    var mVBO_CubePosNor = null;
    var mVBO_CubePos = null;
    var mShaderHeader = ["",""];
    var mShaderHeaderLines = [0,0];

    // public members
    var me = {};

    me.CLEAR      = { Color: 1, Zbuffer : 2, Stencil : 4 };
    me.TEXFMT     = { C4I8 : 0, C1I8 : 1, C1F16 : 2, C4F16 : 3, C1F32 : 4, C4F32 : 5, Z16 : 6, Z24 : 7, Z32 : 8, C3F32:9 };
    me.TEXWRP     = { CLAMP : 0, REPEAT : 1 };
    me.BUFTYPE    = { STATIC : 0, DYNAMIC : 1 };
    me.PRIMTYPE   = { POINTS : 0, LINES : 1, LINE_LOOP : 2, LINE_STRIP : 3, TRIANGLES : 4, TRIANGLE_STRIP : 5 };
    me.RENDSTGATE = { WIREFRAME : 0, FRONT_FACE : 1, CULL_FACE : 2, DEPTH_TEST : 3, ALPHA_TO_COVERAGE : 4 };
    me.TEXTYPE    = { T2D : 0, T3D : 1, CUBEMAP : 2 };
    me.FILTER     = { NONE : 0, LINEAR : 1, MIPMAP : 2, NONE_MIPMAP : 3 };
    me.TYPE       = { UINT8 : 0, UINT16 : 1, UINT32 : 2, FLOAT16: 3, FLOAT32 : 4, FLOAT64: 5 };

    // private functions

    var iFormatPI2GL = function( format )
    {
        if( mIs20 )
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA8,           mGLExternal: mGL.RGBA,             mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.R8,              mGLExternal: mGL.RED,              mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.R16F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA16F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.R32F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA32F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C3F32) return { mGLFormat: mGL.RGB32F,          mGLExternal: mGL.RGB,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT16, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z24)   return { mGLFormat: mGL.DEPTH_COMPONENT24, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z32)   return { mGLFormat: mGL.DEPTH_COMPONENT32F, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        }
        else
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.RED,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT, mGLExternal: mGL.DEPTH_COMPONENT, mGLType: mGL.UNSIGNED_SHORT }
        }

        return null;
     }

    // public functions

    me.Initialize = function( gl )
                    {
                        mGL = gl;

                        mIs20 = !(gl instanceof WebGLRenderingContext);

                        if( mIs20 )
                        {
                            mFloat32Textures  = true;
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = true;
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = true;
                            mDrawBuffers      = true;
                            mDepthTextures    = true;
                            mShaderTextureLOD = true;
                            mAnisotropic = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mGL.getExtension( 'EXT_color_buffer_float');
                            mDebugShader = mGL.getExtension('WEBGL_debug_shaders');
                            mAsynchCompile = mGL.getExtension('KHR_parallel_shader_compile');

							mGL.hint( mGL.FRAGMENT_SHADER_DERIVATIVE_HINT, mGL.NICEST);
                        }
                        else
                        {
                            mFloat32Textures  = mGL.getExtension( 'OES_texture_float' );
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = mGL.getExtension( 'OES_texture_half_float' );
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = mGL.getExtension( 'OES_standard_derivatives' );
                            mDrawBuffers      = mGL.getExtension( 'WEBGL_draw_buffers' );
                            mDepthTextures    = mGL.getExtension( 'WEBGL_depth_texture' );
                            mShaderTextureLOD = mGL.getExtension( 'EXT_shader_texture_lod' );
                            mAnisotropic      = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mFloat32Textures;
                            mDebugShader      = null;
                            mAsynchCompile    = null;
							
							if( mDerivatives !== null) mGL.hint( mDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, mGL.NICEST);
                        }
                        
                        
                        var maxTexSize = mGL.getParameter( mGL.MAX_TEXTURE_SIZE );
                        var maxCubeSize = mGL.getParameter( mGL.MAX_CUBE_MAP_TEXTURE_SIZE );
                        var maxRenderbufferSize = mGL.getParameter( mGL.MAX_RENDERBUFFER_SIZE );
                        var extensions = mGL.getSupportedExtensions();
                        var textureUnits = mGL.getParameter( mGL.MAX_TEXTURE_IMAGE_UNITS );
                        console.log("WebGL (2.0=" + mIs20 + "):" +
                                    " Asynch Compile: "  + ((mAsynchCompile !==null) ? "yes" : "no") +
                                    ", Textures: F32 ["   + ((mFloat32Textures !==null) ? "yes" : "no") +
                                    "], F16 ["   + ((mFloat16Textures !==null) ? "yes" : "no") +
                                    "], Depth [" + ((mDepthTextures   !==null) ? "yes" : "no") +
                                    "], LOD ["    + ((mShaderTextureLOD!==null) ? "yes" : "no") +
                                    "], Aniso ["   + ((mAnisotropic     !==null) ? "yes" : "no") +
                                    "], Units [" + textureUnits +
                                    "], Max Size [" + maxTexSize +
                                    "], Cube Max Size [" + maxCubeSize +
                                    "], Targets: MRT ["            + ((mDrawBuffers     !==null) ? "yes" : "no") +
                                    "], F32 ["     + ((mRenderToFloat32F!==null) ? "yes" : "no") +
                                    "], Max Size [" + maxRenderbufferSize + "]");

                        // create a 2D quad Vertex Buffer
                        var vertices = new Float32Array( [ -1.0, -1.0,   1.0, -1.0,    -1.0,  1.0,     1.0, -1.0,    1.0,  1.0,    -1.0,  1.0] );
                        mVBO_Quad = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                        mGL.bufferData( mGL.ARRAY_BUFFER, vertices, mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 2D triangle Vertex Buffer
                        mVBO_Tri = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0,   3.0, -1.0,    -1.0,  3.0] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePosNor = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0, -1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                               1.0,  1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                               1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                               1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                               1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0,  1.0, -1.0,   0.0,  0.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePos = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0,  1.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        //-------------------------------------------------------------------

                        mShaderHeader[0] = "";
                        mShaderHeaderLines[0] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[0] += "#version 300 es\n" +
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[0] += 6;
                        }
                        else
                        {
                            mShaderHeader[0] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "#endif\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+                                                
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[0] += 26;
                        }

                        //-------------------------------------------------------

                        mShaderHeader[1] = "";
                        mShaderHeaderLines[1] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[1] += "#version 300 es\n"+
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[1] += 6;
                        }
                        else
                        {
                            if( mDerivatives ) { mShaderHeader[1] += "#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n"; mShaderHeaderLines[1]+=3; }
                            if( mShaderTextureLOD  ) { mShaderHeader[1] += "#extension GL_EXT_shader_texture_lod : enable\n"; mShaderHeaderLines[1]++; }
                            mShaderHeader[1] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "#endif\n"+ 
                                                "vec4 texture(     sampler2D   s, vec2 c)                   { return texture2D(s,c); }\n"+
                                                "vec4 texture(     sampler2D   s, vec2 c, float b)          { return texture2D(s,c,b); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c )                  { return textureCube(s,c); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c, float b)          { return textureCube(s,c,b); }\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[1] += 30;
                            if( mShaderTextureLOD )
                            {
                            mShaderHeader[1] += "vec4 textureLod(  sampler2D   s, vec2 c, float b)          { return texture2DLodEXT(s,c,b); }\n";
                            mShaderHeader[1] += "vec4 textureGrad( sampler2D   s, vec2 c, vec2 dx, vec2 dy) { return texture2DGradEXT(s,c,dx,dy); }\n";
                            mShaderHeaderLines[1] += 2;

                            //mShaderHeader[1] += "vec4 texelFetch( sampler2D s, ivec2 c, int l) { return texture2DLodEXT(s,(vec2(c)+0.5)/vec2(800,450),float(l)); }\n";
                            //mShaderHeaderLines[1] += 1;
                            }
                        }

                        return true;
                    };

        me.GetCaps =    function ()
                        {   
                            return { mIsGL20 : mIs20,
                                     mFloat32Textures: mFloat32Textures != null,
                                     mFloat16Textures: mFloat16Textures != null,
                                     mDrawBuffers: mDrawBuffers != null,
                                     mDepthTextures: mDepthTextures != null,
                                     mDerivatives: mDerivatives != null,
                                     mShaderTextureLOD: mShaderTextureLOD != null };
                        };

        me.GetShaderHeaderLines = function (shaderType)
                        {   
                            return mShaderHeaderLines[shaderType];
                        };

        me.CheckErrors = function()
                         {
                                var error = mGL.getError();
                                if( error != mGL.NO_ERROR ) 
                                { 
                                    for( var prop in mGL ) 
                                    {
                                        if( typeof mGL[prop] == 'number' ) 
                                        {
                                            if( mGL[prop] == error )
                                            {
                                                console.log( "GL Error " + error + ": " + prop );
                                                break;
                                            }
                                        }
                                    }
                                }
                         };

        me.Clear =  function( flags, ccolor, cdepth, cstencil )
                    {
                        var mode = 0;
                        if( flags & 1 ) { mode |= mGL.COLOR_BUFFER_BIT;   mGL.clearColor( ccolor[0], ccolor[1], ccolor[2], ccolor[3] ); }
                        if( flags & 2 ) { mode |= mGL.DEPTH_BUFFER_BIT;   mGL.clearDepth( cdepth ); }
                        if( flags & 4 ) { mode |= mGL.STENCIL_BUFFER_BIT; mGL.clearStencil( cstencil ); }
                        mGL.clear( mode );
                    };


        me.CreateTexture = function ( type, xres, yres, format, filter, wrap, buffer)
                           {
                                if( mGL===null ) return null;

                                var id = mGL.createTexture();

                                var glFoTy = iFormatPI2GL( format );
                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                if( type===me.TEXTYPE.T2D )
                                {
                                    mGL.bindTexture( mGL.TEXTURE_2D, id );
//if( buffer==null )
    //mGL.texStorage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres);
//else
                                    mGL.texImage2D( mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap );

                                    if (filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                }
                                else if( type===me.TEXTYPE.T3D )
                                {
                                    if( mIs20 )
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_3D, id );
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_BASE_LEVEL, 0);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAX_LEVEL, Math.log2(xres));
                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_3D);
                                        }
                                        mGL.texImage3D( mGL.TEXTURE_3D, 0, glFoTy.mGLFormat, xres, yres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap );

                                        if (filter === me.FILTER.MIPMAP)
                                            mGL.generateMipmap( mGL.TEXTURE_3D );
                                        mGL.bindTexture( mGL.TEXTURE_3D, null );
                                    }
                                    else 
                                    {
                                        return null;
                                    }
                                }
                                else 
                                {
                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );

                                    // this works great if we know the number of required mipmaps in advance (1, or other)
                                   //mGL.texStorage2D( mGL.TEXTURE_CUBE_MAP, 1, glFoTy.mGLFormat, xres, yres );

                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                    if( filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                    }

                                    if (filter === me.FILTER.MIPMAP)
                                        mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );

                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                }
                        return { mObjectID: id, mXres: xres, mYres: yres, mFormat: format, mType: type, mFilter: filter, mWrap: wrap, mVFlip:false };
                        };

        me.CreateTextureFromImage = function ( type, image, format, filter, wrap, flipY) 
                                {
                                    if( mGL===null ) return null;

                                    var id = mGL.createTexture();

                                    var glFoTy = iFormatPI2GL( format );

                                    var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                    if( type===me.TEXTYPE.T2D )
                                    {
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);

                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.pixelStorei(mGL.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                                        if( mIs20 ) mGL.pixelStorei(mGL.UNPACK_COLORSPACE_CONVERSION_WEBGL, mGL.NONE );

                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);

                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);

                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if( filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                    }
                                    else if( type===me.TEXTYPE.T3D )
                                    {
                                        return null;
                                    }
                                    else 
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );

                                        if( filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                    }
                                    return { mObjectID: id, mXres: image.width, mYres: image.height, mFormat: format, mType: type, mFilter: filter, mWrap:wrap, mVFlip:flipY };
                                };

        me.SetSamplerFilter = function (te, filter, doGenerateMipsIfNeeded) 
                            {
                                if (te.mFilter === filter) return;

                                if (te.mType === me.TEXTYPE.T2D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_3D, null);

                                }
                                else
                                {
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }


                                te.mFilter = filter;
                            };

        me.SetSamplerWrap = function (te, wrap)
                            {
                                if (te.mWrap === wrap) return;

                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, id);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, id);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_3D, null);
                                }

                                te.mWrap = wrap;
                            };

        me.SetSamplerVFlip = function (te, vflip, image)
                            {
                                if (te.mVFlip === vflip) return;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    if( image != null)
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                }
                                else if (te.mType === me.TEXTYPE.CUBEMAP)
                                {
                                    if( image != null)
                                    {
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei( mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
        
                                }

                                te.mVFlip = vflip;
                            };

        me.CreateMipmaps =  function (te)
                            {
                                if( te.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);
                                    mGL.generateMipmap(mGL.TEXTURE_2D);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);
                                }
                                else if( te.mType===me.TEXTYPE.CUBEMAP )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);
                                    mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }
                            };

        me.UpdateTexture =  function( tex, x0, y0, xres, yres, buffer )
                            {
                                var glFoTy = iFormatPI2GL( tex.mFormat );
                                if( tex.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture( mGL.TEXTURE0);
                                    mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                    mGL.texSubImage2D( mGL.TEXTURE_2D, 0, x0, y0, xres, yres, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                }
                            };

        me.UpdateTextureFromImage = function( tex, image )
                                {
                                    var glFoTy = iFormatPI2GL( tex.mFormat );
                                    if( tex.mType===me.TEXTYPE.T2D )
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                        mGL.texImage2D(  mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image );
                                        mGL.bindTexture( mGL.TEXTURE_2D, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                };

        me.DestroyTexture = function( te )
                            {
                                 mGL.deleteTexture( te.mObjectID );
                            };

        me.AttachTextures = function (num, t0, t1, t2, t3) 
                            {
                                if (num > 0 && t0 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                         if (t0.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t0.mObjectID);
                                }

                                if (num > 1 && t1 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE1);
                                         if (t1.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t1.mObjectID);
                                }

                                if (num > 2 && t2 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE2);
                                         if (t2.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t2.mObjectID);
                                }

                                if (num > 3 && t3 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE3);
                                         if (t3.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t3.mObjectID);
                                }
                            };

        me.DettachTextures = function()
                             {
                                mGL.activeTexture(mGL.TEXTURE0);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE1);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE2);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE3);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                             };

        me.CreateRenderTarget = function ( color0, color1, color2, color3, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);

                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_2D, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.DestroyRenderTarget = function ( tex )
                                 {
                                     mGL.deleteFramebuffer(tex.mObjectID);
                                 };

        me.SetRenderTarget = function (tex)
                             {
                                if( tex===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, tex.mObjectID);

                                //mGL.drawBuffers([mGL.COLOR_ATTACHMENT0, mGL.COLOR_ATTACHMENT1]);
                             };

        me.CreateRenderTargetNew = function ( wantColor0, wantZbuffer, xres, yres, samples )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if( wantZbuffer===true )
                                    {
                                        var zb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);

                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.DEPTH_COMPONENT16, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                    }

                                    if( wantColor0 )
                                    {
                                        var cb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, cb);
                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.RGBA8, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.RGBA8, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.RENDERBUFFER, cb);
                                    }

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                    {
                                        return null;
                                    }
                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mXres: xres, mYres:yres, mTex0: color0 };
                                };

        me.CreateRenderTargetCubeMap = function ( color0, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);
                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.SetRenderTargetCubeMap = function (fbo, face)
                             {
                                if( fbo===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                {
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, fbo.mObjectID);
                                    mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X+face, fbo.mTex0.mObjectID, 0);
                                }
                             };


        me.BlitRenderTarget = function( dst, src )
                                {
                                    mGL.bindFramebuffer(mGL.READ_FRAMEBUFFER, src.mObjectID);
                                    mGL.bindFramebuffer(mGL.DRAW_FRAMEBUFFER, dst.mObjectID);
                                    mGL.clearBufferfv(mGL.COLOR, 0, [0.0, 0.0, 0.0, 1.0]);
                                    mGL.blitFramebuffer( 0, 0, src.mXres, src.mYres,
                                                         0, 0, src.mXres, src.mYres,
                                                         mGL.COLOR_BUFFER_BIT, mGL.LINEAR
                                    );
                                };

        me.SetViewport = function( vp )
                         {
                              mGL.viewport( vp[0], vp[1], vp[2], vp[3] );
                         };

        me.SetWriteMask = function( c0, c1, c2, c3, z )
                          {
                              mGL.depthMask(z);
                              mGL.colorMask(c0,c0,c0,c0);
                          };

        me.SetState = function( stateName, stateValue )
                      {
                            if (stateName === me.RENDSTGATE.WIREFRAME)
                            {
                                if( stateValue ) mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.LINE );
                                else             mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.FILL );
                            }
                            else if (stateName === me.RENDSTGATE.FRONT_FACE)
                            {
                                if( stateValue ) mGL.cullFace( mGL.BACK );
                                else             mGL.cullFace( mGL.FRONT );
                            }
                            else if (stateName === me.RENDSTGATE.CULL_FACE)
                            {
                                if( stateValue ) mGL.enable( mGL.CULL_FACE );
                                else             mGL.disable( mGL.CULL_FACE );
                            }
                            else if (stateName === me.RENDSTGATE.DEPTH_TEST)
                            {
                                if( stateValue ) mGL.enable( mGL.DEPTH_TEST );
                                else             mGL.disable( mGL.DEPTH_TEST );
                            }
                            else if (stateName === me.RENDSTGATE.ALPHA_TO_COVERAGE)
                            {
                                if( stateValue ) { mGL.enable(  mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                                else             { mGL.disable( mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                            }
                      };

        me.SetMultisample = function( v)
                    {
                        if( v===true )
                        {
                            mGL.enable(mGL.SAMPLE_COVERAGE);
                            mGL.sampleCoverage(1.0, false);
                        }
                        else
                        {
                            mGL.disable(mGL.SAMPLE_COVERAGE);
                        }
                    };

        me.GetTranslatedShaderSource = function (shader) 
                          {
                            if( mGL===null ) return null;
                            if( mDebugShader===null ) return null;
                            let vfs = mGL.getAttachedShaders(shader.mProgram);
                            let str = mDebugShader.getTranslatedShaderSource(vfs[1]);
                            let parts = str.split("GLSL END"); str = (parts.length<2) ? str : parts[1];
                            return str;
                          };

        me.CreateShader = function (vsSource, fsSource, preventCache, forceSynch, onResolve) 
                          {
                            if( mGL===null ) return;

                            var vs = mGL.createShader( mGL.VERTEX_SHADER   );
                            var fs = mGL.createShader( mGL.FRAGMENT_SHADER );

                            vsSource = mShaderHeader[0] + vsSource;
                            fsSource = mShaderHeader[1] + fsSource;

                            if( preventCache )
                            {
                                let vran = Math.random().toString(36).substring(7);
                                let fran = Math.random().toString(36).substring(7);
                                vsSource += "\n#define K" + vran + "\n";
                                fsSource += "\n#define K" + fran + "\n";
                            }

                            var timeStart = getRealTime();

                            mGL.shaderSource(vs, vsSource);
                            mGL.shaderSource(fs, fsSource);
                            mGL.compileShader(vs);
                            mGL.compileShader(fs);

                            var pr = mGL.createProgram();
                            mGL.attachShader(pr, vs);
                            mGL.attachShader(pr, fs);
                            mGL.linkProgram(pr);

                            //-------------
                            let checkErrors = function()
                            {
                                if (!mGL.getProgramParameter(pr, mGL.LINK_STATUS))
                                {
                                    // vs error
                                    if (!mGL.getShaderParameter(vs, mGL.COMPILE_STATUS))
                                    {
                                        let vsLog = mGL.getShaderInfoLog(vs);
                                        onResolve(false, { mErrorType: 0, mErrorStr: vsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // fs error
                                    else if (!mGL.getShaderParameter(fs, mGL.COMPILE_STATUS))
                                    {
                                        let fsLog = mGL.getShaderInfoLog(fs);
                                        onResolve(false, { mErrorType: 1, mErrorStr: fsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // link error
                                    else
                                    {
                                        let infoLog = mGL.getProgramInfoLog(pr);
                                        onResolve(false, { mErrorType: 2, mErrorStr: infoLog });
                                        mGL.deleteProgram(pr);
                                    }
                                }
                                // no errors
                                else
                                {
                                    let compilationTime = getRealTime() - timeStart;
                                    onResolve(true, { mProgram: pr, mTime: compilationTime });
                                }
                            };

                            // check compilation
                            if (mAsynchCompile === null || forceSynch===true )
                            {
                                checkErrors();
                            }
                            else
                            {
                                let loopCheckCompletion = function ()
                                {
                                    if( mGL.getProgramParameter(pr, mAsynchCompile.COMPLETION_STATUS_KHR) === true )
                                        checkErrors();
                                    else
                                        setTimeout(loopCheckCompletion, 10);
                                };
                                setTimeout(loopCheckCompletion, 10);
                            }
                        };

        me.AttachShader = function( shader )
                          {
                                if( shader===null )
                                {
                                    mBindedShader = null;
                                    mGL.useProgram( null );
                                }
                                else
                                {
                                    mBindedShader = shader;
                                    mGL.useProgram(shader.mProgram);
                                }
                          };

        me.DetachShader = function ()
                        {
                            mGL.useProgram(null);
                        };

        me.DestroyShader = function( tex )
                        {
                            mGL.deleteProgram(tex.mProgram);
                        };

        me.GetAttribLocation = function (shader, name)
                        {
                            return mGL.getAttribLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantLocation = function (shader, name)
                        {
                            return mGL.getUniformLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantMat4F = function( uname, params, istranspose )
                        {
                            var program = mBindedShader;

                            let pos = mGL.getUniformLocation( program.mProgram, uname );
                            if( pos===null )
                                return false;

                            if( istranspose===false )
                            {
                                var tmp = new Float32Array( [ params[0], params[4], params[ 8], params[12],
                                                              params[1], params[5], params[ 9], params[13],
                                                              params[2], params[6], params[10], params[14],
                                                              params[3], params[7], params[11], params[15] ] );
	                            mGL.uniformMatrix4fv(pos,false,tmp);
                            }
                            else
                                mGL.uniformMatrix4fv(pos,false,new Float32Array(params) );
                            return true;
                        };

        me.SetShaderConstant1F_Pos = function(pos, x)
                        {
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1FV_Pos = function(pos, x)
                        {
                            mGL.uniform1fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant1F = function( uname, x )
                        {
                            var pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1I = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1i(pos, x);
                            return true;
                        };
        me.SetShaderConstant1I_Pos = function(pos, x)
                        {
                            mGL.uniform1i(pos, x);
                            return true;
                        };


        me.SetShaderConstant2F = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform2fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant3F = function(uname, x, y, z)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform3f(pos, x, y, z);
                            return true;
                        };

        me.SetShaderConstant1FV = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1fv(pos, new Float32Array(x));
                            return true;
                        };

        me.SetShaderConstant3FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform3fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderConstant4FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform4fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderTextureUnit = function( uname, unit )
                        {
                            var program = mBindedShader;
                            let pos = mGL.getUniformLocation(program.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform1i(pos, unit);
                            return true;
                        };

        me.CreateVertexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, id);
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.CreateIndexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, id );
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.DestroyArray = function( tex )
                        {
                            mGL.destroyBuffer(tex.mObject);
                        };

        me.AttachVertexArray = function( tex, attribs, pos )
                        {
                            let shader = mBindedShader;

                            mGL.bindBuffer( mGL.ARRAY_BUFFER, tex.mObject);

                            var num = attribs.mChannels.length;
                            var stride = attribs.mStride;

                            var offset = 0;
                            for (var i = 0; i < num; i++)
                            {
                                var id = pos[i];
                                mGL.enableVertexAttribArray(id);
                                var dtype = mGL.FLOAT;
                                var dsize = 4;
                                     if( attribs.mChannels[i].mType === me.TYPE.UINT8   ) { dtype = mGL.UNSIGNED_BYTE;  dsize = 1; }
                                else if( attribs.mChannels[i].mType === me.TYPE.UINT16  ) { dtype = mGL.UNSIGNED_SHORT; dsize = 2; }
                                else if( attribs.mChannels[i].mType === me.TYPE.FLOAT32 ) { dtype = mGL.FLOAT;          dsize = 4; }
                                mGL.vertexAttribPointer(id, attribs.mChannels[i].mNumComponents, dtype, attribs.mChannels[i].mNormalize, stride, offset);
                                offset += attribs.mChannels[i].mNumComponents * dsize;
                            }
                        };

        me.AttachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, tex.mObject);
                        };

        me.DetachVertexArray = function (tex, attribs)
                        {
                            let num = attribs.mChannels.length;
                            for (let i = 0; i < num; i++)
                                mGL.disableVertexAttribArray(i);
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, null);
                        };

        me.DetachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, null);
                        };

        me.DrawPrimitive = function( typeOfPrimitive, num, useIndexArray, numInstances )
                        {
                            let glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.POINTS ) glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.LINES ) glType = mGL.LINES;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_LOOP ) glType = mGL.LINE_LOOP;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_STRIP ) glType = mGL.LINE_STRIP;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLES ) glType = mGL.TRIANGLES;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLE_STRIP ) glType = mGL.TRIANGLE_STRIP;

                            if( numInstances<=1 )
                            {
  	                            if( useIndexArray ) mGL.drawElements( glType, num, mGL.UNSIGNED_SHORT, 0 );
	                            else                mGL.drawArrays( glType, 0, num );
                            }
                            else
                            {
                                mGL.drawArraysInstanced(glType, 0, num, numInstances);
                                mGL.drawElementsInstanced( glType, num, mGL.UNSIGNED_SHORT, 0, numInstances);
                            }
                        };


        me.DrawFullScreenTriangle_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 3 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };


        me.DrawUnitQuad_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 6 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };

        me.DrawUnitCube_XYZ_NOR = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                            mGL.vertexAttribPointer( vpos[0], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.vertexAttribPointer( vpos[1], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos[0] );
                            mGL.enableVertexAttribArray( vpos[1] );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos[0] );
                            mGL.disableVertexAttribArray( vpos[1] );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.DrawUnitCube_XYZ = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                            mGL.vertexAttribPointer( vpos, 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.SetBlend = function( enabled )
                    {
                        if( enabled )
                        {
                            mGL.enable( mGL.BLEND );
                            mGL.blendEquationSeparate( mGL.FUNC_ADD, mGL.FUNC_ADD );
                            mGL.blendFuncSeparate( mGL.SRC_ALPHA, mGL.ONE_MINUS_SRC_ALPHA, mGL.ONE, mGL.ONE_MINUS_SRC_ALPHA );
                        }
                        else
                        {
                            mGL.disable( mGL.BLEND );
                        }
                    };

        me.GetPixelData = function( data, offset, xres, yres )
                        {
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.UNSIGNED_BYTE, data, offset);
                        };

        me.GetPixelDataRenderTarget = function( obj, data, xres, yres )
                        {
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, obj.mObjectID);
                            mGL.readBuffer(mGL.COLOR_ATTACHMENT0);
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.FLOAT, data, 0);
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                        };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piShading
//
//==============================================================================

function smoothstep(a, b, x)
{
    x = (x - a) / (b - a);
    if (x < 0) x = 0; else if (x > 1) x = 1;
    return x * x * (3.0 - 2.0 * x);
}

function clamp01(x)
{
    if( x < 0.0 ) x = 0.0;
    if( x > 1.0 ) x = 1.0;
    return x;
}

function clamp(x, a, b)
{
    if( x < a ) x = a;
    if( x > b ) x = b;
    return x;
}

function screen(a, b)
{
    return 1.0 - (1.0 - a) * (1.0 - b);
}

function parabola(x)
{
    return 4.0 * x * (1.0 - x);
}

function min(a, b)
{
    return (a < b) ? a : b;
}

function max(a, b)
{
    return (a > b) ? a : b;
}

function noise( x )
{
    function grad(i, j, x, y)
    {
        var h = 7 * i + 131 * j;
        h = (h << 13) ^ h;
        h = (h * (h * h * 15731 + 789221) + 1376312589);

        var rx = (h & 0x20000000) ? x : -x;
        var ry = (h & 0x10000000) ? y : -y;

        return rx + ry;
    }

    var i = [ Math.floor(x[0]), Math.floor(x[1]) ];
    var f = [ x[0] - i[0], x[1] - i[1] ];
    var w = [ f[0]*f[0]*(3.0-2.0*f[0]), f[1]*f[1]*(3.0-2.0*f[1]) ];

    var a = grad( i[0]+0, i[1]+0, f[0]+0.0, f[1]+0.0 );
    var b = grad( i[0]+1, i[1]+0, f[0]-1.0, f[1]+0.0 );
    var c = grad( i[0]+0, i[1]+1, f[0]+0.0, f[1]-1.0 );
    var d = grad( i[0]+1, i[1]+1, f[0]-1.0, f[1]-1.0 );

    return a + (b-a)*w[0] + (c-a)*w[1] + (a-b-c+d)*w[0]*w[1];
}//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piVecTypes
//
//==============================================================================


function vec3( a, b, c )
{
    return [ a, b, c ];
}

function add( a, b )
{
    return [ a[0]+b[0], a[1]+b[1], a[2]+b[2] ];
}

function sub( a, b )
{
    return [ a[0]-b[0], a[1]-b[1], a[2]-b[2] ];
}

function mul( a, s ) 
{
    return [ a[0]*s, a[1]*s, a[2]*s ];
}

function cross( a, b )
{
    return [ a[1]*b[2] - a[2]*b[1],
             a[2]*b[0] - a[0]*b[2],
             a[0]*b[1] - a[1]*b[0] ];
}

function dot( a, b ) 
{
    return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
}

function normalize( v ) 
{
    var is = 1.0 / Math.sqrt( v[0]*v[0] + v[1]*v[1] + v[2]*v[2] );
    return [ v[0]*is, v[1]*is, v[2]*is ];
}

function createCirclePoint( cen, uuu, vvv, rad, s, t )
{
    return [ cen[0] + rad*(uuu[0]*s + vvv[0]*t),
             cen[1] + rad*(uuu[1]*s + vvv[1]*t),
             cen[2] + rad*(uuu[2]*s + vvv[2]*t) ];
}

function createTangent( a, b, c )
{
    var cb = normalize( [ c[0]-b[0], c[1]-b[1], c[2]-b[2] ] );
    var ba = normalize( [ b[0]-a[0], b[1]-a[1], b[2]-a[2] ] );
    return normalize( [ ba[0]+cb[0], ba[1]+cb[1], ba[2]+cb[2] ] );

}

//===================================

function vec4( a, b, c, d )
{
    return [ a, b, c, d ];
}

function getXYZ( v )
{
    return [ v[0], v[1], v[2] ];
}

//===================================

function setIdentity()
{
    return [ 1.0, 0.0, 0.0, 0.0,
             0.0, 1.0, 0.0, 0.0,
             0.0, 0.0, 1.0, 0.0,
             0.0, 0.0, 0.0, 1.0 ];
}

function setRotationX( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ 1.0,   0.0,   0.0, 0.0,
             0.0,  cost, -sint, 0.0, 
             0.0,  sint,  cost, 0.0,
             0.0,   0.0,   0.0, 1.0 ];
}

function setRotationY( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ cost, 0.0, -sint, 0.0,
              0.0, 1.0,   0.0, 0.0, 
             sint, 0.0,  cost, 0.0,
              0.0, 0.0,   0.0, 1.0 ];
}

function extractRotationEuler( m)
{
    var res = [];
    if (m[0] == 1.0)
    {
        res[0] = Math.atan2(m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;

    }
    else if (m[0] == -1.0)
    {
        res[0] = Math.atan2( m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;
    }
    else
    {
        res[0] = Math.atan2( -m[9], m[10]);
        res[1] = Math.atan2( m[8], Math.sqrt(m[9]*m[9] + m[10]*m[10]));
        res[2] = Math.atan2( m[4], m[0]);
    }
    return res;
}

function setFromQuaternion( q )
{
    var ww = q[3]*q[3];
    var xx = q[0]*q[0];
    var yy = q[1]*q[1];
    var zz = q[2]*q[2];

    return [ ww+xx-yy-zz,                   2.0*(q[0]*q[1] - q[3]*q[2]), 2.0*(q[0]*q[2] + q[3]*q[1]), 0.0,
               2.0*(q[0]*q[1] + q[3]*q[2]),   ww-xx+yy-zz,                 2.0*(q[1]*q[2] - q[3]*q[0]), 0.0,
               2.0*(q[0]*q[2] - q[3]*q[1]),   2.0*(q[1]*q[2] + q[3]*q[0]), ww-xx-yy+zz,                 0.0,
               0.0,                           0.0,                         0.0,                         1.0 ];
}

function setPerspective( fovy, aspect, znear, zfar )
{
    var tan = Math.tan(fovy * Math.PI/180.0);
    var x = 1.0 / (tan*aspect);
    var y = 1.0 / (tan);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0 * zfar * znear) / (zfar - znear);

    return [ x,    0.0,  0.0,  0.0,
             0.0,  y,    0.0,  0.0,
             0.0,  0.0,  c,     d,
             0.0,  0.0, -1.0,  0.0 ];
}

function setLookAt( eye, tar, up )
{
    var dir = [ -tar[0]+eye[0], -tar[1]+eye[1], -tar[2]+eye[2] ];

	var m00 = dir[2]*up[1] - dir[1]*up[2]; 
    var m01 = dir[0]*up[2] - dir[2]*up[0];
    var m02 = dir[1]*up[0] - dir[0]*up[1];
    var im = 1.0/Math.sqrt( m00*m00 + m01*m01 + m02*m02 );
    m00 *= im;
    m01 *= im;
    m02 *= im;

	var m04 = m02*dir[1] - m01*dir[2]; 
    var m05 = m00*dir[2] - m02*dir[0];
    var m06 = m01*dir[0] - m00*dir[1];
    im = 1.0/Math.sqrt( m04*m04 + m05*m05 + m06*m06 );
    m04 *= im;
    m05 *= im;
    m06 *= im;

	var m08 = dir[0];
	var m09 = dir[1];
	var m10 = dir[2];
    im = 1.0/Math.sqrt( m08*m08 + m09*m09 + m10*m10 );
    m08 *= im;
    m09 *= im;
    m10 *= im;

	var m03 = -(m00*eye[0] + m01*eye[1] + m02*eye[2] );
	var m07 = -(m04*eye[0] + m05*eye[1] + m06*eye[2] );
	var m11 = -(m08*eye[0] + m09*eye[1] + m10*eye[2] );

    return [ m00, m01, m02, m03,
             m04, m05, m06, m07,
             m08, m09, m10, m11,
             0.0, 0.0, 0.0, 1.0 ];
}


function setOrtho( left, right, bottom, top, znear, zfar )
{
   var x = 2.0 / (right - left);
   var y = 2.0 / (top - bottom);
   var a = (right + left) / (right - left);
   var b = (top + bottom) / (top - bottom);
   var c = -2.0 / (zfar - znear);
   var d = -(zfar + znear) / ( zfar - znear);

   return [  x, 0.0, 0.0,   a,
           0.0,   y, 0.0,   b,
           0.0, 0.0,   c,   d,
           0.0, 0.0, 0.0, 1.0 ];
}

function setTranslation( p )
{
    return [ 1.0, 0.0, 0.0, p[0],
             0.0, 1.0, 0.0, p[1],
             0.0, 0.0, 1.0, p[2],
             0.0, 0.0, 0.0, 1.0 ];
}

function setScale( s )
{
    return [ s[0], 0.0,  0.0,  0.0,
             0.0,  s[1], 0.0,  0.0,
             0.0,  0.0,  s[2], 0.0,
             0.0,  0.0,  0.0,  1.0];
}

function setProjection( fov, znear, zfar )
{
    var x = 2.0 / (fov[3]+fov[2]);
    var y = 2.0 / (fov[0]+fov[1]);
    var a = (fov[3]-fov[2]) / (fov[3]+fov[2]);
    var b = (fov[0]-fov[1]) / (fov[0]+fov[1]);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0*zfar*znear) / (zfar - znear);
    return [   x, 0.0,    a, 0.0,
             0.0,   y,    b, 0.0,
             0.0, 0.0,    c,   d,
             0.0, 0.0, -1.0, 0.0 ];
   // inverse is:
   //return mat4x4( 1.0/x, 0.0f,  0.0f,   a/x,
   //               0.0f,  1.0/y, 0.0f,   b/x,
   //               0.0f,  0.0f,  0.0f,   -1.0,
   //               0.0f,  0.0f,  1.0f/d, c/d );
}


function invertFast( m )
{
    var inv = [
   
             m[5]  * m[10] * m[15] - 
             m[5]  * m[11] * m[14] - 
             m[9]  * m[6]  * m[15] + 
             m[9]  * m[7]  * m[14] +
             m[13] * m[6]  * m[11] - 
             m[13] * m[7]  * m[10],

             -m[1]  * m[10] * m[15] + 
              m[1]  * m[11] * m[14] + 
              m[9]  * m[2] * m[15] - 
              m[9]  * m[3] * m[14] - 
              m[13] * m[2] * m[11] + 
              m[13] * m[3] * m[10],

             m[1]  * m[6] * m[15] - 
             m[1]  * m[7] * m[14] - 
             m[5]  * m[2] * m[15] + 
             m[5]  * m[3] * m[14] + 
             m[13] * m[2] * m[7] - 
             m[13] * m[3] * m[6],

             -m[1] * m[6] * m[11] + 
              m[1] * m[7] * m[10] + 
              m[5] * m[2] * m[11] - 
              m[5] * m[3] * m[10] - 
              m[9] * m[2] * m[7] + 
              m[9] * m[3] * m[6],

             -m[4]  * m[10] * m[15] + 
              m[4]  * m[11] * m[14] + 
              m[8]  * m[6]  * m[15] - 
              m[8]  * m[7]  * m[14] - 
              m[12] * m[6]  * m[11] + 
              m[12] * m[7]  * m[10],

             m[0]  * m[10] * m[15] - 
             m[0]  * m[11] * m[14] - 
             m[8]  * m[2] * m[15] + 
             m[8]  * m[3] * m[14] + 
             m[12] * m[2] * m[11] - 
             m[12] * m[3] * m[10],

             -m[0]  * m[6] * m[15] + 
              m[0]  * m[7] * m[14] + 
              m[4]  * m[2] * m[15] - 
              m[4]  * m[3] * m[14] - 
              m[12] * m[2] * m[7] + 
              m[12] * m[3] * m[6],


             m[0] * m[6] * m[11] - 
             m[0] * m[7] * m[10] - 
             m[4] * m[2] * m[11] + 
             m[4] * m[3] * m[10] + 
             m[8] * m[2] * m[7] - 
             m[8] * m[3] * m[6],


             m[4]  * m[9] * m[15] - 
             m[4]  * m[11] * m[13] - 
             m[8]  * m[5] * m[15] + 
             m[8]  * m[7] * m[13] + 
             m[12] * m[5] * m[11] - 
             m[12] * m[7] * m[9],



             -m[0]  * m[9] * m[15] + 
              m[0]  * m[11] * m[13] + 
              m[8]  * m[1] * m[15] - 
              m[8]  * m[3] * m[13] - 
              m[12] * m[1] * m[11] + 
              m[12] * m[3] * m[9],

              m[0]  * m[5] * m[15] - 
              m[0]  * m[7] * m[13] - 
              m[4]  * m[1] * m[15] + 
              m[4]  * m[3] * m[13] + 
              m[12] * m[1] * m[7] - 
              m[12] * m[3] * m[5],

              -m[0] * m[5] * m[11] + 
               m[0] * m[7] * m[9] + 
               m[4] * m[1] * m[11] - 
               m[4] * m[3] * m[9] - 
               m[8] * m[1] * m[7] + 
               m[8] * m[3] * m[5],

              -m[4]  * m[9] * m[14] + 
               m[4]  * m[10] * m[13] +
               m[8]  * m[5] * m[14] - 
               m[8]  * m[6] * m[13] - 
               m[12] * m[5] * m[10] + 
               m[12] * m[6] * m[9],

              m[0]  * m[9] * m[14] - 
              m[0]  * m[10] * m[13] - 
              m[8]  * m[1] * m[14] + 
              m[8]  * m[2] * m[13] + 
              m[12] * m[1] * m[10] - 
              m[12] * m[2] * m[9],

              -m[0]  * m[5] * m[14] + 
               m[0]  * m[6] * m[13] + 
               m[4]  * m[1] * m[14] - 
               m[4]  * m[2] * m[13] - 
               m[12] * m[1] * m[6] + 
               m[12] * m[2] * m[5],

              m[0] * m[5] * m[10] - 
              m[0] * m[6] * m[9] - 
              m[4] * m[1] * m[10] + 
              m[4] * m[2] * m[9] + 
              m[8] * m[1] * m[6] - 
              m[8] * m[2] * m[5] ];

    var det = m[0] * inv[0] + m[1] * inv[4] + m[2] * inv[8] + m[3] * inv[12];

    det = 1.0/det;

    for( var i = 0; i<16; i++ ) inv[i] = inv[i] * det;

    return inv;
}

function matMul( a, b )
{
    var res = [];
    for( var i=0; i<4; i++ )
    {
        var x = a[4*i+0];
        var y = a[4*i+1];
        var z = a[4*i+2];
        var w = a[4*i+3];

        res[4*i+0] = x * b[ 0] + y * b[ 4] + z * b[ 8] + w * b[12];
        res[4*i+1] = x * b[ 1] + y * b[ 5] + z * b[ 9] + w * b[13];
        res[4*i+2] = x * b[ 2] + y * b[ 6] + z * b[10] + w * b[14];
        res[4*i+3] = x * b[ 3] + y * b[ 7] + z * b[11] + w * b[15];
    }

    return res;
}

function matMulpoint( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2] + m[ 3],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2] + m[ 7],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] + m[11] ];
}

function matMulvec( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] ];
}


function bound3( infi )
{
    return [ infi, -infi, infi, -infi, infi, -infi ];
}

function bound3_include( a, p )
{
    return [
        (p[0]<a[0]) ? p[0] : a[0],
        (p[0]>a[1]) ? p[0] : a[1],
        (p[1]<a[2]) ? p[1] : a[2],
        (p[1]>a[3]) ? p[1] : a[3],
        (p[2]<a[4]) ? p[2] : a[4],
        (p[2]>a[5]) ? p[2] : a[5] ];
}

function bound3_center( b )
{
    return [ 0.5*(b[0]+b[1]),
             0.5*(b[2]+b[3]),
             0.5*(b[4]+b[5]) ];
}

function bound3_radius( b )
{
    return [ 0.5*(b[1]-b[0]),
             0.5*(b[3]-b[2]),
             0.5*(b[5]-b[4]) ];
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebVR
//
//==============================================================================

function WebVR( isVREnabledCallback, canvasElement )
{
    isVREnabledCallback(false);
    /*


    this.mSupportVR = false;
    this.mHMD = null;

    var me = this;
    var listVRDisplays = function (vrdevs) {
        for (var i = 0; i < vrdevs.length; i++)
        {
            if (vrdevs[i] instanceof VRDisplay)
            {
                me.mHMD = vrdevs[i];
                console.log("WebVR is available.");
                console.log(me.mHMD);
                break;
            }
        }

        isVREnabledCallback(true);
        me.mSupportVR = true;
    }

    if (navigator.getVRDisplays)
    {
        navigator.getVRDisplays().then(listVRDisplays);
    }

    isVREnabledCallback(false);
    this.mCanvas = canvasElement;
    */
}

WebVR.prototype.IsSupported = function()
{
    return false;
    //return this.mSupportVR;
}

WebVR.prototype.GetData = function( id )
{
    return {};
    /*
    var frameData = new VRFrameData();
    var s = this.mHMD.getFrameData(frameData);
    var ss = frameData.pose;
    
    var fovL = this.mHMD.getEyeParameters("left");
    var fovR = this.mHMD.getEyeParameters( "right" );

    // camera info
    var cPos = vec3(0.0, 0.0, 0.0);
    if (ss.position)
        cPos = vec3(-ss.position[0], -ss.position[1], -ss.position[2]);
    var rot = vec4(0.0, 0.0, 0.0, 0.0);
    if (ss.orientation)
        rot = vec4(ss.orientation[0], ss.orientation[1], ss.orientation[2], ss.orientation[3]);
    var cRot = setFromQuaternion(rot);
    var cTra = setTranslation(cPos);
    var cMat = matMul(invertFast(cRot), cTra);
    
    // per eye info
    var lTra = setTranslation( vec3(-fovL.offset[0], -fovL.offset[1], -fovL.offset[2]) );
    var lMat = matMul(lTra, cMat);
    var lPrj = [ Math.tan( fovL.fieldOfView.upDegrees * Math.PI/180.0),
                 Math.tan(fovL.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.rightDegrees * Math.PI / 180.0)];

    var rTra = setTranslation(vec3(-fovR.offset[0], -fovR.offset[1], -fovR.offset[2]));
    var rMat = matMul(rTra, cMat);
    var rPrj = [Math.tan(fovR.fieldOfView.upDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.rightDegrees * Math.PI / 180.0)];

    return {
        mCamera   : { mCamera: cMat },
        mLeftEye  : { mVP:[0,0,fovL.renderWidth,fovL.renderHeight], mProjection:lPrj, mCamera:lMat },
        mRightEye : { mVP:[fovR.renderWidth/2,0,fovR.renderWidth,fovR.renderHeight], mProjection:rPrj, mCamera:rMat }
           };
    */
}

WebVR.prototype.Enable = function( id )
{
    /*
    this.mHMD.requestPresent([{ source: this.mCanvas }]).then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : requestPresent failed.");
        }
    );
    */
}

WebVR.prototype.Disable = function( id )
{
    /*
    if (!this.mHMD.isPresenting)
    {
        return;
    }

    this.mHMD.exitPresent().then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : exitPresent failed.");
        }
    );
    */
}

WebVR.prototype.RequestAnimationFrame = function (id)
{
    //this.mHMD.requestAnimationFrame(id);
}

WebVR.prototype.IsPresenting = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        return true;
    }
    */
    return false;
}

WebVR.prototype.Finish = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        this.mHMD.submitFrame();
    }
    */
}

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebUtils
//
//==============================================================================


// RequestAnimationFrame
window.requestAnimFrame = ( function () { return window.requestAnimationFrame    || window.webkitRequestAnimationFrame ||
                                                 window.mozRequestAnimationFrame || window.oRequestAnimationFrame ||
                                                 window.msRequestAnimationFrame  || function( cb ) { window.setTimeout(cb,1000/60); };
                                        } )();

// performance.now
window.getRealTime = ( function() { if ("performance" in window ) return function() { return window.performance.now(); }
                                                                  return function() { return (new Date()).getTime(); }
                                  } )();

window.URL = window.URL || window.webkitURL;

navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;

function htmlEntities(str) 
{
    return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g,'&apos;');
}

function piDisableTouch()
{
    document.body.addEventListener('touchstart', function(e){ e.preventDefault(); });
}

var piGetTime = function ( timestamp )
{
    if (timestamp == 0)
        return "";
    return new Date(timestamp * 1000).toISOString().substr(0, 10);
}

function piGetCoords( obj )
{
    var x = 0;
    var y = 0; 
    do
    {
         x += obj.offsetLeft;
         y += obj.offsetTop;
    }while( obj = obj.offsetParent );

    return { mX:x, mY:y };
}

function piGetMouseCoords( ev, canvasElement )
{
    var pos = piGetCoords(canvasElement );
    var mcx =                        (ev.pageX - pos.mX) * canvasElement.width / canvasElement.offsetWidth;
    var mcy = canvasElement.height - (ev.pageY - pos.mY) * canvasElement.height / canvasElement.offsetHeight;

    return { mX: mcx, mY: mcy };

}

function piGetSourceElement( e )
{
    var ele = null;
    if( e.target )     ele = e.target;
    if( e.srcElement ) ele = e.srcElement;
    return ele;
}

function piRequestFullScreen( ele )
{
    if( ele==null ) ele =   document.documentElement;
         if( ele.requestFullscreen       ) ele.requestFullscreen();
    else if( ele.msRequestFullscreen     ) ele.msRequestFullscreen();
    else if( ele.mozRequestFullScreen    ) ele.mozRequestFullScreen();
    else if( ele.webkitRequestFullscreen ) ele.webkitRequestFullscreen( Element.ALLOW_KEYBOARD_INPUT );
}

function piIsFullScreen()
{
    return document.fullscreen || document.mozFullScreen || document.webkitIsFullScreen || document.msFullscreenElement || false;
}

function piExitFullScreen()
{
       if( document.exitFullscreen       ) document.exitFullscreen();
  else if( document.msExitFullscreen     ) document.msExitFullscreen();
  else if( document.mozCancelFullScreen  ) document.mozCancelFullScreen();
  else if( document.webkitExitFullscreen ) document.webkitExitFullscreen();
}

function piIsMobile()
{
    return (navigator.userAgent.match(/Android/i) ||
            navigator.userAgent.match(/webOS/i) ||
            navigator.userAgent.match(/iPhone/i) ||
            navigator.userAgent.match(/iPad/i) ||
            navigator.userAgent.match(/iPod/i) ||
            navigator.userAgent.match(/BlackBerry/i) ||
            navigator.userAgent.match(/Windows Phone/i)) ? true : false;
}

function piCreateGlContext( cv, useAlpha, useDepth, usePreserveBuffer, useSupersampling )
{
    var opts = { alpha: useAlpha, 
                 depth: useDepth, 
                 stencil: false, 
                 premultipliedAlpha: false, 
                 antialias: useSupersampling, 
                 preserveDrawingBuffer: usePreserveBuffer, 
                 powerPreference: "high-performance" }; // "low_power", "high_performance", "default"

    var gl = null;
    if( gl === null) gl = cv.getContext( "webgl2", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl2", opts );
    if( gl === null) gl = cv.getContext( "webgl", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl", opts );

    return gl;
}

function piCreateAudioContext()
{
    var res = null;
    try
    {
        if( window.AudioContext ) res = new AudioContext();
        if( res==null && window.webkitAudioContext ) res = new webkitAudioContext();
    }
    catch( e )
    {
        res = null;
    }
    return res;
}

function piHexColorToRGB(str) // "#ff3041"
{
    var rgb = parseInt(str.slice(1), 16);
    var r = (rgb >> 16) & 255;
    var g = (rgb >> 8) & 255;
    var b = (rgb >> 0) & 255;
    return [r, g, b];
}

function piCreateFPSCounter()
{
    var mFrame;
    var mTo;
    var mFPS;

    var iReset = function( time )
    {
        mFrame = 0;
        mTo = time;
        mFPS = 60.0;
    }

    var iCount = function( time )
    {
        mFrame++;

        if( (time-mTo)>500.0 )
        {
            mFPS = 1000.0*mFrame/(time-mTo);
            mFrame = 0;
            mTo = time;
            return true;
        }
        return false;
    }

    var iGetFPS = function()
    {
        return mFPS;
    }
    
    return { Reset : iReset, Count : iCount, GetFPS : iGetFPS };
}

function piCanMediaRecorded(canvas)
{
    if (typeof window.MediaRecorder !== 'function' || typeof canvas.captureStream !== 'function') {
        return false;
    }
    return true;
}

function piCreateMediaRecorder(isRecordingCallback, canvas) 
{
    if (piCanMediaRecorded(canvas) == false)
    {
        return null;
    }
    
    var options = { audioBitsPerSecond : 0, videoBitsPerSecond : 8000000 }; 
	     if (MediaRecorder.isTypeSupported('video/webm;codecs=h264')) options.mimeType = 'video/webm;codecs=h264';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9' )) options.mimeType = 'video/webm;codecs=vp9';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8' )) options.mimeType = 'video/webm;codecs=vp8';
    else                                                              options.mimeType = 'video/webm;';

    var mediaRecorder = new MediaRecorder(canvas.captureStream(), options);
    var chunks = [];
    
    mediaRecorder.ondataavailable = function(e) 
    {
        if (e.data.size > 0) 
        {
            chunks.push(e.data);
        }
    };
 
    mediaRecorder.onstart = function(){ 
        isRecordingCallback( true );
    };
    
    mediaRecorder.onstop = function()
    {
         isRecordingCallback( false );
         let blob     = new Blob(chunks, {type: "video/webm"});
         chunks       = [];
         let videoURL = window.URL.createObjectURL(blob);
         let url      = window.URL.createObjectURL(blob);
         let a        = document.createElement("a");
         document.body.appendChild(a);
         a.style      = "display: none";
         a.href       = url;
         a.download   = "capture.webm";
         a.click();
         window.URL.revokeObjectURL(url);
     };
    
    return mediaRecorder;
}

function piExportToEXR(width, height, numComponents, type, bytes)
{
    var bytesPerComponent = 0;
    if      (type=="Uint")   bytesPerComponent = 4; 
    else if (type=="Half")   bytesPerComponent = 2;
    else if (type=="Float")  bytesPerComponent = 4;

    var tHeader = 258 + (18 * numComponents + 1);
    var tTable = 8 * height;
    var tScanlines = height * (4 + 4 + (numComponents * bytesPerComponent * width));
    var tTotal = tHeader + tTable + tScanlines;

    //console.log("    header size = " + tHeader);
    //console.log("    table size = " + tTable);
    //console.log("    scanlines size = " + tScanlines);
    //console.log("    total = " + tTotal);

    var buffer = new ArrayBuffer(tTotal); 
    var data = new DataView(buffer);

    // Header
    {
        // Header : 4 bytes -> 0x76, 0x2f, 0x31, 0x01
        var c = 0;
        data.setUint8 (c++, 0x76);
        data.setUint8 (c++, 0x2f);
        data.setUint8 (c++, 0x31);
        data.setUint8 (c++, 0x01);

        // Version : 4 bytes -> 2, 0, 0, 0
        data.setUint8 (c++, 0x02);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        
        // Write channel info
        // Write attribute name : "channels"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x73);
            data.setUint8 (c++, 0x0);

            // Write attribute type : "chlist"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : 18 x 3 + 1 = 55
            var attribSize = 18 * numComponents + 1;
            data.setUint8 (c++, attribSize); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            var i;
            for (i = 0; i < numComponents; i++)
            {
                // Attribute : "B" (42) "G" (47) "R" (52)
                if (i==0)       data.setUint8 (c++, 0x42);
                else if (i==1)  data.setUint8 (c++, 0x47);
                else if (i==2)  data.setUint8 (c++, 0x52);
                data.setUint8 (c++, 0x00);
                
                // Value : Float (2), Half (1), Uint (0)
                if      (type=="Uint")   data.setUint8 (c++, 0x00); 
                else if (type=="Half")   data.setUint8 (c++, 0x01);
                else if (type=="Float")  data.setUint8 (c++, 0x02);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);

                // Plinear
                data.setUint8 (c++, 0x01);

                // Reserved
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 

                // X sampling
                data.setUint8 (c++, 0x01); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                
                // Y sampling
                data.setUint8 (c++, 0x01);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
            }
            // End attribute
            data.setUint8 (c++, 0x00);
    
        // Write attribute name : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute type : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : "1"
            data.setUint8 (c++, 0x01); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // Write attribute value : "0" (None)
            data.setUint8 (c++, 0x00);

        // datawindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00); 

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00);

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 

            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // displayWindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x79); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00);

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00); 

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // size
            data.setUint8 (c++, 0x01);
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);
            
            // value 
            data.setUint8 (c++, 0x00);

        // PixelAspectRatio
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x41); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x52); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x00); 

            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);
        
            // size 4
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 1.0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);
        
        // screenWindowCenter
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63);
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x43); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e);
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00);

            // v2f
            data.setUint8 (c++, 0x76); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x00);

            // size 8
            data.setUint8 (c++, 0x08); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

        // screenWindowWidth
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x00); 
            
            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00); 

            // size
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);

            // value
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);

        // End of header
        data.setUint8 (c++, 0x00);
    }
    //console.log("header size = " + c);

    // Scanline table
    var initc = c + height * 8;
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        var jump = initc + scanline * (8 + width * bytesPerComponent * numComponents); 
        data.setUint32 (c, jump, true);
        c += 4; 

        data.setUint32 (c, 0x00, true);
        c += 4;
    }
    //console.log("header + scanlines table size = " + c);

    // Scanlines
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        // Scanline
        data.setUint32(c, scanline, true);
        c += 4;

        // size 24
        var size = width * numComponents * bytesPerComponent; 
        data.setUint32(c, size, true);
        c += 4;

        var numComponentsSource = 4; // number of components in the SOURCE image
        for (var component = 0; component < numComponents ; component ++) 
        {
            for (var pixel = 0 ; pixel < width ; pixel ++) 
            {
                // flip vertical, so we read OpenGL buffers without JS image flipping
                var v = bytes[(height-1-scanline) * width *numComponentsSource + pixel * numComponentsSource + (2-component)];
                if      (type=="Float") data.setFloat32(c, v, true);
                else if (type=="Half")  data.setUint16(c, v, true);

                c += bytesPerComponent;
            }
        }
    }
    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}


function piExportToWAV(numSamples, rate, bits, numChannels, words)
{
    let numBytes = numSamples * numChannels * bits/8;

    let buffer = new ArrayBuffer(44 + numBytes); 
    let data = new DataView(buffer);

    {
        data.setUint32( 0, 0x46464952, true );  // RIFF
        data.setUint32( 4, numBytes + 36, true);
        {
            data.setUint32( 8, 0x45564157, true );  // WAV_WAVE
            data.setUint32( 12, 0x20746D66, true );  // WAV_FMT
            {
                data.setUint32( 16, 16, true);
                data.setUint16( 20, 1, true ); // WAV_FORMAT_PCM
                data.setUint16( 22, numChannels, true);
                data.setUint32( 24, rate, true);
                data.setUint32( 28, rate*numChannels*bits / 8, true);
                data.setUint16( 32, numChannels*bits / 8, true);
                data.setUint16( 34, bits, true);
            }

            data.setUint32( 36, 0x61746164, true);  // WAV_DATA
            {
                data.setUint32( 40, numBytes, true);
                let numWords = numSamples * numChannels;
                for(let i=0; i<numWords; i++ )
                {
                    data.setInt16( 44 + i*2, words[i], true );
                }
            }
        }
    }


    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}

function piTriggerDownload(name, blob)
{
    let url = URL.createObjectURL(blob);
    let aElement = document.createElement("a");
    aElement.href     = url;
    aElement.target   = "_self";
    aElement.download = name;
    document.body.appendChild(aElement);
    aElement.click();
    document.body.removeChild(aElement);
}</script>
    <script>"use strict"

function bufferID_to_assetID( id )
{
    if( id===0 ) return '4dXGR8';
    if( id===1 ) return 'XsXGR8';
    if( id===2 ) return '4sXGR8';
    if( id===3 ) return 'XdfGR8';
    return 'none';
}
function assetID_to_bufferID( id )
{
    if( id==='4dXGR8' ) return 0;
    if( id==='XsXGR8' ) return 1;
    if( id==='4sXGR8' ) return 2;
    if( id==='XdfGR8' ) return 3;
    return -1;
}

function assetID_to_cubemapBuferID( id )
{
    if( id==='4dX3Rr' ) return 0;
    return -1;
}
function cubamepBufferID_to_assetID( id )
{
    if( id===0 ) return '4dX3Rr';
    return 'none';
}

function EffectPass( renderer, is20, isLowEnd, hasShaderTextureLOD, callback, obj, forceMuted, forcePaused, outputGainNode, copyProgram, id, effect  )
{
    this.mID = id;
    this.mInputs  = [null, null, null, null ];
    this.mOutputs = [null, null, null, null ];
    this.mSource = null;

    this.mGainNode = outputGainNode;
    this.mSoundShaderCompiled = false;

    this.mEffect = effect;
    this.mRenderer = renderer;
    this.mProgramCopy = copyProgram; 
    this.mCompilationTime = 0;

    this.mType = "none";
    this.mName = "none";
    this.mFrame = 0;

    this.mShaderTextureLOD = hasShaderTextureLOD;
    this.mIs20 = is20;
    this.mIsLowEnd = isLowEnd;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mForceMuted = forceMuted;
    this.mForcePaused = forcePaused;
}

EffectPass.prototype.MakeHeader_Image = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        // old API
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                   header += "uniform sampler2D iChannel" + i + ";\n";

        // new API (see shadertoy.com/view/wtdGW8)
        header += "uniform struct {\n";
             if( inp===null )                  header += "  sampler2D";
        else if( inp.mInfo.mType==="cubemap" ) header += "  samplerCube";
        else if( inp.mInfo.mType==="volume"  ) header += "  sampler3D";
        else                                  header += "  sampler2D";
        header +=        " sampler;\n";
        header += "  vec3  size;\n";
        header += "  float time;\n";
        header += "  int   loaded;\n";
        header += "}iCh" + i + ";\n";
    }
	header += "void mainImage( out vec4 c, in vec2 f );\n";
    header += "void st_assert( bool cond );\n";
    header += "void st_assert( bool cond, int v );\n";

    if( this.mIs20 ) 
    {
        header += "\nout vec4 shadertoy_out_color;\n" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)shadertoy_out_color.x=-1.0;else if(v==1)shadertoy_out_color.y=-1.0;else if(v==2)shadertoy_out_color.z=-1.0;else shadertoy_out_color.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)shadertoy_out_color.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "shadertoy_out_color = vec4(1.0,1.0,1.0,1.0);" + 
            "vec4 color = vec4(1e20);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "if(shadertoy_out_color.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(shadertoy_out_color.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(shadertoy_out_color.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(shadertoy_out_color.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "shadertoy_out_color = vec4(color.xyz,1.0);" +
        "}";
    }
    else
    {
        header += "" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)gl_FragColor.x=-1.0;else if(v==1)gl_FragColor.y=-1.0;else if(v==2)gl_FragColor.z=-1.0;else gl_FragColor.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)gl_FragColor.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "gl_FragColor = vec4(0.0,0.0,0.0,1.0);" + 
            "vec4 color = vec4(1e20);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "color.w = 1.0;" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(gl_FragColor.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "gl_FragColor = vec4(color.xyz,1.0);"+
        "}";
    }
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 ) 
        this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "void main( void )" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );" +
        "color.w = 1.0;"
    if( this.mIs20 ) 
        this.mImagePassFooterVR +=  "outColor = color;}";
    else
        this.mImagePassFooterVR +=  "gl_FragColor = color;}";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Buffer = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                  header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainImage( out vec4 c,  in vec2 f );\n"

    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +
        "mainImage( color, gl_FragCoord.xy );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
    this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        this.mImagePassFooterVR +="outColor = color; }";
    else
        this.mImagePassFooterVR +="gl_FragColor = color; }";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Cubemap = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                   header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainCubemap( out vec4 c, in vec2 f, in vec3 ro, in vec3 rd );\n"

    header += "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainCubemap( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Sound = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform float     iChannelTime[4];\n" +
              "uniform float     iTimeOffset;\n" +
              "uniform int       iSampleOffset;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n";

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp!==null && inp.mInfo.mType==="cubemap" )
            header += "uniform samplerCube iChannel" + i + ";\n";
        else
            header += "uniform sampler2D iChannel" + i + ";\n";
    }
    header += "\n";
    header += "vec2 mainSound( in int samp, float time );\n";

    if( this.mIs20 )
    {
        header += "out vec4 outColor; void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "int   s = iSampleOffset + int(gl_FragCoord.y-0.2)*512 + int(gl_FragCoord.x-0.2);" +
            "vec2 y = mainSound( s, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "outColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    else
    {
        header += "void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "vec2 y = mainSound( 0, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "gl_FragColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    header += "\n";
    this.mHeader = header;
    this.mHeaderLength = 0;
}


EffectPass.prototype.MakeHeader_Common = function ()
{
    let header = "";
    let headerlength = 0;

    header += "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n";
    headerlength += 2;

    if (this.mIs20)
    {
        header += "out vec4 outColor;\n";
        headerlength += 1;
    }
    header += "void main( void )\n";
    headerlength += 1;

    if (this.mIs20)
        header += "{ outColor = vec4(0.0); }";
    else
        header += "{ gl_FragColor = vec4(0.0); }";
    headerlength += 1;
    header += "\n";
    headerlength += 1;

    this.mHeader = header;
    this.mHeaderLength = headerlength;
}

EffectPass.prototype.MakeHeader = function()
{
         if( this.mType==="image" ) this.MakeHeader_Image();
    else if( this.mType==="sound" ) this.MakeHeader_Sound();
    else if( this.mType==="buffer") this.MakeHeader_Buffer();
    else if( this.mType==="common") this.MakeHeader_Common();
    else if( this.mType==="cubemap") this.MakeHeader_Cubemap();
    else console.log("ERROR 4");
}

EffectPass.prototype.Create_Image = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}
EffectPass.prototype.Destroy_Image = function( wa )
{
}

EffectPass.prototype.Create_Buffer = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}

EffectPass.prototype.Destroy_Buffer = function( wa )
{
}

EffectPass.prototype.Create_Cubemap = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
}

EffectPass.prototype.Destroy_Cubemap = function( wa )
{
}

EffectPass.prototype.Create_Common = function( wa )
{
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.MakeHeader();
}
EffectPass.prototype.Destroy_Common = function( wa )
{
}

EffectPass.prototype.Create_Sound = function (wa)
{
    this.MakeHeader();

    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    this.mSampleRate = 44100;
    this.mPlayTime = 60*3;
    this.mPlaySamples = this.mPlayTime*this.mSampleRate;
    this.mBuffer = wa.createBuffer( 2, this.mPlaySamples, this.mSampleRate );

    //-------------------
    this.mTextureDimensions = 512;
    this.mRenderTexture = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D, 
                                                       this.mTextureDimensions, this.mTextureDimensions,
                                                       this.mRenderer.TEXFMT.C4I8,
                                                       this.mRenderer.FILTER.NONE,
                                                       this.mRenderer.TEXWRP.CLAMP, null);
    this.mRenderFBO = this.mRenderer.CreateRenderTarget(this.mRenderTexture, null, null, null, null, false);

    //-----------------------------

    // ArrayBufferView pixels;
    this.mTmpBufferSamples = this.mTextureDimensions*this.mTextureDimensions;
    this.mData = new Uint8Array( this.mTmpBufferSamples*4 );

    this.mPlaying = false;
}

EffectPass.prototype.Destroy_Sound = function( wa )
{
    if( this.mPlayNode!==null ) this.mPlayNode.stop();
    this.mPlayNode = null;
    this.mBuffer = null;
    this.mData = null;

    this.mRenderer.DestroyRenderTarget(this.mRenderFBO);
    this.mRenderer.DestroyTexture(this.mRenderTexture);
}

EffectPass.prototype.Create = function( passType, wa )
{
    this.mType = passType;
    this.mSource = null;

         if( passType==="image" ) this.Create_Image( wa );
    else if( passType==="sound" ) this.Create_Sound( wa );
    else if( passType==="buffer") this.Create_Buffer( wa );
    else if( passType==="common") this.Create_Common( wa );
    else if( passType==="cubemap") this.Create_Cubemap( wa );
    else alert("ERROR 1");
}

EffectPass.prototype.SetName = function (passName)
{
    this.mName = passName;
}

EffectPass.prototype.SetCode = function (src)
{
    this.mSource = src;
}

EffectPass.prototype.Destroy = function( wa )
{
    this.mSource = null;
         if( this.mType==="image" ) this.Destroy_Image( wa );
    else if( this.mType==="sound" ) this.Destroy_Sound( wa );
    else if( this.mType==="buffer") this.Destroy_Buffer( wa );
    else if( this.mType==="common") this.Destroy_Common( wa );
    else if( this.mType==="cubemap") this.Destroy_Cubemap( wa );
    else alert("ERROR 2");
}

EffectPass.prototype.NewShader_Sound = function( shaderCode, commonShaderCodes)
{
    let vsSource = null;

    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for( let i=0; i<commonShaderCodes.length; i++ )
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    this.mSoundShaderCompiled = false;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader_Image = function ( shaderCode, commonShaderCodes )
{
    this.mSupportsVR = false;

    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    return [vsSource, fsSource];


    /*
    let n1 = shaderCode.indexOf("mainVR(");
    let n2 = shaderCode.indexOf("mainVR (");
    let n3 = shaderCode.indexOf("mainVR  (");
    if( n1>0 || n2>0 || n3>0 )
    {
        let vsSourceVR;
        if( this.mIs20 )
            vsSourceVR = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        else
            vsSourceVR = "attribute in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

        let fsSourceVR = this.mHeader;
        for (let i = 0; i < commonShaderCodes.length; i++) {
            fsSourceVR += commonShaderCodes[i];
        }
        fsSourceVR += shaderCode;
        fsSourceVR += this.mImagePassFooterVR;

        let res = this.mRenderer.CreateShader(vsSource, fsSourceVR, preventCache);
        if( res.mResult == false )
        {
            return res.mInfo;
        }
        if( this.mProgramVR != null )
            this.mRenderer.DestroyShader( this.mProgramVR );

        this.mSupportsVR = true;
        this.mProgramVR = res;
    }
    */
}

EffectPass.prototype.NewShader_Cubemap = function( shaderCode, commonShaderCodes )
{
    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }

    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;

    fsSource += shaderCode;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader_Common = function (shaderCode )
{
    let vsSource = null;
    if (this.mIs20)
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader + shaderCode;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader = function ( commonSourceCodes, preventCache, onResolve)
{
    if( this.mRenderer===null ) return;

    let vs_fs = null;

         if( this.mType==="sound"  ) vs_fs = this.NewShader_Sound(   this.mSource, commonSourceCodes );
    else if( this.mType==="image"  ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="buffer" ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="common" ) vs_fs = this.NewShader_Common(  this.mSource,                   );
    else if( this.mType==="cubemap") vs_fs = this.NewShader_Cubemap( this.mSource, commonSourceCodes );
    else { console.log("ERROR 3: \"" + this.mType + "\""); return; }

    let me = this;
    this.mRenderer.CreateShader(vs_fs[0], vs_fs[1], preventCache, false,
        function (worked, info)
        {
            if (worked === true)
            {
                if (me.mType === "sound")
                {
                    me.mSoundShaderCompiled = true;
                }

                me.mCompilationTime = info.mTime;
                me.mError = false;
                me.mErrorStr = "No Errors";
                if (me.mProgram !== null)
                    me.mRenderer.DestroyShader(me.mProgram);
                me.mTranslatedSource = me.mRenderer.GetTranslatedShaderSource(info);
                me.mProgram = info;
            }
            else
            {
                me.mError = true;
                me.mErrorStr = info.mErrorStr;
            }
            onResolve();
        });
}

EffectPass.prototype.DestroyInput = function( id )
{
    if( this.mInputs[id]===null ) return;

    if( this.mInputs[id].mInfo.mType==="texture" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    if( this.mInputs[id].mInfo.mType==="volume" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="webcam" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video.src = "";

        if( this.mInputs[id].video.srcObject!==null )
        {
        let tracks = this.mInputs[id].video.srcObject.getVideoTracks();
        if( tracks ) tracks[0].stop();
        }
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="video" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="music" || this.mInputs[id].mInfo.mType==="musicstream")
    {
        this.mInputs[id].audio.pause();
        this.mInputs[id].audio.mSound.mFreqData = null;
        this.mInputs[id].audio.mSound.mWaveData = null;
        this.mInputs[id].audio = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="cubemap" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="keyboard" )
    {
        //if( this.mInputs[id].globject != null )
          //  this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="mic" )
    {
        this.mInputs[id].mic = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }

    this.mInputs[id] = null;
}

EffectPass.prototype.TooglePauseInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        else
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.audio.mPaused )
        {
            if( inp.loaded )
            {
                inp.audio.play();
            }
            inp.audio.mPaused = false;
        }
        else
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }

    return null;
}

EffectPass.prototype.StopInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused === false )
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused === false )
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.ResumeInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused )
        {
            inp.audio.play();
            inp.audio.mPaused = false;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.RewindInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp==null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.loaded )
        {
            inp.video.currentTime = 0;
        }
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.loaded )
        {
            inp.audio.currentTime = 0;
        }
    }
}

EffectPass.prototype.MuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = true;
        inp.video.mMuted = true;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 0.0;
        inp.audio.mMuted = true;
    }
}

EffectPass.prototype.UnMuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = false;
        inp.video.mMuted = false;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 1.0;
        inp.audio.mMuted = false;
    }
}

EffectPass.prototype.ToggleMuteInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];
    if( inp===null ) return null;

    if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.video.mMuted;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if( inp.audio.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.audio.mMuted;
    }

    return null;
}

EffectPass.prototype.UpdateInputs = function( wa, forceUpdate, keyboard )
{
   for (let i=0; i<this.mInputs.length; i++ )
   {
        let inp = this.mInputs[i];

        if( inp===null )
        {
            if( forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, null, false, 0, 0, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.image, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mPreview, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if( inp.loaded && forceUpdate )
            {
                if( this.mTextureCallbackFun!==null )
                {
                    let img = (assetID_to_cubemapBuferID(inp.mInfo.mID)===-1) ? inp.image[0] : inp.mImage;
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, img, true, 2, 1, -1.0, this.mID );
                }
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:keyboard.mIcon,mData:keyboard.mData}, false, 6, 0, -1.0, this.mID );
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, -1, this.mID );
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
              if( inp.loaded && inp.audio.mPaused === false && inp.audio.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                      inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                  }

                  if (this.mTextureCallbackFun!==null)
                  {
                           if (inp.mInfo.mType === "music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData}, false, 4, 1, inp.audio.currentTime, this.mID);
                      else if (inp.mInfo.mType === "musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData, info: inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                  }
              }
              else if( inp.loaded===false )
              {
                  if (this.mTextureCallbackFun!==null)
                      this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:null}, false, 4, 0, -1.0, this.mID);
              }
        }
        else if( inp.mInfo.mType==="mic" )
        {
              if( inp.loaded && inp.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                      inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
                  }
                  if( this.mTextureCallbackFun!==null )
                      this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave: ((wa==null)?null:inp.mFreqData) }, false, 5, 1, 0, this.mID );
              }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:null}, true, 9, 1, -1.0, this.mID );
            }
        }
    }
}

EffectPass.prototype.Sampler2Renderer = function (sampler)
{
    let filter = this.mRenderer.FILTER.NONE;
    if (sampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
    if (sampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
    let wrap = this.mRenderer.TEXWRP.REPEAT;
    if (sampler.wrap === "clamp") wrap = this.mRenderer.TEXWRP.CLAMP;
    let vflip = false;
    if (sampler.vflip === "true") vflip = true;

    return { mFilter: filter, mWrap: wrap, mVFlip: vflip };
}

EffectPass.prototype.GetSamplerVFlip = function (id)
{
    let inp = this.mInputs[id];
    return inp.mInfo.mSampler.vflip;
}

EffectPass.prototype.GetTranslatedShaderSource = function ()
{
    return this.mTranslatedSource;
}

EffectPass.prototype.SetSamplerVFlip = function (id, str) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = false;
    if (str === "true") filter = true;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, null);
            inp.mInfo.mSampler.vflip = str;
        }
    }
}

EffectPass.prototype.GetAcceptsVFlip = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return false;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return false;
    return true;
}

EffectPass.prototype.GetSamplerFilter = function (id)
{
    let inp = this.mInputs[id];
    if( inp===null) return;
    return inp.mInfo.mSampler.filter;
}

EffectPass.prototype.SetSamplerFilter = function (id, str, buffers, cubeBuffers) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = renderer.FILTER.NONE;
    if (str === "linear") filter = renderer.FILTER.LINEAR;
    if (str === "mipmap") filter = renderer.FILTER.MIPMAP;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0)
            {
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[0], filter, true);
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[1], filter, true);
                inp.mInfo.mSampler.filter = str;
            }
            else
            {
                renderer.SetSamplerFilter(inp.globject, filter, true);
                inp.mInfo.mSampler.filter = str;
            }
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[0], filter, true);
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[1], filter, true);
        inp.mInfo.mSampler.filter = str;
    }
    else if (inp.mInfo.mType === "keyboard")
    {
        inp.mInfo.mSampler.filter = str;
    }
}

EffectPass.prototype.GetAcceptsMipmapping = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetAcceptsLinear = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return true;
    if (inp.mInfo.mType === "musicstream") return true;
    if (inp.mInfo.mType === "mic")  return true;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return true;
    return false;
}

EffectPass.prototype.GetAcceptsWrapRepeat = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return false;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetSamplerWrap = function (id)
{
    return this.mInputs[id].mInfo.mSampler.wrap;
}

EffectPass.prototype.SetSamplerWrap = function (id, str, buffers)
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let restr = renderer.TEXWRP.REPEAT;
    if (str === "clamp") restr = renderer.TEXWRP.CLAMP;

    if (inp === null) 
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "video") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap") 
    {
        if (inp.loaded)
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "webcam") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[0], restr);
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[1], restr);
        inp.mInfo.mSampler.wrap = str;
    }
}


EffectPass.prototype.GetTexture = function( slot )
{
    let inp = this.mInputs[slot];
    if( inp===null ) return null;
    return inp.mInfo;
}

EffectPass.prototype.SetOutputs = function( slot, id )
{
    this.mOutputs[slot] = id;
}

EffectPass.prototype.SetOutputsByBufferID = function( slot, id )
{
    if( this.mType==="buffer" )
    {
        this.mOutputs[slot] = bufferID_to_assetID( id );

        this.mEffect.ResizeBuffer( id, this.mEffect.mXres, this.mEffect.mYres, false );
    }
    else if( this.mType==="cubemap" )
    {
        this.mOutputs[slot] = cubamepBufferID_to_assetID( id );
        this.mEffect.ResizeCubemapBuffer(id, 1024, 1024 );
    }
}

EffectPass.prototype.NewTexture = function( wa, slot, url, buffers, cubeBuffers, keyboard )
{
    var me = this;
    var renderer = this.mRenderer;

    if( renderer===null ) return;

    let texture = null;

    if( url===null || url.mType===null )
    {
        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( this.mTextureCallbackObj, slot, null, true, 0, 0, -1.0, me.mID );
        me.DestroyInput( slot );
        me.mInputs[slot] = null;
        me.MakeHeader();
        return { mFailed:false, mNeedsShaderCompile:false };
    }
    else if( url.mType==="texture" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.image = new Image();
        texture.image.crossOrigin = '';
        texture.image.onload = function()
        {
            let rti = me.Sampler2Renderer(url.mSampler);

            // O.M.G. FIX THIS
            let channels = renderer.TEXFMT.C4I8;
            if (url.mID === "Xdf3zn" || url.mID === "4sf3Rn" || url.mID === "4dXGzn" || url.mID === "4sf3Rr")
                channels = renderer.TEXFMT.C1I8;
            
            texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.image, channels, rti.mFilter, rti.mWrap, rti.mVFlip);

            texture.loaded = true;
            if( me.mTextureCallbackFun!==null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.image, true, 1, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="volume" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mImage = { mData:null, mXres:1, mYres:0, mZres:0 };
        texture.mPreview = new Image();
        texture.mPreview.crossOrigin = '';

	    var xmlHttp = new XMLHttpRequest();
        if( xmlHttp===null ) return { mFailed:true };

        xmlHttp.open('GET', url.mSrc, true);
        xmlHttp.responseType = "arraybuffer";
        xmlHttp.onerror = function()
        {
            console.log( "Error 1 loading Volume" );
        }
        xmlHttp.onload = function()
        {
            let data = xmlHttp.response;
            if (!data ) { console.log( "Error 2 loading Volume" ); return; }

            let file = piFile(data);

            let signature = file.ReadUInt32();
            texture.mImage.mXres = file.ReadUInt32();
            texture.mImage.mYres = file.ReadUInt32();
            texture.mImage.mZres = file.ReadUInt32();
            let binNumChannels = file.ReadUInt8();
            let binLayout = file.ReadUInt8();
            let binFormat = file.ReadUInt16();
            let format = renderer.TEXFMT.C1I8;
                 if( binNumChannels===1 && binFormat===0 )  format = renderer.TEXFMT.C1I8;
            else if( binNumChannels===2 && binFormat===0 )  format = renderer.TEXFMT.C2I8;
            else if( binNumChannels===3 && binFormat===0 )  format = renderer.TEXFMT.C3I8;
            else if( binNumChannels===4 && binFormat===0 )  format = renderer.TEXFMT.C4I8;
            else if( binNumChannels===1 && binFormat===10 ) format = renderer.TEXFMT.C1F32;
            else if( binNumChannels===2 && binFormat===10 ) format = renderer.TEXFMT.C2F32;
            else if( binNumChannels===3 && binFormat===10 ) format = renderer.TEXFMT.C3F32;
            else if( binNumChannels===4 && binFormat===10 ) format = renderer.TEXFMT.C4F32;
            else return;

            let buffer = new Uint8Array(data, 20); // skip 16 bytes (header of .bin)

            let rti = me.Sampler2Renderer(url.mSampler);

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T3D, texture.mImage.mXres, texture.mImage.mYres, format, rti.mFilter, rti.mWrap, buffer);

            if( texture.globject===null )
            {
                console.log( "Error 4: loading Volume" ); 
                return { mFailed:true };
            }

            if (me.mTextureCallbackFun !== null)
            {
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }

            texture.loaded = true;

            // load icon for it
            texture.mPreview.onload = function()
            {
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }
            texture.mPreview.src = url.mPreviewSrc;
        }
        xmlHttp.send("");


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="volume")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="cubemap" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        let rti = me.Sampler2Renderer(url.mSampler);

        if( assetID_to_cubemapBuferID(url.mID)!==-1 )
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 2, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/cubemap00.png";

            this.mEffect.ResizeCubemapBuffer(0, 1024, 1024 );

        }
        else
        {
            texture.image = [ new Image(), new Image(), new Image(), new Image(), new Image(), new Image() ];

            let numLoaded = 0;
            for (var i=0; i<6; i++ )
            {
                texture.image[i].mId = i;
                texture.image[i].crossOrigin = '';
                texture.image[i].onload = function()
                {
                    var id = this.mId;
                    numLoaded++;
                    if( numLoaded===6 )
                    {
                        texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.CUBEMAP, texture.image, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                        texture.loaded = true;
                        if (me.mTextureCallbackFun !== null)
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, texture.image[0], true, 2, 1, -1.0, me.mID);
                    }
                }

                if( i === 0) 
                {
                    texture.image[i].src = url.mSrc;
                } 
                else 
                {
                    let n = url.mSrc.lastIndexOf(".");
                    texture.image[i].src = url.mSrc.substring(0, n) + "_" + i + url.mSrc.substring(n, url.mSrc.length);
                }
            }
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="cubemap")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="webcam" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        texture.video = document.createElement('video');
    	texture.video.width = 320;
    	texture.video.height = 240;
    	texture.video.autoplay = true;
    	texture.video.loop = true;
        texture.mForceMuted = this.mForceMuted;
        texture.mImage = null;

        let rti = me.Sampler2Renderer(url.mSampler);

        var loadImageInsteadOfWebCam = function()
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.mImage, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 7, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/webcam.png";
        }
        
        loadImageInsteadOfWebCam();

        if( typeof navigator.getUserMedia !== "undefined"  && texture.mForceMuted===false )
        {
            texture.video.addEventListener("canplay", function (e)
            {
				try
				{
                    texture.mImage = null;
                    if( texture.globject != null )
                        renderer.DestroyTexture( texture.globject );
					texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
					texture.loaded = true;
                }
                catch(e)
                {
                    loadImageInsteadOfWebCam();
	                alert( 'Your browser can not transfer webcam data to the GPU.');
                }
            } );

            navigator.mediaDevices.getUserMedia( 
                                { "video": { width: 1280, height: 720 }, "audio": false } )
                                .then( function(stream)
                                       {
                                            texture.video.srcObject = stream;
    	                               } )
                                .catch( function(error)
                                        {
                                            loadImageInsteadOfWebCam();
    		                                alert( 'Unable to capture WebCam. Please reload the page.' );
    	                                } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="mic" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mForceMuted = this.mForceMuted;
        texture.mAnalyser = null;
        let num = 512;
        texture.mFreqData = new Uint8Array( num );
        texture.mWaveData = new Uint8Array( num );

        if( wa === null || typeof navigator.getUserMedia === "undefined" )
        {
            if( !texture.mForceMuted ) alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.mForceMuted = true; 
        }

        if( texture.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, num, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)
            texture.loaded = true;
        }
        else
        {
        navigator.getUserMedia( { "audio": true },
                                function(stream)
                                {
                                  texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, null)
                                  texture.mic = wa.createMediaStreamSource(stream);
                                  texture.mAnalyser = wa.createAnalyser();
                                  texture.mic.connect( texture.mAnalyser );
                                  texture.loaded = true;
    	                        },
                                function(error)
                                {
    		                        alert( 'Unable open Mic. Please reload the page.' );
    	                        } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="video" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.video = document.createElement('video');
    	texture.video.loop = true;
        texture.video.preload = "auto";
        texture.video.mPaused = this.mForcePaused;
        texture.video.mMuted = true;//this.mForceMuted;
    	texture.video.muted  = true;//this.mForceMuted;
        if( this.mForceMuted===true )
            texture.video.volume = 0;
    	texture.video.autoplay = false;
        texture.video.hasFalled = false;
        
        let rti = me.Sampler2Renderer(url.mSampler);

        texture.video.addEventListener("canplay", function (e)
        {
            texture.video.play().then( function()
                                       {
                                           texture.video.mPaused = false;

                                           texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                                           texture.loaded = true;
            
                                           if( me.mTextureCallbackFun!=null )
                                               me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.video, true, 3, 1, -1.0, me.mID );
                                        } )
                               .catch( function(error)
                                       {
                                           console.log( error );
                                       }
                                );
        } );

        texture.video.addEventListener( "error", function(e)
        {
               if( texture.video.hasFalled===true ) { alert("Error: cannot load video" ); return; }
               let str = texture.video.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".mp4";
               texture.video.src = str;
               texture.video.hasFalled = true;
        } );

        texture.video.src = url.mSrc;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="music" || url.mType==="musicstream" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.audio = document.createElement('audio');
    	texture.audio.loop = true;
        texture.audio.mMuted = this.mForceMuted;
        texture.audio.mForceMuted = this.mForceMuted;
        texture.audio.muted = this.mForceMuted;
        if( this.mForceMuted===true )
            texture.audio.volume = 0;
        texture.audio.autoplay = false;
        texture.audio.hasFalled = false;
        texture.audio.mPaused = false;
        texture.audio.mSound = {};

        if( this.mForceMuted===false )
        {
            if(url.mType==="musicstream" && SC === null)
            {
                alert( "Shadertoy: Soundcloud could not be reached" );
                texture.audio.mForceMuted = true;
            }
            }

        if( wa === null && this.mForceMuted===false )
        {
            alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.audio.mForceMuted = true;
        }

        if( texture.audio.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null);
            let num = 512;
            texture.audio.mSound.mFreqData = new Uint8Array( num );
            texture.audio.mSound.mWaveData = new Uint8Array( num );
            texture.loaded = true;
        }

        texture.audio.addEventListener( "canplay", function()
        {
            if( texture===null || texture.audio===null ) return;
            if( this.mForceMuted  ) return;
            if( texture.loaded === true ) return;

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)

            texture.audio.mSound.mSource   = wa.createMediaElementSource( texture.audio );
            texture.audio.mSound.mAnalyser = wa.createAnalyser();
            texture.audio.mSound.mGain     = wa.createGain();

            texture.audio.mSound.mSource.connect(   texture.audio.mSound.mAnalyser );
            texture.audio.mSound.mAnalyser.connect( texture.audio.mSound.mGain );
            texture.audio.mSound.mGain.connect(me.mGainNode);

            texture.audio.mSound.mFreqData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );
            texture.audio.mSound.mWaveData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );

            if( texture.audio.mPaused )
            {
                texture.audio.pause();
            }
            else
            {
                texture.audio.play().then( function() {} ).catch( function(e){console.log("error " + e);} );
            }
            texture.loaded = true;
        } );

        texture.audio.addEventListener( "error", function(e)
        {
               if( this.mForceMuted  ) return;

               if( texture.audio.hasFalled===true ) { return; }
               let str = texture.audio.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".ogg";
               texture.audio.src = str;
               texture.audio.hasFalled = true;
        } );

        if( !texture.audio.mForceMuted )
        {
            if(url.mType==="musicstream")
            {
                SC.resolve(url.mSrc, 
                    function(song) 
                    {
                        if( song.streamable===true )
                        {
                            texture.audio.crossOrigin = 'anonymous';
                            texture.audio.src = song.stream_url;
                            texture.audio.soundcloudInfo = song;
                        }
                        else
                        {
                            alert('Shadertoy: Soundcloud 3 - This track cannot be streamed' );
                        }
                    },
                    function(error)
                    {
                        if (me.mTextureCallbackFun!==null)
                        {
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
                        }
                    } );
            } 
            else
            {
                texture.audio.src = url.mSrc;
            }
        }

        if (me.mTextureCallbackFun!==null)
        {
            if (url.mType === "music")            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
            else if (url.mType === "musicstream") me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null, info: texture.audio.soundcloudInfo}, false, 8, 0, -1.0, me.mID);
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="keyboard" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = true;

        texture.keyboard = {};

        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {mImage: keyboard.mIcon, mData: keyboard.mData}, false, 6, 1, -1.0, me.mID );

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="buffer" )
    {
        texture = {};
        texture.mInfo = url;

        texture.image = new Image();
        texture.image.onload = function()
        {
            if( me.mTextureCallbackFun!==null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {texture: texture.image, data:null}, true, 9, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;
        texture.id = assetID_to_bufferID( url.mID );
        texture.loaded = true;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;

        this.mEffect.ResizeBuffer(texture.id, this.mEffect.mXres, this.mEffect.mYres, false );

        this.SetSamplerFilter(slot, url.mSampler.filter, buffers, cubeBuffers, true);
        this.SetSamplerVFlip(slot, url.mSampler.vflip);
        this.SetSamplerWrap(slot, url.mSampler.wrap, buffers);

        this.MakeHeader();
        return returnValue;
    }
    else
    {
        alert( "input type error" );
        return { mFailed: true };
    }

    return { mFailed: true };
}

EffectPass.prototype.Paint_Image = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];

    //------------------------
    
    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];
    let texIsLoaded = [0, 0, 0, 0 ];
    let texID = [ null, null, null, null];

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
            texIsLoaded[i] = 1;
            resos[3*i+0] = 256;
            resos[3*i+1] = 3;
            resos[3*i+2] = 1;
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;

                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                }
            }
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {

                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                texIsLoaded[i] = 0;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    times[i] = 10.0 + time;
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            let id = inp.id;
            if( inp.loaded===true  )
            {
                texID[i] = buffers[id].mTexture[ buffers[id].mLastRenderDone ];
                texIsLoaded[i] = 1;
                resos[3*i+0] = xres;
                resos[3*i+1] = yres;
                resos[3*i+2] = 1;
                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID[i], filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    let prog = this.mProgram;

    //if( vrData!=null && this.mSupportsVR ) prog = this.mProgramVR;

    this.mRenderer.AttachShader(prog);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F("iFrameRate", fps);

    this.mRenderer.SetShaderConstant1F(  "iCh0.time", times[0] );
    this.mRenderer.SetShaderConstant1F(  "iCh1.time", times[1] );
    this.mRenderer.SetShaderConstant1F(  "iCh2.time", times[2] );
    this.mRenderer.SetShaderConstant1F(  "iCh3.time", times[3] );
    this.mRenderer.SetShaderConstant3F(  "iCh0.size", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iCh1.size", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iCh2.size", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iCh3.size", resos[9], resos[10], resos[11] );
    this.mRenderer.SetShaderConstant1I(  "iCh0.loaded", texIsLoaded[0] );
    this.mRenderer.SetShaderConstant1I(  "iCh1.loaded", texIsLoaded[1] );
    this.mRenderer.SetShaderConstant1I(  "iCh2.loaded", texIsLoaded[2] );
    this.mRenderer.SetShaderConstant1I(  "iCh3.loaded", texIsLoaded[3] );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    if( (vrData !== null) && this.mSupportsVR )
    {
        for (let i=0; i<2; i++ )
        {
            let ei = (i===0) ? vrData.mLeftEye : vrData.mRightEye;

            let vp = [i * xres / 2, 0, xres / 2, yres];

            this.mRenderer.SetViewport(vp);

            let fov = ei.mProjection;
            let corA = [ -fov[2], -fov[1], -1.0 ];
            let corB = [  fov[3], -fov[1], -1.0 ];
            let corC = [  fov[3],  fov[0], -1.0 ];
            let corD = [ -fov[2],  fov[0], -1.0 ];
            let apex = [ 0.0, 0.0, 0.0 ];

            let ma = invertFast( ei.mCamera );
            corA = matMulpoint( ma, corA ); 
            corB = matMulpoint( ma, corB ); 
            corC = matMulpoint( ma, corC ); 
            corD = matMulpoint( ma, corD ); 
            apex = matMulpoint( ma, apex ); 

            let corners = [ corA[0], corA[1], corA[2], 
                            corB[0], corB[1], corB[2], 
                            corC[0], corC[1], corC[2], 
                            corD[0], corD[1], corD[2],
                            apex[0], apex[1], apex[2]];

            this.mRenderer.SetShaderConstant3FV("unCorners", corners);
            this.mRenderer.SetShaderConstant4FV("unViewport", vp);

            this.mRenderer.DrawUnitQuad_XY(l1);
        }
    }
    else 
    {
        this.mRenderer.SetViewport([0, 0, xres, yres]);
        this.mRenderer.DrawFullScreenTriangle_XY( l1 );
    }

    this.mRenderer.DettachTextures();
}

EffectPass.prototype.iRenderSound = function(d, callback )
{
    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds() ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    this.mRenderer.SetRenderTarget(this.mRenderFBO);

    this.mRenderer.SetViewport([0, 0, this.mTextureDimensions, this.mTextureDimensions]);
    this.mRenderer.AttachShader(this.mProgram);
    this.mRenderer.SetBlend( false );

    let texID = [null, null, null, null];
    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
    }

    this.mRenderer.AttachTextures(4, texID[0], texID[1], texID[2], texID[3]);

    let l2 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iTimeOffset");
    let l3 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iSampleOffset");
    this.mRenderer.SetShaderConstant4FV("iDate", dates);
    this.mRenderer.SetShaderConstant3FV("iChannelResolution", resos);
    this.mRenderer.SetShaderConstant1F("iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit("iChannel0", 0);
    this.mRenderer.SetShaderTextureUnit("iChannel1", 1);
    this.mRenderer.SetShaderTextureUnit("iChannel2", 2);
    this.mRenderer.SetShaderTextureUnit("iChannel3", 3);

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    //--------------------------------
    let numSamples = this.mTmpBufferSamples;
    let numBlocks = this.mPlaySamples / numSamples;
    for (let j=0; j<numBlocks; j++ )
    {
        let off = j*numSamples;
        
        this.mRenderer.SetShaderConstant1F_Pos(l2, off / this.mSampleRate);
        this.mRenderer.SetShaderConstant1I_Pos(l3, off );
        this.mRenderer.DrawUnitQuad_XY(l1);

        this.mRenderer.GetPixelData(this.mData, 0, this.mTextureDimensions, this.mTextureDimensions);

        callback( off, this.mData, numSamples );
    }

    this.mRenderer.DetachShader();
    this.mRenderer.DettachTextures();
    this.mRenderer.SetRenderTarget(null);
}

EffectPass.prototype.Paint_Sound = function( wa, d )
{
    let bufL = this.mBuffer.getChannelData(0); // Float32Array
    let bufR = this.mBuffer.getChannelData(1); // Float32Array

    this.iRenderSound( d, function(off, data, numSamples)
                         {
                            for( let i=0; i<numSamples; i++ )
                            {
                                bufL[off+i] = -1.0 + 2.0*(data[4*i+0]+256.0*data[4*i+1])/65535.0;
                                bufR[off+i] = -1.0 + 2.0*(data[4*i+2]+256.0*data[4*i+3])/65535.0;
                            }
                         }
                     );
}

EffectPass.prototype.SetUniforms = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    //------------------------
    
    let texID = [ null, null, null, null];

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
        }
        else if( inp.mInfo.mType=="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
    
                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                }
            }

        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
           if( inp.loaded===true )
           { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                times[i] = 10.0 + time;
            }

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = buffers[inp.id].mTexture[ buffers[inp.id].mLastRenderDone ];
                resos[3*i+0] = buffers[inp.id].mResolution[0];
                resos[3*i+1] = buffers[inp.id].mResolution[1];
                resos[3*i+2] = 1;
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    this.mRenderer.AttachShader(this.mProgram);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F(  "iFrameRate", fps );

    this.mRenderer.SetShaderConstant1F(  "iChannel[0].time",       times[0] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[1].time",       times[1] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[2].time",       times[2] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[3].time",       times[3] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[0].resolution", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[1].resolution", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[2].resolution", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[3].resolution", resos[9], resos[10], resos[11] );
}

EffectPass.prototype.ProcessInputs = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
        }
        else if( inp.mInfo.mType==="volume" )
        {
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );
                }
                else if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                if( inp.audio.mForceMuted === true )
                {
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                let id = inp.id;
                let texID = buffers[id].mTexture[ buffers[id].mLastRenderDone ];

                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID, filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
				let id = inp.id;
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }
}

EffectPass.prototype.Paint_Cubemap = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face )
{
    this.ProcessInputs(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
    this.SetUniforms(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    let vp = [0, 0, xres, yres];

    this.mRenderer.SetViewport(vp);

    let corA = [-1.0, -1.0, -1.0];
    let corB = [ 1.0, -1.0, -1.0];
    let corC = [ 1.0,  1.0, -1.0];
    let corD = [-1.0,  1.0, -1.0];
    let apex = [ 0.0,  0.0,  0.0];

         if( face===0 ) { corA=[ 1.0,  1.0,  1.0]; corB=[ 1.0,  1.0, -1.0]; corC=[ 1.0, -1.0, -1.0]; corD=[ 1.0, -1.0,  1.0]; }
    else if( face===1 ) { corA=[-1.0,  1.0, -1.0]; corB=[-1.0,  1.0,  1.0]; corC=[-1.0, -1.0,  1.0]; corD=[-1.0, -1.0, -1.0]; }
    else if( face===2 ) { corA=[-1.0,  1.0, -1.0]; corB=[ 1.0,  1.0, -1.0]; corC=[ 1.0,  1.0,  1.0]; corD=[-1.0,  1.0,  1.0]; }
    else if( face===3 ) { corA=[-1.0, -1.0,  1.0]; corB=[ 1.0, -1.0,  1.0]; corC=[ 1.0, -1.0, -1.0]; corD=[-1.0, -1.0, -1.0]; }
    else if( face===4 ) { corA=[-1.0,  1.0,  1.0]; corB=[ 1.0,  1.0,  1.0]; corC=[ 1.0, -1.0,  1.0]; corD=[-1.0, -1.0,  1.0]; }
    else if( face===5 ) { corA=[ 1.0,  1.0, -1.0]; corB=[-1.0,  1.0, -1.0]; corC=[-1.0, -1.0, -1.0]; corD=[ 1.0, -1.0, -1.0]; }

    let corners = [ corA[0], corA[1], corA[2], 
                    corB[0], corB[1], corB[2], 
                    corC[0], corC[1], corC[2], 
                    corD[0], corD[1], corD[2],
                    apex[0], apex[1], apex[2]];

    this.mRenderer.SetShaderConstant3FV("unCorners", corners);
    this.mRenderer.SetShaderConstant4FV("unViewport", vp);

    this.mRenderer.DrawUnitQuad_XY(l1);

    this.mRenderer.DettachTextures();
}

EffectPass.prototype.Paint = function( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, bufferNeedsMimaps, buffers, cubeBuffers, keyboard, effect )
{
    if( this.mType==="sound" )
    {
        if (this.mSoundShaderCompiled === true)
        {
            // make sure all textures are loaded
            for (let i=0; i<this.mInputs.length; i++ )
            {
                let inp = this.mInputs[i];
                if (inp === null) continue;

                if (inp.mInfo.mType === "texture" && !inp.loaded) return;
                if (inp.mInfo.mType === "cubemap" && !inp.loaded) return;
            }

            this.Paint_Sound(wa, da);
            this.mSoundShaderCompiled = false;
        }
        if (this.mFrame === 0)
        {
            if (this.mPlaying===true)
            {
                this.mPlayNode.disconnect();
                this.mPlayNode.stop();
                this.mPlayNode = null;
            }
            this.mPlaying = true;

            this.mPlayNode = wa.createBufferSource();
            this.mPlayNode.buffer = this.mBuffer;
            this.mPlayNode.connect(this.mGainNode);
            this.mPlayNode.start(0);
        }
        this.mFrame++;
    }
    else if( this.mType==="image" )
    {
        this.mRenderer.SetRenderTarget( null );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );
        this.mFrame++;
    }
    else if( this.mType==="common" )
    {
    }
    else if( this.mType==="buffer" )
    {
        this.mEffect.ResizeBuffer(bufferID, this.mEffect.mXres, this.mEffect.mYres, false );

        let buffer = buffers[bufferID];

        let dstID = 1 - buffer.mLastRenderDone;

        this.mRenderer.SetRenderTarget( buffer.mTarget[dstID] );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }

        // make thumbnail
        //if( this.mTextureCallbackFun != null )
        /*
        {
            this.mRenderer.SetRenderTarget( buffer.mThumbnailRenderTarget );
            let v = [0, 0, buffer.mThumbnailRes[0], buffer.mThumbnailRes[1]];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            this.mRenderer.SetShaderConstant4FV("v", v);
            this.mRenderer.AttachTextures(1, buffer.mTexture[dstID], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);
            this.mRenderer.DettachTextures();
            this.mRenderer.DetachShader();
            this.mRenderer.GetPixelData( new Uint8Array(buffer.mThumbnailBuffer.data.buffer), buffer.mThumbnailRes[0], buffer.mThumbnailRes[1] );
            this.mRenderer.SetRenderTarget(null);
        }
        */
        buffers[bufferID].mLastRenderDone = 1 - buffers[bufferID].mLastRenderDone;
        this.mFrame++;
    }
    else if( this.mType==="cubemap" )
    {
        this.mEffect.ResizeCubemapBuffer(bufferID, 1024, 1024, false );

        let buffer = cubeBuffers[bufferID];

        xres = buffer.mResolution[0];
        yres = buffer.mResolution[1];
        let dstID = 1 - buffer.mLastRenderDone;
        for( let face=0; face<6; face++ )
        {
            this.mRenderer.SetRenderTargetCubeMap( buffer.mTarget[dstID], face );
            this.Paint_Cubemap( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
        }
        this.mRenderer.SetRenderTargetCubeMap( null, 0 );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }
        cubeBuffers[bufferID].mLastRenderDone = 1 - cubeBuffers[bufferID].mLastRenderDone;

        this.mFrame++;
    }
}

EffectPass.prototype.StopOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;
    this.mPlayNode.disconnect();
}

EffectPass.prototype.ResumeOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;

    wa.resume()
    this.mPlayNode.connect( this.mGainNode );
}

EffectPass.prototype.StopOutput_Image = function( wa )
{
}

EffectPass.prototype.ResumeOutput_Image = function( wa )
{
}

EffectPass.prototype.StopOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.StopInput(j);

    if( this.mType==="sound" )
         this.StopOutput_Sound( wa );
    else
         this.StopOutput_Image( wa );
}

EffectPass.prototype.ResumeOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.ResumeInput(j);

    if( this.mType==="sound" )
         this.ResumeOutput_Sound( wa );
    else
         this.ResumeOutput_Image( wa );
}

EffectPass.prototype.GetCompilationTime = function()
{
    return this.mCompilationTime;
}

//============================================================================================================
function Screenshots()
{
    // private
    let mTexture = null;
    let mTarget = null;
    let mXres = 0;
    let mYres = 0;
    let mCubemapToEquirectProgram;
    let mRenderer = null;

    // public
    var me = {};

    me.Initialize = function(renderer)
    {
        mRenderer = renderer;
        let caps = mRenderer.GetCaps();
        let is20 = caps.mIsGL20;

        let vsSourceC, fsSourceC;
        if( is20 )
        {
            vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; out vec4 outColor; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); outColor = texture(t, rd); }";
        }
        else
        {
            vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); gl_FragColor = texture(t, rd); }";
        }

        let compileShader = function (worked, info)
        {
            if (worked === false)
            {
                console.log("Failed to compile cubemap resample shader (" + errorType + "): " + log);
            }
            else
            {
                mCubemapToEquirectProgram = info;
            }
        }
        mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, compileShader);

        return true;
    };

    me.Allocate = function( xres, yres )
    {
        if( xres>mXres || yres>mYres )
        {
            let texture = mRenderer.CreateTexture(mRenderer.TEXTYPE.T2D, xres, yres, mRenderer.TEXFMT.C4F32, mRenderer.FILTER.NONE, mRenderer.TEXWRP.CLAMP, null);
            let target = mRenderer.CreateRenderTarget( texture, null, null, null, null, false);

            if( mXres!==0 )
            {
                mRenderer.DestroyTexture(mTexture);
                mRenderer.DestroyRenderTarget(mTarget);
            }

            mTexture = texture;
            mTarget = target;
            mXres = xres;
            mYres = yres;
        }
    };

    me.GetProgram = function()
    {
        return mCubemapToEquirectProgram;
    };
    me.GetTarget = function()
    {
        return mTarget;
    };

    return me;
};

//============================================================================================================

function Effect(vr, ac, canvas, callback, obj, forceMuted, forcePaused, resizeCallback, crashCallback )
{
    let xres = canvas.width;
    let yres = canvas.height;

    let me = this;
    this.mCanvas = canvas;
    this.mCreated = false;
    this.mRenderer = null;
    this.mAudioContext = ac;
    this.mGLContext = null;
    this.mWebVR = vr;
    this.mRenderingStereo = false;
    this.mXres = xres;
    this.mYres = yres;
    this.mForceMuted = forceMuted;
    if( ac===null ) this.mForceMuted = true;
    this.mForcePaused = forcePaused;
    this.mGainNode = null;
    this.mPasses = [];
    this.mFrame = 0;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mMaxBuffers = 4;
    this.mMaxCubeBuffers = 1;
    this.mMaxPasses = this.mMaxBuffers + 1 + 1 + 1 + 1; // some day decouple passes from buffers (4 buffers + common + Imagen + sound + cubemap)
    this.mBuffers = [];
    this.mCubeBuffers = [];
    this.mScreenshotSytem = null;
    this.mCompilationTime = 0;
    this.mIsLowEnd = piIsMobile();

    this.mGLContext = piCreateGlContext(canvas, false, false, true, false); // need preserve-buffe to true in order to capture screenshots
    if (this.mGLContext === null)
    {
        return;
    }

    canvas.addEventListener("webglcontextlost", function (event)
        {
            event.preventDefault();
            crashCallback();
        }, false);

    this.mRenderer = piRenderer();
    if (!this.mRenderer.Initialize(this.mGLContext))
        return;

    this.mScreenshotSytem = Screenshots();
    if (!this.mScreenshotSytem.Initialize(this.mRenderer))
        return;

    var caps = this.mRenderer.GetCaps();
    this.mIs20 = caps.mIsGL20;
    this.mShaderTextureLOD = caps.mShaderTextureLOD;
    //-------------
    if( ac!==null )
    {   
        this.mGainNode = ac.createGain();
        if( !forceMuted )
        {
            this.mGainNode.connect( ac.destination);
        }
        if (this.mForceMuted )
            this.mGainNode.gain.value = 0.0;
        else
            this.mGainNode.gain.value = 1.0;
    }

    //-------------
    let vsSourceC, fsSourceC;
    if( this.mIs20 )
    {
        vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { outColor = textureLod(t, gl_FragCoord.xy / v.zw, 0.0); }";
    }
    else
    {
        vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; void main() { gl_FragColor = texture2D(t, gl_FragCoord.xy / v.zw, -100.0); }";
    }

    this.mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, function(worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to copy buffers : " + info.mErrorStr);
            else me.mProgramCopy = info;
        });

    let vsSourceD, fsSourceD;
    if( this.mIs20 )
    {
        vsSourceD = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { vec2 uv = gl_FragCoord.xy / v.zw; outColor = texture(t, vec2(uv.x,1.0-uv.y)); }";
    }
    else
    {
        vsSourceD = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; void main() { vec2 uv = gl_FragCoord.xy / v.zw; gl_FragColor = texture2D(t, vec2(uv.x,1.0-uv.y)); }";
    }

    this.mRenderer.CreateShader(vsSourceD, fsSourceD, false, true, function (worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to downscale buffers : " + info.mErrorStr);
            else me.mProgramDownscale = info;
        });


    // set all buffers and cubemaps to null
    for( let i=0; i<this.mMaxBuffers; i++ )
    {
        this.mBuffers[i] = { mTexture: [null, null], 
                             mTarget:  [null, null], 
                             mResolution: [0, 0],
                             mLastRenderDone: 0,
                             mThumbnailRenderTarget: null,
                             mThumbnailTexture: null,
                             mThumbnailBuffer:  null,
                             mThumbnailRes: [0, 0] };
    }

    for( let i=0; i<this.mMaxCubeBuffers; i++ )
    {
        this.mCubeBuffers[i] = { mTexture: [null, null], 
                                mTarget:  [null, null], 
                                mResolution: [0, 0],
                                mLastRenderDone: 0,
                                mThumbnailRenderTarget: null,
                                mThumbnailTexture: null,
                                mThumbnailBuffer:  null,
                                mThumbnailRes: [0, 0] };
    }

    //-------

    let keyboardData = new Uint8Array( 256*3 );
    for (let j=0; j<(256*3); j++ ) { keyboardData[j] = 0; }
    let kayboardTexture = this.mRenderer.CreateTexture( this.mRenderer.TEXTYPE.T2D, 256, 3, this.mRenderer.TEXFMT.C1I8, this.mRenderer.FILTER.NONE, this.mRenderer.TEXWRP.CLAMP, null);
    let keyboardImage = new Image();
    if( callback!==null )
        keyboardImage.src = "/img/keyboard.png"; // don't load PNG if no UI 
    this.mKeyboard = { mData: keyboardData, mTexture: kayboardTexture, mIcon: keyboardImage };

    let iResize = function( xres, yres )
    {
        me.mCanvas.width = xres;
        me.mCanvas.height = yres;
        me.mXres = xres;
        me.mYres = yres;
        me.ResizeBuffers(xres, yres);
        resizeCallback(xres, yres);
    };

    let bestAttemptFallback = function()
    {
        let devicePixelRatio = window.devicePixelRatio || 1;
        let xres = Math.round(me.mCanvas.offsetWidth  * devicePixelRatio) | 0;
        let yres = Math.round(me.mCanvas.offsetHeight * devicePixelRatio) | 0;
        iResize(xres, yres);
    };

    if(!window.ResizeObserver)
    {
        console.log("WARNING: This browser doesn't support ResizeObserver.");
        bestAttemptFallback();
        window.addEventListener("resize", bestAttemptFallback);
    }
    else
    {
        this.mRO = new ResizeObserver( function(entries, observer)
        {
            var entry = entries[0];
            if (!entry['devicePixelContentBoxSize'])
            {
                observer.unobserve(me.mCanvas);
                console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (2)");
                bestAttemptFallback();
                window.addEventListener("resize", bestAttemptFallback);
            }
            else
            {
                let box = entry.devicePixelContentBoxSize[0];
                let xres = box.inlineSize;
                let yres = box.blockSize;
                iResize(xres, yres);
            }
        });
        try
        {
            this.mRO.observe(this.mCanvas, { box: ["device-pixel-content-box"] });
            //this.mRO.observe(this.mCanvas);
        }
        catch (e)
        {
            console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (1)");
            bestAttemptFallback();
            window.addEventListener("resize", bestAttemptFallback);
        }
    }

    this.mCreated = true;
}

Effect.prototype.ResizeCubemapBuffer = function(i, xres, yres )
{
    let oldXres = this.mCubeBuffers[i].mResolution[0];
    let oldYres = this.mCubeBuffers[i].mResolution[1];

    if( this.mCubeBuffers[i].mTexture[0]===null || oldXres !== xres || oldYres !== yres )
    {
        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);
        let target1 = this.mRenderer.CreateRenderTargetCubeMap( texture1, null, false);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target2 = this.mRenderer.CreateRenderTargetCubeMap( texture2, null, false);

        // Store new buffers
        this.mCubeBuffers[i].mTexture = [texture1,texture2], 
        this.mCubeBuffers[i].mTarget =  [target1, target2 ], 
        this.mCubeBuffers[i].mLastRenderDone = 0;
        this.mCubeBuffers[i].mResolution[0] = xres;
        this.mCubeBuffers[i].mResolution[1] = yres;
    }
}

Effect.prototype.ResizeBuffer = function( i, xres, yres, skipIfNotExists )
{
    if( skipIfNotExists && this.mBuffers[i].mTexture[0]===null ) return;

    let oldXres = this.mBuffers[i].mResolution[0];
    let oldYres = this.mBuffers[i].mResolution[1];

    if( oldXres !== xres || oldYres !== yres )
    {
        let needCopy = (this.mBuffers[i].mTexture[0]!==null);

        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[0].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[0].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[1].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[1].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target1 = this.mRenderer.CreateRenderTarget( texture1, null, null, null, null, false);
        let target2 = this.mRenderer.CreateRenderTarget( texture2, null, null, null, null, false);

        if( needCopy )
        {
            let v = [0, 0, Math.min(xres, oldXres), Math.min(yres, oldYres)];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            let vOld = [0, 0, oldXres, oldYres];
            this.mRenderer.SetShaderConstant4FV("v", vOld);

            // Copy old buffers 1 to new buffer
            this.mRenderer.SetRenderTarget(target1);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[0], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Copy old buffers 2 to new buffer
            this.mRenderer.SetRenderTarget(target2);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[1], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Deallocate old memory
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[0]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[0]);
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[1]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[1]);
            //this.mRenderer.DestroyTexture(this.mBuffers[i].thumbnailTexture);
        }

        // Store new buffers
        this.mBuffers[i].mTexture = [texture1,texture2], 
        this.mBuffers[i].mTarget =  [target1, target2 ], 
        this.mBuffers[i].mLastRenderDone = 0;
        this.mBuffers[i].mResolution[0] = xres;
        this.mBuffers[i].mResolution[1] = yres;
    }
}

Effect.prototype.saveScreenshot = function(passid)
{
    let pass = this.mPasses[passid];

    if( pass.mType === "buffer" )
    {
        let bufferID = assetID_to_bufferID( this.mPasses[passid].mOutputs[0] );

        let texture = this.mBuffers[bufferID].mTarget[ this.mBuffers[bufferID].mLastRenderDone ];

        let numComponents = 3;
        let width = texture.mTex0.mXres;
        let height = texture.mTex0.mYres;
        let type = "Float"; // Other options Float, Half, Uint
        let bytes = new Float32Array(width * height * 4 );//numComponents);
        this.mRenderer.GetPixelDataRenderTarget( texture, bytes, width, height );
        let blob = piExportToEXR(width, height, numComponents, type, bytes);

        // Offer download automatically to the user
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "cubemap" )
    {
        let xres = 4096;
        let yres = 2048;
        this.mScreenshotSytem.Allocate( xres, yres );

        let cubeBuffer = this.mCubeBuffers[0];

        let target = this.mScreenshotSytem.GetTarget();
        this.mRenderer.SetRenderTarget( target );

        let program = this.mScreenshotSytem.GetProgram();

        this.mRenderer.AttachShader(program);
        let l1 = this.mRenderer.GetAttribLocation(program, "pos");
        this.mRenderer.SetViewport( [0, 0, xres, yres] );
        this.mRenderer.AttachTextures(1, cubeBuffer.mTexture[ cubeBuffer.mLastRenderDone ], null, null, null);
        this.mRenderer.DrawUnitQuad_XY(l1);
        this.mRenderer.DettachTextures();
        this.mRenderer.SetRenderTarget( null );

        let data = new Float32Array(xres*yres*4);
        this.mRenderer.GetPixelDataRenderTarget( target, data, xres, yres );

        let blob = piExportToEXR(xres, yres, 3, "Float", data );
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "sound" )
    {
        let offset = 0;
        const bits = 16;
        const numChannels = 2;
        let words = new Int16Array(60*pass.mSampleRate*numChannels );

        pass.iRenderSound( new Date(), function(off, data, numSamples)
                                         {
                                            for( let i=0; i<numSamples; i++ )
                                            {
                                                words[offset++] = (data[4*i+0]+256.0*data[4*i+1]) - 32767;
                                                words[offset++] = (data[4*i+2]+256.0*data[4*i+3]) - 32767;
                                            }
                                         }
                                     );

        let blob = piExportToWAV( 60*pass.mSampleRate, pass.mSampleRate, bits, numChannels, words);

        piTriggerDownload("sound.wav", blob);
    }    
}

Effect.prototype.ResizeBuffers = function(xres, yres)
{
    for (let i=0; i<this.mMaxBuffers; i++ )
    {
        this.ResizeBuffer(i, xres, yres, true);
    }
}

Effect.prototype.IsEnabledVR = function ()
{
    if (this.mRenderingStereo) return true;
    return false;
}

Effect.prototype.EnableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( this.mRenderingStereo ) return;

    this.mRenderingStereo = true;
    this.mWebVR.Enable();
}

Effect.prototype.DisableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( !this.mRenderingStereo ) return;

    this.mRenderingStereo = false;
    this.mWebVR.Disable();
}

Effect.prototype.GetTexture = function( passid, slot ) { return this.mPasses[passid].GetTexture( slot ); }
Effect.prototype.NewTexture = function (passid, slot, url) { return this.mPasses[passid].NewTexture( this.mAudioContext, slot, url, this.mBuffers, this.mCubeBuffers, this.mKeyboard ); }
Effect.prototype.SetOutputs = function( passid, slot, url ) { this.mPasses[passid].SetOutputs( slot, url ); }
Effect.prototype.SetOutputsByBufferID = function( passid, slot, id ) { this.mPasses[passid].SetOutputsByBufferID( slot, id ); }
Effect.prototype.GetAcceptsLinear = function (passid, slot) { return this.mPasses[passid].GetAcceptsLinear(slot); }
Effect.prototype.GetAcceptsMipmapping = function (passid, slot) { return this.mPasses[passid].GetAcceptsMipmapping(slot); }
Effect.prototype.GetAcceptsWrapRepeat = function (passid, slot) { return this.mPasses[passid].GetAcceptsWrapRepeat(slot); }
Effect.prototype.GetAcceptsVFlip = function (passid, slot) { return this.mPasses[passid].GetAcceptsVFlip(slot); }
Effect.prototype.SetSamplerFilter = function (passid, slot, str) { this.mPasses[passid].SetSamplerFilter(slot, str, this.mBuffers, this.mCubeBuffers); }
Effect.prototype.GetTranslatedShaderSource = function (passid) { return this.mPasses[passid].GetTranslatedShaderSource(); }
Effect.prototype.GetSamplerFilter = function (passid, slot) { return this.mPasses[passid].GetSamplerFilter(slot); }
Effect.prototype.SetSamplerWrap = function (passid, slot, str) { this.mPasses[passid].SetSamplerWrap(slot, str, this.mBuffers); }
Effect.prototype.GetSamplerWrap = function (passid, slot) { return this.mPasses[passid].GetSamplerWrap(slot); }
Effect.prototype.SetSamplerVFlip = function (passid, slot, str) { this.mPasses[passid].SetSamplerVFlip(slot, str); }
Effect.prototype.GetSamplerVFlip = function (passid, slot) { return this.mPasses[passid].GetSamplerVFlip(slot); }

Effect.prototype.GetHeaderSize = function (passid)
{
    return this.mPasses[passid].mHeaderLength + 
           this.mRenderer.GetShaderHeaderLines(1);
}

Effect.prototype.ToggleVolume = function()
{
    this.mForceMuted = !this.mForceMuted;

    // outp
    if (this.mForceMuted)
        this.mGainNode.gain.value = 0.0;
    else
        this.mGainNode.gain.value = 1.0;

    // inp
    let num = this.mPasses.length;
    for( let j=0; j<num; j++ )
    {
        for( let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            if( this.mForceMuted )
                this.mPasses[j].MuteInput( this.mAudioContext, i );
            else
                this.mPasses[j].UnMuteInput( this.mAudioContext, i );
        }
    }

    return this.mForceMuted;
}

Effect.prototype.SetKeyDown = function( passid, k )
{
    if( this.mKeyboard.mData[ k + 0*256 ] == 255 ) return;

    this.mKeyboard.mData[ k + 0*256 ] = 255;
    this.mKeyboard.mData[ k + 1*256 ] = 255;
    this.mKeyboard.mData[ k + 2*256 ] = 255 - this.mKeyboard.mData[ k + 2*256 ];
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }
}

Effect.prototype.SetKeyUp = function( passid, k )
{
    this.mKeyboard.mData[ k + 0*256 ] = 0;
    this.mKeyboard.mData[ k + 1*256 ] = 0;
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }
}

Effect.prototype.StopOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].StopOutput( wa );
    }
}

Effect.prototype.ResumeOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].ResumeOutput( wa );
    }
}

Effect.prototype.PauseInput = function( passid, id )
{
    return this.mPasses[passid].TooglePauseInput( this.mAudioContext, id );
}

Effect.prototype.ToggleMuteInput = function( passid, id )
{
    return this.mPasses[passid].ToggleMuteInput( this.mAudioContext, id );
}

Effect.prototype.RewindInput = function( passid, id )
{
    this.mPasses[passid].RewindInput( this.mAudioContext, id );
}

Effect.prototype.UpdateInputs = function( passid, forceUpdate )
{
   this.mPasses[passid].UpdateInputs( this.mAudioContext, forceUpdate, this.mKeyboard );
}

Effect.prototype.ResetTime = function()
{
    this.mFrame = 0;
    this.mAudioContext.resume()

    let num = this.mPasses.length;
    for( let i=0; i<num; i++ )
    {
        this.mPasses[i].mFrame = 0;
        for( let j=0; j<this.mPasses[i].mInputs.length; j++ )
            this.mPasses[i].RewindInput(this.mAudioContext, j)
    }
}

Effect.prototype.RequestAnimationFrame = function (id)
{
    if (this.mRenderingStereo && this.mWebVR.IsPresenting())
    {
        this.mWebVR.RequestAnimationFrame(id);
    }
    else
    {
        requestAnimFrame(id);
    }
}

Effect.prototype.Paint = function(time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, isPaused)
{
    let wa = this.mAudioContext;
    let da = new Date();
    let vrData = null; if (this.mRenderingStereo) vrData = this.mWebVR.GetData();
    let xres = this.mXres / 1;
    let yres = this.mYres / 1;

    if( this.mFrame===0 )
    {
        for( let i=0; i<this.mMaxBuffers; i++ )
        {
            if( this.mBuffers[i].mTexture[0]!==null )
            {
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[0] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[1] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
				
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[0] );
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[1] );
            }
        }
        for( let i=0; i<this.mMaxCubeBuffers; i++ )
        {
            if( this.mCubeBuffers[i].mTexture[0]!==null )
            {
                for( let face=0; face<6; face++ )
                {
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[0], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[1], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
					this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[0] );
				    this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[1] );
                }
            }
        }
    }

    let num = this.mPasses.length;

    // render sound first
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "sound" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "buffer" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;
        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="buffer" && inp.id === bufferID && inp.mInfo.mSampler.filter === "mipmap")
                {
                    needMipMaps = true;
                    break;
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render cubemap buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "cubemap" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = 0;//assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;

        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="cubemap" )
                {
                    if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0 && inp.mInfo.mSampler.filter === "mipmap" )
                    {
                        needMipMaps = true;
                        break;
                    }
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render image last
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "image" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }   

    // erase keypresses
    for (let k=0; k<256; k++ )
    {
       this.mKeyboard.mData[ k + 1*256 ] = 0;
    }
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    if( this.mRenderingStereo ) this.mWebVR.Finish();

    this.mFrame++;
}

Effect.prototype.NewShader = function( passid, preventCache, onResolve )
{
    let commonSourceCodes = [];
    for (let i=0; i<this.mPasses.length; i++ )
    {
        if( this.mPasses[i].mType==="common")
        {
            commonSourceCodes.push(this.mPasses[i].mSource);
        }
    }

    this.mPasses[passid].NewShader(commonSourceCodes, preventCache, onResolve );
}

Effect.prototype.GetNumPasses = function()
{
    return this.mPasses.length;
}

Effect.prototype.GetNumOfType = function(passtype)
{
    let id = 0;
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType===passtype )
        {
            id++;
        }
    }
    return id;
}

Effect.prototype.GetPassType = function( id ) { return this.mPasses[id].mType; }
Effect.prototype.GetPassName = function( id ) { return this.mPasses[id].mName; }
Effect.prototype.GetCode = function( id ) { return this.mPasses[id].mSource; }
Effect.prototype.SetCode = function( id, source ) { this.mPasses[id].SetCode(source); }
Effect.prototype.GetError = function (id) { return this.mPasses[id].mError; }
Effect.prototype.GetErrorStr = function (id) { return this.mPasses[id].mErrorStr; }
Effect.prototype.GetErrorGlobal = function()
{
    for (let i = 0; i < this.mPasses.length; i++)
    {
        if (this.mPasses[i].mError)
        {
            return true;
        }
    }
    return false;
}

Effect.prototype.Load = function (jobj )
{
    if (jobj.ver !== "0.1")
    {
        console.log("Wrong Format");
        return false;
    }

    let numPasses = jobj.renderpass.length;

    if( numPasses<1 || numPasses>this.mMaxPasses )
    {
        console.log("Corrupted Shader - " + numPasses);
        return false;
    }

    this.mPasses = [];
    for (let j = 0; j < numPasses; j++)
    {
        let rpass = jobj.renderpass[j];

        // skip sound passes if in thumbnail mode
        if( this.mForceMuted && rpass.type === "sound" ) continue;

        let wpass = new EffectPass(this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                   this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode,
                                   this.mProgramDownscale, j, this);

        wpass.Create(rpass.type, this.mAudioContext);

        let numInputs = rpass.inputs.length;

        for (let i = 0; i < 4; i++)
        {
            wpass.NewTexture(this.mAudioContext, i, null, null, null);
        }
        for (let i = 0; i < numInputs; i++)
        {
            let lid  = rpass.inputs[i].channel;
            let styp = rpass.inputs[i].type;
            let sid  = rpass.inputs[i].id;
            let ssrc = rpass.inputs[i].filepath;
            let psrc = rpass.inputs[i].previewfilepath;
            let samp = rpass.inputs[i].sampler;

            wpass.NewTexture(this.mAudioContext, lid, { mType: styp, mID: sid, mSrc: ssrc, mSampler: samp, mPreviewSrc: psrc }, this.mBuffers, this.mCubeBuffers, this.mKeyboard);
        }

        for (let i = 0; i < 4; i++)
        {
            wpass.SetOutputs(i, null);
        }

        let numOutputs = rpass.outputs.length;
        for (let i = 0; i < numOutputs; i++)
        {
            let outputID = rpass.outputs[i].id;
            let outputCH = rpass.outputs[i].channel;
            wpass.SetOutputs(outputCH, outputID);
        }

        // create some hardcoded names. This should come from the DB
        let rpassName = "";
        if (rpass.type === "common" ) rpassName = "Common";
        if (rpass.type === "sound"  ) rpassName = "Sound";
        if (rpass.type === "image"  ) rpassName = "Image";
        if (rpass.type === "buffer") rpassName = "Buffer " + String.fromCharCode(65 + assetID_to_bufferID(wpass.mOutputs[0]));
        if (rpass.type === "cubemap") rpassName = "Cube A";// " + String.fromCharCode(65 + assetID_to_bufferID(this.mPasses[j].mOutputs[0]));
        wpass.SetName(rpassName);
        wpass.SetCode(rpass.code);

        this.mPasses.push(wpass);
    }
    return true;
}

Effect.prototype.CompileSome = function ( passes, preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    for (let j = 0; j < passes.length; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(passes[j], preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < me.mPasses.length; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.Compile = function (preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(j, preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < numPasses; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.GetCompilationTime = function( id )
{
    return this.mPasses[id].GetCompilationTime()/1000.0;
}
Effect.prototype.GetTotalCompilationTime = function()
{
    return this.mCompilationTime/1000.0;
}

Effect.prototype.DestroyPass = function( id )
{
   this.mPasses[id].Destroy( this.mAudioContext );
   this.mPasses.splice(id, 1);
}

Effect.prototype.AddPass = function( passType, passName, onResolve )
{
    let shaderStr = null;

    if( passType==="sound"   ) shaderStr = "vec2 mainSound( int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n}";
    if( passType==="buffer"  ) shaderStr = "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}";
    if( passType==="common"  ) shaderStr = "vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}";
    if( passType==="cubemap" ) shaderStr = "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rayDir;\n\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}";

    let id = this.GetNumPasses();
    this.mPasses[id] = new EffectPass( this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                       this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode, 
                                       this.mProgramDownscale, id, this );

    this.mPasses[id].Create( passType, this.mAudioContext );
    this.mPasses[id].SetName( passName );
    this.mPasses[id].SetCode( shaderStr );
    this.NewShader(id, false, function ()
    {
        onResolve();
    });

    return { mId : id, mShader : shaderStr };
}

// this should be removed once we have MultiPass 2.0 and passes render to arbitrary buffers
Effect.prototype.IsBufferPassUsed = function( bufferID )
{
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType !== "buffer" ) continue;
        if( this.mPasses[j].mOutputs[0] === bufferID_to_assetID(bufferID) ) return true;
    }
    return false;
}

Effect.prototype.Save = function()
{
    var result = {};

    result.ver = "0.1";

    result.renderpass = [];

    let numPasses = this.mPasses.length;
    for (let j=0; j<numPasses; j++ )
    {
        result.renderpass[j] = {};

        result.renderpass[j].outputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            let outputID = this.mPasses[j].mOutputs[i];
            if( outputID===null ) continue;
            result.renderpass[j].outputs.push( { channel: i, id: outputID } );
        }
        result.renderpass[j].inputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            if( this.mPasses[j].mInputs[i]===null ) continue;
            result.renderpass[j].inputs.push( {channel: i,
                                               type    : this.mPasses[j].mInputs[i].mInfo.mType,
                                               id      : this.mPasses[j].mInputs[i].mInfo.mID,
                                               filepath: this.mPasses[j].mInputs[i].mInfo.mSrc,
                                               sampler : this.mPasses[j].mInputs[i].mInfo.mSampler });
        }

        result.renderpass[j].code = this.mPasses[j].mSource;
        result.renderpass[j].name = this.mPasses[j].mName
        result.renderpass[j].description = "";
        result.renderpass[j].type = this.mPasses[j].mType;
    }

    result.flags = this.calcFlags();

    return result;
}

Effect.prototype.calcFlags = function ()
{
    let flagVR = false;
    let flagWebcam = false;
    let flagSoundInput = false;
    let flagSoundOutput = false;
    let flagKeyboard = false;
    let flagMultipass = false;
    let flagMusicStream = false;

    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        let pass = this.mPasses[j];

        if (pass.mType === "sound") flagSoundOutput = true;
        if (pass.mType === "buffer") flagMultipass = true;

        for (let i = 0; i < 4; i++)
        {
            if (pass.mInputs[i] === null) continue;

            if (pass.mInputs[i].mInfo.mType === "webcam") flagWebcam = true;
            else if (pass.mInputs[i].mInfo.mType === "keyboard") flagKeyboard = true;
            else if (pass.mInputs[i].mInfo.mType === "mic") flagSoundInput = true;
            else if (pass.mInputs[i].mInfo.mType === "musicstream") flagMusicStream = true;
        }

        let n1 = pass.mSource.indexOf("mainVR(");
        let n2 = pass.mSource.indexOf("mainVR (");
        if (n1 > 0 || n2 > 0) flagVR = true;
    }

    return {
        mFlagVR: flagVR,
        mFlagWebcam: flagWebcam,
        mFlagSoundInput: flagSoundInput,
        mFlagSoundOutput: flagSoundOutput,
        mFlagKeyboard: flagKeyboard,
        mFlagMultipass: flagMultipass,
        mFlagMusicStream: flagMusicStream
    };
}</script>
    <script>"use strict"

const kMaxCompileTime = 10.0;

function iReportCrash(shaderID)
{
    let req = new XMLHttpRequest();
    req.onload = function ()
    {
        let jsn = req.response;
        if (jsn === null) return;
        if (jsn.result === 0)
        {
            // yep
        }
    };
    req.open("POST", "/shadertoy", true);
    req.responseType = "json";
    req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    req.send( "s=" + shaderID + "&r=2" );
}
</script>
    <script>"use strict"

var gActive = -1;
var mShaders = [];
var gNumCanvases = 0;

function myrefresh( id, slot, img, forceFrame, gui, guiID, renderID, time )
{
    if( mShaders[id].mReady===false ) return;
    if( forceFrame )
    {
        if (mShaders[id].mScreenshot === false)
        {
            mShaders[id].gEffect.Paint(mShaders[id].mTime / 1000.0, 1.0 / 60.0, 60.0, 0, 0, 0, 0, false);
        }
    }
}

function startRendering()
{
    if( gActive<0 ) return;
    if( mShaders[gActive].mReady===false ) return;
    if( mShaders[gActive].mScreenshot===true ) return;

    let time = getRealTime();

    mShaders[gActive].mFPS.Count( time );
    mShaders[gActive].mTime = mShaders[gActive].mTime0 + (time - mShaders[gActive].mTo);
    let dtime = 1000.0/60.0;
    mShaders[gActive].gEffect.Paint( mShaders[gActive].mTime/1000.0, dtime/1000.0, mShaders[gActive].mFPS.GetFPS(), 0,0,0,0, false);

    requestAnimFrame( startRendering );
}

function iLoadAndCompile(jsn, i )
{
    var shaderObj = jsn[i];
    if (shaderObj === null) return;

    var resizeCB = function (xres, yres) { myrefresh(i, 0, null, true, false, 0, -1.0) };
    var crashCB = function () { alert('crash');/*iReportCrash(gShaderIDs[i])*/ };
    mShaders[i].gEffect = new Effect(null, null, mShaders[i].mPreview.mCanvas, myrefresh, i, true, true, resizeCB, crashCB);

    if (!mShaders[i].gEffect.Load(shaderObj)) return;

    mShaders[i].gEffect.Compile(false, function (worked)
    {
        if (worked === true)
        {
            previewShowRender(mShaders[i].mPreview);

            mShaders[i].mScreenshot = false;
            mShaders[i].mReady = true;
            mShaders[i].mTime = 10.0 * 1000.0;
            mShaders[i].mTime0 = 0.0;
            mShaders[i].mTo = 0.0;
            mShaders[i].mFPS = piCreateFPSCounter();
            mShaders[i].mPreview.mCanvas.addEventListener("mouseout", function (ev) { gActive = -1; }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseover", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.add('isVisible'); }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseout", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.remove('isVisible'); }, true);
            mShaders[i].mPreview.mCanvas.addEventListener("mouseover", function (ev)
            {
                let ele = piGetSourceElement(ev);
                if (ele.mId === undefined) return;

                gActive = ele.mId;
                if (!mShaders[gActive].mReady) return;
                let time = getRealTime();
                mShaders[gActive].mTo = time;
                mShaders[gActive].mTime0 = mShaders[gActive].mTime;
                mShaders[gActive].mFPS.Reset(time);

                startRendering();
            }, true);


            /*
            let compilationTime = mShaders[i].gEffect.GetTotalCompilationTime();
            if (compilationTime > kMaxCompileTime)
            {
                iReportCrash(mShaders[i].mShaderID);
            }*/

            myrefresh(i, null, null, true, false, 0, -1.0);
        }
        else
        {
            mShaders[i].mReady = false;
            previewShowError(mShaders[i].mPreview);
        }
    });
};


function iProcessShader( jsn, i )
{
    var shaderObj = jsn[i];
    if( shaderObj===null ) return;

    if ((shaderObj.info.usePreview === 0 && !gUseScreenshots) || (mShaders[i].mPreviewReady !== 1))
    {
        iLoadAndCompile(jsn, i);
    }
    else
    {
        mShaders[i].mScreenshot = true;
        if( shaderObj.info.usePreview === 1 )
            previewShowScreenshot(mShaders[i].mPreview, 1); // comp
        else if (gUseScreenshots)
            previewShowScreenshot(mShaders[i].mPreview, 2); // sett
    }

    if( i<(jsn.length-1) ) setTimeout( function(){iProcessShader(jsn,i+1);}, 10 );
}

function iInitUI(numCanvases, uiCallback, windowTitle)
{
    gNumCanvases = numCanvases;
    document.getElementById("mySearch").focus();

    //-----------------------------------------------------------------
    // window
    //-----------------------------------------------------------------
    if (windowTitle !== null) {
        document.title = windowTitle;
    }

    //-----------------------------------------------------------------
    // ui
    //-----------------------------------------------------------------
    var num = Math.min(gShaders.length, gNumCanvases);

    //var base = document.getElementsByClassName( "searchResult" );

    for (let i = 0; i < gNumCanvases; i++)
    {
        let pv = createPreview(i);

        if (i >= num) {
            previewHide(pv);
            continue;
        }

        let shaderID = gShaders[i].info.id;
        
        if (pv.mUI !== null && uiCallback !== null) {
            pv.mUI.addEventListener('click', function (ev) {
                uiCallback(shaderID);
                ev.preventDefault();
            }, false);
        }
        
        previewShowLoading(pv);
        
        mShaders[i] = {};
        mShaders[i].mShaderID = shaderID;
        mShaders[i].mPreview = pv;
        mShaders[i].mScreenshot = false;
        mShaders[i].mPreview.mLink.href = "/view/" + shaderID;
        mShaders[i].mPreviewReady = 0;
        mShaders[i].mReady = false;
        mShaders[i].gEffect = null;

        previewLoadScreenshot(mShaders[i].mPreview,
            function () { mShaders[i].mPreviewReady = 1; if (mShaders[i].mReady === false) previewShowScreenshot(mShaders[i].mPreview, 0); },
            function () { mShaders[i].mPreviewReady = 2; },
            shaderID);
    }

    if (num <= 0) {
        return;
    }
}

function iInitShaders(jsn)
{
    for (let i = 0; i < jsn.length; i++)
    {
        let shaderObj = jsn[i];
        if (shaderObj === null) continue;
        let inf = shaderObj.info;
        mShaders[i].mPreview.mTextA.textContent = inf.name;
        mShaders[i].mPreview.mTextB.innerHTML = "<a class='user' href='/user/" + htmlEntities(inf.username) + "'>" + htmlEntities(inf.username) + "</a>";
        mShaders[i].mPreview.mTextC.innerHTML = "<img src='/img/themes/" + gThemeName + "/views.png' class='viewsIcon'></img>" + inf.viewed + "    &nbsp;&nbsp;  <img src='/img/themes/" + gThemeName + "/likes.png' class='likesIcon'></img>" + inf.likes;
    }

    setTimeout(function () { iProcessShader(jsn, 0); }, 10);
}

function resultsInitStatic(numCanvases, uiCallback, windowTitle)
{
    iInitUI(numCanvases, uiCallback, windowTitle);

    iInitShaders(gShaders);
}

function resultsInit(numCanvases, uiCallback, windowTitle)
{	
    iInitUI(numCanvases, uiCallback, windowTitle);

    var num = Math.min(gShaderIDs.length, gNumCanvases);

    var mHttpReq = new XMLHttpRequest();

    mHttpReq.abort();

    var str = "{ \"shaders\" : [";
    for( let i=0; i<num; i++ )
    {
         str += "\"" + gShaderIDs[i] + "\"";
         if( i!==(num-1) ) str += ", ";
    }
    str += "] }";

    str = "s=" + encodeURIComponent( str ) + "&nt=0&nl=0&np=0";

    mHttpReq.open( "POST", "/shadertoy", true );
    mHttpReq.responseType = "json";
    mHttpReq.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    mHttpReq.onload = function ()
    {
        let jsn = this.response;
        if( jsn===null )
        {
            console.log( "Could not load shaders" );
            return;
        }

        iInitShaders(jsn);
    }
    mHttpReq.send( str );
}</script>
    <style>
    .shaderPreview
    {
    display: block;
    background-color: #000000;
    background-image: url("/img/loading.gif");
    background-repeat: no-repeat;
    background-position: center;
    padding: 0px;
    margin: 0px;
    border: 0px solid #000000;
    border-radius: 8px;
    width:100%;
    height:100%;
    position: absolute;
    overflow:hidden;
    }

    .previewInfo
    {
    width: 100%;
    left: 0px;
    top: 2px;
    position: relative;
    visibility: hidden;
    }

    .previewCanvas
    {
    left: 0px;
    top: 0px;
    padding: 0px;
    margin: 0px;
    position: absolute;
    cursor: pointer;
    width:100%;
    height:100%;
    border-radius: 8px;
    border: 0px solid #000000;
    backgroundColor: transparent;
visibility: hidden;
opacity:0;
transition: opacity 1.0s ease;
    }

    .previewText
    {
        text-overflow: ellipsis;
    white-space: nowrap;
    padding-right: 1px;
    }

    .previewTextUser
    {
    text-overflow: ellipsis;
    white-space: nowrap;
    padding-left: 3px;
    }

    .previewStats
    {
    padding-right: 1px;
    right: 0px;
    top: 0px;
    position: absolute;
    }

    .previewErrorContainer
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    visibility:hidden;
    }

    .previewErrorMessage
    {
    top:50%;
    position:absolute;
    width:100%;
    text-align:center;
    padding:0;
    margin:auto;
    color:#ff0000;
    font-size:2em;
    font-style:italic;
    }

    .previewNoGLContainter
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    position:absolute;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    pointer-events:none;
    visibility:hidden;
    font-size:2em;
    }

    .previewNoGLMessage
    {
    width:86%;
    height:90%;
    padding-left:7%;
    padding-right:7%;
    padding-top:10%;
    padding-bottom:0px;
    color:#ff0000;
    position:absolute;
    visibility:hidden;
    }

    .previewThumbnailContainer
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    visibility:hidden;
    border-radius:8px;
    border:0px solid #000000;
    }

    .previewThumbnailImage
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    border-radius:8px;
    border:0px solid #000000;
opacity: 0.0;
transition: opacity 1.0s ease;
    }

    .previewThumbnailIcon
    {
    width:64px;
    height:32px;
    left:0px;
    top:0px;
    padding:0px;
    padding-top:12px;
    margin:0px;
    position:absolute;
    color:#ffffff;
    background-color:#ff8020;
    font-weight:bold;
    border-radius:0px 0px 8px 0px;
    text-align:center;
    //visibility:hidden;
    }


    .previewUIContainter
    {
    display: block;
    right:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    //cursor:pointer;
    //pointer-events:none;
    //visibility:hidden;
    }
</style>

<script>
    function previewHide(me)
    {
    me.mBase.style.visibility = "hidden";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";
    }

    function previewShowRender(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "visible";
me.mCanvas.style.opacity = 1.0;
    me.mCanvas.style.borderRadius ="8px;";
//  me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    }

    function previewShowScreenshot(me, message)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "visible";
me.mThumbnailImg.style.opacity = 1.0;
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    me.mThumbnailWar1.style.visibility = (message===1)?"visible":"hidden";
    me.mThumbnailWar2.style.visibility = (message===2)?"visible":"hidden";
    }

    function previewShowLoading(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";

    me.mLink.style.visibility = "visible";
    me.mBase.style.backgroundColor = "#ff0000;"
    me.mCont.style.visibility = "visible";
    }

    function previewShowNoWebGL(me, shaderID)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "visible";
    me.mError.style.visibility = "visible";
    me.mThumbnailImgNoWebGL.onerror = function(ev) 
                                      { 
                                            me.mThumbnailImgNoWebGL.style.visibility="hidden"; 
                                            me.mMessageNoWebGL.style.visibility="visible"; 
                                      };
    me.mThumbnailImgNoWebGL.src = "/media/shaders/" + shaderID + ".jpg";
    }

    function previewShowError(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "visible";
    me.mCont.style.visibility = "visible";
    }

    function previewLoadScreenshot( me, cbSuccess, cbError, shaderID )
    {
    var url = "/media/shaders/" + shaderID + ".jpg";
    me.mThumbnailImg.onload = cbSuccess;
    me.mThumbnailImg.onerror = function(ev) { cbError(); };
    me.mThumbnailImg.src = url;
    }
        
    function createPreview(id)
    {
        var bar = document.getElementById( "Preview_"+id+"_Canvas" );
        bar.width = bar.offsetWidth;
        bar.height = bar.offsetHeight;
        bar.mId = id;

        return { mBase: document.getElementById( "Preview_"+id+"_Container" ),
        mLink: document.getElementById( "Preview_"+id+"_Link" ),
        mCanvas: bar,
        mCont: document.getElementById( "Preview_"+id+"_Info" ),
        mTextA: document.getElementById( "Preview_"+id+"_Text" ),
        mTextB: document.getElementById( "Preview_"+id+"_TextUser" ),
        mTextC: document.getElementById( "Preview_"+id+"_Stats" ),
        mNoWebGL: document.getElementById( "Preview_"+id+"_NoWebGL" ),
        mError: document.getElementById( "Preview_"+id+"_Error" ),
        mCanvas2D: document.getElementById( "Preview_"+id+"_Thumnail" ),
        mThumbnailImg: document.getElementById( "Preview_"+id+"_ThumnailImage" ),
        mThumbnailWar1: document.getElementById( "Preview_"+id+"_ThumnailWarning1" ),
        mThumbnailWar2: document.getElementById( "Preview_"+id+"_ThumnailWarning2" ),
        mThumbnailImgNoWebGL: document.getElementById( "Preview_"+id+"_ThumnailImageNoWebGL" ),
        mMessageNoWebGL: document.getElementById( "Preview_"+id+"_MessageNoWebGL"),
        mUI: document.getElementById( "Preview_"+id+"_UI" )
        };
    }
</script>

    <style>

    div#shaderGrid
    {
        width:100%;
        padding:0px;
        margin:0px;
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        grid-template-rows: repeat(3, 1fr);
        grid-column-gap: 64px;
        grid-row-gap: 24px;
    }
    .searchResult
    {
        margin: 0px;
        padding: 0px;
        width: 100%;
    }
    .searchResultContainer
    {
        width: 100%;
        padding-bottom:56.25%;
        height: 0;
        position: relative;
    }
    .navigation
    {
        display:flex;
        align-items:center;
    }
    div#navBottom
    {
        display:none;
        justify-content:center;
    }
    a.pageButtons, .pageButtonsCurrent
    {
        border-style: solid;
        border-width: 1px;
        border-color: #808080;
        text-align: center;
        vertical-align: middle;
        margin-left: 12px;
        display: inline-block;
        border-radius: 4px;
		font-weight:bold;
        cursor: pointer;
        padding-bottom:5px;
        padding-top:4px;
        padding-left: 8px;
        padding-right: 8px;
        margin:8px;
    }
    a.pageButtons
    {
        text-decoration: none;
        -moz-transition:    background-color 0.15s linear, color 0.15s linear;
        -webkit-transition: background-color 0.15s linear, color 0.15s linear;
        transition:         background-color 0.15s linear, color 0.15s linear;
    }
    a.pageButtons:hover
    {
      background-color:#808080;
      color : #ff8020;
    }
    .pageButtonsCurrent
    {
        background-color: #808080;
        color:#000000;
    }
    div#controls
    {
        width:100%;
        padding-top:16px;
        padding-bottom:16px;
        display:flex;
        justify-content:space-between; 
        flex-wrap:wrap;
    }
    div#controls > div
    {
        display:inline-flex;
    }
    .controlOptions
    {
        display:inline-block;
    }

    /* ----------------------- media resolutions ------------------------ */

    @media screen and (max-width:799px) 
    {
        div#shaderGrid  { grid-template-columns: 1fr; grid-template-rows: repeat(12, 1fr); grid-column-gap: 0px; grid-row-gap: 16px; }
        div#controls
        {
            width:100%;
            display:flex;
            justify-content:flex-start; 
            flex-wrap:wrap;
        }
        div#controls > div
        {
            display:inline-flex;
            width:100%;
            margin-left: 0px;
            margin-right: 0px;
            padding-bottom:16px;
        }
        div#navBottom
        {
            display: flex;
        }
    }
    
    </style>
    <script>
    var gShaders=[{"ver":"0.1","info":{"id":"4tyXDR","date":"1483851959","viewed":9433,"name":"Reflect Refract TIR Fresnel RayT","username":"demofox","description":"A raytracer to go along with a blog post about reflection, refraction, total internal reflection and fresnel.\nDrag mouse for orbit camera.\nPlay with #define parameters.\nhttp:\/\/blog.demofox.org\/2017\/01\/09\/raytracing-reflection-refraction-fresnel-total-inte","likes":104,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"\/media\/a\/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"\/media\/ap\/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/*\n  Written by Alan Wolfe\n  http:\/\/demofox.org\/\n  http:\/\/blog.demofox.org\/\n\n  My blog post talking about the techniques in this shadertoy:\n  http:\/\/blog.demofox.org\/2017\/01\/09\/raytracing-reflection-refraction-fresnel-total-internal-reflection-and-beers-law\/\n*\/\n\n\/\/ A great read on all this stuff:\n\/\/ https:\/\/graphics.stanford.edu\/courses\/cs148-10-summer\/docs\/2006--degreve--reflection_refraction.pdf\n\n\/\/ refractive index of some common materials:\n\/\/ http:\/\/hyperphysics.phy-astr.gsu.edu\/hbase\/Tables\/indrf.html\n#define REFRACTIVE_INDEX_OUTSIDE 1.00029\n#define REFRACTIVE_INDEX_INSIDE  1.125\n\n\/\/ lighting parameters\n#define LIGHT_DIRECTIONAL_DIR   normalize(-vec3(1.0,2.0,1.0))\n#define LIGHT_DIRECTIONAL_COLOR vec3(1.0)\n#define LIGHT_AMBIENT           vec3(0.1)\n\n\/\/ object type\n#define OBJECT_TYPE 0 \/\/ 0 = sphere, 1 = box, 2 = geometric gem shape\n\n\/\/ object color parameters\n#define OBJECT_DIFFUSE      vec3(0.0)\n#define OBJECT_SPECPOWER    0.0\n#define OBJECT_REFLECTIVITY 0.01 \/\/ How reflective the object is. regardless of fresnel.\n#define OBJECT_ABSORB       vec3(8.0, 8.0, 3.0) \/\/ for beers law\n\n\/\/ object surface parameters\n#define DO_REFRACTION 1  \/\/ 0 to turn off refraction\n#define DO_REFLECTION 1  \/\/ 0 to turn off reflection\n#define DO_FRESNEL    1  \/\/ 0 to turn off fresnel. fresnel will only show up if reflection is also on.\n\n\/\/ rendering params\n#define DO_AA           1  \/\/ 0 to turn off 16x jittered SSAA\n#define MAX_RAY_BOUNCES 10 \/\/ For box, 2 seems to be max that makes a difference. For sphere, 1 seems to be!\n\n\/\/ hash21 from https:\/\/www.shadertoy.com\/view\/4djSRW\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n\/\/----------------------------------------------------------------------------------------\n\/\/  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n\/\/============================================================\n\/\/ this is ibox() from https:\/\/www.shadertoy.com\/view\/ld23DV\n\/\/ Just renamed some things to be more clear and minimized to needed functionality\n\/\/ returns t and normal\nvec4 RayIntersectBox ( in vec3 rayOrigin, in vec3 rayDirection, in vec3 boxHalfSizes, out vec2 uv ) \n{\n\t\/\/ ray-box intersection\n    vec3 m = 1.0\/rayDirection;    \/\/ how many steps on each axis to travel 1 unit on that axis\n    vec3 n = m*rayOrigin;         \/\/ how many steps on each axis the ray origin is from the object origin\n    vec3 k = abs(m)*boxHalfSizes; \/\/ how many steps on each axis it takes to get from the center of the box to the edge\n\t\n    vec3 t1 = -n - k;   \/\/ how many steps on each axis to get from the ray origin to the negative surface of the box.\n    vec3 t2 = -n + k;   \/\/ how many steps on each axis to get from the ray origin to the positive surface of the box.\n\n\tfloat timeNear = max( max( t1.x, t1.y ), t1.z );\n\tfloat timeFar = min( min( t2.x, t2.y ), t2.z );\n\n\tif( timeNear > timeFar || timeFar < 0.0)\n        return vec4(-1.0);\n\n\t\/\/vec3 normal = -sign(rayDirection)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    \n    if (timeNear < 0.0)\n        timeNear = timeFar;\n    \n    vec3 relPoint = rayOrigin + rayDirection * timeNear;\n    \n    vec3 absRelPoint = abs(relPoint) \/ boxHalfSizes;\n    \n    vec3 normal;\n    vec3 uaxis;\n    vec3 vaxis;\n    \/\/ if Y isn't the biggest value it can't be the normal axis\n    if (absRelPoint.x >= absRelPoint.y)\n    {\n        \/\/ if X is the winner\n        if (absRelPoint.x >= absRelPoint.z)\n        {\n            normal = vec3(1.0, 0.0, 0.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(0.0,1.0,0.0);\n\t\t\tvaxis = vec3(0.0,0.0,1.0);            \n        }\n        \/\/ else it's Z\n        else\n        {\n            normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,1.0,0.0);            \n        }\n    }\n    \/\/ else X isn't the biggest value so it can't be the normal axis\n    else\n    {\n        \/\/ if Y is the winner\n        if (absRelPoint.y >= absRelPoint.z)\n        {\n            normal = vec3(0.0, 1.0, 0.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,0.0,1.0);\t           \n        }\n        \/\/ else it's Z\n        else\n        {\n            normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,1.0,0.0);            \n        }        \n    }\n    \n\tuv = vec2\n\t(\n\t\tdot(relPoint, uaxis),\n\t\tdot(relPoint, vaxis)\n\t);    \n\n\treturn vec4( timeNear, normal );    \n}\n\n\/\/============================================================\n\/\/ returns t and surface normal\n\/\/ sphere xyz = position, w = radius\nvec4 RayIntersectSphere (in vec3 rayPos, in vec3 rayDir, in vec4 sphere)\n{\n\t\/\/get the vector from the center of this circle to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    \/\/get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t\/\/exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn vec4(-1.0);\n\n\t\/\/calculate discriminant\n\tfloat discr = b * b - c;\n\n\t\/\/a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn vec4(-1.0);\n\n\t\/\/ray now found to intersect sphere, compute smallest t value of intersection\n\tfloat normalMultiplier = 1.0;\n\tfloat collisionTime = -b - sqrt(discr);\n    if (collisionTime < 0.0)\n    {\n        collisionTime = -b + sqrt(discr);\n        normalMultiplier = -1.0;\n    }\n    \n    \/\/ calculate the normal, flipping it if we hit the inside of the sphere\n    vec3 normal = normalize((rayPos+rayDir*collisionTime) - sphere.xyz) * normalMultiplier;\n    \n    \/\/ return the time t that the collision happened, as well as the surface normal\n    return vec4 (collisionTime, normal);\n}\n\n\/\/============================================================\n\/\/ returns t and surface normal\n\/\/ plane xyz = normal, w = d\n\/\/ from https:\/\/www.cs.princeton.edu\/courses\/archive\/fall00\/cs426\/lectures\/raycast\/sld017.htm\nvec4 RayIntersectPlane (in vec3 rayPos, in vec3 rayDir, in vec4 plane, out vec2 uv)\n{   \n    float collisionTime = -(dot(rayPos, plane.xyz)+plane.w) \/ dot(rayDir, plane.xyz);\n    vec3 uaxis = normalize(cross(plane.xyz, vec3(0.0, 1.0, 0.0)));\n    vec3 vaxis = normalize(cross(plane.xyz, uaxis));\n    vec3 collisionPos = rayPos + rayDir * collisionTime;\n    uv.x = dot(collisionPos, uaxis);\n    uv.y = dot(collisionPos, vaxis);    \n    return vec4(collisionTime, plane.xyz);\n}\n\n\/\/============================================================\nvoid TrimRayInterval (vec3 rayPos, vec3 rayDir, inout vec2 rayMinMax, vec4 plane, inout vec3 nearNormal, inout vec3 farNormal)\n{\n    vec2 uv;\n    vec4 rayInfo = RayIntersectPlane(rayPos, rayDir, plane, uv);   \n    if (dot(rayInfo.yzw, rayDir) < 0.0)\n    {\n        if (rayInfo.x > rayMinMax.x)\n        {\n            rayMinMax.x = rayInfo.x;\n            nearNormal = rayInfo.yzw;\n        }\n    }\n    else\n    {\n        if (rayInfo.x < rayMinMax.y)\n        {\n            rayMinMax.y = rayInfo.x;\n            farNormal = rayInfo.yzw;\n        }\n    }\n}\n\n\/\/============================================================\nvec4 RayIntersectObject (in vec3 rayPos, in vec3 rayDir)\n{\n    #if OBJECT_TYPE == 0\n    \treturn RayIntersectSphere(rayPos, rayDir, vec4(0.0, 0.0, 0.0, 0.5));\n    #elif OBJECT_TYPE == 1\n    \tvec2 uv;\n    \tvec4 ret = RayIntersectBox(rayPos, rayDir, vec3(0.5), uv);\n    \tif (dot(rayDir, ret.yzw) > 0.0)\n            ret.yzw *= -1.0;\n    \treturn ret;\n    #else\n    \tvec2 rayMinMax = vec2(-1.0, 1000.0);\n    \tvec3 nearNormal;\n    \tvec3 farNormal;\n    \n    \tfloat size = -0.5;\n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 1.0, 0.2, -0.4)), size), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3(-1.0, 0.2, -0.4)), size), nearNormal, farNormal);   \n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0, 1.0,  1.0)), size*0.5), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0,-1.0,  0.0)), size), nearNormal, farNormal);   \n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0,-0.3,  1.0)), size), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0, 0.3, -1.0)), size), nearNormal, farNormal);     \n\n    \tif (rayMinMax.x > rayMinMax.y)\n            return vec4(-1.0);\n    \n    \tif (rayMinMax.x > 0.0)\n    \t\treturn vec4(rayMinMax.x, nearNormal);\n    \telse\n            return vec4(rayMinMax.y, -farNormal);\n    #endif\n}\n\n\/\/============================================================\nvec3 Checkerboard (vec2 uv)\n{\n    return vec3(mod(floor(uv.x * 4.0) + floor(uv.y * 4.0), 2.0) < 1.0 ? 1.0 : 0.4);\n}\n\n\/\/============================================================\nvec3 LightPixel (vec3 rayPos, vec3 rayDir, vec3 diffuse, vec3 normal, float specPower, bool doShadow)\n{   \n    \/\/ ambient\n    vec3 pixelColor = diffuse * LIGHT_AMBIENT;\n    \n    \/\/ see if we are in shadow by casting in the light direction and seeing if we hit the object.\n    \/\/ if we do hit the object, return just the ambient lighting shaded color we have already calculated.\n    if (doShadow && normal.y >= 0.9 && RayIntersectObject(rayPos, -LIGHT_DIRECTIONAL_DIR).x >= 0.0)\n        return pixelColor;\n    \n    \/\/ diffuse\n    float dp = clamp(dot(normal, -LIGHT_DIRECTIONAL_DIR), 0.0, 1.0);\n    pixelColor += diffuse * dp * LIGHT_DIRECTIONAL_COLOR;\n    \n    \/\/ specular highlight\n    if (specPower > 0.0)\n    {\n    \tvec3 reflection = reflect(-LIGHT_DIRECTIONAL_DIR, normal);\n    \tdp = clamp(dot(rayDir, reflection), 0.0, 1.0);\n\t\tpixelColor += LIGHT_DIRECTIONAL_COLOR * pow(dp, specPower);    \n    }\n    \n    return pixelColor;\n}\n\n\/\/============================================================\nfloat FresnelReflectAmount (float n1, float n2, vec3 normal, vec3 incident)\n{\n    #if DO_FRESNEL\n        \/\/ Schlick aproximation\n        float r0 = (n1-n2) \/ (n1+n2);\n        r0 *= r0;\n        float cosX = -dot(normal, incident);\n        if (n1 > n2)\n        {\n            float n = n1\/n2;\n            float sinT2 = n*n*(1.0-cosX*cosX);\n            \/\/ Total internal reflection\n            if (sinT2 > 1.0)\n                return 1.0;\n            cosX = sqrt(1.0-sinT2);\n        }\n        float x = 1.0-cosX;\n        float ret = r0+(1.0-r0)*x*x*x*x*x;\n\n        \/\/ adjust reflect multiplier for object reflectivity\n        ret = (OBJECT_REFLECTIVITY + (1.0-OBJECT_REFLECTIVITY) * ret);\n        return ret;\n    #else\n    \treturn OBJECT_REFLECTIVITY;\n    #endif\n}\n\n\/\/============================================================\nvec3 GetSceneRayColor (in vec3 rayPos, in vec3 rayDir)\n{\n    \/\/ Returns the lit RGB for this ray intersecting with the scene, ignoring the main object.\n    \/\/ Used for reflection off the surface of the object, and refraction out the back of the object.\n    \n    \/\/ if we hit the box, return the lit box color\n    vec2 uv;\n    vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\n    if (rayInfo.x >= 0.0)\n        return LightPixel(rayPos + rayDir*rayInfo.x, rayDir, Checkerboard(uv), rayInfo.yzw, 100.0, true);\n    \/\/ else return skybox color\n    else\n        return texture(iChannel0, rayDir).rgb;\n}\n\n\/\/============================================================\nvec3 GetObjectInternalRayColor (in vec3 rayPos, in vec3 rayDir)\n{\n    \/\/ bounce around inside the object as many times as needed (or until max bounces) due total internal reflection\n    float multiplier = 1.0;\n    vec3 ret = vec3(0.0);\n    float absorbDistance = 0.0;\n\tfor (int i = 0; i < MAX_RAY_BOUNCES; ++i)\n    {\n        \/\/ try and intersect the object\n    \tvec4 rayInfo = RayIntersectObject(rayPos, rayDir);\n        \n        \/\/ should \"never\" happen but handle it anyways\n    \tif (rayInfo.x < 0.0)  \n            return ret;\n        \n        \/\/ move the ray position to the intersection point.\n        rayPos = rayPos + rayDir * rayInfo.x;\n        \n        \/\/ calculate beer's law absorption.\n        absorbDistance += rayInfo.x;    \n        vec3 absorb = exp(-OBJECT_ABSORB * absorbDistance);\n        \n        \/\/ calculate how much to reflect or transmit (refract or diffuse)\n        float reflectMultiplier = FresnelReflectAmount(REFRACTIVE_INDEX_INSIDE, REFRACTIVE_INDEX_OUTSIDE, rayDir, rayInfo.yzw);\n        float refractMultiplier = 1.0 - reflectMultiplier;\n        \n        \/\/ add in refraction outside of the object\n        vec3 refractDir = refract(rayDir, rayInfo.yzw, REFRACTIVE_INDEX_INSIDE \/ REFRACTIVE_INDEX_OUTSIDE);\n        ret += GetSceneRayColor(rayPos + refractDir*0.001, refractDir) * refractMultiplier * multiplier * absorb;\n        \n        \/\/ add specular highlight based on refracted ray direction\n        ret += LightPixel(rayPos, rayDir, OBJECT_DIFFUSE, refractDir, OBJECT_SPECPOWER, false) * refractMultiplier * multiplier * absorb; \n        \n        \/\/ follow the ray down the internal reflection path.\n        rayDir = reflect(rayDir, rayInfo.yzw);\n        \n        \/\/ move the ray slightly down the reflect path\n        rayPos += rayDir * 0.001;\n        \n        \/\/ For reflection, we are only going to be reflecting what is refracted on further bounces.\n        \/\/ So, we just need to make sure the next bounce is added in at the reflectMultiplier amount, recursively.\n\t\tmultiplier *= reflectMultiplier;        \n    }\n    \n    \/\/ return the color we calculated\n    return ret;\n}\n\n\/\/============================================================\nvec3 RayTracePixelColor (in vec3 rayPos, in vec3 rayDir)\n{   \n    vec4 bestRayHitInfo = vec4(1000.0, 0.0, 0.0, 0.0);\n    vec3 rayHitDiffuse = vec3(1.0);\n    vec3 additiveColor = vec3(0.0);\n    \n    vec3 ret = vec3(0.0);\n           \n    \/\/ see if we've hit the platform and remember if we have\n    vec2 uv;    \n    vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\n    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\n    {\n        bestRayHitInfo = rayInfo;\n        rayHitDiffuse = Checkerboard(uv);\n    }\n    \n    \/\/ if we've hit the main object, and it's closer than the platform\n    rayInfo = RayIntersectObject(rayPos, rayDir);\n    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\n    {       \n        \/\/ light the surface of the ball a bit\n        additiveColor += LightPixel(rayPos, rayDir, OBJECT_DIFFUSE, rayInfo.yzw, OBJECT_SPECPOWER, false);\n        \n        \/\/ move the ray to the intersection point\n        rayPos += rayDir * rayInfo.x;    \n        \n        \/\/ calculate how much to reflect or transmit (refract or diffuse)\n        float reflectMultiplier = FresnelReflectAmount(REFRACTIVE_INDEX_OUTSIDE, REFRACTIVE_INDEX_INSIDE, rayDir, rayInfo.yzw);\n        float refractMultiplier = 1.0 - reflectMultiplier;\n        \n        \/\/ get reflection color\n        #if DO_REFLECTION\n        \tvec3 reflectDir = reflect(rayDir, rayInfo.yzw);\n        \tret += GetSceneRayColor(rayPos + reflectDir*0.001, reflectDir) * reflectMultiplier;\n        #endif\n        \n        \/\/ get refraction color\n        #if DO_REFRACTION\n        \tvec3 refractDir = refract(rayDir, rayInfo.yzw, REFRACTIVE_INDEX_OUTSIDE \/ REFRACTIVE_INDEX_INSIDE);\n        \tret += GetObjectInternalRayColor(rayPos + refractDir*0.001, refractDir) * refractMultiplier;\n        #endif\n        \n        return ret + additiveColor;\n    }\n    \/\/ else we missed the object, so return either the skybox color, or the platform color, as appropriate\n    else\n    {\n        if (bestRayHitInfo.x == 1000.0)    \n            return texture(iChannel0, rayDir).rgb;\n        else\n        {\n            \/\/ move the ray to the intersection point (so we can shadow) and light the pixel\n        \trayPos += rayDir * bestRayHitInfo.x;    \n            return LightPixel(rayPos, rayDir, rayHitDiffuse, bestRayHitInfo.yzw, 100.0, true);    \n        }\n    }\n}\n\n\/\/============================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    \/\/----- Camera Setup\n    vec2 mouse = iMouse.xy \/ iResolution.xy;\n\n    vec3 cameraAt \t= vec3(0.0);\n\n    float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 3.14 + iTime * 0.25;\n    float angleY = iMouse.z > 0.0 ? (mouse.y * 6.28) - 0.4 : 0.5;\n    vec3 cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 3.0;\n\n    vec3 cameraFwd  = normalize(cameraAt - cameraPos);\n    vec3 cameraLeft  = normalize(cross(normalize(cameraAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0)));\n    vec3 cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n\n    float cameraViewWidth\t= 6.0;\n    float cameraViewHeight\t= cameraViewWidth * iResolution.y \/ iResolution.x;\n    float cameraDistance\t= 6.0;  \/\/ intuitively backwards!\n\n    \/\/----- Ray Setup\n    vec2 rawPercent = (fragCoord.xy \/ iResolution.xy); \n    vec2 percent = rawPercent - vec2(0.5,0.5);\n\n    vec3 rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n        - (cameraLeft * percent.x * cameraViewWidth)\n        + (cameraUp * percent.y * cameraViewHeight);\n    vec3 rayDir = normalize(rayTarget);    \n\n    \/\/----- Ray Trace\n    vec3 finalColor = vec3(0.0);\n    #if DO_AA\n        for (int i = 1; i <= 16; ++i)\n        {\n            \/\/ calculate stratified subpixel jitter in a 4x4 grid\n            float x = mod(float(i)-1.0, 4.0);\n            float y = mod(floor(float(i) \/ 4.0), 4.0);\n            vec2 jitter = hash21(float(i)) \/ 4.0;\n            jitter.x += x \/ 4.0;\n            jitter.y += y \/ 4.0;\n            \n            \/\/ set up the jittered ray\n            rawPercent = ((fragCoord.xy + jitter) \/ iResolution.xy); \n            percent = rawPercent - vec2(0.5,0.5);\n\n            rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n                - (cameraLeft * percent.x * cameraViewWidth)\n                + (cameraUp * percent.y * cameraViewHeight);\n            rayDir = normalize(rayTarget);                \n           \n\t\t\t\/\/ raytrace\n            vec3 color = RayTracePixelColor(cameraPos, rayDir);\n            \n            \/\/ incrementally average our pixel color in\n            finalColor = mix(finalColor, color, 1.0 \/ float(i));            \n        }\n    #else\n   \t\tfinalColor = RayTracePixelColor(cameraPos, rayDir);\n    #endif\n    \n    \/\/----- Final color, gamma corrected\n    fragColor = vec4(pow(finalColor, vec3(1.0\/2.2)),1.0);        \n}\n\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"3lcSRn","date":"1580237856","viewed":9426,"name":"moving bars","username":"bandaloo","description":"shader i made for class","likes":5,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi = 3.14159265;\n\nvec3 blurry_rectangle(vec2 p, float xEdgeWidth, float yEdgeWidth, float xBlurriness, float yBlurriness, float xOffset, float yOffset) {\n  \/\/ the blurry rectangle mask\n  p -= vec2(xOffset, yOffset);\n  float smoothFrequency = 1.0;\n  vec2 innerEdge = vec2(xEdgeWidth, yEdgeWidth) - vec2(xBlurriness, yBlurriness);\n  vec2 outerEdge = vec2(xEdgeWidth, yEdgeWidth) + vec2(xBlurriness, yBlurriness);\n  vec2 bl = smoothstep(innerEdge, outerEdge, p); \/\/ bottom-left\n  vec2 tr = smoothstep(innerEdge, outerEdge, 1.0 - p); \/\/ top-right\n  return vec3(bl.x * bl.y * tr.x * tr.y);\n}\n\nvec3 waves(vec2 p, float xWiggleRate, float yWiggleRate, float xFrequency, float yFrequency, float xWiggle, float yWiggle) {\n  xFrequency += sin(iTime * xWiggleRate);\n  yFrequency += sin(iTime * yWiggleRate);\n  return vec3(cos(xFrequency * (p.x + xWiggle * sin(p.y))) * cos(yFrequency * (p.y + yWiggle * cos(p.y))));\n}\n\nfloat glow(vec2 p) {\n  vec2 pn = p * 2.0 - 1.0;\n  \n  float glowScalar = 2.0;\n  float glowAdder = 0.0;\n  \n  float fadeFrequency = 1.0;\n  float glowColor = glowAdder + (1.0 - length(pn)) * glowScalar - (0.5 * sin(fadeFrequency * iTime) + 0.5);\n  return clamp(glowColor, 0.0, 1.0);\n}\n\nfloat sinSpeeding(float position, float offset) {\n  float speed = 100.0 * smoothstep(3.0, 100.0, position);\n  return sin(0.01 * position * speed + offset);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \/\/ position on screen\n  vec2 p = fragCoord.xy \/ iResolution.xy;\n  \n  \/\/ rectangle masks\n  vec3 mask1 = blurry_rectangle(p, 0.4, 0.125, 0.02, 0.02, 0.3 * sinSpeeding(iTime, 0.0), 0.0);\n  vec3 mask2 = blurry_rectangle(p, 0.4, 0.125, 0.02, 0.02, 0.3 * sinSpeeding(iTime, 2.0 * pi \/ 3.0), 0.0);\n  vec3 mask3 = blurry_rectangle(p, 0.4, 0.125, 0.02, 0.02, 0.3 * sinSpeeding(iTime, 4.0 * pi \/ 3.0), 0.0);\n  \n  \/\/ inside the blurry rectangle\n  vec3 color1 = waves(p, 0.2, 0.2, 10.0, 10.0, 5.0, 5.0);\n  vec3 color2 = waves(p, 0.1, 0.1, 2.0, 1.0, 100.0, 5.0);\n  vec3 color3 = waves(p, 0.1, 0.1, 2.0, 5.0, 1.0, 5.0);\n  \n  float glowVal = glow(p);\n  fragColor = vec4(mask1 * color1 + mask2 * color2 + mask3 * color3, 1.0) * vec4(0.8 * glowVal, 0.2 * glowVal, 1.0, 1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"llB3zG","date":"1429880393","viewed":9419,"name":"Ray Marching Experiment 22","username":"aiekick","description":"Pattern based on IQ shader https:\/\/www.shadertoy.com\/view\/Xd2GR3 \nThanks to public_int_i\/ethan for godray adding\nuse mouse y to change pattern and use mouse x to change camera distance","likes":68,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"\/media\/a\/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"\/media\/ap\/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\/\/ Created by Stephane Cuillerdier - Aiekick\/2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ use mouse y to change pattern\n\/\/ use mouse x to change camera distance\n\n\/\/#define INVERSE_PATTERN\n\nconst vec2 RMPrec = vec2(0.5, 0.001); \/\/ ray marching tolerance precision \/\/ low, high\nconst vec2 DPrec = vec2(1e-5, 10.); \/\/ ray marching distance precision \/\/ low, high\n    \nfloat pattern = 3.; \/\/ pattern value 1. to 5. use mouse y to change\n\nfloat kernelRadius = 4.5; \/\/ radius of kernel\n\nfloat sphereThick = 0.02; \/\/ thick of sphere plates\nfloat sphereRadius = 6.; \/\/ radius of sphere\n\nfloat norPrec = 0.01; \/\/ normal precision \n\n\/\/ public_int_i\/ethan adding\nconst int godrayIter = 128;\nconst float godrayIntensity = .06;\nconst float godrayPrecision = .05;\n\n\/\/ light\nconst vec3 LCol = vec3(0.8,0.5,0.2);\nconst vec3 LPos = vec3(-0.6, 0.7, -0.5);\nconst vec3 LAmb = vec3( 0. );\nconst vec3 LDif = vec3( 1. , 0.5, 0. );\nconst vec3 LSpe = vec3( 0.8 );\n\n\/\/ material\nconst vec3 MCol = vec3(0.);\nconst vec3 MAmb = vec3( 0. );\nconst vec3 MDif = vec3( 1. , 0.5, 0. );\nconst vec3 MSpe = vec3( 0.6, 0.6, 0.6 );\nconst float MShi =30.;\n    \n#define mPi 3.14159\n#define m2Pi 6.28318\n\nvec2 uvs(vec3 p)\n{\n    p = normalize(p);\n    vec2 tex2DToSphere3D = vec2(0);\n    tex2DToSphere3D.x = 0.5 + atan(p.z, p.x) \/ (m2Pi*1.1547);\n    tex2DToSphere3D.y = 0.5 - asin(p.y) \/ (mPi*1.5);\n    return tex2DToSphere3D;\n}\n\n\/\/ Hex Pattern based on IQ Shader https:\/\/www.shadertoy.com\/view\/Xd2GR3\nfloat hex(vec2 p, int i)\n{\n    p*=50.;\n    \n    vec2 q = vec2( p.x*2.0*0.5773503, p.y + p.x*0.5773503 );\n\tvec2 pi = floor(q);\n\tvec2 pf = fract(q);\n\n    \/\/ 3. => hexagon\n    \/\/ 4. => brain pattern\n\tfloat v = mod(pi.x + pi.y, pattern);\n\n    float ca = step(1.,v);\n\tfloat cb = step(2.,v);\n\tvec2  ma = step(pf.xy,pf.yx);\n\t\n    float e = dot( ma, 1.0-pf.yx + ca*(pf.x+pf.y-1.0) + cb*(pf.yx-2.0*pf.xy) );\n\n    float hex = clamp(e,0.,0.2);\n    \n    #ifdef INVERSE_PATTERN\n        hex = 1.-smoothstep(e, 0.1, 0.0);\n\t#endif\n    \n    return hex * .2;\n}\n\nvec2 map(vec3 p)\n{\n    vec2 res = vec2(0.);\n    \n    float t = sin(iTime*.5)*.5+.5;\n    \n    float sphereOut = length(p) -sphereRadius - hex(uvs(p.xyz),0);\n    res = vec2(sphereOut, 1.);\n    \n    float sphereIn = length(p) - sphereRadius - sphereThick;\n    if (-sphereIn>res.x) \n        res = vec2(-sphereIn, 2.);\n    \n    float kernel = length(p) - kernelRadius;\n    if (kernel<res.x)\n        res = vec2(kernel,3.);\n    \n    return res;\n}\n\nvec3 nor(vec3 p, float prec)\n{\n    vec2 e = vec2(prec, 0.);\n    \n    vec3 n = vec3(0);\n    \n    n.x = map(p+e.xyy).x - map(p-e.xyy).x; \n    n.y = map(p+e.yxy).x - map(p-e.yxy).x; \n    n.z = map(p+e.yyx).x - map(p-e.yyx).x;  \n    \n    return normalize(n); \n}\n\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. \/ 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. \/ 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)\/255.;\n    if (Temp < 1000.) col *= Temp\/1000.;\n   \treturn col;\n}\n\nvec3 ads( vec3 p, vec3 n )\n{\n    vec3 ldif = normalize( LPos - p);\n    vec3 vv = normalize( vec3(0.) - p );\n    vec3 refl = reflect( vec3(0.) - ldif, n );\n    \n    vec3 amb = MAmb*LAmb+ blackbody(2000.);\n    vec3 dif = max(0., dot(ldif, n.xyz)) * MDif * LDif;\n    vec3 spe = vec3( 0. );\n    if( dot(ldif, vv) > 0.)\n        spe = pow(max(0., dot(vv,refl)),MShi)*MSpe*LSpe;\n    \n    return amb*1.2 + dif*1.5 + spe*0.8;\n}\n\n\/\/ thanks to public_int_i\/ethan for his adding\n\/\/ in shader https:\/\/www.shadertoy.com\/view\/MtSGzy\nvec4 god(vec4 c, vec3 ro, vec3 rd ) \n{\n    float sc = dot(ro, ro) - 48.;\n    float sb = dot(rd, ro);\n\n    float sd = sb*sb - sc;\n    float st = -sb - sqrt(abs(sd));\n\n    float r = 6.92839855;\n    if (!(sd < 0.0 || st < 0.0)) \n    {\n        float gr = 0.;\n\n        ro += rd*st;\n        \n        float rlen = r - length(ro);\n\n        for (int i = 0; i < godrayIter; i++) \n        {\n            if (hex(uvs(ro),0) < .04) \n                gr+=rlen;\n            \n            ro += rd * godrayPrecision;\n            \n            rlen = r -length(ro);\n            \n            if (!(rlen > 0. && rlen < 1.)) break;\n        }\n        \n        c.xyz += LCol * godrayIntensity * gr;\n    }\n    return c;\n}\n\nvec4 scn(vec4 col, vec3 ro, vec3 rd)\n{\n    vec2 s = vec2(DPrec.x);\n    float d = 0.;\n    vec3 p = ro+rd*d;\n    vec4 c = col;\n    \n    float b = 0.35;\n    \n    float t = 1.1*(sin(iTime*.3)*.5+.6);\n    \n    for(int i=0;i<200;i++)\n    {\n    \tif(s.x<DPrec.x||s.x>DPrec.y) break;\n        s = map(p);\n        d += s.x*(s.x>DPrec.x?RMPrec.x:RMPrec.y);\n        p = ro+rd*d;\n    }\n    \n    if (s.x<DPrec.x)\n    {\n        vec3 n = nor(p, norPrec); \n      \tvec3 ray = reflect(rd, n);\n\t\t\n        if ( s.y < 1.5) \/\/ ext\n        {\n            vec3 cuberay = texture(iChannel0, ray).rgb * 0.5;\n            c.rgb = MCol + cuberay + pow(b, 25.);\n        }\n        else if ( s.y < 2.5) \/\/ int\n        {\n            c.rgb = ads(p,n);\n        }\n        else if ( s.y < 3.5) \/\/ kernel\n        {\n            float b = dot(n,normalize(ro-p))*0.8;\n            c = (b*vec4(blackbody(2000.),0.2)+pow(b,0.2))*(1.0-d*.01);\n        }\n    }\n    else\n    {\n       \tc = texture(iChannel0, rd);\n    }\n    \n    return c;\n}\n\nvec3 cam(vec2 uv, vec3 ro, vec3 cu, vec3 org, float persp)\n{\n\tvec3 rorg = normalize(org-ro);\n    vec3 u =  normalize(cross(cu, rorg));\n    vec3 v =  normalize(cross(rorg, u));\n    vec3 rd = normalize(rorg + u*uv.x + v*uv.y);\n    return rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 s = iResolution.xy;\n    vec2 g = fragCoord.xy;\n    vec2 uv = (2.*g-s)\/s.y;\n    vec2 m = iMouse.xy;\n    \n    float t = iTime*0.2;\n    float ts = sin(t)*.5+.5;\n    \n    float axz = -t; \/\/ angle XZ\n    float axy = .8; \/\/ angle XY\n    float cd = 7.5;\/\/*ts; \/\/ cam dist to scene origine\n    \n    if ( iMouse.z>0.) cd = 10. * m.x\/s.x; \/\/ mouse x axis \n    if ( iMouse.z>0.) pattern = floor(6. * m.y\/s.y); \/\/ mouse y axis \n    \n    float ap = 1.; \/\/ angle de perspective\n    vec3 cu = vec3(0.,1.,0.); \/\/ cam up \n    vec3 org = vec3(0., 0., 0.); \/\/ scn org\n    vec3 ro = vec3(cos(axz),sin(axy),sin(axz))*cd; \/\/ cam org\n    \n    vec3 rd = cam(uv, ro, cu, org, ap);\n    \n    vec4 c = vec4(0.,0.,0.,1.); \/\/ col\n    \n    c = scn(c, ro, rd);\/\/scene\n\t\n    c = god(c, ro, rd);\/\/god rays\n    \n    fragColor = c;\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"XdcXzn","date":"1457264858","viewed":9389,"name":"Brightness, contrast, saturation","username":"WojtaZam","description":"Basic image processing matrices.","likes":48,"published":3,"flags":0,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"\/media\/a\/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"\/media\/ap\/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat4 brightnessMatrix( float brightness )\n{\n    return mat4( 1, 0, 0, 0,\n                 0, 1, 0, 0,\n                 0, 0, 1, 0,\n                 brightness, brightness, brightness, 1 );\n}\n\nmat4 contrastMatrix( float contrast )\n{\n\tfloat t = ( 1.0 - contrast ) \/ 2.0;\n    \n    return mat4( contrast, 0, 0, 0,\n                 0, contrast, 0, 0,\n                 0, 0, contrast, 0,\n                 t, t, t, 1 );\n\n}\n\nmat4 saturationMatrix( float saturation )\n{\n    vec3 luminance = vec3( 0.3086, 0.6094, 0.0820 );\n    \n    float oneMinusSat = 1.0 - saturation;\n    \n    vec3 red = vec3( luminance.x * oneMinusSat );\n    red+= vec3( saturation, 0, 0 );\n    \n    vec3 green = vec3( luminance.y * oneMinusSat );\n    green += vec3( 0, saturation, 0 );\n    \n    vec3 blue = vec3( luminance.z * oneMinusSat );\n    blue += vec3( 0, 0, saturation );\n    \n    return mat4( red,     0,\n                 green,   0,\n                 blue,    0,\n                 0, 0, 0, 1 );\n}\n\nconst float brightness = 0.15;\nconst float contrast = 1.2;\nconst float saturation = 1.5;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 color = texture( iChannel0, fragCoord\/iResolution.xy );\n    \n\tfragColor = brightnessMatrix( brightness ) *\n        \t\tcontrastMatrix( contrast ) * \n        \t\tsaturationMatrix( saturation ) *\n        \t\tcolor;\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"XtK3W3","date":"1477145781","viewed":9365,"name":"Video Glitch","username":"dyvoid","description":"Simulated video glitches. Random simplex noise displacement, RGB shifting and horizontal line patterns.","likes":121,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"\/media\/a\/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"\/media\/ap\/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/\n\/\/ Description : Array and textureless GLSL 2D simplex noise function.\n\/\/      Author : Ian McEwan, Ashima Arts.\n\/\/  Maintainer : stegu\n\/\/     Lastmod : 20110822 (ijm)\n\/\/     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n\/\/               Distributed under the MIT License. See LICENSE file.\n\/\/               https:\/\/github.com\/ashima\/webgl-noise\n\/\/               https:\/\/github.com\/stegu\/webgl-noise\n\/\/ \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 \/ 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 \/ 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  \/\/ (3.0-sqrt(3.0))\/6.0\n                      0.366025403784439,  \/\/ 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  \/\/ -1.0 + 2.0 * C.x\n                      0.024390243902439); \/\/ 1.0 \/ 41.0\n\/\/ First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n\/\/ Other corners\n  vec2 i1;\n  \/\/i1.x = step( x0.y, x0.x ); \/\/ x0.x > x0.y ? 1.0 : 0.0\n  \/\/i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  \/\/ x0 = x0 - 0.0 + 0.0 * C.xx ;\n  \/\/ x1 = x0 - i1 + 1.0 * C.xx ;\n  \/\/ x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n\/\/ Permutations\n  i = mod289(i); \/\/ Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n\/\/ Gradients: 41 points uniformly over a line, mapped onto a diamond.\n\/\/ The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n\/\/ Normalise gradients implicitly by scaling m\n\/\/ Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n\/\/ Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nfloat rand(vec2 co)\n{\n   return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;    \n    float time = iTime * 2.0;\n    \n    \/\/ Create large, incidental noise waves\n    float noise = max(0.0, snoise(vec2(time, uv.y * 0.3)) - 0.3) * (1.0 \/ 0.7);\n    \n    \/\/ Offset by smaller, constant noise waves\n    noise = noise + (snoise(vec2(time*10.0, uv.y * 2.4)) - 0.5) * 0.15;\n    \n    \/\/ Apply the noise as x displacement for every line\n    float xpos = uv.x - noise * noise * 0.25;\n\tfragColor = texture(iChannel0, vec2(xpos, uv.y));\n    \n    \/\/ Mix in some random interference for lines\n    fragColor.rgb = mix(fragColor.rgb, vec3(rand(vec2(uv.y * time))), noise * 0.3).rgb;\n    \n    \/\/ Apply a line pattern every 4 pixels\n    if (floor(mod(fragCoord.y * 0.25, 2.0)) == 0.0)\n    {\n        fragColor.rgb *= 1.0 - (0.15 * noise);\n    }\n    \n    \/\/ Shift green\/blue channels (using the red channel)\n    fragColor.g = mix(fragColor.r, texture(iChannel0, vec2(xpos + noise * 0.05, uv.y)).g, 0.25);\n    fragColor.b = mix(fragColor.r, texture(iChannel0, vec2(xpos - noise * 0.05, uv.y)).b, 0.25);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"3dVXDc","date":"1576029393","viewed":9340,"name":"Tileable Perlin-Worley 3D","username":"piyushslayer","description":"Tileable Perlin-Worley 3D noise implementation for modeling volumetric clouds like the ones from Horizon Zero Dawn.  Drag the mouse along y-axis to see different slices.","likes":114,"published":3,"flags":32,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/**\nAn implementation of tileable 3D Perlin-Worley noise for modeling volumetric clouds\ninspired from the chapter Real-Time Volumetric Cloudscapes by Andrew Schneider\n(Guerrilla Games). The first column is the perlin-worley noise generated by remapping\nperlin noise with the lowest frequency worley fbm. The next 3 columns are worley fbms\nwith increasing frequencies, and are used to model the cloud shapes which are rendered\nin the last column. See the common tab for all the noise functions used.\n*\/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord \/ iResolution.xy;\n    vec2 uv = fragCoord \/ iResolution.y;\n    st.x *= 5.; \/\/ 5 columns for different noises\n    uv -= .02 * iTime;\n\n    vec3 col = vec3(0.);\n    \n    float perlinWorley = textureLod(iChannel0, uv * .5, 0.).x;\n    \n    \/\/ worley fbms with different frequencies\n    vec3 worley = textureLod(iChannel0, uv, 0.).yzw;\n    float wfbm = worley.x * .625 +\n        \t\t worley.y * .125 +\n        \t\t worley.z * .25; \n    \n    \/\/ cloud shape modeled after the GPU Pro 7 chapter\n    float cloud = remap(perlinWorley, wfbm - 1., 1., 0., 1.);\n    cloud = remap(cloud, .85, 1., 0., 1.); \/\/ fake cloud coverage\n    \n    if (st.x < 1.)\n        col += perlinWorley;\n    else if(st.x < 2.)\n        col += worley.x;\n    else if(st.x < 3.)\n        col += worley.y;\n\telse if(st.x < 4.)\n        col += worley.z;\n    else if(st.x < 5.)\n        col += cloud;\n            \n    \/\/ column dividers\n    float div = smoothstep(.01, 0., abs(st.x - 1.));\n    div += smoothstep(.01, 0., abs(st.x - 2.));\n\tdiv += smoothstep(.01, 0., abs(st.x - 3.));\n    div += smoothstep(.01, 0., abs(st.x - 4.));\n        \n    col = mix(col, vec3(0., 0., .866), div);\n        \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/**\nThis buffer writes the tileable 3D noise to a texture. \n*\/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord \/ iResolution.xy;\n    vec2 m = iMouse.xy \/ iResolution.xy;\n\n    vec4 col = vec4(0.);\n    \n    float slices = 128.; \/\/ number of layers of the 3d texture\n    float freq = 4.;\n    \n    float pfbm= mix(1., perlinfbm(vec3(uv, floor(m.y*slices)\/slices), 4., 7), .5);\n    pfbm = abs(pfbm * 2. - 1.); \/\/ billowy perlin noise\n    \n    col.g += worleyFbm(vec3(uv, floor(m.y*slices)\/slices), freq);\n    col.b += worleyFbm(vec3(uv, floor(m.y*slices)\/slices), freq*2.);\n    col.a += worleyFbm(vec3(uv, floor(m.y*slices)\/slices), freq*4.);\n    col.r += remap(pfbm, 0., 1., col.g, 1.); \/\/ perlin-worley\n    \n    fragColor = vec4(col);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\/**\nThis tab contains all the necessary noise functions required to model a cloud shape.\n*\/\n\n\/\/ Hash by David_Hoskins\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 \/ float(0xffffffffU))\n\nvec3 hash33(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn -1. + 2. * vec3(q) * UIF;\n}\n\nfloat remap(float x, float a, float b, float c, float d)\n{\n    return (((x - a) \/ (b - a)) * (d - c)) + c;\n}\n\n\/\/ Gradient noise by iq (modified to be tileable)\nfloat gradientNoise(vec3 x, float freq)\n{\n    \/\/ grid\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    \/\/ quintic interpolant\n    vec3 u = w * w * w * (w * (w * 6. - 15.) + 10.);\n\n    \n    \/\/ gradients\n    vec3 ga = hash33(mod(p + vec3(0., 0., 0.), freq));\n    vec3 gb = hash33(mod(p + vec3(1., 0., 0.), freq));\n    vec3 gc = hash33(mod(p + vec3(0., 1., 0.), freq));\n    vec3 gd = hash33(mod(p + vec3(1., 1., 0.), freq));\n    vec3 ge = hash33(mod(p + vec3(0., 0., 1.), freq));\n    vec3 gf = hash33(mod(p + vec3(1., 0., 1.), freq));\n    vec3 gg = hash33(mod(p + vec3(0., 1., 1.), freq));\n    vec3 gh = hash33(mod(p + vec3(1., 1., 1.), freq));\n    \n    \/\/ projections\n    float va = dot(ga, w - vec3(0., 0., 0.));\n    float vb = dot(gb, w - vec3(1., 0., 0.));\n    float vc = dot(gc, w - vec3(0., 1., 0.));\n    float vd = dot(gd, w - vec3(1., 1., 0.));\n    float ve = dot(ge, w - vec3(0., 0., 1.));\n    float vf = dot(gf, w - vec3(1., 0., 1.));\n    float vg = dot(gg, w - vec3(0., 1., 1.));\n    float vh = dot(gh, w - vec3(1., 1., 1.));\n\t\n    \/\/ interpolation\n    return va + \n           u.x * (vb - va) + \n           u.y * (vc - va) + \n           u.z * (ve - va) + \n           u.x * u.y * (va - vb - vc + vd) + \n           u.y * u.z * (va - vc - ve + vg) + \n           u.z * u.x * (va - vb - ve + vf) + \n           u.x * u.y * u.z * (-va + vb + vc - vd + ve - vf - vg + vh);\n}\n\n\/\/ Tileable 3D worley noise\nfloat worleyNoise(vec3 uv, float freq)\n{    \n    vec3 id = floor(uv);\n    vec3 p = fract(uv);\n    \n    float minDist = 10000.;\n    for (float x = -1.; x <= 1.; ++x)\n    {\n        for(float y = -1.; y <= 1.; ++y)\n        {\n            for(float z = -1.; z <= 1.; ++z)\n            {\n                vec3 offset = vec3(x, y, z);\n            \tvec3 h = hash33(mod(id + offset, vec3(freq))) * .5 + .5;\n    \t\t\th += offset;\n            \tvec3 d = p - h;\n           \t\tminDist = min(minDist, dot(d, d));\n            }\n        }\n    }\n    \n    \/\/ inverted worley noise\n    return 1. - minDist;\n}\n\n\/\/ Fbm for Perlin noise based on iq's blog\nfloat perlinfbm(vec3 p, float freq, int octaves)\n{\n    float G = exp2(-.85);\n    float amp = 1.;\n    float noise = 0.;\n    for (int i = 0; i < octaves; ++i)\n    {\n        noise += amp * gradientNoise(p * freq, freq);\n        freq *= 2.;\n        amp *= G;\n    }\n    \n    return noise;\n}\n\n\/\/ Tileable Worley fbm inspired by Andrew Schneider's Real-Time Volumetric Cloudscapes\n\/\/ chapter in GPU Pro 7.\nfloat worleyFbm(vec3 p, float freq)\n{\n    return worleyNoise(p*freq, freq) * .625 +\n        \t worleyNoise(p*freq*2., freq*2.) * .25 +\n        \t worleyNoise(p*freq*4., freq*4.) * .125;\n}\n\n","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"XlB3zV","date":"1430516268","viewed":9319,"name":"Magnetismic","username":"nimitz","description":"Volumetric rendering of a deformed field.\n\nWipe Up\/Down = frequency","likes":362,"published":1,"flags":0,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\/\/Magnetismic by nimitz (twitter: @stormoid)\n\/\/ https:\/\/www.shadertoy.com\/view\/XlB3zV\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\/\/ Contact the author for other licensing options\n\n\/\/Getting 60fps here at high quality\n#define HIGH_QUALITY\n\n#ifdef HIGH_QUALITY\n#define STEPS 130\n#define ALPHA_WEIGHT 0.015\n#define BASE_STEP 0.025\n#else\n#define STEPS 50\n#define ALPHA_WEIGHT 0.05\n#define BASE_STEP 0.1\n#endif\n\n#define time iTime\nvec2 mo;\nvec2 rot(in vec2 p, in float a){float c = cos(a), s = sin(a);return p*mat2(c,s,-s,c);}\nfloat hash21(in vec2 n){ return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }\nfloat noise(in vec3 p)\n{\n\tvec3 ip = floor(p), fp = fract(p);\n    fp = fp*fp*(3.0-2.0*fp);\n\tvec2 tap = (ip.xy+vec2(37.0,17.0)*ip.z) + fp.xy;\n\tvec2 cl = textureLod( iChannel0, (tap + 0.5)\/256.0, 0.0 ).yx;\n\treturn mix(cl.x, cl.y, fp.z);\n}\n\nfloat fbm(in vec3 p, in float sr)\n{\n    p *= 3.5;\n    float rz = 0., z = 1.;\n    for(int i=0;i<4;i++)\n    {\n        float n = noise(p-time*.6);\n        rz += (sin(n*4.4)-.45)*z;\n        z *= .47;\n        p *= 3.5;\n    }\n    return rz;\n}\n\nvec4 map(in vec3 p)\n{\n    float dtp = dot(p,p);\n\tp = .5*p\/(dtp + .2);\n    p.xz = rot(p.xz, p.y*2.5);\n    p.xy = rot(p.xz, p.y*2.);\n    \n    float dtp2 = dot(p, p);\n    p = (mo.y + .6)*3.*p\/(dtp2 - 5.);\n    float r = clamp(fbm(p, dtp*0.1)*1.5-dtp*(.35-sin(time*0.3)*0.15), 0. ,1.);\n    vec4 col = vec4(.5,1.7,.5,.96)*r;\n    \n    float grd = clamp((dtp+.7)*0.4,0.,1.);\n    col.b += grd*.6;\n    col.r -= grd*.5;    \n    vec3 lv = mix(p,vec3(0.3),2.);\n    grd = clamp((col.w - fbm(p+lv*.05,1.))*2., 0.01, 1.5 );\n    col.rgb *= vec3(.5, 0.4, .6)*grd + vec3(4.,0.,.4);\n    col.a *= clamp(dtp*2.-1.,0.,1.)*0.07+0.87;\n    \n    return col;\n}\n\nvec4 vmarch(in vec3 ro, in vec3 rd)\n{\n\tvec4 rz = vec4(0);\n\tfloat t = 2.5;\n    t += 0.03*hash21(gl_FragCoord.xy);\n\tfor(int i=0; i<STEPS; i++)\n\t{\n\t\tif(rz.a > 0.99 || t > 6.)break;\n\t\tvec3 pos = ro + t*rd;\n        vec4 col = map(pos);\n        float den = col.a;\n        col.a *= ALPHA_WEIGHT;\n\t\tcol.rgb *= col.a*1.7;\n\t\trz += col*(1. - rz.a);\n        t += BASE_STEP - den*(BASE_STEP-BASE_STEP*0.015);\n\t}\n    return rz;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 p = fragCoord.xy\/iResolution.xy*2. - 1.;\n\tp.x *= iResolution.x\/iResolution.y*.85;\n    p *= 1.1;\n\tmo = 2.0*iMouse.xy\/iResolution.xy;\n    mo = (mo==vec2(.0))?mo=vec2(0.5,1.):mo;\n\t\n\tvec3 ro = 4.*normalize(vec3(cos(2.75-2.0*(mo.x+time*0.05)), sin(time*0.22)*0.2, sin(2.75-2.0*(mo.x+time*0.05))));\n\tvec3 eye = normalize(vec3(0) - ro);\n\tvec3 rgt = normalize(cross(vec3(0,1,0), eye));\n\tvec3 up = cross(eye,rgt);\n\tvec3 rd = normalize(p.x*rgt + p.y*up + (3.3-sin(time*0.3)*.7)*eye);\n\t\n\tvec4 col = clamp(vmarch(ro, rd),0.,1.);\n    col.rgb = pow(col.rgb, vec3(.9));\n    \/*col.rb = rot(col.rg, 0.35);\n    col.gb = rot(col.gb, -0.1);*\/\n    \n    fragColor = vec4(col.rgb, 1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"fsXcR8","date":"1641828262","viewed":9316,"name":"On the salt lake","username":"iapafoto","description":"Improve a bit my red hiker. \nInspired by nguyen nhut work https:\/\/twitter.com\/nguyenhut_art\nTeapot alone: https:\/\/www.shadertoy.com\/view\/XsSGzG","likes":118,"published":1,"flags":0,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"\/media\/a\/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"\/media\/ap\/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/-----------------------------------------------------\n\/\/ Created by sebastien durand - 2021\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/-----------------------------------------------------\n\/\/ inspired by nguyen nhut work https:\/\/twitter.com\/nguyenhut_art\n\/\/ Teapot alone: https:\/\/www.shadertoy.com\/view\/XsSGzG\n\/\/-----------------------------------------------------\n\n#define PI 3.14159265\n\n#define WITH_AO\n\n#define ZERO (min(0, iFrame))\n\n\n#define GROUND 0.\n#define SKIN 1.\n#define SHOES1 2.\n#define SHOES2 2.5\n#define SHORT 3.\n#define BAG 4.\n#define SHIRT 5.\n#define TEAPOT 6.\n#define BED 7.\n#define METAL 8.\n\/\/#define PANEL 9.\n#define BONE 10.\n\n#define WITH_SPIRAL\n\nfloat gTime;\n\n\/\/---------------------------------------------------------------------\n\/\/    Animation\n\/\/---------------------------------------------------------------------\n\n\/\/                       Contact           Down               Pass               Up      \n\nvec3[9] HEAD = vec3[9]( vec3(50,24,0),  vec3(73,30,0),   vec3(94,20,0),   vec3(117,15,0),  \n                        vec3(135,24,0), vec3(158,30,0),  vec3(179,20,0),  vec3(202,15,0), vec3(218,24,0));\n\nvec3[9] SHOULDER = vec3[9](vec3(44,47,16),vec3(66,53,16), vec3(91,43,16), vec3(115,38,16), \n                         vec3(136,50,16), vec3(158,55,16), vec3(176,43,16), vec3(85+111,37,16), vec3(212,47,16));\n\nvec3[9] ELBOW = vec3[9](vec3(25,64,25), vec3(46,67,25),  vec3(88,70,25),  vec3(120,65,25),\n                        vec3(139,72,25),vec3(172,67,25), vec3(176,71,25), vec3(177,61,25), vec3(193,64,25));\n\nvec3[9] WRIST = vec3[9](vec3(20,85,15), vec3(35,76,20), vec3(88,100,25), vec3(128,89,25), \n                        vec3(164,85,15), vec3(187,81,20),vec3(85+88,98,25),vec3(85+82,81,20), vec3(188,85,15));\n\nvec3[9] HIP = vec3[9](  vec3(42,90,10),  vec3(62,95,10),   vec3(83,88,10),   vec3(107,83,10),  \n                        vec3(127,92,10), vec3(147,94,10),  vec3(168,91,10),  vec3(192,85,10), vec3(210,90,10));\n\nvec3[9] KNEE = vec3[9]( vec3(29,118,7),  vec3(48,120,8),   vec3(97,117,10),  vec3(130,107,10), \n                        vec3(144,120,7), vec3(167,118,7),  vec3(167,118,7),  vec3(181,111,7), vec3(197,118,7));\n\nvec3[9] ANKLE = vec3[9](vec3(5,134,5),   vec3(22,132,6),   vec3(71,122,10),  vec3(113,127,10), \n                        vec3(162,146,5), vec3(164,146,5),  vec3(164,146,5),  vec3(168,137,5), vec3(173,134,5));\n\nvec3[9] FOOT = vec3[9]( vec3(14,150,10), vec3(16,150,10),  vec3(63,139,10),  vec3(119,143,10), \n                        vec3(178,139,10),vec3(182,150,10), vec3(182,150,10), vec3(182,150,10), vec3(182,150,10));\n\n\nvec3 shoulder1, elbow1, wrist1, head,\n     shoulder2, elbow2, wrist2;\nvec3 foot1, ankle1, knee1, hip1,\n     foot2, ankle2, knee2, hip2;\n\nmat2 rot, rot1, rot2;\n\n\n#define U(a,b) (a.x*b.y-b.x*a.y)\n\nvec2 A[15];\nvec2 T1[5];\nvec2 T2[5];\n\nfloat smin(float a, float b, float k){\n    float h = clamp(.5+.5*(b-a)\/k, 0., 1.);\n    return mix(b,a,h)-k*h*(1.-h);\n}\n\nvec2 min2(vec2 a, vec2 b) {\n    return a.x<b.x ? a : b; \n}\n\n#ifdef WITH_SPIRAL\nfloat sdSpiral(vec3 p, vec2 sz){\n    float d = length(p.xy)\/sz.x + atan(-p.y,p.x)*.5;  \n    d -= PI*clamp(round(d\/PI),1.,4.);\n    return max(sz.x*(abs(d)-.77), abs(p.z)-sz.y); \n}\n#endif\n\n\n#ifdef BONE\n\/\/ Adated from gaz [Bones] https:\/\/www.shadertoy.com\/view\/ldG3zc\nvec2 sdBone(in vec3 p) {\n\/\/return vec2(sdSpiral(p-vec3(0,.5,0), vec2(.015,.5)),BONE);\n    p.x -= 80.;\n    const float m = 200.;\n    float scale = .5 + floor(abs(p.x)\/m);\n    p.x = mod(p.x+m*.5,m)-m*.5;\n    p.xz *= rot;\n    p \/= scale;\n    p -= vec3(0.,.05,2.5);\n    float d = length(p-vec3(1.2,.2,-.35)) - .2;\n    p.y -= .2*p.x*p.x;\n    p.y *= cos(atan(.6*p.x));\n    float n = clamp(p.x,-.7,1.);\n    vec2 sg = vec2(length(p.xy-vec2(n,0)),(n+.7)\/1.7),\n         p0 = pow(abs(vec2(sg.x, p.z)), vec2(3));\n    d = smin(d,pow(p0.x+p0.y, 1.\/3.) -(.3*pow(sg.y-.5,2.)+.2), .3);\n    return vec2(.7*scale*d, BONE);\n}\n#endif\n\n\/\/ Distance to Bezier\n\/\/ inspired by [iq:https:\/\/www.shadertoy.com\/view\/ldj3Wh]\n\/\/ calculate distance to 2D bezier curve on xy but without forgeting the z component of p\n\/\/ total distance is corrected using pytagore just before return\nvec2 sdBezier(vec2 m, vec2 n, vec2 o, vec3 p) {\n\tvec2 q = p.xy;\n\tm-= q; n-= q; o-= q;\n\tfloat x = U(m, o), y = 2. * U(n, m), z = 2. * U(o, n);\n\tvec2 i = o - m, j = o - n, k = n - m, \n\t\t s = 2. * (x * i + y * j + z * k), \n\t\t r = m + (y * z - x * x) * vec2(s.y, -s.x) \/ dot(s, s);\n\tfloat t = clamp((U(r, i) + 2. * U(k, r)) \/ (x + x + y + z), 0.,1.); \/\/ parametric position on curve\n\tr = m + t * (k + k + t * (j - k)); \/\/ distance on 2D xy space\n\treturn vec2(sqrt(dot(r, r) + p.z * p.z), t); \/\/ distance on 3D space\n}\n\n\/\/-----------------------------------------------------------------------------------\n\/\/ iq - https:\/\/www.shadertoy.com\/view\/ldj3Wh\nvec2 sdBezier(in vec3 p,in vec3 b0,in vec3 b1,in vec3 b2 ) {\n    b0 -= p; b1 -= p; b2 -= p;\n    vec3 b01 = cross(b0,b1), b12 = cross(b1,b2), b20 = cross(b2,b0),\n         n =  b01+b12+b20;\n    float a = -dot(b20,n), b = -dot(b01,n), d = -dot(b12,n), m = -dot(n,n);\n    vec3  g =  (d-b)*b1 + (b+a*.5)*b2 + (-d-a*.5)*b0;\n    float t = clamp((a*.5+b-.5*(a*a*.25-b*d)*dot(g,b0-2.*b1+b2)\/dot(g,g))\/m, 0., 1.);\n    return vec2(length(mix(mix(b0,b1,t), mix(b1,b2,t),t)),t);\n}\n\n\/\/ Distance to scene\nfloat sdTeapot(vec3 p) {\n\/\/ Distance to Teapot --------------------------------------------------- \n\t\/\/ precalcul first part of teapot spout\n\tvec2 h = sdBezier(T1[2],T1[3],T1[4], p);\n\tfloat a = 99., \n    \/\/ distance to teapot handle (-.06 => make the thickness) \n\t\tb = min(min(sdBezier(T2[0],T2[1],T2[2], p).x, sdBezier(T2[2],T2[3],T2[4], p).x) - .06, \n    \/\/ max p.y-.9 => cut the end of the spout \n                max(p.y - .9,\n    \/\/ distance to second part of teapot spout (abs(dist,r1)-dr) => enable to make the spout hole \n                    min(abs(sdBezier(T1[0],T1[1],T1[2], p).x - .07) - .01, \n    \/\/ distance to first part of teapot spout (tickness incrase with pos on curve) \n                        h.x * (1. - .75 * h.y) - .08)));\n    \/\/ distance to teapot body => use rotation symetry to simplify calculation to a distance to 2D bezier curve\n    vec3 qq= vec3(sqrt(dot(p,p)-p.y*p.y), p.y, 0);\n    \/\/ the substraction of .015 enable to generate a small thickness arround bezier to help convergance\n    \/\/ the .8 factor help convergance  \n\tfor(int i=ZERO;i<13;i+=2) \n\t\ta = min(a, (sdBezier(A[i], A[i + 1], A[i + 2], qq).x - .035) * .9); \n    \/\/ smooth minimum to improve quality at junction of handle and spout to the body\n\treturn smin(a,b,.02);\n}\n\n\/\/ Interpolate pos of articulations\nvec3 getPos(vec3 arr[9], int it, float kt, float z) {\n    it = it%8;\n    vec3 p = mix(arr[it], arr[it+1], kt);\n\treturn .02*vec3(p.x+floor(gTime\/8.)*168., 150.-p.y, p.z*z);\n}\n\n\/\/---------------------------------------------------------------------\n\/\/    HASH functions (iq)\n\/\/---------------------------------------------------------------------\n\nvec2 hash22(vec2 p) {\n    p = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n    return fract(vec2(p.x * p.y * 95.4337, p.x * p.y * 97.597));\n}\n\n\/\/---------------------------------------------------------------------\n\/\/   Modeling Primitives\n\/\/   [Inigo Quilez] https:\/\/iquilezles.org\/articles\/distfunctions\n\/\/---------------------------------------------------------------------\n\nfloat sdCap(vec3 p, vec3 a, vec3 b) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)\/dot(ba,ba), 0., 1. );\n    return length( pa - ba*h );\n}\n\nfloat sdCap2(vec3 p, vec3 a, vec3 b, float r1, float r2) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa,ba)\/dot(ba,ba), 0., 1. );\n    return length( pa - ba*h ) - mix(r1,r2,h);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r ) {\n  return length(max(abs(p)-b,0.))-r;\n}\n\nfloat sdCappedCylinder(vec3 p, vec2 h ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.) + length(max(d,0.));\n}\n\n\/\/ approximated\nfloat sdEllipsoid( in vec3 p, in vec3 r ) {\n    float k0 = length(p\/r);\n    return k0*(k0-1.)\/length(p\/(r*r));\n}\n\nfloat sdEar(in vec3 p) {\n    vec3 p_ear = 1.5*p;\n    float d = max(-sdEllipsoid(p_ear-vec3(.005,.015,.02), vec3(.07,.1,.07)), \n                   sdEllipsoid(p_ear, vec3(.08,.12,.09)));\n    d = max(p_ear.z, d); \n    d = smin(d, sdEllipsoid(p_ear+vec3(.035,.045,.01), vec3(.04,.04,.018)), .01);\n    return d\/1.5;\n}\n\n\nmat3 baseArm1, baseArm2, baseBag, baseFoot1, baseFoot2;\n\nvec2 sdMan(in vec3 pos){\n    vec3 p0 = pos;\n    vec2 res = vec2(999,0);\n    \n    \/\/ Legs\n    float dSkin = min(\n        min(sdCap(pos, ankle1, knee1), \n            sdCap(pos, knee1, hip1)),\n        min(sdCap(pos, ankle2, knee2),\n            sdCap(pos, knee2, hip2)))-.1;\n            \n    \/\/ Foot1 flat part - vector base linked to leg 1\n    float dShoes1 = max(sdCap(pos, foot1, ankle1) - .15, -dot((pos-ankle1)*baseFoot1-vec3(0,0,-.13), vec3(0,0,1))); \n\n    \/\/ Leg 2\n    float dShoes2 = max(sdCap(pos, foot2, ankle2) - .15, -dot((pos-ankle2)*baseFoot2-vec3(0,0,-.13), vec3(0,0,1)));  \n    \n    vec3 ep0 = mix(shoulder1,shoulder2,.5),\n         ha0 = mix(hip1,hip2,.5);\n\n    \/\/ Head\n    vec3 h1 = vec3(0,.17,0), h2 = vec3(.02,-.11,0),\n         h = mix(h1,h2,.2);\n    dSkin = min(dSkin, sdCap(pos, head - h, head - h2)-.25);\n    \n    vec3 posHead = pos-head;\n    posHead.xz *= rot1;\n    vec3 posEar = posHead;\n    posEar.z = abs(posEar.z);\n    posEar-=vec3(0.,-.08,.29);\n    posEar.zx *= rot;\n \n     \/\/ ear \/ noze\n    dSkin = smin(dSkin, min(sdEar(posEar.zyx),\n                            sdCap(posHead, - mix(h1,h2,.4), - mix(h1,h2,.4) + vec3(.28,0,0))- .04),.02);\n    \/\/ Torso\n    vec3 a = mix(ha0,ep0,.15), b = mix(ha0,ep0,.78);\n    \n    \/\/ Neck\n    float dNeck = sdCap(pos, ep0-vec3(.08,0,0), head-vec3(.08,.1,0))- .1;\n    dSkin = smin(dSkin, dNeck,.06);\n  \n    float dTorso = smin(sdCap(pos,shoulder1,shoulder2)-.11, sdCap2(pos, a, b, .23,.28),.095);\n    dSkin = min(dSkin, dTorso);\n   \n    dTorso = smin(dTorso, sdCap(pos, shoulder1, mix(shoulder1,elbow1,.3))- .1,.05);\n\n    \/\/ Arm 1\n    dSkin = smin(dSkin, sdCap(pos, shoulder1, elbow1)- .1,.05);\n    dSkin = min(dSkin, sdCap2(pos, elbow1, wrist1-.05*normalize(wrist1-elbow1), .1, .08));\n   \n    vec3 p2 = (pos-wrist1)*baseArm1; \/\/ change to hand base\n    float d2 = sdCap(p2,vec3(-.1,.12,.04),vec3(-.04,.18,.06))-.05;\n    p2.z -= 1.5*p2.x*p2.x;\n    d2 = min(d2,sdEllipsoid(p2-vec3(.02,.05,0), vec3(.17,.14,.07)));\n\n    \/\/ Arm 2\n    dTorso = smin(dTorso, sdCap(pos, shoulder2, mix(shoulder2,elbow2,.3))- .1,.05);\n    dSkin = smin(dSkin, sdCap2(pos, shoulder2, elbow2, .11,.1),.05);\n    dSkin = min(dSkin, sdCap2(pos, elbow2, wrist2-.105*normalize(wrist2-elbow2), .1, .08));\n    \n    p2 = (pos - wrist2)*baseArm2; \/\/ change to hand base\n    d2 = min(d2,sdCap(p2,vec3(-.1,.12,.04),vec3(-.04,.18,.06))-.05);\n    p2.z -= 1.5*p2.x*p2.x;\n    d2 = min(d2,sdEllipsoid(p2-vec3(.02,.05,0), vec3(.17,.14,.07)));\n    \n   \tdSkin = smin(d2, dSkin, .1);\n\n    \/\/ Short\n    float dShort = min(sdCap(pos, hip1, mix(hip1,knee1,.7)), \n                       sdCap(pos, hip2, mix(hip2,knee2,.7)))-.14;  \n    dShort = min(dShort, smin(dShort, sdEllipsoid(pos-ha0-vec3(.01,.06,0),vec3(.23,.3,.3)), .05));\n \n    \/\/ Belt\n    vec3 p3 = p0;\n    p3.y -= ha0.y+.2;\n    float dBelt = max(max(min(dTorso-.05,dShort-.02), p3.y), -p3.y-.16);\n    dShoes1 = min(dShoes1, dBelt); \n\n    float dMetal = mix(dBelt,sdCappedCylinder((p0-ha0-vec3(.2,.11,0)).zxy, vec2(.07,.14)),.5);\n    float dNeck2 = length(pos - ep0)-.25;\n    dTorso = max(max(dTorso-.03, -dNeck2), -dSkin + .005);\n    dTorso = max(dTorso, -pos.y + a.y);\n\n    pos.x += .2;\n    pos = pos - ep0;\n    pos *= baseBag;\n    vec3 pos0 = pos;\n    \n    \/\/ Backpack\n    float ta = cos(2.8+.25*PI*gTime);\n\n    \/\/ Water\n    vec3 p = pos - vec3(-.50,-.5,-.4);\n    p.xy *= rot2;\n    dMetal = min(dMetal, min(sdCap(p,vec3(0), vec3(0,-.4-.04*ta,-.04*ta))- .1,\n                             sdCap(p,vec3(0,.1,.01*ta), vec3(0,.15,.015*ta))-.07)); \n    pos.z = abs(pos.z);\n    float dPack = sdBezier(pos, vec3(-.2,.2,.17),vec3(.9,.2,.36),vec3(-.2,-.6,.3)).x-.04;\n   \n    dPack = mix(dPack, dTorso,.2);\n\n    pos = pos0;\n  \n    float ta2 = cos(2.5+.25*PI*gTime);\n    pos.y += .15*ta2*ta2;\n    pos.z += .06*ta2*ta2*ta2;\n#ifdef WITH_SPIRAL  \n    float dBed = sdSpiral(pos-vec3(-.35-.14,.5-.16,0), vec2(.015,.5));\n#else\n    float dBed = sdCappedCylinder(pos.yzx+vec3(-.35,0,.5), vec2(.2,.5)); \n#endif     \n    \/\/ Teapot\n    vec3 posTeapot = 3.*(pos - vec3(-.9,.25,.4)).yxz;\n    posTeapot.xy *= rot2;\n    posTeapot.yz *= rot;\n    posTeapot.yx *= -1.; \n    float dTeapot = .7*sdTeapot(posTeapot-vec3(1.,-1.,0))\/3.;\n    \n    dPack = min(dPack, sdCappedCylinder(pos-vec3(-.75,.23,.26), vec2(.05,.03))); \n    pos.z = abs(pos.z);\n    dPack = min(dPack, sdCappedCylinder(pos.yzx-vec3(.35,.25,-.5), vec2(.22,.05))); \n    dPack = min(dPack, udRoundBox(pos0-vec3(-.33,-.25,-.35), vec3(.08,.1,.1),.04)); \n    dPack = smin(dPack, udRoundBox(pos0-vec3(-.33,-.2,0), vec3(.1,.3,.2), .15), .12);\n    \n    \/\/ Little box\n    dBed = min(dBed, udRoundBox(pos0-vec3(-.33,-.1,-.35), vec3(.08,.1,.1),.0)); \n    \n    \/\/ Cap\n    pos = posHead + h2;\n    float d = pos.x*.2-pos.y+.15*cos(5.*pos.z)-.12;\n    float dHat = max(sdCap(pos, vec3(0), vec3(.2,0,0))-.27, -d);\n    dHat = min(dHat, mix(dSkin, sdCappedCylinder(pos, vec2(.25,.23)),.4)-.01);      \n    dHat = max(dHat, d-.02);\n    dPack = min(dPack, dHat);\n\n    \/\/ Asssociate distance to materials\n    res = min2(res, vec2(dTeapot, TEAPOT));\n    res = min2(res, vec2(dTorso, SHIRT));\n    res = min2(res, vec2(dShort, SHORT));\n    res = min2(res, vec2(dShoes1, SHOES1));\n    res = min2(res, vec2(dShoes2, SHOES2));\n    res = min2(res, vec2(dSkin, SKIN));\n    res = min2(res, vec2(dMetal, METAL));\n    res = min2(res, vec2(dPack, BAG));\n    res = min2(res, vec2(dBed, BED));\n    \n    \/\/ Distance field is not percise for cap, teapot and hands\n    res.x *= .8;\n    return res;\n}\n\n#ifdef PANEL\n\nfloat sdFont(in vec2 p, in int c) {\n    vec2 uv = (p + vec2(float(c%16), float(15-c\/16)) + .5)\/16.;\n    return max(max(abs(p.x) - .25, max(p.y - .35, -.38 - p.y)), textureLod(iChannel1, uv, 0.).w - 127.\/255.);\n}\n\nfloat sdMessage2D(in vec2 p, int i0, in int[15] txt, in float scale) { \n    p \/= scale;\n \tfloat d = 999., w = .45; \/\/ letter width  \n    p.x += w*float(txt.length()-1)*.5; \/\/ center text arround 0\n    for (int id = i0; id<15; id++){\n        if (txt[id] == 0) break;\n    \td = min(d, sdFont(p, txt[id]));   \n    \tp.x -= w; \n    }\n    return scale*d;\n}\n\nvec2 sdPanel(vec3 p) {\n    p.x -= 300.;\n    p.z += 2.5;\n    float d = udRoundBox(p, vec3(.05,1.9,.05),.01);\n    d = min(d, udRoundBox(p-vec3(0,1.5,.07), vec3(.7,.25,.02),.01));  \n    return vec2(d, PANEL);\n}\n\n#endif\n\nvec2 map(in vec3 p0){\n    \/\/ Little stones    \n    vec2 size = vec2(35.,20.),\n         id = floor((p0.xz + size*0.5)\/size);\n    vec3 pos = p0;\n    pos.xz = mod(p0.xz + size*0.5,size) - size*0.5;\n    vec2 h = 1.-2.*hash22(id);\n    float r = .15+.25*abs(h.x),\n          d = length(pos - vec3(h.x*5.,-r*.4,7.*h.y))-r;\n    vec2 res = vec2(d,GROUND);\n#ifdef PANEL\n    res = min2(res, sdPanel(p0)); \n#endif\n#ifdef BONE\n    res = min2(res, sdBone(p0));\n#endif    \n    d = length(p0-hip1)-2.;\n    if (d<0.) {\n        return min2(sdMan(p0), res);\n    } else {    \n        return min2(vec2(d+.1,999.), res);\n    }\n}\n\n\/\/---------------------------------------------------------------------\n\/\/   Ray marching scene if ray intersect bbox\n\/\/---------------------------------------------------------------------\n\nvec2 Trace( in vec3 ro, in vec3 rd) {\n    vec2 res = vec2(999,0);\n    float t = .5;\n    for( int i=ZERO; i<128 && t<100.; i++ ) {\n        vec2 h = map( ro+rd*t);\n        if( abs(h.x)<.0005*t ) { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    return res;\n}\n\n\/\/------------------------------------------------------------------------\n\/\/ [Shane] - Desert Canyon - https:\/\/www.shadertoy.com\/view\/Xs33Df\n\/\/------------------------------------------------------------------------\n\/\/ Tri-Planar blending function. Based on an old Nvidia writeup:\n\/\/ GPU Gems 3 - Ryan Geiss: http:\/\/http.developer.nvidia.com\/GPUGems3\/gpugems3_ch01.html\nfloat tex3D(sampler2D tex, in vec3 p, in vec3 n){\n    n = max(n*n, .001);\n    n \/= (n.x + n.y + n.z );  \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).x;\n}\n\n\/\/ Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 n, float k){\n    const float ep = .001;\n    vec3 grad = vec3( tex3D(tex, vec3(p.x-ep, p.y, p.z), n),\n                      tex3D(tex, vec3(p.x, p.y-ep, p.z), n),\n                      tex3D(tex, vec3(p.x, p.y, p.z-ep), n));\n    grad = (grad - tex3D(tex, p, n))\/ep;             \n    grad -= n*dot(n, grad);          \n    return normalize(n + grad*k);\n}\n\n\/\/---------------------------------------------------------------------\n\/\/   Ambiant occlusion\n\/\/---------------------------------------------------------------------\n\n#ifdef WITH_AO\nfloat calcAO( in vec3 pos, in vec3 nor ){\n\tfloat dd, hr, sca = 1., totao = 0.;\n    vec3 aopos; \n    for( int aoi=ZERO; aoi<5; aoi++ ) {\n        hr = .01 + .05*float(aoi);\n        aopos = nor * hr + pos;\n        totao += -(map(aopos).x-hr)*sca;\n        sca *= .75;\n    }\n    return clamp(1. - 4.*totao, 0., 1.);\n}\n#endif\n\nfloat textureInvader(vec2 uv) {\n\tfloat y = 7.-floor((uv.y)*16.+4.);\n\tif (y<0. || y>7.) return 0.;\n\tfloat x = floor((abs(uv.x))*16.),\n\t      v=y>6.5? 6.:y>5.5? 40.:y>4.5? 47.:y>3.5?63.:\n\t\t\ty>2.5? 27.:y>1.5? 15.:y>0.5? 4.:8.;\n\treturn floor(mod(v\/pow(2.,x), 2.0)) == 0. ? 0.: 1.;\n}\n\nvec3 doColor(in vec3 p, in vec3 rd, in vec3 n, in vec2 res){\n    \/\/ sky dome\n    vec3 skyColor =  .5*vec3(.5, .6, .9),\n         col = skyColor - max(rd.y,0.)*.5;\n  \n    float ss = .5, sp = 0.;\n#ifdef BONE    \n    if (res.y == GROUND || res.y == BONE) {\n#else    \n    if (res.y == GROUND) {\n#endif    \n        col = .7+ .5 *vec3(texture(iChannel0,.1*p.zx).x)+p.y;\n        col.r *= .8;\n        n = doBumpMap(iChannel0, .1*p, n, .002);\n        ss = 0.;\n        sp = .3;\n    } else \n    if (res.y == SHOES1) {\n        sp = .1;\n        vec3 pFoot = (p-ankle1)*baseFoot1;\n        col = mix(vec3(.1,.1,0), vec3(0,0,.1), smoothstep(-.1,-.09,pFoot.z));\n    } else if (res.y == SHOES2) {\n        col = vec3(0,0,.1);\n        sp = .1;\n        vec3 pFoot = (p-ankle2)*baseFoot2;\n        col = mix(vec3(.1,.1,0), vec3(0,0,.1), smoothstep(-.1,-.09,pFoot.z));\n    } else if (res.y == SKIN) {\n        col = vec3(222,177,144)\/255.;\n        ss = 1.;\n        sp = .1;\n        if (p.x>head.x) {\n\t\t\t\/\/ Draw simple face\n            vec3 phead = (p - head);\n            phead.xz *= rot1;\n\t\t\tvec2 p2 = phead.zy;\n            p2.x = abs(p2.x);\n            float d = length(p2-vec2(.1,0))-.02;\n            d = min(d, max(length(p2-vec2(0.,-.18))-.05, -length(p2-vec2(0.,-.14))+.07))            ;\n            col = mix(vec3(0), col, smoothstep(.0,.01,d));\n\t\t}\n    } else if (res.y == METAL) {\n        col = vec3(.8,.9,1.);\n        sp = 2.;\n    } else if (res.y == SHORT) {\n        col = vec3(.35,.7,.85);\n    } else if (res.y == BAG) {\n\/\/        vec3 ep0 = mix(shoulder1,shoulder2,.5);\n\/\/        p.x += .2;\n\/\/        p -= ep0;\n        col = vec3(.3,.5,.2);\n\/\/        nor = doBumpMap(iChannel0, .1*(p*baseBag), nor, .002);\n        sp = .1;\n    } else if (res.y == SHIRT) {\n        col = vec3(.3,.4,.5);\n        vec2 p2 = p.zy;\n        p2.y -= mix(mix(shoulder2,shoulder1,.5),\n                    mix(hip2,hip1,.5),.5).y;\n        col *= 1.-.5*textureInvader(p2*1.9-vec2(0,.3));\n        ss = .2;\n    } else if (res.y == TEAPOT) {\n        col = vec3(1.,.01,.01);\n        sp = .5;\n    } else if (res.y == BED) {\n        col = vec3(1.,.5,.01);\n        ss = 1.;\n        sp = .3;\n    }\n#ifdef PANEL\n    else if (res.y == PANEL) {\n        col = vec3(.8,.4,.1);\n        if (p.z > -2.4) {\n            int[] gtxt = int[] (72,69,76,76,79,0,0,70,65,66,82,73,67,69,33);\n            float d = min(sdMessage2D(p.xy-vec2(300.66,1.6),0, gtxt, .3),\n                          sdMessage2D(p.xy-vec2(300.5,1.4),7, gtxt, .3));\n            col = mix(vec3(0), col, smoothstep(.0,.01,d));\n        }\n    }\n#endif\n    else {\n        return col;\n    }\n#ifdef BONE    \n    if (res.y == BONE) {\n        ss = 1.;\n        sp = 1.;\n    }\n#endif    \n    vec2 d = vec2(res.x, res.y);\n    vec3 ld = -normalize(vec3(50,100,-100)-p);\n    \/\/ IQ sss version\n    float sss = ss*0.2*clamp(0.5+0.5*dot(ld,n),0.0,1.0)*(2.0+dot(rd,n));\n    vec3 r = reflect(rd,n);\n    float diff = max(0.,dot(n,ld)),\n         amb = dot(n,ld)*.45+.55,\n         spec = pow(max(0.,dot(r,ld)),40.),\n         fres = pow(abs(.7+dot(rd,n)),3.),   \n         ao = calcAO(p, n);\n    \/\/ ligthing     \n    col = col*mix(1.2*vec3(.25,.08,.13),vec3(.984,.996,.804), mix(amb,diff,.75)) + \n          spec*sp+fres*mix(col,vec3(1),.7)*.4;\n    \/\/ kind of sub surface scatering      \n    col += sss*vec3(1.,.3,.2);\n    \/\/ sky light reflected from the ground\n    col += max(0.,dot(vec3(0,-1,0), n))*.1*skyColor;\n    \/\/ ambiant occusion\n    col *= mix(ao,1.,.5);\n    \/\/ fade in distance\n    return mix( col, skyColor, smoothstep(30.,100., res.x) );\n}\n\n\n\/\/---------------------------------------------------------------------\n\/\/   Calculate normal\n\/\/ inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n\/\/---------------------------------------------------------------------\nvec3 normal(in vec3 pos, vec3 rd, float t ) {\n    vec3 n = vec3(0);\n    for( int i=ZERO; i<4; i++) {\n        vec3 e = .5773*(2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.);\n        n += e*map(pos+.002*e).x;\n    }\n\treturn normalize(n - max(0., dot(n,rd ))*rd);\n}\n\n\/\/---------------------------------------------------------------------\n\/\/   Camera\n\/\/---------------------------------------------------------------------\n\nmat3 setCamera( in vec3 ro, in vec3 ta, in float r) {\n\tvec3 w = normalize(ta-ro),\n         p = vec3(sin(r), cos(r),0.),\n         u = normalize( cross(w,p) ),\n         v = normalize( cross(u,w) );\n    return mat3( u, v, w );\n}\n\n\/\/---------------------------------------------------------------------\n\/\/   Entry point\n\/\/---------------------------------------------------------------------\n\/\/#define iTime (iTime + 250.) \/\/ Direct to big Bone\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    \/\/ Teapot body profil (8 quadratic curves) \n\tA[0]=vec2(0,0);A[1]=vec2(.64,0);A[2]=vec2(.64,.03);A[3]=vec2(.8,.12);A[4]=vec2(.8,.3);A[5]=vec2(.8,.48);A[6]=vec2(.64,.9);A[7]=vec2(.6,.93);\n    A[8]=vec2(.56,.9);A[9]=vec2(.56,.96);A[10]=vec2(.12,1.02);A[11]=vec2(0,1.05);A[12]=vec2(.16,1.14);A[13]=vec2(.2,1.2);A[14]=vec2(0,1.2);\n\t\/\/ Teapot spout (2 quadratic curves)\n\tT1[0]=vec2(1.16, .96);T1[1]=vec2(1.04, .9);T1[2]=vec2(1,.72);T1[3]=vec2(.92, .48);T1[4]=vec2(.72, .42);\n\t\/\/ Teapot handle (2 quadratic curves)\n\tT2[0]=vec2(-.6, .78);T2[1]=vec2(-1.16, .84);T2[2]=vec2(-1.16,.63);T2[3]=vec2(-1.2, .42);;T2[4]=vec2(-.72, .24);\n\n    gTime = iTime*6.;\n   \n    \/\/ Animation\n    int it = int(floor(gTime));\n    float kt = fract(gTime), dz = 1.;\n   \n    head = getPos(HEAD, it, kt, dz);\n\n    shoulder1 = getPos(SHOULDER, it, kt, -dz);\n    elbow1 = getPos(ELBOW, it, kt, -dz);\n    wrist1 = getPos(WRIST, it, kt, -dz);\n    \n    foot1 = getPos(FOOT, it, kt, dz);\n    ankle1 = getPos(ANKLE, it, kt, dz);\n    knee1 = getPos(KNEE, it, kt, dz);\n    hip1 = getPos(HIP, it, kt, dz);\n    \n    shoulder2 = getPos(SHOULDER, it+4, kt, dz);\n    elbow2 = getPos(ELBOW, it+4, kt, dz);\n    wrist2 = getPos(WRIST, it+4, kt, dz);\n\n    foot2 = getPos(FOOT, it+4, kt, -dz);\n    ankle2 = getPos(ANKLE, it+4, kt, -dz);\n    knee2 = getPos(KNEE, it+4, kt, -dz);\n    hip2 = getPos(HIP, it+4, kt, -dz);\n    \n    float dx = it%8 < 4 ? -85.*.02 : 85.*.02; \n    foot2.x += dx;\n    ankle2.x += dx;\n    knee2.x += dx;\n    hip2.x += dx;\n\n    shoulder2.x += dx;\n    elbow2.x += dx;\n    wrist2.x += dx;\n    \n    vec3 v1 = normalize(wrist1-elbow1),\n    v0 = normalize(wrist1-shoulder1),\n    v3 = normalize(cross(v1,v0)),\n    v2 = cross(v1,v3);\n    baseArm1 = mat3(v0,v2,-v3);\n    \n    v1 = normalize(wrist2-elbow2),\n    v0 = normalize(wrist2-shoulder2),\n    v3 = normalize(cross(v1,v0)),\n    v2 = cross(v1,v3);\n    baseArm2 = mat3(v0,v2,v3);\n    \n    v1 = normalize(shoulder1-shoulder2);\n    v0 = normalize(mix(hip1,hip2,.5)-mix(shoulder1,shoulder2,.5));\n    v2 = normalize(cross(v1,v0));\n    v3 = normalize(cross(v1,v2));\n    baseBag = mat3(-v2,v3,v1);\n    \n    v2 = normalize(knee1 - ankle1);\n    v1 = normalize(ankle1 - foot1-v2*.1);\n    v3 = cross(v1,v2);\n    baseFoot1 = mat3(v1,v3,-cross(v1,v3));\n    \n    v2 = normalize(knee2 - ankle2);\n    v1 = normalize(ankle2 - foot2-v2*.1);\n    v3 = cross(v1,v2);\n    baseFoot2 = mat3(v1,v3,-cross(v1,v3));\n    \n    float a = -1.5708*.4;\n    rot = mat2(cos(a), sin(a), -sin(a), cos(a));\n     \n    a = .2*cos(.4*iTime) + .3*cos(.05*iTime);\n    rot1 = mat2(cos(a), sin(a), -sin(a), cos(a));\n     \n    a = .5*cos(.5*3.141592*gTime);\n    a = a*a;\n    rot2 = mat2(cos(a), sin(a), -sin(a), cos(a));\n    \n\/\/ ------------------------------------\n \n    \/\/ Screen \n    vec2 q = fragCoord.xy\/iResolution.xy, \n         m = iMouse.xy\/iResolution.y - .5,\n         p = -1.+2.*q;\n    p.x *= iResolution.x\/iResolution.y;        \n      \n    \/\/ Camera\t\n    vec3 ro = vec3(  hip1.x+12.*cos(PI*(.05*iTime+m.x)),\n                4.5+2.*(sin(.1*iTime))+4.*(m.y+.3),\n                hip1.z+12.*sin(PI*(.05*iTime+m.x)));\n    vec3 ta = hip1;\n    ta.x +=1.2;\n    ta.y = 1.2;\n    mat3 ca = setCamera(ro, ta, 0.);\n    vec3 rd = ca * normalize(vec3(p.xy,4.5) );\n  \n    \/\/ Ray intersection with scene\n    vec2 res = Trace(ro, rd);\n    if (rd.y >= 0.) {\n       res = min2(res, vec2(999.,100.));\n    } else {        \n       res = min2(res, vec2(-ro.y \/ rd.y,GROUND));\n    }\n    \n    \/\/ Rendering\n    vec3 pos = ro + rd*res.x;\n    vec3 n = pos.y<.02 ? vec3(0,1,0) : normal(pos, rd, res.x);\n    vec3 col = doColor(pos, rd, n, res);\n    col = pow( col, vec3(.4545) );                 \/\/ Gamma    \n    col *= pow(16.*q.x*q.y*(1.-q.x)*(1.-q.y), .1); \/\/ Vigneting\n     \n\tfragColor = vec4(col,1);\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"fldSRB","date":"1639355776","viewed":9315,"name":"Malmousque","username":"XT95","description":"A lot based on my previous shader, but some new tricks here :\n- Rock based on triangles\n- Foams\n- More temporal accumulations on the out of focus part!\n- PBR Sky\n","likes":131,"published":3,"flags":32,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ ---------------------------------------------------------------------------------\n\/\/ Compositing pass\n\/\/ ---------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 invRes = vec2(1.) \/ iResolution.xy;\n    vec2 uv = fragCoord * invRes;\n\n    \/\/ Chromatic aberration\n    vec2 offset = (uv*2.-1.)\/iResolution.xy*.75;\n    vec4 col = vec4(0.);\n    col.r = texture(iChannel0, uv+offset).r;\n    col.g = texture(iChannel0, uv-offset).g;\n    col.b = texture(iChannel0, uv+offset).b;\n\n    \/\/ Vignetting & color grading\n    col *= pow( uv.x * uv.y * (1.-uv.x) * (1.-uv.y)*100., .15 );\n    col = pow(col, vec4(1.0,1.05,1.1, 1.));\n    \n    \/\/ Gamma correction\n    fragColor = pow(col*3., vec4(1.\/2.2));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ ---------------------------------------------------------------------------------\n\/\/ Sky\n\/\/ https:\/\/www.scratchapixel.com\/lessons\/procedural-generation-virtual-worlds\/simulating-sky\/simulating-colors-of-the-sky\n\/\/ ---------------------------------------------------------------------------------\nfloat iSphere(vec3 ro, vec3 rd, float radius) {\n    float b = 2.0 * dot(rd, ro);\n    float c = dot( ro, ro ) - radius * radius;\n    float disc = b * b - 4.0 * c;\n    if (disc < 0.0)\n        return (-1.0);\n    float q = (-b + ((b < 0.0) ? -sqrt(disc) : sqrt(disc))) \/ 2.0;\n    float t0 = q;\n    float t1 = c \/ q;\n    return max(t0,t1);\/\/vec2(t0,t1);\n}\n\nvec3 skyColor( in vec3 rd )\n{\n    const int nbSamples = 64;\n    const int nbSamplesLight = 32;\n    \n    vec3 absR = vec3(3.8e-6f, 13.5e-6f, 33.1e-6f);\n    vec3 absM = vec3(21e-6f);\n    \n    \n    vec3 accR = vec3(0.);\n    vec3 accM = vec3(0.);\n    \n    float mu = dot(rd, sundir);\n    float g = 0.76f; \n    vec2 phase = vec2(3.f \/ (16.f * PI) * (1. + mu * mu), 3.f \/ (8.f * PI) * ((1.f - g * g) * (1.f + mu * mu)) \/ ((2.f + g * g) * pow(1.f + g * g - 2.f * g * mu, 1.5f)));\n\n    float radA = 6420e3;\n    float radE = 6360e3;\n    vec3 ro = vec3(0., radE+1., 0.);\n    float t = iSphere(ro, rd, radA);\n    float stepSize = t \/ float(nbSamples);\n    \n    vec2 opticalDepth = vec2(0.);\n    \n    for(int i=ZERO; i<nbSamples; i++) {\n     \tvec3 p = ro + rd * (float(i)+.5) * stepSize;\n        \n        float h = length(p) - radE;\n        vec2 thickness = vec2(exp(-h\/7994.), exp(-h\/1200.)) * stepSize;\n        opticalDepth += thickness;\n        \n        float tl = iSphere(p, sundir, radA);\n        float stepSizeLight = tl \/ float(nbSamplesLight);\n        vec2 opticalDepthLight = vec2(0.);\n        int j;\n        for(j=ZERO; j<nbSamplesLight; j++) {\n            vec3 pl = p + sundir * (float(j)+.5) * stepSizeLight;\n            float hl = length(pl) - radE;\n            if (hl < 0.) break;\n        \topticalDepthLight += vec2(exp(-hl\/7994.), exp(-hl\/1200.)) * stepSizeLight;\n        }\n        if (j == nbSamplesLight) {\n            vec3 tau = absR * (opticalDepth.x + opticalDepthLight.x) + absM * 1.1 * (opticalDepth.y + opticalDepthLight.y);\n            vec3 att = exp(-tau);\n            accR += att * thickness.x ;\n            accM += att * thickness.y;\n        }\n    }\n    \n    return (accR * absR * phase.x + accM * absM * phase.y)*1.5;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord \/ iResolution.xy*4.;\n    \n    if (uv.x>1. || uv.y>1.) return;\n    \n    vec3 rd = equi2cube(uv);\n    \n    \/\/ compute only on the first frame!\n    \/\/if (iFrame < 4) {\n        fragColor = vec4(skyColor(rd), 1.);\n    \/\/} else {\n    \/\/    fragColor = texture(iChannel0, uv*.25);\n    \/\/}\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define ZERO (min(iFrame,0)) \/\/ skip unroll loop\n#define saturate(x) clamp(x,0.,1.)\n#define PI 3.141592653589\n#define PI_2 1.5707963267948966192313216916398\n#define PI_X_2 6.283185307179586476925286766559\n#define GOLDEN_RATIO 0.61803398875\n#define time iTime\n#define frame iFrame\n\nvec3 sundir = normalize( vec3(1.5,.8,2.) );\n\n\n\n\/\/ ---------------------------------------------------------------------------------\n\/\/ Maths toolbox\n\/\/ ---------------------------------------------------------------------------------\nfloat seed = 0.;\nfloat rand() { return fract(sin(seed++)*43758.5453123); }\nvec3 tri(vec3 x) {\n    return abs(x-floor(x)-.5);\n}\nvec3 hash3(vec3 p) {\n    uvec3 x = uvec3(p*100000.+1000.);\n    const uint k = 1103515245U; \n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0\/float(0xffffffffU));\n}\n\n\nfloat hash( vec2 p )\n{\n    return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453123);\n}\nfloat hash( float p )\n{\n    vec3 p3  = fract(vec3(p) * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 randomSphereDir(vec2 rnd)\n{\n    float s = rnd.x*PI*2.;\n    float t = rnd.y*2.-1.;\n    return vec3(sin(s), cos(s), t) \/ sqrt(1.0 + t * t);\n}\nvec3 randomHemisphereDir(vec3 dir, float i)\n{\n    vec3 v = randomSphereDir( vec2(hash(i+1.), hash(i+2.)) );\n    return v * sign(dot(v, dir));\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )\/k;\n    return min( a, b ) - h*h*k*(1.0\/4.0);\n}\n\nfloat noise( vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n    \n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm( vec2 p) {\n    float d = noise(p) * .5;\n    d += noise(p*2.) * .25;\n    d += noise(p*4.) * .125;\n    \n    return d;\n}\nfloat capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\nvec3 equi2cube (vec2 uv) {\n    vec2 thetaphi = (uv*2.-1.) * vec2(PI, PI_2); \n    return vec3(cos(thetaphi.y) * cos(thetaphi.x), sin(thetaphi.y), cos(thetaphi.y) * sin(thetaphi.x));\n}\n\nvec2 cube2equi (vec3 p) {\n    return vec2((atan(p.z, p.x) \/ PI_X_2) + 0.5, acos(-p.y) \/ PI);    \n}\n\n\/\/ ---------------------------------------------------------------------------------\n\/\/ Triplanar mapping + bump mapping! \n\/\/ clever code taken from Shane\n\/\/ https:\/\/www.shadertoy.com\/view\/MscSDB\n\/\/ ---------------------------------------------------------------------------------\nvec3 tex3D( sampler2D tex, vec3 p, vec3 n )\n{\n    n = abs(n);\n    vec4 col = texture(tex, p.yz)*n.x + texture(tex, p.xz)*n.y + texture(tex, p.xy)*n.z;\n    return pow(col.rgb,vec3(2.2));\n}\n\nvec3 bumpMapping( sampler2D tex, vec3 p, vec3 n, float bf )\n{\n    const vec2 e = vec2(0.001, 0);\n    \n    mat3 m = mat3( tex3D(tex, p - e.xyy, n).rgb,\n                   tex3D(tex, p - e.yxy, n).rgb,\n                   tex3D(tex, p - e.yyx, n).rgb);\n    \n    vec3 g = vec3(0.299, 0.587, 0.114) * m;\n    g = (g - dot( tex3D(tex,  p , n).rgb, vec3(0.299, 0.587, 0.114)) )\/e.x;\n    g -= n * dot(n, g);\n                      \n    return normalize( n + g*bf );\n    \n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"Xsf3Rr","filepath":"\/media\/a\/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"\/media\/ap\/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/\/ ---------------------------------------------------------------------------------\n\/\/ Raytracing pass\n\/\/ ---------------------------------------------------------------------------------\n\nconst mat3 mt = mat3(0.33338, 0.56034, -0.71817, -0.87887, 0.32651, -0.15323, 0.15162, 0.69596, 0.61339)*1.93;\nconst mat2 mw = mat2(1.6,1.2,-1.2,1.6);\n\n\n\n\/\/ ---------------------------------------------------------------------------------\n\/\/ Signed Distance Field\n\/\/ ---------------------------------------------------------------------------------\nfloat terrain(vec3 p) {\n    \n    float d = length(p.xy-vec2(-4.,0.))-2.;\n    d = smin(d, capsule(p, vec3(-5.,0.,7.), vec3(0.,2.,7.), 1.), 1.7);\n    d = smin(d, p.y-.1+smoothstep(-3.1,5.,p.x)*2., 0.1);\n    \n    \/\/ Add detail only if we are closed of the surface\n    if (d < 1.) {\n        \/\/ Inspired by many shaders of Shane, the master of the rock.\n        float z = 1.;\n        for(int i = 0; i < 6; i++)\n        {\n            d -= dot(tri(p*.5 + tri(p.yzx*.375)), vec3(.4*z));\n            z *= -0.55;\n            p = p*mt;\n        }\n    }\n    \n    return d;\n}\nfloat water(vec3 p) {\n    float d = p.y;\n    \n    float amp = .1;\n    p.xz *= mw;\n    float t = time*.3;\n    \n    \/\/ Add detail only if we are closed of the surface\n    if (d < .2) {\n        for(int i=0; i<6; i++)\n        {\n            d -= (1.-abs(sin(noise(p.xz-t)))) * amp;\n            amp *= .5;\n            p.xz *= mw;\n        }\n    }\n    \n    return d;\n}\n\nfloat map(vec3 p) {\n    float d1 = terrain(p);\n    float d2 = water(p);\n    float d = min(d1,d2);\n    return d;\n    \n}\n\n\n\/\/ ---------------------------------------------------------------------------------\n\/\/ Raytracing toolbox\n\/\/ ---------------------------------------------------------------------------------\nvec3 raymarch(vec3 ro, vec3 rd, const vec2 nf) {\n    vec3 p = ro + rd * nf.x;\n    float l = 0.;\n    for(int i=ZERO; i<70; i++) {\n        float d = map(p);\n        l += d;\n        p += rd * d;\n        \n        if(abs(d)<.01 || l > nf.y)\n            break;\n    }\n    \n    return p;\n}\n\nvec3 normal( vec3 p )\n{\n    const float h = 0.005;\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*h);\n    }\n    return normalize(n);\n}\n\n\nvec3 raymarchUnderwater(vec3 ro, vec3 rd, const vec2 nf) {\n    vec3 p = ro + rd * nf.x;\n    float l = 0.;\n    for(int i=ZERO; i<32; i++) {\n        float d = terrain(p);\n        l += d;\n        p += rd * d;\n        \n        if(abs(d)<.05 || l > nf.y)\n            break;\n    }\n    \n    return p;\n}\n\/\/ Simplified version of https:\/\/www.shadertoy.com\/view\/4sdGWN - http:\/\/www.aduprat.com\/portfolio\/?page=articles\/hemisphericalSDFAO\nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff )\n{\n\tconst int nbIte = 6;\n    const float nbIteInv = 1.\/float(nbIte);\n    const float rad = 1.-1.*nbIteInv;\n    \n\tfloat ao = 0.0;\n    \n    for( int i=ZERO; i<nbIte; i++ )\n    {\n        float l = hash(float(i))*maxDist;\n        vec3 rd = normalize(n+randomHemisphereDir(n, l )*rad)*l;\n        \n        ao += (l - max(terrain( p + rd ),0.)) \/ maxDist * falloff;\n    }\n\t\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\/\/ iq Soft Shadow - https:\/\/iquilezles.org\/articles\/rmshadows\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = terrain(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h\/t );\n        t += h;\n    }\n    return res;\n}\n\n\/\/ ---------------------------------------------------------------------------------\n\/\/ Shading\n\/\/ ---------------------------------------------------------------------------------\nvec3 skyColor(vec3 rd) {\n    return texture(iChannel3, cube2equi(rd)*.25).rgb;\n}\nvec3 shade(vec3 ro, vec3 rd, vec3 p, vec3 n) {\n    vec3 sky = skyColor(rd);\n    if (map(p) > .3) return sky;\n    \n    float wet = smoothstep(.15+fbm(p.xz*30.)*.15,0.15,p.y) * step(0.,water(p));\n    \n    vec3 albedo = tex3D(iChannel1,p*1.,n)*vec3(.3,.275,.25)* (smoothstep(.1,0.4,p.y)+.1);\n    albedo = mix(albedo, vec3(0.09,0.15,0.03)*0.5, saturate(fbm(p.xz*20.2)*2.-.3)*wet*.075);\n    albedo = mix(albedo, vec3(0.1,0.03,0.2)*0.5, saturate(fbm(p.xz*20.2+1.)*2.-.6)*wet*.075);\n    n = bumpMapping(iChannel1,p*1.,n,.005);\n\n    float shad = shadow(p,sundir, .5,10., 10.);\n    float ao = ambientOcclusion(p,n, 5.5,1.7);\n    ao *= smoothstep(0.5,5., length(p-vec3(-1.,0.5,4.5)));\n    \n    vec3 diff = vec3(1.,.5,.3) * saturate(dot(n,sundir)+.1) * pow(vec3(shad),vec3(1.0,1.3,1.8));\n    vec3 skyl = vec3(0.2,0.25,0.35) * (n.y*.25+.75) * ao;\n    vec3 bounce = vec3(1.,.5,.3) * max(dot( n, normalize(sundir*vec3(-1.0,0.0,-1.0))), 0.0) * ao;\n    vec3 spe = vec3(1.,.8,.5) * pow(max(dot(reflect(rd,n),sundir),0.), 80.) * shad * wet;\n    \n    vec3 col = albedo * ( diff*3.+ skyl*1.3 + bounce*.2 + spe*50. );\n    \n    return col;\n}\n\nvec3 calcPixel(vec3 ro, vec3 rd, float seed, inout vec3 firstP) {\n    \n    \/\/ Raytracing primary ray\n    vec3 p = raymarch(ro,rd, vec2(1.,60.));\n    firstP = p;\n    vec3 n = normal(p);\n    float d = map(p);\n    vec3 sky = skyColor(rd);\n    if (d > .3) return sky;\n    \n    \n    vec3 col;\n    \n    \/\/ Fake foam\n    float foam = saturate((fbm(p.xz*70.-time*0.25)+fbm(p.xz*50.+time*0.25))*.5-.34);\n    \n    if (terrain(p) == d) {\n        col = shade(ro,rd, p, n);\n        col = mix(col, vec3(.1), smoothstep(.025,.0,water(p))*foam);\n    } else {\n        \n        \/\/ Reflection\n        vec3 rro = p;\n        vec3 rrd = reflect(rd,n);\n        rrd = normalize(hash3(p+rand())*2.-1.+reflect(rd,n)*3000.);\n        \n        vec3 rp = raymarch(rro,rrd, vec2(.1,10.));\n        vec3 rn = normal(p);\n\n        vec3 reflectedCol = shade(rro,rrd, rp, rn);\n        \/\/ hackish sun specular \n        reflectedCol += vec3(1.,.7,.5)*30. * pow(max(dot(reflect(rd,n), sundir), 0.), 1024.);\n        \n        \/\/ Refraction\n        rro = p;\n        rrd = refract(rd,n, 1.\/1.33);\n        \n        rp = raymarchUnderwater(rro,rrd, vec2(.1,10.));\n        rn = normal(p);\n        vec3 refractedCol = shade(rro,rrd, rp, rn);\n        refractedCol *= exp( -vec3(1.,.4,.2) * length(rp-p)*50.2); \/\/ Beer law for absorption! great blog post -> https:\/\/blog.demofox.org\/2017\/01\/09\/raytracing-reflection-refraction-fresnel-total-internal-reflection-and-beers-law\/\n        \n        \/\/ Mix it with fresnel\n        float fre = pow( saturate( 1.0 + dot(n,rd)), 16.0 );\n        col = mix(refractedCol, reflectedCol , fre);\n        \n        col = mix(col, vec3(.1), smoothstep(.075,.0,terrain(p))*foam);\n    }\n    col = mix(col, sky, smoothstep(10.,60., length(ro-p)));\n    \n    return col;\n}\n\n\/\/ ---------------------------------------------------------------------------------\n\/\/ Entrypoint\n\/\/ ---------------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 invRes = vec2(1.) \/ iResolution.xy;\n    vec2 uv = fragCoord * invRes;\n    seed = iTime + iResolution.y * fragCoord.x \/ iResolution.x + fragCoord.y \/ iResolution.y;\n    vec2 v = -1.0+2.0*(uv);\n    v.x *= iResolution.x\/iResolution.y;\n    \n    \/\/ Camera ray\n    vec3 ro = vec3(-1.,.5,0.);\n    vec3 rd = normalize( vec3(v.x, v.y, 5.) );\n    \n    \/\/ Depth of field\n    float focusDistance = 1.5;\n    float blurAmount = max(0., 0.02*uv.x);\n    vec3 go = blurAmount*vec3( normalize(vec2(rand(),rand())*2.-1.)*sqrt(rand()), 0.0 );\n    vec3 gd = normalize( rd*focusDistance - go );\n    vec3 uu = vec3(1.,0.,0.);\n    vec3 vv = vec3(0.,1.,0.);\n    ro += go.x*uu + go.y*vv;\n    rd += gd.x*uu + gd.y*vv;\n    rd = normalize(rd);\n    \n    \n    \/\/ Compute color\n    vec3 p;\n    vec3 col = calcPixel(ro, rd, seed, p);\n    \n    \n    \/\/ Output with temporal accumulation\n    vec4 lastCol = texture(iChannel0,uv);\n    \n    \/\/ Nice tricks here : more temporal accumulation when we are out of focus :)\n    float taaFactor = (1.05-saturate(abs(focusDistance-length(p-ro))\/1.)) *0.75;\n    if (iFrame == 0) taaFactor = 1.;\n    \/\/taaFactor = 1.;\n    fragColor = mix(lastCol, vec4(saturate(col), length(ro-p)), taaFactor);\n}","name":"Buffer B","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"4lBGRh","date":"1426837649","viewed":9303,"name":"[NV15] 2001 Space Station","username":"otaviogood","description":"My best attempt at making the space station from the movie 2001 a space odyssey.","likes":72,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"\/media\/a\/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"\/media\/ap\/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRn","filepath":"\/media\/a\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"\/media\/ap\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"\/media\/a\/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"\/media\/ap\/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/*--------------------------------------------------------------------------------------\nLicense CC0 - http:\/\/creativecommons.org\/publicdomain\/zero\/1.0\/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^This means do anything you want with this code. Because we are programmers, not lawyers.\n\nSorry this code is pretty messy. I had to finish in time for the competition. :)\n\n-Otavio Good\n*\/\n\nconst int MAX_MARCH_REPS = 100;\nconst float MARCH_DISTANCE_MULTIPLIER = 0.9;\nconst int MAX_SHADOW_MARCHES = 30;\n\nfloat localTime = 0.0;\nconst float earthRad = 6371.0;\nconst vec3 earthPos = normalize(vec3(-6500,-6400,2400)) * (earthRad + 300.0);\n\n\/\/ some noise functions\nfloat Hash(float f)\n{\n    return fract(cos(f)*7561.0);\n}\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 521.0;\t\/\/ repeats after this value\n    float rand = fract(cos(f)*104729.0);\n    return rand;\n}\nvec2 Hash2(vec2 v)\n{\n    return fract(cos(v*3.333)*vec2(100003.9, 37049.7));\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(sin(f)*110003.9);\n}\n\nfloat mixS(float f0, float f1, float a)\n{\n    if (a < 0.5) return f0;\n    return f1;\n}\n\nfloat mixC(float f0, float f1, float a)\n{\n    return mix(f1, f0, cos(a*3.1415926) *0.5+0.5);\n}\n\nfloat mixP(float f0, float f1, float a)\n{\n    return mix(f0, f1, a*a*(3.0-2.0*a));\n}\nvec2 mixP2(vec2 v0, vec2 v1, float a)\n{\n    return mix(v0, v1, a*a*(3.0-2.0*a));\n}\n\nfloat mixSS(float f0, float f1, float a)\n{\n    return mix(f0, f1, smoothstep(0.0, 1.0, a));\n}\n\nconst vec2 zeroOne = vec2(0.0, 1.0);\nfloat noise2dVec(vec2 uv)\n{\n    vec2 fr = fract(uv);\n    vec2 fl = floor(uv);\n    vec2 h0 = vec2(Hash2d(fl), Hash2d(fl + zeroOne));\n    vec2 h1 = vec2(Hash2d(fl + zeroOne.yx), Hash2d(fl + zeroOne.yy));\n    vec2 xMix = mixP2(h0, h1, fr.x);\n    return mixC(xMix.x, xMix.y, fr.y);\n}\nfloat noise2d(vec2 uv)\n{\n    vec2 fr = fract(uv);\n    vec2 fl = floor(uv);\n    float h00 = Hash2d(fl);\n    float h10 = Hash2d(fl + zeroOne.yx);\n    float h01 = Hash2d(fl + zeroOne);\n    float h11 = Hash2d(fl + zeroOne.yy);\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\n}\nfloat noise(vec3 uv)\n{\n    vec3 fr = fract(uv.xyz);\n    vec3 fl = floor(uv.xyz);\n    float h000 = Hash3d(fl);\n    float h100 = Hash3d(fl + zeroOne.yxx);\n    float h010 = Hash3d(fl + zeroOne.xyx);\n    float h110 = Hash3d(fl + zeroOne.yyx);\n    float h001 = Hash3d(fl + zeroOne.xxy);\n    float h101 = Hash3d(fl + zeroOne.yxy);\n    float h011 = Hash3d(fl + zeroOne.xyy);\n    float h111 = Hash3d(fl + zeroOne.yyy);\n    return mixP(\n        mixP(mixP(h000, h100, fr.x),\n             mixP(h010, h110, fr.x), fr.y),\n        mixP(mixP(h001, h101, fr.x),\n             mixP(h011, h111, fr.x), fr.y)\n        , fr.z);\n}\n\nfloat PI=3.14159265;\n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvec3 RotateX(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  \/\/if (RIGHT_HANDED_COORD)\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n  \/\/else return new float3(x, cos * y - sin * z, sin * y + cos * z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  \/\/if (RIGHT_HANDED_COORD)\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n  \/\/else return new float3(cos * x + sin * z, y, -sin * x + cos * z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  \/\/if (RIGHT_HANDED_COORD)\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\nvec3 GetStarColor(vec3 rayDir, vec3 sunDir)\n{\n    rayDir.xyz = rayDir.yzx;\n\tfloat dense = 16.0;\n\tvec3 localRay = normalize(rayDir);\n\tfloat sunIntensity = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\t\/\/sunIntensity = (float)Math.Pow(sunIntensity, 14.0);\n\tsunIntensity = 0.2 \/ sunIntensity;\n\tsunIntensity = min(sunIntensity, 40000.0);\n\tsunIntensity = max(0.0, sunIntensity - 3.0);\n\n\tlocalRay.x = localRay.x + 1.0 - iTime * 0.1;\n\t\/\/vec3 right = normalize(cross(sunDir, vec3(0.0,1.0,0.0)));\n\t\/\/vec3 up = normalize(cross(sunDir, right));\n\tvec2 wrap = fract((localRay.xy)*dense);\n\tvec4 rand = texture(iChannel2, floor(localRay.xy*dense)\/dense).xyzw;\n\tvec3 starColor = rand.xyz;\n\tstarColor = starColor * 0.75 + 0.25;\n\trand.xy = rand.xy * 2.0 - 1.0;\n\tvec2 center = vec2(0.5, 0.5) + rand.xy * 0.9;\/\/ floor(fract((localRay.xy)*8.0)) + 0.5;\n\tfloat star = length(wrap - center);\n\tfloat test = star;\n\tstar = saturate((1.0 - star));\n\tfloat blink = texture(iChannel2, localRay.xy + iTime * 0.03).x;\n\tfloat cluster = 0.3;\/\/ \/*(localRay.x+0.5) *\/ (localRay.y+0.5) * 2.8 + 0.8;\n\tstar = pow(star, 60.0 + saturate(rand.z - 0.0) * 250.0 * cluster);\n\tstar *= blink;\n\t\n\tfloat milkyMask = saturate(0.25 - abs(localRay.x - 0.65));\n\tvec3 milkyway = texture(iChannel3, (localRay.yx*1.5 )+vec2(0.65, 0.3)).yxz;\n\tvec3 milkyLOD = texture(iChannel3, (localRay.yx*1.5 )+vec2(0.65, 0.3), 3.0).yxz;\n\tvec3 milkyDetail = texture(iChannel3, (-localRay.yx*8.0 )+vec2(0.65, 0.3)).yxz;\n\tmilkyway *= milkyDetail.xxx;\n\tmilkyway *= vec3(1.0, 0.8, 0.91)*1.5;\n\tmilkyway = pow(milkyway, vec3(2.0, 2.0, 2.0)*3.0);\n\tmilkyway += vec3(0.2, 0.0015, 1.001) * milkyLOD * 0.006;\n\t\n\tvec3 finalColor = milkyway \/* milkyMask*\/ * 10.0;\n\tfinalColor += \/*environmentSphereColor + sunCol * sunIntensity +*\/ starColor * star * 12.0 * cluster;\n\treturn finalColor;\n\t\/\/return environmentSphereColor + sunCol * sunIntensity + starColor * star * 12000.0 * cluster;\n\t\/\/return vec3(1.0,1.0,1.0)*cluster*1000.0;\n}\n\n\/\/ This function basically is a procedural environment map that makes the sun\nvec3 sunCol = vec3(258.0, 238.0, 210.0) \/ 3555.0;\/\/unfortunately, i seem to have 2 different sun colors. :(\nvec3 GetSunColorReflection(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 localRay = normalize(rayDir);\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\tfloat sunIntensity = 0.015 \/ dist;\n\tsunIntensity = pow(sunIntensity, 0.93)*100.0;\n\n    \/\/sunIntensity += exp(-dist*12.0)*300.0;\n\tsunIntensity = min(sunIntensity, 40000.0);\n    \/\/vec3 skyColor = mix(vec3(1.0, 0.95, 0.85), vec3(0.2,0.3,0.95), pow(saturate(rayDir.y), 0.7))*skyMultiplier*0.95;\n\treturn sunCol * sunIntensity*0.00125;\n}\nvec3 GetSunColorSmall(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 localRay = normalize(rayDir);\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\tfloat sunIntensity = 0.05 \/ dist;\n    sunIntensity += exp(-dist*12.0)*300.0;\n\tsunIntensity = min(sunIntensity, 40000.0);\n\treturn sunCol * sunIntensity*0.025;\n}\n\nvec4 cXX = vec4(0.0, 3.0, 0.0, 0.0);\n\nvec3 camPos = vec3(0.0), camFacing;\nvec3 camLookat=vec3(0,0.0,0);\n\nfloat cylCone(vec3 p)\n{\n    float d = length(p.xy) - 1.0;\n    d = min(d, length(p.xy - 1.0) - 0.1);\n    d = max(0.0, d + max(0.0, abs(p.z) - 1.9)*1.0);\n    return d;\n}\n\nfloat sbox(vec3 p, vec3 size)\n{\n    vec3 a = abs(p) - size;\n    float c = max(a.x, a.y);\n    c = max(c, a.z);\n    return (c);\n}\n\nfloat diamond(vec3 p, vec3 size)\n{\n    vec3 a = abs(p) - size;\n    float c = (a.x*0.5 + a.y*5.0);\n    c = (c + a.z*2.0);\n    return (c*0.25);\n}\n\nfloat cylinderInner(vec3 p, float len)\n{\n    float d = length(p.xy) - clamp(abs(p.z), 0.5, 0.8);\n    \/\/d = min(d, sbox(abs(p) - vec3(1.0\/1.414, 1.0\/1.414, 0.0), vec3(0.1, 0.1, len)));\n    d = max(d, abs(p.z) - len);\n    \/\/ bars above and below hangar\n    vec3 p2 = vec3(p.x, abs(p.y), abs(p.z));\n    d = min(d, sbox(p2 - vec3(0.0, 0.3, 2.0), vec3(0.6, 0.05, 0.025)));\n    \/\/ little rings around hangar area\n    float d3 = length(p.xy) - 0.82;\n    float d2 = max(d3, abs(-p.z + 1.9) - 0.03);\n    d3 = max(d3, abs(p.z + 1.9) - 0.03);\n    return min(d3, min(d, d2));\n}\n\nfloat cylinderV(vec3 p)\n{\n    float rad = 0.15;\n    float len = 4.0;\n    float d = length(p.xz) - rad;\n    float sp = sin(p.y * 10.0);\n    sp = pow(max(0.0, sp - 0.7), 0.4);\n    float ridges = length(p.xz) - rad * abs(sp + 0.5);\n    d = min(d, ridges);\n    \/\/d = min(d, length(p.xy - 1.0) - 0.1);\n    \/\/d = min(d, sbox(abs(p) - vec3(0.25, 0.0, 0.25), vec3(0.03, len, 0.01)));\n    vec2 p2 = vec2(abs(p.x), p.z);\n    d = min(d, length(p2 - vec2(0.25, 0.0)) - 0.02 );\n    d = min(d, length(p2 - vec2(0.35, 0.0)) - 0.02 );\n    float rep = 0.7;\n    vec3 p3 = vec3(abs(p.x), mod(p.y, rep) - rep*0.5, p.z);\n    d = min(d, sbox(p3, vec3(0.35, 0.01, 0.02)));\n    d = max(d, abs(p.y) - len);\n    return d;\n}\n\nfloat outerRadius = 4.0;\nfloat cylinderOuter(vec3 p, float len)\n{\n    float radial = length(p.xy);\n    \/\/float dents = sin(radial * 32.0) * 0.05;\n    \/\/dents = pow(abs(dents), 3.0);\n    float d = -(radial - outerRadius);\n    d = max(d, (radial - (outerRadius + 0.6)));\n    float bevel = abs(radial - (outerRadius + 0.2)) * 0.2;\n    d = max(d, abs(p.z) - len + bevel);\n    return d;\n}\n\nfloat wheel(vec3 p)\n{\n    vec3 p2 = p;\n    if (abs(p2.x) > abs(p2.y)) p2.xy = p2.yx;\n    float d = cylinderV(p2);\n    d = min(d, cylinderOuter(p, 0.25));\n    d = min(d, sbox(vec3(p2.x, abs(p2.y), p2.z) - vec3(0.0, outerRadius, 0.0), vec3(0.4, 0.2, 0.275)));\n    return d;\n}\n\n\/\/ polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)\/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat shipPosition;\nfloat SpaceShip(vec3 p)\n{\n    float d = length(p) - 1.5 + cos(p.z*1.02) * 1.0;\n    d *= 1.1;\n    d = max(d, -sbox(p + vec3(0.0, -0.6, 0.0), vec3(1.0,0.7,1.5)) );\n    d = smin(d, 0.7*diamond(p + vec3(0.0, 0.2, -0.5), vec3(0.1)),0.1);\n    d = max(d, sbox(p, vec3(0.9,4.2,2.5)) );\n    return d;\n}\n\nfloat ScaleShip(vec3 p, float s)\n{\n    return SpaceShip(p\/s)*s;\n}\n\nfloat rotationSpeed = 0.2;\nvec2 DistanceToObject(vec3 p0)\n{\n    float material = 0.0;\n    float h = 0.0;\n    vec3 pr = RotateZ(p0, iTime * rotationSpeed);\n    float d = cylinderInner(pr, 2.0);\n    \/\/p2.x = max(abs(p.x), abs(p.y));\n    \/\/d = sbox(p, vec3(1.0, 1.0, 1.0));\n    vec3 p2 = vec3(pr.x, pr.y, abs(pr.z)) - vec3(0.0, 0.0, 1.5);\n    \/\/p2.z = abs(p2.z);\n    d = min(d, wheel(p2));\n    d = max(d, -sbox(p2, vec3(0.6, 0.2, 0.7)));\t\/\/ ship docking bay - mirrored\n    d = min(d, ScaleShip(pr - vec3(0.0, 0.1, shipPosition), 0.4));\n    material = h;\n    float final = d;\n    return vec2(final, material);\n}\n\nfloat distFromSphere;\nfloat IntersectSphereAndRay(vec3 pos, float radius, vec3 posA, vec3 posB, out vec3 intersectA2, out vec3 intersectB2)\n{\n\t\/\/ Use dot product along line to find closest point on line\n\tvec3 eyeVec2 = normalize(posB-posA);\n\tfloat dp = dot(eyeVec2, pos - posA);\n\tvec3 pointOnLine = eyeVec2 * dp + posA;\n\t\/\/ Clamp that point to line end points if outside\n\t\/\/if ((dp - radius) < 0) pointOnLine = posA;\n\t\/\/if ((dp + radius) > (posB-posA).Length()) pointOnLine = posB;\n\t\/\/ Distance formula from that point to sphere center, compare with radius.\n\tfloat distance = length(pointOnLine - pos);\n\tfloat ac = radius*radius - distance*distance;\n\tfloat rightLen = 0.0;\n\tif (ac >= 0.0) rightLen = sqrt(ac);\n\tintersectA2 = pointOnLine - eyeVec2 * rightLen;\n\tintersectB2 = pointOnLine + eyeVec2 * rightLen;\n\tdistFromSphere = distance - radius;\n\tif (distance <= radius) return 1.0;\n\treturn 0.0;\n}\n\n\/\/ dirVec MUST BE NORMALIZED FIRST!!!!\nfloat SphereIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 spherePos, float rad)\n{\n    vec3 radialVec = pos - spherePos;\n    float b = dot(radialVec, dirVecPLZNormalizeMeFirst);\n    float c = dot(radialVec, radialVec) - rad * rad;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    return -b - sqrt(h);\n}\n\nvec4 cubicTex(vec2 uv)\n{\n    uv *= iChannelResolution[2].xy;\n    vec2 fr = fract(uv);\n    vec2 smoothv = fr*fr*(3.0-2.0*fr);\n    vec2 fl = floor(uv);\n    uv = smoothv + fl;\n    return textureLod(iChannel2, (uv + 0.5)\/iChannelResolution[2].xy, 0.0);\t\/\/ use constant here instead?\n}\n\nvec4 tex3d(vec3 pos, vec3 normal)\n{\n\t\/\/ loook up texture, blended across xyz axis based on normal.\n\tvec4 texX = texture(iChannel2, pos.yz);\n\tvec4 texY = texture(iChannel2, pos.xz);\n\tvec4 texZ = texture(iChannel2, pos.xy);\n\t\/\/vec4 texX = cubicTex(pos.yz);\n\t\/\/vec4 texY = cubicTex(pos.xz);\n\t\/\/vec4 texZ = cubicTex(pos.xy);\n\tvec4 tex = mix(texX, texZ, abs(normal.z));\n\ttex = mix(tex, texY, abs(normal.y));\/\/.zxyw;\n\treturn tex;\n}\n\nvec4 tex3d3(vec3 pos, vec3 normal)\n{\n\t\/\/ loook up texture, blended across xyz axis based on normal.\n\tvec4 texX = texture(iChannel3, pos.yz);\n\tvec4 texY = texture(iChannel3, pos.xz);\n\tvec4 texZ = texture(iChannel3, pos.xy);\n\tvec4 tex = mix(texX, texZ, abs(normal.z));\n\ttex = mix(tex, texY, abs(normal.y));\/\/.zxyw;\n\treturn tex;\n}\n\nfloat GrayPanel(vec2 uv)\n{\n    float grayPanels = texture(iChannel1, uv.xy * 0.25).z;\n    float grayPanels2 = texture(iChannel1, uv.xy * 0.333 + vec2(0.1, 0.3)).z;\n    grayPanels += grayPanels2;\n    float grayPanels3 = texture(iChannel1, uv.xy * 0.1777*vec2(1.0,5.0) + vec2(0.432, 0.765)).z;\n    grayPanels += grayPanels3;\n    return grayPanels;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    localTime = iTime - 0.0;\n\t\/\/ ---------------- First, set up the camera rays for ray marching ----------------\n\tvec2 uv = fragCoord.xy\/iResolution.xy * 2.0 - 1.0;\n    float zoom = 2.0;\n    uv \/= zoom;\n\n\t\/\/ Camera up vector.\n\tvec3 camUp=vec3(0,1,0); \/\/ vuv\n\n\t\/\/ Camera lookat.\n\tcamLookat=vec3(0,0.0,0);\t\/\/ vrp\n\n    \/\/ debugging camera\n    float mx=iMouse.x\/iResolution.x*PI*2.0-0.7 + localTime*3.1415 * 0.0625;\n\tfloat my=0.0;\/\/-iMouse.y\/iResolution.y*10.0 - sin(localTime * 0.31)*0.5;\/\/*PI\/2.01;\n\tcamPos += vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(12.2); \t\/\/ prp\n\n\n    \/\/ add randomness to camera for depth-of-field look close up.\n    \/\/camPos += vec3(Hash2d(uv)*0.91, Hash2d(uv+37.0), Hash2d(uv+47.0))*0.01;\n\n\t\/\/ Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);\/\/vpn\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\t\/\/ u\n\tvec3 upNorm=cross(camVec, sideNorm);\/\/v\n\tvec3 worldFacing=(camPos + camVec);\/\/vcv\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x\/iResolution.y) + uv.y * upNorm;\/\/scrCoord\n\tvec3 relVec = normalize(worldPix - camPos);\/\/scp\n\n\t\/\/ ----------------------------------- Animate ------------------------------------\n    float repTime = 32.0;\t\/\/ repeat every x seconds\n    float t1 = mod(localTime-5.0, repTime) \/ repTime;\n    shipPosition = 9.5 - min(pow(t1, 0.7), 0.5) * 16.0;\n\t\/\/ --------------------------------------------------------------------------------\n\t\/\/ I put a bounding sphere around the whole object. If the ray is outside\n\t\/\/ of the bounding sphere, I don't bother ray marching. It's just an optimization.\n\t\/\/vec3 iA, iB;\n\t\/\/float hit = IntersectSphereAndRay(vec3(0,0,0), 7.6, camPos, camPos+relVec, iA, iB);\n\n\t\/\/ --------------------------------------------------------------------------------\n\tvec2 distAndMat = vec2(0.05, 0.0);\n\tfloat t = 7.0;\n\t\/\/float inc = 0.02;\n\tfloat maxDepth = 22.0;\n\tvec3 pos = vec3(0,0,0);\n    \/\/ start and end the camera ray at the sphere intersections.\n    \/\/camPos = 0.5;\/\/iA;\n    \/\/maxDepth = distance(iA, iB);\n\t\/\/ ray marching time\n\t\/\/if (hit > 0.5)\t\/\/ check if inside bounding sphere before wasting time ray marching.\n\t{\n        for (int i = 0; i < MAX_MARCH_REPS; i++)\t\/\/ This is the count of the max times the ray actually marches.\n        {\n            if ((t > maxDepth) || (abs(distAndMat.x) < 0.0075)) break;\n            pos = camPos + relVec * t;\n            \/\/ *******************************************************\n            \/\/ This is _the_ function that defines the \"distance field\".\n            \/\/ It's really what makes the scene geometry.\n            \/\/ *******************************************************\n            distAndMat = DistanceToObject(pos);\n            \/\/ adjust by constant because deformations mess up distance function.\n            t += distAndMat.x * MARCH_DISTANCE_MULTIPLIER;\n        }\n    }\n    \/*else\n    {\n\t\tt = maxDepth + 1.0;\n        distAndMat.x = 1.0;\n    }*\/\n\t\/\/ --------------------------------------------------------------------------------\n\t\/\/ Now that we have done our ray marching, let's put some color on this geometry.\n\n\tvec3 sunDir = normalize(vec3(0.93, 0.82, -1.5));\n\tvec3 finalColor = vec3(0.0);\n    float radial = length(pos.xy);\n\n\t\/\/ If a ray actually hit the object, let's light it.\n\tif (abs(distAndMat.x) < 0.75)\n    \/\/if (t <= maxDepth)\n\t{\n        vec3 posRot = RotateZ(pos, iTime * rotationSpeed);\n\n\t\tfloat grayPanels = GrayPanel(posRot.xy);\n\n        \/\/ calculate the normal from the distance field. The distance field is a volume, so if you\n        \/\/ sample the current point and neighboring points, you can use the difference to get\n        \/\/ the normal.\n        vec3 smallVec = vec3(0.005, 0, 0);\n        vec3 normalU = vec3(distAndMat.x - DistanceToObject(pos - smallVec.xyy).x,\n                           distAndMat.x - DistanceToObject(pos - smallVec.yxy).x,\n                           distAndMat.x - DistanceToObject(pos - smallVec.yyx).x);\n\n        vec3 normal = normalize(normalU);\n        \n        \/\/ bump map inner stuff\n        if (radial < outerRadius - 0.01)\n        {\n            normal += (texture(iChannel1, posRot.xy * 0.27).x - 0.4) * 0.0625;\n            normal.y += (grayPanels - 1.5) * 0.1;\n            normal = normalize(normal);\n        }\n        else\n        {\n            float ridge = sin(radial*16.0+0.3);\n            ridge = pow(abs(ridge), 16.0);\n            normal += ridge*normal.z;\n            normal = normalize(normal);\n        }\n\n\n        \/\/ calculate 2 ambient occlusion values. One for global stuff and one\n        \/\/ for local stuff - so the green sphere light source can also have ambient.\n        float ambientS = 1.0;\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.1).x*10.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2).x*5.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4).x*2.5);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.8).x*1.25);\n        float ambient = ambientS * saturate(DistanceToObject(pos + normal * 1.6).x*1.25*0.5);\n        ambient *= saturate(DistanceToObject(pos + normal * 3.2).x*1.25*0.25);\n        \/\/ambient *= saturate(DistanceToObject(pos + normal * 6.4).x*1.25*0.125);\n        ambient = max(0.15, pow(ambient, 0.3));\t\/\/ tone down ambient with a pow and min clamp it.\n        ambient = saturate(ambient);\n\n        \/\/ Trace a ray toward the sun for sun shadows\n        float sunShadow = 1.0;\n        float iter = 0.1;\n\t\tfor (int i = 0; i < MAX_SHADOW_MARCHES; i++)\n        {\n            float tempDist = DistanceToObject(pos + sunDir * iter).x;\n\t        sunShadow *= saturate(tempDist*50.0);\n            if (tempDist <= 0.0) break;\n            \/\/iter *= 1.5;\t\/\/ constant is more reliable than distance-based\n            iter += max(0.00, tempDist)*1.0;\n            if (iter > 8.0) break;\n        }\n        sunShadow = saturate(sunShadow);\n\n        \/\/ calculate the reflection vector for highlights\n        vec3 ref = reflect(relVec, normal);\n\n        \/\/ ------ Calculate texture color ------\n        vec3 texColor;\n        texColor = vec3(0.35);\/\/ * grayPanels;\n\n        \/\/ texture outer ring\n        if (radial >= outerRadius - 0.01)\n        {\n            vec2 uvr = vec2(atan(posRot.x, posRot.y) * 8.0, length(posRot.xy) * 2.0);\n\t        if ((radial >= outerRadius  + 0.3) && (radial < outerRadius + 0.5))\n            {\n                float checker = texture(iChannel1, uvr).x;\n                float checkerL = texture(iChannel0, uvr*0.0625).x;\n                checker = pow(checker, 19.0);\n                checker *= saturate((checkerL - 0.7) * 94.0);\n                \/\/texColor += vec3(15.0, 4.0, 2.0) * 5.0 * saturate(checker);\n                \/\/texColor *= vec3(1.0) * saturate(checker);\n            }\n            float stripes = texture(iChannel1, uvr * vec2(0.0625, 1.0)).x;\n            texColor -= stripes * 0.03;\n        }\n        else\n        {\n            texColor = vec3(0.3) + grayPanels * 0.03;\n        }\n        if (length(normal.xy) > 0.95)\n        {\n            vec2 uvr = vec2(atan(posRot.x, posRot.y) * 1.0, posRot.z * 0.25);\n            \/\/float checker = texture(iChannel1, uvr).x;\n            float checker = GrayPanel(uvr * vec2(1.0, 4.0));\n            texColor += vec3(0.05) * checker - vec3(0.025);\n        }\n\n        \/\/ ------ Calculate lighting color ------\n        \/\/ Start with sun color, standard lighting equation, and shadow\n        vec3 lightColor = sunCol * saturate(dot(sunDir, normal)) * sunShadow*24.0;\n        \/\/ sky color, hemisphere light equation approximation, anbient occlusion\n        lightColor += vec3(0.1,0.35,0.95) * (dot(normal, normalize(earthPos)) * 0.5 + 0.5) * ambient * 0.4;\n        \/\/ ground color - another hemisphere light\n        lightColor += vec3(1.0) * ((-normal.y) * 0.5 + 0.5) * ambient * 0.01;\n        \/\/ Apply red glow to hangar\n        vec3 lightPos = vec3(0.0, 0.0, 1.75);\n        vec3 redGlow = vec3(1.0, 0.1, 0.2) * saturate(0.8 - length(pos - lightPos));\n        redGlow *= max(0.0, dot(normalize(-lightPos-pos), normal));\n        lightColor += redGlow * 43.0;\n        \/\/ Apply red glow to hangar (again. too tired to do mirror math.)\n        lightPos = vec3(0.0, 0.0, -1.75);\n        redGlow = vec3(1.0, 0.1, 0.2) * saturate(0.8 - length(pos - lightPos));\n        redGlow *= max(0.0, dot(normalize(-lightPos-pos), normal));\n        lightColor += redGlow * 43.0;\n\n\n        \/\/ finally, apply the light to the texture.\n        finalColor = texColor * lightColor;\n\n        \/\/ glowing windows\n        if (radial >= outerRadius - 0.01)\n        {\n            vec2 uvr = vec2(atan(posRot.x, posRot.y) * 8.0, length(posRot.xy) * 2.0);\n\t        if ((radial >= outerRadius  + 0.3) && (radial < outerRadius + 0.5))\n            {\n                float checker = texture(iChannel1, uvr).x;\n                float checkerL = texture(iChannel0, uvr*0.0625).x;\n                checker = pow(checker, 19.0);\n                checker *= saturate((checkerL - 0.7) * 94.0);\n                finalColor += vec3(10.0, 6.0, 2.0) * 1.0 * saturate(checker);\n                \/\/texColor *= vec3(1.0) * saturate(checker);\n            }\n        }\n\n        \/\/ specular highlights - just a little\n        vec3 refColor = GetSunColorReflection(ref, sunDir)*0.68;\n        finalColor += refColor * sunCol * sunShadow * 9.0 * texColor.g;\n\n        \/\/ fog that fades to sun color so that fog is brightest towards sun\n    \/\/    finalColor = mix(vec3(0.98, 0.981, 0.981) + min(vec3(0.25),GetSunColorSmall(relVec, sunDir))*2.0, finalColor, exp(-t*0.007));\n        \/\/finalColor = vec3(1.0, 21.0, 26.0) * saturate(length(normalU)-0.01);\n        \/\/finalColor = vec3(40.0) * length(normalU);\n           \/\/ finalColor = normal * 0.5 + 0.5;\n\t}\n    else\n    {\n        \/\/vec3 iA, iB;\n        \/\/float hit = IntersectSphereAndRay(earthPos, earthRad, camPos, camPos+relVec, iA, iB);\n        float hit = SphereIntersect(camPos, normalize(relVec), earthPos, earthRad);\n        if (hit >= 0.0)\n        {\n\t\t\tvec3 intersection = camPos + relVec * hit;\n            vec3 normal = normalize(intersection - earthPos);\n            finalColor = texture(iChannel2, vec2(normal.z, normal.y)).xyz;\n            vec3 surface = vec3(0.01, 0.01, 0.1);\n            surface += tex3d(normal * 0.75, normal).yyy;\n            float d = dot(normal, normalize(camPos - intersection));\n\n            float atmosphere = 1.0 - d;\n            atmosphere = pow(atmosphere, 3.5);\n            atmosphere = atmosphere * 0.9 + 0.1;\n            surface = mix(surface, vec3(70.0, 130.0, 240.0)\/355.0, atmosphere);\n\t\t\tfinalColor = surface;\n            \/\/finalColor = vec3(1.0) * d;\n            \/\/finalColor = normal * 0.5 + 0.5;\n        }\n        else\n        {\n\t\t\t\/\/finalColor += GetStarColor(relVec, sunDir);\n            float stars = tex3d3(relVec*1.0, relVec).z;\n            stars = pow(stars,63.0);\/\/63\n            finalColor += vec3(2.0) * stars;\n        }\n        \/\/ Our ray trace hit nothing, so draw sky.\n        \/\/ fade the sky color, multiply sunset dimming\n        \/\/finalColor *=0.0;\/\/ mix(vec3(1.0, 0.95, 0.85), vec3(0.2,0.5,0.95), pow(saturate(relVec.y), 0.7))*0.95;\n        \/\/ add the sun\n    }\n    finalColor += GetSunColorReflection(relVec, sunDir);\/\/ + vec3(0.1, 0.1, 0.1);\n\n    \/\/ vignette?\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv\/2.5));\n    finalColor *= 1.95;\n\n\t\/\/ output the final color with sqrt for \"gamma correction\"\n\tfragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n\n\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"Xsf3RB","date":"1372886069","viewed":9302,"name":"Submerged","username":"fizzer","description":"Experimenting with clipped cones. Unfortunately I have not yet got this to work correctly on Firefox on Windows. Chrome should be okay.","likes":73,"published":1,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"\/media\/a\/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"\/media\/ap\/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MODEL_JELLYFISH  0\n#define MODEL_FISH       1\n#define MODEL_GROUND     2\n\nvec2 t;\nfloat time;\nfloat anim_offset = 0.0;\nint model = 0;\nmat3 rot, trot, rx;\nfloat znear;\nvec3 glow;\nvec2 p;\nfloat tm2;\nvec2 ltc;\nint material;\n\nmat3 rotateYmat(float ang)\n{\n\treturn mat3(cos(ang), 0.0, sin(ang),\n\t\t\t\t0.0, 1.0, 0.0,\n\t\t\t\t-sin(ang), 0.0, cos(ang));\n}\n\nmat3 rotateXmat(float ang)\n{\n\treturn mat3(0.0, 0.0, 1.0,\n\t\t\t\tcos(ang), sin(ang), 0.0,\n\t\t\t\t-sin(ang), cos(ang), 0.0);\n}\n\nfloat traceSphere(vec3 ro, vec3 rd, float radsq)\n{\n\tfloat a = dot(rd, rd);\n\tfloat b = dot(ro, rd);\n\tfloat c = dot(ro, ro) - radsq;\n\tfloat d = (b * b - a * c) * 4.0;\n\n\treturn mix(1e4, (-b + sqrt(d)) \/ (2.0 * a), step(0.0, d));\n}\n\n\nvec3 tex(vec2 p)\n{\n\tfloat su = 0.5 + 0.5 * cos(p.x * 4.0);\n\tvec3 c = mix(vec3(0.5, 0.1, 0.1) * 0.3, vec3(1.0, 0.9, 0.5), 1.0 - p.y + cos(time * 8.0) * 0.02);\n\tvec3 c2 = c * mix(vec3(1.0, 0.9, 0.5), vec3(0.7, 0.5, 0.1), su);\n\treturn mix(c2, c, sqrt(1.0 - p.y)) + pow(su * (0.5 + 0.5 * cos(p.y * 40.0)) * 1.02, 64.0) * vec3(0.1);\n}\n\nfloat radius(float x)\n{\n\tif(model == MODEL_JELLYFISH)\n\t{\n\t\tfloat t = time + anim_offset;\n\t\treturn (x * 0.3 + (0.5 + 0.5 * cos(x * 4.0 + t * 10.0)) * 0.04);\n\t}\n\t\n\tif(model == MODEL_GROUND)\n\t{\n\t\treturn x * 0.5;\n\t}\n\t\n\treturn mix(x * 0.03, 1.0, 0.5 + 0.5 * sin(x * 0.8 - 0.6)) * 0.6;\n}\n\nfloat zpos(float x)\n{\n\tif(model == MODEL_JELLYFISH)\n\t{\n\t\tfloat t = time + anim_offset;\n\t\treturn cos(x * 0.5 + t) * 2.0 * (1.0 + iMouse.x \/ iResolution.x * 2.0);\n\t}\n\t\n\tif(model == MODEL_GROUND)\n\t{\n\t\treturn cos(x \/ 8.0 * 3.14159 * 2.0 + 0.1);\n\t}\n\t\n\treturn x * 0.4 + cos(x + time * 4.0) * 0.1;\n}\n\nvoid swap(inout float a, inout float b)\n{\n\tfloat c = a;\n\ta = b;\n\tb = c;\n}\n\nvoid tubePiece(int j, vec3 ro, vec3 rd, inout vec2 tc, inout float tm)\n{\n    float s0 = radius(float(j)), s1 = radius(float(j + 1));\n    float z0 = zpos(float(j)), z1 = zpos(float(j + 1));\n    \n    float zz0 = -z1;\n    float f = z1 - z0;\n    \n    if(z0 < z1)\n    {\n        swap(s0, s1);\n        swap(z0, z1);\n    }\n    \n    float i = 0.0;\n    vec3 oro = ro, ord = rd;\n    \n\n\tfloat zd = z0 - z1;\n\t\n\tfloat u = (s1 - s0) \/ zd;\n\t\n\tfloat zofs = s0 \/ u;\n\tfloat rus = 1.0 \/ (u * u);\n\t\n\tro.z += zofs + z0;\n\t\n\tfloat a = dot(rd.xy, rd.xy) * rus - rd.z * rd.z;\n\tfloat b = dot(ro.xy, rd.xy) * rus - rd.z * ro.z;\n\tfloat c = dot(ro.xy, ro.xy) * rus - ro.z * ro.z;\n\tfloat d = b * b - a * c;\n\t\n\tif(d < 0.0)\n\t\treturn;\n\t\n\td = sqrt(d);\n\t\n\tfloat cone_min = (-b - d) \/ a;\n\tfloat cone_max = (-b + d) \/ a;\n\t\n\tfloat rp0 = ro.z + rd.z * cone_min - zofs;\n\tfloat rp1 = ro.z + rd.z * cone_max - zofs;\n\t\n\t\n\tif(rp0 > 0.0 && rp0 < zd && cone_min > 0.0)\n\t\ti = cone_min;\n\telse if(rp1 > 0.0 && rp1 < zd && cone_max > 0.0)\n\t\ti = cone_max;\n\telse\n\t\treturn;\n\n        \n    ro = oro;\n    rd = ord;\n    \n\tvec3 rp = ro + rd * i;\n\tfloat t = (rp.z - zz0) \/ f;\n\t\n\tvec2 ltc = vec2(atan(rp.y, rp.x) * 3.0, mix(float(j + 1), float(j), t));\n\tfloat hit = step(i, tm);\n\t\n\ttc = mix(tc, ltc, hit);\n\ttm = mix(tm, i, hit);\n}\n\n\nfloat tube(vec3 ro, vec3 rd, inout vec2 tc)\n{\n\tfloat tm = 1e2;\n\t\n    tubePiece(0, ro, rd, tc, tm);\n    tubePiece(1, ro, rd, tc, tm);\n    tubePiece(2, ro, rd, tc, tm);\n    tubePiece(3, ro, rd, tc, tm);\n    tubePiece(4, ro, rd, tc, tm);\n    tubePiece(5, ro, rd, tc, tm);\n    tubePiece(6, ro, rd, tc, tm);\n    tubePiece(7, ro, rd, tc, tm);\n\t\n\ttc.y \/= float(8);\n\t\n\treturn tm;\n}\n\nvec3 backgtex(vec3 p)\n{\n\tfloat f = clamp(smoothstep(8.0, 30.0, p.y), 0.0, 1.0);\n\tvec3 n = pow(smoothstep(10.0, 42.0, p.y), 100.0) * vec3(1.0, 0.9, 0.5);\n\treturn (mix(vec3(0.1, 0.2, 0.2), vec3(0.0, 0.1, 0.1), 0.5 + 0.5 * cos(p.y * 0.4 + time * 10.0)) * 0.4 * f + n) * 0.5\n\t\t+ vec3(0.05, 0.06, 0.1) * smoothstep(-40.0, 1.0, p.y);\n}\n\nfloat noise( vec2 x )\n{\n\treturn texture(iChannel0, x \/ 64.0).r;\n}\n\/*\nmat3 transpose(mat3 m)\n{\n\treturn mat3(m[0].x, m[1].x, m[2].x,\n\t\t\t\tm[0].y, m[1].y, m[2].y,\n\t\t\t\tm[0].z, m[1].z, m[2].z);\n}\n*\/\n\nvoid traceFish(int i, inout vec2 tc, inout float tm, vec3 ro, vec3 rd)\n{\n\tmat3 r = rotateXmat(time + float(i) * 0.4 + cos(time + float(i))), trans_r = transpose(r);\n\t\n\tvec3 tr = rotateYmat(float(i)) * rotateXmat(float(i)) * vec3(0.0, float(i), float(i)) * 4.0 +\n\t\tr * vec3(0.0, 8.0, 0.0);\n\t\n\tvec3 vtr = trot * (tr - ro);\n\t\n\tif(vtr.z < -1e-3)\n\t{\n\t\tvec2 ptr = vtr.xy \/ vtr.z * znear;\n\t\tglow += vec3(0.3, 0.7, 1.0).bgr * pow(max(0.0, 1.0 - distance(ptr, p) * 1.0) * 5.0, 2.0) * 0.4;\n\t}\n\t\n\tanim_offset = float(i) * 1.7;\n\t\n\tvec3 s = vec3(1.0, 2.0, 1.0);\n\t\n\ttm2 = tube((trans_r * (ro - tr)) * s, (trans_r * rd) * s, ltc);\n\t\n\ttc = mix(tc, ltc, step(tm2, tm));\n\ttm = min(tm, tm2);\n}\n\nvoid traceJellyFish(int i, inout vec2 tc, inout float tm, vec3 ro, vec3 rd)\n{\n\tmat3 r = rotateYmat(float(i) * 2.0) * rx, trans_r = transpose(r);\n\tvec3 tr = rotateYmat(float(i)) * vec3(float(i) * 1.0, sin(float(i) * 5.0) * 10.0, 4.0) *\n\t\t(1.0 + iMouse.y \/ iResolution.y * 2.0);\n\t\n\tvec3 vtr = trot * (tr - ro);\n\t\n\tif(vtr.z < -1e-3)\n\t{\n\t\tvec2 ptr = vtr.xy \/ vtr.z * znear;\n\t\tglow += vec3(0.3, 0.7, 1.0) * pow(max(0.0, 1.0 - distance(ptr, p) * 2.0) * 7.0, 2.0) *\n\t\t\tmix(0.7, 1.2, 0.5 + 0.5 * cos(float(i) + time * 4.0));\n\t}\n\t\n\tanim_offset = float(i) * 1.7;\n\t\n\ttm2 = tube(trans_r * (ro - tr), trans_r * rd, ltc);\n\t\n\tif(tm2 < tm)\n\t\tmaterial = MODEL_JELLYFISH;\n\t\n\ttc = mix(tc, ltc, step(tm2, tm));\n\ttm = min(tm, tm2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n\tt = uv * 2.0 - vec2(1.0);\n\tt.x *= iResolution.x \/ iResolution.y;\n\t\n\ttime = iTime;\n\t\n\tmaterial = MODEL_FISH;\n\tznear = -0.8;\n\trot = rotateXmat(3.1415926 * 0.5 + cos(time * 0.1) + sin(time * 5.0) * 0.002) * rotateYmat(time * 0.2);\n\ttrot = transpose(rot);\n\t\n\tp = t.xy;\n\t\n\tvec3 ro = rot * vec3(cos(time), sin(time * 0.3), 10.0);\n\tvec3 rd = rot * vec3(p, znear);\n\tfloat tm = 2e2;\n\t\n\tvec2 tc = vec2(0.0);\n\t\n\tglow = vec3(0.0);\n\t\n\tmodel = MODEL_FISH;\n\tfor(int i = 0; i < 8; i += 1)\n\t\ttraceFish(i, tc, tm, ro, rd);\n\n\n\n    \n    model = MODEL_JELLYFISH;\n\trx = rotateXmat(3.1415926);\n\t\n\tfor(int i = 0; i < 10; i += 1)\n\t\ttraceJellyFish(i, tc, tm, ro, rd);\n\n\t\n\n    \n\t\/\/ ground\n\t\n\tmodel = MODEL_GROUND;\n\tmat3 r = rotateXmat(-3.1415926), trans_r = transpose(r);\n\tvec3 tr = vec3(0.0, -24.0, 0.0);\n\t\n\tvec3 vtr = trot * (tr - ro);\n\t\n\tanim_offset = 1.7;\n\t\n\tvec3 s = vec3(0.2, 0.2, 0.2);\n\t\n\ttm2 = tube(trans_r * (ro - tr) * s, trans_r * rd * s, ltc);\n\t\n\tif(tm2 < tm)\n\t\tmaterial = MODEL_GROUND;\n\t\n\ttc = mix(tc, ltc, step(tm2, tm));\n\ttm = min(tm, tm2);\n    \n    \n\t\n\t\n\tvec3 rp = ro + rd * tm;\n\t\n\t\n\ttm2 = traceSphere(ro, rd, 40.0 * 40.0);\n\tvec3 backgcol = backgtex(ro + rd * tm2);\n\t\n\tvec3 c;\n\t\n\tif(material == MODEL_FISH)\n\t\tc = tex(tc);\n\t\n\tif(material == MODEL_JELLYFISH)\n\t\tc = tex(tc).bgr;\n\t\n\tif(material == MODEL_GROUND)\n\t\tc = mix(0.3 * mix(vec3(0.5, 0.3, 0.3), vec3(1.0, 1.0, 0.4), mix(0.3, 0.5, noise(rp.xz * 8.0))),\n\t\t\t\tbackgcol, pow(smoothstep(0.0, 1.0, tc.y * 1.0), 2.0)) * smoothstep(-10.0, 1.0, rp.y - -25.0);\n\t\n\tfloat v = pow(1.0 - smoothstep(0.0, 2.0, length(p)), 0.5);\n\t\n\tvec3 col = (mix(vec3(0.0), c, step(tm, 0.9e2))) * 1.1;\n\t\n\tfloat bs = clamp(1.0 - length(backgcol) * 4.0, 0.0, 1.0) * v * 3.5;\n\t\n\tfragColor.rgb = (mix(backgcol, col, step(tm, tm2)) + glow * 0.01) * v;\n\tfragColor.rgb += noise(fragCoord.xy) * 0.01;\n\t\n\tfragColor.rgb += smoothstep(0.9, 0.91,\n\t\t\t\t\t\t\t\t   noise(t.xy * 40.0 + vec2(cos(time + t.y * 5.0) * 4.0, time * 10.0 + cos(time) * 5.0 + sin(time + t.x * 3.0) * 4.0) )) * 0.01 *\n\t\tsmoothstep(0.0, 20.0, tm) * bs;\n\t\n\tfragColor.rgb += smoothstep(0.9, 0.91,\n\t\t\t\t\t\t\t\t   noise(t.xy * 80.0 + vec2(cos(time + t.y * 10.0) * 4.0, time * 10.0 + cos(time + 0.1) * 5.0 + sin(time * 0.5 + t.x * 8.0) * 4.0) )) * 0.01 *\n\t\tsmoothstep(0.0, 15.0, tm) * 2.0 * bs;\n\n\tfragColor.rgb = pow(fragColor.rgb, vec3(0.8));\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"ldfGWs","date":"1381667687","viewed":9302,"name":"Area lights","username":"ben","description":"my first shader. yay!  I have no idea what I'm doing. yaaay!\n\narea lights with glossy reflections and approximate energy conservation from Brian Karis's Siggraph talk. I'm not sure I've done the tube correctly. or the sphere. or anything else.","likes":120,"published":1,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"\/media\/a\/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"\/media\/ap\/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\/\/\tCreative Commons CC0 1.0 Universal (CC-0)\n\/\/\t\n\/\/\tarea lights based on Brian Karis's Siggraph 2013 presentation\n\/\/\thttp:\/\/blog.selfshadow.com\/publications\/s2013-shading-course\/\n\/\/\t\n\/\/\tkind of pointless for a ray marched scene, but they work with rasterized stuff too.\n\/\/\tI still need to do attenuation and some noodling. comments too, though everything's\n\/\/\tin the course notes at the site above for anyone interested.\n\/\/\t\n\/\/\traymarching code and anything else that looks well written courtesy of iq.\n\/\/\t\n\/\/\t~bj.2013\n\n\/\/#define DISABLE_ALBEDO\n\/\/#define DISABLE_NORMALS\n\/\/#define DISABLE_ROUGHNESS\n\nfloat sphereRad;\nvec3 spherePos;\nfloat tubeRad;\nvec3 tubeStart;\nvec3 tubeEnd;\n\nfloat specTrowbridgeReitz( float HoN, float a, float aP )\n{\n\tfloat a2 = a * a;\n\tfloat aP2 = aP * aP;\n\treturn ( a2 * aP2 ) \/ pow( HoN * HoN * ( a2 - 1.0 ) + 1.0, 2.0 );\n}\n\nfloat visSchlickSmithMod( float NoL, float NoV, float r )\n{\n\tfloat k = pow( r * 0.5 + 0.5, 2.0 ) * 0.5;\n\tfloat l = NoL * ( 1.0 - k ) + k;\n\tfloat v = NoV * ( 1.0 - k ) + k;\n\treturn 1.0 \/ ( 4.0 * l * v );\n}\n\nfloat fresSchlickSmith( float HoV, float f0 )\n{\n\treturn f0 + ( 1.0 - f0 ) * pow( 1.0 - HoV, 5.0 );\n}\n\nfloat sphereLight( vec3 pos, vec3 N, vec3 V, vec3 r, float f0, float roughness, float NoV, out float NoL )\n{\n\tvec3 L\t\t\t\t= spherePos - pos;\n\tvec3 centerToRay\t= dot( L, r ) * r - L;\n\tvec3 closestPoint\t= L + centerToRay * clamp( sphereRad \/ length( centerToRay ), 0.0, 1.0 );\t\n\tvec3 l\t\t\t\t= normalize( closestPoint );\n\tvec3 h\t\t\t\t= normalize( V + l );\n\t\n\tNoL\t\t\t\t= clamp( dot( N, l ), 0.0, 1.0 );\n\tfloat HoN\t\t= clamp( dot( h, N ), 0.0, 1.0 );\n\tfloat HoV\t\t= dot( h, V );\n\t\n\tfloat distL\t\t= length( L );\n\tfloat alpha\t\t= roughness * roughness;\n\tfloat alphaPrime\t= clamp( sphereRad \/ ( distL * 2.0 ) + alpha, 0.0, 1.0 );\n\t\n\tfloat specD\t\t= specTrowbridgeReitz( HoN, alpha, alphaPrime );\n\tfloat specF\t\t= fresSchlickSmith( HoV, f0 );\n\tfloat specV\t\t= visSchlickSmithMod( NoL, NoV, roughness );\n\t\n\treturn specD * specF * specV * NoL;\n}\n\nfloat tubeLight( vec3 pos, vec3 N, vec3 V, vec3 r, float f0, float roughness, float NoV, out float NoL )\n{\n\tvec3 L0\t\t\t= tubeStart - pos;\n\tvec3 L1\t\t\t= tubeEnd - pos;\n\tfloat distL0\t= length( L0 );\n\tfloat distL1\t= length( L1 );\n\t\n\tfloat NoL0\t\t= dot( L0, N ) \/ ( 2.0 * distL0 );\n\tfloat NoL1\t\t= dot( L1, N ) \/ ( 2.0 * distL1 );\n\tNoL\t\t\t\t= ( 2.0 * clamp( NoL0 + NoL1, 0.0, 1.0 ) ) \n\t\t\t\t\t\/ ( distL0 * distL1 + dot( L0, L1 ) + 2.0 );\n\t\n\tvec3 Ld\t\t\t= L1 - L0;\n\tfloat RoL0\t\t= dot( r, L0 );\n\tfloat RoLd\t\t= dot( r, Ld );\n\tfloat L0oLd \t= dot( L0, Ld );\n\tfloat distLd\t= length( Ld );\n\tfloat t\t\t\t= ( RoL0 * RoLd - L0oLd ) \n\t\t\t\t\t\/ ( distLd * distLd - RoLd * RoLd );\n\t\n\tvec3 closestPoint\t= L0 + Ld * clamp( t, 0.0, 1.0 );\n\tvec3 centerToRay\t= dot( closestPoint, r ) * r - closestPoint;\n\tclosestPoint\t\t= closestPoint + centerToRay * clamp( tubeRad \/ length( centerToRay ), 0.0, 1.0 );\n\tvec3 l\t\t\t\t= normalize( closestPoint );\n\tvec3 h\t\t\t\t= normalize( V + l );\n\t\n\tfloat HoN\t\t= clamp( dot( h, N ), 0.0, 1.0 );\n\tfloat HoV\t\t= dot( h, V );\n\t\n\tfloat distLight\t= length( closestPoint );\n\tfloat alpha\t\t= roughness * roughness;\n\tfloat alphaPrime\t= clamp( tubeRad \/ ( distLight * 2.0 ) + alpha, 0.0, 1.0 );\n\t\n\tfloat specD\t\t= specTrowbridgeReitz( HoN, alpha, alphaPrime );\n\tfloat specF\t\t= fresSchlickSmith( HoV, f0 );\n\tfloat specV\t\t= visSchlickSmithMod( NoL, NoV, roughness );\n\t\n\treturn specD * specF * specV * NoL;\n}\n\nvec3 areaLights( vec3 pos, vec3 nor, vec3 rd )\n{\n\tfloat noise\t\t=  texture( iChannel1, pos.xz ).x * 0.5;\n\tnoise\t\t\t+= texture( iChannel1, pos.xz * 0.5 ).y;\n\tnoise\t\t\t+= texture( iChannel1, pos.xz * 0.25 ).z * 2.0;\n\tnoise\t\t\t+= texture( iChannel1, pos.xz * 0.125 ).w * 4.0;\n\t\n\tvec3 albedo\t\t= pow( texture( iChannel0, pos.xz ).xyz, vec3( 2.2 ) );\n\talbedo\t\t\t= mix( albedo, albedo * 1.3, noise * 0.35 - 1.0 );\n\tfloat roughness = 0.7 - clamp( 0.5 - dot( albedo, albedo ), 0.05, 0.95 );\n\tfloat f0\t\t= 0.3;\n\t\n\t#ifdef DISABLE_ALBEDO\n\talbedo\t\t\t= vec3(0.1);\n\t#endif\n\t\n\t#ifdef DISABLE_ROUGHNESS\n\troughness\t\t= 0.05;\n\t#endif\n\t\n\tvec3 v\t\t\t= -normalize( rd );\n\tfloat NoV\t\t= clamp( dot( nor, v ), 0.0, 1.0 );\n\tvec3 r\t\t\t= reflect( -v, nor );\n\t\n\tfloat NdotLSphere;\n\tfloat specSph\t= sphereLight( pos, nor, v, r, f0, roughness, NoV, NdotLSphere );\n\t\n\tfloat NdotLTube;\n\tfloat specTube\t= tubeLight( pos, nor, v, r, f0, roughness, NoV, NdotLTube );\n\t\n\tvec3 color\t\t= albedo * 0.3183 * ( NdotLSphere + NdotLTube ) + specSph + specTube;\n\treturn pow( color, vec3( 1.0 \/ 2.2 ) );\n}\n\nvec3 rotYaw( vec3 v, float a )\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn v * mat3( c, 0,-s,\t0, 1, 0,\ts, 0, c );\n}\n\nvec3 rotPitch( vec3 v, float a )\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn v * mat3( 1, 0, 0,\t0, c,-s,\t0, s, c );\n}\n\nvoid updateLights()\n{\n\tsphereRad\t\t= cos( iTime * 0.3 ) * 0.025 + 0.05;\n\tspherePos\t\t= vec3( sin( iTime * 0.25 ), abs( cos( iTime ) * 0.25 ) + sphereRad, 0.0 );\n\t\n\ttubeRad\t\t\t= sin( iTime * 0.1 ) * 0.005 + 0.01;\n\tvec3 tubePos\t= vec3( 0.0, sin( iTime * 0.3 ) * 0.1 + 0.2, cos( iTime * 0.25 ) );\t\n\n\tvec3 tubeVec\t= rotPitch(rotYaw(vec3(0,0,0.2), iTime*-1.5 ), cos( iTime*0.5 ) * 0.3 );\n\t\n\ttubeStart\t\t= tubePos + tubeVec;\n\ttubeEnd\t\t\t= tubePos - tubeVec;\n}\n\n\/\/--------------------------------------------------------------------------\n\/\/\teverything below here is based on iq's Raymarching - Primitives shader\t\n\/\/\thttps:\/\/www.shadertoy.com\/view\/Xds3zN\n\/\/\t\n\/\/--------------------------------------------------------------------------\n\n\n\n\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ A list of usefull distance function to simple primitives, and an example on how to \n\/\/ do some interesting boolean operations, repetition and displacement.\n\/\/\n\/\/ More info here: https:\/\/iquilezles.org\/articles\/distfunctions\n\n\nvec2 map( in vec3 pos )\n{\n\tvec2 sphere\t\t= vec2( length( pos - spherePos ) - sphereRad, 2.0 );\n\n\tvec3 pa\t\t\t= pos - tubeStart;\n\tvec3 ba\t\t\t= tubeEnd - tubeStart;\n\tvec2 tube\t\t= vec2( length( pa - ba * clamp( dot(pa,ba) \/ dot(ba,ba), 0.0, 1.0 ) ) - tubeRad, 2.0 );\n\tfloat bump\t\t= 0.0;\n\t\n\t#ifndef DISABLE_NORMALS\n\tbump\t\t\t= texture( iChannel0, pos.xz * 6.0 ).x * 0.002;\n\t#endif\n\t\n\tvec2 res\t\t= vec2( pos.y + bump, 1.0 );\n\tres\t\t\t\t= ( res.x < sphere.x ) ? res : sphere;\n\tres\t\t\t\t= ( res.x < tube.x ) ? res : tube;\n\t\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, in float maxd )\n{\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float t = 0.0;\n    float m = -1.0;\n    for( int i=0; i<60; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) continue;\/\/break;\n        t += h;\n\t    vec2 res = map( ro+rd*t );\n        h = res.x;\n\t    m = res.y;\n    }\n\n    if( t>maxd ) m=-1.0;\n    return vec2( t, m );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.0);\n    vec2 res = castRay(ro,rd,20.0);\n    if( res.y>-0.5 )\n    {\n\t\tif( res.y == 2.0 )\n\t\t\treturn vec3(1);\n\n        vec3 pos = ro + res.x * rd;\n        vec3 nor = calcNormal( pos );\n\n\t\tcol = areaLights( pos, nor, rd );\n\t}\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy\/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x\/iResolution.y;\n\n\tfloat time = 15.0 + iTime*0.1;\n\tvec3 ro = vec3(1.2*cos(time),0.3+0.2*cos(time),1.2*sin(time));\n\tvec3 ta = vec3(0,0,0);\n\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n\t\n\tupdateLights();\n    vec3 col = render( ro, rd );\n\n\tfragColor=vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}];    var gUseScreenshots = piIsMobile();
    var gThemeName = "classic";



    </script>
</head>

<!-- <body onload="resultsInit(12,null,null)"> -->
<body onload="resultsInitStatic(12,null,null)">

<!-- header =================================================================================== -->


<div id="header">

    <div id="headerBlock1">
        <a href="/" id="headerTitle">Shadertoy</a>
        <form name="formSearch" action="/results" method="get" style="display:inline-block;">
        <div  id="headerSearch">
            <input type="search" id="mySearch" name="query" placeholder="Search..." value=""/>
        </div>
        </form>
    </div>

    <div id="headerBlock2">
            <a class="headerLinks" href="/browse">Browse</a>
        <a class="headerLinks" href="/new">New</a>
        <a class="headerLinks" href="/signin">Sign In</a>
        </div>
</div>
<!-- content ================================================================================== -->

<div id="content">

  <div id="controls">
    <div>
      <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
      Sort:      </div>
      <div class="controlOptions"><div class="pageButtonsCurrent" href="/results?query=&sort=popular&filter=">Popular</div><a class="pageButtons" href="/results?query=&sort=newest&filter=">Newest</a><a class="pageButtons" href="/results?query=&sort=love&filter=">Love</a><a class="pageButtons" href="/results?query=&sort=hot&filter=">Hot</a></div>
    </div>

    <div id="controlFilter">
      <div style="display:flex;margin-right:8px;align-items:center;">Filter:</div>
      <div class="controlOptions"> <a class="pageButtons" href="/results?query=&sort=popular&filter=multipass">Multipass</a><a class="pageButtons" href="/results?query=&sort=popular&filter=soundoutput">GPU Sound</a><a class="pageButtons" href="/results?query=&sort=popular&filter=vr">VR</a><a class="pageButtons" href="/results?query=&sort=popular&filter=soundinput">Microphone</a><a class="pageButtons" href="/results?query=&sort=popular&filter=musicstream">Soundcloud</a><a class="pageButtons" href="/results?query=&sort=popular&filter=webcam">Webcam</a></div>
    </div>

    <div>
        <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
        View:</div>
        <div><a class="pageButtons" href="/slideshow?query=&sort=popular">Slideshow</a></div>
    </div>

    <div class="navigation" id="navTop" ><span style="padding-right:8px;">Results (74098):</span><div class="controlOptions"><a id="pageButtonFirst" class="pageButtons" href="results?query=&sort=popular&from=0&num=12">1</a><span>...</span><a id="pageButton"0 class="pageButtons" href="results?query=&sort=popular&from=708&num=12">60</a><a id="pageButton"1 class="pageButtons" href="results?query=&sort=popular&from=720&num=12">61</a><div id="pageButton"2 class="pageButtonsCurrent" href="results?query=&sort=popular&from=732&num=12">62</div><a id="pageButton"3 class="pageButtons" href="results?query=&sort=popular&from=744&num=12">63</a><a id="pageButton"4 class="pageButtons" href="results?query=&sort=popular&from=756&num=12">64</a><span>...</span><a id="pageButtonLast" class="pageButtons" href="results?query=&sort=popular&from=74088&num=12">6175</a></div>
</div>
  </div>


  <div id="shaderGrid">
    <div class='searchResult'><div class='searchResultContainer' id='Preview_0_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_0_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_0_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_0_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_0_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_0_Thumnail'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_0_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_0_Info'>  <span class='previewText'  id='Preview_0_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_0_TextUser'></span>  <span class='previewStats' id='Preview_0_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_1_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_1_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_1_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_1_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_1_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_1_Thumnail'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_1_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_1_Info'>  <span class='previewText'  id='Preview_1_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_1_TextUser'></span>  <span class='previewStats' id='Preview_1_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_2_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_2_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_2_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_2_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_2_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_2_Thumnail'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_2_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_2_Info'>  <span class='previewText'  id='Preview_2_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_2_TextUser'></span>  <span class='previewStats' id='Preview_2_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_3_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_3_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_3_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_3_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_3_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_3_Thumnail'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_3_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_3_Info'>  <span class='previewText'  id='Preview_3_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_3_TextUser'></span>  <span class='previewStats' id='Preview_3_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_4_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_4_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_4_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_4_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_4_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_4_Thumnail'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_4_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_4_Info'>  <span class='previewText'  id='Preview_4_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_4_TextUser'></span>  <span class='previewStats' id='Preview_4_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_5_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_5_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_5_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_5_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_5_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_5_Thumnail'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_5_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_5_Info'>  <span class='previewText'  id='Preview_5_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_5_TextUser'></span>  <span class='previewStats' id='Preview_5_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_6_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_6_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_6_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_6_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_6_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_6_Thumnail'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_6_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_6_Info'>  <span class='previewText'  id='Preview_6_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_6_TextUser'></span>  <span class='previewStats' id='Preview_6_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_7_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_7_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_7_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_7_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_7_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_7_Thumnail'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_7_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_7_Info'>  <span class='previewText'  id='Preview_7_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_7_TextUser'></span>  <span class='previewStats' id='Preview_7_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_8_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_8_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_8_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_8_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_8_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_8_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_8_Thumnail'>        <img class='previewThumbnailImage' id='Preview_8_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_8_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_8_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_8_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_8_Info'>  <span class='previewText'  id='Preview_8_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_8_TextUser'></span>  <span class='previewStats' id='Preview_8_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_9_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_9_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_9_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_9_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_9_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_9_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_9_Thumnail'>        <img class='previewThumbnailImage' id='Preview_9_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_9_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_9_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_9_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_9_Info'>  <span class='previewText'  id='Preview_9_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_9_TextUser'></span>  <span class='previewStats' id='Preview_9_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_10_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_10_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_10_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_10_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_10_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_10_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_10_Thumnail'>        <img class='previewThumbnailImage' id='Preview_10_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_10_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_10_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_10_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_10_Info'>  <span class='previewText'  id='Preview_10_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_10_TextUser'></span>  <span class='previewStats' id='Preview_10_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_11_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_11_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_11_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_11_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_11_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_11_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_11_Thumnail'>        <img class='previewThumbnailImage' id='Preview_11_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_11_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_11_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_11_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_11_Info'>  <span class='previewText'  id='Preview_11_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_11_TextUser'></span>  <span class='previewStats' id='Preview_11_Stats'></span></div></div>  </div>
  <br>
  <div class="navigation" id="navBottom" ><span style="padding-right:8px;">Results (74098):</span><div class="controlOptions"><a id="pageButtonFirst" class="pageButtons" href="results?query=&sort=popular&from=0&num=12">1</a><span>...</span><a id="pageButton"0 class="pageButtons" href="results?query=&sort=popular&from=708&num=12">60</a><a id="pageButton"1 class="pageButtons" href="results?query=&sort=popular&from=720&num=12">61</a><div id="pageButton"2 class="pageButtonsCurrent" href="results?query=&sort=popular&from=732&num=12">62</div><a id="pageButton"3 class="pageButtons" href="results?query=&sort=popular&from=744&num=12">63</a><a id="pageButton"4 class="pageButtons" href="results?query=&sort=popular&from=756&num=12">64</a><span>...</span><a id="pageButtonLast" class="pageButtons" href="results?query=&sort=popular&from=74088&num=12">6175</a></div>
</div>  <br>      
</div>

<!-- footer ================================================================================== -->

<div id="footer">
    
    <div><span style="color:#ffffff;">Community Forums</span>
      <ul>
      <li><a class="regular" href="/events">Official Events</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/147749602472741">In Facebook (english)</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/1339783682699494">In Facebook (korean)</a></li>
      <li><a class="regular" href="https://discord.gg/XtmMN6E">In Discord</a> (<a class="regular" href="https://discordapp.com/channels/578696555612209173/579531723348639754">direct link</a>)</li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Feedback and Support</span>
      <ul>
      <li><a class="regular" href="https://www.facebook.com/Shadertoy">Facebook</a></li>
      <li><a class="regular" href="https://twitter.com/shadertoy">Twitter</a></li>
      <li><a class="regular" href="https://www.patreon.com/shadertoy">Patreon</a></li>
      <li><a class="regular" href="https://trello.com/b/5hM0CjId">Roadmap</a></li>

      
      </ul>
    </div>

    <div><span style="color:#ffffff;">Shadertoy</span>
      <ul>
      <li><a class="regular" href="/store">Store</a></li>
      <li><a class="regular" href="/howto">Documentation</a></li>
      <li><a class="regular" href="/terms">Terms & Privacy</a></li>
      <li><a class="regular" href="/about">About</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Apps and Plugins</span>
      <ul>
      <li><a class="regular" href="https://itunes.apple.com/us/app/shadertoy/id717961814">Official iPhone App</a> by <a class="user" href="/user/reinder">Reinder</a></li>
      <li><a class="regular" href="https://steamcommunity.com/sharedfiles/filedetails/?id=1726697188">Screensaver</a> by <a class="user" href="/user/kosro">Kosro</a></li>
      <li><a class="regular" href="https://chrome.google.com/webstore/detail/shadertoy-unofficial-plug/ohicbclhdmkhoabobgppffepcopomhgl">Shadertoy plugin</a> by <a class="user" href="/user/patu">Patu</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Tutorials</span>
      <ul>
      <li><a class="regular" href="https://www.youtube.com/watch?v=0ifChJ0nJfM">Shader coding intro</a> by <a class="user" href="/user/iq">iq</a></li>
      <li><a class="regular" href="https://shadertoyunofficial.wordpress.com/">Shadertoy Unofficial</a> by <a class="user" href="/user/FabriceNeyret2">FabriceNeyret2</a></li>
      </ul>
    </div>

</div>

<div id="compliance" style="padding-bottom:6px;visibility:hidden;left:0;top:0px;width:100%;background-color:rgb(200,120,20,0.93);position:absolute;color:#FFFFFF">
    <div style="text-align: center; margin-top:8px">
        We use cookies to give you the best experience on our website. If you continue using Shadertoy, we'll assume that you are happy to receive all cookies on this website. 
        For more information, please review our <a class="regular" href="/terms">Terms & Privacy</a>.
    </div> 
    <div style="text-align: center;margin-top:6px">
        <button type="button" style="width:100px;font-size:inherit" onclick="acceptCompliance()">Accept</button>
    </div>
</div>

<script>
(function runCompliance() 
{
    let showCompliance = 1;
    let allcookies = document.cookie;
    let cookiearray = allcookies.split(';');
    for (var i=0; i<cookiearray.length; i++)
    {
        let name  = cookiearray[i].split('=')[0];
        let value = cookiearray[i].split('=')[1];
        if (name.trim() == "scmp") 
        {
            showCompliance = value;
            break;
        }
    }

    if (showCompliance === 1) 
    {
        var ve = document.getElementById("compliance");
        ve.style.visibility="visible";
    }
})();

function acceptCompliance()
{
    let now = new Date();
    now.setTime( now.getTime() + (5*365*24*60*60*1000) );
    document.cookie="scmp=0;expires=" + now.toUTCString() + ";";

    var ve = document.getElementById("compliance");
    ve.style.visibility="hidden";
}
</script>

</body>
</html>
