<!DOCTYPE HTML>
<html lang="en">
<head>

    
<script async src="https://www.googletagmanager.com/gtag/js?id=G-7SYLWGZYJ2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-7SYLWGZYJ2');
</script>

<title>Browse (34) - Shadertoy BETA</title>
<meta charset="utf-8" />
<meta name="Keywords" content="shadertoy, shader toy, quilez, inigo, jeremias, pol, fractals, demoscene, computer graphics, mathematics, rendering, demo, 3D, realtime, shader, raytracing, raymarching, webgl, glsl" />
<meta name="Description" content="Build shaders, share them, and learn from the best community." />
<meta name="Author" content="Beautypi" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<link rel="image_src" href="https://www.shadertoy.com/img/logo.png" />
<link rel="apple-touch-icon" href="/img/launch_icon_57.png"/>
<link rel="apple-touch-icon" sizes="72x72" href="/img/launch_icon_72.png"/>
<link rel="apple-touch-icon" sizes="114x114" href="/img/launch_icon_114.png"/>
<link rel="shortcut icon" href="/img/favicon.ico"/>

<style>::-webkit-scrollbar {
    height: 8px;
    width: 8px;
    background: #404040;
}

::-webkit-scrollbar-thumb
{
    background: #909090;
    border-radius: 0ex;
}

::-webkit-scrollbar-corner
{
    background: #000;
}

::-webkit-input-placeholder
{
	font-style:italic;
}
input:-moz-placeholder, textarea:-moz-placeholder
{
	font-style:italic;
}
input.placeholder-text, textarea.placeholder-text
{
	font-style:italic;
}

pre 
{
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
    white-space: -pre-wrap;
    white-space: -o-pre-wrap;
    word-wrap: break-word;
}

@font-face
{
    font-family: Lobster;
    src: url("/img/lobster.otf") format("opentype");
}

div#centerScreen
{
    left: 50%;
    top: 50%;
    position: absolute;
}

a.headerLinks:hover
{
    background-color:#505050;
    color : #ff8020;
}

body
{
    color: #000000;
    font-size:12px;
    font-style:normal;
    font-family:Tahoma,Arial;
    background-repeat: no-repeat;
    //background-attachment: fixed;
    padding:0px;
    margin:0px;
    text-align: left;
    background-color: #d0d0d0;
    background-repeat: repeat;
    user-select: text;
}

a,
a:hover,
a:visited
{
  color : inherit;
}

div#content {
    width: 95%;
    overflow: hidden;
    margin: auto;
    padding: 0px;
    min-height: calc(100vh - 80px);
    //box-sizing: border-box;
}


.notificationCount
{
 background-color:#ff0000;
 padding-left:3px;
 padding-right:1px;
 padding-top:1px;
 padding-bottom:1px;
}

div#header
{
    background-color: #404040;
    top: 0px;
    left: 0px;
    width: 100%;
    padding: 0;
    margin: 0;
    color: #ffffff;
    display: flex;
    flex-direction:row;
}

#headerBlock1
{
    width: 50%;
    display:flex;
    align-items:center;
}

a#headerTitle
{
    font-size: 2.25em;
    font-family: Lobster,Tahoma,Arial;
    text-decoration: none;
    padding-left:32px;
    padding-right:32px;
}

#headerSearch
{
    display: inline-block;
    color: #000000;
    width: 300px;
}

input[type=search]#mySearch
{
    width: 100%;
    border-radius: 6px;
    border: 1px solid black;
    padding:12px;
}

#headerBlock2
{
    width: 50%;
    margin-left: auto;
    display: flex;
    justify-content: flex-end;
}


a#headerTitle:hover
{
    color : #ff8020;
}

a.headerLinks
{
    font-weight: bold;
    padding-top: 14px;
    padding-bottom: 14px;
    padding-left: 14px;
    padding-right: 14px;
    margin:0px;
    text-decoration: none;
    transition: background-color 0.15s linear, color 0.15s linear;
}

#footer
{
    background-color: rgba(64,64,64,0.25);
    color: #000000;
    padding: 0px;
    margin: 0px;
    width: 100%;
    display: flex;
    justify-content: space-between;
    flex-wrap: wrap;
}

#footer div
{
    padding-top:10px;
    padding-bottom:0px;
    padding-left:16px;
    padding-right:16px;
}

#footer div ul
{
    margin-left:0px;
    padding-left:16px;
}

#footer div ul li
{
    padding-top:6px;
}

a.regular
{
    font-weight:bold;
    text-decoration:none
}

a.regular:hover
{
  color : #ff8020;
}

a.user
{
    font-weight:bold;
    text-decoration:none;
}

a.user:hover
{
  color : #ff8020;
  text-decoration: underline;
}

.uiButton
{
    border: none;
    outline: none;
    margin: 0px;
    padding: 0px;
    width: 22px;
    height: 22px;
    position: absolute;
    cursor: pointer;
    border-radius: 4px;
}

.uiButton:hover
{
    box-shadow: inset 0px 0px 1px 1px #808080, 0px 0px 1px 1px #808080;
}

.uiDivBUtton
{
    cursor:pointer;
}

.uiDivBUtton:hover
{
    color: #ffffff;
}


.dialog
{
    display: block;
    background-color: #e0e0e0;
    color: #000000;
    border:1px solid #000;
    padding:0px;
    margin:0px;
    text-align:left;
    border-radius: 4px;
    box-shadow:4px 4px 6px 0px rgba(0,0,0,0.5);
    overflow: hidden;
    z-index:1000;
    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;
}

.dialogHeader
{
    left:0px;
    top: 0px;
    width:100%;
    height:32px;
    position: absolute;
    background-color: #808080;
    cursor:move;
}

.dialogTitle
{
    left: 12px;
    top: 4px;
    position: absolute;
    padding: 0px;
    margin: 0px;
    color:#000000;
    font-size:1.5em;
    text-align: left;
    user-select: none;
    -moz-user-select: -moz-none;
    -webkit-user-select: none;
}

.dialogOverlay
{
    z-index:1000;

    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;

    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    width:100%;
    height:100%;
    position:absolute;

    background-color:rgba(0,0,0,.4);
}

.viewsIcon, .likesIcon
{
    border: none;
    outline: none;
    display:inline-block;
    background-repeat:no-repeat;
    top:0px;
    left:0px;
    padding:0px;
    padding-right: 2px;
    margin:0px;
    position:relative;
}

.userPictureSmall
{
    background-color:#808080;
    border: 1px solid #000000;
    width:32px;
    height:32px;
}

.dialogCloseButton
{
    right:8px;
    top: 4px;
    width:22px;
    height:22px;
    position: absolute;
    background-image: url("/img/close.png");
    cursor: pointer;
    border-radius: 4px;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContentButtons
{
     padding:0;
     border:0;
     text-align: justify;
     left: 24px;
     bottom:40px;
     position:absolute;
}

.dialogButton
{
    text-align: center;
    vertical-align: middle;
    display: inline-block;
    border-radius: 4px;
    font-weight: bold;
    cursor: pointer;
    padding-bottom:5px;
    padding-top:4px;
    padding-left: 8px;
    padding-right: 8px;
    margin-left:4px;
    margin-right:4px;
    text-decoration: none;
    color:#000000;
    width: 80px;
    -moz-transition:    background-color 0.15s linear, color 0.15s linear;
    -webkit-transition: background-color 0.15s linear, color 0.15s linear;
    transition:         background-color 0.15s linear, color 0.15s linear;
}

.dialogButton:hover
{
  background-color:#808080;
  color : #ff8020;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContent
{
    color: inherit;
    overflow: auto;
    width:100%;
    height:100%;
    left: 0px;
    top: 32px;
    position:absolute
}

.dialogContentBody
{
    color: inherit;
    width:100%;
    height:auto;
    padding-top:24px;
    padding-bottom:24px;
    padding-left:24px;
    padding-right:24px;
    text-align: left;
}

.formButton
{
    font-weight:bold;
	color:#ffffff;
	border:none;
    text-align:center;
	background-color:#808080;
    border-radius: 4px;
	padding-left:8px;
	padding-right:8px;
	padding-top:4px;
	padding-bottom:4px;
    cursor:pointer;
    min-width:80px;
    box-sizing: border-box;
}
.formInput {
    border-radius: 6px;
    border: 1px solid black;
    padding: 4px;
    border: none;
}
.formButton:hover {
    background-color: #e0e0e0;
}
.formButton:disabled
{
	color:#b0b0b0;
	background-color:#808080;
}

.formButtonSmall
{
    color:#ffffff;
    border:none;
    text-align:center;
    background-color:#808080;
    border-radius: 4px;
    padding-left:2px;
    padding-right:2px;
    padding-top:2px;
    padding-bottom:2px;
    cursor:pointer;
    min-width:40px;
}

.formButtonSmall:hover
{
    background-color: #e0e0e0;
}

.formButtonSmall:disabled
{
    color:#b0b0b0;
    background-color:#808080;
}

.formButtonSmall.disabled2,
.formButton.disabled2 { color:#b0b0b0; background-color:#808080; pointer-events: none; }

.inputForm
{
    padding-left:2%;
    padding-right:2%;
    resize: none;
    text-align: left;
    background-color:#e0e0e0;
    outline: none;
    border-radius: 4px;
    border: 1px solid #808080;
    color:inherit;
    box-sizing: border-box;
}

.inputForm:focus
{
    border: 1px solid #AFCDD8;
    background-color: #EBF2F4;
}

.transparentPannel
{
    background-color:rgba(64,64,64,0.1);
    padding:16px;
}

.comment, .commentSelf, .commentNew
{
    border-radius: 4px;
    width: 100%;
    margin-left: 0px;
    margin-right: 0px;
    margin-top: 0px;
    margin-bottom: 6px;

    padding: 14px;
    box-sizing: border-box;
    display: grid;
    grid-template-columns: 32px auto 8px;
    grid-template-rows: 1fr;
    grid-gap:8px;
}

.comment:nth-child(even)
{
    background-color: rgba(64,64,64,0.1);
}

.comment:nth-child(odd)
{
    background-color: rgba(128,128,128,0.1);
}

.commentSelf
{
    background-color: rgba(240,160,64,0.1);
}

.commentNew
{
    padding-right: 0px;
    grid-template-columns: 40px auto;
}

.commentContent
{
    vertical-align: top;
    text-align: left;
    word-break: break-all;
    word-break: break-word;
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
}


/* ----------------------- media resolutions ------------------------ */

@media screen and (max-width:799px)
{
    div#header {flex-direction:column; }
    #headerBlock1 { width:100%; }
    #headerBlock2 { width:100%; justify-content: space-around;}
    div#headerSearch {width:200px;}
    input#mySearch { width:200px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:10px; }
}

@media screen and (min-width:800px) and (max-width:1279px)
{
    body { font-size: 9px; }
    div#headerSearch {width: 250px;}
    input#mySearch { width:250px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:11px; }
}

@media screen and (min-width:1280px) and (max-width:1439px)
{
    body { font-size: 10px; }
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1440px) and (max-width:1919px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1920px) and (max-width:2559px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}

@media screen and (min-width:2560px) 
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}
body
{
    background-image: url("/img/themes/classic/background.jpg");
}
</style>

    <script>"use strict"

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piCamera
//
//==============================================================================

function piCamera()
{
    var mMatrix = setIdentity();
    var mMatrixInv = setIdentity();

    var mPosition = [0.0,0.0,0.0];
    var mXRotation = 0.0;
    var mYRotation = 0.0;

    var mPositionTarget = [0.0,0.0,0.0];
    var mXRotationTarget = 0.0;
    var mYRotationTarget = 0.0;

    var me = {};
/*
    me.Set = function( pos, dir, roll) 
             {
                 mMatrix    = setLookat( pos, add(pos,dir), [Math.sin(roll),Math.cos(roll),Math.sin(roll)] );
                 mMatrixInv = invertFast( mMatrix );
             };
*/
    me.SetPos = function(pos)
                {
                    mPosition = pos;
                    //mMatrix[ 3] = -(mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                    //mMatrix[ 7] = -(mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                    //mMatrix[11] = -(mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                };
/*
    me.GlobalMove = function(pos)
                    {
                        mMatrix[ 3] -= (mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                        mMatrix[ 7] -= (mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                        mMatrix[11] -= (mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                        mMatrixInv = invertFast(mMatrix);
                    };
*/
    me.LocalMove = function( dis )
                    {
                        dis = matMulvec( setRotationY(-mYRotation), dis);
                        mPositionTarget = sub(mPositionTarget,dis)
                    };

    me.RotateXY = function( x, y)
                  {
                    mXRotationTarget -= x;
                    mYRotationTarget -= y;
                    mXRotationTarget = Math.min( Math.max( mXRotationTarget, -Math.PI/2), Math.PI/2 );
                  };


    me.CameraExectue = function( dt )
    {
        // smooth position
        mXRotation += (mXRotationTarget-mXRotation) * 12.0*dt;
        mYRotation += (mYRotationTarget-mYRotation) * 12.0*dt;
        mPosition = add(mPosition, mul( sub(mPositionTarget, mPosition), 12.0*dt));

        // Make Camera matrix
        mMatrix = matMul( matMul(setRotationX(mXRotation), 
                                 setRotationY(mYRotation)),  
                                 setTranslation(mPosition));
        mMatrixInv = invertFast(mMatrix);

    }

    me.GetMatrix = function() { return mMatrix; };
    me.GetMatrixInverse = function() { return mMatrixInv; };
    me.SetMatrix = function( mat ) 
                    {
                        mMatrix = mat;
                        mMatrixInv = invertFast(mMatrix);

                        mPosition = getXYZ(matMulpoint(mat, [0.0,0.0,0.0]));
                        mPositionTarget = mPosition;
                    };

    me.GetPos = function() { return getXYZ(matMulpoint(mMatrixInv, [0.0,0.0,0.0])); }
    me.GetDir = function() { return getXYZ(normalize(matMulvec(mMatrixInv, [0.0,0.0,-1.0]))); }

    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piFile
//
//==============================================================================

function piFile( binaryDataArrayBuffer )
{
    // private
    //var mDataView = new DataView( binaryDataArrayBuffer, 0 );
    var mDataView = binaryDataArrayBuffer;
    var mOffset = 0;

    // public members
    var me = {};
    me.mDummy = 0;
/*
    // public functions
    me.Seek = function( off ) { mOffset = off - 3; };
    me.ReadUInt16 = function()  { var res = mDataView.getUint16( mOffset ); mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = mDataView.getUint32( mOffset ); mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = mDataView.getFloat32( mOffset ); mOffset+=4; return res; };
*/

    me.Seek = function( off ) { mOffset = off; };
    me.ReadUInt8  = function()  { var res = (new Uint8Array(mDataView,mOffset))[0]; mOffset+=1; return res; };
    me.ReadUInt16 = function()  { var res = (new Uint16Array(mDataView,mOffset))[0]; mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = (new Uint32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = (new Float32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadFloat32Array = function(n) 
                          { 
                              var src = new Float32Array(mDataView, mOffset);
                              var res = [];  for( var i=0; i<n; i++ ) { res[i] = src[i]; }
                              mOffset += 4*n;
                              return res;
                          };
    me.ReadFloat32ArrayNative = function(n) { var src = new Float32Array(mDataView, mOffset); mOffset += 4*n; return src; };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piMesh
//
//==============================================================================

function piMesh()
{
    this.mChunks = [];
    this.mPrimitiveType = 0;
    this.mVertexFormat = null;
}

/*
piMesh.prototype.normalize = function( ppos, npos )
{
    var numv = this.mVertexData.length;
    var numt = this.mIndices.length;

    for( var i=0; i<numv; i++ )
    {
        //float *v = (float*)piMesh_GetVertexData( me, i, npos );
        //v[0] = 0.0f;
        //v[1] = 0.0f;
        //v[2] = 0.0f;
        this.mVerts[8 * i + 3] = 0.0;
        this.mVerts[8 * i + 4] = 0.0;
        this.mVerts[8 * i + 5] = 0.0;
    }

    for( var i=0; i<numt; i++ )
    {
        piMeshFace *face = me->mFaceData.mIndexArray[0].mBuffer + i;

        const int ft = face->mNum;
        
        vec3 nor = vec3( 0.0f, 0.0f, 0.0f );
        for( int j=0; j<ft; j++ )
        {
            const vec3 va = *((vec3*)piMesh_GetVertexData( me, face->mIndex[ j      ], ppos ));
            const vec3 vb = *((vec3*)piMesh_GetVertexData( me, face->mIndex[(j+1)%ft], ppos ));

            nor += cross( va, vb );
        }

        for( int j=0; j<ft; j++ )
        {
            vec3 *n = (vec3*)piMesh_GetVertexData( me, face->mIndex[j], npos );
            n->x += nor.x;
            n->y += nor.y;
            n->z += nor.z;
        }
    }

    for( var i=0; i<numv; i++ )
    {
        vec3 *v = (vec3*)piMesh_GetVertexData( me, i, npos );
        *v = normalize( *v );
    }
}
*/

piMesh.prototype.createCube = function(renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([ -1.0, -1.0, -1.0,
                                       1.0, -1.0, -1.0,
                                      -1.0,  1.0, -1.0,
                                       1.0,  1.0, -1.0,
                                      -1.0, -1.0,  1.0,
                                       1.0, -1.0,  1.0,
                                      -1.0,  1.0,  1.0,
                                       1.0,  1.0,  1.0 ]),

                        mIndices : new Uint16Array([ 0, 2, 1,   1, 2, 3,   5, 1, 3,   5, 3, 7,   4, 5, 7,   4, 7, 6,   4, 6, 2,   4, 2, 0,   6, 7, 3,   6, 3, 2,   4, 0, 1,   4, 1, 5 ]),
                        mNumVertices : 8,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };

    this.mVertexFormat = { mStride:12, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}

piMesh.prototype.createCubeSharp = function (renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 1.0,
                                    -1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 0.0,

                                     1.0, 1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 0.0,

                                     1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 1.0,
                                    -1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   1.0, 1.0,
                                     1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   1.0, 0.0,

                                    -1.0, 1.0, 1.0,  -1.0, 0.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0,-1.0,  -1.0, 0.0, 0.0,   0.0, 1.0,
                                    -1.0,-1.0,-1.0,  -1.0, 0.0, 0.0,   1.0, 1.0,
                                    -1.0,-1.0, 1.0,  -1.0, 0.0, 0.0,   1.0, 0.0 ]),

                        mIndices : new Uint16Array([0,1,2, 0,2,3,   4,5,6, 4,6,7,    8,9,10,8,10,11,   12,13,14,12,14,15,   16,17,18,16,18,19,   20,21,22,20,22,23]),
                        mNumVertices : 24,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };


    this.mVertexFormat = { mStride:32, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}


piMesh.prototype.createUnitQuad = function (renderer)
{
    this.mPrimitiveType = 0;
    this.mVertexFormat = { mStride:8, mChannels: [ {mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false} ] };

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0,  1.0, 1.0,  1.0]),
                        mIndices : new Uint16Array([0, 2, 1, 1, 2, 3]),
                        mNumVertices : 4,
                        mNumFaces : 2, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };
 
    return true;
}




piMesh.prototype.destroy = function()
{
    //delete this.mVerts;   this.mVerts = null;
    //delete this.mIndices; this.mIndices = null;
}

piMesh.prototype.scale = function (x, y, z)
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] *= x;
            this.mChunks[j].mVerts[stride * i + 1] *= y;
            this.mChunks[j].mVerts[stride * i + 2] *= z;
        }
    }
}

piMesh.prototype.translate = function (x, y, z) 
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] += x;
            this.mChunks[j].mVerts[stride * i + 1] += y;
            this.mChunks[j].mVerts[stride * i + 2] += z;
        }
    }
}

piMesh.prototype.GPULoad = function (renderer)
{
    for( var i=0; i<this.mChunks.length; i++ )
    {
        var vbo = renderer.CreateVertexArray(this.mChunks[i].mVerts, renderer.BUFTYPE.STATIC );
        if (vbo == null)
            return false;

        var ibo = renderer.CreateIndexArray(this.mChunks[i].mIndices, renderer.BUFTYPE.STATIC);
        if (ibo == null)
            return false;

        this.mChunks[i].mVBO = vbo;
        this.mChunks[i].mIBO = ibo;
    }
    return true;
}

piMesh.prototype.GPURender = function (renderer, positions )//, matPrj, matCam )
{
    //renderer.SetShaderConstantMat4F("unMPrj", matPrj, false );

    var num = this.mChunks.length;
    for( var i=0; i<num; i++ )
    {
        //var mat =  matMul( matCam, this.mChunks[i].mTransform );
        //renderer.SetShaderConstantMat4F("unMMod", mat, false);

        renderer.AttachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat, positions );
        renderer.AttachIndexArray(this.mChunks[i].mIBO );
        renderer.DrawPrimitive(renderer.PRIMTYPE.TRIANGLES, this.mChunks[i].mNumFaces * 3, true, 1);
        renderer.DetachIndexArray(this.mChunks[i].mIBO);
        renderer.DetachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat );
    }
}
//==============================================================================
//
// piLibs 2014-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piRenderer
//
//==============================================================================

function piRenderer()
{
    // private members

    var mGL = null;
    var mBindedShader = null;
    var mIs20 = false;
    var mFloat32Textures;
    var mFloat32Filter;
    var mFloat16Textures;
    var mDrawBuffers;
    var mDepthTextures;
    var mDerivatives;
    var mFloat16Filter;
    var mShaderTextureLOD;
    var mAnisotropic;
    var mRenderToFloat32F;
    var mDebugShader;
    var mAsynchCompile;

    var mVBO_Quad = null;
    var mVBO_Tri = null;
    var mVBO_CubePosNor = null;
    var mVBO_CubePos = null;
    var mShaderHeader = ["",""];
    var mShaderHeaderLines = [0,0];

    // public members
    var me = {};

    me.CLEAR      = { Color: 1, Zbuffer : 2, Stencil : 4 };
    me.TEXFMT     = { C4I8 : 0, C1I8 : 1, C1F16 : 2, C4F16 : 3, C1F32 : 4, C4F32 : 5, Z16 : 6, Z24 : 7, Z32 : 8, C3F32:9 };
    me.TEXWRP     = { CLAMP : 0, REPEAT : 1 };
    me.BUFTYPE    = { STATIC : 0, DYNAMIC : 1 };
    me.PRIMTYPE   = { POINTS : 0, LINES : 1, LINE_LOOP : 2, LINE_STRIP : 3, TRIANGLES : 4, TRIANGLE_STRIP : 5 };
    me.RENDSTGATE = { WIREFRAME : 0, FRONT_FACE : 1, CULL_FACE : 2, DEPTH_TEST : 3, ALPHA_TO_COVERAGE : 4 };
    me.TEXTYPE    = { T2D : 0, T3D : 1, CUBEMAP : 2 };
    me.FILTER     = { NONE : 0, LINEAR : 1, MIPMAP : 2, NONE_MIPMAP : 3 };
    me.TYPE       = { UINT8 : 0, UINT16 : 1, UINT32 : 2, FLOAT16: 3, FLOAT32 : 4, FLOAT64: 5 };

    // private functions

    var iFormatPI2GL = function( format )
    {
        if( mIs20 )
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA8,           mGLExternal: mGL.RGBA,             mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.R8,              mGLExternal: mGL.RED,              mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.R16F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA16F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.R32F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA32F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C3F32) return { mGLFormat: mGL.RGB32F,          mGLExternal: mGL.RGB,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT16, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z24)   return { mGLFormat: mGL.DEPTH_COMPONENT24, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z32)   return { mGLFormat: mGL.DEPTH_COMPONENT32F, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        }
        else
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.RED,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT, mGLExternal: mGL.DEPTH_COMPONENT, mGLType: mGL.UNSIGNED_SHORT }
        }

        return null;
     }

    // public functions

    me.Initialize = function( gl )
                    {
                        mGL = gl;

                        mIs20 = !(gl instanceof WebGLRenderingContext);

                        if( mIs20 )
                        {
                            mFloat32Textures  = true;
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = true;
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = true;
                            mDrawBuffers      = true;
                            mDepthTextures    = true;
                            mShaderTextureLOD = true;
                            mAnisotropic = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mGL.getExtension( 'EXT_color_buffer_float');
                            mDebugShader = mGL.getExtension('WEBGL_debug_shaders');
                            mAsynchCompile = mGL.getExtension('KHR_parallel_shader_compile');

							mGL.hint( mGL.FRAGMENT_SHADER_DERIVATIVE_HINT, mGL.NICEST);
                        }
                        else
                        {
                            mFloat32Textures  = mGL.getExtension( 'OES_texture_float' );
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = mGL.getExtension( 'OES_texture_half_float' );
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = mGL.getExtension( 'OES_standard_derivatives' );
                            mDrawBuffers      = mGL.getExtension( 'WEBGL_draw_buffers' );
                            mDepthTextures    = mGL.getExtension( 'WEBGL_depth_texture' );
                            mShaderTextureLOD = mGL.getExtension( 'EXT_shader_texture_lod' );
                            mAnisotropic      = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mFloat32Textures;
                            mDebugShader      = null;
                            mAsynchCompile    = null;
							
							if( mDerivatives !== null) mGL.hint( mDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, mGL.NICEST);
                        }
                        
                        
                        var maxTexSize = mGL.getParameter( mGL.MAX_TEXTURE_SIZE );
                        var maxCubeSize = mGL.getParameter( mGL.MAX_CUBE_MAP_TEXTURE_SIZE );
                        var maxRenderbufferSize = mGL.getParameter( mGL.MAX_RENDERBUFFER_SIZE );
                        var extensions = mGL.getSupportedExtensions();
                        var textureUnits = mGL.getParameter( mGL.MAX_TEXTURE_IMAGE_UNITS );
                        console.log("WebGL (2.0=" + mIs20 + "):" +
                                    " Asynch Compile: "  + ((mAsynchCompile !==null) ? "yes" : "no") +
                                    ", Textures: F32 ["   + ((mFloat32Textures !==null) ? "yes" : "no") +
                                    "], F16 ["   + ((mFloat16Textures !==null) ? "yes" : "no") +
                                    "], Depth [" + ((mDepthTextures   !==null) ? "yes" : "no") +
                                    "], LOD ["    + ((mShaderTextureLOD!==null) ? "yes" : "no") +
                                    "], Aniso ["   + ((mAnisotropic     !==null) ? "yes" : "no") +
                                    "], Units [" + textureUnits +
                                    "], Max Size [" + maxTexSize +
                                    "], Cube Max Size [" + maxCubeSize +
                                    "], Targets: MRT ["            + ((mDrawBuffers     !==null) ? "yes" : "no") +
                                    "], F32 ["     + ((mRenderToFloat32F!==null) ? "yes" : "no") +
                                    "], Max Size [" + maxRenderbufferSize + "]");

                        // create a 2D quad Vertex Buffer
                        var vertices = new Float32Array( [ -1.0, -1.0,   1.0, -1.0,    -1.0,  1.0,     1.0, -1.0,    1.0,  1.0,    -1.0,  1.0] );
                        mVBO_Quad = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                        mGL.bufferData( mGL.ARRAY_BUFFER, vertices, mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 2D triangle Vertex Buffer
                        mVBO_Tri = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0,   3.0, -1.0,    -1.0,  3.0] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePosNor = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0, -1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                               1.0,  1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                               1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                               1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                               1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0,  1.0, -1.0,   0.0,  0.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePos = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0,  1.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        //-------------------------------------------------------------------

                        mShaderHeader[0] = "";
                        mShaderHeaderLines[0] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[0] += "#version 300 es\n" +
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[0] += 6;
                        }
                        else
                        {
                            mShaderHeader[0] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "#endif\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+                                                
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[0] += 26;
                        }

                        //-------------------------------------------------------

                        mShaderHeader[1] = "";
                        mShaderHeaderLines[1] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[1] += "#version 300 es\n"+
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[1] += 6;
                        }
                        else
                        {
                            if( mDerivatives ) { mShaderHeader[1] += "#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n"; mShaderHeaderLines[1]+=3; }
                            if( mShaderTextureLOD  ) { mShaderHeader[1] += "#extension GL_EXT_shader_texture_lod : enable\n"; mShaderHeaderLines[1]++; }
                            mShaderHeader[1] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "#endif\n"+ 
                                                "vec4 texture(     sampler2D   s, vec2 c)                   { return texture2D(s,c); }\n"+
                                                "vec4 texture(     sampler2D   s, vec2 c, float b)          { return texture2D(s,c,b); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c )                  { return textureCube(s,c); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c, float b)          { return textureCube(s,c,b); }\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[1] += 30;
                            if( mShaderTextureLOD )
                            {
                            mShaderHeader[1] += "vec4 textureLod(  sampler2D   s, vec2 c, float b)          { return texture2DLodEXT(s,c,b); }\n";
                            mShaderHeader[1] += "vec4 textureGrad( sampler2D   s, vec2 c, vec2 dx, vec2 dy) { return texture2DGradEXT(s,c,dx,dy); }\n";
                            mShaderHeaderLines[1] += 2;

                            //mShaderHeader[1] += "vec4 texelFetch( sampler2D s, ivec2 c, int l) { return texture2DLodEXT(s,(vec2(c)+0.5)/vec2(800,450),float(l)); }\n";
                            //mShaderHeaderLines[1] += 1;
                            }
                        }

                        return true;
                    };

        me.GetCaps =    function ()
                        {   
                            return { mIsGL20 : mIs20,
                                     mFloat32Textures: mFloat32Textures != null,
                                     mFloat16Textures: mFloat16Textures != null,
                                     mDrawBuffers: mDrawBuffers != null,
                                     mDepthTextures: mDepthTextures != null,
                                     mDerivatives: mDerivatives != null,
                                     mShaderTextureLOD: mShaderTextureLOD != null };
                        };

        me.GetShaderHeaderLines = function (shaderType)
                        {   
                            return mShaderHeaderLines[shaderType];
                        };

        me.CheckErrors = function()
                         {
                                var error = mGL.getError();
                                if( error != mGL.NO_ERROR ) 
                                { 
                                    for( var prop in mGL ) 
                                    {
                                        if( typeof mGL[prop] == 'number' ) 
                                        {
                                            if( mGL[prop] == error )
                                            {
                                                console.log( "GL Error " + error + ": " + prop );
                                                break;
                                            }
                                        }
                                    }
                                }
                         };

        me.Clear =  function( flags, ccolor, cdepth, cstencil )
                    {
                        var mode = 0;
                        if( flags & 1 ) { mode |= mGL.COLOR_BUFFER_BIT;   mGL.clearColor( ccolor[0], ccolor[1], ccolor[2], ccolor[3] ); }
                        if( flags & 2 ) { mode |= mGL.DEPTH_BUFFER_BIT;   mGL.clearDepth( cdepth ); }
                        if( flags & 4 ) { mode |= mGL.STENCIL_BUFFER_BIT; mGL.clearStencil( cstencil ); }
                        mGL.clear( mode );
                    };


        me.CreateTexture = function ( type, xres, yres, format, filter, wrap, buffer)
                           {
                                if( mGL===null ) return null;

                                var id = mGL.createTexture();

                                var glFoTy = iFormatPI2GL( format );
                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                if( type===me.TEXTYPE.T2D )
                                {
                                    mGL.bindTexture( mGL.TEXTURE_2D, id );
//if( buffer==null )
    //mGL.texStorage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres);
//else
                                    mGL.texImage2D( mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap );

                                    if (filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                }
                                else if( type===me.TEXTYPE.T3D )
                                {
                                    if( mIs20 )
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_3D, id );
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_BASE_LEVEL, 0);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAX_LEVEL, Math.log2(xres));
                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_3D);
                                        }
                                        mGL.texImage3D( mGL.TEXTURE_3D, 0, glFoTy.mGLFormat, xres, yres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap );

                                        if (filter === me.FILTER.MIPMAP)
                                            mGL.generateMipmap( mGL.TEXTURE_3D );
                                        mGL.bindTexture( mGL.TEXTURE_3D, null );
                                    }
                                    else 
                                    {
                                        return null;
                                    }
                                }
                                else 
                                {
                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );

                                    // this works great if we know the number of required mipmaps in advance (1, or other)
                                   //mGL.texStorage2D( mGL.TEXTURE_CUBE_MAP, 1, glFoTy.mGLFormat, xres, yres );

                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                    if( filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                    }

                                    if (filter === me.FILTER.MIPMAP)
                                        mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );

                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                }
                        return { mObjectID: id, mXres: xres, mYres: yres, mFormat: format, mType: type, mFilter: filter, mWrap: wrap, mVFlip:false };
                        };

        me.CreateTextureFromImage = function ( type, image, format, filter, wrap, flipY) 
                                {
                                    if( mGL===null ) return null;

                                    var id = mGL.createTexture();

                                    var glFoTy = iFormatPI2GL( format );

                                    var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                    if( type===me.TEXTYPE.T2D )
                                    {
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);

                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.pixelStorei(mGL.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                                        if( mIs20 ) mGL.pixelStorei(mGL.UNPACK_COLORSPACE_CONVERSION_WEBGL, mGL.NONE );

                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);

                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);

                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if( filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                    }
                                    else if( type===me.TEXTYPE.T3D )
                                    {
                                        return null;
                                    }
                                    else 
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );

                                        if( filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                    }
                                    return { mObjectID: id, mXres: image.width, mYres: image.height, mFormat: format, mType: type, mFilter: filter, mWrap:wrap, mVFlip:flipY };
                                };

        me.SetSamplerFilter = function (te, filter, doGenerateMipsIfNeeded) 
                            {
                                if (te.mFilter === filter) return;

                                if (te.mType === me.TEXTYPE.T2D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_3D, null);

                                }
                                else
                                {
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }


                                te.mFilter = filter;
                            };

        me.SetSamplerWrap = function (te, wrap)
                            {
                                if (te.mWrap === wrap) return;

                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, id);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, id);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_3D, null);
                                }

                                te.mWrap = wrap;
                            };

        me.SetSamplerVFlip = function (te, vflip, image)
                            {
                                if (te.mVFlip === vflip) return;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    if( image != null)
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                }
                                else if (te.mType === me.TEXTYPE.CUBEMAP)
                                {
                                    if( image != null)
                                    {
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei( mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
        
                                }

                                te.mVFlip = vflip;
                            };

        me.CreateMipmaps =  function (te)
                            {
                                if( te.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);
                                    mGL.generateMipmap(mGL.TEXTURE_2D);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);
                                }
                                else if( te.mType===me.TEXTYPE.CUBEMAP )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);
                                    mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }
                            };

        me.UpdateTexture =  function( tex, x0, y0, xres, yres, buffer )
                            {
                                var glFoTy = iFormatPI2GL( tex.mFormat );
                                if( tex.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture( mGL.TEXTURE0);
                                    mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                    mGL.texSubImage2D( mGL.TEXTURE_2D, 0, x0, y0, xres, yres, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                }
                            };

        me.UpdateTextureFromImage = function( tex, image )
                                {
                                    var glFoTy = iFormatPI2GL( tex.mFormat );
                                    if( tex.mType===me.TEXTYPE.T2D )
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                        mGL.texImage2D(  mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image );
                                        mGL.bindTexture( mGL.TEXTURE_2D, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                };

        me.DestroyTexture = function( te )
                            {
                                 mGL.deleteTexture( te.mObjectID );
                            };

        me.AttachTextures = function (num, t0, t1, t2, t3) 
                            {
                                if (num > 0 && t0 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                         if (t0.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t0.mObjectID);
                                }

                                if (num > 1 && t1 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE1);
                                         if (t1.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t1.mObjectID);
                                }

                                if (num > 2 && t2 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE2);
                                         if (t2.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t2.mObjectID);
                                }

                                if (num > 3 && t3 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE3);
                                         if (t3.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t3.mObjectID);
                                }
                            };

        me.DettachTextures = function()
                             {
                                mGL.activeTexture(mGL.TEXTURE0);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE1);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE2);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE3);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                             };

        me.CreateRenderTarget = function ( color0, color1, color2, color3, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);

                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_2D, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.DestroyRenderTarget = function ( tex )
                                 {
                                     mGL.deleteFramebuffer(tex.mObjectID);
                                 };

        me.SetRenderTarget = function (tex)
                             {
                                if( tex===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, tex.mObjectID);

                                //mGL.drawBuffers([mGL.COLOR_ATTACHMENT0, mGL.COLOR_ATTACHMENT1]);
                             };

        me.CreateRenderTargetNew = function ( wantColor0, wantZbuffer, xres, yres, samples )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if( wantZbuffer===true )
                                    {
                                        var zb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);

                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.DEPTH_COMPONENT16, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                    }

                                    if( wantColor0 )
                                    {
                                        var cb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, cb);
                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.RGBA8, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.RGBA8, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.RENDERBUFFER, cb);
                                    }

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                    {
                                        return null;
                                    }
                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mXres: xres, mYres:yres, mTex0: color0 };
                                };

        me.CreateRenderTargetCubeMap = function ( color0, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);
                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.SetRenderTargetCubeMap = function (fbo, face)
                             {
                                if( fbo===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                {
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, fbo.mObjectID);
                                    mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X+face, fbo.mTex0.mObjectID, 0);
                                }
                             };


        me.BlitRenderTarget = function( dst, src )
                                {
                                    mGL.bindFramebuffer(mGL.READ_FRAMEBUFFER, src.mObjectID);
                                    mGL.bindFramebuffer(mGL.DRAW_FRAMEBUFFER, dst.mObjectID);
                                    mGL.clearBufferfv(mGL.COLOR, 0, [0.0, 0.0, 0.0, 1.0]);
                                    mGL.blitFramebuffer( 0, 0, src.mXres, src.mYres,
                                                         0, 0, src.mXres, src.mYres,
                                                         mGL.COLOR_BUFFER_BIT, mGL.LINEAR
                                    );
                                };

        me.SetViewport = function( vp )
                         {
                              mGL.viewport( vp[0], vp[1], vp[2], vp[3] );
                         };

        me.SetWriteMask = function( c0, c1, c2, c3, z )
                          {
                              mGL.depthMask(z);
                              mGL.colorMask(c0,c0,c0,c0);
                          };

        me.SetState = function( stateName, stateValue )
                      {
                            if (stateName === me.RENDSTGATE.WIREFRAME)
                            {
                                if( stateValue ) mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.LINE );
                                else             mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.FILL );
                            }
                            else if (stateName === me.RENDSTGATE.FRONT_FACE)
                            {
                                if( stateValue ) mGL.cullFace( mGL.BACK );
                                else             mGL.cullFace( mGL.FRONT );
                            }
                            else if (stateName === me.RENDSTGATE.CULL_FACE)
                            {
                                if( stateValue ) mGL.enable( mGL.CULL_FACE );
                                else             mGL.disable( mGL.CULL_FACE );
                            }
                            else if (stateName === me.RENDSTGATE.DEPTH_TEST)
                            {
                                if( stateValue ) mGL.enable( mGL.DEPTH_TEST );
                                else             mGL.disable( mGL.DEPTH_TEST );
                            }
                            else if (stateName === me.RENDSTGATE.ALPHA_TO_COVERAGE)
                            {
                                if( stateValue ) { mGL.enable(  mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                                else             { mGL.disable( mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                            }
                      };

        me.SetMultisample = function( v)
                    {
                        if( v===true )
                        {
                            mGL.enable(mGL.SAMPLE_COVERAGE);
                            mGL.sampleCoverage(1.0, false);
                        }
                        else
                        {
                            mGL.disable(mGL.SAMPLE_COVERAGE);
                        }
                    };

        me.GetTranslatedShaderSource = function (shader) 
                          {
                            if( mGL===null ) return null;
                            if( mDebugShader===null ) return null;
                            let vfs = mGL.getAttachedShaders(shader.mProgram);
                            let str = mDebugShader.getTranslatedShaderSource(vfs[1]);
                            let parts = str.split("GLSL END"); str = (parts.length<2) ? str : parts[1];
                            return str;
                          };

        me.CreateShader = function (vsSource, fsSource, preventCache, forceSynch, onResolve) 
                          {
                            if( mGL===null ) return;

                            var vs = mGL.createShader( mGL.VERTEX_SHADER   );
                            var fs = mGL.createShader( mGL.FRAGMENT_SHADER );

                            vsSource = mShaderHeader[0] + vsSource;
                            fsSource = mShaderHeader[1] + fsSource;

                            if( preventCache )
                            {
                                let vran = Math.random().toString(36).substring(7);
                                let fran = Math.random().toString(36).substring(7);
                                vsSource += "\n#define K" + vran + "\n";
                                fsSource += "\n#define K" + fran + "\n";
                            }

                            var timeStart = getRealTime();

                            mGL.shaderSource(vs, vsSource);
                            mGL.shaderSource(fs, fsSource);
                            mGL.compileShader(vs);
                            mGL.compileShader(fs);

                            var pr = mGL.createProgram();
                            mGL.attachShader(pr, vs);
                            mGL.attachShader(pr, fs);
                            mGL.linkProgram(pr);

                            //-------------
                            let checkErrors = function()
                            {
                                if (!mGL.getProgramParameter(pr, mGL.LINK_STATUS))
                                {
                                    // vs error
                                    if (!mGL.getShaderParameter(vs, mGL.COMPILE_STATUS))
                                    {
                                        let vsLog = mGL.getShaderInfoLog(vs);
                                        onResolve(false, { mErrorType: 0, mErrorStr: vsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // fs error
                                    else if (!mGL.getShaderParameter(fs, mGL.COMPILE_STATUS))
                                    {
                                        let fsLog = mGL.getShaderInfoLog(fs);
                                        onResolve(false, { mErrorType: 1, mErrorStr: fsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // link error
                                    else
                                    {
                                        let infoLog = mGL.getProgramInfoLog(pr);
                                        onResolve(false, { mErrorType: 2, mErrorStr: infoLog });
                                        mGL.deleteProgram(pr);
                                    }
                                }
                                // no errors
                                else
                                {
                                    let compilationTime = getRealTime() - timeStart;
                                    onResolve(true, { mProgram: pr, mTime: compilationTime });
                                }
                            };

                            // check compilation
                            if (mAsynchCompile === null || forceSynch===true )
                            {
                                checkErrors();
                            }
                            else
                            {
                                let loopCheckCompletion = function ()
                                {
                                    if( mGL.getProgramParameter(pr, mAsynchCompile.COMPLETION_STATUS_KHR) === true )
                                        checkErrors();
                                    else
                                        setTimeout(loopCheckCompletion, 10);
                                };
                                setTimeout(loopCheckCompletion, 10);
                            }
                        };

        me.AttachShader = function( shader )
                          {
                                if( shader===null )
                                {
                                    mBindedShader = null;
                                    mGL.useProgram( null );
                                }
                                else
                                {
                                    mBindedShader = shader;
                                    mGL.useProgram(shader.mProgram);
                                }
                          };

        me.DetachShader = function ()
                        {
                            mGL.useProgram(null);
                        };

        me.DestroyShader = function( tex )
                        {
                            mGL.deleteProgram(tex.mProgram);
                        };

        me.GetAttribLocation = function (shader, name)
                        {
                            return mGL.getAttribLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantLocation = function (shader, name)
                        {
                            return mGL.getUniformLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantMat4F = function( uname, params, istranspose )
                        {
                            var program = mBindedShader;

                            let pos = mGL.getUniformLocation( program.mProgram, uname );
                            if( pos===null )
                                return false;

                            if( istranspose===false )
                            {
                                var tmp = new Float32Array( [ params[0], params[4], params[ 8], params[12],
                                                              params[1], params[5], params[ 9], params[13],
                                                              params[2], params[6], params[10], params[14],
                                                              params[3], params[7], params[11], params[15] ] );
	                            mGL.uniformMatrix4fv(pos,false,tmp);
                            }
                            else
                                mGL.uniformMatrix4fv(pos,false,new Float32Array(params) );
                            return true;
                        };

        me.SetShaderConstant1F_Pos = function(pos, x)
                        {
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1FV_Pos = function(pos, x)
                        {
                            mGL.uniform1fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant1F = function( uname, x )
                        {
                            var pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1I = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1i(pos, x);
                            return true;
                        };
        me.SetShaderConstant1I_Pos = function(pos, x)
                        {
                            mGL.uniform1i(pos, x);
                            return true;
                        };


        me.SetShaderConstant2F = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform2fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant3F = function(uname, x, y, z)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform3f(pos, x, y, z);
                            return true;
                        };

        me.SetShaderConstant1FV = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1fv(pos, new Float32Array(x));
                            return true;
                        };

        me.SetShaderConstant3FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform3fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderConstant4FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform4fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderTextureUnit = function( uname, unit )
                        {
                            var program = mBindedShader;
                            let pos = mGL.getUniformLocation(program.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform1i(pos, unit);
                            return true;
                        };

        me.CreateVertexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, id);
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.CreateIndexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, id );
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.DestroyArray = function( tex )
                        {
                            mGL.destroyBuffer(tex.mObject);
                        };

        me.AttachVertexArray = function( tex, attribs, pos )
                        {
                            let shader = mBindedShader;

                            mGL.bindBuffer( mGL.ARRAY_BUFFER, tex.mObject);

                            var num = attribs.mChannels.length;
                            var stride = attribs.mStride;

                            var offset = 0;
                            for (var i = 0; i < num; i++)
                            {
                                var id = pos[i];
                                mGL.enableVertexAttribArray(id);
                                var dtype = mGL.FLOAT;
                                var dsize = 4;
                                     if( attribs.mChannels[i].mType === me.TYPE.UINT8   ) { dtype = mGL.UNSIGNED_BYTE;  dsize = 1; }
                                else if( attribs.mChannels[i].mType === me.TYPE.UINT16  ) { dtype = mGL.UNSIGNED_SHORT; dsize = 2; }
                                else if( attribs.mChannels[i].mType === me.TYPE.FLOAT32 ) { dtype = mGL.FLOAT;          dsize = 4; }
                                mGL.vertexAttribPointer(id, attribs.mChannels[i].mNumComponents, dtype, attribs.mChannels[i].mNormalize, stride, offset);
                                offset += attribs.mChannels[i].mNumComponents * dsize;
                            }
                        };

        me.AttachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, tex.mObject);
                        };

        me.DetachVertexArray = function (tex, attribs)
                        {
                            let num = attribs.mChannels.length;
                            for (let i = 0; i < num; i++)
                                mGL.disableVertexAttribArray(i);
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, null);
                        };

        me.DetachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, null);
                        };

        me.DrawPrimitive = function( typeOfPrimitive, num, useIndexArray, numInstances )
                        {
                            let glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.POINTS ) glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.LINES ) glType = mGL.LINES;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_LOOP ) glType = mGL.LINE_LOOP;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_STRIP ) glType = mGL.LINE_STRIP;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLES ) glType = mGL.TRIANGLES;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLE_STRIP ) glType = mGL.TRIANGLE_STRIP;

                            if( numInstances<=1 )
                            {
  	                            if( useIndexArray ) mGL.drawElements( glType, num, mGL.UNSIGNED_SHORT, 0 );
	                            else                mGL.drawArrays( glType, 0, num );
                            }
                            else
                            {
                                mGL.drawArraysInstanced(glType, 0, num, numInstances);
                                mGL.drawElementsInstanced( glType, num, mGL.UNSIGNED_SHORT, 0, numInstances);
                            }
                        };


        me.DrawFullScreenTriangle_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 3 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };


        me.DrawUnitQuad_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 6 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };

        me.DrawUnitCube_XYZ_NOR = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                            mGL.vertexAttribPointer( vpos[0], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.vertexAttribPointer( vpos[1], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos[0] );
                            mGL.enableVertexAttribArray( vpos[1] );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos[0] );
                            mGL.disableVertexAttribArray( vpos[1] );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.DrawUnitCube_XYZ = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                            mGL.vertexAttribPointer( vpos, 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.SetBlend = function( enabled )
                    {
                        if( enabled )
                        {
                            mGL.enable( mGL.BLEND );
                            mGL.blendEquationSeparate( mGL.FUNC_ADD, mGL.FUNC_ADD );
                            mGL.blendFuncSeparate( mGL.SRC_ALPHA, mGL.ONE_MINUS_SRC_ALPHA, mGL.ONE, mGL.ONE_MINUS_SRC_ALPHA );
                        }
                        else
                        {
                            mGL.disable( mGL.BLEND );
                        }
                    };

        me.GetPixelData = function( data, offset, xres, yres )
                        {
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.UNSIGNED_BYTE, data, offset);
                        };

        me.GetPixelDataRenderTarget = function( obj, data, xres, yres )
                        {
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, obj.mObjectID);
                            mGL.readBuffer(mGL.COLOR_ATTACHMENT0);
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.FLOAT, data, 0);
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                        };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piShading
//
//==============================================================================

function smoothstep(a, b, x)
{
    x = (x - a) / (b - a);
    if (x < 0) x = 0; else if (x > 1) x = 1;
    return x * x * (3.0 - 2.0 * x);
}

function clamp01(x)
{
    if( x < 0.0 ) x = 0.0;
    if( x > 1.0 ) x = 1.0;
    return x;
}

function clamp(x, a, b)
{
    if( x < a ) x = a;
    if( x > b ) x = b;
    return x;
}

function screen(a, b)
{
    return 1.0 - (1.0 - a) * (1.0 - b);
}

function parabola(x)
{
    return 4.0 * x * (1.0 - x);
}

function min(a, b)
{
    return (a < b) ? a : b;
}

function max(a, b)
{
    return (a > b) ? a : b;
}

function noise( x )
{
    function grad(i, j, x, y)
    {
        var h = 7 * i + 131 * j;
        h = (h << 13) ^ h;
        h = (h * (h * h * 15731 + 789221) + 1376312589);

        var rx = (h & 0x20000000) ? x : -x;
        var ry = (h & 0x10000000) ? y : -y;

        return rx + ry;
    }

    var i = [ Math.floor(x[0]), Math.floor(x[1]) ];
    var f = [ x[0] - i[0], x[1] - i[1] ];
    var w = [ f[0]*f[0]*(3.0-2.0*f[0]), f[1]*f[1]*(3.0-2.0*f[1]) ];

    var a = grad( i[0]+0, i[1]+0, f[0]+0.0, f[1]+0.0 );
    var b = grad( i[0]+1, i[1]+0, f[0]-1.0, f[1]+0.0 );
    var c = grad( i[0]+0, i[1]+1, f[0]+0.0, f[1]-1.0 );
    var d = grad( i[0]+1, i[1]+1, f[0]-1.0, f[1]-1.0 );

    return a + (b-a)*w[0] + (c-a)*w[1] + (a-b-c+d)*w[0]*w[1];
}//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piVecTypes
//
//==============================================================================


function vec3( a, b, c )
{
    return [ a, b, c ];
}

function add( a, b )
{
    return [ a[0]+b[0], a[1]+b[1], a[2]+b[2] ];
}

function sub( a, b )
{
    return [ a[0]-b[0], a[1]-b[1], a[2]-b[2] ];
}

function mul( a, s ) 
{
    return [ a[0]*s, a[1]*s, a[2]*s ];
}

function cross( a, b )
{
    return [ a[1]*b[2] - a[2]*b[1],
             a[2]*b[0] - a[0]*b[2],
             a[0]*b[1] - a[1]*b[0] ];
}

function dot( a, b ) 
{
    return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
}

function normalize( v ) 
{
    var is = 1.0 / Math.sqrt( v[0]*v[0] + v[1]*v[1] + v[2]*v[2] );
    return [ v[0]*is, v[1]*is, v[2]*is ];
}

function createCirclePoint( cen, uuu, vvv, rad, s, t )
{
    return [ cen[0] + rad*(uuu[0]*s + vvv[0]*t),
             cen[1] + rad*(uuu[1]*s + vvv[1]*t),
             cen[2] + rad*(uuu[2]*s + vvv[2]*t) ];
}

function createTangent( a, b, c )
{
    var cb = normalize( [ c[0]-b[0], c[1]-b[1], c[2]-b[2] ] );
    var ba = normalize( [ b[0]-a[0], b[1]-a[1], b[2]-a[2] ] );
    return normalize( [ ba[0]+cb[0], ba[1]+cb[1], ba[2]+cb[2] ] );

}

//===================================

function vec4( a, b, c, d )
{
    return [ a, b, c, d ];
}

function getXYZ( v )
{
    return [ v[0], v[1], v[2] ];
}

//===================================

function setIdentity()
{
    return [ 1.0, 0.0, 0.0, 0.0,
             0.0, 1.0, 0.0, 0.0,
             0.0, 0.0, 1.0, 0.0,
             0.0, 0.0, 0.0, 1.0 ];
}

function setRotationX( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ 1.0,   0.0,   0.0, 0.0,
             0.0,  cost, -sint, 0.0, 
             0.0,  sint,  cost, 0.0,
             0.0,   0.0,   0.0, 1.0 ];
}

function setRotationY( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ cost, 0.0, -sint, 0.0,
              0.0, 1.0,   0.0, 0.0, 
             sint, 0.0,  cost, 0.0,
              0.0, 0.0,   0.0, 1.0 ];
}

function extractRotationEuler( m)
{
    var res = [];
    if (m[0] == 1.0)
    {
        res[0] = Math.atan2(m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;

    }
    else if (m[0] == -1.0)
    {
        res[0] = Math.atan2( m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;
    }
    else
    {
        res[0] = Math.atan2( -m[9], m[10]);
        res[1] = Math.atan2( m[8], Math.sqrt(m[9]*m[9] + m[10]*m[10]));
        res[2] = Math.atan2( m[4], m[0]);
    }
    return res;
}

function setFromQuaternion( q )
{
    var ww = q[3]*q[3];
    var xx = q[0]*q[0];
    var yy = q[1]*q[1];
    var zz = q[2]*q[2];

    return [ ww+xx-yy-zz,                   2.0*(q[0]*q[1] - q[3]*q[2]), 2.0*(q[0]*q[2] + q[3]*q[1]), 0.0,
               2.0*(q[0]*q[1] + q[3]*q[2]),   ww-xx+yy-zz,                 2.0*(q[1]*q[2] - q[3]*q[0]), 0.0,
               2.0*(q[0]*q[2] - q[3]*q[1]),   2.0*(q[1]*q[2] + q[3]*q[0]), ww-xx-yy+zz,                 0.0,
               0.0,                           0.0,                         0.0,                         1.0 ];
}

function setPerspective( fovy, aspect, znear, zfar )
{
    var tan = Math.tan(fovy * Math.PI/180.0);
    var x = 1.0 / (tan*aspect);
    var y = 1.0 / (tan);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0 * zfar * znear) / (zfar - znear);

    return [ x,    0.0,  0.0,  0.0,
             0.0,  y,    0.0,  0.0,
             0.0,  0.0,  c,     d,
             0.0,  0.0, -1.0,  0.0 ];
}

function setLookAt( eye, tar, up )
{
    var dir = [ -tar[0]+eye[0], -tar[1]+eye[1], -tar[2]+eye[2] ];

	var m00 = dir[2]*up[1] - dir[1]*up[2]; 
    var m01 = dir[0]*up[2] - dir[2]*up[0];
    var m02 = dir[1]*up[0] - dir[0]*up[1];
    var im = 1.0/Math.sqrt( m00*m00 + m01*m01 + m02*m02 );
    m00 *= im;
    m01 *= im;
    m02 *= im;

	var m04 = m02*dir[1] - m01*dir[2]; 
    var m05 = m00*dir[2] - m02*dir[0];
    var m06 = m01*dir[0] - m00*dir[1];
    im = 1.0/Math.sqrt( m04*m04 + m05*m05 + m06*m06 );
    m04 *= im;
    m05 *= im;
    m06 *= im;

	var m08 = dir[0];
	var m09 = dir[1];
	var m10 = dir[2];
    im = 1.0/Math.sqrt( m08*m08 + m09*m09 + m10*m10 );
    m08 *= im;
    m09 *= im;
    m10 *= im;

	var m03 = -(m00*eye[0] + m01*eye[1] + m02*eye[2] );
	var m07 = -(m04*eye[0] + m05*eye[1] + m06*eye[2] );
	var m11 = -(m08*eye[0] + m09*eye[1] + m10*eye[2] );

    return [ m00, m01, m02, m03,
             m04, m05, m06, m07,
             m08, m09, m10, m11,
             0.0, 0.0, 0.0, 1.0 ];
}


function setOrtho( left, right, bottom, top, znear, zfar )
{
   var x = 2.0 / (right - left);
   var y = 2.0 / (top - bottom);
   var a = (right + left) / (right - left);
   var b = (top + bottom) / (top - bottom);
   var c = -2.0 / (zfar - znear);
   var d = -(zfar + znear) / ( zfar - znear);

   return [  x, 0.0, 0.0,   a,
           0.0,   y, 0.0,   b,
           0.0, 0.0,   c,   d,
           0.0, 0.0, 0.0, 1.0 ];
}

function setTranslation( p )
{
    return [ 1.0, 0.0, 0.0, p[0],
             0.0, 1.0, 0.0, p[1],
             0.0, 0.0, 1.0, p[2],
             0.0, 0.0, 0.0, 1.0 ];
}

function setScale( s )
{
    return [ s[0], 0.0,  0.0,  0.0,
             0.0,  s[1], 0.0,  0.0,
             0.0,  0.0,  s[2], 0.0,
             0.0,  0.0,  0.0,  1.0];
}

function setProjection( fov, znear, zfar )
{
    var x = 2.0 / (fov[3]+fov[2]);
    var y = 2.0 / (fov[0]+fov[1]);
    var a = (fov[3]-fov[2]) / (fov[3]+fov[2]);
    var b = (fov[0]-fov[1]) / (fov[0]+fov[1]);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0*zfar*znear) / (zfar - znear);
    return [   x, 0.0,    a, 0.0,
             0.0,   y,    b, 0.0,
             0.0, 0.0,    c,   d,
             0.0, 0.0, -1.0, 0.0 ];
   // inverse is:
   //return mat4x4( 1.0/x, 0.0f,  0.0f,   a/x,
   //               0.0f,  1.0/y, 0.0f,   b/x,
   //               0.0f,  0.0f,  0.0f,   -1.0,
   //               0.0f,  0.0f,  1.0f/d, c/d );
}


function invertFast( m )
{
    var inv = [
   
             m[5]  * m[10] * m[15] - 
             m[5]  * m[11] * m[14] - 
             m[9]  * m[6]  * m[15] + 
             m[9]  * m[7]  * m[14] +
             m[13] * m[6]  * m[11] - 
             m[13] * m[7]  * m[10],

             -m[1]  * m[10] * m[15] + 
              m[1]  * m[11] * m[14] + 
              m[9]  * m[2] * m[15] - 
              m[9]  * m[3] * m[14] - 
              m[13] * m[2] * m[11] + 
              m[13] * m[3] * m[10],

             m[1]  * m[6] * m[15] - 
             m[1]  * m[7] * m[14] - 
             m[5]  * m[2] * m[15] + 
             m[5]  * m[3] * m[14] + 
             m[13] * m[2] * m[7] - 
             m[13] * m[3] * m[6],

             -m[1] * m[6] * m[11] + 
              m[1] * m[7] * m[10] + 
              m[5] * m[2] * m[11] - 
              m[5] * m[3] * m[10] - 
              m[9] * m[2] * m[7] + 
              m[9] * m[3] * m[6],

             -m[4]  * m[10] * m[15] + 
              m[4]  * m[11] * m[14] + 
              m[8]  * m[6]  * m[15] - 
              m[8]  * m[7]  * m[14] - 
              m[12] * m[6]  * m[11] + 
              m[12] * m[7]  * m[10],

             m[0]  * m[10] * m[15] - 
             m[0]  * m[11] * m[14] - 
             m[8]  * m[2] * m[15] + 
             m[8]  * m[3] * m[14] + 
             m[12] * m[2] * m[11] - 
             m[12] * m[3] * m[10],

             -m[0]  * m[6] * m[15] + 
              m[0]  * m[7] * m[14] + 
              m[4]  * m[2] * m[15] - 
              m[4]  * m[3] * m[14] - 
              m[12] * m[2] * m[7] + 
              m[12] * m[3] * m[6],


             m[0] * m[6] * m[11] - 
             m[0] * m[7] * m[10] - 
             m[4] * m[2] * m[11] + 
             m[4] * m[3] * m[10] + 
             m[8] * m[2] * m[7] - 
             m[8] * m[3] * m[6],


             m[4]  * m[9] * m[15] - 
             m[4]  * m[11] * m[13] - 
             m[8]  * m[5] * m[15] + 
             m[8]  * m[7] * m[13] + 
             m[12] * m[5] * m[11] - 
             m[12] * m[7] * m[9],



             -m[0]  * m[9] * m[15] + 
              m[0]  * m[11] * m[13] + 
              m[8]  * m[1] * m[15] - 
              m[8]  * m[3] * m[13] - 
              m[12] * m[1] * m[11] + 
              m[12] * m[3] * m[9],

              m[0]  * m[5] * m[15] - 
              m[0]  * m[7] * m[13] - 
              m[4]  * m[1] * m[15] + 
              m[4]  * m[3] * m[13] + 
              m[12] * m[1] * m[7] - 
              m[12] * m[3] * m[5],

              -m[0] * m[5] * m[11] + 
               m[0] * m[7] * m[9] + 
               m[4] * m[1] * m[11] - 
               m[4] * m[3] * m[9] - 
               m[8] * m[1] * m[7] + 
               m[8] * m[3] * m[5],

              -m[4]  * m[9] * m[14] + 
               m[4]  * m[10] * m[13] +
               m[8]  * m[5] * m[14] - 
               m[8]  * m[6] * m[13] - 
               m[12] * m[5] * m[10] + 
               m[12] * m[6] * m[9],

              m[0]  * m[9] * m[14] - 
              m[0]  * m[10] * m[13] - 
              m[8]  * m[1] * m[14] + 
              m[8]  * m[2] * m[13] + 
              m[12] * m[1] * m[10] - 
              m[12] * m[2] * m[9],

              -m[0]  * m[5] * m[14] + 
               m[0]  * m[6] * m[13] + 
               m[4]  * m[1] * m[14] - 
               m[4]  * m[2] * m[13] - 
               m[12] * m[1] * m[6] + 
               m[12] * m[2] * m[5],

              m[0] * m[5] * m[10] - 
              m[0] * m[6] * m[9] - 
              m[4] * m[1] * m[10] + 
              m[4] * m[2] * m[9] + 
              m[8] * m[1] * m[6] - 
              m[8] * m[2] * m[5] ];

    var det = m[0] * inv[0] + m[1] * inv[4] + m[2] * inv[8] + m[3] * inv[12];

    det = 1.0/det;

    for( var i = 0; i<16; i++ ) inv[i] = inv[i] * det;

    return inv;
}

function matMul( a, b )
{
    var res = [];
    for( var i=0; i<4; i++ )
    {
        var x = a[4*i+0];
        var y = a[4*i+1];
        var z = a[4*i+2];
        var w = a[4*i+3];

        res[4*i+0] = x * b[ 0] + y * b[ 4] + z * b[ 8] + w * b[12];
        res[4*i+1] = x * b[ 1] + y * b[ 5] + z * b[ 9] + w * b[13];
        res[4*i+2] = x * b[ 2] + y * b[ 6] + z * b[10] + w * b[14];
        res[4*i+3] = x * b[ 3] + y * b[ 7] + z * b[11] + w * b[15];
    }

    return res;
}

function matMulpoint( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2] + m[ 3],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2] + m[ 7],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] + m[11] ];
}

function matMulvec( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] ];
}


function bound3( infi )
{
    return [ infi, -infi, infi, -infi, infi, -infi ];
}

function bound3_include( a, p )
{
    return [
        (p[0]<a[0]) ? p[0] : a[0],
        (p[0]>a[1]) ? p[0] : a[1],
        (p[1]<a[2]) ? p[1] : a[2],
        (p[1]>a[3]) ? p[1] : a[3],
        (p[2]<a[4]) ? p[2] : a[4],
        (p[2]>a[5]) ? p[2] : a[5] ];
}

function bound3_center( b )
{
    return [ 0.5*(b[0]+b[1]),
             0.5*(b[2]+b[3]),
             0.5*(b[4]+b[5]) ];
}

function bound3_radius( b )
{
    return [ 0.5*(b[1]-b[0]),
             0.5*(b[3]-b[2]),
             0.5*(b[5]-b[4]) ];
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebVR
//
//==============================================================================

function WebVR( isVREnabledCallback, canvasElement )
{
    isVREnabledCallback(false);
    /*


    this.mSupportVR = false;
    this.mHMD = null;

    var me = this;
    var listVRDisplays = function (vrdevs) {
        for (var i = 0; i < vrdevs.length; i++)
        {
            if (vrdevs[i] instanceof VRDisplay)
            {
                me.mHMD = vrdevs[i];
                console.log("WebVR is available.");
                console.log(me.mHMD);
                break;
            }
        }

        isVREnabledCallback(true);
        me.mSupportVR = true;
    }

    if (navigator.getVRDisplays)
    {
        navigator.getVRDisplays().then(listVRDisplays);
    }

    isVREnabledCallback(false);
    this.mCanvas = canvasElement;
    */
}

WebVR.prototype.IsSupported = function()
{
    return false;
    //return this.mSupportVR;
}

WebVR.prototype.GetData = function( id )
{
    return {};
    /*
    var frameData = new VRFrameData();
    var s = this.mHMD.getFrameData(frameData);
    var ss = frameData.pose;
    
    var fovL = this.mHMD.getEyeParameters("left");
    var fovR = this.mHMD.getEyeParameters( "right" );

    // camera info
    var cPos = vec3(0.0, 0.0, 0.0);
    if (ss.position)
        cPos = vec3(-ss.position[0], -ss.position[1], -ss.position[2]);
    var rot = vec4(0.0, 0.0, 0.0, 0.0);
    if (ss.orientation)
        rot = vec4(ss.orientation[0], ss.orientation[1], ss.orientation[2], ss.orientation[3]);
    var cRot = setFromQuaternion(rot);
    var cTra = setTranslation(cPos);
    var cMat = matMul(invertFast(cRot), cTra);
    
    // per eye info
    var lTra = setTranslation( vec3(-fovL.offset[0], -fovL.offset[1], -fovL.offset[2]) );
    var lMat = matMul(lTra, cMat);
    var lPrj = [ Math.tan( fovL.fieldOfView.upDegrees * Math.PI/180.0),
                 Math.tan(fovL.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.rightDegrees * Math.PI / 180.0)];

    var rTra = setTranslation(vec3(-fovR.offset[0], -fovR.offset[1], -fovR.offset[2]));
    var rMat = matMul(rTra, cMat);
    var rPrj = [Math.tan(fovR.fieldOfView.upDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.rightDegrees * Math.PI / 180.0)];

    return {
        mCamera   : { mCamera: cMat },
        mLeftEye  : { mVP:[0,0,fovL.renderWidth,fovL.renderHeight], mProjection:lPrj, mCamera:lMat },
        mRightEye : { mVP:[fovR.renderWidth/2,0,fovR.renderWidth,fovR.renderHeight], mProjection:rPrj, mCamera:rMat }
           };
    */
}

WebVR.prototype.Enable = function( id )
{
    /*
    this.mHMD.requestPresent([{ source: this.mCanvas }]).then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : requestPresent failed.");
        }
    );
    */
}

WebVR.prototype.Disable = function( id )
{
    /*
    if (!this.mHMD.isPresenting)
    {
        return;
    }

    this.mHMD.exitPresent().then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : exitPresent failed.");
        }
    );
    */
}

WebVR.prototype.RequestAnimationFrame = function (id)
{
    //this.mHMD.requestAnimationFrame(id);
}

WebVR.prototype.IsPresenting = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        return true;
    }
    */
    return false;
}

WebVR.prototype.Finish = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        this.mHMD.submitFrame();
    }
    */
}

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebUtils
//
//==============================================================================


// RequestAnimationFrame
window.requestAnimFrame = ( function () { return window.requestAnimationFrame    || window.webkitRequestAnimationFrame ||
                                                 window.mozRequestAnimationFrame || window.oRequestAnimationFrame ||
                                                 window.msRequestAnimationFrame  || function( cb ) { window.setTimeout(cb,1000/60); };
                                        } )();

// performance.now
window.getRealTime = ( function() { if ("performance" in window ) return function() { return window.performance.now(); }
                                                                  return function() { return (new Date()).getTime(); }
                                  } )();

window.URL = window.URL || window.webkitURL;

navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;

function htmlEntities(str) 
{
    return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g,'&apos;');
}

function piDisableTouch()
{
    document.body.addEventListener('touchstart', function(e){ e.preventDefault(); });
}

var piGetTime = function ( timestamp )
{
    if (timestamp == 0)
        return "";
    return new Date(timestamp * 1000).toISOString().substr(0, 10);
}

function piGetCoords( obj )
{
    var x = 0;
    var y = 0; 
    do
    {
         x += obj.offsetLeft;
         y += obj.offsetTop;
    }while( obj = obj.offsetParent );

    return { mX:x, mY:y };
}

function piGetMouseCoords( ev, canvasElement )
{
    var pos = piGetCoords(canvasElement );
    var mcx =                        (ev.pageX - pos.mX) * canvasElement.width / canvasElement.offsetWidth;
    var mcy = canvasElement.height - (ev.pageY - pos.mY) * canvasElement.height / canvasElement.offsetHeight;

    return { mX: mcx, mY: mcy };

}

function piGetSourceElement( e )
{
    var ele = null;
    if( e.target )     ele = e.target;
    if( e.srcElement ) ele = e.srcElement;
    return ele;
}

function piRequestFullScreen( ele )
{
    if( ele==null ) ele =   document.documentElement;
         if( ele.requestFullscreen       ) ele.requestFullscreen();
    else if( ele.msRequestFullscreen     ) ele.msRequestFullscreen();
    else if( ele.mozRequestFullScreen    ) ele.mozRequestFullScreen();
    else if( ele.webkitRequestFullscreen ) ele.webkitRequestFullscreen( Element.ALLOW_KEYBOARD_INPUT );
}

function piIsFullScreen()
{
    return document.fullscreen || document.mozFullScreen || document.webkitIsFullScreen || document.msFullscreenElement || false;
}

function piExitFullScreen()
{
       if( document.exitFullscreen       ) document.exitFullscreen();
  else if( document.msExitFullscreen     ) document.msExitFullscreen();
  else if( document.mozCancelFullScreen  ) document.mozCancelFullScreen();
  else if( document.webkitExitFullscreen ) document.webkitExitFullscreen();
}

function piIsMobile()
{
    return (navigator.userAgent.match(/Android/i) ||
            navigator.userAgent.match(/webOS/i) ||
            navigator.userAgent.match(/iPhone/i) ||
            navigator.userAgent.match(/iPad/i) ||
            navigator.userAgent.match(/iPod/i) ||
            navigator.userAgent.match(/BlackBerry/i) ||
            navigator.userAgent.match(/Windows Phone/i)) ? true : false;
}

function piCreateGlContext( cv, useAlpha, useDepth, usePreserveBuffer, useSupersampling )
{
    var opts = { alpha: useAlpha, 
                 depth: useDepth, 
                 stencil: false, 
                 premultipliedAlpha: false, 
                 antialias: useSupersampling, 
                 preserveDrawingBuffer: usePreserveBuffer, 
                 powerPreference: "high-performance" }; // "low_power", "high_performance", "default"

    var gl = null;
    if( gl === null) gl = cv.getContext( "webgl2", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl2", opts );
    if( gl === null) gl = cv.getContext( "webgl", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl", opts );

    return gl;
}

function piCreateAudioContext()
{
    var res = null;
    try
    {
        if( window.AudioContext ) res = new AudioContext();
        if( res==null && window.webkitAudioContext ) res = new webkitAudioContext();
    }
    catch( e )
    {
        res = null;
    }
    return res;
}

function piHexColorToRGB(str) // "#ff3041"
{
    var rgb = parseInt(str.slice(1), 16);
    var r = (rgb >> 16) & 255;
    var g = (rgb >> 8) & 255;
    var b = (rgb >> 0) & 255;
    return [r, g, b];
}

function piCreateFPSCounter()
{
    var mFrame;
    var mTo;
    var mFPS;

    var iReset = function( time )
    {
        mFrame = 0;
        mTo = time;
        mFPS = 60.0;
    }

    var iCount = function( time )
    {
        mFrame++;

        if( (time-mTo)>500.0 )
        {
            mFPS = 1000.0*mFrame/(time-mTo);
            mFrame = 0;
            mTo = time;
            return true;
        }
        return false;
    }

    var iGetFPS = function()
    {
        return mFPS;
    }
    
    return { Reset : iReset, Count : iCount, GetFPS : iGetFPS };
}

function piCanMediaRecorded(canvas)
{
    if (typeof window.MediaRecorder !== 'function' || typeof canvas.captureStream !== 'function') {
        return false;
    }
    return true;
}

function piCreateMediaRecorder(isRecordingCallback, canvas) 
{
    if (piCanMediaRecorded(canvas) == false)
    {
        return null;
    }
    
    var options = { audioBitsPerSecond : 0, videoBitsPerSecond : 8000000 }; 
	     if (MediaRecorder.isTypeSupported('video/webm;codecs=h264')) options.mimeType = 'video/webm;codecs=h264';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9' )) options.mimeType = 'video/webm;codecs=vp9';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8' )) options.mimeType = 'video/webm;codecs=vp8';
    else                                                              options.mimeType = 'video/webm;';

    var mediaRecorder = new MediaRecorder(canvas.captureStream(), options);
    var chunks = [];
    
    mediaRecorder.ondataavailable = function(e) 
    {
        if (e.data.size > 0) 
        {
            chunks.push(e.data);
        }
    };
 
    mediaRecorder.onstart = function(){ 
        isRecordingCallback( true );
    };
    
    mediaRecorder.onstop = function()
    {
         isRecordingCallback( false );
         let blob     = new Blob(chunks, {type: "video/webm"});
         chunks       = [];
         let videoURL = window.URL.createObjectURL(blob);
         let url      = window.URL.createObjectURL(blob);
         let a        = document.createElement("a");
         document.body.appendChild(a);
         a.style      = "display: none";
         a.href       = url;
         a.download   = "capture.webm";
         a.click();
         window.URL.revokeObjectURL(url);
     };
    
    return mediaRecorder;
}

function piExportToEXR(width, height, numComponents, type, bytes)
{
    var bytesPerComponent = 0;
    if      (type=="Uint")   bytesPerComponent = 4; 
    else if (type=="Half")   bytesPerComponent = 2;
    else if (type=="Float")  bytesPerComponent = 4;

    var tHeader = 258 + (18 * numComponents + 1);
    var tTable = 8 * height;
    var tScanlines = height * (4 + 4 + (numComponents * bytesPerComponent * width));
    var tTotal = tHeader + tTable + tScanlines;

    //console.log("    header size = " + tHeader);
    //console.log("    table size = " + tTable);
    //console.log("    scanlines size = " + tScanlines);
    //console.log("    total = " + tTotal);

    var buffer = new ArrayBuffer(tTotal); 
    var data = new DataView(buffer);

    // Header
    {
        // Header : 4 bytes -> 0x76, 0x2f, 0x31, 0x01
        var c = 0;
        data.setUint8 (c++, 0x76);
        data.setUint8 (c++, 0x2f);
        data.setUint8 (c++, 0x31);
        data.setUint8 (c++, 0x01);

        // Version : 4 bytes -> 2, 0, 0, 0
        data.setUint8 (c++, 0x02);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        
        // Write channel info
        // Write attribute name : "channels"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x73);
            data.setUint8 (c++, 0x0);

            // Write attribute type : "chlist"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : 18 x 3 + 1 = 55
            var attribSize = 18 * numComponents + 1;
            data.setUint8 (c++, attribSize); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            var i;
            for (i = 0; i < numComponents; i++)
            {
                // Attribute : "B" (42) "G" (47) "R" (52)
                if (i==0)       data.setUint8 (c++, 0x42);
                else if (i==1)  data.setUint8 (c++, 0x47);
                else if (i==2)  data.setUint8 (c++, 0x52);
                data.setUint8 (c++, 0x00);
                
                // Value : Float (2), Half (1), Uint (0)
                if      (type=="Uint")   data.setUint8 (c++, 0x00); 
                else if (type=="Half")   data.setUint8 (c++, 0x01);
                else if (type=="Float")  data.setUint8 (c++, 0x02);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);

                // Plinear
                data.setUint8 (c++, 0x01);

                // Reserved
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 

                // X sampling
                data.setUint8 (c++, 0x01); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                
                // Y sampling
                data.setUint8 (c++, 0x01);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
            }
            // End attribute
            data.setUint8 (c++, 0x00);
    
        // Write attribute name : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute type : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : "1"
            data.setUint8 (c++, 0x01); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // Write attribute value : "0" (None)
            data.setUint8 (c++, 0x00);

        // datawindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00); 

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00);

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 

            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // displayWindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x79); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00);

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00); 

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // size
            data.setUint8 (c++, 0x01);
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);
            
            // value 
            data.setUint8 (c++, 0x00);

        // PixelAspectRatio
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x41); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x52); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x00); 

            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);
        
            // size 4
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 1.0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);
        
        // screenWindowCenter
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63);
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x43); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e);
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00);

            // v2f
            data.setUint8 (c++, 0x76); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x00);

            // size 8
            data.setUint8 (c++, 0x08); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

        // screenWindowWidth
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x00); 
            
            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00); 

            // size
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);

            // value
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);

        // End of header
        data.setUint8 (c++, 0x00);
    }
    //console.log("header size = " + c);

    // Scanline table
    var initc = c + height * 8;
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        var jump = initc + scanline * (8 + width * bytesPerComponent * numComponents); 
        data.setUint32 (c, jump, true);
        c += 4; 

        data.setUint32 (c, 0x00, true);
        c += 4;
    }
    //console.log("header + scanlines table size = " + c);

    // Scanlines
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        // Scanline
        data.setUint32(c, scanline, true);
        c += 4;

        // size 24
        var size = width * numComponents * bytesPerComponent; 
        data.setUint32(c, size, true);
        c += 4;

        var numComponentsSource = 4; // number of components in the SOURCE image
        for (var component = 0; component < numComponents ; component ++) 
        {
            for (var pixel = 0 ; pixel < width ; pixel ++) 
            {
                // flip vertical, so we read OpenGL buffers without JS image flipping
                var v = bytes[(height-1-scanline) * width *numComponentsSource + pixel * numComponentsSource + (2-component)];
                if      (type=="Float") data.setFloat32(c, v, true);
                else if (type=="Half")  data.setUint16(c, v, true);

                c += bytesPerComponent;
            }
        }
    }
    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}


function piExportToWAV(numSamples, rate, bits, numChannels, words)
{
    let numBytes = numSamples * numChannels * bits/8;

    let buffer = new ArrayBuffer(44 + numBytes); 
    let data = new DataView(buffer);

    {
        data.setUint32( 0, 0x46464952, true );  // RIFF
        data.setUint32( 4, numBytes + 36, true);
        {
            data.setUint32( 8, 0x45564157, true );  // WAV_WAVE
            data.setUint32( 12, 0x20746D66, true );  // WAV_FMT
            {
                data.setUint32( 16, 16, true);
                data.setUint16( 20, 1, true ); // WAV_FORMAT_PCM
                data.setUint16( 22, numChannels, true);
                data.setUint32( 24, rate, true);
                data.setUint32( 28, rate*numChannels*bits / 8, true);
                data.setUint16( 32, numChannels*bits / 8, true);
                data.setUint16( 34, bits, true);
            }

            data.setUint32( 36, 0x61746164, true);  // WAV_DATA
            {
                data.setUint32( 40, numBytes, true);
                let numWords = numSamples * numChannels;
                for(let i=0; i<numWords; i++ )
                {
                    data.setInt16( 44 + i*2, words[i], true );
                }
            }
        }
    }


    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}

function piTriggerDownload(name, blob)
{
    let url = URL.createObjectURL(blob);
    let aElement = document.createElement("a");
    aElement.href     = url;
    aElement.target   = "_self";
    aElement.download = name;
    document.body.appendChild(aElement);
    aElement.click();
    document.body.removeChild(aElement);
}</script>
    <script>"use strict"

function bufferID_to_assetID( id )
{
    if( id===0 ) return '4dXGR8';
    if( id===1 ) return 'XsXGR8';
    if( id===2 ) return '4sXGR8';
    if( id===3 ) return 'XdfGR8';
    return 'none';
}
function assetID_to_bufferID( id )
{
    if( id==='4dXGR8' ) return 0;
    if( id==='XsXGR8' ) return 1;
    if( id==='4sXGR8' ) return 2;
    if( id==='XdfGR8' ) return 3;
    return -1;
}

function assetID_to_cubemapBuferID( id )
{
    if( id==='4dX3Rr' ) return 0;
    return -1;
}
function cubamepBufferID_to_assetID( id )
{
    if( id===0 ) return '4dX3Rr';
    return 'none';
}

function EffectPass( renderer, is20, isLowEnd, hasShaderTextureLOD, callback, obj, forceMuted, forcePaused, outputGainNode, copyProgram, id, effect  )
{
    this.mID = id;
    this.mInputs  = [null, null, null, null ];
    this.mOutputs = [null, null, null, null ];
    this.mSource = null;

    this.mGainNode = outputGainNode;
    this.mSoundShaderCompiled = false;

    this.mEffect = effect;
    this.mRenderer = renderer;
    this.mProgramCopy = copyProgram; 
    this.mCompilationTime = 0;

    this.mType = "none";
    this.mName = "none";
    this.mFrame = 0;

    this.mShaderTextureLOD = hasShaderTextureLOD;
    this.mIs20 = is20;
    this.mIsLowEnd = isLowEnd;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mForceMuted = forceMuted;
    this.mForcePaused = forcePaused;
}

EffectPass.prototype.MakeHeader_Image = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        // old API
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                   header += "uniform sampler2D iChannel" + i + ";\n";

        // new API (see shadertoy.com/view/wtdGW8)
        header += "uniform struct {\n";
             if( inp===null )                  header += "  sampler2D";
        else if( inp.mInfo.mType==="cubemap" ) header += "  samplerCube";
        else if( inp.mInfo.mType==="volume"  ) header += "  sampler3D";
        else                                  header += "  sampler2D";
        header +=        " sampler;\n";
        header += "  vec3  size;\n";
        header += "  float time;\n";
        header += "  int   loaded;\n";
        header += "}iCh" + i + ";\n";
    }
	header += "void mainImage( out vec4 c, in vec2 f );\n";
    header += "void st_assert( bool cond );\n";
    header += "void st_assert( bool cond, int v );\n";

    if( this.mIs20 ) 
    {
        header += "\nout vec4 shadertoy_out_color;\n" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)shadertoy_out_color.x=-1.0;else if(v==1)shadertoy_out_color.y=-1.0;else if(v==2)shadertoy_out_color.z=-1.0;else shadertoy_out_color.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)shadertoy_out_color.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "shadertoy_out_color = vec4(1.0,1.0,1.0,1.0);" + 
            "vec4 color = vec4(1e20);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "if(shadertoy_out_color.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(shadertoy_out_color.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(shadertoy_out_color.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(shadertoy_out_color.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "shadertoy_out_color = vec4(color.xyz,1.0);" +
        "}";
    }
    else
    {
        header += "" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)gl_FragColor.x=-1.0;else if(v==1)gl_FragColor.y=-1.0;else if(v==2)gl_FragColor.z=-1.0;else gl_FragColor.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)gl_FragColor.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "gl_FragColor = vec4(0.0,0.0,0.0,1.0);" + 
            "vec4 color = vec4(1e20);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "color.w = 1.0;" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(gl_FragColor.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "gl_FragColor = vec4(color.xyz,1.0);"+
        "}";
    }
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 ) 
        this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "void main( void )" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );" +
        "color.w = 1.0;"
    if( this.mIs20 ) 
        this.mImagePassFooterVR +=  "outColor = color;}";
    else
        this.mImagePassFooterVR +=  "gl_FragColor = color;}";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Buffer = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                  header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainImage( out vec4 c,  in vec2 f );\n"

    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +
        "mainImage( color, gl_FragCoord.xy );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
    this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        this.mImagePassFooterVR +="outColor = color; }";
    else
        this.mImagePassFooterVR +="gl_FragColor = color; }";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Cubemap = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                   header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainCubemap( out vec4 c, in vec2 f, in vec3 ro, in vec3 rd );\n"

    header += "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainCubemap( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Sound = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform float     iChannelTime[4];\n" +
              "uniform float     iTimeOffset;\n" +
              "uniform int       iSampleOffset;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n";

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp!==null && inp.mInfo.mType==="cubemap" )
            header += "uniform samplerCube iChannel" + i + ";\n";
        else
            header += "uniform sampler2D iChannel" + i + ";\n";
    }
    header += "\n";
    header += "vec2 mainSound( in int samp, float time );\n";

    if( this.mIs20 )
    {
        header += "out vec4 outColor; void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "int   s = iSampleOffset + int(gl_FragCoord.y-0.2)*512 + int(gl_FragCoord.x-0.2);" +
            "vec2 y = mainSound( s, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "outColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    else
    {
        header += "void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "vec2 y = mainSound( 0, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "gl_FragColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    header += "\n";
    this.mHeader = header;
    this.mHeaderLength = 0;
}


EffectPass.prototype.MakeHeader_Common = function ()
{
    let header = "";
    let headerlength = 0;

    header += "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n";
    headerlength += 2;

    if (this.mIs20)
    {
        header += "out vec4 outColor;\n";
        headerlength += 1;
    }
    header += "void main( void )\n";
    headerlength += 1;

    if (this.mIs20)
        header += "{ outColor = vec4(0.0); }";
    else
        header += "{ gl_FragColor = vec4(0.0); }";
    headerlength += 1;
    header += "\n";
    headerlength += 1;

    this.mHeader = header;
    this.mHeaderLength = headerlength;
}

EffectPass.prototype.MakeHeader = function()
{
         if( this.mType==="image" ) this.MakeHeader_Image();
    else if( this.mType==="sound" ) this.MakeHeader_Sound();
    else if( this.mType==="buffer") this.MakeHeader_Buffer();
    else if( this.mType==="common") this.MakeHeader_Common();
    else if( this.mType==="cubemap") this.MakeHeader_Cubemap();
    else console.log("ERROR 4");
}

EffectPass.prototype.Create_Image = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}
EffectPass.prototype.Destroy_Image = function( wa )
{
}

EffectPass.prototype.Create_Buffer = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}

EffectPass.prototype.Destroy_Buffer = function( wa )
{
}

EffectPass.prototype.Create_Cubemap = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
}

EffectPass.prototype.Destroy_Cubemap = function( wa )
{
}

EffectPass.prototype.Create_Common = function( wa )
{
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.MakeHeader();
}
EffectPass.prototype.Destroy_Common = function( wa )
{
}

EffectPass.prototype.Create_Sound = function (wa)
{
    this.MakeHeader();

    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    this.mSampleRate = 44100;
    this.mPlayTime = 60*3;
    this.mPlaySamples = this.mPlayTime*this.mSampleRate;
    this.mBuffer = wa.createBuffer( 2, this.mPlaySamples, this.mSampleRate );

    //-------------------
    this.mTextureDimensions = 512;
    this.mRenderTexture = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D, 
                                                       this.mTextureDimensions, this.mTextureDimensions,
                                                       this.mRenderer.TEXFMT.C4I8,
                                                       this.mRenderer.FILTER.NONE,
                                                       this.mRenderer.TEXWRP.CLAMP, null);
    this.mRenderFBO = this.mRenderer.CreateRenderTarget(this.mRenderTexture, null, null, null, null, false);

    //-----------------------------

    // ArrayBufferView pixels;
    this.mTmpBufferSamples = this.mTextureDimensions*this.mTextureDimensions;
    this.mData = new Uint8Array( this.mTmpBufferSamples*4 );

    this.mPlaying = false;
}

EffectPass.prototype.Destroy_Sound = function( wa )
{
    if( this.mPlayNode!==null ) this.mPlayNode.stop();
    this.mPlayNode = null;
    this.mBuffer = null;
    this.mData = null;

    this.mRenderer.DestroyRenderTarget(this.mRenderFBO);
    this.mRenderer.DestroyTexture(this.mRenderTexture);
}

EffectPass.prototype.Create = function( passType, wa )
{
    this.mType = passType;
    this.mSource = null;

         if( passType==="image" ) this.Create_Image( wa );
    else if( passType==="sound" ) this.Create_Sound( wa );
    else if( passType==="buffer") this.Create_Buffer( wa );
    else if( passType==="common") this.Create_Common( wa );
    else if( passType==="cubemap") this.Create_Cubemap( wa );
    else alert("ERROR 1");
}

EffectPass.prototype.SetName = function (passName)
{
    this.mName = passName;
}

EffectPass.prototype.SetCode = function (src)
{
    this.mSource = src;
}

EffectPass.prototype.Destroy = function( wa )
{
    this.mSource = null;
         if( this.mType==="image" ) this.Destroy_Image( wa );
    else if( this.mType==="sound" ) this.Destroy_Sound( wa );
    else if( this.mType==="buffer") this.Destroy_Buffer( wa );
    else if( this.mType==="common") this.Destroy_Common( wa );
    else if( this.mType==="cubemap") this.Destroy_Cubemap( wa );
    else alert("ERROR 2");
}

EffectPass.prototype.NewShader_Sound = function( shaderCode, commonShaderCodes)
{
    let vsSource = null;

    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for( let i=0; i<commonShaderCodes.length; i++ )
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    this.mSoundShaderCompiled = false;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader_Image = function ( shaderCode, commonShaderCodes )
{
    this.mSupportsVR = false;

    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    return [vsSource, fsSource];


    /*
    let n1 = shaderCode.indexOf("mainVR(");
    let n2 = shaderCode.indexOf("mainVR (");
    let n3 = shaderCode.indexOf("mainVR  (");
    if( n1>0 || n2>0 || n3>0 )
    {
        let vsSourceVR;
        if( this.mIs20 )
            vsSourceVR = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        else
            vsSourceVR = "attribute in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

        let fsSourceVR = this.mHeader;
        for (let i = 0; i < commonShaderCodes.length; i++) {
            fsSourceVR += commonShaderCodes[i];
        }
        fsSourceVR += shaderCode;
        fsSourceVR += this.mImagePassFooterVR;

        let res = this.mRenderer.CreateShader(vsSource, fsSourceVR, preventCache);
        if( res.mResult == false )
        {
            return res.mInfo;
        }
        if( this.mProgramVR != null )
            this.mRenderer.DestroyShader( this.mProgramVR );

        this.mSupportsVR = true;
        this.mProgramVR = res;
    }
    */
}

EffectPass.prototype.NewShader_Cubemap = function( shaderCode, commonShaderCodes )
{
    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }

    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;

    fsSource += shaderCode;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader_Common = function (shaderCode )
{
    let vsSource = null;
    if (this.mIs20)
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader + shaderCode;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader = function ( commonSourceCodes, preventCache, onResolve)
{
    if( this.mRenderer===null ) return;

    let vs_fs = null;

         if( this.mType==="sound"  ) vs_fs = this.NewShader_Sound(   this.mSource, commonSourceCodes );
    else if( this.mType==="image"  ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="buffer" ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="common" ) vs_fs = this.NewShader_Common(  this.mSource,                   );
    else if( this.mType==="cubemap") vs_fs = this.NewShader_Cubemap( this.mSource, commonSourceCodes );
    else { console.log("ERROR 3: \"" + this.mType + "\""); return; }

    let me = this;
    this.mRenderer.CreateShader(vs_fs[0], vs_fs[1], preventCache, false,
        function (worked, info)
        {
            if (worked === true)
            {
                if (me.mType === "sound")
                {
                    me.mSoundShaderCompiled = true;
                }

                me.mCompilationTime = info.mTime;
                me.mError = false;
                me.mErrorStr = "No Errors";
                if (me.mProgram !== null)
                    me.mRenderer.DestroyShader(me.mProgram);
                me.mTranslatedSource = me.mRenderer.GetTranslatedShaderSource(info);
                me.mProgram = info;
            }
            else
            {
                me.mError = true;
                me.mErrorStr = info.mErrorStr;
            }
            onResolve();
        });
}

EffectPass.prototype.DestroyInput = function( id )
{
    if( this.mInputs[id]===null ) return;

    if( this.mInputs[id].mInfo.mType==="texture" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    if( this.mInputs[id].mInfo.mType==="volume" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="webcam" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video.src = "";

        if( this.mInputs[id].video.srcObject!==null )
        {
        let tracks = this.mInputs[id].video.srcObject.getVideoTracks();
        if( tracks ) tracks[0].stop();
        }
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="video" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="music" || this.mInputs[id].mInfo.mType==="musicstream")
    {
        this.mInputs[id].audio.pause();
        this.mInputs[id].audio.mSound.mFreqData = null;
        this.mInputs[id].audio.mSound.mWaveData = null;
        this.mInputs[id].audio = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="cubemap" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="keyboard" )
    {
        //if( this.mInputs[id].globject != null )
          //  this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="mic" )
    {
        this.mInputs[id].mic = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }

    this.mInputs[id] = null;
}

EffectPass.prototype.TooglePauseInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        else
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.audio.mPaused )
        {
            if( inp.loaded )
            {
                inp.audio.play();
            }
            inp.audio.mPaused = false;
        }
        else
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }

    return null;
}

EffectPass.prototype.StopInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused === false )
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused === false )
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.ResumeInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused )
        {
            inp.audio.play();
            inp.audio.mPaused = false;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.RewindInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp==null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.loaded )
        {
            inp.video.currentTime = 0;
        }
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.loaded )
        {
            inp.audio.currentTime = 0;
        }
    }
}

EffectPass.prototype.MuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = true;
        inp.video.mMuted = true;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 0.0;
        inp.audio.mMuted = true;
    }
}

EffectPass.prototype.UnMuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = false;
        inp.video.mMuted = false;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 1.0;
        inp.audio.mMuted = false;
    }
}

EffectPass.prototype.ToggleMuteInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];
    if( inp===null ) return null;

    if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.video.mMuted;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if( inp.audio.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.audio.mMuted;
    }

    return null;
}

EffectPass.prototype.UpdateInputs = function( wa, forceUpdate, keyboard )
{
   for (let i=0; i<this.mInputs.length; i++ )
   {
        let inp = this.mInputs[i];

        if( inp===null )
        {
            if( forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, null, false, 0, 0, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.image, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mPreview, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if( inp.loaded && forceUpdate )
            {
                if( this.mTextureCallbackFun!==null )
                {
                    let img = (assetID_to_cubemapBuferID(inp.mInfo.mID)===-1) ? inp.image[0] : inp.mImage;
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, img, true, 2, 1, -1.0, this.mID );
                }
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:keyboard.mIcon,mData:keyboard.mData}, false, 6, 0, -1.0, this.mID );
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, -1, this.mID );
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
              if( inp.loaded && inp.audio.mPaused === false && inp.audio.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                      inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                  }

                  if (this.mTextureCallbackFun!==null)
                  {
                           if (inp.mInfo.mType === "music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData}, false, 4, 1, inp.audio.currentTime, this.mID);
                      else if (inp.mInfo.mType === "musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData, info: inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                  }
              }
              else if( inp.loaded===false )
              {
                  if (this.mTextureCallbackFun!==null)
                      this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:null}, false, 4, 0, -1.0, this.mID);
              }
        }
        else if( inp.mInfo.mType==="mic" )
        {
              if( inp.loaded && inp.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                      inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
                  }
                  if( this.mTextureCallbackFun!==null )
                      this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave: ((wa==null)?null:inp.mFreqData) }, false, 5, 1, 0, this.mID );
              }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:null}, true, 9, 1, -1.0, this.mID );
            }
        }
    }
}

EffectPass.prototype.Sampler2Renderer = function (sampler)
{
    let filter = this.mRenderer.FILTER.NONE;
    if (sampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
    if (sampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
    let wrap = this.mRenderer.TEXWRP.REPEAT;
    if (sampler.wrap === "clamp") wrap = this.mRenderer.TEXWRP.CLAMP;
    let vflip = false;
    if (sampler.vflip === "true") vflip = true;

    return { mFilter: filter, mWrap: wrap, mVFlip: vflip };
}

EffectPass.prototype.GetSamplerVFlip = function (id)
{
    let inp = this.mInputs[id];
    return inp.mInfo.mSampler.vflip;
}

EffectPass.prototype.GetTranslatedShaderSource = function ()
{
    return this.mTranslatedSource;
}

EffectPass.prototype.SetSamplerVFlip = function (id, str) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = false;
    if (str === "true") filter = true;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, null);
            inp.mInfo.mSampler.vflip = str;
        }
    }
}

EffectPass.prototype.GetAcceptsVFlip = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return false;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return false;
    return true;
}

EffectPass.prototype.GetSamplerFilter = function (id)
{
    let inp = this.mInputs[id];
    if( inp===null) return;
    return inp.mInfo.mSampler.filter;
}

EffectPass.prototype.SetSamplerFilter = function (id, str, buffers, cubeBuffers) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = renderer.FILTER.NONE;
    if (str === "linear") filter = renderer.FILTER.LINEAR;
    if (str === "mipmap") filter = renderer.FILTER.MIPMAP;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0)
            {
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[0], filter, true);
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[1], filter, true);
                inp.mInfo.mSampler.filter = str;
            }
            else
            {
                renderer.SetSamplerFilter(inp.globject, filter, true);
                inp.mInfo.mSampler.filter = str;
            }
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[0], filter, true);
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[1], filter, true);
        inp.mInfo.mSampler.filter = str;
    }
    else if (inp.mInfo.mType === "keyboard")
    {
        inp.mInfo.mSampler.filter = str;
    }
}

EffectPass.prototype.GetAcceptsMipmapping = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetAcceptsLinear = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return true;
    if (inp.mInfo.mType === "musicstream") return true;
    if (inp.mInfo.mType === "mic")  return true;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return true;
    return false;
}

EffectPass.prototype.GetAcceptsWrapRepeat = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return false;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetSamplerWrap = function (id)
{
    return this.mInputs[id].mInfo.mSampler.wrap;
}

EffectPass.prototype.SetSamplerWrap = function (id, str, buffers)
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let restr = renderer.TEXWRP.REPEAT;
    if (str === "clamp") restr = renderer.TEXWRP.CLAMP;

    if (inp === null) 
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "video") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap") 
    {
        if (inp.loaded)
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "webcam") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[0], restr);
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[1], restr);
        inp.mInfo.mSampler.wrap = str;
    }
}


EffectPass.prototype.GetTexture = function( slot )
{
    let inp = this.mInputs[slot];
    if( inp===null ) return null;
    return inp.mInfo;
}

EffectPass.prototype.SetOutputs = function( slot, id )
{
    this.mOutputs[slot] = id;
}

EffectPass.prototype.SetOutputsByBufferID = function( slot, id )
{
    if( this.mType==="buffer" )
    {
        this.mOutputs[slot] = bufferID_to_assetID( id );

        this.mEffect.ResizeBuffer( id, this.mEffect.mXres, this.mEffect.mYres, false );
    }
    else if( this.mType==="cubemap" )
    {
        this.mOutputs[slot] = cubamepBufferID_to_assetID( id );
        this.mEffect.ResizeCubemapBuffer(id, 1024, 1024 );
    }
}

EffectPass.prototype.NewTexture = function( wa, slot, url, buffers, cubeBuffers, keyboard )
{
    var me = this;
    var renderer = this.mRenderer;

    if( renderer===null ) return;

    let texture = null;

    if( url===null || url.mType===null )
    {
        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( this.mTextureCallbackObj, slot, null, true, 0, 0, -1.0, me.mID );
        me.DestroyInput( slot );
        me.mInputs[slot] = null;
        me.MakeHeader();
        return { mFailed:false, mNeedsShaderCompile:false };
    }
    else if( url.mType==="texture" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.image = new Image();
        texture.image.crossOrigin = '';
        texture.image.onload = function()
        {
            let rti = me.Sampler2Renderer(url.mSampler);

            // O.M.G. FIX THIS
            let channels = renderer.TEXFMT.C4I8;
            if (url.mID === "Xdf3zn" || url.mID === "4sf3Rn" || url.mID === "4dXGzn" || url.mID === "4sf3Rr")
                channels = renderer.TEXFMT.C1I8;
            
            texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.image, channels, rti.mFilter, rti.mWrap, rti.mVFlip);

            texture.loaded = true;
            if( me.mTextureCallbackFun!==null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.image, true, 1, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="volume" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mImage = { mData:null, mXres:1, mYres:0, mZres:0 };
        texture.mPreview = new Image();
        texture.mPreview.crossOrigin = '';

	    var xmlHttp = new XMLHttpRequest();
        if( xmlHttp===null ) return { mFailed:true };

        xmlHttp.open('GET', url.mSrc, true);
        xmlHttp.responseType = "arraybuffer";
        xmlHttp.onerror = function()
        {
            console.log( "Error 1 loading Volume" );
        }
        xmlHttp.onload = function()
        {
            let data = xmlHttp.response;
            if (!data ) { console.log( "Error 2 loading Volume" ); return; }

            let file = piFile(data);

            let signature = file.ReadUInt32();
            texture.mImage.mXres = file.ReadUInt32();
            texture.mImage.mYres = file.ReadUInt32();
            texture.mImage.mZres = file.ReadUInt32();
            let binNumChannels = file.ReadUInt8();
            let binLayout = file.ReadUInt8();
            let binFormat = file.ReadUInt16();
            let format = renderer.TEXFMT.C1I8;
                 if( binNumChannels===1 && binFormat===0 )  format = renderer.TEXFMT.C1I8;
            else if( binNumChannels===2 && binFormat===0 )  format = renderer.TEXFMT.C2I8;
            else if( binNumChannels===3 && binFormat===0 )  format = renderer.TEXFMT.C3I8;
            else if( binNumChannels===4 && binFormat===0 )  format = renderer.TEXFMT.C4I8;
            else if( binNumChannels===1 && binFormat===10 ) format = renderer.TEXFMT.C1F32;
            else if( binNumChannels===2 && binFormat===10 ) format = renderer.TEXFMT.C2F32;
            else if( binNumChannels===3 && binFormat===10 ) format = renderer.TEXFMT.C3F32;
            else if( binNumChannels===4 && binFormat===10 ) format = renderer.TEXFMT.C4F32;
            else return;

            let buffer = new Uint8Array(data, 20); // skip 16 bytes (header of .bin)

            let rti = me.Sampler2Renderer(url.mSampler);

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T3D, texture.mImage.mXres, texture.mImage.mYres, format, rti.mFilter, rti.mWrap, buffer);

            if( texture.globject===null )
            {
                console.log( "Error 4: loading Volume" ); 
                return { mFailed:true };
            }

            if (me.mTextureCallbackFun !== null)
            {
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }

            texture.loaded = true;

            // load icon for it
            texture.mPreview.onload = function()
            {
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }
            texture.mPreview.src = url.mPreviewSrc;
        }
        xmlHttp.send("");


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="volume")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="cubemap" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        let rti = me.Sampler2Renderer(url.mSampler);

        if( assetID_to_cubemapBuferID(url.mID)!==-1 )
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 2, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/cubemap00.png";

            this.mEffect.ResizeCubemapBuffer(0, 1024, 1024 );

        }
        else
        {
            texture.image = [ new Image(), new Image(), new Image(), new Image(), new Image(), new Image() ];

            let numLoaded = 0;
            for (var i=0; i<6; i++ )
            {
                texture.image[i].mId = i;
                texture.image[i].crossOrigin = '';
                texture.image[i].onload = function()
                {
                    var id = this.mId;
                    numLoaded++;
                    if( numLoaded===6 )
                    {
                        texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.CUBEMAP, texture.image, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                        texture.loaded = true;
                        if (me.mTextureCallbackFun !== null)
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, texture.image[0], true, 2, 1, -1.0, me.mID);
                    }
                }

                if( i === 0) 
                {
                    texture.image[i].src = url.mSrc;
                } 
                else 
                {
                    let n = url.mSrc.lastIndexOf(".");
                    texture.image[i].src = url.mSrc.substring(0, n) + "_" + i + url.mSrc.substring(n, url.mSrc.length);
                }
            }
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="cubemap")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="webcam" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        texture.video = document.createElement('video');
    	texture.video.width = 320;
    	texture.video.height = 240;
    	texture.video.autoplay = true;
    	texture.video.loop = true;
        texture.mForceMuted = this.mForceMuted;
        texture.mImage = null;

        let rti = me.Sampler2Renderer(url.mSampler);

        var loadImageInsteadOfWebCam = function()
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.mImage, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 7, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/webcam.png";
        }
        
        loadImageInsteadOfWebCam();

        if( typeof navigator.getUserMedia !== "undefined"  && texture.mForceMuted===false )
        {
            texture.video.addEventListener("canplay", function (e)
            {
				try
				{
                    texture.mImage = null;
                    if( texture.globject != null )
                        renderer.DestroyTexture( texture.globject );
					texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
					texture.loaded = true;
                }
                catch(e)
                {
                    loadImageInsteadOfWebCam();
	                alert( 'Your browser can not transfer webcam data to the GPU.');
                }
            } );

            navigator.mediaDevices.getUserMedia( 
                                { "video": { width: 1280, height: 720 }, "audio": false } )
                                .then( function(stream)
                                       {
                                            texture.video.srcObject = stream;
    	                               } )
                                .catch( function(error)
                                        {
                                            loadImageInsteadOfWebCam();
    		                                alert( 'Unable to capture WebCam. Please reload the page.' );
    	                                } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="mic" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mForceMuted = this.mForceMuted;
        texture.mAnalyser = null;
        let num = 512;
        texture.mFreqData = new Uint8Array( num );
        texture.mWaveData = new Uint8Array( num );

        if( wa === null || typeof navigator.getUserMedia === "undefined" )
        {
            if( !texture.mForceMuted ) alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.mForceMuted = true; 
        }

        if( texture.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, num, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)
            texture.loaded = true;
        }
        else
        {
        navigator.getUserMedia( { "audio": true },
                                function(stream)
                                {
                                  texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, null)
                                  texture.mic = wa.createMediaStreamSource(stream);
                                  texture.mAnalyser = wa.createAnalyser();
                                  texture.mic.connect( texture.mAnalyser );
                                  texture.loaded = true;
    	                        },
                                function(error)
                                {
    		                        alert( 'Unable open Mic. Please reload the page.' );
    	                        } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="video" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.video = document.createElement('video');
    	texture.video.loop = true;
        texture.video.preload = "auto";
        texture.video.mPaused = this.mForcePaused;
        texture.video.mMuted = true;//this.mForceMuted;
    	texture.video.muted  = true;//this.mForceMuted;
        if( this.mForceMuted===true )
            texture.video.volume = 0;
    	texture.video.autoplay = false;
        texture.video.hasFalled = false;
        
        let rti = me.Sampler2Renderer(url.mSampler);

        texture.video.addEventListener("canplay", function (e)
        {
            texture.video.play().then( function()
                                       {
                                           texture.video.mPaused = false;

                                           texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                                           texture.loaded = true;
            
                                           if( me.mTextureCallbackFun!=null )
                                               me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.video, true, 3, 1, -1.0, me.mID );
                                        } )
                               .catch( function(error)
                                       {
                                           console.log( error );
                                       }
                                );
        } );

        texture.video.addEventListener( "error", function(e)
        {
               if( texture.video.hasFalled===true ) { alert("Error: cannot load video" ); return; }
               let str = texture.video.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".mp4";
               texture.video.src = str;
               texture.video.hasFalled = true;
        } );

        texture.video.src = url.mSrc;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="music" || url.mType==="musicstream" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.audio = document.createElement('audio');
    	texture.audio.loop = true;
        texture.audio.mMuted = this.mForceMuted;
        texture.audio.mForceMuted = this.mForceMuted;
        texture.audio.muted = this.mForceMuted;
        if( this.mForceMuted===true )
            texture.audio.volume = 0;
        texture.audio.autoplay = false;
        texture.audio.hasFalled = false;
        texture.audio.mPaused = false;
        texture.audio.mSound = {};

        if( this.mForceMuted===false )
        {
            if(url.mType==="musicstream" && SC === null)
            {
                alert( "Shadertoy: Soundcloud could not be reached" );
                texture.audio.mForceMuted = true;
            }
            }

        if( wa === null && this.mForceMuted===false )
        {
            alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.audio.mForceMuted = true;
        }

        if( texture.audio.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null);
            let num = 512;
            texture.audio.mSound.mFreqData = new Uint8Array( num );
            texture.audio.mSound.mWaveData = new Uint8Array( num );
            texture.loaded = true;
        }

        texture.audio.addEventListener( "canplay", function()
        {
            if( texture===null || texture.audio===null ) return;
            if( this.mForceMuted  ) return;
            if( texture.loaded === true ) return;

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)

            texture.audio.mSound.mSource   = wa.createMediaElementSource( texture.audio );
            texture.audio.mSound.mAnalyser = wa.createAnalyser();
            texture.audio.mSound.mGain     = wa.createGain();

            texture.audio.mSound.mSource.connect(   texture.audio.mSound.mAnalyser );
            texture.audio.mSound.mAnalyser.connect( texture.audio.mSound.mGain );
            texture.audio.mSound.mGain.connect(me.mGainNode);

            texture.audio.mSound.mFreqData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );
            texture.audio.mSound.mWaveData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );

            if( texture.audio.mPaused )
            {
                texture.audio.pause();
            }
            else
            {
                texture.audio.play().then( function() {} ).catch( function(e){console.log("error " + e);} );
            }
            texture.loaded = true;
        } );

        texture.audio.addEventListener( "error", function(e)
        {
               if( this.mForceMuted  ) return;

               if( texture.audio.hasFalled===true ) { return; }
               let str = texture.audio.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".ogg";
               texture.audio.src = str;
               texture.audio.hasFalled = true;
        } );

        if( !texture.audio.mForceMuted )
        {
            if(url.mType==="musicstream")
            {
                SC.resolve(url.mSrc, 
                    function(song) 
                    {
                        if( song.streamable===true )
                        {
                            texture.audio.crossOrigin = 'anonymous';
                            texture.audio.src = song.stream_url;
                            texture.audio.soundcloudInfo = song;
                        }
                        else
                        {
                            alert('Shadertoy: Soundcloud 3 - This track cannot be streamed' );
                        }
                    },
                    function(error)
                    {
                        if (me.mTextureCallbackFun!==null)
                        {
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
                        }
                    } );
            } 
            else
            {
                texture.audio.src = url.mSrc;
            }
        }

        if (me.mTextureCallbackFun!==null)
        {
            if (url.mType === "music")            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
            else if (url.mType === "musicstream") me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null, info: texture.audio.soundcloudInfo}, false, 8, 0, -1.0, me.mID);
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="keyboard" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = true;

        texture.keyboard = {};

        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {mImage: keyboard.mIcon, mData: keyboard.mData}, false, 6, 1, -1.0, me.mID );

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="buffer" )
    {
        texture = {};
        texture.mInfo = url;

        texture.image = new Image();
        texture.image.onload = function()
        {
            if( me.mTextureCallbackFun!==null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {texture: texture.image, data:null}, true, 9, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;
        texture.id = assetID_to_bufferID( url.mID );
        texture.loaded = true;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;

        this.mEffect.ResizeBuffer(texture.id, this.mEffect.mXres, this.mEffect.mYres, false );

        this.SetSamplerFilter(slot, url.mSampler.filter, buffers, cubeBuffers, true);
        this.SetSamplerVFlip(slot, url.mSampler.vflip);
        this.SetSamplerWrap(slot, url.mSampler.wrap, buffers);

        this.MakeHeader();
        return returnValue;
    }
    else
    {
        alert( "input type error" );
        return { mFailed: true };
    }

    return { mFailed: true };
}

EffectPass.prototype.Paint_Image = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];

    //------------------------
    
    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];
    let texIsLoaded = [0, 0, 0, 0 ];
    let texID = [ null, null, null, null];

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
            texIsLoaded[i] = 1;
            resos[3*i+0] = 256;
            resos[3*i+1] = 3;
            resos[3*i+2] = 1;
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;

                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                }
            }
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {

                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                texIsLoaded[i] = 0;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    times[i] = 10.0 + time;
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            let id = inp.id;
            if( inp.loaded===true  )
            {
                texID[i] = buffers[id].mTexture[ buffers[id].mLastRenderDone ];
                texIsLoaded[i] = 1;
                resos[3*i+0] = xres;
                resos[3*i+1] = yres;
                resos[3*i+2] = 1;
                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID[i], filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    let prog = this.mProgram;

    //if( vrData!=null && this.mSupportsVR ) prog = this.mProgramVR;

    this.mRenderer.AttachShader(prog);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F("iFrameRate", fps);

    this.mRenderer.SetShaderConstant1F(  "iCh0.time", times[0] );
    this.mRenderer.SetShaderConstant1F(  "iCh1.time", times[1] );
    this.mRenderer.SetShaderConstant1F(  "iCh2.time", times[2] );
    this.mRenderer.SetShaderConstant1F(  "iCh3.time", times[3] );
    this.mRenderer.SetShaderConstant3F(  "iCh0.size", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iCh1.size", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iCh2.size", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iCh3.size", resos[9], resos[10], resos[11] );
    this.mRenderer.SetShaderConstant1I(  "iCh0.loaded", texIsLoaded[0] );
    this.mRenderer.SetShaderConstant1I(  "iCh1.loaded", texIsLoaded[1] );
    this.mRenderer.SetShaderConstant1I(  "iCh2.loaded", texIsLoaded[2] );
    this.mRenderer.SetShaderConstant1I(  "iCh3.loaded", texIsLoaded[3] );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    if( (vrData !== null) && this.mSupportsVR )
    {
        for (let i=0; i<2; i++ )
        {
            let ei = (i===0) ? vrData.mLeftEye : vrData.mRightEye;

            let vp = [i * xres / 2, 0, xres / 2, yres];

            this.mRenderer.SetViewport(vp);

            let fov = ei.mProjection;
            let corA = [ -fov[2], -fov[1], -1.0 ];
            let corB = [  fov[3], -fov[1], -1.0 ];
            let corC = [  fov[3],  fov[0], -1.0 ];
            let corD = [ -fov[2],  fov[0], -1.0 ];
            let apex = [ 0.0, 0.0, 0.0 ];

            let ma = invertFast( ei.mCamera );
            corA = matMulpoint( ma, corA ); 
            corB = matMulpoint( ma, corB ); 
            corC = matMulpoint( ma, corC ); 
            corD = matMulpoint( ma, corD ); 
            apex = matMulpoint( ma, apex ); 

            let corners = [ corA[0], corA[1], corA[2], 
                            corB[0], corB[1], corB[2], 
                            corC[0], corC[1], corC[2], 
                            corD[0], corD[1], corD[2],
                            apex[0], apex[1], apex[2]];

            this.mRenderer.SetShaderConstant3FV("unCorners", corners);
            this.mRenderer.SetShaderConstant4FV("unViewport", vp);

            this.mRenderer.DrawUnitQuad_XY(l1);
        }
    }
    else 
    {
        this.mRenderer.SetViewport([0, 0, xres, yres]);
        this.mRenderer.DrawFullScreenTriangle_XY( l1 );
    }

    this.mRenderer.DettachTextures();
}

EffectPass.prototype.iRenderSound = function(d, callback )
{
    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds() ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    this.mRenderer.SetRenderTarget(this.mRenderFBO);

    this.mRenderer.SetViewport([0, 0, this.mTextureDimensions, this.mTextureDimensions]);
    this.mRenderer.AttachShader(this.mProgram);
    this.mRenderer.SetBlend( false );

    let texID = [null, null, null, null];
    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
    }

    this.mRenderer.AttachTextures(4, texID[0], texID[1], texID[2], texID[3]);

    let l2 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iTimeOffset");
    let l3 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iSampleOffset");
    this.mRenderer.SetShaderConstant4FV("iDate", dates);
    this.mRenderer.SetShaderConstant3FV("iChannelResolution", resos);
    this.mRenderer.SetShaderConstant1F("iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit("iChannel0", 0);
    this.mRenderer.SetShaderTextureUnit("iChannel1", 1);
    this.mRenderer.SetShaderTextureUnit("iChannel2", 2);
    this.mRenderer.SetShaderTextureUnit("iChannel3", 3);

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    //--------------------------------
    let numSamples = this.mTmpBufferSamples;
    let numBlocks = this.mPlaySamples / numSamples;
    for (let j=0; j<numBlocks; j++ )
    {
        let off = j*numSamples;
        
        this.mRenderer.SetShaderConstant1F_Pos(l2, off / this.mSampleRate);
        this.mRenderer.SetShaderConstant1I_Pos(l3, off );
        this.mRenderer.DrawUnitQuad_XY(l1);

        this.mRenderer.GetPixelData(this.mData, 0, this.mTextureDimensions, this.mTextureDimensions);

        callback( off, this.mData, numSamples );
    }

    this.mRenderer.DetachShader();
    this.mRenderer.DettachTextures();
    this.mRenderer.SetRenderTarget(null);
}

EffectPass.prototype.Paint_Sound = function( wa, d )
{
    let bufL = this.mBuffer.getChannelData(0); // Float32Array
    let bufR = this.mBuffer.getChannelData(1); // Float32Array

    this.iRenderSound( d, function(off, data, numSamples)
                         {
                            for( let i=0; i<numSamples; i++ )
                            {
                                bufL[off+i] = -1.0 + 2.0*(data[4*i+0]+256.0*data[4*i+1])/65535.0;
                                bufR[off+i] = -1.0 + 2.0*(data[4*i+2]+256.0*data[4*i+3])/65535.0;
                            }
                         }
                     );
}

EffectPass.prototype.SetUniforms = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    //------------------------
    
    let texID = [ null, null, null, null];

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
        }
        else if( inp.mInfo.mType=="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
    
                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                }
            }

        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
           if( inp.loaded===true )
           { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                times[i] = 10.0 + time;
            }

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = buffers[inp.id].mTexture[ buffers[inp.id].mLastRenderDone ];
                resos[3*i+0] = buffers[inp.id].mResolution[0];
                resos[3*i+1] = buffers[inp.id].mResolution[1];
                resos[3*i+2] = 1;
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    this.mRenderer.AttachShader(this.mProgram);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F(  "iFrameRate", fps );

    this.mRenderer.SetShaderConstant1F(  "iChannel[0].time",       times[0] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[1].time",       times[1] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[2].time",       times[2] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[3].time",       times[3] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[0].resolution", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[1].resolution", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[2].resolution", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[3].resolution", resos[9], resos[10], resos[11] );
}

EffectPass.prototype.ProcessInputs = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
        }
        else if( inp.mInfo.mType==="volume" )
        {
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );
                }
                else if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                if( inp.audio.mForceMuted === true )
                {
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                let id = inp.id;
                let texID = buffers[id].mTexture[ buffers[id].mLastRenderDone ];

                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID, filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
				let id = inp.id;
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }
}

EffectPass.prototype.Paint_Cubemap = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face )
{
    this.ProcessInputs(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
    this.SetUniforms(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    let vp = [0, 0, xres, yres];

    this.mRenderer.SetViewport(vp);

    let corA = [-1.0, -1.0, -1.0];
    let corB = [ 1.0, -1.0, -1.0];
    let corC = [ 1.0,  1.0, -1.0];
    let corD = [-1.0,  1.0, -1.0];
    let apex = [ 0.0,  0.0,  0.0];

         if( face===0 ) { corA=[ 1.0,  1.0,  1.0]; corB=[ 1.0,  1.0, -1.0]; corC=[ 1.0, -1.0, -1.0]; corD=[ 1.0, -1.0,  1.0]; }
    else if( face===1 ) { corA=[-1.0,  1.0, -1.0]; corB=[-1.0,  1.0,  1.0]; corC=[-1.0, -1.0,  1.0]; corD=[-1.0, -1.0, -1.0]; }
    else if( face===2 ) { corA=[-1.0,  1.0, -1.0]; corB=[ 1.0,  1.0, -1.0]; corC=[ 1.0,  1.0,  1.0]; corD=[-1.0,  1.0,  1.0]; }
    else if( face===3 ) { corA=[-1.0, -1.0,  1.0]; corB=[ 1.0, -1.0,  1.0]; corC=[ 1.0, -1.0, -1.0]; corD=[-1.0, -1.0, -1.0]; }
    else if( face===4 ) { corA=[-1.0,  1.0,  1.0]; corB=[ 1.0,  1.0,  1.0]; corC=[ 1.0, -1.0,  1.0]; corD=[-1.0, -1.0,  1.0]; }
    else if( face===5 ) { corA=[ 1.0,  1.0, -1.0]; corB=[-1.0,  1.0, -1.0]; corC=[-1.0, -1.0, -1.0]; corD=[ 1.0, -1.0, -1.0]; }

    let corners = [ corA[0], corA[1], corA[2], 
                    corB[0], corB[1], corB[2], 
                    corC[0], corC[1], corC[2], 
                    corD[0], corD[1], corD[2],
                    apex[0], apex[1], apex[2]];

    this.mRenderer.SetShaderConstant3FV("unCorners", corners);
    this.mRenderer.SetShaderConstant4FV("unViewport", vp);

    this.mRenderer.DrawUnitQuad_XY(l1);

    this.mRenderer.DettachTextures();
}

EffectPass.prototype.Paint = function( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, bufferNeedsMimaps, buffers, cubeBuffers, keyboard, effect )
{
    if( this.mType==="sound" )
    {
        if (this.mSoundShaderCompiled === true)
        {
            // make sure all textures are loaded
            for (let i=0; i<this.mInputs.length; i++ )
            {
                let inp = this.mInputs[i];
                if (inp === null) continue;

                if (inp.mInfo.mType === "texture" && !inp.loaded) return;
                if (inp.mInfo.mType === "cubemap" && !inp.loaded) return;
            }

            this.Paint_Sound(wa, da);
            this.mSoundShaderCompiled = false;
        }
        if (this.mFrame === 0)
        {
            if (this.mPlaying===true)
            {
                this.mPlayNode.disconnect();
                this.mPlayNode.stop();
                this.mPlayNode = null;
            }
            this.mPlaying = true;

            this.mPlayNode = wa.createBufferSource();
            this.mPlayNode.buffer = this.mBuffer;
            this.mPlayNode.connect(this.mGainNode);
            this.mPlayNode.start(0);
        }
        this.mFrame++;
    }
    else if( this.mType==="image" )
    {
        this.mRenderer.SetRenderTarget( null );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );
        this.mFrame++;
    }
    else if( this.mType==="common" )
    {
    }
    else if( this.mType==="buffer" )
    {
        this.mEffect.ResizeBuffer(bufferID, this.mEffect.mXres, this.mEffect.mYres, false );

        let buffer = buffers[bufferID];

        let dstID = 1 - buffer.mLastRenderDone;

        this.mRenderer.SetRenderTarget( buffer.mTarget[dstID] );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }

        // make thumbnail
        //if( this.mTextureCallbackFun != null )
        /*
        {
            this.mRenderer.SetRenderTarget( buffer.mThumbnailRenderTarget );
            let v = [0, 0, buffer.mThumbnailRes[0], buffer.mThumbnailRes[1]];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            this.mRenderer.SetShaderConstant4FV("v", v);
            this.mRenderer.AttachTextures(1, buffer.mTexture[dstID], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);
            this.mRenderer.DettachTextures();
            this.mRenderer.DetachShader();
            this.mRenderer.GetPixelData( new Uint8Array(buffer.mThumbnailBuffer.data.buffer), buffer.mThumbnailRes[0], buffer.mThumbnailRes[1] );
            this.mRenderer.SetRenderTarget(null);
        }
        */
        buffers[bufferID].mLastRenderDone = 1 - buffers[bufferID].mLastRenderDone;
        this.mFrame++;
    }
    else if( this.mType==="cubemap" )
    {
        this.mEffect.ResizeCubemapBuffer(bufferID, 1024, 1024, false );

        let buffer = cubeBuffers[bufferID];

        xres = buffer.mResolution[0];
        yres = buffer.mResolution[1];
        let dstID = 1 - buffer.mLastRenderDone;
        for( let face=0; face<6; face++ )
        {
            this.mRenderer.SetRenderTargetCubeMap( buffer.mTarget[dstID], face );
            this.Paint_Cubemap( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
        }
        this.mRenderer.SetRenderTargetCubeMap( null, 0 );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }
        cubeBuffers[bufferID].mLastRenderDone = 1 - cubeBuffers[bufferID].mLastRenderDone;

        this.mFrame++;
    }
}

EffectPass.prototype.StopOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;
    this.mPlayNode.disconnect();
}

EffectPass.prototype.ResumeOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;

    wa.resume()
    this.mPlayNode.connect( this.mGainNode );
}

EffectPass.prototype.StopOutput_Image = function( wa )
{
}

EffectPass.prototype.ResumeOutput_Image = function( wa )
{
}

EffectPass.prototype.StopOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.StopInput(j);

    if( this.mType==="sound" )
         this.StopOutput_Sound( wa );
    else
         this.StopOutput_Image( wa );
}

EffectPass.prototype.ResumeOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.ResumeInput(j);

    if( this.mType==="sound" )
         this.ResumeOutput_Sound( wa );
    else
         this.ResumeOutput_Image( wa );
}

EffectPass.prototype.GetCompilationTime = function()
{
    return this.mCompilationTime;
}

//============================================================================================================
function Screenshots()
{
    // private
    let mTexture = null;
    let mTarget = null;
    let mXres = 0;
    let mYres = 0;
    let mCubemapToEquirectProgram;
    let mRenderer = null;

    // public
    var me = {};

    me.Initialize = function(renderer)
    {
        mRenderer = renderer;
        let caps = mRenderer.GetCaps();
        let is20 = caps.mIsGL20;

        let vsSourceC, fsSourceC;
        if( is20 )
        {
            vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; out vec4 outColor; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); outColor = texture(t, rd); }";
        }
        else
        {
            vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); gl_FragColor = texture(t, rd); }";
        }

        let compileShader = function (worked, info)
        {
            if (worked === false)
            {
                console.log("Failed to compile cubemap resample shader (" + errorType + "): " + log);
            }
            else
            {
                mCubemapToEquirectProgram = info;
            }
        }
        mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, compileShader);

        return true;
    };

    me.Allocate = function( xres, yres )
    {
        if( xres>mXres || yres>mYres )
        {
            let texture = mRenderer.CreateTexture(mRenderer.TEXTYPE.T2D, xres, yres, mRenderer.TEXFMT.C4F32, mRenderer.FILTER.NONE, mRenderer.TEXWRP.CLAMP, null);
            let target = mRenderer.CreateRenderTarget( texture, null, null, null, null, false);

            if( mXres!==0 )
            {
                mRenderer.DestroyTexture(mTexture);
                mRenderer.DestroyRenderTarget(mTarget);
            }

            mTexture = texture;
            mTarget = target;
            mXres = xres;
            mYres = yres;
        }
    };

    me.GetProgram = function()
    {
        return mCubemapToEquirectProgram;
    };
    me.GetTarget = function()
    {
        return mTarget;
    };

    return me;
};

//============================================================================================================

function Effect(vr, ac, canvas, callback, obj, forceMuted, forcePaused, resizeCallback, crashCallback )
{
    let xres = canvas.width;
    let yres = canvas.height;

    let me = this;
    this.mCanvas = canvas;
    this.mCreated = false;
    this.mRenderer = null;
    this.mAudioContext = ac;
    this.mGLContext = null;
    this.mWebVR = vr;
    this.mRenderingStereo = false;
    this.mXres = xres;
    this.mYres = yres;
    this.mForceMuted = forceMuted;
    if( ac===null ) this.mForceMuted = true;
    this.mForcePaused = forcePaused;
    this.mGainNode = null;
    this.mPasses = [];
    this.mFrame = 0;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mMaxBuffers = 4;
    this.mMaxCubeBuffers = 1;
    this.mMaxPasses = this.mMaxBuffers + 1 + 1 + 1 + 1; // some day decouple passes from buffers (4 buffers + common + Imagen + sound + cubemap)
    this.mBuffers = [];
    this.mCubeBuffers = [];
    this.mScreenshotSytem = null;
    this.mCompilationTime = 0;
    this.mIsLowEnd = piIsMobile();

    this.mGLContext = piCreateGlContext(canvas, false, false, true, false); // need preserve-buffe to true in order to capture screenshots
    if (this.mGLContext === null)
    {
        return;
    }

    canvas.addEventListener("webglcontextlost", function (event)
        {
            event.preventDefault();
            crashCallback();
        }, false);

    this.mRenderer = piRenderer();
    if (!this.mRenderer.Initialize(this.mGLContext))
        return;

    this.mScreenshotSytem = Screenshots();
    if (!this.mScreenshotSytem.Initialize(this.mRenderer))
        return;

    var caps = this.mRenderer.GetCaps();
    this.mIs20 = caps.mIsGL20;
    this.mShaderTextureLOD = caps.mShaderTextureLOD;
    //-------------
    if( ac!==null )
    {   
        this.mGainNode = ac.createGain();
        if( !forceMuted )
        {
            this.mGainNode.connect( ac.destination);
        }
        if (this.mForceMuted )
            this.mGainNode.gain.value = 0.0;
        else
            this.mGainNode.gain.value = 1.0;
    }

    //-------------
    let vsSourceC, fsSourceC;
    if( this.mIs20 )
    {
        vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { outColor = textureLod(t, gl_FragCoord.xy / v.zw, 0.0); }";
    }
    else
    {
        vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; void main() { gl_FragColor = texture2D(t, gl_FragCoord.xy / v.zw, -100.0); }";
    }

    this.mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, function(worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to copy buffers : " + info.mErrorStr);
            else me.mProgramCopy = info;
        });

    let vsSourceD, fsSourceD;
    if( this.mIs20 )
    {
        vsSourceD = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { vec2 uv = gl_FragCoord.xy / v.zw; outColor = texture(t, vec2(uv.x,1.0-uv.y)); }";
    }
    else
    {
        vsSourceD = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; void main() { vec2 uv = gl_FragCoord.xy / v.zw; gl_FragColor = texture2D(t, vec2(uv.x,1.0-uv.y)); }";
    }

    this.mRenderer.CreateShader(vsSourceD, fsSourceD, false, true, function (worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to downscale buffers : " + info.mErrorStr);
            else me.mProgramDownscale = info;
        });


    // set all buffers and cubemaps to null
    for( let i=0; i<this.mMaxBuffers; i++ )
    {
        this.mBuffers[i] = { mTexture: [null, null], 
                             mTarget:  [null, null], 
                             mResolution: [0, 0],
                             mLastRenderDone: 0,
                             mThumbnailRenderTarget: null,
                             mThumbnailTexture: null,
                             mThumbnailBuffer:  null,
                             mThumbnailRes: [0, 0] };
    }

    for( let i=0; i<this.mMaxCubeBuffers; i++ )
    {
        this.mCubeBuffers[i] = { mTexture: [null, null], 
                                mTarget:  [null, null], 
                                mResolution: [0, 0],
                                mLastRenderDone: 0,
                                mThumbnailRenderTarget: null,
                                mThumbnailTexture: null,
                                mThumbnailBuffer:  null,
                                mThumbnailRes: [0, 0] };
    }

    //-------

    let keyboardData = new Uint8Array( 256*3 );
    for (let j=0; j<(256*3); j++ ) { keyboardData[j] = 0; }
    let kayboardTexture = this.mRenderer.CreateTexture( this.mRenderer.TEXTYPE.T2D, 256, 3, this.mRenderer.TEXFMT.C1I8, this.mRenderer.FILTER.NONE, this.mRenderer.TEXWRP.CLAMP, null);
    let keyboardImage = new Image();
    if( callback!==null )
        keyboardImage.src = "/img/keyboard.png"; // don't load PNG if no UI 
    this.mKeyboard = { mData: keyboardData, mTexture: kayboardTexture, mIcon: keyboardImage };

    let iResize = function( xres, yres )
    {
        me.mCanvas.width = xres;
        me.mCanvas.height = yres;
        me.mXres = xres;
        me.mYres = yres;
        me.ResizeBuffers(xres, yres);
        resizeCallback(xres, yres);
    };

    let bestAttemptFallback = function()
    {
        let devicePixelRatio = window.devicePixelRatio || 1;
        let xres = Math.round(me.mCanvas.offsetWidth  * devicePixelRatio) | 0;
        let yres = Math.round(me.mCanvas.offsetHeight * devicePixelRatio) | 0;
        iResize(xres, yres);
    };

    if(!window.ResizeObserver)
    {
        console.log("WARNING: This browser doesn't support ResizeObserver.");
        bestAttemptFallback();
        window.addEventListener("resize", bestAttemptFallback);
    }
    else
    {
        this.mRO = new ResizeObserver( function(entries, observer)
        {
            var entry = entries[0];
            if (!entry['devicePixelContentBoxSize'])
            {
                observer.unobserve(me.mCanvas);
                console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (2)");
                bestAttemptFallback();
                window.addEventListener("resize", bestAttemptFallback);
            }
            else
            {
                let box = entry.devicePixelContentBoxSize[0];
                let xres = box.inlineSize;
                let yres = box.blockSize;
                iResize(xres, yres);
            }
        });
        try
        {
            this.mRO.observe(this.mCanvas, { box: ["device-pixel-content-box"] });
            //this.mRO.observe(this.mCanvas);
        }
        catch (e)
        {
            console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (1)");
            bestAttemptFallback();
            window.addEventListener("resize", bestAttemptFallback);
        }
    }

    this.mCreated = true;
}

Effect.prototype.ResizeCubemapBuffer = function(i, xres, yres )
{
    let oldXres = this.mCubeBuffers[i].mResolution[0];
    let oldYres = this.mCubeBuffers[i].mResolution[1];

    if( this.mCubeBuffers[i].mTexture[0]===null || oldXres !== xres || oldYres !== yres )
    {
        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);
        let target1 = this.mRenderer.CreateRenderTargetCubeMap( texture1, null, false);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target2 = this.mRenderer.CreateRenderTargetCubeMap( texture2, null, false);

        // Store new buffers
        this.mCubeBuffers[i].mTexture = [texture1,texture2], 
        this.mCubeBuffers[i].mTarget =  [target1, target2 ], 
        this.mCubeBuffers[i].mLastRenderDone = 0;
        this.mCubeBuffers[i].mResolution[0] = xres;
        this.mCubeBuffers[i].mResolution[1] = yres;
    }
}

Effect.prototype.ResizeBuffer = function( i, xres, yres, skipIfNotExists )
{
    if( skipIfNotExists && this.mBuffers[i].mTexture[0]===null ) return;

    let oldXres = this.mBuffers[i].mResolution[0];
    let oldYres = this.mBuffers[i].mResolution[1];

    if( oldXres !== xres || oldYres !== yres )
    {
        let needCopy = (this.mBuffers[i].mTexture[0]!==null);

        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[0].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[0].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[1].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[1].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target1 = this.mRenderer.CreateRenderTarget( texture1, null, null, null, null, false);
        let target2 = this.mRenderer.CreateRenderTarget( texture2, null, null, null, null, false);

        if( needCopy )
        {
            let v = [0, 0, Math.min(xres, oldXres), Math.min(yres, oldYres)];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            let vOld = [0, 0, oldXres, oldYres];
            this.mRenderer.SetShaderConstant4FV("v", vOld);

            // Copy old buffers 1 to new buffer
            this.mRenderer.SetRenderTarget(target1);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[0], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Copy old buffers 2 to new buffer
            this.mRenderer.SetRenderTarget(target2);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[1], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Deallocate old memory
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[0]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[0]);
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[1]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[1]);
            //this.mRenderer.DestroyTexture(this.mBuffers[i].thumbnailTexture);
        }

        // Store new buffers
        this.mBuffers[i].mTexture = [texture1,texture2], 
        this.mBuffers[i].mTarget =  [target1, target2 ], 
        this.mBuffers[i].mLastRenderDone = 0;
        this.mBuffers[i].mResolution[0] = xres;
        this.mBuffers[i].mResolution[1] = yres;
    }
}

Effect.prototype.saveScreenshot = function(passid)
{
    let pass = this.mPasses[passid];

    if( pass.mType === "buffer" )
    {
        let bufferID = assetID_to_bufferID( this.mPasses[passid].mOutputs[0] );

        let texture = this.mBuffers[bufferID].mTarget[ this.mBuffers[bufferID].mLastRenderDone ];

        let numComponents = 3;
        let width = texture.mTex0.mXres;
        let height = texture.mTex0.mYres;
        let type = "Float"; // Other options Float, Half, Uint
        let bytes = new Float32Array(width * height * 4 );//numComponents);
        this.mRenderer.GetPixelDataRenderTarget( texture, bytes, width, height );
        let blob = piExportToEXR(width, height, numComponents, type, bytes);

        // Offer download automatically to the user
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "cubemap" )
    {
        let xres = 4096;
        let yres = 2048;
        this.mScreenshotSytem.Allocate( xres, yres );

        let cubeBuffer = this.mCubeBuffers[0];

        let target = this.mScreenshotSytem.GetTarget();
        this.mRenderer.SetRenderTarget( target );

        let program = this.mScreenshotSytem.GetProgram();

        this.mRenderer.AttachShader(program);
        let l1 = this.mRenderer.GetAttribLocation(program, "pos");
        this.mRenderer.SetViewport( [0, 0, xres, yres] );
        this.mRenderer.AttachTextures(1, cubeBuffer.mTexture[ cubeBuffer.mLastRenderDone ], null, null, null);
        this.mRenderer.DrawUnitQuad_XY(l1);
        this.mRenderer.DettachTextures();
        this.mRenderer.SetRenderTarget( null );

        let data = new Float32Array(xres*yres*4);
        this.mRenderer.GetPixelDataRenderTarget( target, data, xres, yres );

        let blob = piExportToEXR(xres, yres, 3, "Float", data );
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "sound" )
    {
        let offset = 0;
        const bits = 16;
        const numChannels = 2;
        let words = new Int16Array(60*pass.mSampleRate*numChannels );

        pass.iRenderSound( new Date(), function(off, data, numSamples)
                                         {
                                            for( let i=0; i<numSamples; i++ )
                                            {
                                                words[offset++] = (data[4*i+0]+256.0*data[4*i+1]) - 32767;
                                                words[offset++] = (data[4*i+2]+256.0*data[4*i+3]) - 32767;
                                            }
                                         }
                                     );

        let blob = piExportToWAV( 60*pass.mSampleRate, pass.mSampleRate, bits, numChannels, words);

        piTriggerDownload("sound.wav", blob);
    }    
}

Effect.prototype.ResizeBuffers = function(xres, yres)
{
    for (let i=0; i<this.mMaxBuffers; i++ )
    {
        this.ResizeBuffer(i, xres, yres, true);
    }
}

Effect.prototype.IsEnabledVR = function ()
{
    if (this.mRenderingStereo) return true;
    return false;
}

Effect.prototype.EnableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( this.mRenderingStereo ) return;

    this.mRenderingStereo = true;
    this.mWebVR.Enable();
}

Effect.prototype.DisableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( !this.mRenderingStereo ) return;

    this.mRenderingStereo = false;
    this.mWebVR.Disable();
}

Effect.prototype.GetTexture = function( passid, slot ) { return this.mPasses[passid].GetTexture( slot ); }
Effect.prototype.NewTexture = function (passid, slot, url) { return this.mPasses[passid].NewTexture( this.mAudioContext, slot, url, this.mBuffers, this.mCubeBuffers, this.mKeyboard ); }
Effect.prototype.SetOutputs = function( passid, slot, url ) { this.mPasses[passid].SetOutputs( slot, url ); }
Effect.prototype.SetOutputsByBufferID = function( passid, slot, id ) { this.mPasses[passid].SetOutputsByBufferID( slot, id ); }
Effect.prototype.GetAcceptsLinear = function (passid, slot) { return this.mPasses[passid].GetAcceptsLinear(slot); }
Effect.prototype.GetAcceptsMipmapping = function (passid, slot) { return this.mPasses[passid].GetAcceptsMipmapping(slot); }
Effect.prototype.GetAcceptsWrapRepeat = function (passid, slot) { return this.mPasses[passid].GetAcceptsWrapRepeat(slot); }
Effect.prototype.GetAcceptsVFlip = function (passid, slot) { return this.mPasses[passid].GetAcceptsVFlip(slot); }
Effect.prototype.SetSamplerFilter = function (passid, slot, str) { this.mPasses[passid].SetSamplerFilter(slot, str, this.mBuffers, this.mCubeBuffers); }
Effect.prototype.GetTranslatedShaderSource = function (passid) { return this.mPasses[passid].GetTranslatedShaderSource(); }
Effect.prototype.GetSamplerFilter = function (passid, slot) { return this.mPasses[passid].GetSamplerFilter(slot); }
Effect.prototype.SetSamplerWrap = function (passid, slot, str) { this.mPasses[passid].SetSamplerWrap(slot, str, this.mBuffers); }
Effect.prototype.GetSamplerWrap = function (passid, slot) { return this.mPasses[passid].GetSamplerWrap(slot); }
Effect.prototype.SetSamplerVFlip = function (passid, slot, str) { this.mPasses[passid].SetSamplerVFlip(slot, str); }
Effect.prototype.GetSamplerVFlip = function (passid, slot) { return this.mPasses[passid].GetSamplerVFlip(slot); }

Effect.prototype.GetHeaderSize = function (passid)
{
    return this.mPasses[passid].mHeaderLength + 
           this.mRenderer.GetShaderHeaderLines(1);
}

Effect.prototype.ToggleVolume = function()
{
    this.mForceMuted = !this.mForceMuted;

    // outp
    if (this.mForceMuted)
        this.mGainNode.gain.value = 0.0;
    else
        this.mGainNode.gain.value = 1.0;

    // inp
    let num = this.mPasses.length;
    for( let j=0; j<num; j++ )
    {
        for( let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            if( this.mForceMuted )
                this.mPasses[j].MuteInput( this.mAudioContext, i );
            else
                this.mPasses[j].UnMuteInput( this.mAudioContext, i );
        }
    }

    return this.mForceMuted;
}

Effect.prototype.SetKeyDown = function( passid, k )
{
    if( this.mKeyboard.mData[ k + 0*256 ] == 255 ) return;

    this.mKeyboard.mData[ k + 0*256 ] = 255;
    this.mKeyboard.mData[ k + 1*256 ] = 255;
    this.mKeyboard.mData[ k + 2*256 ] = 255 - this.mKeyboard.mData[ k + 2*256 ];
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }
}

Effect.prototype.SetKeyUp = function( passid, k )
{
    this.mKeyboard.mData[ k + 0*256 ] = 0;
    this.mKeyboard.mData[ k + 1*256 ] = 0;
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }
}

Effect.prototype.StopOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].StopOutput( wa );
    }
}

Effect.prototype.ResumeOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].ResumeOutput( wa );
    }
}

Effect.prototype.PauseInput = function( passid, id )
{
    return this.mPasses[passid].TooglePauseInput( this.mAudioContext, id );
}

Effect.prototype.ToggleMuteInput = function( passid, id )
{
    return this.mPasses[passid].ToggleMuteInput( this.mAudioContext, id );
}

Effect.prototype.RewindInput = function( passid, id )
{
    this.mPasses[passid].RewindInput( this.mAudioContext, id );
}

Effect.prototype.UpdateInputs = function( passid, forceUpdate )
{
   this.mPasses[passid].UpdateInputs( this.mAudioContext, forceUpdate, this.mKeyboard );
}

Effect.prototype.ResetTime = function()
{
    this.mFrame = 0;
    this.mAudioContext.resume()

    let num = this.mPasses.length;
    for( let i=0; i<num; i++ )
    {
        this.mPasses[i].mFrame = 0;
        for( let j=0; j<this.mPasses[i].mInputs.length; j++ )
            this.mPasses[i].RewindInput(this.mAudioContext, j)
    }
}

Effect.prototype.RequestAnimationFrame = function (id)
{
    if (this.mRenderingStereo && this.mWebVR.IsPresenting())
    {
        this.mWebVR.RequestAnimationFrame(id);
    }
    else
    {
        requestAnimFrame(id);
    }
}

Effect.prototype.Paint = function(time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, isPaused)
{
    let wa = this.mAudioContext;
    let da = new Date();
    let vrData = null; if (this.mRenderingStereo) vrData = this.mWebVR.GetData();
    let xres = this.mXres / 1;
    let yres = this.mYres / 1;

    if( this.mFrame===0 )
    {
        for( let i=0; i<this.mMaxBuffers; i++ )
        {
            if( this.mBuffers[i].mTexture[0]!==null )
            {
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[0] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[1] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
				
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[0] );
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[1] );
            }
        }
        for( let i=0; i<this.mMaxCubeBuffers; i++ )
        {
            if( this.mCubeBuffers[i].mTexture[0]!==null )
            {
                for( let face=0; face<6; face++ )
                {
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[0], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[1], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
					this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[0] );
				    this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[1] );
                }
            }
        }
    }

    let num = this.mPasses.length;

    // render sound first
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "sound" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "buffer" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;
        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="buffer" && inp.id === bufferID && inp.mInfo.mSampler.filter === "mipmap")
                {
                    needMipMaps = true;
                    break;
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render cubemap buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "cubemap" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = 0;//assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;

        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="cubemap" )
                {
                    if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0 && inp.mInfo.mSampler.filter === "mipmap" )
                    {
                        needMipMaps = true;
                        break;
                    }
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render image last
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "image" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }   

    // erase keypresses
    for (let k=0; k<256; k++ )
    {
       this.mKeyboard.mData[ k + 1*256 ] = 0;
    }
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    if( this.mRenderingStereo ) this.mWebVR.Finish();

    this.mFrame++;
}

Effect.prototype.NewShader = function( passid, preventCache, onResolve )
{
    let commonSourceCodes = [];
    for (let i=0; i<this.mPasses.length; i++ )
    {
        if( this.mPasses[i].mType==="common")
        {
            commonSourceCodes.push(this.mPasses[i].mSource);
        }
    }

    this.mPasses[passid].NewShader(commonSourceCodes, preventCache, onResolve );
}

Effect.prototype.GetNumPasses = function()
{
    return this.mPasses.length;
}

Effect.prototype.GetNumOfType = function(passtype)
{
    let id = 0;
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType===passtype )
        {
            id++;
        }
    }
    return id;
}

Effect.prototype.GetPassType = function( id ) { return this.mPasses[id].mType; }
Effect.prototype.GetPassName = function( id ) { return this.mPasses[id].mName; }
Effect.prototype.GetCode = function( id ) { return this.mPasses[id].mSource; }
Effect.prototype.SetCode = function( id, source ) { this.mPasses[id].SetCode(source); }
Effect.prototype.GetError = function (id) { return this.mPasses[id].mError; }
Effect.prototype.GetErrorStr = function (id) { return this.mPasses[id].mErrorStr; }
Effect.prototype.GetErrorGlobal = function()
{
    for (let i = 0; i < this.mPasses.length; i++)
    {
        if (this.mPasses[i].mError)
        {
            return true;
        }
    }
    return false;
}

Effect.prototype.Load = function (jobj )
{
    if (jobj.ver !== "0.1")
    {
        console.log("Wrong Format");
        return false;
    }

    let numPasses = jobj.renderpass.length;

    if( numPasses<1 || numPasses>this.mMaxPasses )
    {
        console.log("Corrupted Shader - " + numPasses);
        return false;
    }

    this.mPasses = [];
    for (let j = 0; j < numPasses; j++)
    {
        let rpass = jobj.renderpass[j];

        // skip sound passes if in thumbnail mode
        if( this.mForceMuted && rpass.type === "sound" ) continue;

        let wpass = new EffectPass(this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                   this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode,
                                   this.mProgramDownscale, j, this);

        wpass.Create(rpass.type, this.mAudioContext);

        let numInputs = rpass.inputs.length;

        for (let i = 0; i < 4; i++)
        {
            wpass.NewTexture(this.mAudioContext, i, null, null, null);
        }
        for (let i = 0; i < numInputs; i++)
        {
            let lid  = rpass.inputs[i].channel;
            let styp = rpass.inputs[i].type;
            let sid  = rpass.inputs[i].id;
            let ssrc = rpass.inputs[i].filepath;
            let psrc = rpass.inputs[i].previewfilepath;
            let samp = rpass.inputs[i].sampler;

            wpass.NewTexture(this.mAudioContext, lid, { mType: styp, mID: sid, mSrc: ssrc, mSampler: samp, mPreviewSrc: psrc }, this.mBuffers, this.mCubeBuffers, this.mKeyboard);
        }

        for (let i = 0; i < 4; i++)
        {
            wpass.SetOutputs(i, null);
        }

        let numOutputs = rpass.outputs.length;
        for (let i = 0; i < numOutputs; i++)
        {
            let outputID = rpass.outputs[i].id;
            let outputCH = rpass.outputs[i].channel;
            wpass.SetOutputs(outputCH, outputID);
        }

        // create some hardcoded names. This should come from the DB
        let rpassName = "";
        if (rpass.type === "common" ) rpassName = "Common";
        if (rpass.type === "sound"  ) rpassName = "Sound";
        if (rpass.type === "image"  ) rpassName = "Image";
        if (rpass.type === "buffer") rpassName = "Buffer " + String.fromCharCode(65 + assetID_to_bufferID(wpass.mOutputs[0]));
        if (rpass.type === "cubemap") rpassName = "Cube A";// " + String.fromCharCode(65 + assetID_to_bufferID(this.mPasses[j].mOutputs[0]));
        wpass.SetName(rpassName);
        wpass.SetCode(rpass.code);

        this.mPasses.push(wpass);
    }
    return true;
}

Effect.prototype.CompileSome = function ( passes, preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    for (let j = 0; j < passes.length; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(passes[j], preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < me.mPasses.length; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.Compile = function (preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(j, preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < numPasses; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.GetCompilationTime = function( id )
{
    return this.mPasses[id].GetCompilationTime()/1000.0;
}
Effect.prototype.GetTotalCompilationTime = function()
{
    return this.mCompilationTime/1000.0;
}

Effect.prototype.DestroyPass = function( id )
{
   this.mPasses[id].Destroy( this.mAudioContext );
   this.mPasses.splice(id, 1);
}

Effect.prototype.AddPass = function( passType, passName, onResolve )
{
    let shaderStr = null;

    if( passType==="sound"   ) shaderStr = "vec2 mainSound( int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n}";
    if( passType==="buffer"  ) shaderStr = "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}";
    if( passType==="common"  ) shaderStr = "vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}";
    if( passType==="cubemap" ) shaderStr = "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rayDir;\n\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}";

    let id = this.GetNumPasses();
    this.mPasses[id] = new EffectPass( this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                       this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode, 
                                       this.mProgramDownscale, id, this );

    this.mPasses[id].Create( passType, this.mAudioContext );
    this.mPasses[id].SetName( passName );
    this.mPasses[id].SetCode( shaderStr );
    this.NewShader(id, false, function ()
    {
        onResolve();
    });

    return { mId : id, mShader : shaderStr };
}

// this should be removed once we have MultiPass 2.0 and passes render to arbitrary buffers
Effect.prototype.IsBufferPassUsed = function( bufferID )
{
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType !== "buffer" ) continue;
        if( this.mPasses[j].mOutputs[0] === bufferID_to_assetID(bufferID) ) return true;
    }
    return false;
}

Effect.prototype.Save = function()
{
    var result = {};

    result.ver = "0.1";

    result.renderpass = [];

    let numPasses = this.mPasses.length;
    for (let j=0; j<numPasses; j++ )
    {
        result.renderpass[j] = {};

        result.renderpass[j].outputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            let outputID = this.mPasses[j].mOutputs[i];
            if( outputID===null ) continue;
            result.renderpass[j].outputs.push( { channel: i, id: outputID } );
        }
        result.renderpass[j].inputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            if( this.mPasses[j].mInputs[i]===null ) continue;
            result.renderpass[j].inputs.push( {channel: i,
                                               type    : this.mPasses[j].mInputs[i].mInfo.mType,
                                               id      : this.mPasses[j].mInputs[i].mInfo.mID,
                                               filepath: this.mPasses[j].mInputs[i].mInfo.mSrc,
                                               sampler : this.mPasses[j].mInputs[i].mInfo.mSampler });
        }

        result.renderpass[j].code = this.mPasses[j].mSource;
        result.renderpass[j].name = this.mPasses[j].mName
        result.renderpass[j].description = "";
        result.renderpass[j].type = this.mPasses[j].mType;
    }

    result.flags = this.calcFlags();

    return result;
}

Effect.prototype.calcFlags = function ()
{
    let flagVR = false;
    let flagWebcam = false;
    let flagSoundInput = false;
    let flagSoundOutput = false;
    let flagKeyboard = false;
    let flagMultipass = false;
    let flagMusicStream = false;

    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        let pass = this.mPasses[j];

        if (pass.mType === "sound") flagSoundOutput = true;
        if (pass.mType === "buffer") flagMultipass = true;

        for (let i = 0; i < 4; i++)
        {
            if (pass.mInputs[i] === null) continue;

            if (pass.mInputs[i].mInfo.mType === "webcam") flagWebcam = true;
            else if (pass.mInputs[i].mInfo.mType === "keyboard") flagKeyboard = true;
            else if (pass.mInputs[i].mInfo.mType === "mic") flagSoundInput = true;
            else if (pass.mInputs[i].mInfo.mType === "musicstream") flagMusicStream = true;
        }

        let n1 = pass.mSource.indexOf("mainVR(");
        let n2 = pass.mSource.indexOf("mainVR (");
        if (n1 > 0 || n2 > 0) flagVR = true;
    }

    return {
        mFlagVR: flagVR,
        mFlagWebcam: flagWebcam,
        mFlagSoundInput: flagSoundInput,
        mFlagSoundOutput: flagSoundOutput,
        mFlagKeyboard: flagKeyboard,
        mFlagMultipass: flagMultipass,
        mFlagMusicStream: flagMusicStream
    };
}</script>
    <script>"use strict"

const kMaxCompileTime = 10.0;

function iReportCrash(shaderID)
{
    let req = new XMLHttpRequest();
    req.onload = function ()
    {
        let jsn = req.response;
        if (jsn === null) return;
        if (jsn.result === 0)
        {
            // yep
        }
    };
    req.open("POST", "/shadertoy", true);
    req.responseType = "json";
    req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    req.send( "s=" + shaderID + "&r=2" );
}
</script>
    <script>"use strict"

var gActive = -1;
var mShaders = [];
var gNumCanvases = 0;

function myrefresh( id, slot, img, forceFrame, gui, guiID, renderID, time )
{
    if( mShaders[id].mReady===false ) return;
    if( forceFrame )
    {
        if (mShaders[id].mScreenshot === false)
        {
            mShaders[id].gEffect.Paint(mShaders[id].mTime / 1000.0, 1.0 / 60.0, 60.0, 0, 0, 0, 0, false);
        }
    }
}

function startRendering()
{
    if( gActive<0 ) return;
    if( mShaders[gActive].mReady===false ) return;
    if( mShaders[gActive].mScreenshot===true ) return;

    let time = getRealTime();

    mShaders[gActive].mFPS.Count( time );
    mShaders[gActive].mTime = mShaders[gActive].mTime0 + (time - mShaders[gActive].mTo);
    let dtime = 1000.0/60.0;
    mShaders[gActive].gEffect.Paint( mShaders[gActive].mTime/1000.0, dtime/1000.0, mShaders[gActive].mFPS.GetFPS(), 0,0,0,0, false);

    requestAnimFrame( startRendering );
}

function iLoadAndCompile(jsn, i )
{
    var shaderObj = jsn[i];
    if (shaderObj === null) return;

    var resizeCB = function (xres, yres) { myrefresh(i, 0, null, true, false, 0, -1.0) };
    var crashCB = function () { alert('crash');/*iReportCrash(gShaderIDs[i])*/ };
    mShaders[i].gEffect = new Effect(null, null, mShaders[i].mPreview.mCanvas, myrefresh, i, true, true, resizeCB, crashCB);

    if (!mShaders[i].gEffect.Load(shaderObj)) return;

    mShaders[i].gEffect.Compile(false, function (worked)
    {
        if (worked === true)
        {
            previewShowRender(mShaders[i].mPreview);

            mShaders[i].mScreenshot = false;
            mShaders[i].mReady = true;
            mShaders[i].mTime = 10.0 * 1000.0;
            mShaders[i].mTime0 = 0.0;
            mShaders[i].mTo = 0.0;
            mShaders[i].mFPS = piCreateFPSCounter();
            mShaders[i].mPreview.mCanvas.addEventListener("mouseout", function (ev) { gActive = -1; }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseover", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.add('isVisible'); }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseout", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.remove('isVisible'); }, true);
            mShaders[i].mPreview.mCanvas.addEventListener("mouseover", function (ev)
            {
                let ele = piGetSourceElement(ev);
                if (ele.mId === undefined) return;

                gActive = ele.mId;
                if (!mShaders[gActive].mReady) return;
                let time = getRealTime();
                mShaders[gActive].mTo = time;
                mShaders[gActive].mTime0 = mShaders[gActive].mTime;
                mShaders[gActive].mFPS.Reset(time);

                startRendering();
            }, true);


            /*
            let compilationTime = mShaders[i].gEffect.GetTotalCompilationTime();
            if (compilationTime > kMaxCompileTime)
            {
                iReportCrash(mShaders[i].mShaderID);
            }*/

            myrefresh(i, null, null, true, false, 0, -1.0);
        }
        else
        {
            mShaders[i].mReady = false;
            previewShowError(mShaders[i].mPreview);
        }
    });
};


function iProcessShader( jsn, i )
{
    var shaderObj = jsn[i];
    if( shaderObj===null ) return;

    if ((shaderObj.info.usePreview === 0 && !gUseScreenshots) || (mShaders[i].mPreviewReady !== 1))
    {
        iLoadAndCompile(jsn, i);
    }
    else
    {
        mShaders[i].mScreenshot = true;
        if( shaderObj.info.usePreview === 1 )
            previewShowScreenshot(mShaders[i].mPreview, 1); // comp
        else if (gUseScreenshots)
            previewShowScreenshot(mShaders[i].mPreview, 2); // sett
    }

    if( i<(jsn.length-1) ) setTimeout( function(){iProcessShader(jsn,i+1);}, 10 );
}

function iInitUI(numCanvases, uiCallback, windowTitle)
{
    gNumCanvases = numCanvases;
    document.getElementById("mySearch").focus();

    //-----------------------------------------------------------------
    // window
    //-----------------------------------------------------------------
    if (windowTitle !== null) {
        document.title = windowTitle;
    }

    //-----------------------------------------------------------------
    // ui
    //-----------------------------------------------------------------
    var num = Math.min(gShaders.length, gNumCanvases);

    //var base = document.getElementsByClassName( "searchResult" );

    for (let i = 0; i < gNumCanvases; i++)
    {
        let pv = createPreview(i);

        if (i >= num) {
            previewHide(pv);
            continue;
        }

        let shaderID = gShaders[i].info.id;
        
        if (pv.mUI !== null && uiCallback !== null) {
            pv.mUI.addEventListener('click', function (ev) {
                uiCallback(shaderID);
                ev.preventDefault();
            }, false);
        }
        
        previewShowLoading(pv);
        
        mShaders[i] = {};
        mShaders[i].mShaderID = shaderID;
        mShaders[i].mPreview = pv;
        mShaders[i].mScreenshot = false;
        mShaders[i].mPreview.mLink.href = "/view/" + shaderID;
        mShaders[i].mPreviewReady = 0;
        mShaders[i].mReady = false;
        mShaders[i].gEffect = null;

        previewLoadScreenshot(mShaders[i].mPreview,
            function () { mShaders[i].mPreviewReady = 1; if (mShaders[i].mReady === false) previewShowScreenshot(mShaders[i].mPreview, 0); },
            function () { mShaders[i].mPreviewReady = 2; },
            shaderID);
    }

    if (num <= 0) {
        return;
    }
}

function iInitShaders(jsn)
{
    for (let i = 0; i < jsn.length; i++)
    {
        let shaderObj = jsn[i];
        if (shaderObj === null) continue;
        let inf = shaderObj.info;
        mShaders[i].mPreview.mTextA.textContent = inf.name;
        mShaders[i].mPreview.mTextB.innerHTML = "<a class='user' href='/user/" + htmlEntities(inf.username) + "'>" + htmlEntities(inf.username) + "</a>";
        mShaders[i].mPreview.mTextC.innerHTML = "<img src='/img/themes/" + gThemeName + "/views.png' class='viewsIcon'></img>" + inf.viewed + "    &nbsp;&nbsp;  <img src='/img/themes/" + gThemeName + "/likes.png' class='likesIcon'></img>" + inf.likes;
    }

    setTimeout(function () { iProcessShader(jsn, 0); }, 10);
}

function resultsInitStatic(numCanvases, uiCallback, windowTitle)
{
    iInitUI(numCanvases, uiCallback, windowTitle);

    iInitShaders(gShaders);
}

function resultsInit(numCanvases, uiCallback, windowTitle)
{	
    iInitUI(numCanvases, uiCallback, windowTitle);

    var num = Math.min(gShaderIDs.length, gNumCanvases);

    var mHttpReq = new XMLHttpRequest();

    mHttpReq.abort();

    var str = "{ \"shaders\" : [";
    for( let i=0; i<num; i++ )
    {
         str += "\"" + gShaderIDs[i] + "\"";
         if( i!==(num-1) ) str += ", ";
    }
    str += "] }";

    str = "s=" + encodeURIComponent( str ) + "&nt=0&nl=0&np=0";

    mHttpReq.open( "POST", "/shadertoy", true );
    mHttpReq.responseType = "json";
    mHttpReq.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    mHttpReq.onload = function ()
    {
        let jsn = this.response;
        if( jsn===null )
        {
            console.log( "Could not load shaders" );
            return;
        }

        iInitShaders(jsn);
    }
    mHttpReq.send( str );
}</script>
    <style>
    .shaderPreview
    {
    display: block;
    background-color: #000000;
    background-image: url("/img/loading.gif");
    background-repeat: no-repeat;
    background-position: center;
    padding: 0px;
    margin: 0px;
    border: 0px solid #000000;
    border-radius: 8px;
    width:100%;
    height:100%;
    position: absolute;
    overflow:hidden;
    }

    .previewInfo
    {
    width: 100%;
    left: 0px;
    top: 2px;
    position: relative;
    visibility: hidden;
    }

    .previewCanvas
    {
    left: 0px;
    top: 0px;
    padding: 0px;
    margin: 0px;
    position: absolute;
    cursor: pointer;
    width:100%;
    height:100%;
    border-radius: 8px;
    border: 0px solid #000000;
    backgroundColor: transparent;
visibility: hidden;
opacity:0;
transition: opacity 1.0s ease;
    }

    .previewText
    {
        text-overflow: ellipsis;
    white-space: nowrap;
    padding-right: 1px;
    }

    .previewTextUser
    {
    text-overflow: ellipsis;
    white-space: nowrap;
    padding-left: 3px;
    }

    .previewStats
    {
    padding-right: 1px;
    right: 0px;
    top: 0px;
    position: absolute;
    }

    .previewErrorContainer
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    visibility:hidden;
    }

    .previewErrorMessage
    {
    top:50%;
    position:absolute;
    width:100%;
    text-align:center;
    padding:0;
    margin:auto;
    color:#ff0000;
    font-size:2em;
    font-style:italic;
    }

    .previewNoGLContainter
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    position:absolute;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    pointer-events:none;
    visibility:hidden;
    font-size:2em;
    }

    .previewNoGLMessage
    {
    width:86%;
    height:90%;
    padding-left:7%;
    padding-right:7%;
    padding-top:10%;
    padding-bottom:0px;
    color:#ff0000;
    position:absolute;
    visibility:hidden;
    }

    .previewThumbnailContainer
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    visibility:hidden;
    border-radius:8px;
    border:0px solid #000000;
    }

    .previewThumbnailImage
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    border-radius:8px;
    border:0px solid #000000;
opacity: 0.0;
transition: opacity 1.0s ease;
    }

    .previewThumbnailIcon
    {
    width:64px;
    height:32px;
    left:0px;
    top:0px;
    padding:0px;
    padding-top:12px;
    margin:0px;
    position:absolute;
    color:#ffffff;
    background-color:#ff8020;
    font-weight:bold;
    border-radius:0px 0px 8px 0px;
    text-align:center;
    //visibility:hidden;
    }


    .previewUIContainter
    {
    display: block;
    right:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    //cursor:pointer;
    //pointer-events:none;
    //visibility:hidden;
    }
</style>

<script>
    function previewHide(me)
    {
    me.mBase.style.visibility = "hidden";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";
    }

    function previewShowRender(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "visible";
me.mCanvas.style.opacity = 1.0;
    me.mCanvas.style.borderRadius ="8px;";
//  me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    }

    function previewShowScreenshot(me, message)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "visible";
me.mThumbnailImg.style.opacity = 1.0;
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    me.mThumbnailWar1.style.visibility = (message===1)?"visible":"hidden";
    me.mThumbnailWar2.style.visibility = (message===2)?"visible":"hidden";
    }

    function previewShowLoading(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";

    me.mLink.style.visibility = "visible";
    me.mBase.style.backgroundColor = "#ff0000;"
    me.mCont.style.visibility = "visible";
    }

    function previewShowNoWebGL(me, shaderID)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "visible";
    me.mError.style.visibility = "visible";
    me.mThumbnailImgNoWebGL.onerror = function(ev) 
                                      { 
                                            me.mThumbnailImgNoWebGL.style.visibility="hidden"; 
                                            me.mMessageNoWebGL.style.visibility="visible"; 
                                      };
    me.mThumbnailImgNoWebGL.src = "/media/shaders/" + shaderID + ".jpg";
    }

    function previewShowError(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "visible";
    me.mCont.style.visibility = "visible";
    }

    function previewLoadScreenshot( me, cbSuccess, cbError, shaderID )
    {
    var url = "/media/shaders/" + shaderID + ".jpg";
    me.mThumbnailImg.onload = cbSuccess;
    me.mThumbnailImg.onerror = function(ev) { cbError(); };
    me.mThumbnailImg.src = url;
    }
        
    function createPreview(id)
    {
        var bar = document.getElementById( "Preview_"+id+"_Canvas" );
        bar.width = bar.offsetWidth;
        bar.height = bar.offsetHeight;
        bar.mId = id;

        return { mBase: document.getElementById( "Preview_"+id+"_Container" ),
        mLink: document.getElementById( "Preview_"+id+"_Link" ),
        mCanvas: bar,
        mCont: document.getElementById( "Preview_"+id+"_Info" ),
        mTextA: document.getElementById( "Preview_"+id+"_Text" ),
        mTextB: document.getElementById( "Preview_"+id+"_TextUser" ),
        mTextC: document.getElementById( "Preview_"+id+"_Stats" ),
        mNoWebGL: document.getElementById( "Preview_"+id+"_NoWebGL" ),
        mError: document.getElementById( "Preview_"+id+"_Error" ),
        mCanvas2D: document.getElementById( "Preview_"+id+"_Thumnail" ),
        mThumbnailImg: document.getElementById( "Preview_"+id+"_ThumnailImage" ),
        mThumbnailWar1: document.getElementById( "Preview_"+id+"_ThumnailWarning1" ),
        mThumbnailWar2: document.getElementById( "Preview_"+id+"_ThumnailWarning2" ),
        mThumbnailImgNoWebGL: document.getElementById( "Preview_"+id+"_ThumnailImageNoWebGL" ),
        mMessageNoWebGL: document.getElementById( "Preview_"+id+"_MessageNoWebGL"),
        mUI: document.getElementById( "Preview_"+id+"_UI" )
        };
    }
</script>

    <style>

    div#shaderGrid
    {
        width:100%;
        padding:0px;
        margin:0px;
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        grid-template-rows: repeat(3, 1fr);
        grid-column-gap: 64px;
        grid-row-gap: 24px;
    }
    .searchResult
    {
        margin: 0px;
        padding: 0px;
        width: 100%;
    }
    .searchResultContainer
    {
        width: 100%;
        padding-bottom:56.25%;
        height: 0;
        position: relative;
    }
    .navigation
    {
        display:flex;
        align-items:center;
    }
    div#navBottom
    {
        display:none;
        justify-content:center;
    }
    a.pageButtons, .pageButtonsCurrent
    {
        border-style: solid;
        border-width: 1px;
        border-color: #808080;
        text-align: center;
        vertical-align: middle;
        margin-left: 12px;
        display: inline-block;
        border-radius: 4px;
		font-weight:bold;
        cursor: pointer;
        padding-bottom:5px;
        padding-top:4px;
        padding-left: 8px;
        padding-right: 8px;
        margin:8px;
    }
    a.pageButtons
    {
        text-decoration: none;
        -moz-transition:    background-color 0.15s linear, color 0.15s linear;
        -webkit-transition: background-color 0.15s linear, color 0.15s linear;
        transition:         background-color 0.15s linear, color 0.15s linear;
    }
    a.pageButtons:hover
    {
      background-color:#808080;
      color : #ff8020;
    }
    .pageButtonsCurrent
    {
        background-color: #808080;
        color:#000000;
    }
    div#controls
    {
        width:100%;
        padding-top:16px;
        padding-bottom:16px;
        display:flex;
        justify-content:space-between; 
        flex-wrap:wrap;
    }
    div#controls > div
    {
        display:inline-flex;
    }
    .controlOptions
    {
        display:inline-block;
    }

    /* ----------------------- media resolutions ------------------------ */

    @media screen and (max-width:799px) 
    {
        div#shaderGrid  { grid-template-columns: 1fr; grid-template-rows: repeat(12, 1fr); grid-column-gap: 0px; grid-row-gap: 16px; }
        div#controls
        {
            width:100%;
            display:flex;
            justify-content:flex-start; 
            flex-wrap:wrap;
        }
        div#controls > div
        {
            display:inline-flex;
            width:100%;
            margin-left: 0px;
            margin-right: 0px;
            padding-bottom:16px;
        }
        div#navBottom
        {
            display: flex;
        }
    }
    
    </style>
    <script>
    var gShaders=[{"ver":"0.1","info":{"id":"Mst3Wr","date":"1449111699","viewed":16033,"name":"La calanque","username":"XT95","description":"Something like &quot;Les calanques&quot; a beautiful place near Marseille, France!","likes":153,"published":3,"flags":32,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Created by anatole duprat - XT95\/2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    vec4 bufa = texture(iChannel0, uv);\n    \n    \/\/Lens fresnel\n    vec2 offset = (uv*2.-1.)\/iResolution.xy*2.;\n    vec3 col = vec3(0.);\n    col.r = texture(iChannel0, uv+offset).r;\n    col.g = bufa.g;\n    col.b = texture(iChannel0, uv-offset).b;\n    \n    \/\/Vignetting\n    col = clamp(col,0.,1.) * (.5 + .5*pow( uv.x*uv.y*(1.-uv.x)*(1.-uv.y)*50., .5));\n    \n    fragColor = vec4(col*min(iTime*.25,1.), 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ Created by anatole duprat - XT95\/2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat map( in vec3 p);\nvec3 shade( in vec3 p, in vec3 n, in vec3 ro, in vec3 rd);\n\nvec2 rotate( vec2 v, float a);\nvec3 seaHit( in vec3 ro, in vec3 rd, float h, out float t );\nvec3 raymarch( in vec3 ro, in vec3 rd, in vec2 clip);\nvec3 raymarchSmall( in vec3 ro, in vec3 rd, in vec2 clip);\n\nvec3 normal( in vec3 p, in float e );\nfloat ambientOcclusion(vec3 p, vec3 n, vec2 a);\n\nfloat noise( in vec3 x );\nfloat displacement( vec3 p );\nvec3 skyColor( in vec3 rd);\n\n\n\n\n\n\n\/\/Distance field maps\nfloat rock( in vec3 p)\n{\n\tfloat d = length(abs(p.xy)+vec2(-220.,50.))-200.; \/\/ 2 cylinders \n\td = max(d, -p.z-250.);\n    \n\td = d*.2  + noise(p*.04-.75)*7. + displacement(p*.25)*2.;\n    \n\treturn d;\n}\nfloat ground( in vec3 p )\n{\n\treturn p.y-clamp(p.z*.08-5.5,-20., 0.);\n}\nfloat map( in vec3 p )\n{\n\treturn min(ground(p), rock(p));\n}\n\n\n\/\/Shading\nvec3 shade( in vec3 p, in vec3 n, in vec3 ro, in vec3 rd)\n{\n\t\/\/Sky ?\n\tconst vec3 sunDir = vec3(-0.128,0.946, -0.189);\n\tvec3 sky = skyColor(rd);\n\tfloat d = length(p-ro);\n\tif(d>500. )\n\t\treturn sky;\n\n    vec3 nn = normal(p,5.);\n    \n   \t\/\/Materials\n\tvec3 col;\n\tif(rock(p.xyz) < p.y ) \/\/Rock\n\t{\n\t\tcol = mix(vec3(1.), vec3(.2,.3\/*+noise(p*0.4)*.5*\/,.1)*.4, pow(clamp(nn.y*1.1,0.,1.),4.));\n\t\tcol = mix(mix(vec3(.3,.2,.1), vec3(.3,.28,.22)*1.9, clamp(p.z-70.,0.,1.)), col, clamp(p.y*.3,0.,1.));\n\t}\n\telse \/\/Sand\n\t{\n\t\tcol = vec3(.3,.28,.22)*1.9*(noise(p*10.)*noise(p*vec3(.8,0.,3.))*.1+.8);\n\t}\n\n\n    \/\/BRDF \n    float shad = ambientOcclusion(p.xyz, sunDir, vec2(7.,12.));\n    float ao = ambientOcclusion(p.xyz, n, vec2(1.,1.5)) * ambientOcclusion(p.xyz, n, vec2(5.,8.));\n    \n    vec3 amb = vec3(.9,.97,1.)*ao;\n    vec3 diff = vec3(1.,.8,.5) * min( max(dot(n,sunDir),0.)*max(dot(nn,sunDir)*1.2,0.1)*shad*6., 1.);\n    vec3 ind = vec3(1.,.8,.5) * max(dot(n,sunDir*vec3(-1.,0.,-1.)),0.);\n    vec3 skylight = vec3(.9,.97,1.)*clamp( 0.5 + 0.5*n.y, 0.0, 1.0 )*ao;\n    col *=  amb*.3 + diff*.8 + ind*.1 + .2*skylight;\n    \n    \n    \n    \/\/Underwater blue\n    float a = clamp(-p.y*.4,0.,1.);\n    float b = pow(clamp(2.5-displacement(p*vec3(.5,1.,.3)*.05+1.)*6.*a, 0.8, 1.),4.);\n    float c = pow(clamp(2.5-displacement(p*vec3(.5,1.,.4)*.08+10.)*5.*a, 0.8, 1.),4.);\n\tcol = mix(col, vec3(.2,1.,.8)*.2*(b-c+1.), a);\n    \n    \/\/A little fog\n\tcol = mix( col, vec3(1.,.98,.9), clamp( (d-25.)*.0007,0.,1.) );\n\n\treturn col;\n}\n\n\nvec3 shadeWater( in vec3 p, in vec3 n, in vec3 ro, in vec3 rd) \n{\n\t\/\/Sky ?\n\tconst vec3 sunDir = vec3(-0.0828,0.946, -0.189);\n\tvec3 sky = skyColor(rd);\n\tif( map(p)>1.)\n\t\treturn sky;\n    \n    \/\/BRDF\n\tfloat d = length(p-ro);\n\tvec3 col = vec3(.9,.97,1.)*.1 +  vec3(1.,.9,.6)*max(dot(n,sunDir),0.)*.3;\n    \n    \/\/A little fog\n\tcol = mix( col, vec3(1.,.98,.9), clamp( (d-25.)*.0007,0.,1.) );\n    return col;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/Screen coords\n\tvec2 q = fragCoord.xy\/iResolution.xy;\n\tvec2 v = -1.0+2.0*q;\n\tv.x *= iResolution.x\/iResolution.y;\n    \n\t\/\/Camera\n\tfloat ct = cos(iTime*.1);\n    vec3 ro = vec3(20.*ct,10.,75.+20.*ct);\n\tvec3 rd = normalize( vec3(v.x, v.y, -1.5+length(v)*.5) );\n\trd.xz = rotate(rd.xz, -.5*ct+1.57);\n    \n    \n    \/\/Compute pixel\n    vec3 p = raymarch(ro, rd, vec2(.1,1800.));\n\tvec3 n = normal(p.xyz, 0.01);\n    vec3 col = shade(p,n, ro,rd);\n    \n    \/\/Water hit ?\n\tfloat t;\n\tvec3 pWater = seaHit(ro,rd,.1, t);\n    float d = length(p-ro);\n\tif( t>0. && (length(pWater-ro) < d || d>800.) )\n\t{\n\t\tfloat depth =  map(pWater);\n\t\tro = pWater.xyz;\n\t\tn = normalize( vec3(0.,1.,0.) + (noise(pWater+vec3(0.,0.,iTime))*2.-1.)*.025);\n\t\tfloat fre = (1.-max(dot(rd,n),0.));\n\t\tvec3 refd = reflect(rd, n);\n    \tp = raymarchSmall(pWater+n, refd, vec2(.1,800.));\n    \tn = normal(p.xyz, 5.);\n    \tvec3 col2= shadeWater(p,n, ro,refd);\n\t\tcol = mix(col, col2, min(depth,1.)*.5*fre);\n\t\tcol = mix( col, skyColor(rd), min( d*0.001,1.) );\n\t}\n    \n    \/\/Little lens flare\n    vec3 sundir = normalize( vec3(.5, .2, -1.) );\n    col += pow( max(dot(rd, sundir),0.), 2.0)*(float(d<500.)*.8+.2) *.1;\n    \n    \n    \/\/Gamma correction\n    col = pow( col, vec3(1.\/1.42) );\n    \n    fragColor = vec4(col, float(d>500.));\n}\n\n\n\n\n\n\n\n\nvec2 rotate( vec2 v, float a)\n{\n  return vec2( v.y*cos(a) - v.x*sin(a), v.x*cos(a) + v.y*sin(a));\n}\n\n\nvec3 seaHit( in vec3 ro, in vec3 rd, float h, out float t )\n{\n        vec4 pl = vec4(0.0,1.0,0.0,h);\n         t = -(dot(pl.xyz,ro)+pl.w)\/dot(pl.xyz,rd);\n        return ro+rd*t;\n}\n\n\nvec3 raymarch( in vec3 ro, in vec3 rd, in vec2 clip)\n{\n    float accD=2.;\n    for(int i=0; i<128; i++)\n    {\n\t\tfloat d = map( ro+rd*accD);\n        if(  accD > clip.y) break;\n        accD += d*2.5;\n        \n    }\n    return ro+rd*accD;\n}\n\nvec3 raymarchSmall( in vec3 ro, in vec3 rd, in vec2 clip)\n{\n    float accD=5.;\n    for(int i=0; i<64; i++)\n    {\n\t\tfloat d = map( ro+rd*accD);\n        if( d < .01 || accD > clip.y) break;\n        accD += d*2.5;\n        \n    }\n    return ro+rd*accD;\n}\n\nvec3 normal( in vec3 p, in float e )\n{\n    vec3 eps = vec3(e,0.0,0.0);\n    return normalize(vec3(\n        map(p+eps.xyy)-map(p-eps.xyy),\n        map(p+eps.yxy)-map(p-eps.yxy),\n        map(p+eps.yyx)-map(p-eps.yyx)\n    ));\n}\n\n\nfloat ambientOcclusion(vec3 p, vec3 n, vec2 a)\n{\n\tfloat dlt = a.x;\n\tfloat oc = 0.0, d = a.y;\n\tfor(int i = 0; i<5; i++)\n\t{\n\t\toc += (float(i) * dlt - map(p + n * float(i) * dlt)) \/ d;\n\t\td *= 2.0;\n\t}\n\treturn clamp(1.0 - oc, 0.0, 1.0);\n}\n\n\n\n\n\nvec3 skyColor( in vec3 rd )\n{\n    vec3 sundir = normalize( vec3(-.5, .2, -1.) );\n    \n    float yd = min(rd.y+0.05, 0.);\n    rd.y = max(rd.y+0.05, 0.05);\n    \n    vec3 col = vec3(0.);\n    \n    col += vec3(.4, .4 - exp( -rd.y*20. )*.3, .0) * exp(-rd.y*9.); \/\/ Red \/ Green \n    col += vec3(.3, .5, .6) * (1. - exp(-rd.y*8.) ) * exp(-rd.y*.9) ; \/\/ Blue\n    \n    col = mix(col*1.2, vec3(.3),  1.-exp(yd*100.)); \/\/ Fog\n    \n    col += vec3(1.0, .5, .0) * (pow( max(dot(rd,sundir),0.), 15. ) + pow( max(dot(rd, sundir),0.), 150.0)*.5)*.3; \/\/ Sun\n    \n    \n    col -= vec3(.6)*displacement( vec3(rd.xz*1.5\/(.001+rd.y),0.)-vec3(.0,.1,.05)*iTime )*rd.y-.2; \/\/Clouds\n    \n    return max(col, vec3(0.))*.9;\n}\n\n\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat displacement( vec3 p ) \/\/Thx to Inigo Quilez\n{\t\n    p *= vec3(1.,.8,1.);\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.01;\n    f += 0.2500*noise( p); p = m*p*3.5;\n    f += 0.0425*noise( p ); \/*p = m*p*2.01;\n    f += 0.0625*noise( p ); *\/\n\t\n    return f;\n}\n\nfloat noise(vec3 p) \/\/Thx to Las^Mercury\n{\n\tvec3 i = floor(p);\n\tvec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n\tvec3 f = cos((p-i)*acos(-1.))*(-.5)+.5;\n\ta = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\n\ta.xy = mix(a.xz, a.yw, f.y);\n\treturn mix(a.x, a.y, f.z)*.5+.5;\n}","name":"Buf A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"Xsf3zX","date":"1375124646","viewed":15977,"name":"Rolling hills","username":"Dave_Hoskins","description":"Grassy fields. Ray marches a ray to a smooth hill, then enters detailed stepping through a grass like distance, erm, field. :)\nNow uses eiffie's 'Circle of Confusion' function for blurred ray marching into the grass.\nThanks eiffie!\n","likes":198,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Rolling hills. By David Hoskins, November 2013.\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ https:\/\/www.shadertoy.com\/view\/Xsf3zX\n\n\/\/ v.2.00 Uses eiffie's 'Circle of Confusion' function\n\/\/\t\t  for blurred ray marching into the grass.\n\/\/ v.1.02 Camera aberrations.\n\/\/ v.1.01 Added better grass, with wind movement.\n\n\/\/ For red\/cyan 3D...\n\/\/#define STEREO\n\n#define THRESHOLD .003\n#define MOD2 vec2(3.07965, 7.4235)\nfloat PI  = 4.0*atan(1.0);\nvec3 sunLight  = normalize( vec3(  0.35, 0.2,  0.3 ) );\nvec3 cameraPos;\nvec3 sunColour = vec3(1.0, .75, .6);\nconst mat2 rotate2D = mat2(1.932, 1.623, -1.623, 1.952);\nfloat gTime = 0.0;\n\n\/\/--------------------------------------------------------------------------\n\/\/ Noise functions...\nfloat Hash( float p )\n{\n\tvec2 p2 = fract(vec2(p) \/ MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);\n}\n\n\/\/--------------------------------------------------------------------------\nfloat Hash(vec2 p)\n{\n\tp  = fract(p \/ MOD2);\n    p += dot(p.xy, p.yx+19.19);\n    return fract(p.x * p.y);\n}\n\n\n\/\/--------------------------------------------------------------------------\nfloat Noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0;\n    float res = mix(mix( Hash(n+  0.0), Hash(n+  1.0),f.x),\n                    mix( Hash(n+ 57.0), Hash(n+ 58.0),f.x),f.y);\n    return res;\n}\n\n\/\/  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n\/\/--------------------------------------------------------------------------\nvec2 Voronoi( in vec2 x )\n{\n\tvec2 p = floor( x );\n\tvec2 f = fract( x );\n\tfloat res=100.0;\n    vec2 id;\n\tfor( int j=-1; j<=1; j++ )\n\tfor( int i=-1; i<=1; i++ )\n\t{\n\t\tvec2 b = vec2( float(i), float(j) );\n\t\tvec2 r = b - f  + hash22( p + b );\n\t\tfloat d = dot(r,r);\n\t\tif( d < res )\n\t\t{\n\t\t\tres = d;\n\t\t\tid.x  = Hash(p+b);\n\t\t}\t\t\t\n    }\n\treturn vec2(max(.4-sqrt(res), 0.0),id.x);\n}\n\n\n\n\n\/\/--------------------------------------------------------------------------\nvec2 Terrain( in vec2 p)\n{\n\tfloat type = 0.0;\n\tvec2 pos = p*0.003;\n\tfloat w = 50.0;\n\tfloat f = .0;\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tf += Noise(pos) * w;\n\t\tw = w * 0.62;\n\t\tpos *= 2.5;\n\t}\n\n\treturn vec2(f, type);\n}\n\n\/\/--------------------------------------------------------------------------\nvec2 Map(in vec3 p)\n{\n\tvec2 h = Terrain(p.xz);\n    return vec2(p.y - h.x, h.y);\n}\n\n\/\/--------------------------------------------------------------------------\nfloat FractalNoise(in vec2 xy)\n{\n\tfloat w = .7;\n\tfloat f = 0.0;\n\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tf += Noise(xy) * w;\n\t\tw = w*0.6;\n\t\txy = 2.0 * xy;\n\t}\n\treturn f;\n}\n\n\/\/--------------------------------------------------------------------------\n\/\/ Grab all sky information for a given ray from camera\nvec3 GetSky(in vec3 rd)\n{\n\tfloat sunAmount = max( dot( rd, sunLight), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,0.0),6.);\n\tvec3  sky = mix(vec3(.1, .2, .3), vec3(.32, .32, .32), v);\n\tsky = sky + sunColour * sunAmount * sunAmount * .25;\n\tsky = sky + sunColour * min(pow(sunAmount, 800.0)*1.5, .3);\n\treturn clamp(sky, 0.0, 1.0);\n}\n\n\/\/--------------------------------------------------------------------------\n\/\/ Merge grass into the sky background for correct fog colouring...\nvec3 ApplyFog( in vec3  rgb, in float dis, in vec3 dir)\n{\n\tfloat fogAmount = clamp(dis*dis* 0.0000012, 0.0, 1.0);\n\treturn mix( rgb, GetSky(dir), fogAmount );\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 DE(vec3 p)\n{\n\tfloat base = Terrain(p.xz).x - 1.9;\n\tfloat height = Noise(p.xz*2.0)*.75 + Noise(p.xz)*.35 + Noise(p.xz*.5)*.2;\n\t\/\/p.y += height;\n\tfloat y = p.y - base-height;\n\ty = y*y;\n\tvec2 ret = Voronoi((p.xz*2.5+sin(y*2.0+p.zx*12.3)*.12+vec2(sin(iTime*1.3+1.5*p.z),sin(iTime*2.6+1.5*p.x))*y*.5));\n\tfloat f = ret.x * .65 + y * .5;\n\treturn vec3( y - f*1.4, clamp(f * 1.1, 0.0, 1.0), ret.y);\n}\n\n\/\/--------------------------------------------------------------------------\n\/\/ eiffie's code for calculating the aperture size for a given distance...\nfloat CircleOfConfusion(float t)\n{\n\treturn max(t * .04, (2.0 \/ iResolution.y) * (1.0+t));\n}\n\n\/\/--------------------------------------------------------------------------\nfloat Linstep(float a, float b, float t)\n{\n\treturn clamp((t-a)\/(b-a),0.,1.);\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 GrassBlades(in vec3 rO, in vec3 rD, in vec3 mat, in float dist)\n{\n\tfloat d = 0.0;\n\t\/\/ Only calculate cCoC once is enough here...\n\tfloat rCoC = CircleOfConfusion(dist*.3);\n\tfloat alpha = 0.0;\n\t\n\tvec4 col = vec4(mat*0.15, 0.0);\n\n\tfor (int i = 0; i < 15; i++)\n\t{\n\t\tif (col.w > .99) break;\n\t\tvec3 p = rO + rD * d;\n\t\t\n\t\tvec3 ret = DE(p);\n\t\tret.x += .5 * rCoC;\n\n\t\tif (ret.x < rCoC)\n\t\t{\n\t\t\talpha = (1.0 - col.y) * Linstep(-rCoC, rCoC, -ret.x);\/\/calculate the mix like cloud density\n\t\t\t\/\/ Mix material with white tips for grass...\n\t\t\tvec3 gra = mix(mat, vec3(.35, .35, min(pow(ret.z, 4.0)*35.0, .35)), pow(ret.y, 9.0)*.7) * ret.y;\n\t\t\tcol += vec4(gra * alpha, alpha);\n\t\t}\n\t\td += max(ret.x * .7, .1);\n\t}\n\tif(col.w < .2)\n\t\tcol.xyz = vec3(0.1, .15, 0.05);\n\treturn col.xyz;\n}\n\n\/\/--------------------------------------------------------------------------\n\/\/ Calculate sun light...\nvoid DoLighting(inout vec3 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float dis)\n{\n\tfloat h = dot(sunLight,normal);\n\tmat = mat * sunColour*(max(h, 0.0)+.2);\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 TerrainColour(vec3 pos, vec3 dir,  vec3 normal, float dis, float type)\n{\n\tvec3 mat;\n\tif (type == 0.0)\n\t{\n\t\t\/\/ Random colour...\n\t\tmat = mix(vec3(.0,.3,.0), vec3(.2,.3,.0), Noise(pos.xz*.025));\n\t\t\/\/ Random shadows...\n\t\tfloat t = FractalNoise(pos.xz * .1)+.5;\n\t\t\/\/ Do grass blade tracing...\n\t\tmat = GrassBlades(pos, dir, mat, dis) * t;\n\t\tDoLighting(mat, pos, normal,dir, dis);\n\t}\n\tmat = ApplyFog(mat, dis, dir);\n\treturn mat;\n}\n\n\/\/--------------------------------------------------------------------------\n\/\/ Home in on the surface by dividing by two and split...\n\/\/ Note, this does a much better job than using 'abs' on the distance march.\nfloat BinarySubdivision(in vec3 rO, in vec3 rD, float t, float oldT)\n{\n\tfloat halfwayT = 0.0;\n\tfor (int n = 0; n < 5; n++)\n\t{\n\t\thalfwayT = (oldT + t ) * .5;\n        float h = Map(rO + halfwayT*rD).x;\n        (h < THRESHOLD) ? t = halfwayT:oldT = halfwayT;\n  }\n\treturn t;\n}\n\n\/\/--------------------------------------------------------------------------\nbool Scene(in vec3 rO, in vec3 rD, out float resT, out float type )\n{\n    float t = 5.;\n\tfloat oldT = 0.0;\n\tfloat delta = 0.;\n\tfloat h = 0.0;\n\tbool hit = false;\n\tfor( int j=0; j < 60; j++ )\n\t{\n\t    vec3 p = rO + t*rD;\n\t\th = Map(p).x; \/\/ ...Get this position's height mapping.\n\n\t\t\/\/ Are we inside, and close enough to fudge a hit?...\n\t\tif( h < THRESHOLD)\n\t\t{\n\t\t\thit = true;\n            break;\n\t\t}\n        oldT = t;\n\t\tt +=  h + (t*0.04);\n\t}\n    type = 0.0;\n    resT = BinarySubdivision(rO, rD, t, oldT);\n\treturn hit;\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 CameraPath( float t )\n{\n\t\/\/t = time + t;\n    vec2 p = vec2(200.0 * sin(3.54*t), 200.0 * cos(2.0*t) );\n\treturn vec3(p.x+55.0,  12.0+sin(t*.3)*6.5, -94.0+p.y);\n} \n\n\/\/--------------------------------------------------------------------------\nvec3 PostEffects(vec3 rgb, vec2 xy)\n{\n\t\/\/ Gamma first...\n\trgb = pow(rgb, vec3(0.45));\n\t\n\t\/\/ Then...\n\t#define CONTRAST 1.1\n\t#define SATURATION 1.3\n\t#define BRIGHTNESS 1.3\n\trgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\n\t\/\/ Vignette...\n\trgb *= .4+0.5*pow(40.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.2 );\t\n\treturn rgb;\n}\n\n\/\/--------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat m = (iMouse.x\/iResolution.x)*300.0;\n\tfloat gTime = (iTime*5.0+m+2352.0)*.006;\n    vec2 xy = fragCoord.xy \/ iResolution.xy;\n\tvec2 uv = (-1.0 + 2.0 * xy) * vec2(iResolution.x\/iResolution.y,1.0);\n\tvec3 camTar;\n\t\n\tif (xy.y < .13 || xy.y >= .87)\n\t{\n\t\t\/\/ Top and bottom cine-crop - what a waste! :)\n\t\tfragColor=vec4(vec4(0.0));\n\t\treturn;\n\t}\n\n\t#ifdef STEREO\n\tfloat isCyan = mod(fragCoord.x + mod(fragCoord.y,2.0),2.0);\n\t#endif\n\n\tcameraPos = CameraPath(gTime + 0.0);\n    cameraPos.x -= 3.0;\n\tcamTar\t = CameraPath(gTime + .009);\n\tcameraPos.y += Terrain(CameraPath(gTime + .009).xz).x;\n\tcamTar.y = cameraPos.y;\n\t\n\tfloat roll = .4*sin(gTime+.5);\n\tvec3 cw = normalize(camTar-cameraPos);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = cross(cw,cp);\n\tvec3 cv = cross(cu,cw);\n\tvec3 dir = normalize(uv.x*cu + uv.y*cv + 1.3*cw);\n\tmat3 camMat = mat3(cu, cv, cw);\n\n\t#ifdef STEREO\n\tcameraPos += .85*cu*isCyan; \/\/ move camera to the right - the rd vector is still good\n\t#endif\n\n\tvec3 col;\n\tfloat distance;\n\tfloat type;\n\tif( !Scene(cameraPos, dir, distance, type) )\n\t{\n\t\t\/\/ Missed scene, now just get the sky...\n\t\tcol = GetSky(dir);\n\t}\n\telse\n\t{\n\t\t\/\/ Get world coordinate of landscape...\n\t\tvec3 pos = cameraPos + distance * dir;\n\t\t\/\/ Get normal from sampling the high definition height map\n\t\t\/\/ Use the distance to sample larger gaps to help stop aliasing...\n\t\tvec2 p = vec2(0.1, 0.0);\n\t\tvec3 nor  \t= vec3(0.0,\t\tTerrain(pos.xz).x, 0.0);\n\t\tvec3 v2\t\t= nor-vec3(p.x,\tTerrain(pos.xz+p).x, 0.0);\n\t\tvec3 v3\t\t= nor-vec3(0.0,\tTerrain(pos.xz-p.yx).x, -p.x);\n\t\tnor = cross(v2, v3);\n\t\tnor = normalize(nor);\n\n\t\t\/\/ Get the colour using all available data...\n\t\tcol = TerrainColour(pos, dir, nor, distance, type);\n\t}\n\t\n\t\/\/ bri is the brightness of sun at the centre of the camera direction.\n\t\/\/ Yeah, the lens flares is not exactly subtle, but it was good fun making it.\n\tfloat bri = dot(cw, sunLight)*.75;\n\tif (bri > 0.0)\n\t{\n\t\tvec2 sunPos = vec2( dot( sunLight, cu ), dot( sunLight, cv ) );\n\t\tvec2 uvT = uv-sunPos;\n\t\tuvT = uvT*(length(uvT));\n\t\tbri = pow(bri, 6.0)*.8;\n\n\t\t\/\/ glare = the red shifted blob...\n\t\tfloat glare1 = max(dot(normalize(vec3(dir.x, dir.y+.3, dir.z)),sunLight),0.0)*1.4;\n\t\t\/\/ glare2 is the yellow ring...\n\t\tfloat glare2 = max(1.0-length(uvT+sunPos*.5)*4.0, 0.0);\n\t\tuvT = mix (uvT, uv, -2.3);\n\t\t\/\/ glare3 is a purple splodge...\n\t\tfloat glare3 = max(1.0-length(uvT+sunPos*5.0)*1.2, 0.0);\n\n\t\tcol += bri * vec3(1.0, .0, .0)  * pow(glare1, 12.5)*.05;\n\t\tcol += bri * vec3(1.0, 1.0, 0.2) * pow(glare2, 2.0)*2.5;\n\t\tcol += bri * sunColour * pow(glare3, 2.0)*3.0;\n\t}\n\tcol = PostEffects(col, xy);\t\n\t\n\t#ifdef STEREO\t\n\tcol *= vec3( isCyan, 1.0-isCyan, 1.0-isCyan );\t\n\t#endif\n\t\n\tfragColor=vec4(col,1.0);\n}\n\n\/\/--------------------------------------------------------------------------","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4scGWj","date":"1452176909","viewed":15970,"name":"Electro","username":"sqrt_1","description":"Port of Humus Electro demo http:\/\/humus.name\/index.php?page=3D&ID=35","likes":128,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[],"code":"\/\/ Port of Humus Electro demo http:\/\/humus.name\/index.php?page=3D&ID=35\n\/\/ Not exactly right as the noise is wrong, but is the closest I could make it.\n\/\/ Uses Simplex noise by Nikita Miropolskiy https:\/\/www.shadertoy.com\/view\/XsX3zB\n\n\/* Simplex code license\n * This work is licensed under a \n * Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n * http:\/\/creativecommons.org\/licenses\/by-nc-sa\/3.0\/\n *  - You must attribute the work in the source code \n *    (link to https:\/\/www.shadertoy.com\/view\/XsX3zB).\n *  - You may not use this work for commercial purposes.\n *  - You may distribute a derivative work only under the same license.\n *\/\n\n\n\/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 *\/\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n\/* skew constants for 3d simplex functions *\/\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n\/* 3d simplex noise *\/\nfloat simplex3d(vec3 p) {\n\t \/* 1. find current tetrahedron T and it's four vertices *\/\n\t \/* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices *\/\n\t \/* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*\/\n\t \n\t \/* calculate s and x *\/\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t \/* calculate i1 and i2 *\/\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t \/* x1, x2, x3 *\/\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t \/* 2. find four surflets and store them in d *\/\n\t vec4 w, d;\n\t \n\t \/* calculate surflet weights *\/\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t \/* w fades from 0.6 at the center of the surflet to 0.0 at the margin *\/\n\t w = max(0.6 - w, 0.0);\n\t \n\t \/* calculate surflet components *\/\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t \/* multiply d by w^4 *\/\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t \/* 3. return the sum of the four surflets *\/\n\t return dot(d, vec4(52.0));\n}\n\nfloat noise(vec3 m) {\n    return   0.5333333*simplex3d(m)\n\t\t\t+0.2666667*simplex3d(2.0*m)\n\t\t\t+0.1333333*simplex3d(4.0*m)\n\t\t\t+0.0666667*simplex3d(8.0*m);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy \/ iResolution.xy;    \n  uv = uv * 2. -1.;  \n \n  vec2 p = fragCoord.xy\/iResolution.x;\n  vec3 p3 = vec3(p, iTime*0.4);    \n    \n  float intensity = noise(vec3(p3*12.0+12.0));\n                          \n  float t = clamp((uv.x * -uv.x * 0.16) + 0.15, 0., 1.);                         \n  float y = abs(intensity * -t + uv.y);\n    \n  float g = pow(y, 0.2);\n                          \n  vec3 col = vec3(1.70, 1.48, 1.78);\n  col = col * -g + col;                    \n  col = col * col;\n  col = col * col;\n                          \n  fragColor.rgb = col;                          \n  fragColor.w = 1.;  \n}\n\n\/* Origial shader and setup source\n\n!!ARBfp1.0\n\nOUTPUT output = result.color;\nTEMP glow, turb, y, t, mid;\n\nPARAM glowFallOff = 0.2;\nPARAM color = { 1.70, 1.48, 1.78, 0 };\n\nTEX\t\tturb, fragment.texcoord[0], texture[0], 3D;\nMAD\t\tturb.x, turb.x, 2, -1;\n\nMAD_SAT\tt.x, fragment.texcoord[1].y, -fragment.texcoord[1].y, 0.15;\n\nMAD\t\ty, turb.x, -t.x, fragment.texcoord[1].x;\nABS\t\ty, y;\n\nPOW\t\tglow.x, y.x, glowFallOff.x;\nMAD\t\tglow, -glow.x, color, color;\nMUL\t\tglow, glow, glow;\nMUL\t\toutput, glow, glow;\n\nEND \n*\/\n\n\/*\n\tfloat z = currTime * 0.8f;\n\tfloat y = z * 1.82f;\n\n\tglBegin(GL_TRIANGLE_STRIP);\n\t\tglMultiTexCoord3fARB(GL_TEXTURE0_ARB, -1, y - 1, z);\n\t\tglMultiTexCoord2fARB(GL_TEXTURE1_ARB,  1, -0.4f);\n\t\tglVertex2f(-1,  1);\n\t\tglMultiTexCoord3fARB(GL_TEXTURE0_ARB,  1, y - 1, z);\n\t\tglMultiTexCoord2fARB(GL_TEXTURE1_ARB,  1, 0.4f);\n\t\tglVertex2f( 1,  1);\n\t\tglMultiTexCoord3fARB(GL_TEXTURE0_ARB, -1, y,     z);\n\t\tglMultiTexCoord2fARB(GL_TEXTURE1_ARB,  0, -0.4f);\n\t\tglVertex2f(-1,  0);\n\t\tglMultiTexCoord3fARB(GL_TEXTURE0_ARB,  1, y,     z);\n\t\tglMultiTexCoord2fARB(GL_TEXTURE1_ARB,  0, 0.4f);\n\t\tglVertex2f( 1,  0);\n\t\tglMultiTexCoord3fARB(GL_TEXTURE0_ARB, -1, y - 1, z);\n\t\tglMultiTexCoord2fARB(GL_TEXTURE1_ARB, -1, -0.4f);\n\t\tglVertex2f(-1, -1);\n\t\tglMultiTexCoord3fARB(GL_TEXTURE0_ARB,  1, y - 1, z);\n\t\tglMultiTexCoord2fARB(GL_TEXTURE1_ARB, -1, 0.4f);\n\t\tglVertex2f( 1, -1);\n\tglEnd();\n\n*\/","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"llB3W1","date":"1428522186","viewed":15943,"name":"Fractal Audio 01","username":"relampago2048","description":"This shader is a render of the Julia Set, generated by audio input from microphone.","likes":112,"published":3,"flags":4,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"XdXGRr","filepath":"\/presets\/mic.png","previewfilepath":"\/presets\/mic.png","type":"mic","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"const int iters = 150;\n\nint fractal(vec2 p, vec2 point) {\n\tvec2 so = (-1.0 + 2.0 * point) * 0.4;\n\tvec2 seed = vec2(0.098386255 + so.x, 0.6387662 + so.y);\n\t\n\tfor (int i = 0; i < iters; i++) {\n\t\t\n\t\tif (length(p) > 2.0) {\n\t\t\treturn i;\n\t\t}\n\t\tvec2 r = p;\n\t\tp = vec2(p.x * p.x - p.y * p.y, 2.0* p.x * p.y);\n\t\tp = vec2(p.x * r.x - p.y * r.y + seed.x, r.x * p.y + p.x * r.y + seed.y);\n\t}\n\t\n\treturn 0;\t\n}\n\nvec3 color(int i) {\n\tfloat f = float(i)\/float(iters) * 2.0;\n\tf=f*f*2.;\n\treturn vec3((sin(f*2.0)), (sin(f*3.0)), abs(sin(f*7.0)));\n}\n\n\nfloat sampleMusicA() {\n\treturn 0.5 * (\n\t\ttexture( iChannel0, vec2( 0.15, 0.25 ) ).x + \n\t\ttexture( iChannel0, vec2( 0.30, 0.25 ) ).x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    vec2 mouse = vec2(iMouse.x\/iResolution.x,iMouse.y\/iResolution.y);\n    \n    vec2 position = 3. * (-0.5 + fragCoord.xy \/ iResolution.xy );\n\tposition.x *= iResolution.x\/iResolution.y;\n    \n    vec2 iFC = vec2(iResolution.x-fragCoord.x,iResolution.y-fragCoord.y);    \n    vec2 pos2 = 2. * (-0.5 + iFC.xy \/ iResolution.xy);\n    pos2.x*=iResolution.x\/iResolution.y;\n    \n    vec4 t3 = texture(iChannel0, vec2(length(position)\/2.0,0.1) );\n    float pulse = 0.5+sampleMusicA()*1.8;\n\n    vec3 invFract = color(fractal(pos2,vec2(0.55+sin(iTime\/3.+0.5)\/2.0,pulse*.9)));\n    \n    vec3 fract4 = color(fractal(position\/1.6,vec2(0.6+cos(iTime\/2.+0.5)\/2.0,pulse*.8)));\n\n    vec3 c = color(fractal(position,vec2(0.5+sin(iTime\/3.)\/2.0,pulse)));\n    \n    t3=abs(vec4(0.5,0.1,0.5,1.)-t3)*2.;\n    \n    vec4 fract01 =  vec4( c , 1.0 );\n    vec4 salida;\n    salida = fract01 \/ t3 + fract01 * t3 + vec4(invFract,0.6) + vec4(fract4,0.3);\n\tfragColor = salida;\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"llXGR4","date":"1418975438","viewed":15941,"name":"Antialiasing (sort of)","username":"iq","description":"More worms like in [url=https:\/\/www.shadertoy.com\/view\/XsjXR1]XsjXR1[\/url], but edge-antialiased (more or less)","likes":209,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Copyright Inigo Quilez, 2014 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work neither\n\/\/ as it is or altered, here on Shadertoy or anywhere else, in any\n\/\/ form including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it or train a neural\n\/\/ network with it without permission. I share this Work for educational\n\/\/ purposes, and you can link to it, through an URL, proper attribution\n\/\/ and unmodified screenshot, as part of your educational material. If\n\/\/ these conditions are too restrictive please contact me and we'll\n\/\/ definitely work it out.\n\n\/\/ An edge antialising experiment (not multisampling used)\n\n#define ANTIALIASING\n\nvec2 sincos( float x ) { return vec2( sin(x), cos(x) ); }\n\nvec2 sdSegment( in vec3 p, in vec3 a, in vec3 b )\n{\n    vec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa-ba*h ), h );\n}\n\nvec3 opU( vec3 d1, vec3 d2 ) { return (d1.x<d2.x) ? d1 : d2; }\n\nvec3 map( vec3 p )\n{\n    vec2 id = floor( (p.xz+1.0)\/2.0);\n    p.xz = mod( p.xz+1.0, 2.0 ) - 1.0;\n    \n    float ph = sin(0.5 + 3.1*id.x + sin(7.1*id.y));\n    \n    p.xz += 0.5*sincos(1.0+0.5*iTime+(p.y+11.0*ph)*0.8);\n\n    vec3 p1 = p; p1.xz += 0.15*sincos(1.0*p.y-1.0*iTime+0.0);\n    vec3 p2 = p; p2.xz += 0.15*sincos(1.0*p.y-1.0*iTime+2.0);\n    vec3 p3 = p; p3.xz += 0.15*sincos(1.0*p.y-1.0*iTime+4.0);\n    \n    vec2 h1 = sdSegment(p1, vec3(0.0,-50.0, 0.0), vec3(0.0, 50.0, 0.0) );\n    vec2 h2 = sdSegment(p2, vec3(0.0,-50.0, 0.0), vec3(0.0, 50.0, 0.0) );\n    vec2 h3 = sdSegment(p3, vec3(0.0,-50.0, 0.0), vec3(0.0, 50.0, 0.0) );\n    \n    return opU( opU( vec3(h1.x-0.12,                                         ph + 0.0\/3.0, h1.y), \n                     vec3(h2.x-0.12-0.05*cos( 500.0*h2.y - iTime*4.0), ph + 1.0\/3.0, h2.y) ), \n                     vec3(h3.x-0.12-0.02*cos(2000.0*h3.y - iTime*4.0), ph + 2.0\/3.0, h3.y) );\n}\n\n\/\/-------------------------------------------------------\n\nvec3 calcNormal( in vec3 pos, in float dt )\n{\n    vec2 e = vec2(1.0,-1.0)*dt;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nfloat calcOcc( in vec3 pos, in vec3 nor )\n{\n    const float h = 0.15;\n\tfloat ao = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        vec3 dir = sin( float(i)*vec3(1.0,7.13,13.71)+vec3(0.0,2.0,4.0) );\n        dir = dir + 2.5*nor*max(0.0,-dot(nor,dir));            \n        float d = map( pos + h*dir ).x;\n        ao += max(0.0,h-d);\n    }\n    return clamp( 1.0 - 0.7*ao, 0.0, 1.0 );\n}\n\n\/\/-------------------------------------------------------\nvec3 shade( in float t, in float m, in float v, in vec3 ro, in vec3 rd )\n{\n    float px = 0.0001;\/\/(2.0\/iResolution.y)*(1.0\/3.0);\n    float eps = px*t;\n\n    vec3  pos = ro + t*rd;\n    vec3  nor = calcNormal( pos, eps );\n    float occ = calcOcc( pos, nor );\n\n    vec3 col = 0.5 + 0.5*cos( m*vec3(1.4,1.2,1.0) + vec3(0.0,1.0,2.0) );\n    col += 0.05*nor;\n    col = clamp( col, 0.0, 1.0 );\n    col *= 1.0 + 0.5*nor.x;\n    col += 0.2*clamp(1.0+dot(rd,nor),0.0,1.0);\n    col *= 1.4;\n    col *= occ;\n    col *= exp( -0.15*t );\n    col *= 1.0 - smoothstep( 15.0, 35.0, t );\n    \n    return col;\n}\n\n\/\/-------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = (-iResolution.xy+2.0*fragCoord.xy)\/iResolution.y;\n    \n\tvec3 ro = 0.6*vec3(2.0,-3.0, 4.0);\n\tvec3 ta = 0.5*vec3(0.0, 4.0,-4.0);\n    \n    float fl = 1.0;\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize( cross( vec3(1.0,0.0,0.0), ww ) );\n    vec3 vv = normalize( cross(ww,uu) );\n    vec3 rd = normalize( p.x*uu + p.y*vv + fl*ww );\n\t\n    float px = (2.0\/iResolution.y)*(1.0\/fl);\n    \n    vec3 col = vec3(0.0);\n\n    \/\/---------------------------------------------\n    \/\/ raymach loop\n    \/\/---------------------------------------------\n    const float maxdist = 32.0;\n\n    vec3 res = vec3(-1.0);\n    float t = 0.0;\n    #ifdef ANTIALIASING\n    vec3 oh = vec3(0.0);\n    vec4 tmp = vec4(0.0);\n    #endif\n    \n    for( int i=0; i<128; i++ )\n    {\n\t    vec3 h = map( ro + t*rd );\n        float th1 = px*t;\n        #ifndef ANTIALIASING\n        th1 *= 1.5;\n        #endif\n        res = vec3( t, h.yz );\n        if( h.x<th1 || t>maxdist ) break;\n\n        \n        #ifdef ANTIALIASING\n        float th2 = px*t*2.0;\n        if( (h.x<th2) && (h.x>oh.x) )\n        {\n            float lalp = 1.0 - (h.x-th1)\/(th2-th1);\n            vec3  lcol = shade( t, oh.y, oh.z, ro, rd );\n            tmp.xyz += (1.0-tmp.w)*lalp*lcol;\n            tmp.w   += (1.0-tmp.w)*lalp;\n            if( tmp.w>0.99 ) break;\n        }\n        oh = h;\n        #endif\n        \n        t += min( h.x, 0.5 )*0.5;\n    }\n    \n    if( t < maxdist )\n        col = shade( res.x, res.y, res.z, ro, rd );\n    \n    #ifdef ANTIALIASING\n\tcol = mix( col, tmp.xyz\/(0.001+tmp.w), tmp.w );\n    #endif\n \n    \/\/---------------------------------------------\n    \n    col = pow( col, vec3(0.5,0.7,0.5) );\n    \n    vec2 q = fragCoord.xy\/iResolution.xy;\n    col *= pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.1);\n    \n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"MdlXRS","date":"1403494492","viewed":15924,"name":"Noise animation - Flow","username":"nimitz","description":"Playing with different ways of animating noise. In this version, the noise is made using a technique similar to \"flow noise\" (maybe it even qualifies as flow noise)","likes":266,"published":1,"flags":0,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"\/media\/a\/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"\/media\/ap\/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\/\/ Noise animation - Flow\n\/\/ 2014 by nimitz (twitter: @stormoid)\n\/\/ https:\/\/www.shadertoy.com\/view\/MdlXRS\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\/\/ Contact the author for other licensing options\n\n\n\/\/Somewhat inspired by the concepts behind \"flow noise\"\n\/\/every octave of noise is modulated separately\n\/\/with displacement using a rotated vector field\n\n\/\/normalization is used to created \"swirls\"\n\/\/usually not a good idea, depending on the type of noise\n\/\/you are going for.\n\n\/\/Sinus ridged fbm is used for better effect.\n\n#define time iTime*0.1\n#define tau 6.2831853\n\nmat2 makem2(in float theta){float c = cos(theta);float s = sin(theta);return mat2(c,-s,s,c);}\nfloat noise( in vec2 x ){return texture(iChannel0, x*.01).x;}\nmat2 m2 = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat grid(vec2 p)\n{\n\tfloat s = sin(p.x)*cos(p.y);\n\treturn s;\n}\n\nfloat flow(in vec2 p)\n{\n\tfloat z=2.;\n\tfloat rz = 0.;\n\tvec2 bp = p;\n\tfor (float i= 1.;i < 7.;i++ )\n\t{\n\t\tbp += time*1.5;\n\t\tvec2 gr = vec2(grid(p*3.-time*2.),grid(p*3.+4.-time*2.))*0.4;\n\t\tgr = normalize(gr)*0.4;\n\t\tgr *= makem2((p.x+p.y)*.3+time*10.);\n\t\tp += gr*0.5;\n\t\t\n\t\trz+= (sin(noise(p)*8.)*0.5+0.5) \/z;\n\t\t\n\t\tp = mix(bp,p,.5);\n\t\tz *= 1.7;\n\t\tp *= 2.5;\n\t\tp*=m2;\n\t\tbp *= 2.5;\n\t\tbp*=m2;\n\t}\n\treturn rz;\t\n}\n\nfloat spiral(vec2 p,float scl) \n{\n\tfloat r = length(p);\n\tr = log(r);\n\tfloat a = atan(p.y, p.x);\n\treturn abs(mod(scl*(r-2.\/scl*a),tau)-1.)*2.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy \/ iResolution.xy-0.5;\n\tp.x *= iResolution.x\/iResolution.y;\n\tp*= 3.;\n\tfloat rz = flow(p);\n\tp \/= exp(mod(time*3.,2.1));\n\trz *= (6.-spiral(p,3.))*.9;\n\tvec3 col = vec3(.2,0.07,0.01)\/rz;\n\tcol=pow(abs(col),vec3(1.01));\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4d2cWd","date":"1495084406","viewed":15914,"name":"Splitting DNA","username":"BigWIngs","description":"DNA. See comments for details. Hope you like!","likes":156,"published":1,"flags":64,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"Mlf3WB","filepath":"https:\/\/soundcloud.com\/free-tracks-downloads\/gus-gus-selfoss-deepfunks","previewfilepath":"https:\/\/soundcloud.com\/free-tracks-downloads\/gus-gus-selfoss-deepfunks","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Splitting DNA by Martijn Steinrucken aka BigWings - 2017\n\/\/ Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/\n\/\/ Its still a little slow. I tried a bunch of things to optimize:\n\/\/ Using raytracing, instead of marching:  works, is significantly faster but I couldn't get rid of artifacts. \n\/\/ Using bounding volumes: makes it a little bit faster, though not nearly as much as I had hoped.\n\/\/ Only calculating the color once in the end: should save a ton of mix-es, not noticably faster\n\/\/ Skipping to the next strand when marching away from current one: works, makes it a little faster\n\/\/ Mirroring the backbone: doesn't have any noticable effect\n\/\/\n\/\/ Took me a loong time to figure out the atomic structure of the bases, its not easy to figure \n\/\/ out from 2d pictures, I might very well have made a mistake.\n\/\/\n\/\/ Use the mouse to look around a little bit.\n\/\/\n\/\/ Anyways, worked on this for too long already, gotta ship it. Hope you like!\n\n\n#define INVERTMOUSE -1.\n\n\/\/ comment out to see one basepair by itself\n#define STRANDS\n\n#define MAX_INT_STEPS 100\n\n#define MIN_DISTANCE 0.1\n#define MAX_DISTANCE 1000.\n#define RAY_PRECISION .1\n\n#define OPTIMIZED\n#define USE_BOUNDING_VOLUMES\n\/\/ set to -1 to see bounding spheres\n#define SHOW_BOUNDING_VOLUMES 1.  \n\n#define S(x,y,z) smoothstep(x,y,z)\n#define B(x,y,z,w) S(x-z, x+z, w)*S(y+z, y-z, w)\n#define sat(x) clamp(x,0.,1.)\n#define SIN(x) sin(x)*.5+.5\n\nfloat smth = .6;\nfloat hr = 1.;\t\t\t\t\t\/\/ radii of atoms\nfloat nr = 2.264;\nfloat cr = 2.674;\nfloat or = 2.102;\nfloat pr = 3.453;\n\nvec3 hc = vec3(1.);\t\t\t\t\/\/ colors of atoms\nvec3 nc = vec3(.1, .1, 1.);\nvec3 cc = vec3(.1);\nvec3 oc = vec3(1., .1, .1);\nvec3 pc = vec3(1., .75, .3);\n\nconst vec3 lf=vec3(1., 0., 0.);\nconst vec3 up=vec3(0., 1., 0.);\nconst vec3 fw=vec3(0., 0., 1.);\n\nconst float halfpi = 1.570796326794896619;\nconst float pi = 3.141592653589793238;\nconst float twopi = 6.283185307179586;\n\n\nvec3 bg = vec3(.1, .5, 1.); \/\/ global background color\n\nfloat L2(vec3 p) {return dot(p, p);}\nfloat L2(vec2 p) {return dot(p, p);}\n\nfloat N1( float x ) { return fract(sin(x)*5346.1764); }\nfloat N2(float x, float y) { return N1(x + y*23414.324); }\n\nfloat N3(vec3 p) {\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nvec3 N31(float p) {\n    \/\/  3 out, 1 in... DAVE HOSKINS\n   vec3 p3 = fract(vec3(p) * vec3(.1031,.11369,.13787));\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n\nstruct ray {\n    vec3 o;\n    vec3 d;\n};\n\nstruct camera {\n    vec3 p;\t\t\t\/\/ the position of the camera\n    vec3 forward;\t\/\/ the camera forward vector\n    vec3 left;\t\t\/\/ the camera left vector\n    vec3 up;\t\t\/\/ the camera up vector\n\t\n    vec3 center;\t\/\/ the center of the screen, in world coords\n    vec3 i;\t\t\t\/\/ where the current ray intersects the screen, in world coords\n    ray ray;\t\t\/\/ the current ray: from cam pos, through current uv projected on screen\n    vec3 lookAt;\t\/\/ the lookat point\n    float zoom;\t\t\/\/ the zoom factor\n};\n\nstruct de {\n    \/\/ data type used to pass the various bits of information used to shade a de object\n\tfloat d;\t\/\/ distance to the object\n    float m; \t\/\/ material\n    vec3 col;\n    \n    vec3 id;\n    float spread;\n    \/\/ shading parameters\n    vec3 pos;\t\t\/\/ the world-space coordinate of the fragment\n    vec3 nor;\t\t\/\/ the world-space normal of the fragment\n    vec3 rd;\n    float fresnel;\t\n};\n    \nstruct rc {\n    \/\/ data type used to handle a repeated coordinate\n\tvec3 id;\t\/\/ holds the floor'ed coordinate of each cell. Used to identify the cell.\n    vec3 h;\t\t\/\/ half of the size of the cell\n    vec3 p;\t\t\/\/ the repeated coordinate\n    vec3 c;\t\t\/\/ the center of the cell, world coordinates\n};\n    \nrc Repeat(vec3 pos, vec3 size) {\n\trc o;\n    o.h = size*.5;\t\t\t\t\t\n    o.id = floor(pos\/size);\t\t\t\/\/ used to give a unique id to each cell\n    o.p = mod(pos, size)-o.h;\n    o.c = o.id*size+o.h;\n    \n    return o;\n}\n    \ncamera cam;\n\n\nvoid CameraSetup(vec2 uv, vec3 position, vec3 lookAt, float zoom) {\n\t\n    cam.p = position;\n    cam.lookAt = lookAt;\n    cam.forward = normalize(cam.lookAt-cam.p);\n    cam.left = cross(up, cam.forward);\n    cam.up = cross(cam.forward, cam.left);\n    cam.zoom = zoom;\n    \n    cam.center = cam.p+cam.forward*cam.zoom;\n    cam.i = cam.center+cam.left*uv.x+cam.up*uv.y;\n    \n    cam.ray.o = cam.p;\t\t\t\t\t\t\/\/ ray origin = camera position\n    cam.ray.d = normalize(cam.i-cam.p);\t\/\/ ray direction is the vector from the cam pos through the point on the imaginary screen\n}\n\nfloat remap01(float a, float b, float t) { return (t-a)\/(b-a); }\n\n\n\/\/ DE functions from IQ\n\/\/ https:\/\/www.shadertoy.com\/view\/Xds3zN\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)\/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 smin2( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)\/k, 0.0, 1.0 );\n    return vec2(mix( b, a, h ) - k*h*(1.0-h), h);\n}\n\nfloat smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)\/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\nfloat sdSphere( vec3 p, vec3 pos, float s ) { return (length(p-pos)-s)*.9; }\n\n\nvec3 background(vec3 r) {\n\tfloat y = pi*0.5-acos(r.y);  \t\t\/\/ from -1\/2pi to 1\/2pi\t\t\n    \n    return bg*(1.+y);\n}\n\nvec4 Adenine(vec3 p, float getColor) {\n   #ifdef USE_BOUNDING_VOLUMES\n    float b = sdSphere(p, vec3(29.52, 6.64, 3.04), 11.019);\n    \n    if(b>0.)\n        return vec4(bg, b+SHOW_BOUNDING_VOLUMES);\n    else {\n #endif\n    \n    float h =  sdSphere(p, vec3(22.44, 13.63, 3.04), hr);\n    h = min(h, sdSphere(p, vec3(21.93, 0.28, 3.04), hr));\n    h = min(h, sdSphere(p, vec3(26.08, -1.19, 3.04), hr));\n    h = min(h, sdSphere(p, vec3(39.04, 3.98, 3.04), hr));\n    \n    float n =  sdSphere(p, vec3(23.18, 7.49, 3.04), nr);\n    n = min(n, sdSphere(p, vec3(28.39, 11.95, 3.04), nr));\n    n = min(n, sdSphere(p, vec3(24.43, 0.75, 3.04), nr));\n    n = min(n, sdSphere(p, vec3(32.79, 2.79, 3.04), nr));\n    n = min(n, sdSphere(p, vec3(34.93, 8.83, 3.04), nr));\n    \n    float c =  sdSphere(p, vec3(24.50, 11.22, 3.04), cr);\n    c = min(c, sdSphere(p, vec3(25.75, 4.47, 3.04), cr));\n    c = min(c, sdSphere(p, vec3(29.65, 5.2, 3.04), cr));\n    c = min(c, sdSphere(p, vec3(30.97, 8.93, 3.04), cr));\n    c = min(c, sdSphere(p, vec3(36.06, 5.03, 3.04), cr));\n    \n    \n        vec3 col = vec3(0.);\n        float d;\n\n        if(getColor!=0.) {\n            vec2 i = smin2(h, n, smth);\n            col = mix(nc, hc, i.y);        \n\n            i = smin2(i.x, c, smth);\n            col = mix(cc, col, i.y);\n\n            d = i.x;\n        } else\n            d = smin(c, smin(h, n, smth), smth);\n\n        return vec4(col, d);\n    #ifdef USE_BOUNDING_VOLUMES\n    }\n    #endif\n}\n\nvec4 Thymine(vec3 p, float getColor) {\n\n #ifdef USE_BOUNDING_VOLUMES\n    float b = sdSphere(p, vec3(12.96, 5.55, 3.04), 10.466);\n    \n    if(b>0.)\n        return vec4(bg, b+SHOW_BOUNDING_VOLUMES);\n    else {\n #endif\n    float o =  sdSphere(p, vec3(18.171, -.019, 3.04), or);\n    o = min(o, sdSphere(p, vec3(15.369, 13.419, 3.04), or));\n    \n    float h =  sdSphere(p, vec3(19.253, 7.218, 3.04), hr);\n    h = min(h, sdSphere(p, vec3(12.54, -3.449, 4.534), hr));\n    h = min(h, sdSphere(p, vec3(7.625, -1.831, 4.533), hr));\n    h = min(h, sdSphere(p, vec3(10.083, -2.64, 0.052), hr));\n    \n    float n =  sdSphere(p, vec3(16.77, 6.7, 3.04), nr);\n    n = min(n, sdSphere(p, vec3(10.251, 8.846, 3.04), nr));\n    \n    float c =  sdSphere(p, vec3(10.541, -1.636, 3.04), cr);\n    c = min(c, sdSphere(p, vec3(11.652, 2.127, 3.04), cr));\n    c = min(c, sdSphere(p, vec3(15.531, 2.936, 3.04), cr));\n    c = min(c, sdSphere(p, vec3(9.012, 5.082, 3.04), cr));\n    c = min(c, sdSphere(p, vec3(14.13, 9.655, 3.04), cr));\n    \n\n        vec3 col = vec3(0.);\n        float d;\n\n        if(getColor!=0.) {\n            vec2 i = smin2(h, n, smth);\n            col = mix(nc, hc, i.y);        \n\n            i = smin2(i.x, c, smth);\n            col = mix(cc, col, i.y);\n\n            i = smin2(i.x, o, smth);\n            col = mix(oc, col, i.y);\n\n            d = i.x;\n        } else\n            d = smin(o, smin(c, smin(h, n, smth), smth), smth);\n\n        return vec4(col, d);\n    #ifdef USE_BOUNDING_VOLUMES\n    }\n    #endif\n}\n\n\n\n\nvec4 Cytosine(vec3 p, float getColor) {\n\n #ifdef USE_BOUNDING_VOLUMES\n    float b = sdSphere(p, vec3(14.556, 5.484, 3.227), 10.060);\n    if(b>0.)\n        return vec4(bg, b+SHOW_BOUNDING_VOLUMES);\n    else {\n #endif\n        \n        float c = sdSphere(p, vec3(11.689, 1.946, 3.067), cr);\n        c = min(c, sdSphere(p, vec3(15.577, 2.755, 3.067), cr));\n        c = min(c, sdSphere(p, vec3(14.176, 9.474, 3.067), cr));\n        c = min(c, sdSphere(p, vec3(9.058, 4.9, 3.067), cr));\n\n        float n = sdSphere(p, vec3(18.412, 0.342, 3.067), nr);\n        n = min(n, sdSphere(p, vec3(16.816, 6.519, 3.067), nr));\n        n = min(n, sdSphere(p, vec3(10.297, 8.665, 3.067), nr));\n\n        float h = sdSphere(p, vec3(6.526, 3.015, 3.067), hr);\n        h = min(h, sdSphere(p, vec3(10.61, -1.045, 3.067), hr));\n        h = min(h, sdSphere(p, vec3(18.805, -2.297, 3.067), hr));\n        h = min(h, sdSphere(p, vec3(20.95, 0.584, 3.067), hr));\n\n\n        float o = sdSphere(p, vec3(15.415, 13.237, 3.067), or);\n\n        vec3 col = vec3(1.);\n\n        float d;\n        \n        if(getColor!=0.) {\n            vec2 i = smin2(c, n, smth);\n            col = mix(nc, cc, i.y);        \n\n            i = smin2(i.x, h, smth);\n            col = mix(hc, col, i.y);\n\n            i = smin2(i.x, o, smth);\n            col = mix(oc, col, i.y);\n            \n            d = i.x;\n        } else\n            d = smin(o, smin(h, smin(c, n, smth), smth), smth);\n        \n        return vec4(col, d);\n    #ifdef USE_BOUNDING_VOLUMES\n    }\n    #endif\n}\n\nvec4 Guanine(vec3 p, float getColor) {\n\n #ifdef USE_BOUNDING_VOLUMES\n    float b = sdSphere(p, vec3(29.389, 8.944, 3.227), 12.067);\n    \n    if(b>0.)\n        return vec4(bg, b+SHOW_BOUNDING_VOLUMES);\n    else {\n #endif\n        \n        float c = sdSphere(p, vec3(24.642, 11.602, 3.067), cr);\n        c = min(c, sdSphere(p, vec3(31.111, 9.311, 3.067), cr));\n        c = min(c, sdSphere(p, vec3(29.79, 5.576, 3.067), cr));\n        c = min(c, sdSphere(p, vec3(25.893, 4.854, 3.067), cr));\n        c = min(c, sdSphere(p, vec3(36.19, 5.409, 3.067), cr));\n\n        float n = sdSphere(p, vec3(22.56, 14.31, 3.067), nr);\n        n = min(n, sdSphere(p, vec3(23.32, 7.867, 3.067), nr));\n        n = min(n, sdSphere(p, vec3(28.538, 12.325, 3.067), nr));\n        n = min(n, sdSphere(p, vec3(32.934, 3.164, 3.067), nr));\n        n = min(n, sdSphere(p, vec3(35.07, 9.209, 3.067), nr));\n\n        float h = sdSphere(p, vec3(20.044, 14.723, 3.04), hr);\n        h = min(h, sdSphere(p, vec3(22.852, 16.965, 3.04), hr));\n        h = min(h, sdSphere(p, vec3(20.856, 7.404, 3.067), hr));\n        h = min(h, sdSphere(p, vec3(39.187, 4.352, 3.067), hr));\n\n\n        float o = sdSphere(p, vec3(24.7, 1.893, 3.067), or);\n\n        vec3 col = vec3(1.);\n        \n        float d;\n        \n        if(getColor!=0.) {\n            vec2 i = smin2(c, n, smth);\n            col = mix(nc, cc, i.y);        \n\n            i = smin2(i.x, h, smth);\n            col = mix(hc, col, i.y);\n\n            i = smin2(i.x, o, smth);\n            col = mix(oc, col, i.y);\n            \n            d = i.x;\n        } else\n            d = smin(o, smin(h, smin(c, n, smth), smth), smth);\n        \n        return vec4(col, d);\n    #ifdef USE_BOUNDING_VOLUMES\n    }\n    #endif\n}\n\n\nvec4 Backbone(vec3 p, float getColor) {\n\n #ifdef USE_BOUNDING_VOLUMES\n    float b = sdSphere(p, vec3(0., 7.03, 0.), 10.572);   \n    if(b>0.)\n        return vec4(bg, b+SHOW_BOUNDING_VOLUMES);\n    else {\n #endif       \n        float c = sdSphere(p, vec3(1.391, 8.476, -0.708), cr);\n        c = min(c, sdSphere(p, vec3(5.173, 9.661, -0.708), cr));\n        c = min(c, sdSphere(p, vec3(6.342, 10.028, 3.061), cr));\n        c = min(c, sdSphere(p, vec3(0.222, 8.109, 3.061), cr));\n        c = min(c, sdSphere(p, vec3(0.658, 4.4, 4.8871), cr));\n\n        float h = sdSphere(p, vec3(-5.853, 0., 2.213), hr);\n        h = min(h, sdSphere(p, vec3(5.4512, 12.437, -2.216), hr));\n        h = min(h, sdSphere(p, vec3(6.986, 7.541, -2.216), hr));\n        h = min(h, sdSphere(p, vec3(-1.726, 10.517, 4.39), hr));\n        h = min(h, sdSphere(p, vec3(3.203, 2.519, 4.691), hr));\n        h = min(h, sdSphere(p, vec3(-1.619, 3.162, 3.063), hr));\n\n        float o = sdSphere(p, vec3(-4.918, 1.599, 0.344), or);\n        o = min(o, sdSphere(p, vec3(-1.471, 0.995, -5.1), or));\n        o = min(o, sdSphere(p, vec3(-0.836, 6.288, -1.438), or));\n        o = min(o, sdSphere(p, vec3(3.282, 9.068, 5.391), or));\n        o = min(o, sdSphere(p, vec3(-6.286, 5.299, -4.775), or));\n        \n        float ph = sdSphere(p, vec3(-3.377, 3.544, -2.742), pr);\n\t\t\n        #ifdef STRANDS\n        o = min(o, sdSphere(p, vec3(-6.286, 5.299, 6.558), or));\n        ph = min(ph, sdSphere(p, vec3(-3.377, 3.544, 8.592), pr)); \/\/ extra so it tiles better\n        #endif\n        \n        vec3 col = vec3(1.);\n\t\tfloat d;\n        \n        if(getColor!=0.) {\n            vec2 i = smin2(c, h, smth);\n            col = mix(hc, cc, i.y);        \n\n            i = smin2(i.x, o, smth);\n            col = mix(oc, col, i.y);\n\n            i = smin2(i.x, ph, smth);\n            col = mix(pc, col, i.y);\n            \n            d = i.x;\n        } else\n            d = smin(ph, smin(o, smin(c, h, smth), smth), smth);\n        \n        return vec4(col, d);\n  #ifdef USE_BOUNDING_VOLUMES      \n    }\n  #endif  \n}\n\n\n\n\nvec4 map( vec3 p, vec3 id, float spread, float getColor ) {\n    \n    p.z += 2.4;\/\/ offset so it tiles better\n    vec4 col;\n    \n    vec3 bp = p;    \n    bp.x = 22.5-bp.x;\n    float side = sign(bp.x);\n    bp.x = 22.5-abs(bp.x)+spread;\n    bp.z = bp.z*side - min(0., side)*5.;\n    vec4 b = Backbone(bp, getColor);\n    \n    vec4 c = vec4(1000.);\n    vec4 g = vec4(1000.);\n    vec3 cp = p;\n    vec3 gp = p;\n    \n    float n = N3(id);\n    \n    if(n<.5) {\n    \tcp.xz = -cp.xz + vec2(46., 6.);\n    \tgp.xz = -gp.xz + vec2(46., 6.);\n    }\n    cp.x += spread;\n    gp.x -= spread;\n    \n    if(mod(floor(n*4.), 2.)==0.) {\n    \tc = Cytosine(cp, getColor);\n    \tg = Guanine(gp, getColor);\n    } else {    \n    \tg = Adenine(gp, getColor);\n    \tc = Thymine(cp, getColor);\n    }\n  \n    col.a = min(b.a, min(c.a, g.a));\n  \n    if(getColor!=0.) {\n        if(col.a==b.a)\n            col.rgb = b.rgb;\t\n        else if(col.a==c.a)\n            col.rgb = c.rgb;\n        else\n            col.rgb = g.rgb;\n    }\n    \n    return col;\n}\n\n\nde castRay( ray r ) {\n    float t = iTime*.3;\n    \n    de o;\n    o.m = -1.0;\n    vec2 cbd = vec2(MIN_DISTANCE, MAX_DISTANCE);\n    vec2 bbd = cbd;\n    \n    vec4 col_pos;\n    \n    vec3 p = vec3(0.);\n    \n    float d = MIN_DISTANCE;\n    rc q;\n    vec3 center = vec3(19.12, 7.09, 3.09);\n    float spread;\n    \n    vec3 grid = vec3(180., 180., 11.331);\n    \n    #ifdef STRANDS\n    for( int i=0; i<MAX_INT_STEPS; i++ ) {\n        p = r.o+r.d*d;\n        float oz = p.z;\n        \n        q = Repeat(p, grid);\n        float sd = length((q.c.xy-center.xy));\n            \n        p.z += t*200.*S(800., 100., sd);\n        float n = N2(q.id.x, q.id.y);\n        \n        p.y += sin(n*twopi + p.z*.003+t)*50.*S(300., 500., sd);\n        \n        q = Repeat(p, grid);\n\t\t\n       \n        float z = oz*.05;\n        float z2 = smax(0., abs(oz*.03)-6., 2.);\n        float s = sin(z2);\n        float c = cos(z2);\n        \n        oz *= .012;\n        spread = max(0., 6.-oz*oz);\n        spread *= spread;\n        spread *= S(250., 1., length(q.id.xy*grid.xy+q.h.xy-r.o.xy));\n            \n        vec3 rC = ((2.*step(0., r.d)-1.)*q.h-q.p)\/r.d;\t\/\/ ray to cell boundary\n        float dC = min(min(rC.x, rC.y), rC.z)+.01;\t\t\/\/ distance to cell just past boundary\n        \n       \n        \n        float dS = MAX_DISTANCE;\n        \n        #ifdef OPTIMIZED\n        vec2 bla = q.p.xy-center.xy;\n        if(dot(bla, r.d.xy)>0. && length(bla)>50.)\t\/\/ if we are stepping away from the strand and we are already far enough\n        \tdC = min(rC.x, rC.y)+1.;\t\t\t\t\/\/ then we won't hit this strand anymore and we can skip to the next one\n        else {\n            #endif \n             q.p-=center;\n        mat2 m = mat2(c, -s, s, c);\n        q.p.xy *= m;\n        q.p+=center;\n            \n        \tdC = rC.z +.01;\n            dS = map( q.p, q.id, spread, 0. ).a;\n        #ifdef OPTIMIZED\n        } \n        #endif\n        \n            \n        if( dS<RAY_PRECISION || d>MAX_DISTANCE ) break;      \n        \n        d+=min(dS, dC);\t\/\/ move to distance to next cell or surface, whichever is closest\n    }\n    \n    #else\n\tq.id = vec3(0.);\n    spread = 0.;\n     for( int i=0; i<MAX_INT_STEPS; i++ ) {\n        p = r.o+r.d*d;\n         \n        col_pos = map( p, vec3(0.), 0., 0. );\n        float dS = col_pos.a;\n        if( dS<RAY_PRECISION || d>MAX_DISTANCE ) break;      \n       \n        d+=dS;\n    }\n    #endif\n    \n    if(d<MAX_DISTANCE) { \n        o.m=1.;\n        o.d = d;\n        o.id = q.id;\n        o.spread = spread;\n        #ifdef STRANDS\n        o.pos = q.p;\n        #else\n        o.pos = p;\n        #endif\n        \n        o.d = d;\n    }\n    return o;\n}\n\nvec4 nmap( de o, vec3 offs ) {\n   \n    return map(o.pos+offs, o.id, o.spread, 0.);\n}\n\nde GetSurfaceProps( de o )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 p = o.pos-eps.yyx;\n    vec4 c = map(p, o.id, o.spread, 1.);\n    o.col = c.rgb;\n    \n    vec3 nor = vec3(\n\t    nmap(o, eps.xyy).a - nmap(o, -eps.xyy).a,\n\t    nmap(o, eps.yxy).a - nmap(o, -eps.yxy).a,\n\t    nmap(o, eps.yyx).a - c.a );\n\to.nor = normalize(nor);\n    \n    return o;\n}\n\nvec3 AtomMat(de o, vec3 rd) {\n    o = GetSurfaceProps( o );\n    \n    vec3 R = reflect(cam.ray.d, o.nor);\n    vec3 ref = background(R);\n    \n    float dif = dot(up, o.nor)*.5+.5;\n    dif = mix(.3, 1., dif);\n    \n\tvec3 col = o.col*dif;\n    \n    float t = iTime*50.+length(o.col)*10.;\n\n    float fresnel = 1.-sat(dot(o.nor, -rd));\n    fresnel = pow(fresnel, .5);\n          \n    \n    \n    #ifdef STRANDS\n    float up = dot(rd, vec3(0., 1., 0.));\n    col = mix(col, ref, fresnel*.5*S(.8, .0, up));\n    col *= S(.9, .2, up);\n    #else  \n    col = mix(col, ref, fresnel*.5);\n    #endif\n    \n    col = mix(col, bg, S(0., 1000., o.d));\n\n    return col;\n}\n\nvec3 render( vec2 uv, ray camRay, float depth ) {\n    \/\/ outputs a color\n    \n    bg = background(cam.ray.d);\n    \n    vec3 col = bg;\n    de o = castRay(camRay);\n   \n    if(o.m>0.) {\n        col = AtomMat(o, cam.ray.d);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy \/ iResolution.xy);\n    uv -= .5;\n    uv.y *= iResolution.y\/iResolution.x;\n    vec2 m = iMouse.xy\/iResolution.xy;\n    \n\tfloat t = iTime;\n    \n   if(m.x==0.&&m.y==0.) m = vec2(.5, .5);\n    \n    \n    #ifdef STRANDS\n    float camDist = -4.;\n    \n    t = t * .2;\n    \n    float y = t*.5;;\n    float x = t;\n    vec3 camPos = vec3(-60.+sin(t)*180., -80.+sin(y)*250., 0.);\n    \n    m -= .5;\n    vec3 pos = vec3(-(cos(x)+m.x)*3., -(cos(y)+m.y)*3., camDist);\/\/*rotX;\n    #else\n    \n    float turn = (.1-m.x)*twopi+t*.0;\n    float s = sin(turn);\n    float c = cos(turn);\n    mat3 rotX = mat3(c,  0., s, 0., 1., 0., s,  0., -c);\n    \n    float camDist = -100.;\n    vec3 camPos = vec3(19., 0., 0.);\n    \n    vec3 pos = vec3(0., INVERTMOUSE*camDist*cos((m.y)*pi), camDist)*rotX;\n    #endif\n    \t\n    CameraSetup(uv, camPos+pos, camPos, 1.);\n    \n    vec3 col = render(uv, cam.ray, 0.);\n   \n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"lldGDr","date":"1469384349","viewed":15823,"name":"[SH16C] Doom","username":"P_Malin","description":"I had to change the controls as pressing Ctrl + W closes the window.\nCursors - Turn\nWASD - Move\nSpace - Fire\nEnter\/F - Open Door\nShift - Run\nAlt - Strafe\nL - Mouse look\nI - Invert Y\nTab - Map\n(see ReadControls() in  buffer C)","likes":129,"published":3,"flags":112,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"\/media\/previz\/buffer03.png","previewfilepath":"\/media\/previz\/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\/\/   _____ _               _           _               ______           ___  ___\n\/\/  \/  ___| |             | |         | |              |  _  \\          |  \\\/  |\n\/\/  \\ `--.| |__   __ _  __| | ___ _ __| |_ ___  _   _  | | | |___   ___ | .  . |\n\/\/   `--. \\ '_ \\ \/ _` |\/ _` |\/ _ \\ '__| __\/ _ \\| | | | | | | \/ _ \\ \/ _ \\| |\\\/| |\n\/\/  \/\\__\/ \/ | | | (_| | (_| |  __\/ |  | || (_) | |_| | | |\/ \/ (_) | (_) | |  | |\n\/\/  \\____\/|_| |_|\\__,_|\\__,_|\\___|_|   \\__\\___\/ \\__, | |___\/ \\___\/ \\___\/\\_|  |_\/\n\/\/                                               __\/ |                          \n\/\/                                              |___\/                           \n\n\/\/ https:\/\/www.shadertoy.com\/view\/lldGDr\n\n\/\/ @P_Malin\n\n\/\/ Entry for shadertoy 2016 competetion (Part C)\n\/\/ YouTube video here: https:\/\/www.youtube.com\/watch?v=ETDjQ1itiNE\n\n\/\/ I worked on this a lot after the week we had for the competition.\n\/\/ I think the earlier verion I submitted for the competition was like this\n\/\/ https:\/\/www.shadertoy.com\/view\/ldscz7\n\n\/\/ Note - Exit sign texture is disabled - enable it in Buffer D by removing #define LINUX_WORKAROUND\n\n\/\/ Comment out for faster rendering:\n#define HUD_MESSAGES\n#define FULL_HUD\n\n\/\/#define SHOW_SPRITES\n\/\/#define SHOW_MAP_DATA\n\n\/\/ Enables map on Tab key (slow):\n\/\/ Also need define in buf c\n#define ALLOW_MAP\n\/\/#define HIRES_MAP\n\n\/\/ Controls: \n\n\/\/ Press Space \/ Enter to Start!\n\/\/ Cursors - Turn\n\/\/ WASD - Move\n\/\/ Space - Fire\n\/\/ Enter\/F - Open Door\n\/\/ Shift - Run\n\/\/ Alt - Strafe\n\/\/ L - Mouse look\n\/\/ I - Invert Y\n\n\/\/ ( see ReadControls() in  buffer C )\n\n\n\/\/ Note: I've added a bunch of additional stuff to this shader since the competition deadline\n\/\/\n\/\/ * Fixed framerate issue on some machines\n\/\/ * Fixed some state machine timer logic\n\/\/ * Enemy sprites for different compass directions\n\/\/ * Changed aspect ratio\n\/\/ * Added mouse control + mouselook\n\/\/ * Sergeants carry shotguns\n\/\/ * Added sprites for more enemy states\n\/\/ * Fixed sky rendering\n\/\/ * Added viemodel\n\/\/ * Added enemy model textures sprites\n\/\/ * Added muzzle flash sprite\n\/\/ * Improved barrel explode sprite\n\/\/ * Impreove imp fireball sprite\n\/\/ * Improved HUD and added numbers font\n\/\/ * Added messages for pickups etc.\n\n\/\/ Music : https:\/\/soundcloud.com\/plasma3\/doom-remix-at-dooms-gate-level-1-theme-e1m1\n\n\/\/ Thanks to adx and morimea for investigating the linux version.\n\n\/\/ HUD \/ UI \/ Viewmodel\n\n#define MAP_CHANNEL iChannel0\n#define STATE_CHANNEL iChannel1\n\n\/\/ ----------------- 8< -------------------------- 8< -------------------------- 8< --------------\n\/\/ Common code follows\n\n#define NO_UNROLL(X) (X + min(0,iFrame))\n#define NO_UNROLLU(X) (X + uint(min(0,iFrame)))\n\nbool Map_PointInSector( sampler2D mapSampler, vec2 vPos, Sector sector )\n{\n    float fInOutTest = 0.0;\n    \n    for(int iSideDefIndex=0; iSideDefIndex< NO_UNROLL( sector.iSideDefCount ); iSideDefIndex++)\n    {        \n        SideDef sideDef = Map_ReadSideDefInfo( mapSampler, sector.iSectorId, iSideDefIndex );\n        \n        vec2 vPosToA = sideDef.vA - vPos;\n        vec2 vPosToB = sideDef.vB - vPos;\n        \n        if ( vPosToA.y > 0.0 && vPosToB.y > 0.0 )\n        \tcontinue;\n        if ( vPosToB.y <= 0.0 && vPosToA.y <= 0.0 )\n        \tcontinue;               \n        \n        float fCross = Cross2d( vPosToA, vPosToB );\n        if ( vPosToA.y > vPosToB.y )\n            fCross = -fCross;\n        if ( fCross < 0.0 )\n        {\n            fInOutTest++;\n        }        \n    }\n    \n    return mod( fInOutTest, 2.0 ) >= 1.0;    \n}\n\nbool Map_PointInSector( sampler2D mapSampler, MapInfo mapInfo, vec2 vPos, int iSectorId )\n{\n    if ( !Map_ValidSectorId(mapInfo, iSectorId) )\n    {\n        return false;\n    }\n\n    Sector sector = Map_ReadSector( mapSampler, iSectorId );\n\n    return Map_PointInSector( mapSampler, vPos, sector );\n}\n\nint Map_SeekSector( sampler2D mapSampler, MapInfo mapInfo, vec2 vPos )\n{    \n    for(int iSectorIndex=0; iSectorIndex<NO_UNROLL( mapInfo.iSectorCount ); iSectorIndex++)\n    {        \n        if ( Map_PointInSector( mapSampler, mapInfo, vPos, iSectorIndex ) )\n        {\n            return iSectorIndex;\n        }        \n    }\n\n    return SECTOR_NONE;\n}\n\n\nvoid Map_UpdateSector( sampler2D mapSampler, MapInfo mapInfo, vec2 vPrev, vec2 vPos, inout int iSectorId )\n{    \n    if ( vPrev == vPos )\n    {\n        return;\n    }\n    \n    if ( !Map_PointInSector( mapSampler, mapInfo, vPos, iSectorId ) )\n    {\n        int iNewSectorId = Map_SeekSector( mapSampler, mapInfo, vPos );\n        \n        if ( iNewSectorId != SECTOR_NONE )\n        {\n        \tiSectorId = iNewSectorId;\n        }                \n    }\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Trace\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nTraceResult Map_Trace( sampler2D mapSampler, MapInfo mapInfo, vec3 vRayOrigin, vec3 vRayDir, int iSectorId, float fMaxDist )\n{\n    TraceResult result;\n    \n    result.iTexture = 0u;\n    result.vTexture = vec3(0.0);\n    result.fDist = 0.0;\n    result.fLightLevel = 0.0;\n    result.iSector = SECTOR_NONE;\n    \n    while(true)\n    {\n        if ( iSectorId == SECTOR_NONE )\n        {\n            break;\n        }\n        \n        Sector sector = Map_ReadSector( mapSampler, iSectorId );\n        \n        TraceSectorState sectorState;\n        sectorState.iNextSector = SECTOR_NONE;        \n        sectorState.fEnterDist = result.fDist;\n        sectorState.bNoUpper = false;\n        result.fDist = fMaxDist;\n        result.iSector = iSectorId;\n        \n        for(int iSideDefIndex=0; iSideDefIndex<NO_UNROLL( sector.iSideDefCount); iSideDefIndex++)\n        {\n            SideDef sideDef = Map_ReadSideDefInfo( mapSampler, iSectorId, iSideDefIndex );                        \n\n            TraceSideDef( mapSampler, vRayOrigin, vRayDir, result, sectorState, sector, sideDef );\n        }\n\n        \/\/ Test floor \/ ceiling\n        if ( sectorState.fExitY < sector.fFloorHeight )\n        {\n            result.fDist = (sector.fFloorHeight - vRayOrigin.y) \/ vRayDir.y;\n            vec3 vFloorPos = vRayOrigin + vRayDir * result.fDist;\n            result.vTexture.st = vec2( vFloorPos.xz );\n            result.iTexture = sector.iFloorTexture;\n            result.fLightLevel = 0.0;\n            sectorState.iNextSector = SECTOR_NONE;\n        }\n        else\n        if ( sectorState.fExitY > sector.fCeilingHeight && !sectorState.bNoUpper )\n        {\n            result.fDist = (sector.fCeilingHeight - vRayOrigin.y) \/ vRayDir.y;\n            vec3 vCeilingPos = vRayOrigin + vRayDir * result.fDist;\n            result.vTexture.st = vec2( vCeilingPos.xz );\n            result.iTexture = sector.iCeilingTexture;\n            result.fLightLevel = 0.0;\n            sectorState.iNextSector = SECTOR_NONE;\n        }        \n\n        iSectorId = sectorState.iNextSector;\n    }\n    \n    if ( result.iTexture == 1u )\n        result.fDist = FAR_CLIP;\n    \n    return result;\n}\n\n\n\/\/ End of common code\n\/\/ ----------------- 8< -------------------------- 8< -------------------------- 8< --------------\n\n\n\/\/ ----------------- 8< -------------------------- 8< -------------------------- 8< --------------\n\/\/ Start of Font code\n\nconst ivec3 _SPACE_ = ivec3(0,0,5);\nconst ivec3 _EXCLAMATION_ = ivec3(49539,384,4);\nconst ivec3 _QUOTE_ = ivec3(2331,0,7);\nconst ivec3 _HASH_ = ivec3(167818,1311,7);\nconst ivec3 _DOLLAR_ = ivec3(508575,69524,7);\nconst ivec3 _PERCENT_ = ivec3(232984,4487,8);\nconst ivec3 _AMPERSAND_ = ivec3(249630,8095,8);\nconst ivec3 _APOSTROPHE_ = ivec3(259,0,4);\nconst ivec3 _L_PAREN_ = ivec3(115614,3847,7);\nconst ivec3 _R_PAREN_ = ivec3(462351,1948,7);\nconst ivec3 _ASTERISK_ = ivec3(509700,526,7);\nconst ivec3 _PLUS_ = ivec3(114944,2,5);\nconst ivec3 _COMMA_ = ivec3(0,33152,4);\nconst ivec3 _MINUS_ = ivec3(245760,0,6);\nconst ivec3 _PERIOD_ = ivec3(0,384,4);\nconst ivec3 _SLASH_ = ivec3(232984,391,7);\nconst ivec3 _0_ = ivec3(843678,3903,8);\nconst ivec3 _1_ = ivec3(99206,774,5);\nconst ivec3 _2_ = ivec3(1039935,8067,8);\nconst ivec3 _3_ = ivec3(1023007,4024,8);\nconst ivec3 _4_ = ivec3(511387,3096,7);\nconst ivec3 _5_ = ivec3(508319,3998,7);\nconst ivec3 _6_ = ivec3(1033150,7987,8);\nconst ivec3 _7_ = ivec3(793663,6192,8);\nconst ivec3 _8_ = ivec3(498111,8115,8);\nconst ivec3 _9_ = ivec3(1038751,4024,8);\nconst ivec3 _COLON_ = ivec3(3,384,4);\nconst ivec3 _SEMICOLON_ = ivec3(384,33152,4);\nconst ivec3 _LESSTHAN_ = ivec3(98816,66307,5);\nconst ivec3 _EQUALS_ = ivec3(114688,896,5);\nconst ivec3 _GREATERTHAN_ = ivec3(49280,16774,5);\nconst ivec3 _QUESTION_MARK_ = ivec3(925568,114751,8);\nconst ivec3 _AT_ = ivec3(1532350,65237,9);\nconst ivec3 _A_ = ivec3(1038782,6579,8);\nconst ivec3 _B_ = ivec3(515135,8123,8);\nconst ivec3 _C_ = ivec3(115646,7943,8);\nconst ivec3 _D_ = ivec3(842783,4027,8);\nconst ivec3 _E_ = ivec3(1034174,7951,8);\nconst ivec3 _F_ = ivec3(508863,387,8);\nconst ivec3 _G_ = ivec3(902078,7991,8);\nconst ivec3 _H_ = ivec3(1038771,6579,8);\nconst ivec3 _I_ = ivec3(49539,387,4);\nconst ivec3 _J_ = ivec3(792624,8120,8);\nconst ivec3 _K_ = ivec3(249267,6555,8);\nconst ivec3 _L_ = ivec3(49539,8071,8);\nconst ivec3 _M_ = ivec3(2096099,12779,9);\nconst ivec3 _N_ = ivec3(1039287,7615,8);\nconst ivec3 _O_ = ivec3(843678,3903,8);\nconst ivec3 _P_ = ivec3(1039423,387,8);\nconst ivec3 _Q_ = ivec3(843678,790335,8);\nconst ivec3 _R_ = ivec3(515135,6587,8);\nconst ivec3 _S_ = ivec3(508319,3992,7);\nconst ivec3 _T_ = ivec3(198207,1548,8);\nconst ivec3 _U_ = ivec3(842163,3903,8);\nconst ivec3 _V_ = ivec3(232859,526,7);\nconst ivec3 _W_ = ivec3(2094563,15359,9);\nconst ivec3 _X_ = ivec3(466807,15294,9);\nconst ivec3 _Y_ = ivec3(498099,1548,8);\nconst ivec3 _Z_ = ivec3(232991,3975,7);\nconst ivec3 _L_SQUARE_BRACKET_ = ivec3(49543,899,5);\nconst ivec3 _BACKSLASH_ = ivec3(230275,3100,7);\nconst ivec3 _R_SQUARE_BRACKET_ = ivec3(99079,902,5);\nconst ivec3 _CARET_ = ivec3(444164,0,7);\nconst ivec3 _UNDERSCORE_ = ivec3(0,1032192,8);\n\nfloat Font_DecodeBitmap( vec2 vCoord, ivec3 vCharacter )\n{\n    vCoord = floor( vCoord );\n\n    int iRow = int(vCoord.y) - 1;\n    int iCol = int(vCoord.x) - 1;\n    \n    if ( iRow < 0 || iRow >= 6 ) return 0.0;\n    if ( iCol < 0 || iCol >= 7 ) return 0.0;\n    \n    int iRowBits = 0;\n        \n   \tif ( iRow == 0 ) \t\t\tiRowBits = vCharacter.x;\n    else  if ( iRow == 1 ) \t\tiRowBits = vCharacter.x \/ 128;\n    else  if ( iRow == 2 ) \t\tiRowBits = vCharacter.x \/ 16384;\n    else  if ( iRow == 3 ) \t\tiRowBits = vCharacter.y;\n    else  if ( iRow == 4 ) \t\tiRowBits = vCharacter.y \/ 128;\n    else \t\t\t\t\t\tiRowBits = vCharacter.y \/ 16384;\n      \n    return (iRowBits & (1 << iCol )) == 0 ? 0.0 : 1.0;\n}\n\n\nstruct PrintState\n{\n    vec2 vTexCoord;\n    vec2 vOrigin;\n    vec2 vPos;\n    \n    vec3 vColor;\n    vec3 vOutline;\n};\n    \nvoid Print_MoveTo( inout PrintState printState, vec2 vPos )\n{\n    printState.vOrigin = printState.vTexCoord - vPos;\n    printState.vPos = printState.vOrigin;\n}\n\nvoid Print_Newline( inout PrintState printState )\n{\n    printState.vPos.x = printState.vOrigin.x;\n    printState.vPos.y -= 8.0;\n}\n\nvoid Print_Color( inout PrintState printState, vec3 vColor )\n{\n    printState.vColor = vColor;\n}\n\nvoid Print_Init( out PrintState printState, vec2 vTexCoord )\n{\n    printState.vTexCoord = vTexCoord;        \n    printState.vOrigin = vTexCoord;\n    printState.vPos = vTexCoord;\n    printState.vColor = vec3(1,0,0);\n    printState.vOutline = vec3(.3,0,0);\n    Print_MoveTo( printState, vec2(0) ); \n}\n\nvoid Print_Space( inout PrintState printState )\n{\n    printState.vPos.x -= 5.0;\n}\n\nbool Print_Test( inout PrintState printState, vec3 vCharacter, float fSpacing )\n{\n    if ( vCharacter.z == -1.0 )\n    {\n        Print_MoveTo( printState, vCharacter.xy );\n        return false;\n    }\n    \n    if ( printState.vPos.x < vCharacter.z )\n        return true;\n         \n\tprintState.vPos.x -= vCharacter.z + fSpacing;\n    return false;\n}\n\nvoid Print_Char( inout PrintState printState, inout vec3 vResult, ivec3 vCharacter )\n{\n    float fBitmap = Font_DecodeBitmap( printState.vPos, vCharacter );\n    if ( fBitmap > 0.0 ) vResult = printState.vColor;\n    \n    printState.vPos.x -= float(vCharacter.z - 1);\n}\n\nvoid Print_HudChar( inout PrintState printState, inout vec3 vResult, ivec3 vCharacter )\n{\n    float fBitmap = Font_DecodeBitmap( printState.vPos, vCharacter );\n    float fShadow = Font_DecodeBitmap( printState.vPos - vec2( 1, 1), vCharacter );\n\n    if ( fBitmap > 0.0 ) vResult = printState.vColor * 0.5 + 0.5 * (printState.vPos.y \/ 8.);\n    else if ( fShadow > 0.0 ) vResult *= 0.5;\n    \n    printState.vPos.x -= float(vCharacter.z);\n}\n\nvoid Print_FancyChar( inout PrintState printState, inout vec3 vResult, ivec3 vCharacter )\n{\n    float fBitmapTL = Font_DecodeBitmap( printState.vPos - vec2(-1,-1), vCharacter );\n    float fBitmapTC = Font_DecodeBitmap( printState.vPos - vec2( 0,-1), vCharacter );\n    float fBitmapTR = Font_DecodeBitmap( printState.vPos - vec2( 1,-1), vCharacter );\n\n    float fBitmapCL = Font_DecodeBitmap( printState.vPos - vec2(-1, 0), vCharacter );\n    float fBitmapCC = Font_DecodeBitmap( printState.vPos - vec2( 0, 0), vCharacter );\n    float fBitmapCR = Font_DecodeBitmap( printState.vPos - vec2( 1, 0), vCharacter );\n    \n    float fBitmapBL = Font_DecodeBitmap( printState.vPos - vec2(-1, 1), vCharacter );\n    float fBitmapBC = Font_DecodeBitmap( printState.vPos - vec2( 0, 1), vCharacter );\n    float fBitmapBR = Font_DecodeBitmap( printState.vPos - vec2( 1, 1), vCharacter );\n    \n    float fOutline \t= min( 1., fBitmapTL + fBitmapTC + fBitmapTR + fBitmapCL + fBitmapCR + fBitmapBL + fBitmapBC + fBitmapBR );    \n    float fShade = (fBitmapTL * .5 - fBitmapBR * .5 ) + 0.5;\n    \n    if ( fBitmapCC > 0.0 ) vResult = printState.vColor * (fShade * 0.25 + 0.75);\n    else\n    if ( fOutline > 0.0 ) vResult = printState.vOutline;\n    \n    printState.vPos.x -= float(vCharacter.z);\n}\n\n\/\/ End of font code\n\/\/ ----------------- 8< -------------------------- 8< -------------------------- 8< --------------\n\n\n\nEntity g_playerEnt;\nGameState g_gameState;\n\nfloat hash2D(vec2 p)    \n{\n\treturn Hash( dot( p, vec2(1.0, 41.0) ) );\t\n}\n\nfloat noise1D( float p )\n{\n\tfloat fl = floor(p);\n\t\n\tfloat h0 = Hash( fl );\n\tfloat h1 = Hash( fl + 1.0 );\n\t\n\tfloat fr = p - fl;\n\tfloat fr2 = fr * fr;\n\tfloat fr3 = fr2 * fr;\n\t\n\tfloat t1 = 3.0 * fr2 - 2.0 * fr3;\t\n\tfloat t0 = 1.0 - t1;\n\t\n\treturn h0 * t0\n\t\t + h1 * t1;\n}\n\nfloat noise2D( vec2 p, float r )\n{\n\tvec2 fl = floor(p);\n\n\tfloat h00 = hash2D( mod(fl + vec2(0.0, 0.0), r) );\n\tfloat h10 = hash2D( mod(fl + vec2(1.0, 0.0), r) );\n\tfloat h01 = hash2D( mod(fl + vec2(0.0, 1.0), r) );\n\tfloat h11 = hash2D( mod(fl + vec2(1.0, 1.0), r) );\n\t\n\tvec2 fr = p - fl;\n\t\n\tvec2 fr2 = fr * fr;\n\tvec2 fr3 = fr2 * fr;\n\t\n\tvec2 t1 = 3.0 * fr2 - 2.0 * fr3;\t\n\tvec2 t0 = 1.0 - t1;\n\t\n\treturn h00 * t0.x * t0.y\n\t\t + h10 * t1.x * t0.y\n\t\t + h01 * t0.x * t1.y\n\t\t + h11 * t1.x * t1.y;\n}\n\nfloat fbm( vec2 p, float per )\n{\n\tfloat val = 0.0;\n\tfloat tot = 0.0;\n\tfloat mag = 0.5;\n\n\tp += 0.5;\n\tp = p * (1.0 \/ 8.0);\n\tval += noise2D(p, 4.0) * mag; tot+=mag; p=p*2.0 + 1.234; mag*=per;\t\n\tval += noise2D(p, 8.0) * mag; tot+=mag; p=p*2.0 + 2.456; mag*=per;\n\tval += noise2D(p, 16.0) * mag; tot+=mag; p=p*2.0 + 3.678; mag*=per;\n\tval += noise2D(p, 32.0) * mag; tot+=mag;\n\n\treturn val * (1.0 \/ tot);\n}\n\nvec3 Tex( vec2 vTexCoord )\n{\n    vec2 vSize = vec2(64.0);    \n    float fPersistence = 0.8;\n\tfloat fNoise2Freq = 0.5;\n    \n    vTexCoord = floor( vTexCoord );\n    \n\tfloat fRandom = fbm( vTexCoord, fPersistence );\n    \n\tvec3 col = mix( vec3(63.0, 47.0, 23.0), vec3(147.0, 123.0, 99.0), fRandom) \/ 255.0;\n\t\n\treturn col;    \n}\n\nvoid VWipe( inout vec2 vPixel, float fFade, vec2 vSize )\n{\n    float fEffectTime = max( 0.0, fFade );\n    float fEffectOffset = max(fEffectTime - 1.0, 0.0) - Hash(floor(vPixel.x)) * 0.4;\n\n    fEffectOffset = clamp(fEffectOffset, 0.0, 1.0);\n    \t\n    vPixel.y += fEffectOffset * vSize.y;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Raymarching\n\n\nstruct SceneResult\n{\n\tfloat fDist;\n\tfloat fObjectId;\n    vec3 vUVW;\n};\n\nSceneResult Scene_Union( const in SceneResult a, const in SceneResult b )\n{\n    if ( a.fDist < b.fDist )\n    {\n        return a;\n    }\n    return b;\n}\n    \nSceneResult Scene_Subtract( const in SceneResult a, const in SceneResult b )\n{\n    if ( -a.fDist < b.fDist )\n    {\n        return a;\n    }\n\n    SceneResult result;\n    result.fDist = -b.fDist;\n    result.fObjectId = b.fObjectId;\n    result.vUVW = b.vUVW;\n    return result;\n}\n\nSceneResult Scene_Intersection( const in SceneResult a, const in SceneResult b )\n{\n    if ( a.fDist > b.fDist )\n    {\n        return a;\n    }\n    return b;\n}\n    \nSceneResult Scene_GetDistance( const vec3 vPos );    \n\nvec3 Scene_GetNormal(const in vec3 vPos)\n{\n    const float fDelta = 0.001;\n    vec2 e = vec2( -1, 1 );\n    \n    vec3 vNormal = \n        Scene_GetDistance( vPos + e.yxx * fDelta ).fDist * e.yxx + \n        Scene_GetDistance( vPos + e.xxy * fDelta ).fDist * e.xxy + \n        Scene_GetDistance( vPos + e.xyx * fDelta ).fDist * e.xyx + \n        Scene_GetDistance( vPos + e.yyy * fDelta ).fDist * e.yyy;\n    \n    if ( dot( vNormal, vNormal ) < 0.00001 )\n    {\n        return vec3(0, 1, 0);\n    }\n    \n    return normalize( vNormal );\n}    \n\nSceneResult Scene_Trace( const in vec3 vRayOrigin, const in vec3 vRayDir, float maxDist )\n{\t\n    SceneResult result;\n    result.fDist = 0.0;\n    result.vUVW = vec3(0.0);\n    result.fObjectId = 0.0;\n    \n\tfloat t = 0.1;\n\tconst int kRaymarchMaxIter = 128;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\t\t\n\t\tresult = Scene_GetDistance( vRayOrigin + vRayDir * t );\t\t\n        t += result.fDist;\n\n        if ( abs(result.fDist) < 0.001 )\n\t\t{\n\t\t\tbreak;\n\t\t}\t\t\n        if ( t > maxDist )\n        {\n            result.fObjectId = -1.0;\n\t        t = maxDist;\n            break;\n        }\n\t}\n    \n    result.fDist = t;\n\n    return result;\n}\n\nvec2 Segment_Internal( vec3 vPos, vec3 vP0, vec3 vP1 )\n{\n\tvec3 pa = vPos - vP0;\n\tvec3 ba = vP1 - vP0;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\t\n\treturn vec2( length( pa - ba*h ), h );\n}\n\nfloat Segment( vec3 vPos, vec3 vP0, vec3 vP1, float r0, float r1 )\n{\n    vec2 vC = Segment_Internal( vPos, vP0, vP1 );\n    \n    return vC.x - mix(r0, r1, vC.y);\n}\n\n#define MAT_BG 0.0\n#define MAT_SHOTGUN 1.0\n#define MAT_PISTOL 2.0\n\nSceneResult Scene_GetDistance( const vec3 vPos )\n{\n    vec3 vWeaponPos = vPos;\n    \n    if ( g_playerEnt.fHealth <= 0.0 )\n    {    \n        float fDeathFall = 0.0;\n\n        \/\/ Death\n        if( g_playerEnt.fHealth <= 0.0 )\n        {\n            fDeathFall = 1.0 - (g_playerEnt.fTimer \/ 1.5);\n        }\n\n    \tvWeaponPos.y += fDeathFall * 5.0;\n    }        \n    \n    \n    if ( g_playerEnt.fUseWeapon == 2.0 )\n    {\n\t    vWeaponPos += vec3(0.0, 0.0, 1.0) * pow( g_playerEnt.fTimer, 3.0) * 5.0 ;\n        \n        float fDist = Segment( vWeaponPos, vec3(0,-1.0,2.5), vec3(0, -5, 25), .2, 0.2 );\n        float fDist2 =  Segment( vWeaponPos, vec3(0, -4.5, 23), vec3(0, -4.5, 25), .1, 0.1 );\n        fDist = min( fDist, fDist2 );\n        return SceneResult( fDist, MAT_SHOTGUN, vec3(0.0) );    \n    }\n    \n    \/\/ pistol\n    vWeaponPos += vec3(0.0, 0.0, 1.0) * pow( g_playerEnt.fTimer, 3.0) * 10.0 ;\n    \n    float fDist = Segment( vWeaponPos, vec3(0,-0.8,0), vec3(0, -5, 20), .1, 0.1 );\n\treturn SceneResult( fDist, MAT_PISTOL, vec3(0.0) );    \n    \n    \/\/return SceneResult( length(vPos - vec3(0.0, 1.0, 5.0)) - 0.5, MAT_SHOTGUN, vec3(0.0) );\n}\n\nvec4 MuzzleFlash( vec2 vUV, vec2 vPos, vec2 vSize )\n{\n    vec4 vResult = vec4( 0.0 );\n    vec2 vLocalPos = vUV - vPos;\n    vLocalPos = vLocalPos \/ vSize;\n    float fDist = length( vLocalPos );\n    fDist += abs(vLocalPos.x) + abs(vLocalPos.y);\n\n    float fFactor = fDist * 5.0 + fbm( vLocalPos * 100., 0.8);\n\n    \/\/float fAmount = exp2( * fFactor );\n\n    if ( fFactor < 3.0)\n    {\n        fFactor = 1.0 - fFactor \/ 3.0;\n\n        fFactor = pow( 0.5 + fFactor, 5.0 );\n\n        vResult.rgb = vec3( fFactor, pow(fFactor, 2.0) * .4, pow(fFactor, 3.0) * .2) * 5.0;\n        vResult.a = 1.0;\n\n    }\n    \n    return vResult;\n}\n\nvec4 ViewmodelSprite( vec2 vUV, float fLightLevel )\n{\n    vec4 vResult = vec4( 0 );\n    \n    vec2 vBoundsMin = vec2(0);\n    vec2 vBoundsMax = vec2(1);\n    \n    if ( g_playerEnt.fUseWeapon == 2.0 )\n    {\n    \tvBoundsMin = vec2(0.4, 0.0);\n    \tvBoundsMax = vec2(0.6,0.25);\n    }\n    else\n    {\n    \tvBoundsMin = vec2(0.47, 0.0);\n    \tvBoundsMax = vec2(0.53,0.15);\n    }\n    \n    if ( all( greaterThanEqual( vUV, vBoundsMin ) ) &&\n         all( lessThan( vUV, vBoundsMax ) ) )\n    {       \n        vec3 vCameraPos = vec3(0.0, 0.0, 0.0);    \n        vec2 vWindowPos = vec2(vUV.x * 2.0 - 1.0, vUV.y * 2.0 - 1.0);\n        vec3 vCameraDir = normalize( vec3(vWindowPos, 3.0) - vCameraPos );\n\n        SceneResult sceneResult = Scene_Trace( vCameraPos, vCameraDir, 1000.0 );\n\n        if ( sceneResult.fDist < 400.0 )\n        {\n\n            vec3 vHitPos = vCameraPos + vCameraDir * sceneResult.fDist;\n\n            vec3 vNormal = Scene_GetNormal( vHitPos );\n\n            vec3 vAmbientLight = vec3(0.1);\n            vec3 vLightDir = normalize( vec3( 0.2, 0.3, 0.2 ) );\n            vec3 vLightColor = vec3(1.0);\n\n            float fShade = max( 0.0, dot( vNormal, vLightDir ) );\n\n            vec3 vDiffuseCol = vec3(.1);\n            float fSpecPow = 10.0;\n            float fSpecIntensity = 200.0;\n\n            if ( sceneResult.fObjectId == MAT_SHOTGUN )\n            {\n                vDiffuseCol = vec3(.1);\n                fSpecPow = 10.0;\n                fSpecIntensity = 200.0;        \n            }\n            else\n            if ( sceneResult.fObjectId == MAT_PISTOL )\n            {\n                vDiffuseCol = vec3(.2);\n                fSpecPow = 50.0;\n                fSpecIntensity = 20.0;        \n\n            }\n\n            vec3 vDiffuseLight = vAmbientLight + fShade * vLightColor;\n            vResult.rgb = vDiffuseCol * vDiffuseLight;\n\n            vec3 vRefl = reflect( vCameraDir, vNormal );\n            float fDot = max(0.0, dot( vRefl, vLightDir )) * fShade;\n            float fSpec = pow( fDot, fSpecPow );\n            vResult.rgb += fSpec * fSpecIntensity;\n\n            vResult.rgb = 1.0 - exp2( vResult.rgb * -2.0 );\n            vResult.rgb = pow( vResult.rgb, vec3(1.0 \/ 1.5) );\n            vResult.rgb = clamp( vResult.rgb, vec3(0.0), vec3(1.0) );\n            vResult.rgb *= fLightLevel;\n            vResult.rgb = clamp( vResult.rgb, vec3(0.0), vec3(1.0) );\n\n            vResult.a = 1.0;\n\n            return vResult;\n        }\n        else\n        {\n            \/\/ Bounds debug\n\t\t\t\/\/return vec4(1,0,0,1);            \n        }\n    }\n    \n    \/\/ muzzle flash sprite\n       \n    if(  g_playerEnt.fHealth > 0.0 )\n    {    \n        if ( g_playerEnt.fUseWeapon == 2.0 )\n        {\n       \t\tif ( g_playerEnt.fTimer > 0.9 )\n\t    \t{\n                vec4 vMuzzleFlash = MuzzleFlash( vUV, vec2(0.5, 0.2), vec2(0.5, 0.5) );\n                \n                if ( vMuzzleFlash.a > 0.0 )\n                {\n                    return vMuzzleFlash;\n                }\n            }\n        }\n        else\n        {\n       \t\tif ( g_playerEnt.fTimer > 0.45 )\n\t    \t{\n                vec4 vMuzzleFlash = MuzzleFlash( vUV, vec2(0.5, 0.12), vec2(0.25, 0.25) );\n                \n                if ( vMuzzleFlash.a > 0.0 )\n                {\n                    return vMuzzleFlash;\n                }\n            }\n        }\t            \n\t}\n    \n    return vResult;    \n}\n\n#define FONT_POS \tivec2(280,0)\n#define FONT_CHAR \tivec2(16,0)\n\n\nvec4 NumFont_Char( vec2 vCharUV, int iDigit )\n{\n \tif ( iDigit < 0 )\n    \treturn vec4(0.0);\n    \n    ivec2 vTexCoord = ivec2(floor(vCharUV * vec2(14.0, 16.0))) + FONT_POS;\n    vTexCoord += iDigit * FONT_CHAR;\n        \n    return texelFetch( iChannel2, vTexCoord, 0 );\n}\n\nvec4 PrintHUDPercent(const in vec2 vStringUV, const in float fValue )\n{\n    float fMaxDigits = 3.0;\n    if ((vStringUV.y < 0.0) || (vStringUV.y >= 1.0)) return vec4(0.0);\n\tfloat fLog10Value = log2(abs(fValue)) \/ log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringUV.x);\n\tfloat fCharacter = -1.0;\n    \n\tif(fDigitIndex > (-0.0 - 1.01)) {\n\t\tif(fDigitIndex <= fBiggestIndex) {\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tfCharacter = 10.0; \/\/ Percent\n\t\t\t} else {\n\t\t\t\tfloat fDigitValue = (abs(fValue \/ (pow(10.0, fDigitIndex))));\n                float kFix = 0.0001;\n                fCharacter = floor(mod(kFix+fDigitValue, 10.0));\n\t\t\t}\t\t\n\t\t}\n\t}\n    \n    return NumFont_Char( fract(vStringUV), int(fCharacter) );\n}\n\n\nvec4 GetHudText( vec2 vPos, float fHealth, float fArmor )\n{    \n    vPos = floor( vPos );\n\tvec4 vHealth = PrintHUDPercent( vec2( (vPos - vec2(33,12)) \/ vec2(14,16)), fHealth );\n    if ( vHealth.a > 0.0 )\n    \treturn vHealth;\n    \n\tvec4 vArmor = PrintHUDPercent( vec2( (vPos - vec2(164,12)) \/ vec2(14,16)), fArmor );\n    if ( vArmor.a > 0.0 )\n    \treturn vArmor;\n    \n    return vec4(0.0);\n}\n\n\nvec4 SampleScene( vec2 vPixelCoord, vec2 vResolution, float fLightLevel )\n{\n    vec2 vScenePixelCoord = floor(vPixelCoord) - vec2(0, 32.0);\n    vec4 vResult = texture( iChannel3, (vScenePixelCoord + 0.5) \/ iChannelResolution[2].xy );\n    \n    vec2 vQuantizedUV = floor(vScenePixelCoord) * (1.0 \/ vResolution);\n    vec4 vViewmodelSprite = ViewmodelSprite( vQuantizedUV, fLightLevel );\n\n    vResult = mix ( vResult, vViewmodelSprite, vViewmodelSprite.a );\n    \n    if ( vScenePixelCoord.y < 1.0 )\n    {\n        return vec4((vec3(70.\/256.)), 1.);\n    }   \n    \n    return vResult;\n}\n\nvec3 DrawMap( vec2 vPixelCoord, vec2 vResolution )\n{\n    vec3 vResult = vec3(0.0);\n    vec2 vScenePixelCoord = floor(vPixelCoord) - vec2(0, 31.0);\n    \n    float fScale = 5.0;\n    \n    vec2 vPixelWorldPos = (vScenePixelCoord - vec2(160,100)) * fScale + g_playerEnt.vPos.xz;\n\n    MapInfo mapInfo = ReadMapInfo( MAP_CHANNEL );\n    \n    \/\/if ( Key_IsToggled( KEY_TAB ) )\n    {\n        for(int iSectorIndex=0; iSectorIndex<mapInfo.iSectorCount; iSectorIndex++)\n        {\n            Sector sector = Map_ReadSector( MAP_CHANNEL, iSectorIndex );\n            \n            \/*if ( Map_PointInSector( vPixelWorldPos, sector ) )\n            {\n                vResult = vec3(1,0,0);\n            }*\/\n            \n\n            for(int iSideDefIndex=0; iSideDefIndex<sector.iSideDefCount; iSideDefIndex++)\n            {\n                SideDef sideDef = Map_ReadSideDefInfo( MAP_CHANNEL, iSectorIndex, iSideDefIndex );                        \n\n                vec2 vSideDir = normalize( sideDef.vB - sideDef.vA );\n\n                float fProj = dot( vSideDir, vPixelWorldPos - sideDef.vA );\n                fProj = clamp( fProj, 0.0, sideDef.fLength );\n                \n                vec2 vClosest = sideDef.vA + vSideDir * fProj;\n                float fDist = length( vClosest - vPixelWorldPos );\n                \n                if (fDist < fScale * .5 )\n                {\n                    if ( sideDef.iNextSector != SECTOR_NONE )\n                    {\n\t                    vResult = vec3(1,1,0);\n                    }\n                    else\n                    {\n\t                    vResult = vec3(1,0,0);\n                    }\n                }\n            }\t\t\t\n        }\n    }    \n    \n    return vResult;\n}\n\nfloat Relief( vec2 vPos, vec2 vMin, vec2 vMax )\n{\n    vPos = floor(vPos);\n    if ( (vPos.x == vMin.x ) && (vPos.y <= vMax.y && vPos.y >= vMin.y ) )\n    {\n\t    return 1.3;\n    }\n\n    if ( (vPos.y == vMax.y ) && (vPos.x <= vMax.x && vPos.x >= vMin.x ) )\n    {\n\t    return 1.4;\n    }\n        \n    if ( (vPos.x == vMax.x ) && (vPos.y <= vMax.y && vPos.y >= vMin.y ) )\n    {\n\t    return 0.4;\n    }\n\n    if ( (vPos.y == vMin.y ) && (vPos.x <= vMax.x && vPos.x >= vMin.x ) )\n    {\n\t    return 0.7;\n    }\n    \n    return 1.0;\n}\n\n#ifdef FULL_HUD\n\nivec3 GetMessageChar( int iMessage, int iChar )\n{\n\t#define MESSAGE_CHAR(X) if ( iChar == 0 ) return X; iChar--\n    \n    if ( iMessage == EVENT_HEALTH_BONUS ||\n       \tiMessage == EVENT_ARMOR_BONUS || \n       \tiMessage == EVENT_GREENARMOR || \n        iMessage == EVENT_BLUEARMOR ||\n       iMessage == EVENT_MEDIKIT)\n    {\n        MESSAGE_CHAR( _P_ );\n        MESSAGE_CHAR( _I_ );\n        MESSAGE_CHAR( _C_ );\n        MESSAGE_CHAR( _K_ );\n        MESSAGE_CHAR( _E_ );\n        MESSAGE_CHAR( _D_ );\n\n        MESSAGE_CHAR( _SPACE_ );\n\n        MESSAGE_CHAR( _U_ );\n        MESSAGE_CHAR( _P_ );\n\n        MESSAGE_CHAR( _SPACE_ );\n    }\n    else\n    if( iMessage == EVENT_SHOTGUN )\n    {\n        MESSAGE_CHAR( _Y_ );\n        MESSAGE_CHAR( _O_ );\n        MESSAGE_CHAR( _U_ );\n        \n        MESSAGE_CHAR( _SPACE_ );\n\n        MESSAGE_CHAR( _G_ );\n        MESSAGE_CHAR( _O_ );\n        MESSAGE_CHAR( _T_ );\n        \n        MESSAGE_CHAR( _SPACE_ );\n    }\n        \n    \n    if ( iMessage == EVENT_HEALTH_BONUS || iMessage == EVENT_ARMOR_BONUS || iMessage == EVENT_MEDIKIT)\n    {    \n        MESSAGE_CHAR( _A_ );\n        if ( iMessage == EVENT_ARMOR_BONUS )\n        {    \n\t        MESSAGE_CHAR( _N_ );\n        }\n        MESSAGE_CHAR( _SPACE_ );\n    }\n    else if ( iMessage == EVENT_GREENARMOR ||\n            iMessage == EVENT_BLUEARMOR || \n            iMessage == EVENT_SHOTGUN )\n    {\n        MESSAGE_CHAR( _T_ );\n        MESSAGE_CHAR( _H_ );\n        MESSAGE_CHAR( _E_ );\n        \n        MESSAGE_CHAR( _SPACE_ );\n    }\n\n    if ( iMessage == EVENT_BLUEARMOR )\n    {\n        MESSAGE_CHAR( _M_ );\n        MESSAGE_CHAR( _E_ );\n        MESSAGE_CHAR( _G_ );\n        MESSAGE_CHAR( _A_ );\n    }\n    \n    if( iMessage == EVENT_SHOTGUN )\n    {\n        MESSAGE_CHAR( _S_ );\n        MESSAGE_CHAR( _H_ );\n        MESSAGE_CHAR( _O_ );\n        MESSAGE_CHAR( _T_ );\n        MESSAGE_CHAR( _G_ );\n        MESSAGE_CHAR( _U_ );\n        MESSAGE_CHAR( _N_ );\n        \n        MESSAGE_CHAR( _SPACE_ );\n    }\n    \n    if ( iMessage == EVENT_HEALTH_BONUS )\n    {    \n        MESSAGE_CHAR( _H_ );\n        MESSAGE_CHAR( _E_ );\n        MESSAGE_CHAR( _A_ );\n        MESSAGE_CHAR( _L_ );\n        MESSAGE_CHAR( _T_ );\n        MESSAGE_CHAR( _H_ );\n    }\n    else if ( iMessage == EVENT_ARMOR_BONUS || iMessage == EVENT_GREENARMOR || iMessage == EVENT_BLUEARMOR)\n    {    \n        MESSAGE_CHAR( _A_ );\n        MESSAGE_CHAR( _R_ );\n        MESSAGE_CHAR( _M_ );\n        MESSAGE_CHAR( _O_ );\n        MESSAGE_CHAR( _R_ );\n    }\n    else if ( iMessage == EVENT_MEDIKIT )\n    {    \n        MESSAGE_CHAR( _M_ );\n        MESSAGE_CHAR( _E_ );\n        MESSAGE_CHAR( _D_ );\n        MESSAGE_CHAR( _I_ );\n        MESSAGE_CHAR( _K_ );\n        MESSAGE_CHAR( _I_ );\n        MESSAGE_CHAR( _T_ );\n    }\n    \n    if ( iMessage == EVENT_HEALTH_BONUS || iMessage == EVENT_ARMOR_BONUS)\n    {    \n        MESSAGE_CHAR( _SPACE_ );\n        \n        MESSAGE_CHAR( _B_ );\n        MESSAGE_CHAR( _O_ );\n        MESSAGE_CHAR( _N_ );\n        MESSAGE_CHAR( _U_ );\n        MESSAGE_CHAR( _S_ );\n    }\n\n    if ( iMessage == EVENT_BLUEARMOR || iMessage == EVENT_SHOTGUN )\n    {\n        MESSAGE_CHAR( _EXCLAMATION_ );\n    }\n    else\n    {\n        MESSAGE_CHAR( _PERIOD_ );\n    }   \n    \n    return ivec3(0);\n}\n\n\nivec3 GetHudTextChar( int iChar ) \n{\n\n\t#define HUD_TEXT_CHAR(X) if ( iChar == 0 ) return X; iChar--\n    \n    HUD_TEXT_CHAR( ivec3(6,189, -1) ); \/\/ MOVE\n\n    HUD_TEXT_CHAR( _A_ );\n    HUD_TEXT_CHAR( _M_ );\n    HUD_TEXT_CHAR( _M_ );\n    HUD_TEXT_CHAR( _O_ );\n\n    HUD_TEXT_CHAR( ivec3(52,189, -1) ); \/\/ MOVE\n    \n    HUD_TEXT_CHAR( _H_ );\n    HUD_TEXT_CHAR( _E_ );\n    HUD_TEXT_CHAR( _A_ );\n    HUD_TEXT_CHAR( _L_ );\n    HUD_TEXT_CHAR( _T_ );\n    HUD_TEXT_CHAR( _H_ );\n    \n    HUD_TEXT_CHAR( ivec3(109,189, -1) ); \/\/ MOVE\n\n    HUD_TEXT_CHAR( _A_ );\n    HUD_TEXT_CHAR( _R_ );\n    HUD_TEXT_CHAR( _M_ );\n    HUD_TEXT_CHAR( _S_ );\n    \n    HUD_TEXT_CHAR( ivec3(187,189, -1) ); \/\/ MOVE\n\n    HUD_TEXT_CHAR( _A_ );\n    HUD_TEXT_CHAR( _R_ );\n    HUD_TEXT_CHAR( _M_ );\n    HUD_TEXT_CHAR( _O_ );\n    HUD_TEXT_CHAR( _R_ );\n\n    return ivec3(0);\n}\n\n\nvoid PrintHudMessage( vec2 vTexCoord, int iMessage, inout vec3 vResult )\n{\n    if ( vTexCoord.y > 8.0 || vTexCoord.y < 0.0 || vTexCoord.x < 0.0 || vTexCoord.x > 240. )\n        return;     \n    \n    vec2 vUV = vec2( vTexCoord.x, vTexCoord.y );\n    vUV.y += float(iMessage * 8);\n    vUV.y = (iChannelResolution[0].y - 1.0) - vUV.y;\n    vUV = floor( vUV ) + 0.5;\n    vUV \/= iChannelResolution[0].xy;\n    vec4 vSample = texture(iChannel0, vUV);\n\tif( vSample.a > 0.0)\n\t{\n        vResult = vSample.rgb;\n\t}\n                    \n    \n                    \/*\n    \/\/ Message text\n    PrintState printState;\n    Print_Init( printState, vTexCoord );\n\n    \/\/ Fixed size font\n    \/\/float fCharIndex = floor( printState.vPos.x \/ 8. );\n    \/\/printState.vPos.x -= fCharIndex * 8.0;\n    \/\/vec3 vChar = GetMessageChar( fMessage, fCharIndex );\n    \n    vec3 vChar = _SPACE_;\n    for ( int i=0; i<32; i++)\n    {\n        vChar = GetMessageChar( fMessage, float(i) );\n        if ( Print_Test( printState, vChar, 0.0 ) )\n        {\n            break;\n        }\n        if ( vChar.z == 0. )\n            break;\n    }\n        \t\n    Print_FancyChar( printState, vResult, vChar );\n\t*\/\n}\n#endif \/\/ FULL_HUD\n\nvec4 GameImage( vec2 vUV, vec2 vResolution )\n{\n    vec4 vResult = vec4(0.0);\n\n    if ( any( lessThan( vUV, vec2(0.0) ) ) || any( greaterThanEqual( vUV, vec2(1,1) ) ) )\n    {\n        return vResult;\n    }\n    \n    vec2 vHudPixel = vUV * vResolution.xy;\n    vec2 vScenePixel = vUV * vResolution.xy;\n\n    g_playerEnt = Entity_Read( STATE_CHANNEL, 0 );\n    Sector playerSector = Map_ReadSector( MAP_CHANNEL, g_playerEnt.iSectorId );\n    \n\tg_gameState = GameState_Read( STATE_CHANNEL );\n    \n    float fHudFade = 0.0;\n    float fGameFade = 10.0;\n    \n    if ( g_gameState.iMainState == MAIN_GAME_STATE_GAME_RUNNING )\n    {\n        fHudFade = 0.01 + g_gameState.fStateTimer;\n        fGameFade = 0.0;\n    }\n    if ( g_gameState.iMainState == MAIN_GAME_STATE_WIN )\n    {\n        fGameFade = 0.01 + g_gameState.fStateTimer;\n        fHudFade = 0.0;\n    }\n    \n    VWipe( vHudPixel, fHudFade, vResolution );\n    VWipe( vScenePixel, fGameFade, vResolution );       \n    \n    \n    vec3 vRenderImage;\n    \n#ifdef ALLOW_MAP    \n    if ( g_gameState.fMap > 0.0 )\n    {\n#ifdef HIRES_MAP        \n        vRenderImage = DrawMap( vScenePixel, vResolution );\n#else \/\/ HIRES_MAP       \n        vec2 vScenePixelCoord = floor(vScenePixel);\n\n        float fScale = 10.0;\n        vec2 vPixelWorldPos = (vScenePixelCoord - vec2(160,100)) * fScale + g_playerEnt.vPos.xz;\n        \n        vec2 vMapUV = (vPixelWorldPos - vec2(1056, -3616)) \/ 10.0 + vec2(200, 150);\n        vMapUV += vec2(0, 32.0);\n        \n        vRenderImage = texture( iChannel1, (floor(vMapUV) + 0.5) \/ iChannelResolution[1].xy ).rgb;\n#endif \/\/ HIRES_MAP\n    }        \n    else\n#endif \/\/ ALLOW_MAP        \n    {\n \t\tvRenderImage = SampleScene( vScenePixel, vResolution, playerSector.fLightLevel ).rgb;        \n    }\n    \n    if ( vScenePixel.y <= 32.0 )\n    {\n        vec4 vHudText = GetHudText( vScenePixel, g_playerEnt.fHealth, g_playerEnt.fArmor );\n\n\t\tvec2 vNoiseScale = vec2(500.0, 300.0);        \n        float fNoisePer = 0.8;\n        if ( vHudText.a > 0.0 )\n        {\n            vNoiseScale = vec2(600.0); \n            fNoisePer = 0.5;\n        }\n\n        float fNoise = fbm( vUV * vNoiseScale, fNoisePer );\n        fNoise = fNoise * 0.5 + 0.5;\n        \n        if ( vHudText.a > 0.0 )\n        {\n            vRenderImage = vHudText.rgb * fNoise;\n        }\n    \telse\n        {\n            vRenderImage = vec3(fNoise * fNoise * 0.65 );\n        }    \n        \n#ifdef FULL_HUD\n        \/\/ Main relief\n        vRenderImage *= Relief( vScenePixel, vec2(0, 0), vec2(46, 31));\n        vRenderImage *= Relief( vScenePixel, vec2(48, 0), vec2(104, 31));\n        vRenderImage *= Relief( vScenePixel, vec2(106, 0), vec2(142, 31));\n        vRenderImage *= Relief( vScenePixel, vec2(178, 0), vec2(235, 31));\n        vRenderImage *= Relief( vScenePixel, vec2(249, 0), vec2(319, 31));\n        \n        \/\/ weapon avail\n        vRenderImage *= Relief( vScenePixel, vec2(107, 200 - 179), vec2(117, 200 - 171));\n        vRenderImage *= Relief( vScenePixel, vec2(119, 200 - 179), vec2(129, 200 - 171));\n        vRenderImage *= Relief( vScenePixel, vec2(131, 200 - 179), vec2(141, 200 - 171));\n        \n        vRenderImage *= Relief( vScenePixel, vec2(107, 200 - 189), vec2(117, 200 - 181));\n        vRenderImage *= Relief( vScenePixel, vec2(119, 200 - 189), vec2(129, 200 - 181));\n        vRenderImage *= Relief( vScenePixel, vec2(131, 200 - 189), vec2(141, 200 - 181));\n\n        \/\/ decoration\n        vRenderImage *= Relief( vScenePixel, vec2(237, 200 - 179), vec2(247, 200 - 171));\n        vRenderImage *= Relief( vScenePixel, vec2(237, 200 - 189), vec2(247, 200 - 181));\n        vRenderImage *= Relief( vScenePixel, vec2(237, 200 - 199), vec2(247, 200 - 191));\n        \n        vRenderImage *= Relief( vScenePixel, vec2(143, 0), vec2(177, 31));\n        \n        if ( all( greaterThanEqual( vScenePixel, vec2(144,1) ) ) &&\n            all( lessThan( vScenePixel, vec2(177,31) ) ) )\n        {\n            vRenderImage = vec3(0.0);\n        }\n#endif \/\/ FULL_HUD\n            \n#ifdef FULL_HUD   \n        \n        PrintHudMessage( vec2(vScenePixel.x, (vResolution.y - 1.) - (vScenePixel.y + 189.)), MESSAGE_HUD_TEXT, vRenderImage );\n        \n        PrintState printState;\n        Print_Init( printState, vec2(vScenePixel.x, (vResolution.y - 1.) - vScenePixel.y) );        \n\n        \n        \/\/ HUD text AMMO, HEALTH, ARMS, ARMOR\n\/*\n        Print_Color( printState, vec3(.9 ) );\n        vec3 vChar = _SPACE_;\n        for ( int i=0; i<24; i++)\n        {\n            vChar = GetHudTextChar( float(i) );\n            if ( Print_Test( printState, vChar, 0.0 ) )\n            {\n                break;\n            }\n            if ( vChar.z == 0. )\n                break;\n        }\n\n        Print_HudChar( printState, vRenderImage, vChar );        \n*\/\n        \/\/ Arms numbers\n        Print_Color( printState, vec3(.8,.8,0 ) );        \n        Print_MoveTo( printState, vec2(109,170) );\n        Print_Char( printState, vRenderImage, _2_ );\n\n        if( g_playerEnt.fHaveShotgun <= 0.0 )\n        {\n\t\t\tPrint_Color( printState, vec3(.25 ) );        \n        }\n        \n        Print_MoveTo( printState, vec2(120,170) );\n        Print_Char( printState, vRenderImage, _3_ );\n        Print_Color( printState, vec3(.25 ) );        \n        Print_MoveTo( printState, vec2(132,170) );\n        Print_Char( printState, vRenderImage, _4_ );\n\n        Print_MoveTo( printState, vec2(109,179) );\n        Print_Char( printState, vRenderImage, _5_ );\n        Print_MoveTo( printState, vec2(120,179) );\n        Print_Char( printState, vRenderImage, _6_ );\n        Print_MoveTo( printState, vec2(132,179) );\n        Print_Char( printState, vRenderImage, _7_ );\n#endif \/\/ FULL_HUD        \n    }    \n    \n\tfloat fEffectAmount = clamp( abs(g_gameState.fHudFx), 0.0, 1.0 );\n            \n    if (g_gameState.fHudFx > 0.0) \n    {\n        vRenderImage.rgb = mix( vRenderImage.rgb, vec3( 0.5, 1, 0.6), fEffectAmount * 0.75 );\n    }\n\n    if (g_gameState.fHudFx < 0.0) \n    {\n        vRenderImage.rgb = mix( vRenderImage.rgb, vec3( 1, 0, 0), fEffectAmount * 0.75 );\n    }\n    \n#ifdef FULL_HUD    \n#ifdef HUD_MESSAGES\n    if ( g_gameState.fMessageTimer > 0.0 )\n    {\n        if (g_gameState.iMessage >= 0 )\n        {\n        \tPrintHudMessage( vec2(vScenePixel.x, (vResolution.y) - vScenePixel.y), g_gameState.iMessage, vRenderImage );\n        }\n    }\n#endif \/\/ HUD_MESSAGES    \n#endif \/\/ FULL_HUD    \n    \n    \n    vec3 vFrontendImage = vec3(0.0);\n    \n    if ( vHudPixel.y > 0.0 )\n    {\n        vFrontendImage = Tex( vHudPixel );\n        vec2 vHudTextCoord = vec2(vHudPixel.x, (vResolution.y) - vHudPixel.y);\n\n        if ( g_gameState.iMainState == MAIN_GAME_STATE_WIN )\n        {\n            float fScale = 0.5;\n            vec2 vPos = vec2(58,8);\n\n            PrintHudMessage( (vHudTextCoord * fScale - vPos ), MESSAGE_HANGAR, vFrontendImage );        \n            vPos.y += 10.0;\n            vPos.x = 56.0;\n            PrintHudMessage( (vHudTextCoord * fScale - vPos ), MESSAGE_FINISHED, vFrontendImage );        \n\n        }\n\n        \/*\n        if ( g_gameState.fMainState == MAIN_GAME_STATE_SKILL_SELECT\n           || g_gameState.fMainState == MAIN_GAME_STATE_INIT_LEVEL\n           || g_gameState.fMainState == MAIN_GAME_STATE_GAME_RUNNING )\n        {            \n            float fScale = 0.8;\n            vec2 vPos = vec2(32,32);\n\n            PrintHudMessage( (vHudTextCoord * fScale - vPos ), MESSAGE_CHOOSE_SKILL, vFrontendImage );        \n\n            vPos.x += 32.0;\n            vPos.y += 24.0;\n\n            PrintHudMessage( (vHudTextCoord * fScale - vPos ), MESSAGE_SKILL_1, vFrontendImage );        \n            vPos.y += 16.0;\n            PrintHudMessage( (vHudTextCoord * fScale - vPos ), MESSAGE_SKILL_2, vFrontendImage );        \n            vPos.y += 16.0;\n            PrintHudMessage( (vHudTextCoord * fScale - vPos ), MESSAGE_SKILL_3, vFrontendImage );        \n            PrintHudMessage( (vHudTextCoord * fScale - vPos + vec2(16.0, 0) ), MESSAGE_SELECT, vFrontendImage );        \n            vPos.y += 16.0;\n            PrintHudMessage( (vHudTextCoord * fScale - vPos ), MESSAGE_SKILL_4, vFrontendImage );        \n            vPos.y += 16.0;\n            PrintHudMessage( (vHudTextCoord * fScale - vPos ), MESSAGE_SKILL_5, vFrontendImage );        \n            vPos.y += 16.0;       \t\t        \n        }\n\t\t*\/\n    }\n    \n    \n    vec2 vHudUV = vHudPixel \/ vResolution;\n    vec2 vSceneUV = vScenePixel \/ vResolution;\n    if ( fHudFade > fGameFade )\n    {\n        vResult.rgb = vRenderImage;\n\n        if ( vHudUV.y < 1.0 )\n        {\n            vResult.rgb = vFrontendImage;    \n        }\n    }\n    else\n    {\n        vResult.rgb = vFrontendImage;\n\n        if ( vSceneUV.y < 1.0 )\n        {\n\t        vResult.rgb = vRenderImage;\n        }\n    }\n    \n    if ( g_gameState.iMainState == MAIN_GAME_STATE_BOOT  ) \n    {\n        vResult.rgb = vec3( 0, 0, 0 );\n    }\n\n    \/\/vResult *= 0.5 + 0.5 * mod(mod(floor(vScenePixel.x), 2.0) + mod(floor(vScenePixel.y), 2.0), 2.0);\n    \n\treturn vResult;    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 vUV = fragCoord \/ iResolution.xy;\n    \n    vec2 vResolution = min( iResolution.xy, vec2( 320.0, 200.0 ) );\n    \/\/vec2 vAspect = iResolution.xy;\n    vec2 vAspect = vec2( 4, 3 );\n    \n    vec2 vWindowUV = vUV;\n    float fXScale = (iResolution.x \/ iResolution.y) * (vAspect.y \/ vAspect.x);;\n    \n    vWindowUV.x = vWindowUV.x * fXScale + (1.0 - fXScale) * 0.5;\n    \n    \n\/\/ Full screen\n#if 0\n    vWindowUV = vUV;\n#endif  \n    \n\/\/ 1 : 1\n#if 0\n    vWindowUV = vUV * iResolution.xy \/ vResolution.xy;\n#endif    \n    \n    \n#ifdef SHOW_MAP_DATA\n    fragColor = texture( iChannel0, vUV); return;\n#endif \/\/ SHOW_MAP_DATA    \n\n    \/\/fragColor = texture( iChannel1, vUV * 0.25 ); return;\n    \n#ifdef SHOW_SPRITES\n    fragColor = texture( iChannel2, vUV); return;\n#endif \/\/ SHOW_SPRITES\n        \n    \/\/fragColor = texture( iChannel2, vUV); return;\n    \/\/fragColor = texture( iChannel2, vUV * vec2(600,400) \/ iResolution.xy); return;\n      \n    fragColor = GameImage( vWindowUV, vResolution );\n    \n    \n    #ifdef QUANTIZE_FINAL_IMAGE\n    fragColor = Quantize(fragColor.rgb, 32.0);\n    #endif\n    \n    if ( false )\n    {\n\t   vec4 vSample = texture( iChannel2, vUV * 0.5 + vec2(0.0, 0) );\n    \tfragColor.rgb = mix( fragColor.rgb, vSample.rgb, vSample.a );\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dj3Rz","filepath":"https:\/\/soundcloud.com\/plasma3\/doom-remix-at-dooms-gate-level-1-theme-e1m1","previewfilepath":"https:\/\/soundcloud.com\/plasma3\/doom-remix-at-dooms-gate-level-1-theme-e1m1","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/#define WRITE_GRID_DATA\n\n#define MAP_CHANNEL iChannel0\n#define STATE_CHANNEL iChannel1\n\n\/\/ ----------------- 8< -------------------------- 8< -------------------------- 8< --------------\n\/\/ Common code follows\n\n#define NO_UNROLL(X) (X + min(0,iFrame))\n#define NO_UNROLLU(X) (X + uint(min(0,iFrame)))\n\n\n\nbool Map_PointInSector( sampler2D mapSampler, vec2 vPos, Sector sector )\n{\n    float fInOutTest = 0.0;\n    \n    for(int iSideDefIndex=0; iSideDefIndex< NO_UNROLL( sector.iSideDefCount ); iSideDefIndex++)\n    {        \n        SideDef sideDef = Map_ReadSideDefInfo( mapSampler, sector.iSectorId, iSideDefIndex );\n        \n        vec2 vPosToA = sideDef.vA - vPos;\n        vec2 vPosToB = sideDef.vB - vPos;\n        \n        if ( vPosToA.y > 0.0 && vPosToB.y > 0.0 )\n        \tcontinue;\n        if ( vPosToB.y <= 0.0 && vPosToA.y <= 0.0 )\n        \tcontinue;               \n        \n        float fCross = Cross2d( vPosToA, vPosToB );\n        if ( vPosToA.y > vPosToB.y )\n            fCross = -fCross;\n        if ( fCross < 0.0 )\n        {\n            fInOutTest++;\n        }        \n    }\n    \n    return mod( fInOutTest, 2.0 ) >= 1.0;    \n}\n\nbool Map_PointInSector( sampler2D mapSampler, MapInfo mapInfo, vec2 vPos, int iSectorId )\n{\n    if ( !Map_ValidSectorId(mapInfo, iSectorId) )\n    {\n        return false;\n    }\n\n    Sector sector = Map_ReadSector( mapSampler, iSectorId );\n\n    return Map_PointInSector( mapSampler, vPos, sector );\n}\n\nint Map_SeekSector( sampler2D mapSampler, MapInfo mapInfo, vec2 vPos )\n{    \n    for(int iSectorIndex=0; iSectorIndex<NO_UNROLL( mapInfo.iSectorCount ); iSectorIndex++)\n    {        \n        if ( Map_PointInSector( mapSampler, mapInfo, vPos, iSectorIndex ) )\n        {\n            return iSectorIndex;\n        }        \n    }\n\n    return SECTOR_NONE;\n}\n\n\nvoid Map_UpdateSector( sampler2D mapSampler, MapInfo mapInfo, vec2 vPrev, vec2 vPos, inout int iSectorId )\n{    \n    if ( vPrev == vPos )\n    {\n        return;\n    }\n    \n    if ( !Map_PointInSector( mapSampler, mapInfo, vPos, iSectorId ) )\n    {\n        int iNewSectorId = Map_SeekSector( mapSampler, mapInfo, vPos );\n        \n        if ( iNewSectorId != SECTOR_NONE )\n        {\n        \tiSectorId = iNewSectorId;\n        }                \n    }\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Trace\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nTraceResult Map_Trace( sampler2D mapSampler, MapInfo mapInfo, vec3 vRayOrigin, vec3 vRayDir, int iSectorId, float fMaxDist )\n{\n    TraceResult result;\n    \n    result.iTexture = 0u;\n    result.vTexture = vec3(0.0);\n    result.fDist = 0.0;\n    result.fLightLevel = 0.0;\n    result.iSector = SECTOR_NONE;\n    \n    while(true)\n    {\n        if ( iSectorId == SECTOR_NONE )\n        {\n            break;\n        }\n        \n        Sector sector = Map_ReadSector( mapSampler, iSectorId );\n        \n        TraceSectorState sectorState;\n        sectorState.iNextSector = SECTOR_NONE;        \n        sectorState.fEnterDist = result.fDist;\n        sectorState.bNoUpper = false;\n        result.fDist = fMaxDist;\n        result.iSector = iSectorId;\n        \n        for(int iSideDefIndex=0; iSideDefIndex<NO_UNROLL( sector.iSideDefCount); iSideDefIndex++)\n        {\n            SideDef sideDef = Map_ReadSideDefInfo( mapSampler, iSectorId, iSideDefIndex );                        \n\n            TraceSideDef( mapSampler, vRayOrigin, vRayDir, result, sectorState, sector, sideDef );\n        }\n\n        \/\/ Test floor \/ ceiling\n        if ( sectorState.fExitY < sector.fFloorHeight )\n        {\n            result.fDist = (sector.fFloorHeight - vRayOrigin.y) \/ vRayDir.y;\n            vec3 vFloorPos = vRayOrigin + vRayDir * result.fDist;\n            result.vTexture.st = vec2( vFloorPos.xz );\n            result.iTexture = sector.iFloorTexture;\n            result.fLightLevel = 0.0;\n            sectorState.iNextSector = SECTOR_NONE;\n        }\n        else\n        if ( sectorState.fExitY > sector.fCeilingHeight && !sectorState.bNoUpper )\n        {\n            result.fDist = (sector.fCeilingHeight - vRayOrigin.y) \/ vRayDir.y;\n            vec3 vCeilingPos = vRayOrigin + vRayDir * result.fDist;\n            result.vTexture.st = vec2( vCeilingPos.xz );\n            result.iTexture = sector.iCeilingTexture;\n            result.fLightLevel = 0.0;\n            sectorState.iNextSector = SECTOR_NONE;\n        }        \n\n        iSectorId = sectorState.iNextSector;\n    }\n    \n    if ( result.iTexture == 1u )\n        result.fDist = FAR_CLIP;\n    \n    return result;\n}\n\n\n\n\/\/ End of common code\n\/\/ ----------------- 8< -------------------------- 8< -------------------------- 8< --------------\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define FONT_POS \tvec2(280,0)\n#define FONT_CHAR \tvec2(16,0)\n\nfloat NumFont_Rect( vec2 vPos, vec2 bl, vec2 tr )\n{\n\tif ( all( greaterThanEqual( vPos, bl ) ) &&\n        all( lessThanEqual( vPos, tr ) ) )\n    {\n        return 1.0;\n    }\n        \n    return 0.0;\n}     \n\n\nfloat NumFont_Pixel( vec2 vPos, vec2 vPixel )\n{\n    return NumFont_Rect( vPos, vPixel, vPixel );\n}\n\nfloat NumFont_Circle( vec2 vTexCoord )\n{\n    float fResult = 0.0;\n    \n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(2, 2), vec2(10,12) ));\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(4, 1), vec2(8,13) ));\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(1, 4), vec2(11,10) ));\n    \n    return fResult;\n}\n\nfloat NumFont_Zero( vec2 vTexCoord )\n{\n    float fResult = NumFont_Circle( vTexCoord );\n\n    float fHole = NumFont_Rect( vTexCoord, vec2(6, 4), vec2(6,10) );\n    fHole = max( fHole, NumFont_Rect( vTexCoord, vec2(5, 5), vec2(7,9) ) );\n\n    fResult = min( fResult, 1.0 - fHole );    \n\n    return fResult;\n}\n\nfloat NumFont_One( vec2 vTexCoord )\n{\n    float fResult = 0.0;\n    \n    \/\/fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(4, 1), vec2(8,13), fOutline ));\n    \/\/fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(3, 2), vec2(3,4), fOutline ));\n    \/\/fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(2, 3), vec2(2,4), fOutline ));\n    \/\/fResult = max( fResult, NumFont_Pixel( vTexCoord, vec2(1, 4), fOutline ));\n    \n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(6, 1), vec2(10,13) ));\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(5, 2), vec2(5,4) ));\n    fResult = max( fResult, NumFont_Pixel( vTexCoord, vec2(3, 4) ));\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(4, 3), vec2(4,4.1) ));\n    \n\n    return fResult;\n}\n\nfloat NumFont_Two( vec2 vTexCoord )\n{\n    float fResult = 0.0;\n    \n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(2, 1), vec2(9,3) ));\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(3, 6), vec2(9,8) ));\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(1, 8), vec2(4,13) ));\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(1, 11), vec2(10,13) ));\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(2, 7), vec2(10,7) ));\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(8, 3), vec2(11,6) ));\n    fResult = max( fResult, NumFont_Pixel( vTexCoord, vec2(10, 2) ) );\n\n    return fResult;\n}\n\nfloat NumFont_Three( vec2 vTexCoord )\n{\n    float fResult = NumFont_Circle( vTexCoord );\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(1, 1), vec2(8,13) ));\n\n    float fHole = NumFont_Rect( vTexCoord, vec2(-1, 4), vec2(7,5) );\n    fHole = max( fHole, NumFont_Rect( vTexCoord, vec2(-1, 9), vec2(7,10) ));\n    fHole = max( fHole, NumFont_Rect( vTexCoord, vec2(-1, 6), vec2(3,8) ));\n    \n    fResult = min( fResult, 1.0 - fHole );    \n    \n    return fResult;\n}\n\nfloat NumFont_Four( vec2 vTexCoord )\n{\n    float fResult = 0.0;\n    \n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(1, 1), vec2(4,8) ));\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(8, 1), vec2(11,13) ));\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(1, 6), vec2(11,8) ));\n\n    return fResult;\n}\n\nfloat NumFont_Five( vec2 vTexCoord )\n{\n    float fResult = 0.0;\n\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(1, 1), vec2(10,3) ));\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(1, 1), vec2(3,8) ));\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(1, 6), vec2(9,8) ));\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(8, 7), vec2(10,12) ));\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(8, 8), vec2(11,11) ));\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(1, 11), vec2(9,13) ));\n    \n    return fResult;\n}\n\nfloat NumFont_Six( vec2 vTexCoord )\n{\n    float fResult = NumFont_Circle( vTexCoord );\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(4, 1), vec2(11,13) ));\n\n    float fHole = NumFont_Rect( vTexCoord, vec2(5, 9), vec2(8,10) );\n    fHole = max( fHole, NumFont_Rect( vTexCoord, vec2(5, 4), vec2(17,5) ));\n    fHole = max( fHole, NumFont_Rect( vTexCoord, vec2(10, 6), vec2(17,6) ));\n    fHole = max( fHole, NumFont_Rect( vTexCoord, vec2(10, 13), vec2(17,13) ));\n\n    fResult = min( fResult, 1.0 - fHole );    \n    \n    return fResult;\n}\n\nfloat NumFont_Seven( vec2 vTexCoord )\n{\n    float fResult = 0.0;\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(1, 1), vec2(11,3) ));\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(8, 4), vec2(11,13) ));\n\n    float fHole = NumFont_Rect( vTexCoord, vec2(9, -1), vec2(17,1) );\n    fHole = max( fHole, NumFont_Rect( vTexCoord, vec2(11, -1), vec2(17,3) ));\n    fResult = min( fResult, 1.0 - fHole );    \n    \n    return fResult;\n}\n\nfloat NumFont_Eight( vec2 vTexCoord )\n{\n    float fResult = 0.0;\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(2, 1), vec2(10,13) ));\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(1, 2), vec2(11,12) ));\n    \n    float fHole = NumFont_Rect( vTexCoord, vec2(5, 4), vec2(7,5) );\n    fHole = max( fHole, NumFont_Rect( vTexCoord, vec2(5, 9), vec2(7,10) ));\n    fHole = max( fHole, NumFont_Rect( vTexCoord, vec2(-1, 6), vec2(1,8) ));\n    fHole = max( fHole, NumFont_Rect( vTexCoord, vec2(11, 6), vec2(17,8) ));\n    fHole = max( fHole, NumFont_Pixel( vTexCoord, vec2(2, 7) ));\n    fHole = max( fHole, NumFont_Pixel( vTexCoord, vec2(10, 7) ));\n\n    fResult = min( fResult, 1.0 - fHole );    \n    \n    return fResult;\n}\n\nfloat NumFont_Nine( vec2 vTexCoord )\n{\n    float fResult = NumFont_Circle( vTexCoord );\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(1, 3), vec2(9,13) ));\n\n    float fHole = NumFont_Rect( vTexCoord, vec2(5, 4), vec2(7,5) );\n    fHole = max( fHole, NumFont_Rect( vTexCoord, vec2(-1, 9), vec2(7,10) ));\n    fHole = max( fHole, NumFont_Rect( vTexCoord, vec2(-1, 8), vec2(3,8) ));\n    fHole = max( fHole, NumFont_Pixel( vTexCoord, vec2(-1, 7) ));\n\n    fResult = min( fResult, 1.0 - fHole );    \n    \n    return fResult;\n}\n\nfloat NumFont_Percent( vec2 vTexCoord )\n{\n    float fResult = 0.0;\n    \n    vec2 vClosestRectMin;\n    vClosestRectMin.x = clamp( vTexCoord.x, 1.0, 11.0 );\n    vClosestRectMin.y = 12.0 - vClosestRectMin.x;\n    \n    vec2 vClosestRectMax = vClosestRectMin + vec2(0,3); \n    \n    vClosestRectMax.y = min( vClosestRectMax.y, 13.0 );\n    \n    fResult = max( fResult, NumFont_Rect( vTexCoord, vClosestRectMin, vClosestRectMax ));\n    \n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(1, 1), vec2(3,3) ));\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(9, 11), vec2(11,13) ));\n    \n    return fResult;\n}\n\nfloat NumFont_BinChar( vec2 vTexCoord, float fDigit )\n{\n    vTexCoord.y = 15. - vTexCoord.y;\n    vTexCoord = floor(vTexCoord);\n    if ( fDigit == 0.0 )\n    {\n\t\treturn NumFont_Zero( vTexCoord );\n    }\n    else\n    if ( fDigit == 1.0 )\n    {\n\t\treturn NumFont_One( vTexCoord );\n    }\n    else\n    if ( fDigit == 2.0 )\n    {\n\t\treturn NumFont_Two( vTexCoord );\n    }\n    else\n    if ( fDigit == 3.0 )\n    {\n\t\treturn NumFont_Three( vTexCoord );\n    }\n    else\n    if ( fDigit == 4.0 )\n    {\n\t\treturn NumFont_Four( vTexCoord );\n    }\n    else\n    if ( fDigit == 5.0 )\n    {\n\t\treturn NumFont_Five( vTexCoord );\n    }\n    else\n    if ( fDigit == 6.0 )\n    {\n\t\treturn NumFont_Six( vTexCoord );\n    }\n    else\n    if ( fDigit == 7.0 )\n    {\n\t\treturn NumFont_Seven( vTexCoord );\n    }\n    else\n    if ( fDigit == 8.0 )\n    {\n\t\treturn NumFont_Eight( vTexCoord );\n    }\n    else\n    if ( fDigit == 9.0 )\n    {\n\t\treturn NumFont_Nine( vTexCoord );\n    }\n    else\n    if ( fDigit == 10.0 )\n    {\n\t\treturn NumFont_Percent( vTexCoord );\n    }\n        \n    return 0.0;\n}\n\n\nvec4 NumFont_Char( vec2 vTexCoord, float fDigit )\n{\n    float fOutline = 0.0;\n    float f00 = NumFont_BinChar( vTexCoord + vec2(-1,-1), fDigit );\n    float f10 = NumFont_BinChar( vTexCoord + vec2( 0,-1), fDigit );\n    float f20 = NumFont_BinChar( vTexCoord + vec2( 1,-1), fDigit );\n        \n    float f01 = NumFont_BinChar( vTexCoord + vec2(-1, 0), fDigit );\n    float f11 = NumFont_BinChar( vTexCoord + vec2( 0, 0), fDigit );\n    float f21 = NumFont_BinChar( vTexCoord + vec2( 1, 0), fDigit );\n        \n    float f02 = NumFont_BinChar( vTexCoord + vec2(-1, 1), fDigit );\n    float f12 = NumFont_BinChar( vTexCoord + vec2( 0, 1), fDigit );\n    float f22 = NumFont_BinChar( vTexCoord + vec2( 1, 1), fDigit );\n        \n    float fn1 = NumFont_BinChar( vTexCoord + vec2(-2, 0), fDigit );\n    float fn2 = NumFont_BinChar( vTexCoord + vec2(-2, 1), fDigit );\n    \n    float fn3 = NumFont_BinChar( vTexCoord + vec2(-2, 2), fDigit );\n    float f03 = NumFont_BinChar( vTexCoord + vec2(-1, 2), fDigit );\n    float f13 = NumFont_BinChar( vTexCoord + vec2( 0, 2), fDigit );\n        \n    float fOutlineI = min( 1.0, f00 + f10 + f20 + f01 + f11 + f21 + f02 + f12 + f22 );\n    float fShadow = min( 1.0, fn1 + f01 + f21 + fn2 + f02 + f12 + fn3 + f03 + f13 );\n\n    float nx = f00 * -1.0 + f20 * 1.0\n             + f01 * -2.0 + f21 * 2.0\n         \t + f02 * -1.0 + f22 * 1.0;\n        \n    float ny = f00 * -1.0 + f02 * 1.0\n             + f10 * -2.0 + f12 * 2.0\n         \t + f20 * -1.0 + f22 * 1.0;\n    \n    vec3 n = normalize( vec3( nx, ny, 0.1 ) );\n    \n    vec3 vLight = normalize( vec3( 0.5, -1.0, 0.5 ) );\n    \n    float NdotL = dot( n, vLight ) * 0.25 + 0.75;\n    NdotL = sqrt(NdotL);\n    \n    if ( (fOutlineI + fShadow) <= 0.0 )\n    {\n        return vec4(0.0);\n    }\n\n    vec4 vResult = vec4(1.0);\n    \n    if ( fShadow > 0.0 )\n    {\n        vResult.xyz = vec3(0.2);\n    }\n\n    if ( fOutlineI > 0.0 )\n    {\n\t    vec3 vDiff = vec3(0.5,0,0);\n        \n        if ( f11 > 0.0 )\n        {\n            vDiff = vec3(1,0,0) * NdotL;\n        }\n        vResult.rgb = vDiff;\n    }\n    \n    return vResult;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\n\/\/ ----------------- 8< -------------------------- 8< -------------------------- 8< --------------\n\/\/ Start of Font code\n\nconst ivec3 _SPACE_ = ivec3(0,0,5);\nconst ivec3 _EXCLAMATION_ = ivec3(49539,384,4);\nconst ivec3 _QUOTE_ = ivec3(2331,0,7);\nconst ivec3 _HASH_ = ivec3(167818,1311,7);\nconst ivec3 _DOLLAR_ = ivec3(508575,69524,7);\nconst ivec3 _PERCENT_ = ivec3(232984,4487,8);\nconst ivec3 _AMPERSAND_ = ivec3(249630,8095,8);\nconst ivec3 _APOSTROPHE_ = ivec3(259,0,4);\nconst ivec3 _L_PAREN_ = ivec3(115614,3847,7);\nconst ivec3 _R_PAREN_ = ivec3(462351,1948,7);\nconst ivec3 _ASTERISK_ = ivec3(509700,526,7);\nconst ivec3 _PLUS_ = ivec3(114944,2,5);\nconst ivec3 _COMMA_ = ivec3(0,33152,4);\nconst ivec3 _MINUS_ = ivec3(245760,0,6);\nconst ivec3 _PERIOD_ = ivec3(0,384,4);\nconst ivec3 _SLASH_ = ivec3(232984,391,7);\nconst ivec3 _0_ = ivec3(843678,3903,8);\nconst ivec3 _1_ = ivec3(99206,774,5);\nconst ivec3 _2_ = ivec3(1039935,8067,8);\nconst ivec3 _3_ = ivec3(1023007,4024,8);\nconst ivec3 _4_ = ivec3(511387,3096,7);\nconst ivec3 _5_ = ivec3(508319,3998,7);\nconst ivec3 _6_ = ivec3(1033150,7987,8);\nconst ivec3 _7_ = ivec3(793663,6192,8);\nconst ivec3 _8_ = ivec3(498111,8115,8);\nconst ivec3 _9_ = ivec3(1038751,4024,8);\nconst ivec3 _COLON_ = ivec3(3,384,4);\nconst ivec3 _SEMICOLON_ = ivec3(384,33152,4);\nconst ivec3 _LESSTHAN_ = ivec3(98816,66307,5);\nconst ivec3 _EQUALS_ = ivec3(114688,896,5);\nconst ivec3 _GREATERTHAN_ = ivec3(49280,16774,5);\nconst ivec3 _QUESTION_MARK_ = ivec3(925568,114751,8);\nconst ivec3 _AT_ = ivec3(1532350,65237,9);\nconst ivec3 _A_ = ivec3(1038782,6579,8);\nconst ivec3 _B_ = ivec3(515135,8123,8);\nconst ivec3 _C_ = ivec3(115646,7943,8);\nconst ivec3 _D_ = ivec3(842783,4027,8);\nconst ivec3 _E_ = ivec3(1034174,7951,8);\nconst ivec3 _F_ = ivec3(508863,387,8);\nconst ivec3 _G_ = ivec3(902078,7991,8);\nconst ivec3 _H_ = ivec3(1038771,6579,8);\nconst ivec3 _I_ = ivec3(49539,387,4);\nconst ivec3 _J_ = ivec3(792624,8120,8);\nconst ivec3 _K_ = ivec3(249267,6555,8);\nconst ivec3 _L_ = ivec3(49539,8071,8);\nconst ivec3 _M_ = ivec3(2096099,12779,9);\nconst ivec3 _N_ = ivec3(1039287,7615,8);\nconst ivec3 _O_ = ivec3(843678,3903,8);\nconst ivec3 _P_ = ivec3(1039423,387,8);\nconst ivec3 _Q_ = ivec3(843678,790335,8);\nconst ivec3 _R_ = ivec3(515135,6587,8);\nconst ivec3 _S_ = ivec3(508319,3992,7);\nconst ivec3 _T_ = ivec3(198207,1548,8);\nconst ivec3 _U_ = ivec3(842163,3903,8);\nconst ivec3 _V_ = ivec3(232859,526,7);\nconst ivec3 _W_ = ivec3(2094563,15359,9);\nconst ivec3 _X_ = ivec3(466807,15294,9);\nconst ivec3 _Y_ = ivec3(498099,1548,8);\nconst ivec3 _Z_ = ivec3(232991,3975,7);\nconst ivec3 _L_SQUARE_BRACKET_ = ivec3(49543,899,5);\nconst ivec3 _BACKSLASH_ = ivec3(230275,3100,7);\nconst ivec3 _R_SQUARE_BRACKET_ = ivec3(99079,902,5);\nconst ivec3 _CARET_ = ivec3(444164,0,7);\nconst ivec3 _UNDERSCORE_ = ivec3(0,1032192,8);\n\nfloat Font_DecodeBitmap( vec2 vCoord, ivec3 vCharacter )\n{\n    vCoord = floor( vCoord );\n\n    int iRow = int(vCoord.y) - 1;\n    int iCol = int(vCoord.x) - 1;\n    \n    if ( iRow < 0 || iRow >= 6 ) return 0.0;\n    if ( iCol < 0 || iCol >= 7 ) return 0.0;\n    \n    int iRowBits = 0;\n        \n   \tif ( iRow == 0 ) \t\t\tiRowBits = vCharacter.x;\n    else  if ( iRow == 1 ) \t\tiRowBits = vCharacter.x \/ 128;\n    else  if ( iRow == 2 ) \t\tiRowBits = vCharacter.x \/ 16384;\n    else  if ( iRow == 3 ) \t\tiRowBits = vCharacter.y;\n    else  if ( iRow == 4 ) \t\tiRowBits = vCharacter.y \/ 128;\n    else \t\t\t\t\t\tiRowBits = vCharacter.y \/ 16384;\n      \n    return (iRowBits & (1 << iCol )) == 0 ? 0.0 : 1.0;\n}\n\n\nstruct PrintState\n{\n    vec2 vTexCoord;\n    vec2 vOrigin;\n    vec2 vPos;\n    \n    vec3 vColor;\n    vec3 vOutline;\n};\n    \nvoid Print_MoveTo( inout PrintState printState, vec2 vPos )\n{\n    printState.vOrigin = printState.vTexCoord - vPos;\n    printState.vPos = printState.vOrigin;\n}\n\nvoid Print_Newline( inout PrintState printState )\n{\n    printState.vPos.x = printState.vOrigin.x;\n    printState.vPos.y -= 8.0;\n}\n\nvoid Print_Color( inout PrintState printState, vec3 vColor )\n{\n    printState.vColor = vColor;\n}\n\nvoid Print_Init( out PrintState printState, vec2 vTexCoord )\n{\n    printState.vTexCoord = vTexCoord;        \n    printState.vOrigin = vTexCoord;\n    printState.vPos = vTexCoord;\n    printState.vColor = vec3(1,0,0);\n    printState.vOutline = vec3(.3,0,0);\n    Print_MoveTo( printState, vec2(0) ); \n}\n\nvoid Print_Space( inout PrintState printState )\n{\n    printState.vPos.x -= 5.0;\n}\n\nbool Print_Test( inout PrintState printState, ivec3 vCharacter, float fSpacing )\n{\n    if ( vCharacter.z == -1 )\n    {\n        Print_MoveTo( printState, vec2(vCharacter.xy) );\n        return false;\n    }\n    \n    if ( printState.vPos.x < float(vCharacter.z) )\n        return true;\n         \n\tprintState.vPos.x -= float(vCharacter.z) + fSpacing;\n    return false;\n}\n\nvoid Print_Char( inout PrintState printState, inout vec3 vResult, ivec3 vCharacter )\n{\n    float fBitmap = Font_DecodeBitmap( printState.vPos, vCharacter );\n    if ( fBitmap > 0.0 ) vResult = printState.vColor;\n    \n    printState.vPos.x -= float(vCharacter.z - 1);\n}\n\nvoid Print_HudChar( inout PrintState printState, inout vec3 vResult, ivec3 vCharacter )\n{\n    float fBitmap = Font_DecodeBitmap( printState.vPos, vCharacter );\n    float fShadow = Font_DecodeBitmap( printState.vPos - vec2( 1, 1), vCharacter );\n\n    if ( fBitmap > 0.0 ) vResult = printState.vColor * 0.5 + 0.5 * (printState.vPos.y \/ 8.);\n    else if ( fShadow > 0.0 ) vResult *= 0.5;\n    \n    printState.vPos.x -= float(vCharacter.z);\n}\n\nvoid Print_FancyChar( inout PrintState printState, inout vec3 vResult, ivec3 vCharacter )\n{\n    float fBitmapTL = Font_DecodeBitmap( printState.vPos - vec2(-1,-1), vCharacter );\n    float fBitmapTC = Font_DecodeBitmap( printState.vPos - vec2( 0,-1), vCharacter );\n    float fBitmapTR = Font_DecodeBitmap( printState.vPos - vec2( 1,-1), vCharacter );\n\n    float fBitmapCL = Font_DecodeBitmap( printState.vPos - vec2(-1, 0), vCharacter );\n    float fBitmapCC = Font_DecodeBitmap( printState.vPos - vec2( 0, 0), vCharacter );\n    float fBitmapCR = Font_DecodeBitmap( printState.vPos - vec2( 1, 0), vCharacter );\n    \n    float fBitmapBL = Font_DecodeBitmap( printState.vPos - vec2(-1, 1), vCharacter );\n    float fBitmapBC = Font_DecodeBitmap( printState.vPos - vec2( 0, 1), vCharacter );\n    float fBitmapBR = Font_DecodeBitmap( printState.vPos - vec2( 1, 1), vCharacter );\n    \n    float fOutline \t= min( 1., fBitmapTL + fBitmapTC + fBitmapTR + fBitmapCL + fBitmapCR + fBitmapBL + fBitmapBC + fBitmapBR );    \n    float fShade = (fBitmapTL * .5 - fBitmapBR * .5 ) + 0.5;\n    \n    if ( fBitmapCC > 0.0 ) vResult = printState.vColor * (fShade * 0.25 + 0.75);\n    else\n    if ( fOutline > 0.0 ) vResult = printState.vOutline;\n    \n    printState.vPos.x -= float(vCharacter.z);\n}\n\n\/\/ End of font code\n\/\/ ----------------- 8< -------------------------- 8< -------------------------- 8< --------------\n\n\nivec3 GetMessageChar( int iMessage, int iChar )\n{\n\t#define MESSAGE_CHAR(X) if ( iChar == 0 ) return X; iChar--\n    \n    if (iMessage == MESSAGE_HUD_TEXT)\n    {\n        MESSAGE_CHAR( ivec3(6,0, -1) ); \/\/ MOVE\n\n        MESSAGE_CHAR( _A_ );\n        MESSAGE_CHAR( _M_ );\n        MESSAGE_CHAR( _M_ );\n        MESSAGE_CHAR( _O_ );\n\n        MESSAGE_CHAR( ivec3(52,0, -1) ); \/\/ MOVE\n\n        MESSAGE_CHAR( _H_ );\n        MESSAGE_CHAR( _E_ );\n        MESSAGE_CHAR( _A_ );\n        MESSAGE_CHAR( _L_ );\n        MESSAGE_CHAR( _T_ );\n        MESSAGE_CHAR( _H_ );\n\n        MESSAGE_CHAR( ivec3(109,0, -1) ); \/\/ MOVE\n\n        MESSAGE_CHAR( _A_ );\n        MESSAGE_CHAR( _R_ );\n        MESSAGE_CHAR( _M_ );\n        MESSAGE_CHAR( _S_ );\n\n        MESSAGE_CHAR( ivec3(187,0, -1) ); \/\/ MOVE\n\n        MESSAGE_CHAR( _A_ );\n        MESSAGE_CHAR( _R_ );\n        MESSAGE_CHAR( _M_ );\n        MESSAGE_CHAR( _O_ );\n        MESSAGE_CHAR( _R_ );        \n    }\n    else\n    if (iMessage == MESSAGE_CHOOSE_SKILL )\n    {\n        MESSAGE_CHAR( _C_ ); MESSAGE_CHAR( _H_ );MESSAGE_CHAR( _O_ ); MESSAGE_CHAR( _O_ ); MESSAGE_CHAR( _S_ ); MESSAGE_CHAR( _E_ );\n        MESSAGE_CHAR( _SPACE_ );\n        MESSAGE_CHAR( _S_ ); MESSAGE_CHAR( _K_ );MESSAGE_CHAR( _I_ ); MESSAGE_CHAR( _L_ ); MESSAGE_CHAR( _L_ );\n        MESSAGE_CHAR( _SPACE_ );\n        MESSAGE_CHAR( _L_ ); MESSAGE_CHAR( _E_ );MESSAGE_CHAR( _V_ ); MESSAGE_CHAR( _E_ ); MESSAGE_CHAR( _L_ );\n        MESSAGE_CHAR( _COLON_ );\n    }\n    else\n    if (iMessage == MESSAGE_SKILL_1 )\n    {\n        MESSAGE_CHAR( _I_ ); MESSAGE_CHAR( _APOSTROPHE_ );MESSAGE_CHAR( _M_ );\n        MESSAGE_CHAR( _SPACE_ );\n        MESSAGE_CHAR( _T_ ); MESSAGE_CHAR( _O_ );MESSAGE_CHAR( _O_ );\n        MESSAGE_CHAR( _SPACE_ );\n        MESSAGE_CHAR( _Y_ ); MESSAGE_CHAR( _O_ );MESSAGE_CHAR( _U_ ); MESSAGE_CHAR( _N_ ); MESSAGE_CHAR( _G_ );\n        MESSAGE_CHAR( _SPACE_ );\n        MESSAGE_CHAR( _T_ ); MESSAGE_CHAR( _O_ );\n        MESSAGE_CHAR( _SPACE_ );\n        MESSAGE_CHAR( _D_ ); MESSAGE_CHAR( _I_ );MESSAGE_CHAR( _E_ );\n        MESSAGE_CHAR( _PERIOD_ );\n    }\n    else\n    if (iMessage == MESSAGE_SKILL_2 )\n    {\n        MESSAGE_CHAR( _H_ ); MESSAGE_CHAR( _E_ );MESSAGE_CHAR( _Y_ );\n        MESSAGE_CHAR( _COMMA_ );MESSAGE_CHAR( _SPACE_ );\n        MESSAGE_CHAR( _N_ ); MESSAGE_CHAR( _O_ );MESSAGE_CHAR( _T_ );\n        MESSAGE_CHAR( _SPACE_ );\n        MESSAGE_CHAR( _T_ ); MESSAGE_CHAR( _O_ );MESSAGE_CHAR( _O_ );\n        MESSAGE_CHAR( _SPACE_ );\n        MESSAGE_CHAR( _R_ ); MESSAGE_CHAR( _O_ );MESSAGE_CHAR( _U_ ); MESSAGE_CHAR( _G_ ); MESSAGE_CHAR( _H_ );\n        MESSAGE_CHAR( _PERIOD_ );\n    }\n    else\n    if (iMessage == MESSAGE_SKILL_3 )\n    {\n        MESSAGE_CHAR( _H_ ); MESSAGE_CHAR( _U_ );MESSAGE_CHAR( _R_ );MESSAGE_CHAR( _T_ );\n        MESSAGE_CHAR( _SPACE_ );\n        MESSAGE_CHAR( _M_ );MESSAGE_CHAR( _E_ );\n        MESSAGE_CHAR( _SPACE_ );\n        MESSAGE_CHAR( _P_ ); MESSAGE_CHAR( _L_ );MESSAGE_CHAR( _E_ ); MESSAGE_CHAR( _N_ ); MESSAGE_CHAR( _T_ ); MESSAGE_CHAR( _Y_ );\n        MESSAGE_CHAR( _PERIOD_ );\n    }\n    else\n    if (iMessage == MESSAGE_SKILL_4 )\n    {\n        MESSAGE_CHAR( _U_ ); MESSAGE_CHAR( _L_ );MESSAGE_CHAR( _T_ );MESSAGE_CHAR( _R_ );MESSAGE_CHAR( _A_ );\n        MESSAGE_CHAR( _MINUS_ );\n        MESSAGE_CHAR( _V_ ); MESSAGE_CHAR( _I_ );MESSAGE_CHAR( _O_ );MESSAGE_CHAR( _L_ );MESSAGE_CHAR( _E_ );MESSAGE_CHAR( _N_ );MESSAGE_CHAR( _C_ );MESSAGE_CHAR( _E_ );\n        MESSAGE_CHAR( _PERIOD_ );\n    }\n    else\n    if (iMessage == MESSAGE_SKILL_5 )\n    {\n        MESSAGE_CHAR( _N_ ); MESSAGE_CHAR( _I_ );MESSAGE_CHAR( _G_ );MESSAGE_CHAR( _H_ );MESSAGE_CHAR( _T_ );MESSAGE_CHAR( _M_ );MESSAGE_CHAR( _A_ );MESSAGE_CHAR( _R_ );MESSAGE_CHAR( _E_ );\n        MESSAGE_CHAR( _EXCLAMATION_ );\n    }\n    else\n    if (iMessage == MESSAGE_HANGAR )\n    {\n        MESSAGE_CHAR( _H_ ); MESSAGE_CHAR( _A_ );MESSAGE_CHAR( _N_ );MESSAGE_CHAR( _G_ );MESSAGE_CHAR( _A_ );MESSAGE_CHAR( _R_ );\n    }\n    else\n    if (iMessage == MESSAGE_FINISHED )\n    {\n        MESSAGE_CHAR( _F_ ); MESSAGE_CHAR( _I_ );MESSAGE_CHAR( _N_ );MESSAGE_CHAR( _I_ );MESSAGE_CHAR( _S_ );MESSAGE_CHAR( _H_ );MESSAGE_CHAR( _E_ );MESSAGE_CHAR( _D_ );\n    }\n    else\n    if (iMessage == MESSAGE_KILLS )\n    {\n        MESSAGE_CHAR( _K_ ); MESSAGE_CHAR( _I_ );MESSAGE_CHAR( _L_ );MESSAGE_CHAR( _L_ );MESSAGE_CHAR( _S_ );\n    }\n    else\n    if (iMessage == MESSAGE_ITEMS )\n    {\n        MESSAGE_CHAR( _I_ ); MESSAGE_CHAR( _T_ );MESSAGE_CHAR( _E_ );MESSAGE_CHAR( _M_ );MESSAGE_CHAR( _S_ );\n    }\n    else\n    if (iMessage == MESSAGE_SECRET )\n    {\n        MESSAGE_CHAR( _S_ ); MESSAGE_CHAR( _E_ );MESSAGE_CHAR( _C_ );MESSAGE_CHAR( _R_ );MESSAGE_CHAR( _E_ );MESSAGE_CHAR( _T_ );\n    }\n    else\n    if (iMessage == MESSAGE_TIME )\n    {\n        MESSAGE_CHAR( _T_ ); MESSAGE_CHAR( _I_ );MESSAGE_CHAR( _M_ );MESSAGE_CHAR( _E_ );\n    }\n    else\n    if (iMessage == MESSAGE_SELECT )\n    {\n        MESSAGE_CHAR( _ASTERISK_ );\n    }\n    else\n    {    \n        if ( iMessage == MESSAGE_HEALTH_BONUS ||\n            iMessage == MESSAGE_ARMOR_BONUS || \n            iMessage == MESSAGE_GREENARMOR || \n            iMessage == MESSAGE_BLUEARMOR ||\n            iMessage == MESSAGE_STIMPACK ||\n           iMessage == MESSAGE_MEDIKIT)\n        {\n            MESSAGE_CHAR( _P_ );\n            MESSAGE_CHAR( _I_ );\n            MESSAGE_CHAR( _C_ );\n            MESSAGE_CHAR( _K_ );\n            MESSAGE_CHAR( _E_ );\n            MESSAGE_CHAR( _D_ );\n\n            MESSAGE_CHAR( _SPACE_ );\n\n            MESSAGE_CHAR( _U_ );\n            MESSAGE_CHAR( _P_ );\n\n            MESSAGE_CHAR( _SPACE_ );\n        }\n        else\n        if( iMessage == MESSAGE_SHOTGUN )\n        {\n            MESSAGE_CHAR( _Y_ );\n            MESSAGE_CHAR( _O_ );\n            MESSAGE_CHAR( _U_ );\n\n            MESSAGE_CHAR( _SPACE_ );\n\n            MESSAGE_CHAR( _G_ );\n            MESSAGE_CHAR( _O_ );\n            MESSAGE_CHAR( _T_ );\n\n            MESSAGE_CHAR( _SPACE_ );\n        }\n\n\n        if ( iMessage == MESSAGE_HEALTH_BONUS || iMessage == MESSAGE_ARMOR_BONUS || iMessage == MESSAGE_STIMPACK || iMessage == MESSAGE_MEDIKIT)\n        {    \n            MESSAGE_CHAR( _A_ );\n            if ( iMessage == MESSAGE_ARMOR_BONUS )\n            {    \n                MESSAGE_CHAR( _N_ );\n            }\n            MESSAGE_CHAR( _SPACE_ );\n        }\n        else if ( iMessage == MESSAGE_GREENARMOR ||\n                iMessage == MESSAGE_BLUEARMOR || \n                iMessage == MESSAGE_SHOTGUN )\n        {\n            MESSAGE_CHAR( _T_ );\n            MESSAGE_CHAR( _H_ );\n            MESSAGE_CHAR( _E_ );\n\n            MESSAGE_CHAR( _SPACE_ );\n        }\n\n        if ( iMessage == MESSAGE_BLUEARMOR )\n        {\n            MESSAGE_CHAR( _M_ );\n            MESSAGE_CHAR( _E_ );\n            MESSAGE_CHAR( _G_ );\n            MESSAGE_CHAR( _A_ );\n        }\n\n        if( iMessage == MESSAGE_SHOTGUN )\n        {\n            MESSAGE_CHAR( _S_ );\n            MESSAGE_CHAR( _H_ );\n            MESSAGE_CHAR( _O_ );\n            MESSAGE_CHAR( _T_ );\n            MESSAGE_CHAR( _G_ );\n            MESSAGE_CHAR( _U_ );\n            MESSAGE_CHAR( _N_ );\n        }\n\n        if ( iMessage == MESSAGE_HEALTH_BONUS )\n        {    \n            MESSAGE_CHAR( _H_ );\n            MESSAGE_CHAR( _E_ );\n            MESSAGE_CHAR( _A_ );\n            MESSAGE_CHAR( _L_ );\n            MESSAGE_CHAR( _T_ );\n            MESSAGE_CHAR( _H_ );\n        }\n        else if ( iMessage == MESSAGE_ARMOR_BONUS || iMessage == MESSAGE_GREENARMOR || iMessage == MESSAGE_BLUEARMOR)\n        {    \n            MESSAGE_CHAR( _A_ );\n            MESSAGE_CHAR( _R_ );\n            MESSAGE_CHAR( _M_ );\n            MESSAGE_CHAR( _O_ );\n            MESSAGE_CHAR( _R_ );\n        }\n        else if ( iMessage == MESSAGE_MEDIKIT )\n        {    \n            MESSAGE_CHAR( _M_ );\n            MESSAGE_CHAR( _E_ );\n            MESSAGE_CHAR( _D_ );\n            MESSAGE_CHAR( _I_ );\n            MESSAGE_CHAR( _K_ );\n            MESSAGE_CHAR( _I_ );\n            MESSAGE_CHAR( _T_ );\n        }\n        else if ( iMessage == MESSAGE_STIMPACK )\n        {\n            MESSAGE_CHAR( _S_ );\n            MESSAGE_CHAR( _T_ );\n            MESSAGE_CHAR( _I_ );\n            MESSAGE_CHAR( _M_ );\n            MESSAGE_CHAR( _P_ );\n            MESSAGE_CHAR( _A_ );\n            MESSAGE_CHAR( _C_ );\n            MESSAGE_CHAR( _K_ );\n        }\n\n        if ( iMessage == MESSAGE_HEALTH_BONUS || iMessage == MESSAGE_ARMOR_BONUS)\n        {    \n            MESSAGE_CHAR( _SPACE_ );\n\n            MESSAGE_CHAR( _B_ );\n            MESSAGE_CHAR( _O_ );\n            MESSAGE_CHAR( _N_ );\n            MESSAGE_CHAR( _U_ );\n            MESSAGE_CHAR( _S_ );\n        }\n\n        if ( iMessage == MESSAGE_BLUEARMOR || iMessage == MESSAGE_SHOTGUN )\n        {\n            MESSAGE_CHAR( _EXCLAMATION_ );\n        }\n        else\n        {\n            MESSAGE_CHAR( _PERIOD_ );\n        }   \n    }\n    \n    return ivec3(0.0);\n}\n\nvoid PrintHudMessage( vec2 vTexCoord, int iMessage, inout vec3 vResult )\n{\n    if ( vTexCoord.y > 8.0 )\n        return;\n\n    if ( iMessage >= MESSAGE_COUNT )\n        return;\n    \n    \/\/ Message text\n    PrintState printState;\n    Print_Init( printState, vTexCoord );\n\n    \/\/ Fixed size font\n    \/\/float fCharIndex = floor( printState.vPos.x \/ 8. );\n    \/\/printState.vPos.x -= fCharIndex * 8.0;\n    \/\/vec3 vChar = GetMessageChar( fMessage, fCharIndex );\n    \n    ivec3 vChar = _SPACE_;\n    for ( int i=0; i<NO_UNROLL( 26 ); i++)\n    {\n        vChar = GetMessageChar( iMessage, i );\n        if ( Print_Test( printState, vChar, 0.0 ) )\n        {\n            break;\n        }\n        if ( vChar.z == 0 )\n            break;\n    }\n        \n    if ( iMessage == MESSAGE_HUD_TEXT || iMessage == MESSAGE_HANGAR )\n    {\n\t\tPrint_Color( printState, vec3(1. ) );        \n    \tPrint_HudChar( printState, vResult, vChar );\n    }\n    else\n    {\n    \tPrint_FancyChar( printState, vResult, vChar );\n    }\n}\n\n\/\/ Constant Data\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nfloat hash(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\n#define GRID_POS \t\tvec2(244,32)\n#define GRID_SIZE \t\tvec2(256,256)\n#define GRID_WORLD_MIN\tvec2(-780,-4900)\n#define GRID_WORLD_MAX\tvec2(3820,-2060)\n\nbool LineInGridCell( vec2 vA, vec2 vB, vec2 vGridCellMin, vec2 vGridCellMax )\n{\n    vec2 vAB = vB - vA;\n    \n    \/\/ Check if box crosses line\n\n    float fCross0 = Cross2d( vAB, vec2(vGridCellMin.x, vGridCellMin.y) - vA );\n    float fCross1 = Cross2d( vAB, vec2(vGridCellMax.x, vGridCellMin.y) - vA );\n    float fCross2 = Cross2d( vAB, vec2(vGridCellMin.x, vGridCellMax.y) - vA );\n    float fCross3 = Cross2d( vAB, vec2(vGridCellMax.x, vGridCellMax.y) - vA );\n       \n    if ( fCross0 < 0.0 && fCross1 < 0.0 && fCross2 < 0.0 && fCross3 < 0.0 )\n        return false;\n\n    if ( fCross0 > 0.0 && fCross1 > 0.0 && fCross2 > 0.0 && fCross3 > 0.0 )\n        return false;\n           \n    \/\/ Check if line projection crosses box\n\n    vec2 vLineMin = min( vA, vB );\n    vec2 vLineMax = max( vA, vB );\n\n    if ( vLineMin.x > vGridCellMax.x ) return false;\n    if ( vLineMin.y > vGridCellMax.y ) return false;\n    if ( vLineMax.x < vGridCellMin.x ) return false;\n    if ( vLineMax.y < vGridCellMin.y ) return false;\n    \n    return true;\n}\n\nbool Map_SectorInGridCell( sampler2D mapSampler, MapInfo mapInfo, vec2 vGridCellMin, vec2 vGridCellMax, int iSectorId )\n{\n    Sector sector;\n    \n    sector = Map_ReadSector( mapSampler, iSectorId );\n    \n    float fInOutTest = 0.0;\n    \n    for(int iSideDefIndex=0; iSideDefIndex<NO_UNROLL( MAX_SIDEDEF_COUNT ); iSideDefIndex++)\n    {        \n        SideDef sideDef = Map_ReadSideDefInfo( mapSampler, sector.iSectorId, iSideDefIndex );                        \n        \n        if ( sideDef.fLength <= 0.0)\n        {\n            break;\n        }\n\n        if ( LineInGridCell( sideDef.vA, sideDef.vB, vGridCellMin, vGridCellMax ) )\n        {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\nvec4 GetGridData( sampler2D mapSampler, vec2 vGridCellWorldMin, vec2 vGridCellWorldMax )\n{\n    MapInfo mapInfo = ReadMapInfo( mapSampler );\n    \n    int sectorCount = 0;\n    int gridSectors[8];\n        \n\tgridSectors[0] = -1;\n    gridSectors[1] = -1;\n    gridSectors[2] = -1;\n    gridSectors[3] = -1;\n    gridSectors[4] = -1;\n    gridSectors[5] = -1;\n    gridSectors[6] = -1;\n    gridSectors[7] = -1;\n    \n    \/\/gridSectors[0] = Map_SeekSector( mapInfo, vGridCellWorldMin ); \n    \n\tint foundIndex = 0;\n    for(int iSectorIndex=0; iSectorIndex<NO_UNROLL( MAX_SECTOR_COUNT ); iSectorIndex++)\n    {\n        if ( !Map_ValidSectorId( mapInfo, iSectorIndex ) )\n        {\n            break;\n        }\n\n        if ( foundIndex > 7 )\n        {\n            break;\n        }\n        \n        if ( Map_SectorInGridCell( mapSampler, mapInfo, vGridCellWorldMin, vGridCellWorldMax, iSectorIndex ) )\n        {\n            if ( foundIndex == 0 ) gridSectors[0] = iSectorIndex;\n            if ( foundIndex == 1 ) gridSectors[1] = iSectorIndex;\n            if ( foundIndex == 2 ) gridSectors[2] = iSectorIndex;\n            if ( foundIndex == 3 ) gridSectors[3] = iSectorIndex;\n            if ( foundIndex == 4 ) gridSectors[4] = iSectorIndex;\n            if ( foundIndex == 5 ) gridSectors[5] = iSectorIndex;\n            if ( foundIndex == 6 ) gridSectors[6] = iSectorIndex;\n            if ( foundIndex == 7 ) gridSectors[7] = iSectorIndex;\n            foundIndex++;\n        }        \n    }\n    \n\n    vec4 gridDataPacked;\n    gridDataPacked.x = BytePack2( vec2( gridSectors[0], gridSectors[1] ) + 1. );\n    gridDataPacked.y = BytePack2( vec2( gridSectors[2], gridSectors[3] ) + 1. );\n    gridDataPacked.z = BytePack2( vec2( gridSectors[4], gridSectors[5] ) + 1. );\n    gridDataPacked.w = BytePack2( vec2( gridSectors[6], gridSectors[7] ) + 1. );\n    \n    return gridDataPacked;\n}\n\n#define PACK_DATA(A,B,C,D) ( A + (B<<8) + (C<<16) + (D<<24) )\n#define UNPACK_DATA(X) uvec4( X & 0xffu, (X>>8u)&0xffu, (X>>16u)&0xffu, (X>>24u)&0xffu )\n\n\t\t\/\/ Textures\n\t\t#define TEX_X 0u\n\t\t#define TEX_F_SKY1 1u\n\t\t#define TEX_NUKAGE3 2u\n\t\t#define TEX_FLOOR7_1 3u\n\t\t#define TEX_FLOOR4_8 4u\n\t\t#define TEX_CEIL5_1 5u\n\t\t#define TEX_FLAT5_5 6u\n\t\t#define TEX_FLAT20 7u\n\t\t#define TEX_FLOOR5_1 8u\n\t\t#define TEX_CEIL5_2 9u\n\t\t#define TEX_CEIL3_5 10u\n\t\t#define TEX_TLITE6_5 11u\n\t\t#define TEX_FLAT14 12u\n\t\t#define TEX_FLAT18 13u\n\t\t#define TEX_TLITE6_4 14u\n\t\t#define TEX_FLOOR7_2 15u\n\t\t#define TEX_STEP2 16u\n\t\t#define TEX_TLITE6_1 17u\n\t\t#define TEX_FLOOR1_1 18u\n\t\t#define TEX_FLOOR5_2 19u\n\t\t#define TEX_FLOOR6_2 20u\n\t\t#define TEX_FLAT23 21u\n\t\t#define TEX_TLITE6_6 22u\n\t\t#define TEX_DOOR3 23u\n\t\t#define TEX_LITE3 24u\n\t\t#define TEX_STARTAN3 25u\n\t\t#define TEX_BROWN1 26u\n\t\t#define TEX_DOORSTOP 27u\n\t\t#define TEX_COMPUTE2 28u\n\t\t#define TEX_STEP6 29u\n\t\t#define TEX_BROWN144 30u\n\t\t#define TEX_SUPPORT2 31u\n\t\t#define TEX_STARG3 32u\n\t\t#define TEX_DOORTRAK 33u\n\t\t#define TEX_SLADWALL 34u\n\t\t#define TEX_TEKWALL4 35u\n\t\t#define TEX_SW1COMP 36u\n\t\t#define TEX_BIGDOOR2 37u\n\t\t#define TEX_STARGR1 38u\n\t\t#define TEX_BROWNGRN 39u\n\t\t#define TEX_NUKE24 40u\n\t\t#define TEX_BROWN96 41u\n\t\t#define TEX_BRNBIGR 42u\n\t\t#define TEX_BRNBIGL 43u\n\t\t#define TEX_BRNBIGC 44u\n\t\t#define TEX_STARTAN1 45u\n\t\t#define TEX_EXITDOOR 46u\n\t\t#define TEX_SW1STRTN 47u\n\t\t#define TEX_BIGDOOR4 48u\n\t\t#define TEX_EXITSIGN 49u\n\t\t#define TEX_TEKWALL1 50u\n\t\t#define TEX_COMPTALL 51u\n\t\t#define TEX_COMPSPAN 52u\n\t\t#define TEX_PLANET1 53u\n\t\t#define TEX_COMPTILE 54u\n\t\t#define TEX_STEP1 55u\n\t\t#define TEX_COMPUTE3 56u\n        \n\t\tstruct DataSideDefPacked\n        {\n            uint A;\n            uint B;\n            uint packed0;\n            uint packed1;\n        };\n\n\t\tstruct DataSideDef\n\t\t{\n\t\t\tivec2 A;\n\t\t\tivec2 B;\n\t\t\tint len;\n\t\t\tint otherSector;\n\t\t\tfloat lightLevel;\n\t\t\tuint bytePacked;\n\t\t};\n            \n\t\t#define DATA_SIDE_DEF(Ax, Ay, Bx, By, len, otherSector, light, packed)\t\t\\\n            DataSideDefPacked\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n            (\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n                uint((Ax+8192)|((Ay+8192)<<16)),\t\t\t\t\t\t\t\t\t\\\n                uint((Bx+8192)|((By+8192)<<16)),\t\t\t\t\t\t\t\t\t\\\n                uint(len<<16)|(uint(sign(light)+1.)<<14)|uint(otherSector+1),\t\t\\\n                packed\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n            )\n            \n\t\tDataSideDef UnpackSideDef( const DataSideDefPacked p)\n        {\n            DataSideDef sideDef;\n            sideDef.A.x = int(p.A & 0xffffu) - 8192;\n            sideDef.A.y = int(p.A >> 16) - 8192;\n            sideDef.B.x = int(p.B & 0xffffu) - 8192;\n            sideDef.B.y = int(p.B >> 16) - 8192;\n            sideDef.len = int(p.packed0 >> 16) - 1;\n            sideDef.otherSector = int(p.packed0 & 0x3fffu) - 1;\n            sideDef.lightLevel = .063 * (float((p.packed0 >> 14) & 3u) - 1.);\n            sideDef.bytePacked = p.packed1;\n            return sideDef;\n        }            \n\n\t\tstruct DataSector\n\t\t{\n\t\t\tfloat lightLevel;\n\t\t\tint floorHeight;\n\t\t\tint ceilingHeight;\n\t\t\tuint floorTex;\n\t\t\tuint ceilingTex;\n\t\t\tint firstSideDef;\n\t\t\tint sideDefCount;\n\t\t};\n            \n\t\tstruct DataEntity\n\t\t{\n\t\t\tivec2 origin;\n\t\t\tint type;\n\t\t\tint subType;\n\t\t\tint angle;\n\t\t\tint flags;\n\t\t\tivec2 triggerPos;\n\t\t};\n\n\t\tstruct DataMap\n\t\t{\n\t\t\tint sectorCount;\n\t\t\tDataSector sectors[88];\n\t\t\tDataSideDefPacked sideDefs[666];\n\t\t\tDataEntity entities[102];\n\t\t};\n\n\t\tconst DataMap map = DataMap(\n\t\t\t88,\n\t\t\tDataSector[88] (\n\t\t\t\t\/\/ Sector Data 0\n\t\t\t\tDataSector( 1.000, -80, 216, TEX_NUKAGE3, TEX_F_SKY1, 0, 8 ),\n\t\t\t\t\/\/ Sector Data 1\n\t\t\t\tDataSector( 1.000, -56, 216, TEX_FLOOR7_1, TEX_F_SKY1, 8, 29 ),\n\t\t\t\t\/\/ Sector Data 2\n\t\t\t\tDataSector( 1.000, 0, 0, TEX_FLOOR4_8, TEX_CEIL5_1, 37, 6 ),\n\t\t\t\t\/\/ Sector Data 3\n\t\t\t\tDataSector( 1.000, 8, 192, TEX_FLAT5_5, TEX_FLAT5_5, 43, 4 ),\n\t\t\t\t\/\/ Sector Data 4\n\t\t\t\tDataSector( 0.565, 0, 0, TEX_FLOOR4_8, TEX_FLAT20, 47, 4 ),\n\t\t\t\t\/\/ Sector Data 5\n\t\t\t\tDataSector( 1.000, 8, 192, TEX_FLAT5_5, TEX_FLAT5_5, 51, 4 ),\n\t\t\t\t\/\/ Sector Data 6\n\t\t\t\tDataSector( 0.502, -136, -40, TEX_FLOOR5_1, TEX_CEIL5_2, 55, 7 ),\n\t\t\t\t\/\/ Sector Data 7\n\t\t\t\tDataSector( 0.502, -120, 16, TEX_FLOOR5_1, TEX_CEIL5_2, 62, 4 ),\n\t\t\t\t\/\/ Sector Data 8\n\t\t\t\tDataSector( 0.502, -104, 16, TEX_FLOOR5_1, TEX_CEIL5_2, 66, 4 ),\n\t\t\t\t\/\/ Sector Data 9\n\t\t\t\tDataSector( 0.502, -88, 16, TEX_FLOOR5_1, TEX_CEIL5_2, 70, 4 ),\n\t\t\t\t\/\/ Sector Data 10\n\t\t\t\tDataSector( 0.502, -72, 16, TEX_FLOOR5_1, TEX_CEIL5_2, 74, 4 ),\n\t\t\t\t\/\/ Sector Data 11\n\t\t\t\tDataSector( 1.000, -56, 24, TEX_FLOOR7_1, TEX_F_SKY1, 78, 5 ),\n\t\t\t\t\/\/ Sector Data 12\n\t\t\t\tDataSector( 1.000, -56, 64, TEX_FLOOR7_1, TEX_F_SKY1, 83, 8 ),\n\t\t\t\t\/\/ Sector Data 13\n\t\t\t\tDataSector( 0.690, -56, 16, TEX_FLOOR7_1, TEX_CEIL5_2, 91, 6 ),\n\t\t\t\t\/\/ Sector Data 14\n\t\t\t\tDataSector( 1.000, 32, 88, TEX_FLOOR4_8, TEX_CEIL5_1, 97, 4 ),\n\t\t\t\t\/\/ Sector Data 15\n\t\t\t\tDataSector( 0.502, 0, 224, TEX_FLOOR4_8, TEX_CEIL3_5, 101, 32 ),\n\t\t\t\t\/\/ Sector Data 16\n\t\t\t\tDataSector( 1.000, 0, 224, TEX_FLOOR4_8, TEX_CEIL3_5, 133, 8 ),\n\t\t\t\t\/\/ Sector Data 17\n\t\t\t\tDataSector( 1.000, 0, 96, TEX_FLOOR4_8, TEX_TLITE6_5, 141, 4 ),\n\t\t\t\t\/\/ Sector Data 18\n\t\t\t\tDataSector( 1.000, 0, 224, TEX_FLOOR4_8, TEX_CEIL3_5, 145, 8 ),\n\t\t\t\t\/\/ Sector Data 19\n\t\t\t\tDataSector( 1.000, 0, 96, TEX_FLOOR4_8, TEX_TLITE6_5, 153, 4 ),\n\t\t\t\t\/\/ Sector Data 20\n\t\t\t\tDataSector( 1.000, 8, 152, TEX_FLAT14, TEX_TLITE6_5, 157, 4 ),\n\t\t\t\t\/\/ Sector Data 21\n\t\t\t\tDataSector( 1.000, 32, 88, TEX_FLAT18, TEX_CEIL5_1, 161, 12 ),\n\t\t\t\t\/\/ Sector Data 22\n\t\t\t\tDataSector( 0.627, 0, 72, TEX_FLOOR4_8, TEX_CEIL3_5, 173, 4 ),\n\t\t\t\t\/\/ Sector Data 23\n\t\t\t\tDataSector( 1.000, 32, 88, TEX_FLAT18, TEX_CEIL5_1, 177, 6 ),\n\t\t\t\t\/\/ Sector Data 24\n\t\t\t\tDataSector( 0.565, 0, 144, TEX_FLOOR4_8, TEX_CEIL3_5, 183, 6 ),\n\t\t\t\t\/\/ Sector Data 25\n\t\t\t\tDataSector( 1.000, 0, 88, TEX_FLOOR4_8, TEX_TLITE6_4, 189, 4 ),\n\t\t\t\t\/\/ Sector Data 26\n\t\t\t\tDataSector( 0.816, 0, 0, TEX_FLOOR4_8, TEX_FLAT20, 193, 4 ),\n\t\t\t\t\/\/ Sector Data 27\n\t\t\t\tDataSector( 0.878, -16, 200, TEX_FLAT14, TEX_CEIL3_5, 197, 12 ),\n\t\t\t\t\/\/ Sector Data 28\n\t\t\t\tDataSector( 0.753, -8, 120, TEX_FLAT14, TEX_CEIL3_5, 209, 12 ),\n\t\t\t\t\/\/ Sector Data 29\n\t\t\t\tDataSector( 0.565, 0, 72, TEX_FLOOR4_8, TEX_CEIL3_5, 221, 29 ),\n\t\t\t\t\/\/ Sector Data 30\n\t\t\t\tDataSector( 1.000, 0, 72, TEX_FLOOR4_8, TEX_CEIL3_5, 250, 4 ),\n\t\t\t\t\/\/ Sector Data 31\n\t\t\t\tDataSector( 0.502, -8, 120, TEX_FLOOR4_8, TEX_CEIL3_5, 254, 10 ),\n\t\t\t\t\/\/ Sector Data 32\n\t\t\t\tDataSector( 0.502, -8, 224, TEX_FLOOR4_8, TEX_FLOOR7_2, 264, 32 ),\n\t\t\t\t\/\/ Sector Data 33\n\t\t\t\tDataSector( 0.565, 8, 224, TEX_FLOOR4_8, TEX_FLOOR7_2, 296, 4 ),\n\t\t\t\t\/\/ Sector Data 34\n\t\t\t\tDataSector( 0.565, 24, 224, TEX_FLOOR4_8, TEX_FLOOR7_2, 300, 4 ),\n\t\t\t\t\/\/ Sector Data 35\n\t\t\t\tDataSector( 1.000, 40, 184, TEX_STEP2, TEX_TLITE6_1, 304, 4 ),\n\t\t\t\t\/\/ Sector Data 36\n\t\t\t\tDataSector( 1.000, 40, 184, TEX_STEP2, TEX_TLITE6_1, 308, 4 ),\n\t\t\t\t\/\/ Sector Data 37\n\t\t\t\tDataSector( 0.565, 40, 224, TEX_FLOOR4_8, TEX_FLOOR7_2, 312, 4 ),\n\t\t\t\t\/\/ Sector Data 38\n\t\t\t\tDataSector( 0.565, 56, 224, TEX_FLOOR4_8, TEX_FLOOR7_2, 316, 4 ),\n\t\t\t\t\/\/ Sector Data 39\n\t\t\t\tDataSector( 0.565, 72, 224, TEX_FLOOR4_8, TEX_FLOOR7_2, 320, 4 ),\n\t\t\t\t\/\/ Sector Data 40\n\t\t\t\tDataSector( 0.878, 0, 128, TEX_FLOOR7_1, TEX_F_SKY1, 324, 8 ),\n\t\t\t\t\/\/ Sector Data 41\n\t\t\t\tDataSector( 0.753, 104, 264, TEX_FLOOR4_8, TEX_FLOOR7_2, 332, 18 ),\n\t\t\t\t\/\/ Sector Data 42\n\t\t\t\tDataSector( 1.000, 0, 264, TEX_FLOOR7_1, TEX_F_SKY1, 350, 16 ),\n\t\t\t\t\/\/ Sector Data 43\n\t\t\t\tDataSector( 1.000, 136, 240, TEX_FLAT20, TEX_FLAT20, 366, 4 ),\n\t\t\t\t\/\/ Sector Data 44\n\t\t\t\tDataSector( 0.753, 128, 264, TEX_FLOOR1_1, TEX_FLOOR7_2, 370, 8 ),\n\t\t\t\t\/\/ Sector Data 45\n\t\t\t\tDataSector( 1.000, 136, 240, TEX_FLAT20, TEX_FLAT20, 378, 4 ),\n\t\t\t\t\/\/ Sector Data 46\n\t\t\t\tDataSector( 1.000, 136, 240, TEX_FLAT20, TEX_FLAT20, 382, 4 ),\n\t\t\t\t\/\/ Sector Data 47\n\t\t\t\tDataSector( 0.690, 104, 192, TEX_FLOOR4_8, TEX_FLOOR7_2, 386, 8 ),\n\t\t\t\t\/\/ Sector Data 48\n\t\t\t\tDataSector( 0.565, 88, 224, TEX_FLOOR4_8, TEX_FLOOR7_2, 394, 4 ),\n\t\t\t\t\/\/ Sector Data 49\n\t\t\t\tDataSector( 0.565, -24, 176, TEX_FLOOR5_2, TEX_CEIL3_5, 398, 9 ),\n\t\t\t\t\/\/ Sector Data 50\n\t\t\t\tDataSector( 0.627, -16, 72, TEX_FLOOR4_8, TEX_CEIL3_5, 407, 4 ),\n\t\t\t\t\/\/ Sector Data 51\n\t\t\t\tDataSector( 0.565, -48, 176, TEX_NUKAGE3, TEX_CEIL3_5, 411, 3 ),\n\t\t\t\t\/\/ Sector Data 52\n\t\t\t\tDataSector( 0.565, -24, 176, TEX_FLOOR5_2, TEX_CEIL3_5, 414, 8 ),\n\t\t\t\t\/\/ Sector Data 53\n\t\t\t\tDataSector( 0.753, -48, 176, TEX_NUKAGE3, TEX_CEIL3_5, 422, 11 ),\n\t\t\t\t\/\/ Sector Data 54\n\t\t\t\tDataSector( 0.502, -48, 104, TEX_FLOOR4_8, TEX_FLOOR6_2, 433, 10 ),\n\t\t\t\t\/\/ Sector Data 55\n\t\t\t\tDataSector( 0.627, 96, 176, TEX_FLOOR4_8, TEX_CEIL3_5, 443, 5 ),\n\t\t\t\t\/\/ Sector Data 56\n\t\t\t\tDataSector( 0.753, -24, 176, TEX_FLOOR5_2, TEX_CEIL3_5, 448, 14 ),\n\t\t\t\t\/\/ Sector Data 57\n\t\t\t\tDataSector( 0.753, -48, 176, TEX_NUKAGE3, TEX_CEIL3_5, 462, 7 ),\n\t\t\t\t\/\/ Sector Data 58\n\t\t\t\tDataSector( 0.502, 104, 184, TEX_FLOOR4_8, TEX_FLOOR6_2, 469, 19 ),\n\t\t\t\t\/\/ Sector Data 59\n\t\t\t\tDataSector( 1.000, 16, 152, TEX_FLAT14, TEX_TLITE6_5, 488, 4 ),\n\t\t\t\t\/\/ Sector Data 60\n\t\t\t\tDataSector( 1.000, 24, 152, TEX_FLAT14, TEX_TLITE6_5, 492, 4 ),\n\t\t\t\t\/\/ Sector Data 61\n\t\t\t\tDataSector( 0.627, -8, 72, TEX_FLOOR4_8, TEX_CEIL3_5, 496, 6 ),\n\t\t\t\t\/\/ Sector Data 62\n\t\t\t\tDataSector( 0.753, 0, 136, TEX_FLAT20, TEX_FLAT20, 502, 4 ),\n\t\t\t\t\/\/ Sector Data 63\n\t\t\t\tDataSector( 1.000, -56, 24, TEX_FLOOR7_1, TEX_F_SKY1, 506, 4 ),\n\t\t\t\t\/\/ Sector Data 64\n\t\t\t\tDataSector( 1.000, -24, 104, TEX_FLOOR5_2, TEX_TLITE6_5, 510, 24 ),\n\t\t\t\t\/\/ Sector Data 65\n\t\t\t\tDataSector( 0.502, -24, 48, TEX_FLOOR5_2, TEX_CEIL3_5, 534, 18 ),\n\t\t\t\t\/\/ Sector Data 66\n\t\t\t\tDataSector( 1.000, -24, 72, TEX_FLOOR5_2, TEX_CEIL3_5, 552, 10 ),\n\t\t\t\t\/\/ Sector Data 67\n\t\t\t\tDataSector( 1.000, -24, 56, TEX_FLOOR5_2, TEX_FLAT23, 562, 4 ),\n\t\t\t\t\/\/ Sector Data 68\n\t\t\t\tDataSector( 1.000, -24, 48, TEX_FLOOR5_2, TEX_CEIL3_5, 566, 4 ),\n\t\t\t\t\/\/ Sector Data 69\n\t\t\t\tDataSector( 1.000, -24, -24, TEX_FLOOR5_2, TEX_FLAT20, 570, 4 ),\n\t\t\t\t\/\/ Sector Data 70\n\t\t\t\tDataSector( 1.000, -24, 88, TEX_FLOOR5_2, TEX_TLITE6_5, 574, 12 ),\n\t\t\t\t\/\/ Sector Data 71\n\t\t\t\tDataSector( 1.000, -24, 72, TEX_FLOOR5_2, TEX_FLAT23, 586, 4 ),\n\t\t\t\t\/\/ Sector Data 72\n\t\t\t\tDataSector( 1.000, -24, 48, TEX_FLOOR5_2, TEX_CEIL3_5, 590, 4 ),\n\t\t\t\t\/\/ Sector Data 73\n\t\t\t\tDataSector( 0.502, -104, 48, TEX_FLOOR5_1, TEX_CEIL5_2, 594, 4 ),\n\t\t\t\t\/\/ Sector Data 74\n\t\t\t\tDataSector( 0.502, -88, 48, TEX_FLOOR5_1, TEX_CEIL5_2, 598, 4 ),\n\t\t\t\t\/\/ Sector Data 75\n\t\t\t\tDataSector( 0.502, -72, 48, TEX_FLOOR5_1, TEX_CEIL5_2, 602, 4 ),\n\t\t\t\t\/\/ Sector Data 76\n\t\t\t\tDataSector( 0.502, -56, 48, TEX_FLOOR5_1, TEX_CEIL5_2, 606, 4 ),\n\t\t\t\t\/\/ Sector Data 77\n\t\t\t\tDataSector( 0.502, -40, 48, TEX_FLOOR5_1, TEX_CEIL5_2, 610, 4 ),\n\t\t\t\t\/\/ Sector Data 78\n\t\t\t\tDataSector( 0.502, -24, 48, TEX_FLOOR5_2, TEX_CEIL5_2, 614, 4 ),\n\t\t\t\t\/\/ Sector Data 79\n\t\t\t\tDataSector( 1.000, -136, -24, TEX_FLOOR5_1, TEX_TLITE6_6, 618, 8 ),\n\t\t\t\t\/\/ Sector Data 80\n\t\t\t\tDataSector( 0.502, -136, -40, TEX_FLOOR5_1, TEX_CEIL5_2, 626, 6 ),\n\t\t\t\t\/\/ Sector Data 81\n\t\t\t\tDataSector( 0.502, -120, 48, TEX_FLOOR5_1, TEX_CEIL5_2, 632, 4 ),\n\t\t\t\t\/\/ Sector Data 82\n\t\t\t\tDataSector( 0.502, -24, 48, TEX_FLOOR5_2, TEX_CEIL3_5, 636, 4 ),\n\t\t\t\t\/\/ Sector Data 83\n\t\t\t\tDataSector( 0.565, -24, -24, TEX_FLOOR5_2, TEX_FLAT5_5, 640, 4 ),\n\t\t\t\t\/\/ Sector Data 84\n\t\t\t\tDataSector( 0.502, -24, 48, TEX_FLOOR5_2, TEX_CEIL3_5, 644, 6 ),\n\t\t\t\t\/\/ Sector Data 85\n\t\t\t\tDataSector( 0.502, -24, -24, TEX_FLOOR5_2, TEX_FLAT20, 650, 4 ),\n\t\t\t\t\/\/ Sector Data 86\n\t\t\t\tDataSector( 1.000, -48, 32, TEX_FLOOR4_8, TEX_TLITE6_6, 654, 6 ),\n\t\t\t\t\/\/ Sector Data 87\n\t\t\t\tDataSector( 0.502, 104, 184, TEX_FLOOR4_8, TEX_FLOOR6_2, 660, 6 )\n\t\t\t),\n\t\t\tDataSideDefPacked[666] (\n\t\t\t\tDATA_SIDE_DEF( 1520, -3168, 1672, -3104, 164, 1, 0.000, PACK_DATA(TEX_BROWN144, TEX_X, TEX_X, 1u) ),\n\t\t\t\tDATA_SIDE_DEF( 1672, -3104, 1896, -3104, 224, 1, -0.063, PACK_DATA(TEX_BROWN144, TEX_X, TEX_X, 1u) ),\n\t\t\t\tDATA_SIDE_DEF( 1896, -3104, 2040, -3144, 149, 1, 0.000, PACK_DATA(TEX_BROWN144, TEX_X, TEX_X, 1u) ),\n\t\t\t\tDATA_SIDE_DEF( 2040, -3144, 2128, -3272, 155, 1, 0.000, PACK_DATA(TEX_BROWN144, TEX_X, TEX_X, 1u) ),\n\t\t\t\tDATA_SIDE_DEF( 2128, -3272, 2064, -3408, 150, 1, 0.000, PACK_DATA(TEX_BROWN144, TEX_X, TEX_X, 1u) ),\n\t\t\t\tDATA_SIDE_DEF( 2064, -3408, 1784, -3448, 282, 1, 0.000, PACK_DATA(TEX_BROWN144, TEX_X, TEX_X, 1u) ),\n\t\t\t\tDATA_SIDE_DEF( 1784, -3448, 1544, -3384, 248, 1, 0.000, PACK_DATA(TEX_BROWN144, TEX_X, TEX_X, 1u) ),\n\t\t\t\tDATA_SIDE_DEF( 1544, -3384, 1520, -3168, 217, 1, 0.000, PACK_DATA(TEX_BROWN144, TEX_X, TEX_X, 1u) ),\n\t\t\t\tDATA_SIDE_DEF( 1376, -3200, 1376, -3104, 96, 5, 0.063, PACK_DATA(TEX_STARTAN3, TEX_X, TEX_STARTAN3, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1376, -3360, 1376, -3264, 96, 3, 0.063, PACK_DATA(TEX_STARTAN3, TEX_X, TEX_STARTAN3, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1376, -3264, 1376, -3200, 64, -1, 0.063, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1376, -3104, 1376, -2944, 160, -1, 0.063, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1376, -2944, 1472, -2880, 115, -1, 0.000, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1856, -2880, 1920, -2920, 75, 2, 0.000, PACK_DATA(TEX_STARTAN3, TEX_X, TEX_STARTAN3, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1672, -3104, 1520, -3168, 164, 0, 0.000, PACK_DATA(TEX_X, TEX_X, TEX_X, 1u) ),\n\t\t\t\tDATA_SIDE_DEF( 1896, -3104, 1672, -3104, 224, 0, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 1u) ),\n\t\t\t\tDATA_SIDE_DEF( 2040, -3144, 1896, -3104, 149, 0, 0.000, PACK_DATA(TEX_X, TEX_X, TEX_X, 1u) ),\n\t\t\t\tDATA_SIDE_DEF( 2128, -3272, 2040, -3144, 155, 0, 0.000, PACK_DATA(TEX_X, TEX_X, TEX_X, 1u) ),\n\t\t\t\tDATA_SIDE_DEF( 2064, -3408, 2128, -3272, 150, 0, 0.000, PACK_DATA(TEX_X, TEX_X, TEX_X, 1u) ),\n\t\t\t\tDATA_SIDE_DEF( 1784, -3448, 2064, -3408, 282, 0, 0.000, PACK_DATA(TEX_X, TEX_X, TEX_X, 1u) ),\n\t\t\t\tDATA_SIDE_DEF( 1544, -3384, 1784, -3448, 248, 0, 0.000, PACK_DATA(TEX_X, TEX_X, TEX_X, 1u) ),\n\t\t\t\tDATA_SIDE_DEF( 1520, -3168, 1544, -3384, 217, 0, 0.000, PACK_DATA(TEX_X, TEX_X, TEX_X, 1u) ),\n\t\t\t\tDATA_SIDE_DEF( 2736, -3360, 2736, -3648, 288, -1, 0.063, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2736, -3648, 2240, -3648, 496, 63, -0.063, PACK_DATA(TEX_STARTAN3, TEX_X, TEX_X, 1u) ),\n\t\t\t\tDATA_SIDE_DEF( 2240, -3648, 1984, -3648, 256, 12, -0.063, PACK_DATA(TEX_STARTAN3, TEX_X, TEX_X, 1u) ),\n\t\t\t\tDATA_SIDE_DEF( 1984, -3648, 1376, -3648, 608, 11, -0.063, PACK_DATA(TEX_STARTAN3, TEX_X, TEX_X, 1u) ),\n\t\t\t\tDATA_SIDE_DEF( 2240, -2920, 2272, -3008, 93, -1, 0.000, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2272, -3008, 2432, -3112, 190, -1, 0.000, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2432, -3112, 2736, -3112, 304, -1, -0.063, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2736, -3112, 2736, -3360, 248, 62, 0.063, PACK_DATA(TEX_STARTAN3, TEX_X, TEX_STARTAN3, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1376, -3648, 1376, -3520, 128, -1, 0.063, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1376, -3392, 1376, -3360, 32, -1, 0.063, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1376, -3520, 1376, -3392, 128, 4, 0.063, PACK_DATA(TEX_STARTAN3, TEX_X, TEX_STARTAN3, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1472, -2880, 1664, -2880, 192, -1, -0.063, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1664, -2880, 1856, -2880, 192, 2, -0.063, PACK_DATA(TEX_STARTAN3, TEX_X, TEX_STARTAN3, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1920, -2920, 2176, -2920, 256, 2, -0.063, PACK_DATA(TEX_STARTAN3, TEX_X, TEX_STARTAN3, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2176, -2920, 2240, -2920, 64, -1, -0.063, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1920, -2920, 1856, -2880, 75, 1, 0.000, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1664, -2816, 2176, -2816, 512, 14, -0.063, PACK_DATA(TEX_COMPUTE3, TEX_X, TEX_COMPUTE3, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1856, -2880, 1664, -2880, 192, 1, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2176, -2920, 1920, -2920, 256, 1, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2176, -2816, 2176, -2920, 104, -1, 0.063, PACK_DATA(TEX_X, TEX_DOORSTOP, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1664, -2880, 1664, -2816, 64, -1, 0.063, PACK_DATA(TEX_X, TEX_DOORSTOP, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1344, -3360, 1344, -3264, 96, 27, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1376, -3264, 1376, -3360, 96, 1, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1344, -3264, 1376, -3264, 32, -1, -0.063, PACK_DATA(TEX_X, TEX_DOORSTOP, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1376, -3360, 1344, -3360, 32, -1, -0.063, PACK_DATA(TEX_X, TEX_DOORSTOP, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1344, -3520, 1344, -3392, 128, 29, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1344, -3392, 1376, -3392, 32, -1, -0.063, PACK_DATA(TEX_X, TEX_DOORSTOP, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1376, -3520, 1344, -3520, 32, -1, -0.063, PACK_DATA(TEX_X, TEX_DOORSTOP, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1376, -3392, 1376, -3520, 128, 1, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1344, -3200, 1344, -3104, 96, 27, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1376, -3104, 1376, -3200, 96, 1, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1376, -3200, 1344, -3200, 32, -1, -0.063, PACK_DATA(TEX_X, TEX_DOORSTOP, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1344, -3104, 1376, -3104, 32, -1, -0.063, PACK_DATA(TEX_X, TEX_DOORSTOP, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2240, -4096, 2112, -4032, 143, -1, 0.000, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2048, -3904, 2176, -3904, 128, 7, -0.063, PACK_DATA(TEX_BROWN1, TEX_X, TEX_BROWN1, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2240, -3968, 2240, -4096, 128, 79, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2176, -3904, 2176, -3920, 16, -1, 0.063, PACK_DATA(TEX_X, TEX_SUPPORT2, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2176, -3920, 2240, -3968, 80, -1, 0.000, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2112, -4032, 2048, -3920, 128, -1, 0.000, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2048, -3920, 2048, -3904, 16, -1, 0.063, PACK_DATA(TEX_X, TEX_SUPPORT2, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2048, -3904, 2048, -3872, 32, -1, 0.063, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2176, -3872, 2176, -3904, 32, -1, 0.063, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2048, -3872, 2176, -3872, 128, 8, -0.063, PACK_DATA(TEX_BROWN1, TEX_X, TEX_BROWN1, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2176, -3904, 2048, -3904, 128, 6, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_BROWN1, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2048, -3872, 2048, -3840, 32, -1, 0.063, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2176, -3840, 2176, -3872, 32, -1, 0.063, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2048, -3840, 2176, -3840, 128, 9, -0.063, PACK_DATA(TEX_BROWN1, TEX_X, TEX_BROWN1, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2176, -3872, 2048, -3872, 128, 7, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2176, -3808, 2176, -3840, 32, -1, 0.063, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2048, -3840, 2048, -3808, 32, -1, 0.063, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2048, -3808, 2176, -3808, 128, 10, -0.063, PACK_DATA(TEX_BROWN1, TEX_X, TEX_BROWN1, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2176, -3840, 2048, -3840, 128, 8, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2176, -3776, 2176, -3808, 32, -1, 0.063, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2048, -3808, 2048, -3776, 32, -1, 0.063, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2048, -3776, 2176, -3776, 128, 13, -0.063, PACK_DATA(TEX_BROWN1, TEX_X, TEX_BROWN1, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2176, -3808, 2048, -3808, 128, 9, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1528, -3680, 1376, -3648, 155, -1, 0.000, PACK_DATA(TEX_X, TEX_BROWN144, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1672, -3744, 1528, -3680, 157, -1, 0.000, PACK_DATA(TEX_X, TEX_BROWN144, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1984, -3776, 1672, -3744, 313, -1, 0.000, PACK_DATA(TEX_X, TEX_BROWN144, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1376, -3648, 1984, -3648, 608, 1, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 1u) ),\n\t\t\t\tDATA_SIDE_DEF( 1984, -3648, 1984, -3776, 128, 12, 0.063, PACK_DATA(TEX_STARTAN3, TEX_X, TEX_X, 1u) ),\n\t\t\t\tDATA_SIDE_DEF( 2240, -3776, 2208, -3680, 101, -1, 0.000, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2208, -3680, 2176, -3680, 32, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2016, -3680, 1984, -3776, 101, -1, 0.000, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2048, -3680, 2016, -3680, 32, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2176, -3680, 2048, -3680, 128, 13, -0.063, PACK_DATA(TEX_BROWN1, TEX_X, TEX_BROWN1, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1984, -3648, 2240, -3648, 256, 1, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 1u) ),\n\t\t\t\tDATA_SIDE_DEF( 1984, -3776, 1984, -3648, 128, 11, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 1u) ),\n\t\t\t\tDATA_SIDE_DEF( 2240, -3648, 2240, -3776, 128, 63, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 1u) ),\n\t\t\t\tDATA_SIDE_DEF( 2048, -3680, 2176, -3680, 128, 12, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2176, -3776, 2048, -3776, 128, 10, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2176, -3680, 2176, -3704, 24, -1, 0.063, PACK_DATA(TEX_X, TEX_SUPPORT2, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2176, -3704, 2176, -3776, 72, -1, 0.063, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2048, -3776, 2048, -3704, 72, -1, 0.063, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2048, -3704, 2048, -3680, 24, -1, 0.063, PACK_DATA(TEX_X, TEX_SUPPORT2, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2176, -2752, 2176, -2816, 64, -1, 0.063, PACK_DATA(TEX_X, TEX_LITE3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1664, -2752, 2176, -2752, 512, 15, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2176, -2816, 1664, -2816, 512, 2, -0.063, PACK_DATA(TEX_COMPUTE3, TEX_X, TEX_COMPUTE3, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1664, -2816, 1664, -2752, 64, 23, 0.063, PACK_DATA(TEX_COMPSPAN, TEX_X, TEX_COMPTALL, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1664, -2368, 1664, -2112, 256, 21, 0.063, PACK_DATA(TEX_COMPSPAN, TEX_X, TEX_COMPTALL, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1664, -2112, 2496, -2112, 832, 21, -0.063, PACK_DATA(TEX_COMPSPAN, TEX_X, TEX_COMPTALL, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2496, -2112, 2496, -2496, 384, 21, 0.063, PACK_DATA(TEX_COMPSPAN, TEX_X, TEX_COMPTALL, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2176, -2752, 1664, -2752, 512, 14, -0.063, PACK_DATA(TEX_COMPSPAN, TEX_X, TEX_COMPTALL, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2496, -2688, 2496, -2752, 64, -1, 0.063, PACK_DATA(TEX_X, TEX_STARGR1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1664, -2560, 1664, -2432, 128, 22, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_STARGR1, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2496, -2560, 2496, -2688, 128, 61, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_STARGR1, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1664, -2624, 1664, -2600, 24, -1, 0.063, PACK_DATA(TEX_X, TEX_SUPPORT2, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1664, -2600, 1664, -2560, 40, -1, 0.063, PACK_DATA(TEX_X, TEX_STARGR1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1664, -2432, 1664, -2392, 40, -1, 0.063, PACK_DATA(TEX_X, TEX_STARGR1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1664, -2392, 1664, -2368, 24, -1, 0.063, PACK_DATA(TEX_X, TEX_SUPPORT2, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2496, -2496, 2496, -2520, 24, -1, 0.063, PACK_DATA(TEX_X, TEX_SUPPORT2, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2496, -2520, 2496, -2560, 40, -1, 0.063, PACK_DATA(TEX_X, TEX_STARGR1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2496, -2752, 2200, -2752, 296, -1, -0.063, PACK_DATA(TEX_X, TEX_STARGR1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2200, -2752, 2176, -2752, 24, -1, -0.063, PACK_DATA(TEX_X, TEX_SUPPORT2, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2112, -2592, 2336, -2592, 224, -1, -0.063, PACK_DATA(TEX_X, TEX_COMPTILE, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2336, -2592, 2336, -2272, 320, -1, 0.063, PACK_DATA(TEX_X, TEX_COMPTILE, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2336, -2272, 2112, -2272, 224, -1, -0.063, PACK_DATA(TEX_X, TEX_COMPTILE, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2112, -2272, 2112, -2304, 32, -1, 0.063, PACK_DATA(TEX_X, TEX_COMPTILE, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2112, -2304, 2144, -2304, 32, -1, -0.063, PACK_DATA(TEX_X, TEX_SUPPORT2, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2144, -2560, 2112, -2560, 32, -1, -0.063, PACK_DATA(TEX_X, TEX_SUPPORT2, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2112, -2560, 2112, -2592, 32, -1, 0.063, PACK_DATA(TEX_X, TEX_COMPTILE, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2144, -2304, 2144, -2560, 256, 20, 0.063, PACK_DATA(TEX_STEP1, TEX_X, TEX_COMPTILE, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1992, -2552, 1784, -2552, 208, 18, -0.063, PACK_DATA(TEX_STARGR1, TEX_X, TEX_PLANET1, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1784, -2552, 1784, -2632, 80, 18, 0.063, PACK_DATA(TEX_STARGR1, TEX_X, TEX_PLANET1, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1784, -2632, 1992, -2632, 208, 18, -0.063, PACK_DATA(TEX_STARGR1, TEX_X, TEX_PLANET1, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1992, -2632, 1992, -2552, 80, 18, 0.063, PACK_DATA(TEX_STARGR1, TEX_X, TEX_PLANET1, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1784, -2312, 1992, -2312, 208, 16, -0.063, PACK_DATA(TEX_STARGR1, TEX_X, TEX_PLANET1, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1992, -2312, 1992, -2232, 80, 16, 0.063, PACK_DATA(TEX_STARGR1, TEX_X, TEX_PLANET1, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1992, -2232, 1784, -2232, 208, 16, -0.063, PACK_DATA(TEX_STARGR1, TEX_X, TEX_PLANET1, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1784, -2232, 1784, -2312, 80, 16, 0.063, PACK_DATA(TEX_STARGR1, TEX_X, TEX_PLANET1, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1664, -2752, 1664, -2624, 128, 23, 0.063, PACK_DATA(TEX_COMPSPAN, TEX_X, TEX_COMPTALL, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1984, -2304, 1984, -2240, 64, 17, 0.063, PACK_DATA(TEX_STARGR1, TEX_X, TEX_PLANET1, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1984, -2240, 1792, -2240, 192, 17, -0.063, PACK_DATA(TEX_STARGR1, TEX_X, TEX_PLANET1, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1792, -2240, 1792, -2304, 64, 17, 0.063, PACK_DATA(TEX_STARGR1, TEX_X, TEX_PLANET1, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1792, -2304, 1984, -2304, 192, 17, -0.063, PACK_DATA(TEX_STARGR1, TEX_X, TEX_PLANET1, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1992, -2312, 1784, -2312, 208, 15, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1992, -2232, 1992, -2312, 80, 15, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1784, -2232, 1992, -2232, 208, 15, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1784, -2312, 1784, -2232, 80, 15, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1984, -2240, 1984, -2304, 64, 16, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1792, -2240, 1984, -2240, 192, 16, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1792, -2304, 1792, -2240, 64, 16, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1984, -2304, 1792, -2304, 192, 16, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1984, -2624, 1984, -2560, 64, 19, 0.063, PACK_DATA(TEX_STARGR1, TEX_X, TEX_PLANET1, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1984, -2560, 1792, -2560, 192, 19, -0.063, PACK_DATA(TEX_STARGR1, TEX_X, TEX_PLANET1, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1792, -2560, 1792, -2624, 64, 19, 0.063, PACK_DATA(TEX_STARGR1, TEX_X, TEX_PLANET1, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1792, -2624, 1984, -2624, 192, 19, -0.063, PACK_DATA(TEX_STARGR1, TEX_X, TEX_PLANET1, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1784, -2552, 1992, -2552, 208, 15, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1784, -2632, 1784, -2552, 80, 15, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1992, -2632, 1784, -2632, 208, 15, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1992, -2552, 1992, -2632, 80, 15, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1984, -2560, 1984, -2624, 64, 18, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1792, -2560, 1984, -2560, 192, 18, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1792, -2624, 1792, -2560, 64, 18, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1984, -2624, 1792, -2624, 192, 18, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2144, -2304, 2176, -2304, 32, -1, -0.063, PACK_DATA(TEX_X, TEX_COMPTILE, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2176, -2560, 2144, -2560, 32, -1, -0.063, PACK_DATA(TEX_X, TEX_COMPTILE, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2144, -2560, 2144, -2304, 256, 15, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2176, -2304, 2176, -2560, 256, 59, 0.063, PACK_DATA(TEX_STEP1, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1664, -2368, 1600, -2368, 64, -1, -0.063, PACK_DATA(TEX_X, TEX_LITE3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1600, -2368, 1600, -2112, 256, -1, 0.063, PACK_DATA(TEX_X, TEX_COMPUTE2, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2560, -2112, 2560, -2496, 384, -1, 0.063, PACK_DATA(TEX_X, TEX_COMPUTE2, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2560, -2496, 2496, -2496, 64, -1, -0.063, PACK_DATA(TEX_X, TEX_LITE3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1600, -2048, 1664, -2048, 64, -1, -0.063, PACK_DATA(TEX_X, TEX_LITE3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1664, -2048, 2496, -2048, 832, -1, -0.063, PACK_DATA(TEX_X, TEX_COMPUTE2, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2496, -2048, 2560, -2048, 64, -1, -0.063, PACK_DATA(TEX_X, TEX_LITE3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2560, -2048, 2560, -2112, 64, -1, 0.063, PACK_DATA(TEX_X, TEX_LITE3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1600, -2112, 1600, -2048, 64, -1, 0.063, PACK_DATA(TEX_X, TEX_LITE3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1664, -2112, 1664, -2368, 256, 15, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2496, -2112, 1664, -2112, 832, 15, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2496, -2496, 2496, -2112, 384, 15, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1552, -2560, 1552, -2432, 128, 26, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_BIGDOOR2, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1664, -2560, 1552, -2560, 112, -1, -0.063, PACK_DATA(TEX_X, TEX_STARGR1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1552, -2432, 1664, -2432, 112, -1, -0.063, PACK_DATA(TEX_X, TEX_STARGR1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1664, -2432, 1664, -2560, 128, 15, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1600, -2624, 1664, -2624, 64, -1, -0.063, PACK_DATA(TEX_X, TEX_LITE3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1664, -2816, 1600, -2816, 64, -1, -0.063, PACK_DATA(TEX_X, TEX_LITE3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1600, -2816, 1600, -2752, 64, -1, 0.063, PACK_DATA(TEX_X, TEX_LITE3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1600, -2752, 1600, -2624, 128, -1, 0.063, PACK_DATA(TEX_X, TEX_COMPUTE2, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1664, -2752, 1664, -2816, 64, 14, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1664, -2624, 1664, -2752, 128, 15, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1216, -2880, 1248, -2528, 353, -1, 0.000, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1384, -2592, 1344, -2880, 290, -1, 0.000, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1472, -2560, 1384, -2592, 93, -1, 0.000, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1248, -2528, 1472, -2432, 243, -1, 0.000, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1344, -2880, 1216, -2880, 128, 29, -0.063, PACK_DATA(TEX_STEP6, TEX_X, TEX_STARTAN3, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1472, -2432, 1472, -2560, 128, 25, 0.063, PACK_DATA(TEX_STEP6, TEX_X, TEX_STARTAN3, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1472, -2560, 1472, -2432, 128, 24, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1536, -2432, 1536, -2560, 128, 26, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_BIGDOOR2, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1536, -2560, 1472, -2560, 64, -1, -0.063, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1472, -2432, 1536, -2432, 64, -1, -0.063, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1536, -2560, 1536, -2432, 128, 25, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1552, -2432, 1552, -2560, 128, 22, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1536, -2432, 1552, -2432, 16, -1, -0.063, PACK_DATA(TEX_X, TEX_DOORTRAK, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1552, -2560, 1536, -2560, 16, -1, -0.063, PACK_DATA(TEX_X, TEX_DOORTRAK, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1216, -3392, 1216, -3360, 32, -1, 0.063, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1216, -3360, 1184, -3360, 32, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1184, -3104, 1216, -3104, 32, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1216, -3104, 1216, -3072, 32, -1, 0.063, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1344, -3264, 1344, -3360, 96, 3, 0.063, PACK_DATA(TEX_STARTAN3, TEX_X, TEX_STARTAN3, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1344, -3200, 1344, -3264, 64, -1, 0.063, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1344, -3104, 1344, -3200, 96, 5, 0.063, PACK_DATA(TEX_STARTAN3, TEX_X, TEX_STARTAN3, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1344, -3360, 1216, -3392, 131, 29, 0.000, PACK_DATA(TEX_STEP6, TEX_X, TEX_STARTAN3, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1216, -3072, 1344, -3104, 131, 29, 0.000, PACK_DATA(TEX_STEP6, TEX_X, TEX_STARTAN3, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  928, -3104, 1184, -3104, 256, 28, -0.063, PACK_DATA(TEX_STEP6, TEX_X, TEX_STARTAN3, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1184, -3360,  928, -3360, 256, 28, -0.063, PACK_DATA(TEX_STEP6, TEX_X, TEX_STARTAN3, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  928, -3360,  928, -3104, 256, 28, 0.063, PACK_DATA(TEX_STEP6, TEX_X, TEX_STARTAN3, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  928, -3392,  928, -3360, 32, -1, 0.063, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF(  928, -3360,  896, -3360, 32, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1184, -3360, 1184, -3392, 32, -1, 0.063, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF(  896, -3104,  928, -3104, 32, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF(  928, -3104,  928, -3072, 32, -1, 0.063, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1184, -3072, 1184, -3104, 32, -1, 0.063, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1184, -3392,  928, -3392, 256, 29, -0.063, PACK_DATA(TEX_STEP6, TEX_X, TEX_COMPUTE2, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1184, -3104,  928, -3104, 256, 27, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  928, -3360, 1184, -3360, 256, 27, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  928, -3104,  928, -3360, 256, 27, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  896, -3360,  896, -3104, 256, 29, 0.063, PACK_DATA(TEX_STEP6, TEX_X, TEX_COMPUTE2, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  928, -3072, 1184, -3072, 256, 29, -0.063, PACK_DATA(TEX_STEP6, TEX_X, TEX_COMPUTE2, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1152, -3648, 1088, -3648, 64, -1, -0.063, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1024, -3648,  960, -3648, 64, -1, -0.063, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1280, -3552, 1152, -3648, 160, -1, 0.000, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF(  960, -3648,  832, -3552, 160, -1, 0.000, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1344, -3552, 1280, -3552, 64, -1, -0.063, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF(  832, -3552,  704, -3552, 128, -1, -0.063, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF(  896, -3392,  928, -3392, 32, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF(  896, -3360,  896, -3392, 32, -1, 0.063, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1184, -3392, 1216, -3392, 32, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF(  896, -3072,  896, -3104, 32, -1, 0.063, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF(  928, -3072,  896, -3072, 32, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1216, -3072, 1184, -3072, 32, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1344, -2880, 1344, -3104, 224, -1, 0.063, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF(  928, -3392, 1184, -3392, 256, 28, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1216, -3392, 1344, -3360, 131, 27, 0.000, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1344, -3104, 1216, -3072, 131, 27, 0.000, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  704, -2944,  832, -2944, 128, -1, -0.063, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF(  832, -2944,  968, -2880, 150, -1, 0.000, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF(  968, -2880, 1216, -2880, 248, -1, -0.063, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1088, -3648, 1024, -3648, 64, 30, -0.063, PACK_DATA(TEX_STARTAN3, TEX_X, TEX_STARTAN3, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  896, -3104,  896, -3360, 256, 28, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1184, -3072,  928, -3072, 256, 28, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  704, -3552,  704, -3360, 192, -1, 0.063, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF(  704, -3104,  704, -2944, 160, -1, 0.063, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF(  704, -3360,  704, -3104, 256, 31, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1216, -2880, 1344, -2880, 128, 24, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1344, -3360, 1344, -3392, 32, -1, 0.063, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1344, -3520, 1344, -3552, 32, -1, 0.063, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1344, -3392, 1344, -3520, 128, 4, 0.063, PACK_DATA(TEX_STARTAN3, TEX_X, TEX_STARTAN3, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 1088, -3680, 1024, -3680, 64, -1, -0.063, PACK_DATA(TEX_X, TEX_DOOR3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1024, -3680, 1024, -3648, 32, -1, 0.063, PACK_DATA(TEX_X, TEX_LITE3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1088, -3648, 1088, -3680, 32, -1, 0.063, PACK_DATA(TEX_X, TEX_LITE3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 1024, -3648, 1088, -3648, 64, 29, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  704, -3104,  704, -3360, 256, 29, 0.063, PACK_DATA(TEX_STEP6, TEX_X, TEX_STARTAN3, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  512, -3328,  512, -3304, 24, -1, 0.063, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF(  512, -3160,  512, -3136, 24, -1, 0.063, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF(  512, -3136,  680, -3104, 171, -1, 0.000, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF(  680, -3104,  704, -3104, 24, -1, -0.063, PACK_DATA(TEX_X, TEX_SUPPORT2, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF(  704, -3360,  680, -3360, 24, -1, -0.063, PACK_DATA(TEX_X, TEX_SUPPORT2, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF(  680, -3360,  512, -3328, 171, -1, 0.000, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF(  496, -3304,  496, -3160, 144, 32, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  512, -3304,  496, -3304, 16, -1, -0.063, PACK_DATA(TEX_X, TEX_DOORTRAK, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF(  496, -3160,  512, -3160, 16, -1, -0.063, PACK_DATA(TEX_X, TEX_DOORTRAK, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF(  496, -3160,  496, -3304, 144, 31, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_STARG3, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  496, -3304,  496, -3328, 24, -1, 0.063, PACK_DATA(TEX_X, TEX_STARG3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF(  496, -3328,  448, -3456, 136, -1, 0.000, PACK_DATA(TEX_X, TEX_STARG3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF(  448, -3456,  128, -3456, 320, -1, -0.063, PACK_DATA(TEX_X, TEX_STARG3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF(  128, -3008,  448, -3008, 320, -1, -0.063, PACK_DATA(TEX_X, TEX_STARG3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF(  496, -3136,  496, -3160, 24, -1, 0.063, PACK_DATA(TEX_X, TEX_STARG3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF(  448, -3008,  496, -3136, 136, -1, 0.000, PACK_DATA(TEX_X, TEX_STARG3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF(  128, -3264,  160, -3264, 32, 48, -0.063, PACK_DATA(TEX_SLADWALL, TEX_X, TEX_STARTAN3, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  160, -3264,  192, -3264, 32, 39, -0.063, PACK_DATA(TEX_SLADWALL, TEX_X, TEX_STARTAN3, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  192, -3264,  224, -3264, 32, 38, -0.063, PACK_DATA(TEX_SLADWALL, TEX_X, TEX_STARTAN3, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  224, -3264,  256, -3264, 32, 37, -0.063, PACK_DATA(TEX_SLADWALL, TEX_X, TEX_STARTAN3, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  256, -3264,  288, -3264, 32, 34, -0.063, PACK_DATA(TEX_SLADWALL, TEX_X, TEX_STARTAN3, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  288, -3264,  320, -3264, 32, 33, -0.063, PACK_DATA(TEX_SLADWALL, TEX_X, TEX_STARTAN3, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  320, -3264,  320, -3200, 64, 33, 0.063, PACK_DATA(TEX_STEP6, TEX_X, TEX_STARTAN3, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  320, -3200,  288, -3200, 32, 33, -0.063, PACK_DATA(TEX_SLADWALL, TEX_X, TEX_STARTAN3, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  288, -3200,  256, -3200, 32, 34, -0.063, PACK_DATA(TEX_SLADWALL, TEX_X, TEX_STARTAN3, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  256, -3200,  224, -3200, 32, 37, -0.063, PACK_DATA(TEX_SLADWALL, TEX_X, TEX_STARTAN3, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  224, -3200,  192, -3200, 32, 38, -0.063, PACK_DATA(TEX_SLADWALL, TEX_X, TEX_STARTAN3, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  192, -3200,  160, -3200, 32, 39, -0.063, PACK_DATA(TEX_SLADWALL, TEX_X, TEX_STARTAN3, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  160, -3200,  128, -3200, 32, 48, -0.063, PACK_DATA(TEX_SLADWALL, TEX_X, TEX_STARTAN3, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  128, -3200,   64, -3072, 143, 47, 0.000, PACK_DATA(TEX_STARG3, TEX_X, TEX_STARG3, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(   64, -3072,  128, -3008, 90, -1, 0.000, PACK_DATA(TEX_X, TEX_STARG3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF(  128, -3456,   64, -3392, 90, -1, 0.000, PACK_DATA(TEX_X, TEX_STARG3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF(   64, -3392,  128, -3264, 143, 47, 0.000, PACK_DATA(TEX_STARG3, TEX_X, TEX_STARG3, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  256, -3136,  320, -3136, 64, 36, -0.063, PACK_DATA(TEX_TEKWALL4, TEX_X, TEX_TEKWALL4, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  320, -3136,  320, -3072, 64, 36, 0.063, PACK_DATA(TEX_TEKWALL4, TEX_X, TEX_TEKWALL4, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  320, -3072,  256, -3072, 64, 36, -0.063, PACK_DATA(TEX_SW1COMP, TEX_X, TEX_TEKWALL4, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  256, -3072,  256, -3136, 64, 36, 0.063, PACK_DATA(TEX_TEKWALL4, TEX_X, TEX_TEKWALL4, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  256, -3392,  320, -3392, 64, 35, -0.063, PACK_DATA(TEX_TEKWALL4, TEX_X, TEX_TEKWALL4, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  320, -3392,  320, -3328, 64, 35, 0.063, PACK_DATA(TEX_TEKWALL4, TEX_X, TEX_TEKWALL4, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  320, -3328,  256, -3328, 64, 35, -0.063, PACK_DATA(TEX_TEKWALL4, TEX_X, TEX_TEKWALL4, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  256, -3328,  256, -3392, 64, 35, 0.063, PACK_DATA(TEX_TEKWALL4, TEX_X, TEX_TEKWALL4, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  320, -3264,  288, -3264, 32, 32, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  320, -3200,  320, -3264, 64, 32, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  288, -3200,  320, -3200, 32, 32, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  288, -3264,  288, -3200, 64, 34, 0.063, PACK_DATA(TEX_STEP6, TEX_X, TEX_STARTAN3, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  288, -3264,  256, -3264, 32, 32, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  256, -3200,  288, -3200, 32, 32, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  256, -3264,  256, -3200, 64, 37, 0.063, PACK_DATA(TEX_STEP6, TEX_X, TEX_STARTAN3, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  288, -3200,  288, -3264, 64, 33, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  320, -3392,  256, -3392, 64, 32, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  320, -3328,  320, -3392, 64, 32, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  256, -3328,  320, -3328, 64, 32, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  256, -3392,  256, -3328, 64, 32, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  320, -3136,  256, -3136, 64, 32, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  320, -3072,  320, -3136, 64, 32, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  256, -3072,  320, -3072, 64, 32, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  256, -3136,  256, -3072, 64, 32, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  256, -3264,  224, -3264, 32, 32, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  224, -3200,  256, -3200, 32, 32, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  224, -3264,  224, -3200, 64, 38, 0.063, PACK_DATA(TEX_STEP6, TEX_X, TEX_STARTAN3, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  256, -3200,  256, -3264, 64, 34, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  224, -3264,  192, -3264, 32, 32, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  192, -3200,  224, -3200, 32, 32, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  192, -3264,  192, -3200, 64, 39, 0.063, PACK_DATA(TEX_STEP6, TEX_X, TEX_STARTAN3, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  224, -3200,  224, -3264, 64, 37, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  192, -3264,  160, -3264, 32, 32, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  160, -3200,  192, -3200, 32, 32, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  160, -3264,  160, -3200, 64, 48, 0.063, PACK_DATA(TEX_STEP6, TEX_X, TEX_STARTAN3, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  192, -3200,  192, -3264, 64, 38, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(   64, -3648, -640, -3648, 704, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWN144, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( -640, -3648, -768, -3520, 181, -1, 0.000, PACK_DATA(TEX_X, TEX_BROWN144, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( -768, -3520, -768, -2944, 576, -1, 0.063, PACK_DATA(TEX_X, TEX_BROWN144, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( -768, -2944, -640, -2816, 181, -1, 0.000, PACK_DATA(TEX_X, TEX_BROWN144, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( -640, -2816,   64, -2816, 704, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWN144, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( -640, -3520,   64, -3648, 715, 42, 0.000, PACK_DATA(TEX_X, TEX_X, TEX_X, 1u) ),\n\t\t\t\tDATA_SIDE_DEF( -640, -2944, -640, -3520, 576, 42, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 1u) ),\n\t\t\t\tDATA_SIDE_DEF(   64, -2816, -640, -2944, 715, 42, 0.000, PACK_DATA(TEX_X, TEX_X, TEX_X, 1u) ),\n\t\t\t\tDATA_SIDE_DEF( -256, -3328, -320, -3296, 71, -1, 0.000, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( -320, -3168, -256, -3136, 71, -1, 0.000, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF(  -64, -3136,  -64, -3328, 192, 47, 0.063, PACK_DATA(TEX_STARG3, TEX_X, TEX_STARG3, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( -128, -3328, -256, -3328, 128, 46, -0.063, PACK_DATA(TEX_STARTAN3, TEX_X, TEX_STARTAN3, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( -256, -3136, -128, -3136, 128, 43, -0.063, PACK_DATA(TEX_STARTAN3, TEX_X, TEX_STARTAN3, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( -320, -3296, -320, -3168, 128, 45, 0.063, PACK_DATA(TEX_STARTAN3, TEX_X, TEX_STARTAN3, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( -128, -3136,  -88, -3136, 40, -1, -0.063, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF(  -88, -3136,  -64, -3136, 24, -1, -0.063, PACK_DATA(TEX_X, TEX_SUPPORT2, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF(  -64, -3328,  -88, -3328, 24, -1, -0.063, PACK_DATA(TEX_X, TEX_SUPPORT2, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF(  -88, -3328, -128, -3328, 40, -1, -0.063, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( -240, -3264, -208, -3264, 32, 44, -0.063, PACK_DATA(TEX_TEKWALL1, TEX_X, TEX_TEKWALL1, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( -208, -3264, -192, -3248, 22, 44, 0.000, PACK_DATA(TEX_TEKWALL1, TEX_X, TEX_TEKWALL1, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( -192, -3248, -192, -3216, 32, 44, 0.063, PACK_DATA(TEX_TEKWALL1, TEX_X, TEX_TEKWALL1, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( -192, -3216, -208, -3200, 22, 44, 0.000, PACK_DATA(TEX_TEKWALL1, TEX_X, TEX_TEKWALL1, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( -208, -3200, -240, -3200, 32, 44, -0.063, PACK_DATA(TEX_TEKWALL1, TEX_X, TEX_TEKWALL1, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( -240, -3200, -256, -3216, 22, 44, 0.000, PACK_DATA(TEX_TEKWALL1, TEX_X, TEX_TEKWALL1, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( -256, -3216, -256, -3248, 32, 44, 0.063, PACK_DATA(TEX_TEKWALL1, TEX_X, TEX_TEKWALL1, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( -256, -3248, -240, -3264, 22, 44, 0.000, PACK_DATA(TEX_TEKWALL1, TEX_X, TEX_TEKWALL1, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( -256, -3120, -336, -3120, 80, -1, -0.063, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( -336, -3120, -336, -3168, 48, -1, 0.063, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( -336, -3296, -336, -3344, 48, -1, 0.063, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( -336, -3344, -256, -3344, 80, -1, -0.063, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( -128, -3344,  -96, -3344, 32, -1, -0.063, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF(  -96, -3344,   64, -3520, 237, -1, 0.000, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF(  -96, -3120, -128, -3120, 32, -1, -0.063, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF(   64, -2944,  -96, -3120, 237, -1, 0.000, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( -256, -3344, -128, -3344, 128, 46, -0.063, PACK_DATA(TEX_STARTAN3, TEX_X, TEX_STARTAN3, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( -128, -3120, -256, -3120, 128, 43, -0.063, PACK_DATA(TEX_STARTAN3, TEX_X, TEX_STARTAN3, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( -336, -3168, -336, -3296, 128, 45, 0.063, PACK_DATA(TEX_STARTAN3, TEX_X, TEX_STARTAN3, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(   64, -2816,   64, -2944, 128, -1, 0.063, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF(   64, -3520,   64, -3648, 128, -1, 0.063, PACK_DATA(TEX_X, TEX_STARTAN3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF(   64, -3648, -640, -3520, 715, 40, 0.000, PACK_DATA(TEX_STARG3, TEX_X, TEX_X, 1u) ),\n\t\t\t\tDATA_SIDE_DEF( -640, -3520, -640, -2944, 576, 40, 0.063, PACK_DATA(TEX_STARG3, TEX_X, TEX_X, 1u) ),\n\t\t\t\tDATA_SIDE_DEF( -640, -2944,   64, -2816, 715, 40, 0.000, PACK_DATA(TEX_STARG3, TEX_X, TEX_X, 1u) ),\n\t\t\t\tDATA_SIDE_DEF( -128, -3120, -128, -3136, 16, -1, 0.063, PACK_DATA(TEX_X, TEX_DOORSTOP, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( -256, -3136, -256, -3120, 16, -1, 0.063, PACK_DATA(TEX_X, TEX_DOORSTOP, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( -128, -3136, -256, -3136, 128, 41, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( -256, -3120, -128, -3120, 128, 42, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( -208, -3264, -240, -3264, 32, 41, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( -192, -3248, -208, -3264, 22, 41, 0.000, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( -192, -3216, -192, -3248, 32, 41, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( -208, -3200, -192, -3216, 22, 41, 0.000, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( -240, -3200, -208, -3200, 32, 41, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( -256, -3216, -240, -3200, 22, 41, 0.000, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( -256, -3248, -256, -3216, 32, 41, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( -240, -3264, -256, -3248, 22, 41, 0.000, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( -320, -3296, -336, -3296, 16, -1, -0.063, PACK_DATA(TEX_X, TEX_DOORSTOP, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( -336, -3168, -320, -3168, 16, -1, -0.063, PACK_DATA(TEX_X, TEX_DOORSTOP, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( -320, -3168, -320, -3296, 128, 41, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( -336, -3296, -336, -3168, 128, 42, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( -256, -3344, -256, -3328, 16, -1, 0.063, PACK_DATA(TEX_X, TEX_DOORSTOP, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( -128, -3328, -128, -3344, 16, -1, 0.063, PACK_DATA(TEX_X, TEX_DOORSTOP, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( -256, -3328, -128, -3328, 128, 41, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( -128, -3344, -256, -3344, 128, 42, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  128, -3200,  128, -3264, 64, 48, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(   64, -3072,  128, -3200, 143, 32, 0.000, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  128, -3264,   64, -3392, 143, 32, 0.000, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(   64, -3392,   48, -3392, 16, -1, -0.063, PACK_DATA(TEX_X, TEX_SUPPORT2, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF(   48, -3392,  -64, -3328, 128, -1, 0.000, PACK_DATA(TEX_X, TEX_STARG3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF(  -64, -3136,   48, -3072, 128, -1, 0.000, PACK_DATA(TEX_X, TEX_STARG3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF(   48, -3072,   64, -3072, 16, -1, -0.063, PACK_DATA(TEX_X, TEX_SUPPORT2, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF(  -64, -3328,  -64, -3136, 192, 41, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  160, -3264,  128, -3264, 32, 32, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  128, -3200,  160, -3200, 32, 32, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  160, -3200,  160, -3264, 64, 39, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF(  128, -3264,  128, -3200, 64, 47, 0.063, PACK_DATA(TEX_STARG3, TEX_X, TEX_STARG3, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2880, -2912, 2880, -2880, 32, -1, 0.063, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2752, -3048, 2752, -2912, 136, -1, 0.063, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2752, -2784, 2944, -2656, 230, 50, 0.000, PACK_DATA(TEX_BROWN1, TEX_X, TEX_BROWN1, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3048, -2880, 2752, -3048, 340, 56, 0.000, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2880, -2880, 2752, -2800, 150, -1, 0.000, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2752, -2800, 2752, -2784, 16, -1, 0.063, PACK_DATA(TEX_X, TEX_SUPPORT2, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2944, -2656, 2960, -2656, 16, -1, -0.063, PACK_DATA(TEX_X, TEX_SUPPORT2, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2960, -2656, 3048, -2880, 240, -1, 0.000, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2752, -2912, 2880, -2912, 128, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2752, -2784, 2624, -2784, 128, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2752, -2560, 2944, -2656, 214, -1, 0.000, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2944, -2656, 2752, -2784, 230, 49, 0.000, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2624, -2784, 2752, -2560, 257, 61, 0.000, PACK_DATA(TEX_BROWN1, TEX_X, TEX_BROWN1, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2752, -3584, 2752, -3360, 224, -1, 0.063, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2752, -3360, 2944, -3536, 260, 57, 0.000, PACK_DATA(TEX_NUKE24, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2944, -3536, 2752, -3584, 197, 52, 0.000, PACK_DATA(TEX_NUKE24, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2944, -3648, 2752, -3584, 202, -1, 0.000, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3072, -3648, 3072, -4000, 352, -1, 0.063, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2944, -3776, 2944, -3648, 128, -1, 0.063, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2944, -3536, 3072, -3648, 170, 56, 0.000, PACK_DATA(TEX_NUKE24, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2752, -3584, 2944, -3536, 197, 51, 0.000, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2944, -3904, 2944, -3776, 128, 83, 0.063, PACK_DATA(TEX_BROWN96, TEX_X, TEX_BROWN96, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2944, -4000, 2944, -3904, 96, -1, 0.063, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3072, -4000, 2944, -4000, 128, 82, -0.063, PACK_DATA(TEX_BROWNGRN, TEX_X, TEX_BROWNGRN, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3136, -3072, 3304, -3040, 171, 56, 0.000, PACK_DATA(TEX_NUKE24, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3280, -3320, 2984, -3200, 319, 56, 0.000, PACK_DATA(TEX_NUKE24, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2984, -3200, 3136, -3072, 198, 56, 0.000, PACK_DATA(TEX_NUKE24, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3104, -3552, 3280, -3320, 291, 56, 0.000, PACK_DATA(TEX_NUKE24, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3264, -3616, 3104, -3552, 172, 56, 0.000, PACK_DATA(TEX_NUKE24, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3352, -3568, 3264, -3616, 100, -1, 0.000, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3472, -3432, 3408, -3432, 64, 55, -0.063, PACK_DATA(TEX_BROWNGRN, TEX_X, TEX_BROWNGRN, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3408, -3432, 3312, -3496, 115, 55, 0.000, PACK_DATA(TEX_BROWNGRN, TEX_X, TEX_BROWNGRN, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3312, -3496, 3352, -3568, 82, 55, 0.000, PACK_DATA(TEX_BROWNGRN, TEX_X, TEX_BROWNGRN, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3400, -3152, 3472, -3432, 289, -1, 0.000, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3304, -3040, 3400, -3152, 147, 58, 0.000, PACK_DATA(TEX_BROWNGRN, TEX_BROWNGRN, TEX_BROWNGRN, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3352, -3568, 3448, -3520, 107, 55, 0.000, PACK_DATA(TEX_BROWNGRN, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3520, -3904, 3328, -3968, 202, -1, 0.000, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3328, -3744, 3360, -3648, 101, -1, 0.000, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3328, -3968, 3328, -3744, 224, 86, 0.063, PACK_DATA(TEX_BROWNGRN, TEX_X, TEX_BROWNGRN, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3448, -3520, 3472, -3520, 24, -1, -0.063, PACK_DATA(TEX_X, TEX_SUPPORT2, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3472, -3520, 3520, -3584, 80, -1, 0.000, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3360, -3648, 3352, -3592, 56, -1, 0.000, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3352, -3592, 3352, -3568, 24, -1, 0.063, PACK_DATA(TEX_X, TEX_SUPPORT2, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3520, -3584, 3520, -3840, 256, -1, 0.063, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3520, -3840, 3520, -3904, 64, 87, 0.063, PACK_DATA(TEX_BROWNGRN, TEX_X, TEX_BROWNGRN, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3408, -3432, 3472, -3432, 64, 53, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3312, -3496, 3408, -3432, 115, 53, 0.000, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3352, -3568, 3312, -3496, 82, 53, 0.000, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3472, -3432, 3448, -3520, 91, -1, 0.000, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3448, -3520, 3352, -3568, 107, 54, 0.000, PACK_DATA(TEX_BROWNGRN, TEX_X, TEX_BROWNGRN, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3048, -2880, 3048, -2944, 64, -1, 0.063, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3048, -2944, 3304, -3040, 273, -1, 0.000, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3304, -3040, 3136, -3072, 171, 53, 0.000, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2944, -3536, 3112, -3360, 243, 57, 0.000, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3112, -3360, 2816, -3232, 322, 57, 0.000, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2984, -3200, 3280, -3320, 319, 53, 0.000, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2816, -3232, 2976, -3072, 226, 57, 0.000, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3136, -3072, 2984, -3200, 198, 53, 0.000, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3264, -3616, 3072, -3648, 194, -1, 0.000, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3072, -3648, 2944, -3536, 170, 52, 0.000, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2752, -3048, 3048, -2880, 340, 49, 0.000, PACK_DATA(TEX_NUKE24, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3280, -3320, 3104, -3552, 291, 53, 0.000, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3104, -3552, 3264, -3616, 172, 53, 0.000, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2976, -3072, 2752, -3048, 225, 57, 0.000, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3112, -3360, 2944, -3536, 243, 56, 0.000, PACK_DATA(TEX_NUKE24, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2816, -3232, 3112, -3360, 322, 56, 0.000, PACK_DATA(TEX_NUKE24, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2976, -3072, 2816, -3232, 226, 56, 0.000, PACK_DATA(TEX_NUKE24, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2944, -3536, 2752, -3360, 260, 51, 0.000, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2752, -3048, 2976, -3072, 225, 56, 0.000, PACK_DATA(TEX_NUKE24, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2752, -3360, 2752, -3112, 248, 62, 0.063, PACK_DATA(TEX_BROWNGRN, TEX_X, TEX_BROWNGRN, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2752, -3112, 2752, -3048, 64, -1, 0.063, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3680, -3904, 3584, -3904, 96, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3744, -3808, 3680, -3904, 115, -1, 0.000, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3584, -3840, 3616, -3776, 71, -1, 0.000, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3616, -3776, 3552, -3552, 232, -1, 0.000, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3552, -3552, 3552, -3392, 160, -1, 0.063, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3552, -3392, 3648, -3264, 160, -1, 0.000, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3680, -3552, 3744, -3808, 263, -1, 0.000, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3680, -3392, 3680, -3552, 160, -1, 0.063, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3808, -3264, 3680, -3392, 181, -1, 0.000, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3648, -3264, 3496, -3032, 277, -1, 0.000, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3584, -2880, 3808, -3264, 444, -1, 0.000, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3496, -3032, 3456, -3032, 40, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3360, -2880, 3584, -2880, 224, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3400, -3152, 3304, -3040, 147, 53, 0.000, PACK_DATA(TEX_X, TEX_X, TEX_BROWNGRN, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3584, -3904, 3584, -3840, 64, 87, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3304, -3040, 3320, -3040, 16, -1, -0.063, PACK_DATA(TEX_X, TEX_SUPPORT2, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3320, -3040, 3360, -2880, 164, -1, 0.000, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3456, -3032, 3416, -3152, 126, -1, 0.000, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3416, -3152, 3400, -3152, 16, -1, -0.063, PACK_DATA(TEX_X, TEX_SUPPORT2, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2176, -2304, 2208, -2304, 32, -1, -0.063, PACK_DATA(TEX_X, TEX_COMPTILE, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2208, -2560, 2176, -2560, 32, -1, -0.063, PACK_DATA(TEX_X, TEX_COMPTILE, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2176, -2560, 2176, -2304, 256, 20, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2208, -2304, 2208, -2560, 256, 60, 0.063, PACK_DATA(TEX_STEP1, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2208, -2304, 2304, -2304, 96, -1, -0.063, PACK_DATA(TEX_X, TEX_COMPTILE, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2304, -2304, 2304, -2560, 256, -1, 0.063, PACK_DATA(TEX_X, TEX_COMPTILE, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2304, -2560, 2208, -2560, 96, -1, -0.063, PACK_DATA(TEX_X, TEX_COMPTILE, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2208, -2560, 2208, -2304, 256, 59, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2520, -2560, 2752, -2560, 232, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2624, -2784, 2520, -2688, 141, -1, 0.000, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2496, -2560, 2520, -2560, 24, -1, -0.063, PACK_DATA(TEX_X, TEX_SUPPORT2, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2520, -2688, 2496, -2688, 24, -1, -0.063, PACK_DATA(TEX_X, TEX_SUPPORT2, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2496, -2688, 2496, -2560, 128, 15, 0.063, PACK_DATA(TEX_BROWN1, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2752, -2560, 2624, -2784, 257, 50, 0.000, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2752, -3360, 2736, -3360, 16, -1, -0.063, PACK_DATA(TEX_X, TEX_DOORSTOP, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2736, -3112, 2752, -3112, 16, -1, -0.063, PACK_DATA(TEX_X, TEX_DOORSTOP, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2752, -3112, 2752, -3360, 248, 57, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2736, -3360, 2736, -3112, 248, 1, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2736, -3648, 2488, -3744, 265, -1, 0.000, PACK_DATA(TEX_X, TEX_BROWN144, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2488, -3744, 2240, -3776, 250, -1, 0.000, PACK_DATA(TEX_X, TEX_BROWN144, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2240, -3648, 2736, -3648, 496, 1, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 1u) ),\n\t\t\t\tDATA_SIDE_DEF( 2240, -3776, 2240, -3648, 128, 12, 0.063, PACK_DATA(TEX_STARTAN3, TEX_X, TEX_X, 1u) ),\n\t\t\t\tDATA_SIDE_DEF( 2856, -4160, 2888, -4160, 32, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2888, -4160, 2912, -4160, 24, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3160, -4352, 3128, -4352, 32, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3128, -4352, 3104, -4352, 24, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3104, -4160, 3128, -4160, 24, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3128, -4160, 3160, -4160, 32, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2912, -4352, 2888, -4352, 24, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2888, -4352, 2856, -4352, 32, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2888, -4320, 2888, -4352, 32, 64, 0.063, PACK_DATA(TEX_X, TEX_BRNBIGR, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2888, -4352, 2888, -4320, 32, 64, 0.063, PACK_DATA(TEX_X, TEX_BRNBIGL, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2888, -4192, 2888, -4320, 128, 64, 0.063, PACK_DATA(TEX_X, TEX_BRNBIGC, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2888, -4320, 2888, -4192, 128, 64, 0.063, PACK_DATA(TEX_X, TEX_BRNBIGC, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2888, -4160, 2888, -4192, 32, 64, 0.063, PACK_DATA(TEX_X, TEX_BRNBIGL, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2888, -4192, 2888, -4160, 32, 64, 0.063, PACK_DATA(TEX_X, TEX_BRNBIGR, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3128, -4352, 3128, -4320, 32, 64, 0.063, PACK_DATA(TEX_X, TEX_BRNBIGL, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3128, -4320, 3128, -4352, 32, 64, 0.063, PACK_DATA(TEX_X, TEX_BRNBIGR, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3128, -4192, 3128, -4160, 32, 64, 0.063, PACK_DATA(TEX_X, TEX_BRNBIGR, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3128, -4160, 3128, -4192, 32, 64, 0.063, PACK_DATA(TEX_X, TEX_BRNBIGL, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3128, -4320, 3128, -4192, 128, 64, 0.063, PACK_DATA(TEX_X, TEX_BRNBIGC, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3128, -4192, 3128, -4320, 128, 64, 0.063, PACK_DATA(TEX_X, TEX_BRNBIGC, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2912, -4160, 3104, -4160, 192, 84, -0.063, PACK_DATA(TEX_BROWNGRN, TEX_X, TEX_BROWNGRN, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3104, -4352, 2912, -4352, 192, 65, -0.063, PACK_DATA(TEX_BROWNGRN, TEX_X, TEX_BROWNGRN, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2856, -4352, 2856, -4160, 192, 65, 0.063, PACK_DATA(TEX_BROWNGRN, TEX_X, TEX_BROWNGRN, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3160, -4160, 3160, -4352, 192, 65, 0.063, PACK_DATA(TEX_BROWNGRN, TEX_X, TEX_BROWNGRN, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3200, -4128, 3328, -4128, 128, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2688, -4128, 2816, -4128, 128, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2816, -4128, 2856, -4160, 51, -1, 0.000, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3160, -4160, 3200, -4128, 51, -1, 0.000, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3104, -4352, 3104, -4384, 32, -1, 0.063, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3104, -4384, 3160, -4384, 56, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3160, -4384, 3160, -4352, 32, -1, 0.063, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2856, -4352, 2856, -4384, 32, -1, 0.063, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2856, -4384, 2912, -4384, 56, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2912, -4384, 2912, -4352, 32, -1, 0.063, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3328, -4544, 3072, -4544, 256, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2944, -4544, 2688, -4544, 256, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2912, -4352, 3104, -4352, 192, 64, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2688, -4544, 2688, -4128, 416, -1, 0.063, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3328, -4128, 3328, -4544, 416, -1, 0.063, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2856, -4160, 2856, -4352, 192, 64, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3160, -4352, 3160, -4160, 192, 64, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3072, -4544, 2944, -4544, 128, 66, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3072, -4544, 3072, -4608, 64, -1, 0.063, PACK_DATA(TEX_X, TEX_LITE3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2944, -4608, 2944, -4544, 64, -1, 0.063, PACK_DATA(TEX_X, TEX_LITE3, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2944, -4544, 3072, -4544, 128, 65, -0.063, PACK_DATA(TEX_BROWNGRN, TEX_X, TEX_BROWNGRN, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3072, -4608, 3040, -4608, 32, -1, -0.063, PACK_DATA(TEX_X, TEX_STARTAN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2976, -4608, 2944, -4608, 32, -1, -0.063, PACK_DATA(TEX_X, TEX_STARTAN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3024, -4592, 2992, -4592, 32, 67, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_EXITSIGN, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2992, -4600, 3024, -4600, 32, 67, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_EXITSIGN, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3024, -4600, 3024, -4592, 8, 67, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_EXITSIGN, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2992, -4592, 2992, -4600, 8, 67, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_EXITSIGN, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3040, -4608, 2976, -4608, 64, 68, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_STARTAN1, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2992, -4592, 3024, -4592, 32, 66, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3024, -4600, 2992, -4600, 32, 66, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3024, -4592, 3024, -4600, 8, 66, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2992, -4600, 2992, -4592, 8, 66, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2976, -4632, 2976, -4608, 24, -1, 0.063, PACK_DATA(TEX_X, TEX_EXITDOOR, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3040, -4608, 3040, -4632, 24, -1, 0.063, PACK_DATA(TEX_X, TEX_EXITDOOR, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3040, -4632, 2976, -4632, 64, 69, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_EXITDOOR, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2976, -4608, 3040, -4608, 64, 66, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3040, -4632, 3040, -4648, 16, -1, 0.063, PACK_DATA(TEX_X, TEX_DOORTRAK, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2976, -4648, 2976, -4632, 16, -1, 0.063, PACK_DATA(TEX_X, TEX_DOORTRAK, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3040, -4648, 2976, -4648, 64, 72, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2976, -4632, 3040, -4632, 64, 68, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3040, -4672, 3104, -4672, 64, -1, -0.063, PACK_DATA(TEX_X, TEX_STARTAN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2912, -4672, 2976, -4672, 64, -1, -0.063, PACK_DATA(TEX_X, TEX_STARTAN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3104, -4672, 3104, -4864, 192, -1, 0.063, PACK_DATA(TEX_X, TEX_STARTAN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2912, -4864, 2912, -4800, 64, -1, 0.063, PACK_DATA(TEX_X, TEX_STARTAN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2912, -4800, 2912, -4736, 64, -1, 0.063, PACK_DATA(TEX_X, TEX_SW1STRTN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2912, -4736, 2912, -4672, 64, -1, 0.063, PACK_DATA(TEX_X, TEX_STARTAN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3104, -4864, 2912, -4864, 192, -1, -0.063, PACK_DATA(TEX_X, TEX_STARTAN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2976, -4672, 3040, -4672, 64, 72, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_STARTAN1, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3024, -4840, 2992, -4840, 32, 71, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_EXITSIGN, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2992, -4848, 3024, -4848, 32, 71, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_EXITSIGN, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3024, -4848, 3024, -4840, 8, 71, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_EXITSIGN, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2992, -4840, 2992, -4848, 8, 71, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_EXITSIGN, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2992, -4840, 3024, -4840, 32, 70, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3024, -4848, 2992, -4848, 32, 70, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3024, -4840, 3024, -4848, 8, 70, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2992, -4848, 2992, -4840, 8, 70, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3040, -4648, 3040, -4672, 24, -1, 0.063, PACK_DATA(TEX_X, TEX_EXITDOOR, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2976, -4672, 2976, -4648, 24, -1, 0.063, PACK_DATA(TEX_X, TEX_EXITDOOR, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2976, -4648, 3040, -4648, 64, 69, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_EXITDOOR, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3040, -4672, 2976, -4672, 64, 70, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2752, -3776, 2752, -3904, 128, 74, 0.063, PACK_DATA(TEX_BROWN1, TEX_X, TEX_BROWN1, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2720, -3904, 2688, -3776, 131, 81, 0.000, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2688, -3776, 2752, -3776, 64, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2752, -3904, 2720, -3904, 32, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2784, -3776, 2784, -3904, 128, 75, 0.063, PACK_DATA(TEX_BROWN1, TEX_X, TEX_BROWN1, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2752, -3904, 2752, -3776, 128, 73, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2752, -3776, 2784, -3776, 32, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2784, -3904, 2752, -3904, 32, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2816, -3776, 2816, -3904, 128, 76, 0.063, PACK_DATA(TEX_BROWN1, TEX_X, TEX_BROWN1, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2784, -3904, 2784, -3776, 128, 74, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2784, -3776, 2816, -3776, 32, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2816, -3904, 2784, -3904, 32, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2848, -3776, 2848, -3904, 128, 77, 0.063, PACK_DATA(TEX_BROWN1, TEX_X, TEX_BROWN1, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2816, -3904, 2816, -3776, 128, 75, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2816, -3776, 2848, -3776, 32, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2848, -3904, 2816, -3904, 32, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2880, -3776, 2880, -3904, 128, 78, 0.063, PACK_DATA(TEX_BROWN1, TEX_X, TEX_BROWN1, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2848, -3904, 2848, -3776, 128, 76, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2848, -3776, 2880, -3776, 32, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2880, -3904, 2848, -3904, 32, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2880, -3904, 2880, -3776, 128, 77, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2880, -3776, 2912, -3776, 32, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2912, -3904, 2880, -3904, 32, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2912, -3776, 2912, -3904, 128, 83, 0.063, PACK_DATA(TEX_BROWN96, TEX_X, TEX_BROWN96, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2240, -4096, 2240, -3968, 128, 6, 0.063, PACK_DATA(TEX_BROWN1, TEX_X, TEX_BROWN1, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2368, -3968, 2368, -4096, 128, 80, 0.063, PACK_DATA(TEX_BROWN1, TEX_X, TEX_BROWN1, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2368, -4096, 2344, -4096, 24, -1, -0.063, PACK_DATA(TEX_X, TEX_SUPPORT2, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2344, -4096, 2264, -4096, 80, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2264, -4096, 2240, -4096, 24, -1, -0.063, PACK_DATA(TEX_X, TEX_SUPPORT2, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2240, -3968, 2264, -3968, 24, -1, -0.063, PACK_DATA(TEX_X, TEX_SUPPORT2, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2264, -3968, 2344, -3968, 80, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2344, -3968, 2368, -3968, 24, -1, -0.063, PACK_DATA(TEX_X, TEX_SUPPORT2, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2368, -4096, 2368, -3968, 128, 79, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2632, -3792, 2688, -3920, 139, 81, 0.000, PACK_DATA(TEX_BROWN1, TEX_X, TEX_BROWN1, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2688, -3920, 2672, -3920, 16, -1, -0.063, PACK_DATA(TEX_X, TEX_SUPPORT2, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2672, -3920, 2368, -4096, 351, -1, 0.000, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2368, -3968, 2616, -3792, 304, -1, 0.000, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2616, -3792, 2632, -3792, 16, -1, -0.063, PACK_DATA(TEX_X, TEX_SUPPORT2, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2688, -3776, 2720, -3904, 131, 73, 0.000, PACK_DATA(TEX_BROWN1, TEX_X, TEX_BROWN1, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2688, -3920, 2632, -3792, 139, 80, 0.000, PACK_DATA(TEX_X, TEX_X, TEX_BROWN1, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2632, -3792, 2688, -3776, 58, -1, 0.000, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2720, -3904, 2688, -3920, 35, -1, 0.000, PACK_DATA(TEX_X, TEX_BROWN1, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2944, -4000, 3072, -4000, 128, 52, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2944, -4016, 2944, -4000, 16, -1, 0.063, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3072, -4000, 3072, -4016, 16, -1, 0.063, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3072, -4016, 2944, -4016, 128, 85, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_BIGDOOR4, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2944, -3904, 2912, -3904, 32, -1, -0.063, PACK_DATA(TEX_X, TEX_DOORSTOP, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2912, -3776, 2944, -3776, 32, -1, -0.063, PACK_DATA(TEX_X, TEX_DOORSTOP, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2944, -3776, 2944, -3904, 128, 52, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2912, -3904, 2912, -3776, 128, 78, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2912, -4160, 2912, -4128, 32, -1, 0.063, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3104, -4128, 3104, -4160, 32, -1, 0.063, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3104, -4160, 2912, -4160, 192, 64, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2912, -4128, 2944, -4032, 101, -1, 0.000, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3072, -4032, 3104, -4128, 101, -1, 0.000, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2944, -4032, 3072, -4032, 128, 85, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_BIGDOOR4, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 2944, -4032, 2944, -4016, 16, -1, 0.063, PACK_DATA(TEX_X, TEX_DOORTRAK, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3072, -4016, 3072, -4032, 16, -1, 0.063, PACK_DATA(TEX_X, TEX_DOORTRAK, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 2944, -4016, 3072, -4016, 128, 82, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3072, -4032, 2944, -4032, 128, 84, -0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3200, -3968, 3200, -3744, 224, -1, 0.063, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3328, -3744, 3328, -3968, 224, 54, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_X, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3328, -3968, 3304, -3968, 24, -1, -0.063, PACK_DATA(TEX_X, TEX_SUPPORT2, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3304, -3968, 3200, -3968, 104, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3200, -3744, 3304, -3744, 104, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3304, -3744, 3328, -3744, 24, -1, -0.063, PACK_DATA(TEX_X, TEX_SUPPORT2, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3520, -3904, 3520, -3840, 64, 54, 0.063, PACK_DATA(TEX_X, TEX_X, TEX_BROWNGRN, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3584, -3840, 3584, -3904, 64, 58, 0.063, PACK_DATA(TEX_BROWNGRN, TEX_X, TEX_BROWNGRN, 0u) ),\n\t\t\t\tDATA_SIDE_DEF( 3520, -3840, 3536, -3840, 16, -1, -0.063, PACK_DATA(TEX_X, TEX_SUPPORT2, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3536, -3840, 3584, -3840, 48, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3584, -3904, 3536, -3904, 48, -1, -0.063, PACK_DATA(TEX_X, TEX_BROWNGRN, TEX_X, 2u) ),\n\t\t\t\tDATA_SIDE_DEF( 3536, -3904, 3520, -3904, 16, -1, -0.063, PACK_DATA(TEX_X, TEX_SUPPORT2, TEX_X, 2u) )\n\t\t\t),\n\t\t\tDataEntity[102] (\n\t\t\t\tDataEntity( ivec2( 1056, -3616 ), ENTITY_TYPE_PLAYER, 0, 90, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 1545, -2483 ), ENTITY_TYPE_DOOR, 0, 0, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 2926, -3830 ), ENTITY_TYPE_DOOR, 0, 0, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 3000, -4019 ), ENTITY_TYPE_DOOR, 0, 0, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 3000, -4644 ), ENTITY_TYPE_DOOR, 0, 0, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 3410, -3489 ), ENTITY_TYPE_PLATFORM, 0, -10, 7, ivec2( 2996, -4070 ) ),\n\t\t\t\tDataEntity( ivec2( 3533, -3874 ), ENTITY_TYPE_PLATFORM, 1, 200, 7, ivec2( 2945, -2918 ) ),\n\t\t\t\tDataEntity( ivec2( 288, -3104 ), ENTITY_TYPE_DECORATION, ENTITY_SUB_TYPE_DECORATION_TALL_TECHNO_PILLAR, 90, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 288, -3360 ), ENTITY_TYPE_DECORATION, ENTITY_SUB_TYPE_DECORATION_TALL_TECHNO_PILLAR, 90, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 528, -3312 ), ENTITY_TYPE_DECORATION, ENTITY_SUB_TYPE_DECORATION_FLOOR_LAMP, 90, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 528, -3152 ), ENTITY_TYPE_DECORATION, ENTITY_SUB_TYPE_DECORATION_FLOOR_LAMP, 90, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 3440, -3472 ), ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_IMP, 135, 15, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 3360, -3504 ), ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_IMP, 135, 12, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 2912, -2816 ), ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_TROOPER, 90, 15, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 3056, -3584 ), ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_TROOPER, 90, 14, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 3136, -3408 ), ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_TROOPER, 90, 12, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 1824, -3280 ), ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_BLUEARMOR, 180, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 2736, -4256 ), ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_TROOPER, 0, 12, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 3280, -4256 ), ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_TROOPER, 180, 12, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 3008, -4416 ), ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_IMP, 90, 15, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 3280, -4304 ), ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_TROOPER, 180, 12, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 2736, -4304 ), ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_TROOPER, 0, 12, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 2880, -4416 ), ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_MEDIKIT, 0, 15, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 144, -3136 ), ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_HEALTH_BONUS, 90, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 144, -3328 ), ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_HEALTH_BONUS, 90, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 96, -3392 ), ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_HEALTH_BONUS, 90, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 96, -3072 ), ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_HEALTH_BONUS, 90, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 432, -3040 ), ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 90, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 432, -3424 ), ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 90, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 32, -3232 ), ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 90, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( -32, -3232 ), ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 90, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 1312, -3520 ), ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_HEALTH_BONUS, 90, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 736, -3520 ), ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_HEALTH_BONUS, 90, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 752, -2992 ), ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 90, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 976, -2912 ), ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 90, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 1312, -3264 ), ENTITY_TYPE_BARREL, 0, 90, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 1152, -2912 ), ENTITY_TYPE_BARREL, 0, 90, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 864, -3328 ), ENTITY_TYPE_BARREL, 0, 90, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 2672, -2752 ), ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_HEALTH_BONUS, 90, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 2752, -2640 ), ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_HEALTH_BONUS, 90, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 3232, -3040 ), ENTITY_TYPE_DECORATION, ENTITY_SUB_TYPE_DECORATION_FLOOR_LAMP, 90, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 2800, -3040 ), ENTITY_TYPE_DECORATION, ENTITY_SUB_TYPE_DECORATION_FLOOR_LAMP, 90, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 2912, -4176 ), ENTITY_TYPE_DECORATION, ENTITY_SUB_TYPE_DECORATION_FLOOR_LAMP, 180, 15, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 3104, -4176 ), ENTITY_TYPE_DECORATION, ENTITY_SUB_TYPE_DECORATION_FLOOR_LAMP, 180, 15, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 2720, -4352 ), ENTITY_TYPE_DECORATION, ENTITY_SUB_TYPE_DECORATION_FLOOR_LAMP, 180, 15, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 3296, -4352 ), ENTITY_TYPE_DECORATION, ENTITY_SUB_TYPE_DECORATION_FLOOR_LAMP, 180, 15, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 2944, -4320 ), ENTITY_TYPE_BARREL, 0, 180, 15, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 3184, -4224 ), ENTITY_TYPE_BARREL, 0, 180, 15, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 2832, -4240 ), ENTITY_TYPE_BARREL, 0, 180, 15, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 3184, -4176 ), ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_HEALTH_BONUS, 180, 15, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 2832, -4176 ), ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_HEALTH_BONUS, 180, 15, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 2736, -4192 ), ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_HEALTH_BONUS, 180, 15, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 3280, -4192 ), ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_HEALTH_BONUS, 180, 12, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 3280, -4448 ), ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_HEALTH_BONUS, 180, 15, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 2736, -4448 ), ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 180, 15, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 3072, -4832 ), ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 180, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 2944, -4832 ), ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 180, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 3072, -4704 ), ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 180, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 2944, -4704 ), ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 180, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 3008, -4816 ), ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_IMP, 90, 12, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 3072, -4768 ), ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_STIMPACK, 90, 15, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 2304, -4032 ), ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_MEDIKIT, 90, 15, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( -224, -3232 ), ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_GREENARMOR, 90, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( -288, -3232 ), ENTITY_TYPE_DECORATION, ENTITY_SUB_TYPE_DECORATION_BLOODY_MESS, 0, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 1056, -3552 ), ENTITY_TYPE_DECORATION, ENTITY_SUB_TYPE_DECORATION_BLOODY_MESS, 90, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 1792, -2944 ), ENTITY_TYPE_DECORATION, ENTITY_SUB_TYPE_DECORATION_BLOODY_MESS, 270, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 3408, -3504 ), ENTITY_TYPE_DECORATION, ENTITY_SUB_TYPE_DECORATION_BLOODY_MESS, 135, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 2784, -4160 ), ENTITY_TYPE_DECORATION, ENTITY_SUB_TYPE_DECORATION_BLOODY_MESS, 270, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 2272, -2432 ), ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_TROOPER, 180, 15, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 2272, -2352 ), ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_TROOPER, 180, 14, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 2272, -2512 ), ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_SERGEANT, 180, 12, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 2464, -2432 ), ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_SERGEANT, 180, 12, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 2224, -2320 ), ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 180, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 2224, -2544 ), ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 180, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 2288, -2544 ), ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 180, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 2288, -2320 ), ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 180, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 1712, -2144 ), ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 180, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 2240, -2256 ), ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 180, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 3264, -3936 ), ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_SHOTGUN, 270, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 3232, -3808 ), ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_MEDIKIT, 270, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 3216, -3888 ), ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_SERGEANT, 0, 12, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( -160, -3232 ), ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_SERGEANT, 0, 12, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 240, -3376 ), ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_SERGEANT, 135, 12, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 240, -3088 ), ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_SERGEANT, 225, 12, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 1696, -2688 ), ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_SERGEANT, 90, 12, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 1920, -2176 ), ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_SERGEANT, 270, 12, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 2976, -3264 ), ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_SERGEANT, 90, 12, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 3008, -3520 ), ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_SERGEANT, 90, 12, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 3008, -3072 ), ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_SERGEANT, 90, 12, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 2816, -2688 ), ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_SERGEANT, 0, 12, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 2496, -3968 ), ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_SERGEANT, 0, 12, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 2256, -4064 ), ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_SERGEANT, 0, 4, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 3072, -4256 ), ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_SERGEANT, 90, 12, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( -192, -3296 ), ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_SERGEANT, 0, 12, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 3616, -3392 ), ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 0, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 3712, -3264 ), ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 0, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 3472, -2960 ), ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 0, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 3376, -3024 ), ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 0, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 3568, -2992 ), ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 0, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 3616, -3088 ), ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 0, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 3664, -3168 ), ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 0, 7, ivec2( 0, 0 ) ),\n\t\t\t\tDataEntity( ivec2( 3648, -3840 ), ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 0, 7, ivec2( 0, 0 ) )\n\t\t\t)\n\t\t);\n\n\nvoid MainData( out vec4 fragColor, in ivec2 fragCoord )\n{\n    if( all(equal(fragCoord, ivec2(0,0) )))\n    {\n        fragColor = vec4( 88,iResolution.x, iResolution.y, 0 );\n        return;\n    }\n\n    if ( fragCoord.x < 128 )\n    {    \n        int sectorIndex = fragCoord.y - 1;\n        if ( sectorIndex >= 0 && sectorIndex < map.sectorCount )\n        {\n            DataSector sector = map.sectors[ sectorIndex ];\n            \/\/DATA1(0, 1.000);\n            \/\/DATA(1, -80,216,TEX_NUKAGE3,TEX_F_SKY1);\n            \/\/ Sidedefs\n            \/\/DATA(2, 1520,-3168,1672,-3104); \tDATA(3, 164,0.,TEX_X,1); \t\tDATA3(4, TEX_BROWN144,TEX_X,1);\n\n            if ( fragCoord.x == 0 )\n            {\n                fragColor = vec4( sector.lightLevel, sector.sideDefCount, 0, 0 );\n            }\n            else\n            if ( fragCoord.x == 1 )\n            {\n                fragColor = vec4( sector.floorHeight, sector.ceilingHeight, sector.floorTex, sector.ceilingTex );\n            }\n            else\n            {\n                uint sideDefIndex = (uint(fragCoord.x) - 2u) \/ 3u;\n                uint sideDefData = (uint(fragCoord.x) - 2u) % 3u;\n\n                if ( sideDefIndex < uint(map.sectors[ sectorIndex ].sideDefCount) )\n                {\n                    DataSideDef sideDef = UnpackSideDef( map.sideDefs[ uint(sector.firstSideDef) + sideDefIndex ] );\n                    uvec4 unpacked = UNPACK_DATA(sideDef.bytePacked);\n\t\t\t\t\tuint lowerTex = unpacked.x;\n                    uint midTex = unpacked.y;\n                    uint upperTex = unpacked.z;\n                    uint flags = unpacked.w;\n                    \n                    if ( sideDefData == 0u )\n                    {                    \n                        fragColor = vec4( sideDef.A.x, sideDef.A.y, sideDef.B.x, sideDef.B.y );\n                    }\n                    else\n                    if ( sideDefData == 1u )\n                    {\n                        fragColor = vec4( sideDef.len, sideDef.lightLevel, midTex, sideDef.otherSector );\n                    }\n                    else\n                    {\n                        fragColor = vec4( lowerTex, upperTex, flags, 0 );\n                    }\n                }\n                else\n                {\n                    fragColor = vec4( 0 );\n                }\n            }\n        }\n    }\n    else\n    if( fragCoord.x < 130)\n    {\n        int entityIndex = fragCoord.y;\n        if ( entityIndex < 102 )\n        {\n            DataEntity entity = map.entities[entityIndex];\n            \n            if( fragCoord.x == 128)\n            {\n                fragColor = vec4( entity.type, entity.subType, entity.origin.x, entity.origin.y);\n            }\n            else\n            if( fragCoord.x == 129)\n            {\n                fragColor = vec4( entity.angle, entity.flags, entity.triggerPos.x, entity.triggerPos.y);\n            }\n        }\n        else\n        {\n            fragColor = vec4( 0 );\n        }\n    }\n    \n    \t#define DOOR_START 1    \n\n        #define DOOR_COUNT 6\n\t    #define DOOR_END ( DOOR_START + DOOR_COUNT )\n\n\t\t\t\/\/Entities\n\t\t\n\t\t\/\/BEGIN_BLOCK(vec2(128, 0));\n\t\t\/\/BEGIN_ROW(0);\tDATA( 0, ENTITY_TYPE_PLAYER, 0, 1056, -3616 );\tDATA( 1, 90, 7, 0, 0 );\tEND_ROW();\n\n        \/\/ Doors must be the first entities so we can traverse them below\n\t    \/\/#define DOOR_START 1    \n        \n\t\t\/\/BEGIN_ROW(1);\n        \/\/DATA( 0, ENTITY_TYPE_DOOR, 0, 1545, -2483 );\tDATA( 1, 0, 7, 0, 0 );\n\t\t\/\/END_ROW();\n\n\t\t\/\/BEGIN_ROW(2);\n        \/\/DATA( 0, ENTITY_TYPE_DOOR, 0, 2926, -3830 );\tDATA( 1, 0, 7, 0, 0 );\n\t\t\/\/END_ROW();\n\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vFontCoord = floor( fragCoord - FONT_POS );\n    vec2 vFontMax = 10. * FONT_CHAR;\n    bool isBigFont = ( vFontCoord.x >= 0.0 && vFontCoord.y >= 0.0 && vFontCoord.x < (vFontMax.x + 16.0) && vFontCoord.y < (vFontMax.y + 16.0) );\n\n    bool isMapData = all( lessThanEqual( fragCoord, vec2( 148, 100 ) ) );\n    \n    vec2 vMessageUV = vec2(fragCoord.x, (iResolution.y - 1.) - fragCoord.y);\n    int iMessageIndex = int(floor(vMessageUV.y \/ 8.0));\n    bool isMessage = (iMessageIndex < MESSAGE_COUNT) && vMessageUV.x < 240.;\n    \n    vec2 vGridCoord = floor( fragCoord - GRID_POS );\n\n#ifdef WRITE_GRID_DATA\n    bool isGridData = ( vGridCoord.x >= 0.0 && vGridCoord.y >= 0.0 && vGridCoord.x < GRID_SIZE.x && vGridCoord.y < GRID_SIZE.y );\n#else\n    bool isGridData = false;\n#endif\n    \n    if ( !isMapData && !isBigFont && !isMessage && !isGridData) \n    {\n    \tdiscard;\n    }\n            \n    fragColor = vec4(0.0,0.0,0.0,0.0);\n        \n    bool bReuseData = false;\n    if ( iFrame > 1 )\n    {\n\t    \/\/ Check Resolution\n        vec4 info = texelFetch( iChannel0, ivec2(0, 0), 0);\n        if ( (info.y == iResolution.x) && (info.z == iResolution.y) )\n        {\n            bReuseData = true;\n        }\n    }\n\n\tif ( bReuseData )\n    {\n        fragColor = texelFetch( iChannel0, ivec2(fragCoord), 0 );\n        \n        \/\/fragColor.r = sin(iTime * 10.0) *0.5 + 0.5; \/\/ flash the cache\n    }\n    else\n    {\n\t    if( isBigFont )\n    \t{\n            float fFontDigit = floor( vFontCoord.x \/ 16.0);\n            vec2 vFontPixel = floor( vFontCoord.xy );\n            vFontPixel.x = mod( vFontPixel.x, 16.0 );\n            float fValue = NumFont_BinChar( vFontPixel, fFontDigit );\n            \/\/float fValue = NumFont_Char( vFontPixel, fFontDigit );            \n            fragColor =  vec4( fValue );\t        \n            return;\n        }\n        \n        if ( isMessage )\n        {\n            vMessageUV.y = mod(vMessageUV.y, 8.0);\n    \t\tPrintHudMessage( vMessageUV, iMessageIndex, fragColor.rgb );\t\n            fragColor.a = fragColor.r > 0. ? 1.0 : 0.0;\n            return;\n        }                  \n\n#ifdef WRITE_GRID_DATA\n        if ( isGridData )\n        {\n            vec2 vGridCellWorldMin = GRID_WORLD_MIN + (vGridCoord \/ GRID_SIZE) * (GRID_WORLD_MAX - GRID_WORLD_MIN);\n            vec2 vGridCellWorldMax = GRID_WORLD_MIN + ((vGridCoord + 1.) \/ GRID_SIZE) * (GRID_WORLD_MAX - GRID_WORLD_MIN);\n            \n            float fSize = 16.0;\n            \n            vec4 gridData = GetGridData(vGridCellWorldMin - fSize, vGridCellWorldMax + fSize);\n            \n            fragColor = gridData;\n            return;\n        }\n#endif \/\/ WRITE_GRID_DATA        \n        \n\t\tMainData( fragColor, ivec2(fragCoord.xy) );\n    }\n    \n    \/\/ Flashing sectors\n    if ( floor(fragCoord.x) == 0. ) \n    {\n        float fTestSectorId = floor(fragCoord.y);\n        if ( fTestSectorId == 31. || fTestSectorId == 65.)\n        {\n        \tfragColor.x = (hash(floor(iTime * 10.0)) > 0.2) ? 0.4 : 0.8;\n        }\n        else\n        if ( fTestSectorId == 36. || fTestSectorId == 37. )\n        {\n            fragColor.x = sin(iTime * 8.0) * 0.5 + 0.5;\n            fragColor.x = sqrt(fragColor.x);\n        }\n    }\n\n    \/\/ We need to modify the map data in this pass \n    \/\/ but as simply as possible due to constraints in the data shader.\n    \/\/ Doors are hardcoded to be the first n entities...\n    \n    \/\/ Output to the sector info texel\n    if ( floor(fragCoord.x) == 1. )\n    {\n        int iOutputSectorId = int( floor(fragCoord.y - 1.) );\n        \n        for (int iDoorIndex = DOOR_START; iDoorIndex < NO_UNROLL( DOOR_END ); iDoorIndex++)\n        {\n            ivec2 vAddress = ivec2(iDoorIndex, ENTITY_DATA_YPOS);\n            vec4 vEntData0 = LoadVec4( iChannel1, vAddress );\n            \n            \/\/\n            vec3 vUnpacked0 = ByteUnpack3( vEntData0.x ) - 1.;\n            int iType = int(vUnpacked0.x);\n            int iSubType = int(vUnpacked0.y);\n            int iSectorId = int(vUnpacked0.z);\n            \n            \/\/ Validate it really is a door (could be blank on frame zero)\n            if ( iType == ENTITY_TYPE_DOOR )\n            {\n                if ( iSectorId == iOutputSectorId )\n                {\n                    \/\/ Update the ceiling height\n\t\t\t\t    \/\/ The entity target data[0].z field stores the height\n                    fragColor.y = vEntData0.z;\n                }                \n            }            \n            else if ( iType == ENTITY_TYPE_PLATFORM )\n            {\n                if ( iSectorId == iOutputSectorId )\n                {\n                    \/\/ Update the floor height\n\t\t\t\t    \/\/ The entity target data[0].z field stores the height\n                    fragColor.x = vEntData0.z;\n                }                \n            }\n        }        \n                \n    }\n}\n        \n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/\/ Sprite Sheet\n\n\/\/ Pickup \/ Enemy Sprites\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define NO_UNROLL(X) (X + min(0,iFrame))\n#define NO_UNROLLU(X) (X + uint(min(0,iFrame)))\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Texture Helpers\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nfloat hash2D(vec2 p)\n{\n\treturn Hash( dot( p, vec2(1.0, 41.0) ) );\t\n}\n\nfloat noise1D( float p )\n{\n\tfloat fl = floor(p);\n\t\n\tfloat h0 = Hash( fl );\n\tfloat h1 = Hash( fl + 1.0 );\n\t\n\tfloat fr = p - fl;\n\tfloat fr2 = fr * fr;\n\tfloat fr3 = fr2 * fr;\n\t\n\tfloat t1 = 3.0 * fr2 - 2.0 * fr3;\t\n\tfloat t0 = 1.0 - t1;\n\t\n\treturn h0 * t0\n\t\t + h1 * t1;\n}\n\nfloat noise2D( vec2 p, float r )\n{\n\tvec2 fl = floor(p);\n\n\tfloat h00 = hash2D( mod(fl + vec2(0.0, 0.0), r) );\n\tfloat h10 = hash2D( mod(fl + vec2(1.0, 0.0), r) );\n\tfloat h01 = hash2D( mod(fl + vec2(0.0, 1.0), r) );\n\tfloat h11 = hash2D( mod(fl + vec2(1.0, 1.0), r) );\n\t\n\tvec2 fr = p - fl;\n\t\n\tvec2 fr2 = fr * fr;\n\tvec2 fr3 = fr2 * fr;\n\t\n\tvec2 t1 = 3.0 * fr2 - 2.0 * fr3;\t\n\tvec2 t0 = 1.0 - t1;\n\t\n\treturn h00 * t0.x * t0.y\n\t\t + h10 * t1.x * t0.y\n\t\t + h01 * t0.x * t1.y\n\t\t + h11 * t1.x * t1.y;\n}\n\nfloat fbm( vec2 p, float per )\n{\n\tfloat val = 0.0;\n\tfloat tot = 0.0;\n\tfloat mag = 0.5;\n\n\tp += 0.5;\n\tp = p * (1.0 \/ 8.0);\n\tval += noise2D(p, 4.0) * mag; tot+=mag; p=p*2.0 + 1.234; mag*=per;\t\n\tval += noise2D(p, 8.0) * mag; tot+=mag; p=p*2.0 + 2.456; mag*=per;\n\tval += noise2D(p, 16.0) * mag; tot+=mag; p=p*2.0 + 3.678; mag*=per;\n\tval += noise2D(p, 32.0) * mag; tot+=mag;\n\n\treturn val * (1.0 \/ tot);\n}\n\nfloat Indent(vec2 vTexCoord, vec2 vHigh, vec2 vLow, float fHighIntensity, float fLowIntensity)\n{\n\tvec2 vMin = min(vLow, vHigh);\n\tvec2 vMax = max(vLow, vHigh);\n\tif((vTexCoord.x < vMin.x) || (vTexCoord.x > vMax.x) || (vTexCoord.y < vMin.y) || (vTexCoord.y > vMax.y))\n\t\treturn 1.0;\n\n\tif((vTexCoord.x == vHigh.x) || (vTexCoord.y == vHigh.y))\n\t{\n\t\treturn fHighIntensity;\n\t}\n\t\n\tif((vTexCoord.x == vLow.x) || (vTexCoord.y == vLow.y))\n\t{\n\t\treturn fLowIntensity;\n\t}\n\t\n\treturn 1.0;\n}\n\nvec4 SmoothBump(const in vec2 vTexCoord, const in vec2 vMin, const in vec2 vMax, const in vec2 vLightDir, const in float fSize)\n{\n\tvec2 vNearest = min( max(vTexCoord, vMin), vMax );\n\tvec2 vDelta = vNearest - vTexCoord;\n    float fDeltaLen = length(vDelta);\n\tfloat fDist = (fDeltaLen - fSize) \/ fSize;\n\tvec2 vDir = vDelta;\n    if(fDeltaLen > 0.0) vDir = vDir \/ fDeltaLen;\n\tfloat fShade = dot(vDir, vLightDir);\n\t\/\/return clamp(1.0 - (fDist \/ fSize), 0.0, 1.0) * fShade;\n\tfShade *= clamp(1.0 - abs((fDist)), 0.0, 1.0);\n\treturn vec4( fShade, fDist, (vTexCoord - vMin + fSize) \/ (vMax - vMin + fSize * 2.0) );\n}\n\n\nfloat wrap( const in float x , const in float r )\n{\n\treturn fract( x * (1.0 \/ r) ) * r;\n}\n\nvec4 Hexagon( vec2 vUV )\n{\n\tvec2 vIndex;\n\t\n\tfloat fRow = floor(vUV.y);\n\t\n\tvec2 vLocalUV = vUV;\n\tfloat fRowEven = wrap(fRow, 2.0);\n\tif(fRowEven < 0.5)\n\t{\n\t\tvLocalUV.x += 0.5;\n\t}\n\t\n\tvIndex = floor(vLocalUV);\n\t\n\tvec2 vTileUV = fract(vLocalUV);\n\t{\n\t\tfloat m = 2.0 \/ 3.0;\n\t\tfloat c = 2.0 \/ 3.0;\n\t\tif((vTileUV.x *m + c) < vTileUV.y)\n\t\t{\n\t\t\tif(fRowEven < 0.5)\n\t\t\t{\n\t\t\t\tvIndex.x -= 1.0;\n\t\t\t}\n\t\t\tfRowEven = 1.0 - fRowEven;\t\t\t\t\n\t\t\tvIndex.y += 1.0;\n\t\t}\n\t}\n\t\n\t{\n\t\tfloat m = -2.0 \/ 3.0;\n\t\tfloat c = 4.0 \/ 3.0;\n\t\tif((vTileUV.x *m + c) < vTileUV.y)\n\t\t{\n\t\t\tif(fRowEven >= 0.5)\n\t\t\t{\n\t\t\t\tvIndex.x += 1.0;\n\t\t\t}\n\t\t\tfRowEven = 1.0 - fRowEven;\t\t\t\t\n\t\t\tvIndex.y += 1.0;\n\t\t}\n\t}\n\t\n\tvec2 vCenter = vIndex - vec2(0.0, -1.0 \/ 3.0);\n\tif(fRowEven > 0.5)\n\t{\n\t\tvCenter.x += 0.5;\n\t}\n\t\n\tvec2 vDelta = vUV - vCenter;\n\t\n\t\/\/vDelta = abs(vDelta);\n\t\n\tfloat d1 = vDelta.x;\n\tfloat d2 = dot(vDelta, normalize(vec2(2.0\/3.0, 1.0)));\n\tfloat d3 = dot(vDelta, normalize(vec2(-2.0\/3.0, 1.0)));\n\t\n\td2 *= 0.9;\n\td3 *= 0.9;\n\t\n\tfloat fDist = max( abs(d1), abs(d2) );\n\tfDist = max( fDist, abs(d3) );\n\t\n\tfloat fTest = max(max(-d1, -d2), d3);\n\t\n\treturn vec4(vIndex, abs(fDist), fTest);\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Raymarching\n\n\nstruct SceneResult\n{\n\tfloat fDist;\n\tfloat fObjectId;\n    vec3 vUVW;\n};\n\nSceneResult Scene_Union( const in SceneResult a, const in SceneResult b )\n{\n    if ( a.fDist < b.fDist )\n    {\n        return a;\n    }\n    return b;\n}\n    \nSceneResult Scene_Subtract( const in SceneResult a, const in SceneResult b )\n{\n    if ( -a.fDist < b.fDist )\n    {\n        return a;\n    }\n\n    SceneResult result;\n    result.fDist = -b.fDist;\n    result.fObjectId = b.fObjectId;\n    result.vUVW = b.vUVW;\n    return result;\n}\n\nSceneResult Scene_Intersection( const in SceneResult a, const in SceneResult b )\n{\n    if ( a.fDist > b.fDist )\n    {\n        return a;\n    }\n    return b;\n}\n    \nSceneResult Scene_GetDistance( const vec3 vPos );    \n\nvec3 Scene_GetNormal(const in vec3 vPos)\n{\n    const float fDelta = 0.01;\n    \n#if 1    \n    \/\/ dont unroll normal calculation ( from https:\/\/www.shadertoy.com\/view\/ldd3DX )\n    \n    vec3 n = vec3(0.0);\n    for( int i=0; i<NO_UNROLL(4); i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*Scene_GetDistance(vPos+e*fDelta).fDist;\n    }\n    \n    return normalize( n );\n#else\n    \n    vec2 e = vec2( -1, 1 );\n    \n    vec3 vNormal = \n        Scene_GetDistance( vPos + e.yxx * fDelta ).fDist * e.yxx + \n        Scene_GetDistance( vPos + e.xxy * fDelta ).fDist * e.xxy + \n        Scene_GetDistance( vPos + e.xyx * fDelta ).fDist * e.xyx + \n        Scene_GetDistance( vPos + e.yyy * fDelta ).fDist * e.yyy;\n    \n    if ( dot( vNormal, vNormal ) < 0.00001 )\n    {\n        return vec3(0, 1, 0);\n    }\n    \n    return normalize( vNormal );\n#endif\n}    \n\nSceneResult Scene_Trace( const in vec3 vRayOrigin, const in vec3 vRayDir, float maxDist )\n{\t\n    SceneResult result;\n    result.fDist = 0.0;\n    result.vUVW = vec3(0.0);\n    result.fObjectId = 0.0;\n    \n\tfloat t = 0.1;\n\tconst int kRaymarchMaxIter = 128;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\t\t\n\t\tresult = Scene_GetDistance( vRayOrigin + vRayDir * t );\t\t\n        t += result.fDist;\n\n        if ( abs(result.fDist) < 0.001 )\n\t\t{\n\t\t\tbreak;\n\t\t}\t\t\n        if ( t > maxDist )\n        {\n            result.fObjectId = -1.0;\n\t        t = maxDist;\n            break;\n        }\n\t}\n    \n    result.fDist = t;\n\n    return result;\n}\n\n\nvec4 Raymarch_GetColor( vec3 vRayOrigin, vec3 vRayDir )\n{\n    vec4 vColor = vec4(0);\n    \n    return vColor;\n}\n\nstruct PoseLeg\n{\n    vec3 vHip;\n    vec3 vKnee;\n    vec3 vAnkle;\n    vec3 vToe;\n};\n\nstruct PoseArm\n{\n    vec3 vShoulder;\n    vec3 vElbow;\n    vec3 vWrist;\n    vec3 vHand;\n};\n\nstruct Pose\n{\n    PoseLeg leftLeg;\n    PoseLeg rightLeg;\n    PoseArm leftArm;\n    PoseArm rightArm;\n    \n    vec3 vHeadUp;\n    vec3 vHeadFd;\n};\n    \nstruct CharDef\n{\n    float fToe;\n    float fAnkle;\n    float fKnee;\n    float fHip;\n    \n    float fShoulder;\n    float fElbow;\n    float fWrist;\n    float fHand;\n    \n    float fHead1;\n    float fHead2;\n        \n    vec3 vCol;\n\n    vec3 vUniformColor0;\n    vec3 vUniformColor1;\n    vec3 vBootsColor;\n    vec3 vSkinColor;\n\n    vec3 vEyeColor;\n    vec3 vHairColor;\n};\n\nvoid CharDef_Default( inout CharDef charDef )\n{    \n    charDef.fToe = 2.5;\n    charDef.fAnkle = 3.0;\n    charDef.fKnee = 3.0;\n    charDef.fHip = 4.0;\n    \n    charDef.fShoulder = 3.0;\n    charDef.fElbow = 2.5;\n    charDef.fWrist = 2.4;\n    charDef.fHand = 2.5;\n    \n    charDef.fHead1 = 4.0;\n    charDef.fHead2 = 3.0;    \n    \n    charDef.vCol = vec3( 0.4, 1.0, 0.2 );\n    charDef.vEyeColor = vec3( 1, 0, 0 );\n    \n    charDef.vUniformColor0 = vec3( 0, 1, 0 );\n    charDef.vUniformColor1 = vec3( 0, 0, 1 );\n    charDef.vBootsColor = vec3(0.5);\n    charDef.vSkinColor = vec3(239, 163, 115) \/ 255.;    \n    charDef.vHairColor = vec3( 0 );\n}\n\nvoid CharDef_Imp( inout CharDef charDef )\n{    \n    CharDef_Default(charDef);\n    \n    float fExtra = 1.0;\n    \n    charDef.fToe += fExtra;\n    charDef.fAnkle += fExtra;\n    charDef.fKnee += fExtra;\n    charDef.fHip += fExtra;\n    \n    charDef.fShoulder += fExtra;\n    charDef.fElbow += fExtra;\n    charDef.fWrist += fExtra;\n    charDef.fHand += fExtra;\n    \n    charDef.fHead1 += 0.4;\n    charDef.fHead2 += 0.4;  \n    \n    charDef.vCol = vec3( 1.0, 0.5, 0.2 );\n    charDef.vUniformColor0 = charDef.vCol;\n\tcharDef.vUniformColor1 = charDef.vCol * 0.7;\n\tcharDef.vSkinColor = charDef.vCol * 1.2;\n    charDef.vBootsColor = charDef.vCol * 0.5;\n    charDef.vHairColor = charDef.vSkinColor;\n\n    charDef.vEyeColor = vec3( 1.0, 0.9, .1 ) * 10.;\n}\n\nvoid CharDef_Trooper( inout CharDef charDef )\n{    \n    CharDef_Default(charDef);\n\n    float fExtra = 0.1;\n    \n    charDef.fToe += fExtra;\n    charDef.fAnkle += fExtra;\n    charDef.fKnee += fExtra;\n    charDef.fHip += fExtra;\n    \n    charDef.fShoulder += fExtra;\n    charDef.fElbow += fExtra;\n    charDef.fWrist += fExtra;\n    charDef.fHand += fExtra;\n    \n    charDef.fHead1 = 3.5;\n    charDef.fHead2 = 3.2;      \n\n    charDef.vUniformColor0 = vec3( 87, 67, 44 ) \/ 255.;\n    charDef.vUniformColor1 = 1.5 * vec3( 90, 71, 49 ) \/ 255.;\n    charDef.vBootsColor = 1.5 * vec3(63,71,43) \/ 255.;\n\n    charDef.vHairColor = vec3( 67, 147, 55) \/ 255.;\n\n    charDef.fHead1 = 3.5;\n    charDef.fHead2 = 3.2;      \n}\n\nvoid CharDef_Sergeant( inout CharDef charDef )\n{    \n    CharDef_Default(charDef);\n\n    float fExtra = 0.2;\n    \n    charDef.fToe += fExtra;\n    charDef.fAnkle += fExtra;\n    charDef.fKnee += fExtra;\n    charDef.fHip += fExtra;\n    \n    charDef.fShoulder += fExtra;\n    charDef.fElbow += fExtra;\n    charDef.fWrist += fExtra;\n    charDef.fHand += fExtra;\n    \n    charDef.fHead1 = 3.5;\n    charDef.fHead2 = 3.2;      \n\n    charDef.vCol = vec3( 0.3, 0.3, 0.3 );\n\n    charDef.vUniformColor0 = vec3( 0.3, .3, .3 );\n    charDef.vUniformColor1 = vec3( 0.1, 0.1, 0.1 );\n    charDef.vBootsColor = vec3(0.5,0,0);\n\n    charDef.vHairColor = vec3( 179, 115, 71) \/ 255.;\n}\n\nstruct Scene\n{\n    float fCameraRotation;\n    vec3 vLightDir;\n    vec3 vLightColor;\n    vec3 vAmbientLight;\n    \n    bool bArmor;\n    bool bCharacter;\n    \n    CharDef charDef;\n    Pose pose;\n    \n    vec3 vWeaponStart;\n    vec3 vWeaponDir;\n    \n};\n    \nScene g_scene;\n\nvoid Pose_MirrorLeft( inout Pose pose )\n{\n    vec3 vMirror = vec3( -1.0, 1, 1 );\n    pose.rightLeg.vHip = pose.leftLeg.vHip * vMirror;\n    pose.rightLeg.vKnee = pose.leftLeg.vKnee * vMirror;\n    pose.rightLeg.vAnkle = pose.leftLeg.vAnkle * vMirror;\n    pose.rightLeg.vToe = pose.leftLeg.vToe * vMirror;\n\n    pose.rightArm.vShoulder = pose.leftArm.vShoulder * vMirror;\n    pose.rightArm.vElbow = pose.leftArm.vElbow * vMirror;\n    pose.rightArm.vWrist = pose.leftArm.vWrist * vMirror;\n    pose.rightArm.vHand = pose.leftArm.vHand * vMirror;\n}\n\n\nvoid Pose_Flip( inout Pose pose )\n{\n    vec3 vTemp;\n    vec3 vMirror = vec3( -1.0, 1, 1 );\n        \n\t#define SWAP_FLIP(X,Y) vTemp=X;X=Y*vMirror; Y=vTemp*vMirror;\n    \n    SWAP_FLIP(pose.rightLeg.vHip, pose.leftLeg.vHip);\n    SWAP_FLIP(pose.rightLeg.vKnee, pose.leftLeg.vKnee);\n    SWAP_FLIP(pose.rightLeg.vAnkle, pose.leftLeg.vAnkle);\n    SWAP_FLIP(pose.rightLeg.vToe, pose.leftLeg.vToe);\n\n    SWAP_FLIP(pose.rightArm.vShoulder, pose.leftArm.vShoulder);\n    SWAP_FLIP(pose.rightArm.vElbow, pose.leftArm.vElbow);\n    SWAP_FLIP(pose.rightArm.vWrist, pose.leftArm.vWrist);\n    SWAP_FLIP(pose.rightArm.vHand, pose.leftArm.vHand);\n    \n    pose.vHeadUp *= vMirror;\n    pose.vHeadFd *= vMirror;\n}\n\nvoid Pose_Clear( inout Pose pose )\n{\n    pose.leftLeg.vHip = vec3( 2.0, 24.0, 1.0 );\n    pose.leftLeg.vKnee = vec3( 5.0, 14.0, -2.0 );\n    pose.leftLeg.vAnkle = vec3( 5.0, 3.0, -0.0 );\n    pose.leftLeg.vToe = vec3( 5.0, 3.0, -4.0 );\n\n    pose.leftArm.vShoulder = vec3( 3.5, 40.0, 0.0 );\n    pose.leftArm.vElbow = vec3( 8.0, 30.0, 1.0 );\n    pose.leftArm.vWrist = vec3( 9.0, 28.0, -4.0 );\n    pose.leftArm.vHand = vec3( 10.0, 28.0, -5.0 );\n    \n    Pose_MirrorLeft( pose );\n    \n    pose.vHeadUp = vec3(0, 1, 0);\n    pose.vHeadFd = vec3(0, 0, -1);\n}\n\nvoid Pose_Attack( inout Pose pose )\n{\n    pose.leftLeg.vHip = vec3( 2.0, 24.0, 1.0 );\n    pose.leftLeg.vKnee = vec3( 5.0, 14.0, -2.0 );\n    pose.leftLeg.vAnkle = vec3( 5.0, 3.0, -0.0 );\n    pose.leftLeg.vToe = vec3( 5.0, 3.0, -2.0 );\n\n    pose.leftArm.vShoulder = vec3( 3.5, 40.0, -1.0 );\n    pose.leftArm.vElbow = vec3( 8.0, 34.0, -5.0 );\n    pose.leftArm.vWrist = vec3( 1.2, 37.0, -10.0 );\n    pose.leftArm.vHand = vec3( 0.0, 37.0, -10.0 );\n    \n    Pose_MirrorLeft( pose );\n        \n    pose.leftLeg.vHip.z = 3.0;\n    pose.leftLeg.vKnee.z = 5.0;\n    pose.leftLeg.vAnkle.z = 8.0;\n    pose.leftLeg.vAnkle.y = 4.0;\n    pose.leftLeg.vToe.z = 5.0;\n\n    pose.rightLeg.vHip.z = 1.0;\n    pose.rightLeg.vKnee.z = -5.0;\n    pose.rightLeg.vAnkle.z = -8.0;\n    pose.rightLeg.vToe.z = -7.0;\n\n    pose.leftArm.vShoulder.z += 1.;\n    pose.rightArm.vShoulder.z -= 1.;\n\n    pose.leftArm.vHand.y += 1.8;\n    pose.leftArm.vHand.z -= 3.;\n    pose.leftArm.vWrist.z -= 3.;\n    pose.rightArm.vHand.z += 1.;\n    pose.rightArm.vWrist.z += 1.;\n    \n    pose.vHeadUp = vec3(0, 1, -.5);\n    pose.vHeadFd = vec3(0, 0, -1);    \n}\n\nvoid Pose_Walk1( inout Pose pose )\n{\n    pose.leftLeg.vHip = vec3( 2.0, 24.0, 1.0 );\n    pose.leftLeg.vKnee = vec3( 5.0, 14.0, -4.0 );\n    pose.leftLeg.vAnkle = vec3( 5.0, 8.0, 7.0 );\n    pose.leftLeg.vToe = vec3( 5.0, 4.0, 6.0 );\n\n    pose.rightLeg.vHip = vec3( -2.0, 24.0, 1.0 );\n    pose.rightLeg.vKnee = vec3( -5.0, 14.0, -2.0 );\n    pose.rightLeg.vAnkle = vec3( -5.0, 3.0, 2.0 );\n    pose.rightLeg.vToe = vec3( -5.0, 2.0, -2.0 );\n\n    pose.leftArm.vShoulder.z += 1.;\n    pose.rightArm.vShoulder.z -= 1.;\n    \n    pose.vHeadUp = vec3(0, 1, -.5);\n    pose.vHeadFd = vec3(0.1, 0, -1);    \n    \n    \n    pose.rightArm.vShoulder = vec3( -3.5, 40.0, 1.0 );\n    pose.rightArm.vElbow = vec3( -8.0, 30.0, -0.0 );\n    pose.rightArm.vWrist = vec3( -9.0, 24.0, -8.0 );\n    pose.rightArm.vHand = vec3( -9.0, 23.0, -9.0 );    \n\n    pose.leftArm.vShoulder = vec3( 3.5, 40.0, -1.0 );\n    pose.leftArm.vElbow = vec3( 8.0, 30.0, 2.0 );\n    pose.leftArm.vWrist = vec3( 9.0, 24.0, -4.0 );\n    pose.leftArm.vHand = vec3( 9.0, 23.0, -6.0 );\n}\n\nvoid Pose_Walk2( inout Pose pose )\n{\n    Pose_Walk1( pose );\n    Pose_Flip( pose );\n}\n\nvoid Pose_Pain( inout Pose pose )\n{\n    pose.leftLeg.vHip = vec3( 2.0, 24.0, 1.0 );\n    pose.leftLeg.vKnee = vec3( 4.0, 15.0, -2.0 );\n    pose.leftLeg.vAnkle = vec3( 4.0, 4.0, -0.0 );\n    pose.leftLeg.vToe = vec3( 4.0, 3.0, -4.0 );\n\n    pose.leftArm.vShoulder = vec3( 3.5, 36.0, 6.0 );\n    pose.leftArm.vElbow = vec3(10.0, 27.0, 4.0 );\n    pose.leftArm.vWrist = vec3( 12.0, 25.0, -6.0 );\n    pose.leftArm.vHand = vec3( 12.5, 26.0, -6.0 );\n    \n    Pose_MirrorLeft( pose );\n\n    pose.rightLeg.vHip = vec3( -2.0, 24.0, 1.0 );\n    pose.rightLeg.vKnee = vec3( -4.0, 15.0, 2.0 );\n    pose.rightLeg.vAnkle = vec3( -4.0, 4.0, 3.0 );\n    pose.rightLeg.vToe = vec3( -4.0, 3.0, -2.0 );\n\n    \n    pose.vHeadUp = vec3(0, 1, .5);\n    pose.vHeadFd = vec3(0, .5, -1);\n    \n}\n\nvoid Pose_Die( inout Pose pose )\n{\n    pose.leftLeg.vHip = vec3( 2.0, 20.0, -3.0 );\n    pose.leftLeg.vKnee = vec3( 4.0, 12.0, -10.0 );\n    pose.leftLeg.vAnkle = vec3( 4.0, 4.0, -6.0 );\n    pose.leftLeg.vToe = vec3( 4.0, 3.0, -11.0 );\n\n    pose.leftArm.vShoulder = vec3( 3.5, 28.0, 9.0 );\n    pose.leftArm.vElbow = vec3(10.0, 23.0, 4.0 );\n    pose.leftArm.vWrist = vec3( 9.0, 28.0, -6.0 );\n    pose.leftArm.vHand = vec3( 8.5, 29.0, -6.0 );\n    \n    Pose_MirrorLeft( pose );\n\n    pose.leftArm.vWrist.y -= 4.0;\n    pose.leftArm.vHand.y -= 5.0;\n    pose.leftArm.vHand.z -= 2.0;\n    \n    pose.rightArm.vHand.z -= 2.0;\n    \n    pose.rightLeg.vKnee.x -= 3.0;\n        \n    pose.vHeadUp = vec3(0, 1, .6);\n    pose.vHeadFd = vec3(0, .5, -1);\n    \n}\n\nvoid Pose_Weapon()\n{\n    \n    g_scene.vWeaponStart = g_scene.pose.rightArm.vHand + vec3( 0, 2, 0);\n    g_scene.vWeaponDir = normalize( g_scene.pose.leftArm.vHand - g_scene.vWeaponStart );\n}\n\nvoid Weapon_None()\n{\n\tg_scene.vWeaponStart = vec3(-10,-100,0);\n    g_scene.vWeaponDir = vec3(1, 0, 0);\n}\n\nvoid Weapon_DefaultPos()\n{\n\tg_scene.vWeaponStart = vec3(-10,6,0);\n    g_scene.vWeaponDir = vec3(1, 0, 0);\n    \n}\n\n\nvoid Pose_Dead( inout Pose pose )\n{\n    float dy = 4.0;\n    pose.leftLeg.vHip = vec3( 2.0, dy + 3.0, 1.0 );\n    pose.leftLeg.vKnee = vec3( 4.0, dy + 4.0, -2.0 );\n    pose.leftLeg.vAnkle = vec3( 15.0, dy + 7.0, -0.0 );\n    pose.leftLeg.vToe = vec3( 6.0, dy + 4.0, -2.0 );\n\n    pose.leftArm.vShoulder = vec3( 3.5, dy + 5.0, 0.0 );\n    pose.leftArm.vElbow = vec3( 4.0, dy + 4.0, 1.0 );\n    pose.leftArm.vWrist = vec3( 3.0, dy + 6.0, -4.0 );\n    pose.leftArm.vHand = vec3( 5.0, dy + 4.0, -5.0 );\n    \n    Pose_MirrorLeft( pose );\n\n    pose.leftArm.vElbow.y += 5.;\n    pose.leftLeg.vKnee.y += 4.;\n    \n    pose.vHeadUp = vec3(1, 0.3, 0);\n    pose.vHeadFd = vec3(0, 0, -1);\n    \n    Weapon_None();\n}\n\nvoid Scene_Clear()\n{\n    g_scene.vLightDir = normalize( vec3(0, 1, -0.3) );\n    g_scene.vLightColor = vec3(1, 1, 1);\n    g_scene.vAmbientLight = vec3(0.4);\n    \n    g_scene.bCharacter = false;\n    g_scene.bArmor = false;\n        \n    g_scene.fCameraRotation = 0.0;\n    \n\t\n    Weapon_None();\n    \n    Pose_Clear( g_scene.pose );\n    \n    CharDef_Default( g_scene.charDef );\n}\n\n\n\nconst float kMaxTraceDist = 1000.0;\n\n#define MAT_BG 0.0\n#define MAT_CHARACTER 1.0\n#define MAT_WHITE 2.0\n#define MAT_GREY 3.0\n#define MAT_SHOTGUN 4.0\n#define MAT_WOOD 5.0\n#define MAT_HEAD 6.0\n#define MAT_EYE 7.0\n\nvec2 Segment_Internal( vec3 vPos, vec3 vP0, vec3 vP1 )\n{\n\tvec3 pa = vPos - vP0;\n\tvec3 ba = vP1 - vP0;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\t\n\treturn vec2( length( pa - ba*h ), h );\n}\n\nfloat Segment( vec3 vPos, vec3 vP0, vec3 vP1, float r0, float r1 )\n{\n    vec2 vC = Segment_Internal( vPos, vP0, vP1 );\n    \n    return vC.x - mix(r0, r1, vC.y);\n}\n\nvec3 Segment3( vec3 vPos, vec3 vP0, vec3 vP1, float r0, float r1 )\n{\n    \/\/return vec3( Segment( vPos, vP0, vP1, r0, r1 ) );\n    vec3 vDir = normalize(vP1 - vP0);\n    float len = length( vP1 - vP0 );\n    float t = dot( vDir, vPos - vP0 ) \/ len;\n    float clamped_t = clamp( t, 0.0, 1.0 );\n\n    vec3 vClosestOnLine = mix( vP0, vP1, clamped_t);\n    vec3 vDirToClosest = vPos - vClosestOnLine;\n    float fClosestDist = length( vDirToClosest );\n    \n    float d = fClosestDist - mix(r0, r1, t);\n\n    vec3 fd = vec3(1,0,0);\n    \n    return vec3( d, t, dot( fd, normalize(vDirToClosest))  );\n}\n\n\n\/*\nfloat Limb( vec3 vPos, vec3 vP0, vec3 vP1, vec3 vPerpDir, float l1, float l2, float rStart, float rMid, float rEnd )\n{\n    vec3 vStartToEnd = vP1 - vP0;\n    vec3 vDir = normalize( vStartToEnd );\n    \n    vec3 vTemp = cross( vDir, vPerpDir);\n    vec3 vPerDir = normalize( cross( vDir, vTemp) );\n    \n    float d = length( vStartToEnd );\n    \n    float d1 = (l1 * l1 - l2 *  l2 + d * d) \/ ( 2.0 * d );\n    float d2 = d - d1;\n    \n    float h = sqrt( l1 * l1 - d1 * d1 );\n\n    vec3 vMidPoint = vP0 + vDir * d1 + vPerpDir * h;\n    \n    return LimbSegments();\n    float fSD1 = Segment( vPos, vP0, vMidPoint, rStart, rMid );\n    float fSD2 = Segment( vPos, vMidPoint, vP1, rMid, rEnd );\n\n    return min( fSD1, fSD2 );\n}\n*\/\nfloat SmoothMin( float a, float b, float k )\n{\n\t\/\/return min(a,b);\n\t\n\t\n    \/\/float k = 0.06;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)\/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 SmoothMin3( vec3 a, vec3 b, float k )\n{\n\t\/\/return min(a,b);\n\t\n\t\n    \/\/float k = 0.06;\n\tfloat h = clamp( 0.5 + 0.5*(b.x-a.x)\/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 LimbCombine( vec3 fA, vec3 fB )\n{\n    return SmoothMin3( fA, fB, 0.5);\n    \/\/return min( fA, fB );\n}\n\nvec3 Chain( vec3 vPos, vec4 vA, vec4 vB, vec4 vC, vec4 vD, vec3 vWeights )\n{\n    vec3 vD1 = Segment3( vPos, vA.xyz, vB.xyz, vA.w, vB.w );\n    vec3 vD2 = Segment3( vPos, vB.xyz, vC.xyz, vB.w, vC.w );\n    vec3 vD3 = Segment3( vPos, vC.xyz, vD.xyz, vC.w, vD.w );\n    \n    vD1.y = vD1.y * vWeights.x;\n    vD2.y = vWeights.x + vD2.y * vWeights.y;\n    vD3.y = vWeights.x + vWeights.y + vD3.y * vWeights.z;\n    \n    vec3 vResult = LimbCombine( vD1, vD2 );    \n    vResult = LimbCombine( vResult, vD3 );    \n    return vResult;\n}\n\nvec3 LegDist( vec3 vPos, PoseLeg leg )\n{    \n    return Chain( \n        vPos,\n        vec4(leg.vToe, g_scene.charDef.fToe),\n        vec4(leg.vAnkle, g_scene.charDef.fAnkle),\n        vec4(leg.vKnee, g_scene.charDef.fKnee), \n        vec4(leg.vHip, g_scene.charDef.fHip), \n        vec3(0.1, 0.4, 0.5 )\n    );\n}\n\nvec3 ArmDist( vec3 vPos, PoseArm arm )\n{\n    return Chain( \n        vPos,\n        vec4(arm.vShoulder, g_scene.charDef.fShoulder), \n        vec4(arm.vElbow, g_scene.charDef.fElbow), \n        vec4(arm.vWrist, g_scene.charDef.fWrist),\n        vec4(arm.vHand, g_scene.charDef.fHand),\n        vec3(0.5, 0.4, 0.1 )\n    );    \n}\n\n\nvec3 TorsoDistance( vec3 vPos, vec3 vA, vec3 vB, vec3 vC, vec3 vD, float fSizeTop, float fSizeBase )\n{    \n    vec3 vMidBase = (vA + vB) * 0.5;\n    vec3 vMidTop = (vC + vD) * 0.5;\n    \n    vec3 vAxis = vMidTop - vMidBase;\n    float fAxisLen = length( vAxis );\n    vec3 vAxisDir = normalize( vAxis );\n    \n    float fProjection = dot( vAxisDir, vPos - vMidBase );\n    \n    float fNormProj = fProjection \/ fAxisLen;\n    float fNormProjClamped = clamp( fNormProj, 0., 1. );\n    \n    \/\/vec3 vProjected = vMidBase + vAxisDir * clamp( fProjection, 0., fAxisLen );\n    \n    vec3 vSpinePos = mix( vMidBase, vMidTop, fNormProjClamped );\n\n    vec3 vPerpBase = (vB - vA) * 0.5;\n    vec3 vPerpTop = (vD - vC) * 0.5;\n    \n    vec3 vPerp = mix( vPerpBase, vPerpTop, fNormProj );\n    vec3 vPerpDir = normalize( vPerp );\n    \n    float fSideLen = length( vPerp );\n    \n    float fPerpProj = dot( vPerpDir, vPos - vSpinePos );\n    float fPerpProjClamped = clamp( fPerpProj, -fSideLen, fSideLen );\n    \n\tvec3 vBackPlanePos = vSpinePos + vPerpDir * fPerpProjClamped;\n    \n    float fSize = mix( fSizeBase, fSizeTop, fNormProjClamped );\n    \n    \/\/float fNormPerpProj = fPerpProj \/ length(vPerp);\n    \/\/float fNormPerpProjClamped = clamp( fNormPerpProj, -1., 1.);\n    \n    \/\/vec3 vSidePos = vSpinePos + vPerp;\n    \/\/vec3 vBackPlanePos = mix( vSpinePos, vSidePos, fNormPerpProjClamped );\n    \n    \n    float fDistance = length(vPos - vBackPlanePos) - fSize;\n    \n    return vec3( fDistance, fNormProj, fPerpProj \/ (fSideLen * 2.0) + 0.5);\n}\n\nfloat BodyCombine( float fA, float fB )\n{\n    return SmoothMin( fA, fB, 0.5);\n    \/\/return min( fA, fB );\n}\nvec3 BodyCombine3( vec3 fA, vec3 fB )\n{\n    return SmoothMin3( fA, fB, 0.5);\n    \/\/return min( fA, fB );\n}\n\nSceneResult Character_GetDistance( vec3 vPos )\n{\n    SceneResult result = SceneResult( kMaxTraceDist, MAT_BG, vec3(0.0) );\n\n\n    vec3 vLeftLeg = LegDist( vPos, g_scene.pose.leftLeg );\n    vec3 vRightLeg = LegDist( vPos, g_scene.pose.rightLeg );\n    vec3 vLeftArm = ArmDist( vPos, g_scene.pose.leftArm );\n    vec3 vRightArm = ArmDist( vPos, g_scene.pose.rightArm );\n    vec3 vTorsoDist = TorsoDistance( \n        vPos,\n        g_scene.pose.leftLeg.vHip, \n        g_scene.pose.rightLeg.vHip,\n        g_scene.pose.leftArm.vShoulder,\n        g_scene.pose.rightArm.vShoulder,\n    \tg_scene.charDef.fShoulder, g_scene.charDef.fHip);\n        \n    vTorsoDist.y += 1.0;\n    vLeftArm.y += 2.0;\n    vRightArm.y += 2.0;            \n    vLeftArm.z += 1.0;\n    vLeftLeg.z += 1.0;\n        \n    vec3 vLimbDist = vec3(10000.0);\n    vLimbDist = BodyCombine3( vLimbDist, vLeftLeg );\n    vLimbDist = BodyCombine3( vLimbDist, vRightLeg );\n    vLimbDist = BodyCombine3( vLimbDist, vLeftArm );\n    vLimbDist = BodyCombine3( vLimbDist, vRightArm );        \n    vec3 vCharacterDist = BodyCombine3( vLimbDist, vTorsoDist );\n\n    \/\/vCharacterDist.x -= fbm( vLimbDist.xy * 10., 0.9 ) * 2.0;\n    \n    float fNeckSize = 1.0;\n    float fNeckLen = 3.0;\n\n    vec3 vNeckBase = (g_scene.pose.leftArm.vShoulder + g_scene.pose.rightArm.vShoulder) * 0.5;\n    vec3 vNeckTop = vNeckBase + g_scene.pose.vHeadUp * fNeckLen;\n    vec3 vNeckDist = Segment3( vPos, vNeckBase, vNeckTop, fNeckSize, fNeckSize );\n    \n    float fHead1 = g_scene.charDef.fHead1;\n    float fHead2 = g_scene.charDef.fHead2;\n    float fHeadTop = 6.0;\n    float fHeadChin = 2.0;\n    \n    vec3 vHeadBase = vNeckBase + g_scene.pose.vHeadUp * ( fHeadChin + fHead2);\n    vec3 vHead2 = vHeadBase  + g_scene.pose.vHeadFd * (fHead2 * .5);\n    vec3 vHead1 = vHeadBase + g_scene.pose.vHeadUp * (fHeadTop - fHead1);\n    \n    vec3 vHeadDist = Segment3( vPos, vHead1, vHead2, fHead1, fHead2 );\n    vHeadDist = SmoothMin3( vHeadDist, vNeckDist, 0.5 );\n\n    vec3 vNosePos = vHead1 + g_scene.pose.vHeadFd * fHead1 * 1.2 - g_scene.pose.vHeadUp * 1.5;\n    float fNoseDist = length( vPos - vNosePos ) - 1.;\n    vHeadDist.x = min( vHeadDist.x, fNoseDist ); \/\/ keep material\n\n\n    vec3 vEyePerp = normalize( cross(g_scene.pose.vHeadFd, g_scene.pose.vHeadUp) );\n\n    vec3 vEyePos1 = vHead1 + g_scene.pose.vHeadFd * fHead1 + vEyePerp * 1.5;\n    float fEyeDist1 = length( vPos - vEyePos1 ) - 1.;\n\n    vec3 vEyePos2 = vHead1 + g_scene.pose.vHeadFd * fHead1 - vEyePerp * 1.5;\n    float fEyeDist2 = length( vPos - vEyePos2 ) - 1.;\n    \n    float fEyeDist = min( fEyeDist1, fEyeDist2 );\n        \n    vHeadDist.x = max( vHeadDist.x, -(fEyeDist - 0.2) );\n    \n    \n    \/\/vCharacterDist = BodyCombine3( vCharacterDist, vHeadDist );\n    result = Scene_Union( result, SceneResult( vHeadDist.x, MAT_HEAD, vHeadDist.yzz ) );    \n    \n    \n    \n    result = Scene_Union( result, SceneResult( fEyeDist, MAT_EYE, g_scene.charDef.vCol ) );    \n        \n    result = Scene_Union( result, SceneResult( vCharacterDist.x, MAT_CHARACTER, vCharacterDist.yzz ) );    \n\n         \n    return result;\n}\n\n\nSceneResult Armor_GetDistance( vec3 vPos )\n{\n    vPos.x = abs(vPos.x);\n\n    vPos.y += 1.;\n    \n    float fScale = 1.4;\n    vPos \/= fScale;\n    \n    float fDist1 = Segment( vPos, vec3(0,10,2), vec3(6, 9, 0), 4., 4. );\n    float fDist2 = Segment( vPos, vec3(0,10,0), vec3(0, 5, 0), 5., 6. );\n    float fDist = SmoothMin( fDist1, fDist2, 1.5 );\n\n    float fDistHole1 = Segment( vPos, vec3(0,12,-1), vec3(0, -2, -0.5), 3.5, 4.5 );    \n    float fDistHole2 = Segment( vPos, vec3(0,10,2), vec3(8, 8, -1), 3.0, 3.0 );\n    float fDistHole = SmoothMin( fDistHole1, fDistHole2, 1.5 );\n\n    SceneResult result = SceneResult( fDist, MAT_WHITE, vec3(0.0) );\n        \n    result = Scene_Subtract( result, SceneResult( fDistHole, MAT_GREY, vec3(0.0) ));\n    \n    result.fDist *= fScale;\n    \n\n    return result;\n}\n\n\nSceneResult Scene_GetDistance( const vec3 vPos )\n{\n    SceneResult result = SceneResult( kMaxTraceDist, MAT_BG, vec3(0.0) );\n        \n\tif ( g_scene.bCharacter )\n    {\n\t    result = Scene_Union( result, Character_GetDistance( vPos ) );\n    }\n\n    {\n\/*        float fDist = Segment( vPos, vec3(-10,10,0), vec3(13, 10, 0), 1., 1. );\n        result = Scene_Union( result, SceneResult( fDist, MAT_SHOTGUN, g_scene.charDef.vCol ) );    \n\n        float fDist2 = Segment( vPos, vec3(-12,6,0), vec3(-4, 10, 0), 2., 1. );\n        result = Scene_Union( result, SceneResult( fDist2, MAT_WOOD, g_scene.charDef.vCol ) );    *\/\n        \n        vec3 vStart = g_scene.vWeaponStart;\n        vec3 vDir = g_scene.vWeaponDir;\n        float fDist = Segment( vPos, vStart, vStart + vDir * 23.0, 1., 1. );\n        result = Scene_Union( result, SceneResult( fDist, MAT_SHOTGUN, g_scene.charDef.vCol ) );    \n\n        float fDist2 = Segment( vPos, vStart + vDir * -2. + vec3(0,-4,0), vStart + vDir * 6., 2., 1. );\n        result = Scene_Union( result, SceneResult( fDist2, MAT_WOOD, g_scene.charDef.vCol ) );\n    }\n    \n    if ( g_scene.bArmor )\n    {        \n\t    result = Scene_Union( result, Armor_GetDistance( vPos ) );\n    }\n    \n    return result;\n}\n\n\n\n\nvec4 Raymarch_Sprite( vec2 fragCoord, vec4 vSpriteInfo )\n{\n    vec4 vResult = vec4( 0 );\n    \n    vec2 vSpritePos = fragCoord - vSpriteInfo.xy;\n    float fSpriteX = vSpritePos.x - vSpriteInfo.z * 0.5;\n    \n    float fRotation = g_scene.fCameraRotation;\n    \n    \/\/fRotation += iTime;\n    \n    vec3 vCameraPos;\n    vCameraPos.x = cos(fRotation) * fSpriteX;\n    vCameraPos.y = vSpritePos.y;\n    vCameraPos.z = sin(fRotation) * fSpriteX;\n    \n    vec3 vCameraDir = vec3(-sin(fRotation), 0, cos(fRotation));\n    \n    vCameraPos -= vCameraDir * 200.0;\n\n\tSceneResult sceneResult = Scene_Trace( vCameraPos, vCameraDir, 1000.0 );\n    \n    if ( sceneResult.fDist > 400.0 )\n    {\n        return vResult;\n    }\n\n    vec3 vHitPos = vCameraPos + vCameraDir * sceneResult.fDist;\n    \n    vec3 vNormal = Scene_GetNormal( vHitPos );\n    \n    float fShade = max( 0.0, dot( vNormal, g_scene.vLightDir ) );\n    \n    float fSpecIntensity = 1.0;\n    \n    float fFBM1 = fbm( sceneResult.vUVW.xy * 30.0 * vec2(1.0, 0.4), 0.2 );    \n    float fFBM2 = fbm( sceneResult.vUVW.xy * 30.0 * vec2(1.0, 0.4) + 5.0, 0.5 );\n    vec3 vDiffuseCol = vec3(1.);\n    if ( sceneResult.fObjectId == MAT_CHARACTER )\n    {\n        float fUniformBlend = smoothstep( 0.5, 0.6, fFBM1 );\n        \n        vDiffuseCol = mix( g_scene.charDef.vUniformColor0, \n                          g_scene.charDef.vUniformColor1, \n                          fUniformBlend );\n        \n        vDiffuseCol = mix( vDiffuseCol, g_scene.charDef.vSkinColor, step(2.2,sceneResult.vUVW.x) );\n\n        float fBootBlend = step(sceneResult.vUVW.x, .4);\n        \n        fBootBlend = max( fBootBlend, step( abs(2.5 - sceneResult.vUVW.x), 0.2 ) ); \/\/ arm thing\n        \n        vDiffuseCol = mix( vDiffuseCol, g_scene.charDef.vBootsColor, fBootBlend );\n                \n        float fGoreBlend = smoothstep( 0.6, 0.7, fFBM2 );\n        fGoreBlend = max( fGoreBlend, step(2.9,sceneResult.vUVW.x) ); \/\/ bloody hands\n        \n        vDiffuseCol = mix( vDiffuseCol, \n                          vec3(1,0,0), \n                          fGoreBlend );\n        \n        \/\/vDiffuseCol = fract(sceneResult.vUVW);\/\/g_scene.charDef.vCol;\n        \/\/vDiffuseCol = sceneResult.vUVW.xxx \/ 5.0;\/\/g_scene.charDef.vCol;\n    }\n    else if ( sceneResult.fObjectId == MAT_SHOTGUN )\n    {\n        vDiffuseCol = vec3( 0.2 );\n    }\n    else if ( sceneResult.fObjectId == MAT_WOOD )\n    {\n        vDiffuseCol = vec3( 0.4, 0.2, .1 );\n    }\n    else if ( sceneResult.fObjectId == MAT_HEAD )\n    {\n        vDiffuseCol = g_scene.charDef.vSkinColor;\n        float fHairBlend = step( sceneResult.vUVW.x + fFBM1 * 0.5, 0.1 );\n        vDiffuseCol = mix( vDiffuseCol, g_scene.charDef.vHairColor, fHairBlend );\n    }\n    else if ( sceneResult.fObjectId == MAT_EYE )\n    {\n        vDiffuseCol = g_scene.charDef.vEyeColor;\n    }\n    else if ( sceneResult.fObjectId == MAT_GREY )\n    {\n        vDiffuseCol = vec3( 0.2 );\n        fSpecIntensity = 0.1;\n    }\n    \n    vec3 vDiffuseLight = g_scene.vAmbientLight + fShade * g_scene.vLightColor;\n    vResult.rgb = vDiffuseCol * vDiffuseLight;\n    \n    vec3 vRefl = reflect( vec3(0, 0, 1), vNormal );\n    float fDot = max(0.0, dot( vRefl, g_scene.vLightDir )) * fShade;\n    float fSpec = pow( fDot, 5.0 );\n    vResult.rgb += fSpec * fSpecIntensity;\n    \n    vResult.rgb = 1.0 - exp2( vResult.rgb * -2.0 );\n    vResult.rgb = pow( vResult.rgb, vec3(1.0 \/ 1.5) );\n    \n    vResult.a = 1.0;\n    \n    return vResult;\n}\n\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nbool MaskBarrel(vec2 vTexCoord)\n{\n\tvec2 vSize = vec2(23.0, 32.0);\n\t\n\tvTexCoord = floor(vTexCoord);\n\t\n\t\/\/ remove corner pixels\n\tvec2 vWrapCoord = fract((vTexCoord + vec2(2.0, 1.0) ) \/ vSize) * vSize;\n\t\n\treturn ( (vWrapCoord.x >= 4.0) || (vWrapCoord.y >= 2.0) );\n}\n\nvec4 TexBar1A( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n    if ( any( lessThan( vTexCoord, vec2(0) ) ) ) return vec4(0);\n    if ( any( greaterThan( vTexCoord, vec2(22,32) ) ) ) return vec4(0);\n    vTexCoord.y = 31. - vTexCoord.y;\n\tvec3 col = vec3(123.0, 127.0, 99.0) \/ 255.0;\n\t\n\tfloat fBrownStreakBlend = smoothstep( 2.0, 1.0, abs(vTexCoord.x - 3.5));\n\tcol = mix(col, vec3(0.724, 0.736, 0.438), fBrownStreakBlend);\n\t\n\tif( (vTexCoord.y == 1.0) && (vTexCoord.x > 3.0) && (vTexCoord.x < 18.0) )\n\t{\n\t\tcol = col * clamp(((vTexCoord.x \/ 18.0)), 0.0, 1.0);\t\t\n\t}\n\telse\n\t{\n\t\tcol = col * clamp((1.0 - (vTexCoord.x \/ 18.0)), 0.0, 1.0);\t\t\n\t}\n\t\n\tfloat fNukageBlend = 0.0;\n\tif( (vTexCoord.y == 1.0) && (vTexCoord.x > 8.0) && (vTexCoord.x < 14.0) )\n\t{\n\t\tfNukageBlend = 1.0;\n\t}\t\n\tif( (vTexCoord.y == 2.0) && (vTexCoord.x > 2.0) && (vTexCoord.x < 20.0) )\n\t{\n\t\tfNukageBlend = 1.0;\n\t}\t\n\tcol = mix(col, vec3(0.172, 0.560, 0.144) * fRandom, fNukageBlend);\n\t\n\t\n\tif(vTexCoord.x < 1.0)\n\t{\n\t\tcol += 0.1;\n\t}\n\t\n\tfloat fBlend = clamp(((vTexCoord.x - 20.0) \/ 3.0), 0.0, 1.0);\n\tcol += fBlend * 0.2;\n\t\n\tfloat fBumpY = 8.0;\n\tif(vTexCoord.y > 14.0) fBumpY += 9.0;\n\tif(vTexCoord.y > 23.0) fBumpY += 8.0;\n\n\tvec4 vBump = SmoothBump( vTexCoord, vec2(2.0, fBumpY), vec2(23.0 - 2.0, fBumpY), normalize(vec2(-0.2, 1.0)), 1.25 );\t\n\tcol += vBump.x * 0.2;\n\n\t\/\/ rim highlights\n\t{\n\t\tvec2 vOffset = (vTexCoord - vec2(17.0, 0.0)) \/ vec2(8.0, 2.0);\n\t\tcol += clamp(1.0 - dot(vOffset, vOffset), 0.0, 1.0) * 0.2;\n\t}\t\n\t{\n\t\tvec2 vOffset = (vTexCoord - vec2(20.0, 1.0)) \/ vec2(4.0, 1.0);\n\t\tcol += clamp(1.0 - dot(vOffset, vOffset), 0.0, 1.0) * 0.2;\n\t}\t\n\t{\n\t\tvec2 vOffset = (vTexCoord - vec2(3.0, 2.0)) \/ vec2(4.0, 2.0);\n\t\tcol += clamp(1.0 - dot(vOffset, vOffset), 0.0, 1.0) * 0.2;\n\t}\t\n\t\n\tcol *= 0.5 + fRandom * 0.5;\n\t\n    vec4 vResult;\n    vResult.rgb = col;\n    vResult.a = MaskBarrel( vTexCoord ) ? 1. : 0.;\n    \n\treturn vResult;\n}\n\n\nvec4 CosApprox( vec4 x )\n{\n\tx = abs(fract(x * (0.5))*2.0 - 1.0);\n\tvec4 x2 = x*x;\n\treturn( ( x2 * 3.0) - ( 2.0 * x2*x) );\n}\n\nbool MaskCorpseSprite(vec2 vTexCoord)\n{\n\t\/\/vTexCoord = floor(vTexCoord);\n    \n    vec2 vUV = vTexCoord.xy \/ vec2(48.0, 22.0);\n    vec2 vOffset = vUV;\n    vOffset = vOffset * 2.0 -vec2(1.0, 0.6);\n    float fDist = dot(vOffset, vOffset);\n    fDist += dot(CosApprox(vTexCoord.xyxy * vec4(0.55, 0.41, 0.25, 0.1)), vec4(0.2 * -vOffset.y));\n\treturn fDist < 0.4;\n}\n\nvec4 TexPlayW( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n    vec3 col = mix(vec3(190.0, 10.0, 10.0), vec3(50, 16.0, 16.0 ), fRandom * vTexCoord.y\/18.0) \/ 255.0;\n    \n    vec4 vResult = vec4(0);\n    vResult.rgb = col;\n    vResult.a = MaskCorpseSprite( vTexCoord ) ? 1. : 0.;\n    \n\treturn vResult;\n}\n\nvec4 TexFireball( vec2 vTexCoord, float fRandom, float fHRandom, float fSize, float fType )\n{\n    float fLen = length( vTexCoord - vec2(fSize) ) \/ fSize;\n    \n    vec4 vResult = vec4(0);\n    \n    vResult.rgb = mix( vec3( 1., 0.5, 0.4), vec3(0.6, 0.2, 0.05), fLen );\/\/vec3(sin(fLen * 10.0) * 0.5 + 0.5,0,1);\n    if ( fType == 0. )\n    {\n    \tvResult.rgb += vec3( 1., 0.3, 0.1) * ( exp( fLen * -3.0)) * 3.;\n    }\n    else\n    {\n        fLen += fRandom - 0.25;\n    }\n    vResult.rgb *= fRandom * 0.5 + 0.5;\n\n    if ( fLen < 1.0 )\n    {\n        vResult.a = 1.;\n    }\n    \n    return vResult;\n}\n\nvec4 TexHealthBonus( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n    float fLen = length( vTexCoord - vec2(8.0, 6.0) ) \/ 5.5;\n    \n    vec4 vResult = vec4(0);\n    \n    vec3 vCol = vec3(0,0,1);\n    if ( all( greaterThan( vTexCoord, vec2( 6, 13) ) ) && all( lessThan( vTexCoord, vec2(10, 16 ) ) ) )\n\t{\n        vCol = vec3(1., .5, .2) * 2.;\n\t}\n    \n    float fShade = clamp( vTexCoord.y \/ 10.0, 0.0, 1.0);\n    vResult.rgb = vCol * fShade * fRandom;\n    if ( fLen < 1.0 )\n    {\n        vResult.a = 1.;\n    }\n    \n    if ( all( greaterThan( vTexCoord, vec2( 6, 4) ) ) && all( lessThan( vTexCoord, vec2(10, 16 ) ) ) )\n\t{\n        vResult.a = 1.;\n\t}\n    \n    \n    return vResult;\n}\n    \nvec4 TexArmorBonus( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n    vec2 vXY = vTexCoord - vec2(7.5,7.0);\n\n    vec4 vResult = vec4(0);\n    \n    float fRad = 8.0;\n    if ( vXY.y < 0.0 )\n    {\n        vXY.y += 1.0;\n        vXY.x *= 0.9;\n    }\n\n    vec3 vCol = mix( vec3(75), vec3(95, 67, 35), step(0.55, fRandom)) \/ 255.;\n    \n    \n    float fLen = length( vXY );\n    \n    if ( fLen < fRad )\n    {\n    \tvec3 vNormal = normalize( vec3( vXY, sqrt( fRad * fRad - fLen * fLen) ) );\n        vec3 vLight = normalize( vec3( 0.4, 0.3, 3.0 ) );\n        \n                \n        float fShade = max(0.0, dot( vLight, vNormal ) );\n        \n        float fHighlight = pow(fShade, 50.0) * 0.2;\n        \n        fShade = fShade * 0.8 + 0.2;\n        \n        \n        vResult = vec4( vCol * fShade + fHighlight, 1 );\n    }\n    \n    if ( (vTexCoord.x == 6. || vTexCoord.x == 9.) && ( vTexCoord.y >= 0. && vTexCoord.y < 5.) )\n    {\n        vResult.rgb *= 0.5;\n    }\n    else\n    if ( (vTexCoord.x >= 6. && vTexCoord.x <= 9.) && vTexCoord.y == 0. )\n    {\n        vResult.rgb *= 0.5;\n    }\n    \n    float fMirrorX = 7.5 - abs( vTexCoord.x - 7.5 );\n    vec2 vMirror = vec2( fMirrorX, vTexCoord.y );\n    \n    bool bEye = false;\n    if( all( greaterThanEqual( vMirror, vec2(2,4) ) ) &&\n        all( lessThanEqual( vMirror, vec2(5,5) ) ))\n    {\n        bEye = true; \n    }\n\n    if( all( greaterThanEqual( vMirror, vec2(4,2) ) ) &&\n        all( lessThanEqual( vMirror, vec2(5,3) ) ))\n    {\n        bEye = true; \n    }\n    \n    if( bEye )\n\t{\n        float fEyeShade = clamp( 1.0 - (10. -vMirror.x - vMirror.y) \/ 8.0, 0.0, 1.0);\n\t\tvResult.rgb = fEyeShade * vec3(83,175,71) \/ 255.;\n\t}\n\n    if( all( greaterThanEqual( vMirror, vec2(4,0) ) ) &&\n        all( lessThanEqual( vMirror, vec2(5,1) ) ))\n    {\n        vResult = vec4(0.0);\n    }\n    \n    \n    \/*\n\n    vec3 vCol = vec3(0,1,.5);\n    if ( all( greaterThan( vTexCoord, vec2(4, 6) ) ) && all( lessThan( vTexCoord, vec2(8, 9 ) ) ) )\n\t{\n        vCol *= 0.5;\n\t}\n    if ( all( greaterThan( vTexCoord, vec2(9, 6) ) ) && all( lessThan( vTexCoord, vec2(13, 9 ) ) ) )\n\t{\n        vCol *= 0.5;\n\t}\n    \n    float fShade = clamp( vTexCoord.y \/ 10.0, 0.0, 1.0);\n    vResult.rgb = vCol * fShade * fRandom;\n    if ( fLen < 1.0 )\n    {\n        vResult.a = 1.;\n    }\n    \n    if ( length( vTexCoord ) < 5.5 )\n    {\n        vResult.a = 0.;\n    }\n    if ( length( vTexCoord - vec2(16,0)) < 5.5 )\n    {\n        vResult.a = 0.;\n    }\n\t*\/\n    \n    return vResult;\n}\n\nvec4 TexWallImpact( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n    vec4 vResult = vec4(0);\n    \n    float fLen = length( vTexCoord - vec2(3.0) ) \/ 3.0;\n    fLen = sqrt(fLen);\n    fLen = max( 0.0, fLen * 1.3 - 0.3 );\n    vResult.rgb = mix( vec3(1.,1.,.8), vec3(0.4,0.2,0.0), fLen * fLen);\n    vResult.rgb *= 1.5;\n    \n\n    vResult.a = step(fLen, 1.0);\n    \n    return vResult;  \n}\n\nvec4 TexBulletSmokeImpact( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n    vec4 vResult = vec4(0);\n    \n    vResult.rgb = vec3(1.0,1.0,1.0) * fRandom;\n    \n    float fLen = length( (vTexCoord - vec2(4.0, 8.0)) \/ vec2(6.0, 10.0) ) ;\n\n    fRandom = 1.0 - fRandom;\n    \n    vResult.a = step(fLen + fRandom * fRandom * 2.0, 1.0);\n    \n    return vResult;    \n}\n\nvec4 TexFleshImpact( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n    vec4 vResult = vec4(0);\n    \n    vResult.rgb = vec3(1.0,0.0,0.0) * fRandom;\n    \n    float fLen = length( vTexCoord - vec2(4.0) ) \/ 4.2;\n\n    vResult.a = step(fLen + fRandom * fRandom * 1.5, 1.0);\n    \n    return vResult;  \n}\n    \nvec4 TexEnemyPlaceholder( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n    vec4 vResult = vec4(0);\n    \n    vResult.rgb = vec3(0,0.2,0);\n    if ( (length( vTexCoord - vec2(16.0, 50.) ) < 5.0) )\n    {\n        vResult.a = 1.;\n    }\n    if ( (length( vTexCoord - vec2(16.0, 30.) ) < 12.0) )\n    {\n        vResult.a = 1.;\n    }\n    \n    if ( (length( vTexCoord - vec2(9.0, 5.) ) < 5.0) )\n    {\n        vResult.a = 1.;\n    }\n\n    if ( (length( vTexCoord - vec2(31. -9.0, 5.) ) < 5.0) )\n    {\n        vResult.a = 1.;\n    }\n\n    if ( (length( vTexCoord - vec2(9.0, 15.) ) < 5.0) )\n    {\n        vResult.a = 1.;\n    }\n\n    if ( (length( vTexCoord - vec2(31. -9.0, 15.) ) < 5.0) )\n    {\n        vResult.a = 1.;\n    }\n        \n    return vResult;\n}\n\nvec4 TexShotgunItem( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n    vec4 vResult = vec4(1);\n    \n    vResult.rgb = vec3(0.3) * fRandom;\n \n    return vResult;    \n}\n\nvec4 TexPlaceholder( vec2 vTexCoord, float fRandom, float fHRandom, vec3 vCol )\n{\n    vec4 vResult = vec4(1);\n    \n    vResult.rgb = vCol * fRandom;\n \n    return vResult;\n}\n\n\nbool RedCross( vec2 vTexCoord )\n{\n    if ( all( greaterThan( vTexCoord, vec2( -4, -2) ) ) && all( lessThan( vTexCoord, vec2(3, 1 ) ) ) )\n\t{\n        return true;\n\t}\n\n    if ( all( greaterThan( vTexCoord, vec2( -2, -4) ) ) && all( lessThan( vTexCoord, vec2(1, 3 ) ) ) )\n\t{\n        return true;\n\t}\n    \n    return false;\n}\n\nfloat Flap( vec2 vTexCoord )\n{\n    float f1 = vTexCoord.y - 4.0;\n    float f2 = vTexCoord.y + vTexCoord.x - 9.0;\n\n    float fFlap = min(f1,f2);\n    \n    return fFlap \/ 3.0;\n    \n}\n\nvec4 TexMedikit( vec2 vTexCoord, float fRandom, float fHRandom, float fEdge )\n{\n    vec4 vResult = vec4(1);\n    \n    float xMirror = 13.5 - abs(vTexCoord.x - 13.5);\n    \n    if ( xMirror - vTexCoord.y + 15.0 - fEdge < 0.0 )\n    {\n        return vec4(0.0);\n    }\n    \n    xMirror -= fEdge * .5;\n        \n    vResult.rgb = vec3(111)\/255.;\n \n    if ( vTexCoord.y > 15. )\n    {\n\t\tvResult.rgb = vec3(139)\/255.;\n    }\n    else\n    if ( vTexCoord.y > 14. )\n    {\n\t\tvResult.rgb = vec3(167)\/255.;\n    }        \n    \n    float fFlap = Flap( vec2( xMirror, vTexCoord.y ) );\n    \n    \/\/ Strap\n    if ( xMirror >= 6. && xMirror <= 8. )\n    {\n        if ( vTexCoord.y < 6. )\n        {\n            if ( fFlap >= 1.0 )\n            {\n\t        \tvResult.rgb = vec3(151) \/ 255.;\n            }\n            else\n            {\n\t        \tvResult.rgb = vec3(39) \/ 255.;\n            }\n        }\n    }\n        \n    if ( fFlap > 0.0 && fFlap < 1.0 )\n    {\n        vResult.rgb *= 1.0 - fFlap;\n    }\n\n    if ( vTexCoord.y < 1. )\n    {\n        vResult.rgb *= 0.75;\n    }\n\n    \n    vResult.rgb *= (fRandom * 0.2 + 0.8);\n\n    vec2 vCrossPos = vTexCoord - vec2(14, 11 );\n    if ( RedCross( vCrossPos ) )\n\t{\n        float fDist = 1.0 - length( vCrossPos ) \/ 4.5;\n        vResult.rgb = fDist * vec3(155,0,0)\/255.;\n        \n\t}\n\n    \/*if ( RedCross( vCrossPos + vec2(1,-1) ) )\n    {\n        vResult.rgb *= 0.9;        \n    }\n    \n    if ( RedCross( vCrossPos - vec2(1,-1) ) )\n    {\n\t\t\tvResult.rgb *= 1.1;        \n    }*\/\n                        \n    return vResult;\n}\n\nvec4 TexFloorLamp( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n    vec4 vResult = vec4(0);\n\n    float y = floor( vTexCoord.y );\n    float xMirror = floor( abs(vTexCoord.x - 11.) );\n\n    float fWidth = 6.0;;\n    float fSpread = 1.0 \/ 4.0;\n    float fLightPos = 10.0;\n    \n    if ( y == 47.0 )\n    {\n        fWidth = 3.0;\n    }\n    else\n    if ( y == 46.0 )\n    {\n        fWidth = 5.0;\n    }\n    else\n    if ( y == 7.0 || y == 10.0 || y == 13.0 )\n    {\n        fWidth = 7.0;\n        fSpread = 1.0 \/ 8.;\n        fLightPos = 8.0;\n    }\n    else\n    if ( y == 2.0 || y == 3.0 )\n    {\n        fWidth = 11.0;\n    }\n    else\n    if ( y == 1.0 )\n    {\n        fWidth = 9.0;\n    }\n    else\n    if ( y == 4.0 )\n    {\n        fWidth = 10.0;\n    }\n    if ( y == 5.0 )\n    {\n        fWidth = 8.0;\n    }\n    \n    if ( y <= 5.0 )\n    {\n        fSpread = 1.0 \/ 20.;\n        fLightPos = y * .5 + 5.;\n    }\n    \n    if ( xMirror < fWidth )\n    {\n        if ( y >= 41. && y <= 44. )\n        {\n            vec2 delta = vTexCoord - vec2(11, 42.5);\n            float d = dot( delta, delta );\n\t        \n            float fShade1 = 0.8 - (xMirror \/ 6.0);\n            \n            float fShade2 = 1.0 - d \/ 8.0;\n            float fShade = max(0.0, max( fShade1, fShade2 ) );\n            \n            vec3 vCol = vec3(215, 187, 67)\/255.;\n            vCol += fShade * vec3(1, 0.75, 0.5);\n    \t    vResult = vec4( vCol,1.0);\n        }\n        else\n        {\n\t        float fShade= max(0.0, 1.0 - abs(vTexCoord.x - fLightPos ) * fSpread ) * 0.25;\n    \t    vResult = vec4(vec3(fShade),1.0);\n        }\n    }\n    \n    return vResult;\n}\n\nvec3 Project( vec3 a, vec3 b )\n{\n\treturn a - b * dot(a, b);\n}\n\/*\nvoid TraceSlab( const in vec3 vRayOrigin, const in vec3 vRayDir, const in vec3 vSlabOrigin, const in vec3 vSlabDir, const in float fThickness, out float fNear, out float fFar, inout vec3 vNormal )\n{\n    \n    float t0 = projOffset0 \/ projDir;\n    float t1 = projOffset1 \/ projDir;\n    \n    \n    \n    if ( f0 > \n}\n*\/\nfloat TraceCylinder( const in vec3 vRayOrigin, const in vec3 vRayDir, const in vec3 vCylinderOrigin, const in vec3 vCylinderDir, const in float fLength, const in float fCylinderRadius, inout vec3 vNormal )\n{\t\n\t\n\tvec3 vOffset = vCylinderOrigin - vRayOrigin;\n\t\n\tvec3 vProjOffset = Project(vOffset, vCylinderDir);\n\tvec3 vProjDir = Project(vRayDir, vCylinderDir);\n\tfloat fProjScale = length(vProjDir);\n\tvProjDir \/= fProjScale;\n\t\n\t\/\/ intersect circle in projected space\n\t\n\tfloat fTClosest = dot(vProjOffset, vProjDir);\n\t\n\tvec3 vClosest = vProjDir * fTClosest;\n\tfloat fDistClosest = length(vClosest - vProjOffset);\n\tif(fDistClosest < fCylinderRadius)\n\t{\t\t\n\t\tfloat fHalfChordLength = sqrt(fCylinderRadius * fCylinderRadius - fDistClosest * fDistClosest);\n\t\tfloat fTIntersectMin = clamp((fTClosest - fHalfChordLength) \/ fProjScale, 0.0, 100000.0);\n\t\tfloat fTIntersectMax = (fTClosest + fHalfChordLength) \/ fProjScale;\t\n\t\t\n\t\tif(fTIntersectMax > fTIntersectMin)\n\t\t{\t\n            vec3 vHitPos = vRayOrigin + vRayDir * fTIntersectMin;\n            float hitU = dot( vHitPos - vCylinderOrigin, vCylinderDir );\n            if ( hitU >= 0.0 && hitU <= fLength )\n            {\n\t\t\t\tvNormal = normalize(vProjDir * (fTClosest - fHalfChordLength) - vProjOffset );\n\t\t\t\treturn fTIntersectMin;\n            }\n\t\t}\t\t\n\t}\n    \n    \/\/ end cap\n\n    vec3 vEndPos = vCylinderOrigin;\n\tvNormal = vCylinderDir;\n    \n    if ( dot( vRayDir, vCylinderDir) < 0.0 )\n    {\n        vEndPos += vCylinderDir * fLength;\n        vNormal = -vNormal;\n    }\n    \n    vec3 vEndOffset = vEndPos - vRayOrigin;\n    float endDot = dot( vEndOffset , vCylinderDir );\n    float dirDot = dot( vRayDir, vCylinderDir );\n    \n    float capT = endDot \/ dirDot;\n    \n    if ( capT > 0.0 )\n    {\n        vec3 vCapPos = vRayOrigin + vRayDir * capT;\n        \n        if ( length( vEndPos - vCapPos ) < fCylinderRadius )\n        {\n            return capT;\n        }\n    }\n    \n    \n    return 100000.0;\n}\n\nvec4 TexTallTechnoPillar( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n    vec3 vRayOrigin = vec3(0.0, 64.0, -300.0);\n    vec3 vRayTarget = vec3( vTexCoord.x - 38. * .5, vTexCoord.y, 0.0);\n    vec3 vRayDir = normalize( vRayTarget - vRayOrigin );\n    \n    vec3 vNormal;\n    \n    float t = TraceCylinder( vRayOrigin, vRayDir, vec3(0, 3, 0), vec3(0,1,0), 127.0 - 6., 12.0, vNormal );\n\n    vec3 vNormal2;\n    float t2; \n    t2 = TraceCylinder( vRayOrigin, vRayDir, vec3(0, 3, 0), vec3(0,1,0), 6.0, 16.0, vNormal2 );\n    if ( t2 < t )\n    {\n        t = t2;\n        vNormal = vNormal2;\n    }\n\n    t2 = TraceCylinder( vRayOrigin, vRayDir, vec3(0, 127. - 3. - 6., 0), vec3(0,1,0), 6.0, 16.0, vNormal2 );\n    if ( t2 < t )\n    {\n        t = t2;\n        vNormal = vNormal2;\n    }\n\n\n    t2 = TraceCylinder( vRayOrigin, vRayDir, vec3(0, 32, 0), vec3(0,1,0), 2.0, 16.0, vNormal2 );\n    if ( t2 < t )\n    {\n        t = t2;\n        vNormal = vNormal2;\n    }\n    \n    t2 = TraceCylinder( vRayOrigin, vRayDir, vec3(0, 36, 0), vec3(0,1,0), 2.0, 16.0, vNormal2 );\n    if ( t2 < t )\n    {\n        t = t2;\n        vNormal = vNormal2;\n    }\n    t2 = TraceCylinder( vRayOrigin, vRayDir, vec3(0, 40, 0), vec3(0,1,0), 2.0, 16.0, vNormal2 );\n    if ( t2 < t )\n    {\n        t = t2;\n        vNormal = vNormal2;\n    }\n    \n    \n    \/\/vec3 vNormal1;\n    if ( t > 5000. )\n    {\n        return vec4(0.);\n    }\n    \n    vec3 vLight = normalize( vec3(-1., -0.5, -2 ) );\n    \n    float fShade = max(0.0, dot( vNormal, vLight ));\n    \n    vec3 vCol = vec3(0.2) + fRandom * 0.1;\n    \n    vec3 vPos = vRayOrigin + vRayDir * t;\n    \n    if ( vPos.y > 43. && vPos.y < 118. )\n    {\n        float f = fRandom \/ .75;\n        \/\/f *= 0.75 + fHRandom * 0.25;\n        vCol = vec3( pow( f, 5.0) );\n    }\n    \n    vCol *= fShade;\n    return vec4(vCol,1);\n    \n    \/\/ float fShade = fRandom - fHRandom * 0.5;\n    \/\/return vec4(fShade,fShade, fShade, 1);\n}\n\nvoid AddGlow( inout vec3 vResult, vec2 vSpritePixel, vec2 vGlowPos, vec3 vCol, float f )\n{\n    float fLen = length( vSpritePixel - vGlowPos );\n    \n    vResult += exp2(-fLen * f) * vCol;\n}\n\nvec4 MuzzleFlash( vec2 vUV, vec2 vPos, vec2 vSize )\n{\n    vec4 vResult = vec4( 0.0 );\n    vec2 vLocalPos = vUV - vPos;\n    vLocalPos = vLocalPos \/ vSize;\n    float fDist = length( vLocalPos );\n    fDist += abs(vLocalPos.x) + abs(vLocalPos.y);\n\n    float fFactor = fDist * 5.0 + fbm( vLocalPos * 100., 0.8);\n\n    \/\/float fAmount = exp2( * fFactor );\n\n    if ( fFactor < 3.0)\n    {\n        fFactor = 1.0 - fFactor \/ 3.0;\n\n        fFactor = pow( 0.5 + fFactor, 5.0 );\n\n        vResult.rgb = vec3( fFactor, pow(fFactor, 2.0) * .4, pow(fFactor, 3.0) * .2) * 5.0;\n        vResult.a = 1.0;\n\n    }\n    \n    return vResult;\n}\n\n\nvec4 TexBarExpl( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n    vec4 vResult = TexBar1A( vTexCoord - vec2(4,0), fRandom, fHRandom );\n    \n    vec4 vExplode = MuzzleFlash( vTexCoord, vec2(16,16), vec2(60, 60));\n    \n    if ( vExplode.a > 0.0 )\n    {\n        vResult.rgb += vExplode.rgb * 0.2;\n        vResult.a = 1.0;\n        return vResult;\n    }\n    \n    \/\/AddGlow( vResult.rgb, vTexCoord, vec2(13., 20.0), vec3(1,.9, .5) * 2., 0.15 );\n    \/\/vResult *= TexFireball( vTexCoord, fRandom, fHRandom );\n\treturn vResult;\n}\n\nvec4 TexBarExpl2( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n    vec4 vResult = MuzzleFlash( vTexCoord.yx, vec2(24,19), vec2(90, 82));    \n    \n\treturn vResult;\n}\n\n\/\/\/\/\/\/\/\/\/\n\nvec2 SpritePixel( vec2 sheetPixel, vec4 vSpriteInfo )\n{\n    return floor(sheetPixel - vSpriteInfo.xy);\n}\n\nbool IsInSprite( vec2 sheetPixel, vec4 vSpriteInfo )\n{\n    return all( greaterThanEqual(sheetPixel, vSpriteInfo.xy) ) && all( lessThan(sheetPixel, vSpriteInfo.xy + vSpriteInfo.zw) );\n}\n\nbool SpriteSelectIterate( vec4 vSpriteInfo, vec2 sheetPixel, inout vec4 vOutSpriteInfo, inout float fOutSpriteIndex, inout float fTestIndex )\n{\n    bool isInSprite = IsInSprite( sheetPixel, vSpriteInfo );\n    \n    if ( isInSprite )\n    {\n        vOutSpriteInfo = vSpriteInfo;\n        fOutSpriteIndex = fTestIndex;\n    }\n    \n    fTestIndex++;\n    return isInSprite;\n}\n\nbool SpriteProcessIterate( inout float fTestIndex, float fSpriteIndex )\n{\n    bool bResult = false;\n    if ( fSpriteIndex == fTestIndex )\n    {\n        bResult = true;\n    }\n    \n    fTestIndex++;\n    \n    return bResult;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Sprite Crop Sheet Info\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define SPR_RIGHT(V) vec2((V.x + V.z), V.y)\n#define SPR_ABOVE(V) vec2(V.x, (V.y + V.w))\n\nconst vec4 kSpriteNone\t\t\t\t= vec4( 0 );\n\nconst vec4 kSpriteBarrel\t\t\t= vec4(\tSPR_RIGHT(kSpriteNone),\t\t\t\t\t23,32);\nconst vec4 kSpriteBarrelExpl\t\t= vec4(\tSPR_RIGHT(kSpriteBarrel),\t\t\t\t32,32);\n\nconst vec4 kSpriteFireball\t\t\t= vec4(\tSPR_RIGHT(kSpriteBarrelExpl),\t\t\t20,20);\nconst vec4 kSpriteFireball2\t\t\t= vec4(\tSPR_RIGHT(kSpriteFireball),\t\t\t\t24,24);\n\nconst vec4 kSpriteHealthBonus\t\t= vec4(\tSPR_RIGHT(kSpriteFireball2),\t\t\t16,16);\nconst vec4 kSpriteArmorBonus\t\t= vec4(\tSPR_ABOVE(kSpriteHealthBonus),\t\t\t16,15);\nconst vec4 kSpriteMedikit\t\t\t= vec4(\tSPR_RIGHT(kSpriteHealthBonus),\t\t\t28,19);\nconst vec4 kSpriteStimpack\t\t\t= vec4(\tSPR_RIGHT(kSpriteMedikit),\t\t\t\t16,19);\nconst vec4 kSpriteBlueArmor\t\t\t= vec4(\tSPR_RIGHT(kSpriteStimpack),\t\t\t\t32,24);\nconst vec4 kSpriteGreenArmor\t\t= vec4(\tSPR_RIGHT(kSpriteBlueArmor),\t\t\t32,24);\nconst vec4 kSpriteShotgun\t\t\t= vec4(\tSPR_RIGHT(kSpriteGreenArmor),\t\t\t32,16);\n\nconst vec4 kSpriteWallImpact1\t\t= vec4(\tSPR_RIGHT(kSpriteShotgun),\t\t\t\t6,6);\nconst vec4 kSpriteWallSmokeImpact1\t= vec4(\tSPR_RIGHT(kSpriteWallImpact1),\t\t\t8,16);\nconst vec4 kSpriteFleshImpact1\t\t= vec4(\tSPR_RIGHT(kSpriteWallSmokeImpact1),\t\t8,8);\n\nconst vec4 kSpriteBloodyMess\t\t= vec4(\tSPR_RIGHT(kSpriteFleshImpact1) + vec2(0,16),\t\t42,16);\nconst vec4 kSpriteDeadTrooper \t\t= vec4(\tSPR_RIGHT(kSpriteBloodyMess),\t\t\t42,16);\nconst vec4 kSpriteDeadSergeant \t\t= vec4(\tSPR_RIGHT(kSpriteDeadTrooper),\t\t\t42,16);\nconst vec4 kSpriteDeadImp \t\t\t= vec4(\tSPR_RIGHT(kSpriteDeadSergeant),\t\t\t42,16);\n\nconst vec4 kSpriteBarrelExpl2\t\t= vec4(\t480,0,\t\t\t\t\t\t\t\t\t38,48);\n\nconst vec4 kSpriteFloorLamp\t\t\t= vec4(\t480,48,\t\t\t\t\t\t\t\t\t23,48);\nconst vec4 kSpriteTallTechnoPillar\t= vec4(\tSPR_ABOVE(kSpriteFloorLamp),\t\t\t38,128);\n\nconst vec4 kSpriteEnemyBegin = vec4(0, 32., 32, 52);\n\n\n#define SPRITE_ENEMY_ACTION_STAND \t\t0.\n#define SPRITE_ENEMY_ACTION_ATTACK\t\t1.\n#define SPRITE_ENEMY_ACTION_WALK1 \t\t2.\n#define SPRITE_ENEMY_ACTION_WALK2 \t\t3.\n#define SPRITE_ENEMY_ACTION_PAIN \t\t4.\n#define SPRITE_ENEMY_ACTION_DIE \t\t5.\n\n#define SPRITE_ENEMY_ACTION_COUNT \t\t6\n\n#define SPRITE_ENEMY_ACTION_DEAD\t\t10.\n\n#define SPRITE_ENEMY_TYPE_TROOPER \t0.\n#define SPRITE_ENEMY_TYPE_IMP \t\t1.\n#define SPRITE_ENEMY_TYPE_SERGEANT \t2.\n\n#define SPRITE_ENEMY_TYPE_COUNT     3\n\nvec4 GetEnemySprite( float fType, float fAction, float fDirection )\n{\n    vec2 vGridPos = vec2( fType + fDirection * float(SPRITE_ENEMY_TYPE_COUNT), fAction );\n    vec2 vPos = kSpriteEnemyBegin.xy +kSpriteEnemyBegin.zw * vGridPos;\n\treturn vec4( vPos, kSpriteEnemyBegin.zw );\n}\n\n\n\nbool GetEnemySpriteId( vec2 fragCoord, out float fEnemySpriteType, out float fEnemySpriteAction, out float fEnemySpriteDirection )\n{\n    vec2 vGridLocal = fragCoord - kSpriteEnemyBegin.xy;\n    vec2 vGridPos = floor( vGridLocal \/ kSpriteEnemyBegin.zw );\n    \n    fEnemySpriteType = mod( vGridPos.x, float(SPRITE_ENEMY_TYPE_COUNT) );\n    fEnemySpriteAction = vGridPos.y;\n    fEnemySpriteDirection = floor( vGridPos.x \/ float(SPRITE_ENEMY_TYPE_COUNT) );\n\n    return ( vGridPos.x >= 0. && vGridPos.y >= 0. && vGridPos.x < (float(SPRITE_ENEMY_TYPE_COUNT) * 5.0) && vGridPos.y < float(SPRITE_ENEMY_ACTION_COUNT) );        \n}\n\n\n\n\nvoid Pose_Enemy( float fEnemySpriteType, float fEnemySpriteAction, float fEnemySpriteDirection )\n{\n    bool bWeapon = false;\n    if ( fEnemySpriteType == float(SPRITE_ENEMY_TYPE_IMP))\n    {\n        CharDef_Imp( g_scene.charDef );            \n    }            \n    else\n        if ( fEnemySpriteType == float(SPRITE_ENEMY_TYPE_TROOPER))\n        {\n            CharDef_Trooper( g_scene.charDef );\n        }   \n    else\n        if ( fEnemySpriteType == float(SPRITE_ENEMY_TYPE_SERGEANT))\n        {\n            CharDef_Sergeant( g_scene.charDef );\n            bWeapon = true;\n        }                        \n\n    \/\/\/\/\/\/\n    \n    if ( fEnemySpriteAction == float(SPRITE_ENEMY_ACTION_STAND))\n    {\n        Pose_Clear( g_scene.pose );\n    }            \n    else\n        if ( fEnemySpriteAction == float(SPRITE_ENEMY_ACTION_ATTACK))\n        {\n            Pose_Attack( g_scene.pose );\n        }            \n    else\n        if ( fEnemySpriteAction == float(SPRITE_ENEMY_ACTION_WALK1))\n        {\n            Pose_Walk1( g_scene.pose );\n        }   \n    else\n        if ( fEnemySpriteAction == float(SPRITE_ENEMY_ACTION_WALK2))\n        {\n            Pose_Walk2( g_scene.pose );\n        }                        \n    else\n        if ( fEnemySpriteAction == float(SPRITE_ENEMY_ACTION_PAIN))\n        {\n            Pose_Pain( g_scene.pose );\n        }                        \n    else \n        if ( fEnemySpriteAction == float(SPRITE_ENEMY_ACTION_DIE))\n    {\n        Pose_Die( g_scene.pose );\n        bWeapon = false;        \n    }                        \n    else \n        if ( fEnemySpriteAction == float(SPRITE_ENEMY_ACTION_DEAD))\n    {\n        Pose_Dead( g_scene.pose );\n        bWeapon = false;\n    }                        \n\n                          \n    if ( bWeapon )\n    {\n    \tPose_Weapon();\n    }\n    else\n    {\n\t\tWeapon_None();\n    }    \n\n    g_scene.fCameraRotation = fEnemySpriteDirection * radians(45.0);            \n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define FONT_POS \tivec2(280,0)\n#define FONT_CHAR \tivec2(16,0)\n\nvec4 NumFont_Char( ivec2 vTexCoord, int iDigit )\n{\n \tif ( iDigit < 0 || iDigit > 10 )\n    \treturn vec4(0.0);\n    \n    \/\/vTexCoord = floor(vTexCoord * vec2(14.0, 16.0)) + 0.5 + vec2(480,96);\n    vTexCoord = vTexCoord + FONT_POS;\n    vTexCoord += FONT_CHAR * iDigit;\n    \n    float fSample_TL = texelFetch( iChannel1, (vTexCoord - ivec2(-1, 1) ), 0 ).a;\n    float fSample_TC = texelFetch( iChannel1, (vTexCoord - ivec2( 0, 1) ), 0 ).a;\n    float fSample_TR = texelFetch( iChannel1, (vTexCoord - ivec2( 1, 1) ), 0 ).a;\n    \n    float fSample_CL = texelFetch( iChannel1, (vTexCoord - ivec2(-1, 0) ), 0 ).a;\n    float fSample_CC = texelFetch( iChannel1, (vTexCoord - ivec2( 0, 0) ), 0 ).a;\n    float fSample_CR = texelFetch( iChannel1, (vTexCoord - ivec2( 1, 0) ), 0 ).a;\n    float fSample_CS = texelFetch( iChannel1, (vTexCoord - ivec2( 2, 0) ), 0 ).a;\n\n    float fSample_BL = texelFetch( iChannel1, (vTexCoord - ivec2(-1,-1) ), 0 ).a;\n    float fSample_BC = texelFetch( iChannel1, (vTexCoord - ivec2( 0,-1) ), 0 ).a;\n    float fSample_BR = texelFetch( iChannel1, (vTexCoord - ivec2( 1,-1) ), 0 ).a;\n    float fSample_BS = texelFetch( iChannel1, (vTexCoord - ivec2( 2,-1) ), 0 ).a;\n    \n    \n    float fSample_SC = texelFetch( iChannel1, (vTexCoord - ivec2( 0,-2) ), 0 ).a;\n    float fSample_SR = texelFetch( iChannel1, (vTexCoord - ivec2( 1,-2) ), 0 ).a;\n    float fSample_SS = texelFetch( iChannel1, (vTexCoord - ivec2( 2,-2) ), 0 ).a;\n   \n    float fOutline = min( 1.0, \n\t\tfSample_TL + fSample_TC + fSample_TR +\n\t\tfSample_CL + fSample_CC + fSample_CR +\n\t\tfSample_BL + fSample_BC + fSample_BR );\n    \n    float fShadow = min( 1.0, \n\t\tfSample_CC + fSample_CR + fSample_CS +\n\t\tfSample_BC + fSample_BR + fSample_BS + \n\t\tfSample_SC + fSample_SR + fSample_SS);\n    \t\n    float fMain = fSample_CC;\n    \n    vec4 vResult = vec4(0.0);\n    \n    float fAlpha = min( 1.0, fOutline + fMain + fShadow );\n    \n    float fShade = fSample_TL * 1.5 + fSample_BR * -1.5 + fSample_TC * 1.0 + fSample_CL * 1.0 \n        + fSample_BC * -1.0 + fSample_CR * -1.0;\n    \n    fShade = clamp( fShade * 0.25, 0.0, 1.0 );\n    \n    fShade = fShade * .3 + .7;\n    \n    vec3 vColor = vec3( .2 ); \/\/ drop shadow\n    \n    if ( fOutline > 0.0 )\n        vColor = vec3(.4, 0, 0); \/\/ outline\n\n    if ( fMain > 0.0 )\n        vColor = vec3(fShade, 0, 0); \/\/ main text\n            \n    vResult = vec4(vColor, fAlpha);\n    \n    return vResult;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool bReuseData = false;\n    if ( iFrame > 0 )\n    {\n\t    \/\/ Check Resolution\n        vec4 info = texelFetch( iChannel0, ivec2(0, 0), 0 );\n        if ( (info.x == iResolution.x) && (info.y == iResolution.y) )\n        {\n            bReuseData = true;\n        }\n    }\n\n\tif ( bReuseData )\n    {\n        fragColor = texelFetch( iChannel0, ivec2(floor(fragCoord)), 0 );\n        return;\n        \/\/vResult.r = sin(iTime * 10.0) *0.5 + 0.5; \/\/ flash the cache\n    }    \n    \n    ivec2 vFontCoord = ivec2(floor(fragCoord)) - FONT_POS;\n    \n    vec4 vResult = vec4(0.2,0,0,1);\n    \n    float fPersistence = 0.8;\n\tfloat fNoise2Freq = 0.5;    \n    \n    vec2 vSpritePixel = vec2(0);\n    vec4 vSpriteInfo = vec4(0);\n    \n    float fSpriteIndex = -1.;\n    \n    bool bRaymarch = false;\n    Scene_Clear();\n    \n    \n    #if 0\n        bRaymarch = true;\n    \n    \t#if 1\n    \t\tg_scene.bArmor = true;\n    \t#endif\n    \n    \t#if 0\n            g_scene.bCharacter = true;\n\n            \/\/float fType = SPRITE_ENEMY_TYPE_TROOPER;\n            float fType = SPRITE_ENEMY_TYPE_SERGEANT;\n            \/\/float fType = SPRITE_ENEMY_TYPE_IMP;\n\n            \/\/float fAction = SPRITE_ENEMY_ACTION_STAND;\n            float fAction = SPRITE_ENEMY_ACTION_WALK1;\n            \/\/float fAction = SPRITE_ENEMY_ACTION_WALK2;\n            \/\/float fAction = SPRITE_ENEMY_ACTION_ATTACK;\n            \/\/float fAction = SPRITE_ENEMY_ACTION_PAIN;\n            \/\/float fAction = SPRITE_ENEMY_ACTION_DIE;\n            \/\/float fAction = SPRITE_ENEMY_ACTION_DEAD;\n\n\n            Pose_Enemy( fType, fAction, 0. );\n\n    \t#endif\n\n        vec2 vSize = vec2(512, 512);\n        float fScale = 6.5;\n        vec2 vPos = fragCoord.xy;\n        vPos.x = (vPos.x - vSize.x * .5) \/ fScale + vSize.x * .5;\n        vPos.y \/= fScale;\n    \n    \tg_scene.fCameraRotation = iTime;\n    \tfragColor = Raymarch_Sprite( vPos.xy, vec4(0,0,512,512) );\n    \n    \treturn;\n    #endif\n    \n    \n    float fTestIndex = 0.;\n    if ( SpriteSelectIterate( kSpriteFireball, fragCoord, vSpriteInfo, fSpriteIndex, fTestIndex ) )\n    {\n    }\n    if ( SpriteSelectIterate( kSpriteFireball2, fragCoord, vSpriteInfo, fSpriteIndex, fTestIndex ) )\n    {\n    }\n    if ( SpriteSelectIterate( kSpriteBarrel, fragCoord, vSpriteInfo, fSpriteIndex, fTestIndex ) )\n    {        \n    }\n    if ( SpriteSelectIterate( kSpriteBarrelExpl, fragCoord, vSpriteInfo, fSpriteIndex, fTestIndex ) )\n    {        \n    }\n    if ( SpriteSelectIterate( kSpriteBarrelExpl2, fragCoord, vSpriteInfo, fSpriteIndex, fTestIndex ) )\n    {        \n    }\n    if ( SpriteSelectIterate( kSpriteBloodyMess, fragCoord, vSpriteInfo, fSpriteIndex, fTestIndex ) )\n    {        \n        fPersistence = 1.0;\n    }\n    if ( SpriteSelectIterate( kSpriteHealthBonus, fragCoord, vSpriteInfo, fSpriteIndex, fTestIndex ) )\n    {        \n    }\n    if ( SpriteSelectIterate( kSpriteArmorBonus, fragCoord, vSpriteInfo, fSpriteIndex, fTestIndex ) )\n    {        \n        fPersistence = 0.6;\n    }\n    if ( SpriteSelectIterate( kSpriteMedikit, fragCoord, vSpriteInfo, fSpriteIndex, fTestIndex ) )\n    {        \n    }\n    if ( SpriteSelectIterate( kSpriteStimpack, fragCoord, vSpriteInfo, fSpriteIndex, fTestIndex ) )\n    {        \n    }\n    if ( SpriteSelectIterate( kSpriteBlueArmor, fragCoord, vSpriteInfo, fSpriteIndex, fTestIndex ) )\n    {        \n        bRaymarch = true;\n        g_scene.bArmor = true;\n    }\n    if ( SpriteSelectIterate( kSpriteGreenArmor, fragCoord, vSpriteInfo, fSpriteIndex, fTestIndex ) )\n    {        \n        bRaymarch = true;\n        g_scene.bArmor = true;\n\t    g_scene.vLightDir = normalize( vec3(0.2, 1, -0.2) );\n        \n    }\n    if ( SpriteSelectIterate( kSpriteShotgun, fragCoord, vSpriteInfo, fSpriteIndex, fTestIndex ) )\n    {        \n        bRaymarch = true;\n        g_scene.bCharacter = false;\n        Weapon_DefaultPos();\n    }\n    if ( SpriteSelectIterate( kSpriteWallImpact1, fragCoord, vSpriteInfo, fSpriteIndex, fTestIndex ) )\n    {        \n    }\n    if ( SpriteSelectIterate( kSpriteWallSmokeImpact1, fragCoord, vSpriteInfo, fSpriteIndex, fTestIndex ) )\n    {        \n        fPersistence = 0.95;\n    }\n    if ( SpriteSelectIterate( kSpriteFleshImpact1    , fragCoord, vSpriteInfo, fSpriteIndex, fTestIndex ) )\n    {        \n    }\n    if ( SpriteSelectIterate( kSpriteDeadTrooper    , fragCoord, vSpriteInfo, fSpriteIndex, fTestIndex ) )\n    {        \n        bRaymarch = true;\n        g_scene.bCharacter = true;\n\t    CharDef_Trooper( g_scene.charDef );            \n        Pose_Dead( g_scene.pose );\n    }\n    if ( SpriteSelectIterate( kSpriteDeadSergeant    , fragCoord, vSpriteInfo, fSpriteIndex, fTestIndex ) )\n    {\n        bRaymarch = true;\n        g_scene.bCharacter = true;\n\t    CharDef_Sergeant( g_scene.charDef );                    \n        Pose_Dead( g_scene.pose );\n    }\n    if ( SpriteSelectIterate( kSpriteDeadImp    , fragCoord, vSpriteInfo, fSpriteIndex, fTestIndex ) )\n    {\n        bRaymarch = true;\n        g_scene.bCharacter = true;\n\t    CharDef_Imp( g_scene.charDef );                    \n        Pose_Dead( g_scene.pose );\n    }\n    if ( SpriteSelectIterate( kSpriteFloorLamp, fragCoord, vSpriteInfo, fSpriteIndex, fTestIndex ) )\n    {\n    }\n    if ( SpriteSelectIterate( kSpriteTallTechnoPillar, fragCoord, vSpriteInfo, fSpriteIndex, fTestIndex ) )\n    {\n        fNoise2Freq = 2.0;\n        fPersistence = 1.0;\n    }\n    \n    float fEnemySpriteType;\n    float fEnemySpriteAction;\n    float fEnemySpriteDirection;\n    bool isEnemySprite = GetEnemySpriteId( fragCoord, fEnemySpriteType, fEnemySpriteAction, fEnemySpriteDirection );\n\n    ivec2 vFontMax = 10 * FONT_CHAR;\n    if( vFontCoord.x >= 0 && vFontCoord.y >= 0 && vFontCoord.x < (vFontMax.x + 16) && vFontCoord.y < (vFontMax.y + 16) )\n    {\n        fSpriteIndex = 777.;\n    }\n    else\n    if ( isEnemySprite )\n    {\n        bRaymarch = true;\n        g_scene.bCharacter = true;\n\t\tPose_Enemy( fEnemySpriteType, fEnemySpriteAction, fEnemySpriteDirection );\n        \n        fSpriteIndex = 666.;\n        vSpriteInfo = GetEnemySprite( fEnemySpriteType, fEnemySpriteAction, fEnemySpriteDirection );\n        \n        \/\/fragColor.rgb= vec3( fEnemySpriteType, fEnemySpriteAction, fEnemySpriteDirection) \/ 8.0; return;\n    }\n        \n    if ( fSpriteIndex == -1.0 )\n    {\n        discard;\n    }\n\t\t\n\tvec4 vRaymarchResult = vec4( 0 );\n    vRaymarchResult = Raymarch_Sprite( fragCoord.xy, vSpriteInfo );\n    \n    {    \n        vSpritePixel = SpritePixel( fragCoord, vSpriteInfo );\n\n        float fRandom = fbm( vSpritePixel, fPersistence );\n        float fHRandom = noise1D( vSpritePixel.x * fNoise2Freq );\/\/ - (vSpritePixel.y \/ vSpriteInfo.w);\n\n        fTestIndex = 0.;\n\n\t    if( vFontCoord.x >= 0 && vFontCoord.y >= 0 && vFontCoord.x < (vFontMax.x + 16) && vFontCoord.y < (vFontMax.y + 16) )\n        {\n\n            int iFontDigit = vFontCoord.x \/ 16;\n            ivec2 vFontPixel = vFontCoord.xy;\n            vFontPixel.x = vFontPixel.x % 16;\n            vResult = NumFont_Char( vFontPixel, iFontDigit );\n            \/\/float fValue = NumFont_BinChar( vFontPixel, fFontDigit );\n            \/\/vResult =  vec4( fValue );\n        }\n        if ( SpriteProcessIterate( fTestIndex, fSpriteIndex) )\n        {\n            vResult = TexFireball( vSpritePixel, fRandom, fHRandom, vSpriteInfo.z * .5, 0. );\n        }\n\t\tif ( SpriteProcessIterate( fTestIndex, fSpriteIndex) )\n        {\n            vResult = TexFireball( vSpritePixel, fRandom, fHRandom, vSpriteInfo.z * .5, 1. );\n        }\n        if ( SpriteProcessIterate( fTestIndex, fSpriteIndex) )\n        {\n            vResult = TexBar1A( vSpritePixel, fRandom, fHRandom );\n        }\n        if ( SpriteProcessIterate( fTestIndex, fSpriteIndex) )\n        {\n            vResult = TexBarExpl( vSpritePixel, fRandom, fHRandom );\n        }\n        if ( SpriteProcessIterate( fTestIndex, fSpriteIndex) )\n        {\n            vResult = TexBarExpl2( vSpritePixel, fRandom, fHRandom );\n        }\n        if ( SpriteProcessIterate( fTestIndex, fSpriteIndex) )\n        {\n            vResult = TexPlayW( vSpritePixel, fRandom, fHRandom  );\n        }\n        if ( SpriteProcessIterate( fTestIndex, fSpriteIndex) )\n        {\n            vResult = TexHealthBonus( vSpritePixel, fRandom, fHRandom  );\n        }\n        if ( SpriteProcessIterate( fTestIndex, fSpriteIndex) )\n        {\n            vResult = TexArmorBonus( vSpritePixel, fRandom, fHRandom  );\n        }\n        if ( SpriteProcessIterate( fTestIndex, fSpriteIndex) )\n        {\n            \/\/ Medikit\n            vResult = TexMedikit( vSpritePixel, fRandom, fHRandom, 0.0 );\n        }\n        if ( SpriteProcessIterate( fTestIndex, fSpriteIndex) )\n        {\n            \/\/ Stimpack\n            vResult = TexMedikit( vSpritePixel + vec2(6,0), fRandom, fHRandom, 5.0 );\n        }\n        if ( SpriteProcessIterate( fTestIndex, fSpriteIndex) )\n        {\n            \/\/ blue armor\n            \/\/vResult = TexPlaceholder( vSpritePixel, fRandom, fHRandom, vec3(0,0,1) );\n            vResult = vRaymarchResult;            \n            vResult.rgb *= fRandom * vec3(0,0,1);            \n        }\n        if ( SpriteProcessIterate( fTestIndex, fSpriteIndex) )\n        {\n            \/\/ green armor\n            vResult = vRaymarchResult;            \n            vResult.rgb *= fRandom * vec3(0,1.0,0);\n            \/\/vResult = TexPlaceholder( vSpritePixel, fRandom, fHRandom, vec3(0,1.0,0) );\n        }\n        if ( SpriteProcessIterate( fTestIndex, fSpriteIndex) )\n        {\n            \/\/ Shotgun\n            \/\/vResult = TexShotgunItem( vSpritePixel, fRandom, fHRandom  );\n            vResult = vRaymarchResult;       \n            vResult.rgb *= fRandom;\n            \n        }\n        if ( SpriteProcessIterate( fTestIndex, fSpriteIndex) )\n        {\n            vResult = TexWallImpact( vSpritePixel, fRandom, fHRandom  );\n        }        \n        if ( SpriteProcessIterate( fTestIndex, fSpriteIndex) )\n        {\n            vResult = TexBulletSmokeImpact( vSpritePixel, fRandom, fHRandom  );\n        }        \n        if ( SpriteProcessIterate( fTestIndex, fSpriteIndex) )\n        {\n            vResult = TexFleshImpact( vSpritePixel, fRandom, fHRandom  );\n        }        \n        if ( SpriteProcessIterate( fTestIndex, fSpriteIndex) )\n        {\n            \/\/ Dead trooper\n            vResult = TexPlayW( vSpritePixel, fRandom, fHRandom );\n            float fMask = fRandom * fRandom * ((16.0 - vSpritePixel.y) \/ 4.0);\n            if ( (vRaymarchResult.a - fMask ) > 0. )\n            {\n            \tvResult = vRaymarchResult;            \n\t            vResult.xyz *= fRandom;\n            }\n        }\n        if ( SpriteProcessIterate( fTestIndex, fSpriteIndex) )\n        {\n            \/\/ Dead sergeant\n            vResult = TexPlayW( vSpritePixel, fRandom, fHRandom );\n            float fMask = fRandom * fRandom * ((16.0 - vSpritePixel.y) \/ 4.0);\n            if ( (vRaymarchResult.a - fMask ) > 0. )\n            {\n            \tvResult = vRaymarchResult;            \n\t            vResult.xyz *= fRandom;\n            }\n        }\n        if ( SpriteProcessIterate( fTestIndex, fSpriteIndex) )\n        {\n            \/\/ Dead imp\n            vResult = TexPlayW( vSpritePixel, fRandom, fHRandom );\n            float fMask = fRandom * fRandom * ((16.0 - vSpritePixel.y) \/ 4.0);\n            if ( (vRaymarchResult.a - fMask ) > 0. )\n            {\n            \tvResult = vRaymarchResult;            \n\t            vResult.xyz *= fRandom;\n            }\n        }\n        if ( SpriteProcessIterate( fTestIndex, fSpriteIndex) )\n        {\n            vResult = TexFloorLamp( vSpritePixel, fRandom, fHRandom  );\n        }        \n        if ( SpriteProcessIterate( fTestIndex, fSpriteIndex) )\n        {\n            vResult = TexTallTechnoPillar( vSpritePixel, fRandom, fHRandom  );\n        }        \n        \n        \n        if ( isEnemySprite )\n        {\n            vResult = vRaymarchResult;\n            vResult.xyz *= fRandom;\n            \n            if ( fEnemySpriteAction == float(SPRITE_ENEMY_ACTION_ATTACK) )\n            {\n\t            AddGlow( vResult.xyz, vSpritePixel, vec2(16. - 8. * sin( g_scene.fCameraRotation), 36), vec3(1,.9, .5) * 3., 1.0 );\n            }\n        }\n\n        vResult.rgb = clamp( vResult.rgb, 0.0, 1.0 );\n        vResult.rgb = Quantize(vResult.rgb, 32.0);\n    }\n    \n\t\n\n \n    \/\/ Flash alpha channel\n#if 0\n    if ( vResult.a == 0. )\n    {\n        float fFlash = 1.0;\n        \/\/float fFlash = sin(iTime* 10.) * 0.5 + 0.5;\n        vResult.rgb = mix ( vec3(0,0,0.3), vec3(1,.5, 1), fFlash );\n    }\n#endif    \n    \n    if ( floor ( fragCoord ) == vec2(0.0) )\n    {\n        vResult = vec4( iResolution.x, iResolution.y, 0, 0 );\n    }\n    \n    fragColor = vResult;\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"\/presets\/tex00.jpg","previewfilepath":"\/presets\/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\/\/ Update \/ Game Logic\n\n\/\/#define DEV\n\n#ifdef DEV\n\n#define CHEAT_GOD\n#define CHEAT_NOCLIP\n#define CHEAT_NOAI\n\n#endif \n\n\n\/\/ TODO:\n\/\/\n\/\/ * Bug fixes\n\/\/ ** Only pickup when needed\n\/\/ ** Fix slidebox bugs *!*\n\n\/\/ * Performance\n\/\/ ** Profile\n\/\/ ** Entity rendering precalc\n\/\/ ** Sector update logic in BufC (makes bufA static)\n\n\/\/ *Implement more textures\n\/\/ ** Exit door\n\/\/ ** Exit area door\n\/\/ ** Walls with alpha\n\/\/\n\/\/ * Add more decorations \n\/\/ ** Dead players\n\/\/ ** Candelabra\n\n\/\/ * Sprites\n\/\/ ** improve fireball + explode\n\n\/\/ * Presentation \/ UI\n\/\/ ** Skill select?\n\/\/ ** Level summary\n\n\/\/ * Enemy sound \/ path finding\n\n\/\/ * Viewmodel\n\/\/ ** Viewmodel hand\n\/\/ ** Better pistol viewmodel\n\/\/ ** Better viewmodel anim\n\n\/\/ * Map color (brown vs yellow)\n\n\/\/ * Gameplay\n\/\/ ** More authentic movement\n\/\/ ** Mouse accel\n\/\/ ** Balance damage \/ health amounts\n\n\/\/ * Ammo \/ ammo pickups\n\/\/ ** Clip\n\/\/ ** Shells\n\/\/ ** Box of shells\n\n\/\/ * Unpinned top \/ bottom textures\n\n\/\/ * Generic door \/ platform logic\n\n\/\/ * Improve enemy poses\n\n\n#define ALLOW_MAP\n\n#define MAP_CHANNEL iChannel0\n#define STATE_CHANNEL iChannel1\n#define iChannelKeyboard iChannel3\n\n\/\/ ----------------- 8< -------------------------- 8< -------------------------- 8< --------------\n\/\/ Common code follows\n\n#define NO_UNROLL(X) (X + min(0,iFrame))\n#define NO_UNROLLU(X) (X + uint(min(0,iFrame)))\n\nbool Map_PointInSector( sampler2D mapSampler, vec2 vPos, Sector sector )\n{\n    float fInOutTest = 0.0;\n    \n    for(int iSideDefIndex=0; iSideDefIndex< NO_UNROLL( sector.iSideDefCount ); iSideDefIndex++)\n    {        \n        SideDef sideDef = Map_ReadSideDefInfo( mapSampler, sector.iSectorId, iSideDefIndex );\n        \n        vec2 vPosToA = sideDef.vA - vPos;\n        vec2 vPosToB = sideDef.vB - vPos;\n        \n        if ( vPosToA.y > 0.0 && vPosToB.y > 0.0 )\n        \tcontinue;\n        if ( vPosToB.y <= 0.0 && vPosToA.y <= 0.0 )\n        \tcontinue;               \n        \n        float fCross = Cross2d( vPosToA, vPosToB );\n        if ( vPosToA.y > vPosToB.y )\n            fCross = -fCross;\n        if ( fCross < 0.0 )\n        {\n            fInOutTest++;\n        }        \n    }\n    \n    return mod( fInOutTest, 2.0 ) >= 1.0;    \n}\n\nbool Map_PointInSector( sampler2D mapSampler, MapInfo mapInfo, vec2 vPos, int iSectorId )\n{\n    if ( !Map_ValidSectorId(mapInfo, iSectorId) )\n    {\n        return false;\n    }\n\n    Sector sector = Map_ReadSector( mapSampler, iSectorId );\n\n    return Map_PointInSector( mapSampler, vPos, sector );\n}\n\nint Map_SeekSector( sampler2D mapSampler, MapInfo mapInfo, vec2 vPos )\n{    \n    for(int iSectorIndex=0; iSectorIndex<NO_UNROLL( mapInfo.iSectorCount ); iSectorIndex++)\n    {        \n        if ( Map_PointInSector( mapSampler, mapInfo, vPos, iSectorIndex ) )\n        {\n            return iSectorIndex;\n        }        \n    }\n\n    return SECTOR_NONE;\n}\n\n\nvoid Map_UpdateSector( sampler2D mapSampler, MapInfo mapInfo, vec2 vPrev, vec2 vPos, inout int iSectorId )\n{    \n    if ( vPrev == vPos )\n    {\n        return;\n    }\n    \n    if ( !Map_PointInSector( mapSampler, mapInfo, vPos, iSectorId ) )\n    {\n        int iNewSectorId = Map_SeekSector( mapSampler, mapInfo, vPos );\n        \n        if ( iNewSectorId != SECTOR_NONE )\n        {\n        \tiSectorId = iNewSectorId;\n        }                \n    }\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Trace\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nTraceResult Map_Trace( sampler2D mapSampler, MapInfo mapInfo, vec3 vRayOrigin, vec3 vRayDir, int iSectorId, float fMaxDist )\n{\n    TraceResult result;\n    \n    result.iTexture = 0u;\n    result.vTexture = vec3(0.0);\n    result.fDist = 0.0;\n    result.fLightLevel = 0.0;\n    result.iSector = SECTOR_NONE;\n    \n    while(true)\n    {\n        if ( iSectorId == SECTOR_NONE )\n        {\n            break;\n        }\n        \n        Sector sector = Map_ReadSector( mapSampler, iSectorId );\n        \n        TraceSectorState sectorState;\n        sectorState.iNextSector = SECTOR_NONE;        \n        sectorState.fEnterDist = result.fDist;\n        sectorState.bNoUpper = false;\n        result.fDist = fMaxDist;\n        result.iSector = iSectorId;\n        \n        for(int iSideDefIndex=0; iSideDefIndex<NO_UNROLL( sector.iSideDefCount); iSideDefIndex++)\n        {\n            SideDef sideDef = Map_ReadSideDefInfo( mapSampler, iSectorId, iSideDefIndex );                        \n\n            TraceSideDef( mapSampler, vRayOrigin, vRayDir, result, sectorState, sector, sideDef );\n        }\n\n        \/\/ Test floor \/ ceiling\n        if ( sectorState.fExitY < sector.fFloorHeight )\n        {\n            result.fDist = (sector.fFloorHeight - vRayOrigin.y) \/ vRayDir.y;\n            vec3 vFloorPos = vRayOrigin + vRayDir * result.fDist;\n            result.vTexture.st = vec2( vFloorPos.xz );\n            result.iTexture = sector.iFloorTexture;\n            result.fLightLevel = 0.0;\n            sectorState.iNextSector = SECTOR_NONE;\n        }\n        else\n        if ( sectorState.fExitY > sector.fCeilingHeight && !sectorState.bNoUpper )\n        {\n            result.fDist = (sector.fCeilingHeight - vRayOrigin.y) \/ vRayDir.y;\n            vec3 vCeilingPos = vRayOrigin + vRayDir * result.fDist;\n            result.vTexture.st = vec2( vCeilingPos.xz );\n            result.iTexture = sector.iCeilingTexture;\n            result.fLightLevel = 0.0;\n            sectorState.iNextSector = SECTOR_NONE;\n        }        \n\n        iSectorId = sectorState.iNextSector;\n    }\n    \n    if ( result.iTexture == 1u )\n        result.fDist = FAR_CLIP;\n    \n    return result;\n}\n\n\/\/ End of common code\n\/\/ ----------------- 8< -------------------------- 8< -------------------------- 8< --------------\n\n\nMapInfo g_mapInfo;\nGameState g_gameState;\n\nstruct Controls\n{\n    bool menuConfirm;\n    bool menuUp;\n    bool menuDown;\n    \n    bool moveForwards;\n    bool moveBackwards;\n    bool moveLeft;\n    bool moveRight;\n    bool fire;\n\n    bool turnLeft;\n    bool turnRight;\n\n    bool run;\n    bool strafe;\n    bool open;    \n    \n    bool weap_2;\n    bool weap_3;\n    \n    bool toggleMouseLook;\n    bool toggleInvertY;\n};\n    \nControls g_controls;\n\nControls ReadControls()\n{\n    Controls controls;\n    \n    bool bArrowUp = Key_IsPressed( iChannelKeyboard, KEY_UP );\n    bool bArrowDown = Key_IsPressed( iChannelKeyboard, KEY_DOWN );\n    bool bSpace = Key_IsPressed( iChannelKeyboard, KEY_SPACE );        \n    bool bEnter = Key_IsPressed( iChannelKeyboard, KEY_ENTER );        \n    \n    controls.moveForwards = \t\tKey_IsPressed( iChannelKeyboard, KEY_W ) || bArrowUp;\n    controls.moveBackwards = \t\tKey_IsPressed( iChannelKeyboard, KEY_S ) || bArrowDown;\n    controls.moveLeft = \t\t\tKey_IsPressed( iChannelKeyboard, KEY_A );\n    controls.moveRight = \t\t\tKey_IsPressed( iChannelKeyboard, KEY_D );\n    controls.fire = \t\t\t\tbSpace;\n\n    controls.turnLeft = \t\t\tKey_IsPressed( iChannelKeyboard, KEY_LEFT );\n    controls.turnRight = \t\t\tKey_IsPressed( iChannelKeyboard, KEY_RIGHT );\n\n    controls.run = \t\t\t\t\tKey_IsPressed( iChannelKeyboard, KEY_SHIFT );\n    controls.strafe = \t\t\t\tKey_IsPressed( iChannelKeyboard, KEY_ALT );        \n    controls.open = \t\t\t\tbEnter || Key_IsPressed( iChannelKeyboard, KEY_F );\n    \n    controls.weap_2 = \t\t\t\tKey_IsPressed( iChannelKeyboard, KEY_2 );\n    controls.weap_3 = \t\t\t\tKey_IsPressed( iChannelKeyboard, KEY_3 );        \n    \n    controls.toggleMouseLook = \t\tKey_IsToggled( iChannelKeyboard, KEY_L );\n    controls.toggleInvertY = \t\tKey_IsToggled( iChannelKeyboard, KEY_I );\n    \n    controls.menuConfirm = \t\t\tbSpace || bEnter;\n    controls.menuUp = \t\t\t\tbArrowUp;\n    controls.menuDown = \t\t\tbArrowDown;\n    \n    return controls;\n}\n    \n\nvoid Entity_MapSpawn( inout Entity entity, int iSpawnIndex )\n{   \n    Entity_Clear( entity );\n    \n    vec4 vData0 = ReadMapData( MAP_CHANNEL, ivec2(128, iSpawnIndex) );\n    vec4 vData1 = ReadMapData( MAP_CHANNEL, ivec2(129, iSpawnIndex) );\n    \n    if ( dot(vData0.zw, vData0.zw) > 0.0 )\n    {\n        entity.iType = int(vData0.x);\n        entity.iSubType = int(vData0.y);\n        entity.vPos.xz = vData0.zw;\n        entity.vPos.y = 0.0;\n        entity.fYaw = radians( 90. - vData1.x );\n\n        entity.iSectorId = Map_SeekSector( MAP_CHANNEL, g_mapInfo, entity.vPos.xz );    \n\n        Sector sector = Map_ReadSector( MAP_CHANNEL, entity.iSectorId );\n\n        entity.vPos.y = sector.fFloorHeight;\n        \n        if ( entity.iType == ENTITY_TYPE_PLAYER )\n        {\n            entity.fHealth = 100.0;\n        }\n        if ( entity.iType == ENTITY_TYPE_ENEMY )\n        {\n            if ( entity.iSubType == ENTITY_SUB_TYPE_ENEMY_TROOPER )\n            {\n\t            entity.fHealth = 20.0;\n            }\n            else\n            if ( entity.iSubType == ENTITY_SUB_TYPE_ENEMY_SERGEANT )\n            {\n\t            entity.fHealth = 30.0;\n            }\n            else\n            if ( entity.iSubType == ENTITY_SUB_TYPE_ENEMY_IMP )\n            {\n\t            entity.fHealth = 60.0;\n            }\n        }\n        if ( entity.iType == ENTITY_TYPE_BARREL )\n        {\n            entity.fHealth = 20.0;\n        }        \n        if ( entity.iType == ENTITY_TYPE_DOOR )\n        {        \n\t        entity.fTarget = sector.fFloorHeight;\n        }\n        if ( entity.iType == ENTITY_TYPE_PLATFORM )\n        {        \n            entity.vPos.y = sector.fFloorHeight;\n            entity.vPos.xz = vData1.zw; \/\/ trigger location\n\t        entity.fTarget = sector.fFloorHeight;\n        }\n    }\n    else\n    {\n        entity.iType = ENTITY_TYPE_NONE;\n    }\n}\n\nvoid Entity_Fall( inout Entity entity, float fTimestep )\n{\n    if ( Map_ValidSectorId( g_mapInfo, entity.iSectorId ) )\n    {\n        Sector sector = Map_ReadSector( MAP_CHANNEL, entity.iSectorId );    \t\n        float a = -800.;\n        entity.vPos.y += entity.vVel.y * fTimestep + .5 * a * fTimestep * fTimestep;\n        entity.vVel.y += a * fTimestep;\n        if ( entity.vPos.y < sector.fFloorHeight )\n        {\n            entity.vPos.y = sector.fFloorHeight;\n            entity.vVel.y = 0.0;\n        }\n    }\n    else\n    {\n        entity.vVel.y = 0.0;\n    }\n}\n\n\nvoid SlideVector( inout int iSectorId, inout vec2 vPos, inout vec2 vVel, float fYPos, float fYPos2, float fDropOff )\n{       \n\tbool bReevaluate = false;\n    \n    int iInitialSector = iSectorId;\n    \n    \/\/ maximum number of sector traversal \/ wall collisions\n    for (int iIter=0; iIter<8; iIter++ )\n    {\n\t    bReevaluate = false;\n\n        float fVelLength = length( vVel );\n        if ( length( vVel ) <= 0.0 )\n        {\n            break;\n        }\n\n        vec2 vVelDir = normalize( vVel );\n\n        Sector sector = Map_ReadSector( MAP_CHANNEL, iSectorId );\n\n        for(int iSideDefIndex=0; iSideDefIndex<sector.iSideDefCount; iSideDefIndex++)\n        {\n            SideDef sideDef = Map_ReadSideDefInfo( MAP_CHANNEL, iSectorId, iSideDefIndex );                        \n\n            vec3 vHitTUD = Map_SideDefIntersectLine( sideDef, vPos, vVelDir );\n\n            float fHitT = vHitTUD.x;\n            float fHitU = vHitTUD.y;\n            float fDenom = vHitTUD.z;        \n\n\t\t\t\/\/ Only consider cases when we are leaving sector\n            if ( fDenom < 0.0 )\n            {        \n                if ( fHitT > 0.0 && fHitT < fVelLength )\n                {\n                    if ( fHitU > 0.0 && fHitU < 1.0 )\n                    {\n                        \/\/ We hit a sidedef\n\n                        bool bSolid = true;\n                        bReevaluate = true;\n                        \n                        if ( sideDef.iNextSector != SECTOR_NONE )\n                        {\n#ifdef CHEAT_NOCLIP                            \n                            {   {   {\n#else \/\/ #ifdef CHEAT_NOCLIP                                \n                            \/\/ blocking flag\n                            if ( mod( floor(sideDef.fFlags \/ 2.), 2. ) == 0. )\n                            {\n                                \/\/ Check heights of next sector\n                                Sector nextSector = Map_ReadSector( MAP_CHANNEL, sideDef.iNextSector );                            \n                                if( ( fYPos > nextSector.fFloorHeight && fYPos < nextSector.fCeilingHeight ) && \n                                    ( fYPos2 > nextSector.fFloorHeight && fYPos2 < nextSector.fCeilingHeight ) )\n                                {\n                                    \/\/ Check DropOff (enemies are blocked from walking over ledges higher than this)\n                                    if ( nextSector.fFloorHeight >= (sector.fFloorHeight - fDropOff) )\n                                    {\n#endif \/\/ #ifdef CHEAT_NOCLIP                            \n                                        \/\/ Consider next sector\n                                        bSolid = false;\n                                        iSectorId = sideDef.iNextSector;                                    \n                                    }\n                                }\n                            }\n                        }\n                        \n                        \n                        \/\/if (false)\n                        if ( bSolid )\n                        {\n                            \/\/vVel *= 0.0;\n                            \/\/break;\n\n                            \/\/ Apply the sliding constraint\n                            vec2 vAB = sideDef.vB - sideDef.vA;\n                            vec2 vNormal = normalize( vec2( -vAB.y, vAB.x ) );\n\n                            float fDot = dot( vVel, vNormal );\n                            vVel -= vNormal * fDot;\n                            vVel -= vNormal * 0.2;\n                            \n                            \/\/ Velocity updated, begin testing from initial sector\n                            iSectorId = iInitialSector;\n                        }    \n                        \n                        break;                    \n                    }\n                }\n            }                \n        }        \n\n        if ( !bReevaluate )\n        {\n            break;\n        }\n    }\n    \n    if (!bReevaluate)\n    {\n    \tvPos += vVel;    \n    }\n    else\n    {\n        vVel = vec2(0);\n    }\n}\n            \nvoid Entity_UpdateSlideBox( inout Entity entity, float fTimestep )\n{\n    entity.fYaw += entity.fYawVel * fTimestep;\n\n    const float fStepHeight = 24.1; \/\/ https:\/\/www.doomworld.com\/vb\/doom-general\/67054-maximum-height-monsters-can-step-on\/\n    const float fClearanceHeight = 32.;\n    \n    float fDropOff = 10000.0;\n    if ( entity.iType == ENTITY_TYPE_ENEMY )\n    {\n        \/\/ Enemies \n        fDropOff = 24.0;\n    }\n    entity.vVel.xz *= fTimestep;\n    SlideVector( entity.iSectorId, entity.vPos.xz, entity.vVel.xz, entity.vPos.y + fStepHeight, entity.vPos.y + fClearanceHeight, fDropOff );\n    entity.vVel.xz \/= fTimestep;\n}\n\nfloat Entity_GetWeaponType( Entity entity )\n{\n    if ( entity.iType == ENTITY_TYPE_PLAYER )\n    {\n        \/\/return WEAPON_TYPE_FIREBALL;\n        if ( entity.fUseWeapon == 1. )\n        {\n        \treturn WEAPON_TYPE_PISTOL;\n        }\n        else\n        {\n    \t\treturn WEAPON_TYPE_SHOTGUN;\n        }\n    }\n    else\n    if ( entity.iType == ENTITY_TYPE_ENEMY )\n    {\n        if ( entity.iSubType == ENTITY_SUB_TYPE_ENEMY_TROOPER )\n        {\n            return WEAPON_TYPE_PISTOL;        \n        }\n        else if ( entity.iSubType == ENTITY_SUB_TYPE_ENEMY_SERGEANT )\n        {\n            return WEAPON_TYPE_SHOTGUN;        \n        }\n        else if ( entity.iSubType == ENTITY_SUB_TYPE_ENEMY_IMP )\n        {\n            return WEAPON_TYPE_FIREBALL;        \n        }        \n    }\n\n    return WEAPON_TYPE_PISTOL;\n}\n\nWeaponDef Entity_GetWeaponDef( Entity entity )\n{\n    return Weapon_GetDef( Entity_GetWeaponType( entity ), entity.iType == ENTITY_TYPE_ENEMY );\n}\n    \n    \nint Enemy_GetState( Entity entity )\n{\n    return int(entity.fArmor);\n}\n\nvoid Enemy_SetState( inout Entity entity, int iNewState )\n{\n    if ( Enemy_GetState(entity) == ENEMY_STATE_DIE )\n    {\n        return;\n    }\n    \n    entity.fArmor = float(iNewState);\n    \n    bool setRandomTimer = false;\n    \n    if ( iNewState == ENEMY_STATE_PAIN )\n    {\n        entity.fTimer = 0.2;    \n    }\n    else\n    if ( iNewState == ENEMY_STATE_DIE )\n    {\n        SetFlag( entity.iFrameFlags, ENTITY_FRAME_FLAG_DROP_ITEM );\n        entity.fTimer = 0.4;    \n    }\n    else\n#ifdef CHEAT_NOAI \n    {\n    \tentity.fArmor = float(ENEMY_STATE_STAND);        \n        entity.fTimer = 0.4;    \n    }\n#else        \n    if ( iNewState == ENEMY_STATE_FIRE )\n    {\n        SetFlag( entity.iFrameFlags, ENTITY_FRAME_FLAG_FIRE_WEAPON );\n        entity.fTimer = 0.3;    \n    }\n    else\n    if ( iNewState == ENEMY_STATE_WALK_RANDOM )\n    {\n    \tfloat fRandom = Hash( float(entity.iId) + iTime + 3.456 );        \n        \n        entity.fYaw = fRandom * 3.14 * 2.0;\n\n        float fStepScale = 3.14 \/ 4.0;\n        entity.fYaw = floor( entity.fYaw \/ fStepScale ) * fStepScale;\n        \n        setRandomTimer = true;\n    }\n    else\n    if ( iNewState == ENEMY_STATE_WALK_TO_TARGET )\n    {\n        Entity targetEnt = Entity_Read( STATE_CHANNEL, int(entity.fTarget) );\n        vec3 vToTarget = targetEnt.vPos - entity.vPos;\n        entity.fYaw = atan(vToTarget.x, vToTarget.z);\n        \n        float fStepScale = 3.14 \/ 4.0;\n        entity.fYaw = floor( entity.fYaw \/ fStepScale ) * fStepScale;\n        \n        setRandomTimer = true;\n    }\n    else\n    {\n        setRandomTimer = true;\n    }    \n\n    if ( setRandomTimer )\n    {\n    \tfloat fRandom = Hash( float(entity.iId) + iTime + 0.1 );        \n        entity.fTimer = 0.5 + fRandom * fRandom * 1.5;\n    }\n#endif \/\/ #ifndef CHEAT_NOAI        \n}\n\nvoid Enemy_SetRandomHostileState( inout Entity entity, bool notFire )\n{\n    float fRandom = Hash( float(entity.iId) + iTime );\n    \n    if ( !notFire && (fRandom < 0.2) )\n    {        \n        if ( notFire )\n        {\n        \tEnemy_SetState( entity, ENEMY_STATE_STAND );                    \n        }\n        else\n        {\n\t        Enemy_SetState( entity, ENEMY_STATE_FIRE );        \n        }\n\t}\n    else\n    if ( fRandom < 0.7 )\n    {\n        Entity targetEnt = Entity_Read( STATE_CHANNEL, int(entity.fTarget) );\n        vec3 vToTarget = targetEnt.vPos - entity.vPos;\n        \n        if ( length( vToTarget ) < 100.0 )\n        {\n        \tEnemy_SetState( entity, ENEMY_STATE_WALK_RANDOM );\n        }\n        else\n        {\n        \tEnemy_SetState( entity, ENEMY_STATE_WALK_TO_TARGET );\n\t\t}\n    }\n    else\n    {        \n        Enemy_SetState( entity, ENEMY_STATE_STAND );        \n\t}\n}\n\nbool Entity_CanHear( Entity entityA, Entity entityB )\n{\n    \/\/ Simple distance check for now...\n    \/\/ Could do sector coloring somehow?\n    if ( length( entityA.vPos - entityB.vPos ) < 400.0 ) \n    {\n        return true;\n    }\n    return false;\n}\n\nbool Entity_CanSee( Entity entityA, Entity entityB )\n{\n    vec3 vRayStart = entityA.vPos + vec3(0,32,0);\n    vec3 vRayEnd = entityB.vPos + vec3(0,32,0);            \n    vec3 vRayDir = normalize( vRayEnd - vRayStart );\n    float fDistToTarget = distance( vRayStart, vRayEnd );\n\tTraceResult traceResult = Map_Trace( MAP_CHANNEL, g_mapInfo, vRayStart, vRayDir, entityA.iSectorId, fDistToTarget );\n    return traceResult.fDist >= fDistToTarget;\n}\n\nbool Enemy_CanSee( inout Entity enemy, Entity target )\n{\n    vec3 vTargetPos = target.vPos;\n    vec3 vToTarget = vTargetPos - enemy.vPos;\n    float fAng = mod((degrees( atan( vToTarget.x, vToTarget.z ) - enemy.fYaw ) + 180.0), 360.0) - 180.0;\n\n    if ( abs( fAng ) < 45.0 )\n    {\n        \/\/ Line of sight check\n\n        if ( Entity_CanSee( enemy, target ) )\n        {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\nvoid Enemy_UpdateState(  inout Entity entity )\n{\n    int iState = Enemy_GetState( entity );\n    \n    if( entity.fHealth <= 0.0 )\n    {\n        Enemy_SetState( entity, ENEMY_STATE_DIE );\n        iState = ENEMY_STATE_DIE;\n    }\n\n    if ( iState == ENEMY_STATE_DIE )\n    {\n        if ( entity.fTimer == 0. )\n        {            \n            entity.iType = ENTITY_TYPE_DECORATION;\n            if ( entity.iSubType == ENTITY_SUB_TYPE_ENEMY_TROOPER )\n            {\n            \tentity.iSubType = ENTITY_SUB_TYPE_DECORATION_DEAD_TROOPER;\n    \t\t}\n            else\n            if ( entity.iSubType == ENTITY_SUB_TYPE_ENEMY_SERGEANT )\n            {\n            \tentity.iSubType = ENTITY_SUB_TYPE_DECORATION_DEAD_SERGEANT;\n    \t\t}\n            else\n            if ( entity.iSubType == ENTITY_SUB_TYPE_ENEMY_IMP )\n            {\n            \tentity.iSubType = ENTITY_SUB_TYPE_DECORATION_DEAD_IMP;\n    \t\t}\n            else\n            {\n            \tentity.iSubType = ENTITY_SUB_TYPE_DECORATION_BLOODY_MESS;            \n            }\n        }\n        \n        return;\n    }    \n     \n    \/\/ Check if can see player    \n    if ( int(entity.fTarget) == ENTITY_NONE )\n    {        \n\t\tEntity playerEnt = Entity_Read( STATE_CHANNEL, 0 );\n        \n        bool wakeUp = false;\n\n        if ( Enemy_CanSee( entity, playerEnt ) )\n        {\n\t\t\twakeUp = true;\n        }   \n\n        \/\/ Wake if player firing weapon\n        if ( !wakeUp )\n        {\n        \tif ( FlagSet( playerEnt.iFrameFlags, ENTITY_FRAME_FLAG_FIRE_WEAPON ) )\n            {\n                if ( Entity_CanHear( entity, playerEnt ) )\n                {\n\t                wakeUp  = true;\n\t\t\t\t}\n            }            \n        }\n\n        if ( wakeUp )\n        {\n            \/\/ target player \n            entity.fTarget = 0.;\n        \tEnemy_SetState( entity, ENEMY_STATE_STAND );\n            iState = ENEMY_STATE_STAND;            \n        }\n    }\n    \n    \n    if ( iState == ENEMY_STATE_IDLE )\n    {\n    }\n\telse\n    if ( iState == ENEMY_STATE_PAIN )\n    {\n        if ( entity.fTimer == 0. )\n        {\n            Enemy_SetState( entity, ENEMY_STATE_STAND );\n        }\n    }\n\telse\n    if ( \tiState == ENEMY_STATE_STAND ||\n        \tiState == ENEMY_STATE_FIRE ||\n        \tiState == ENEMY_STATE_WALK_TO_TARGET ||\n        \tiState == ENEMY_STATE_WALK_RANDOM\n       )\n    {\n        if ( int(entity.fTarget) != ENTITY_NONE )\n        {\n            Entity targetEnt = Entity_Read( STATE_CHANNEL, int(entity.fTarget) );\n\n            if ( targetEnt.fHealth <= 0.0 )\n            {\n                entity.fTarget = float( ENTITY_NONE );\n                Enemy_SetState( entity, ENEMY_STATE_IDLE );\n            }\n        }\n        \n        if ( entity.fTimer == 0. )\n        {\n            if ( iState == ENEMY_STATE_FIRE )\n            {\n\t            Enemy_SetRandomHostileState( entity, true );\n            }\n            else\n            {\n\t            Enemy_SetRandomHostileState( entity, false );\n            }                \n        }\n    }        \n}\n\nbool Entity_IsAlivePlayer( Entity entity )\n{\n    if ( entity.iType == ENTITY_TYPE_PLAYER )\n    {\n        if ( entity.fHealth > 0.0 )\n        {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\nbool Entity_CanReceiveDamage( Entity entity )\n{\n    if ( entity.iType == ENTITY_TYPE_BARREL )\n        return true;\n    \n    if ( Entity_IsAlivePlayer( entity ) )\n    {\n#ifdef CHEAT_GOD        \n        return false;\n#else\n        return true;\n#endif    \n    }\n    \n    if ( entity.iType == ENTITY_TYPE_ENEMY )\n    {\n        if ( Enemy_GetState(entity) == ENEMY_STATE_DIE )\n        {\n            return false;\n        }\n        \n        return true;\n    }\n    \n    return false;\n}\n\nvoid Entity_ApplyDamage( inout Entity entity, float fAmount, int iSourceId )\n{\n    if ( !Entity_CanReceiveDamage( entity ) )\n    {\n        return;\n    }\n    \n    if ( Entity_IsAlivePlayer( entity ) )\n    {\n        entity.fTookDamage += fAmount;\n        if ( entity.fHealth - fAmount <= 0.0 )\n        {\n            entity.fTimer = 1.5;\n            entity.iEvent = EVENT_DIED;\n        }\n    } \n    \n    float fArmorAbsorb = 0.;\n    \n    if ( Entity_IsAlivePlayer( entity ) )\n    {\n        fArmorAbsorb = min( fAmount, entity.fArmor );\n        entity.fArmor -= fArmorAbsorb;\n        fArmorAbsorb *= 0.25; \/\/ always absorb 25% (ignore special rules about blue armor)\n    }\n    \n    entity.fHealth -= (fAmount - fArmorAbsorb);\n    \n    Entity source = Entity_Read( STATE_CHANNEL, iSourceId );\n\n    if ( iSourceId != ENTITY_NONE )\n    {\n\t    entity.vVel.xz += normalize( entity.vPos.xz - source.vPos.xz ) * fAmount;\n    }\n\n    if ( entity.iType == ENTITY_TYPE_ENEMY )\n    {\n        if ( iSourceId != ENTITY_NONE )\n        {\n            if ( (source.iType == ENTITY_TYPE_ENEMY && entity.iSubType != source.iSubType)\n                || source.iType == ENTITY_TYPE_PLAYER )\n            {\n                \/\/ We are now riled with the attacker\n                entity.fTarget = float( iSourceId );\n            }\n        }\n        Enemy_SetState( entity, ENEMY_STATE_PAIN );\n    }                           \n}\n\nbool Entity_IsPlayerTarget( Entity entity )\n{\n    if ( \tentity.iType == ENTITY_TYPE_PLAYER ||\n       \t \tentity.iType == ENTITY_TYPE_BARREL || \n       \t\tentity.iType == ENTITY_TYPE_ENEMY )\n    {\n        return true;\n    }\n    \n    return false;\n}\n\nvoid Player_SelectTarget( inout Entity playerEnt )\n{\n    \/\/ Select target entity (used to aim shots up \/ down)\n    float fBiggestDot = cos( radians( 4.0 ) );\n    \n    float fClosest = FAR_CLIP;\n    \n    playerEnt.fTarget = float(ENTITY_NONE);\n    \n    vec2 vPlayerForwards = vec2( sin( playerEnt.fYaw ), cos( playerEnt.fYaw ) );\n    \n    for ( int iOtherEntityIndex=0; iOtherEntityIndex<int(ENTITY_MAX_COUNT); iOtherEntityIndex++ )\n    {\n        Entity otherEntity = Entity_Read( STATE_CHANNEL, iOtherEntityIndex );\n\n        if ( Entity_IsPlayerTarget( otherEntity ) )\n        {\n            vec3 vToTarget = otherEntity.vPos - playerEnt.vPos;\n            \n            float fDist = length( vToTarget.xz );\n            \n            if ( fDist < fClosest ) \n            {\n                vec2 vDirToTarget = normalize( vToTarget.xz );\n                float fDot = dot( vDirToTarget, vPlayerForwards );\n                \n                if ( fDot > fBiggestDot )\n                {\n                    fClosest = fDist;\n                    playerEnt.fTarget = float(iOtherEntityIndex);\n                }\n            }\n        }        \n    }    \n}\n\nvoid Entity_Think( inout Entity entity, float fTimestep )\n{\n    entity.fTimer = max( 0.0, entity.fTimer - fTimestep );    \n\n    float fMaxAccel = 1000.0;    \n    vec2 vIdealVel = vec2(0);\n    \n    bool bUseVelSteer = false;\n    \n    if ( entity.iType == ENTITY_TYPE_PLAYER )\n    {        \n        bUseVelSteer = true;\n                \n        if( entity.fHealth > 0.0 )\n        {\n            vec2 vDir = vec2(0.0);\n\n\n\n            if ( g_controls.moveForwards )\n            {\n                vDir.y += 1.0;\n            }\n            if ( g_controls.moveBackwards )\n            {\n                vDir.y -= 1.0;\n            }\n            if (g_controls.moveLeft || (g_controls.turnLeft && g_controls.strafe))\n            {\n                vDir.x -= 1.0;\n            }\n            if (g_controls.moveRight || (g_controls.turnRight && g_controls.strafe))\n            {\n                vDir.x += 1.0;\n            }\n\n            float fspeed = g_controls.run ? 250.0 : 150.0;\n            fMaxAccel = g_controls.run ? 2000.0 : 1000.0; \n            float fMaxYawVelAccel = g_controls.run ? 50.0 : 30.0;\n            float fTurnspeed = g_controls.run ? 3.5 : 1.5;\n\n            vDir *= fspeed;\n\n            vIdealVel.x = vDir.x * cos( entity.fYaw ) + vDir.y * sin( entity.fYaw );\n            vIdealVel.y = vDir.x * -sin( entity.fYaw ) + vDir.y * cos( entity.fYaw );\n\n            float fMouseSpeed = 1.0 \/ 180.0;\n            \n            vec2 vMouseDelta = (iMouse.xy - g_gameState.vPrevMouse.xy) * fMouseSpeed;\n            vec2 vMouseSign = sign(vMouseDelta);\n            vec2 vMouseAbs = abs(vMouseDelta);\n            vMouseAbs = pow( vMouseAbs, vec2(1.5));\n            vMouseDelta = vMouseAbs * vMouseSign;\n            if ( iMouse.z > 0.0 && g_gameState.vPrevMouse.z > 0.0 )\n            {\n            \tentity.fYaw += (vMouseDelta.x);\n                \n                if ( g_controls.toggleMouseLook )\n                {\n                    float fPitchInvert = g_controls.toggleInvertY ? -1.0 : 1.0;\n                    \n                \tentity.fPitch += (vMouseDelta.y) * fPitchInvert;\n                }\n                else\n                {\n                \tentity.fPitch = 0.0;\n                }\n                float fMaxPitch = radians(89.0);\n                entity.fPitch = clamp( entity.fPitch, -fMaxPitch, fMaxPitch);\n            }\n            \n            float fIdealYawVel = 0.0;\n\n            if ( g_controls.turnLeft && !g_controls.strafe )\n            {\n                fIdealYawVel -= 1.0;\n            }\n            if ( g_controls.turnRight && !g_controls.strafe )\n            {\n                fIdealYawVel += 1.0;\n            }\n\n            fIdealYawVel *= fTurnspeed;\n\n            float fToIdealYawVel = fIdealYawVel - entity.fYawVel;\n            entity.fYawVel += clamp( fToIdealYawVel, -fMaxYawVelAccel * fTimestep, fMaxYawVelAccel * fTimestep );        \n            \n            \/\/ Change weapon\n            {\n\t\t\t\tif ( g_controls.weap_2 )\n                {\n                    entity.fUseWeapon = 1.;\n                }\n                \n\t\t\t\tif ( g_controls.weap_3 )\n                {\n                    if ( entity.fHaveShotgun > 0. )\n                    {\n                    \tentity.fUseWeapon = 2.;\n                    }\n                }\n            }\n            \n            \n            \/\/ Fire weapon\n            if ( g_controls.fire )\n            {\n                if ( entity.fTimer == 0.0 )\n                {\n                    SetFlag( entity.iFrameFlags, ENTITY_FRAME_FLAG_FIRE_WEAPON );\n\n                    WeaponDef weaponDef = Entity_GetWeaponDef( entity );\n\n                    \/\/ reload time\n                    entity.fTimer = weaponDef.fReloadTime;\n                    \n                    Player_SelectTarget( entity );\n                }\n            }\n            \n            \/\/ Apply Nukage damage\n\t        #define TEX_NUKAGE 2u\n            Sector sector = Map_ReadSector( MAP_CHANNEL, entity.iSectorId );\n            if ( sector.iFloorTexture == TEX_NUKAGE )\n            {\n                float fCurrTime = g_gameState.fGameTime;\n                float fNextTime = fCurrTime + fTimestep;\n                \/\/ apply damage every second\n                if ( floor( fCurrTime ) != floor( fNextTime ) )\n                {\n                    \/\/ 5 damage per second\n                \tEntity_ApplyDamage( entity, 5.0, ENTITY_NONE );\n                }\n            }                           \n        }\n        else\n        {\n            entity.fYawVel *= pow( 0.3, fTimestep );\n        }\n    }    \n    else if ( entity.iType == ENTITY_TYPE_ENEMY )\n    {\n        bUseVelSteer = true;\n        fMaxAccel = 50.;\n        \n        Enemy_UpdateState( entity );\n        \n        int iState = Enemy_GetState( entity );\n        \n        if ( iState == ENEMY_STATE_FIRE )\n        {\n            Entity targetEnt = Entity_Read( STATE_CHANNEL, int(entity.fTarget) );\n            vec3 vToTarget = targetEnt.vPos - entity.vPos;\n            entity.fYaw = atan(vToTarget.x, vToTarget.z);\n        }\n        \n        if ( iState == ENEMY_STATE_WALK_TO_TARGET || iState == ENEMY_STATE_WALK_RANDOM )\n        {\n            float fWalkSpeed = 50.;\n            vIdealVel.x = sin( entity.fYaw ) * fWalkSpeed;\n            vIdealVel.y = cos( entity.fYaw ) * fWalkSpeed;\n        }     \n    }    \n    else if ( entity.iType == ENTITY_TYPE_BARREL )\n    {\n        entity.vVel *= pow( 0.3, fTimestep );\n        \n        if( entity.fHealth <= 0.0 )\n        {\n            if ( entity.iSubType == ENTITY_SUB_TYPE_BARREL_INACTIVE )\n            {\n                entity.iSubType = ENTITY_SUB_TYPE_BARREL_EXPLODING;\n                entity.fTimer = 1.0;\n            }\n            else\n            if ( entity.iSubType == ENTITY_SUB_TYPE_BARREL_EXPLODING )\n            {\n                if ( entity.fTimer <= 0.0 )\n                {\n\t                entity.iSubType = ENTITY_SUB_TYPE_BARREL_APPLY_DAMAGE;\n                }\n            }\n            else\n            {\n\t\t\t\tEntity_Clear( entity );                                    \n            }\n        }        \n    }    \n    else if ( entity.iType == ENTITY_TYPE_BULLET )\n    {\n        entity.fTarget = -1.; \/\/ Clear target (only deal damage for first frame)\n        if ( entity.fTimer <= 0.0 )\n        {\n            Entity_Clear( entity );\n        }\n    }\n    else if ( entity.iType == ENTITY_TYPE_FIREBALL )\n    {\n        if ( entity.fTimer <= 0.0 )\n        {\n            Entity_Clear( entity );\n        }\n    }\n    else if ( entity.iType == ENTITY_TYPE_DOOR )\n    {        \n        Entity playerEnt = Entity_Read( STATE_CHANNEL, 0 );\n        \n        bool bPlayerNearby = (distance(entity.vPos.xz, playerEnt.vPos.xz) < 100. );\n        bool bTrigger = g_controls.open && bPlayerNearby;\n        \n        float fOpenDist = entity.fTarget - entity.vPos.y;\n        \n        \/\/ Door state machine\n        if ( entity.iSubType == 0 )\n        {\n\t        \/\/ Closed        \n            if ( bTrigger )\n            {\n                entity.iSubType = 1;\n            }\n        }\n        else\n        if ( entity.iSubType == 1 )\n        {\n\t        \/\/ Opening\n            fOpenDist += 40.0 * fTimestep;\n            \n            if ( fOpenDist >= 80.0 )\n            {\n                fOpenDist = 80.0;\n                entity.iSubType = 2;\n                \n                entity.fTimer = 5.;\n            }\n        }\n        else\n        if ( entity.iSubType == 2 )\n        {\n\t        \/\/ Open\n            if ( bTrigger || entity.fTimer == 0.0 )\n            {\n                entity.iSubType = 3;\n            }\n        }\n        else\n        if ( entity.iSubType == 3 )\n        {\n\t        \/\/ Closing\n            fOpenDist -= 40.0 * fTimestep;\n            \n            if ( fOpenDist <= 0.0 )\n            {\n                fOpenDist = 0.0;\n                entity.iSubType = 0;\n            }\n            \n            if ( bTrigger )\n            {\n                entity.iSubType = 1;\n            }            \n        }\n        \n        entity.fTarget = fOpenDist + entity.vPos.y;        \n    }\n    else\n    if ( entity.iType == ENTITY_TYPE_PLATFORM )\n    {\n        Entity playerEnt = Entity_Read( STATE_CHANNEL, 0 );\n        \n        bool bPlayerNearby = (distance(entity.vPos.xz, playerEnt.vPos.xz) < 150. );\n        \n        float fOpenDist = entity.fTarget;\n        \/\/ Hack - params from spawn data yaw\n        float fSpawnYaw = 90. - degrees(entity.fYaw);\n        float fMoveSpeed = abs(fSpawnYaw);\n        bool bStaysLowered = fSpawnYaw < 0.0;\n        \n        \/\/ Hack - both platforms on this level go to this height\n        float fFinalFloorHeight = -48.;\n        \n        if ( entity.iSubType == 0 )\n        {\n            \/\/ Platform is Up\n            \n            if ( bPlayerNearby )\n            {\n                entity.iSubType = 1;\n            }\n        }\n        else if ( entity.iSubType == 1 )\n        {\n            \/\/ Platform is Lowering\n            fOpenDist -= fMoveSpeed * fTimestep;\n            \n            if ( fOpenDist < fFinalFloorHeight )\n            {\n                fOpenDist = fFinalFloorHeight;\n                entity.iSubType = 2;\n                \n                entity.fTimer = 5.;\n            }            \n        }\n        else if ( entity.iSubType == 2 )\n        {\n            \/\/ Platform is Down\n            if ( !bStaysLowered )\n            {\n                if ( entity.fTimer == 0.0 )\n                {\n                    entity.iSubType = 3;\n                }            \n            }\n        }\n        else if ( entity.iSubType == 3 )\n        {\n            \/\/ Platform is Raising\n            fOpenDist += fMoveSpeed * fTimestep;\n            \n            if ( fOpenDist > entity.vPos.y )\n            {\n                fOpenDist = entity.vPos.y;\n                entity.iSubType = 0;\n            }            \n        }\n        \n        entity.fTarget = fOpenDist;\n        \n        \/\/entity.fTarget = sin( iTime ) * 100.0;\n    }\n    \n    if ( bUseVelSteer )\n    {\n        vec2 vToIdealVel = vIdealVel - entity.vVel.xz;\n        float len = length( vToIdealVel );\n\n        if ( len > 0.0 )\n        {\n            entity.vVel.xz += normalize(vToIdealVel) * clamp( len, 0.0, fMaxAccel * fTimestep );\n        }        \n    }\n}\n\nbool CanBePushed( Entity entity, Entity otherEntity )\n{\n    if ( Entity_IsAlivePlayer( entity ) )\n    {\n        if ( (otherEntity.iType == ENTITY_TYPE_ENEMY && Enemy_GetState( otherEntity ) != ENEMY_STATE_DIE ) ||\n             (otherEntity.iType == ENTITY_TYPE_BARREL) ||\n             (otherEntity.iType == ENTITY_TYPE_DECORATION && otherEntity.iSubType == ENTITY_SUB_TYPE_DECORATION_FLOOR_LAMP)\n           )\n        {\n            return true;\n        }\n    }\n    else if ( entity.iType == ENTITY_TYPE_ENEMY )\n    {\n        if (    (otherEntity.iType == ENTITY_TYPE_ENEMY)\n             || (otherEntity.iType == ENTITY_TYPE_BARREL)\n             \/\/|| (otherEntity.fType == ENTITY_TYPE_PLAYER)\n           )\n        {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\nvoid Entity_Collide( inout Entity entity, Entity otherEntity, float fTimestep )\n{\n    \/\/ True if we can be pushed\n    if ( CanBePushed( entity, otherEntity ) )\n    {\n        vec2 vDeltaPos = entity.vPos.xz - otherEntity.vPos.xz;\n        vec2 vDeltaVel = entity.vVel.xz - otherEntity.vVel.xz;\n\n        float fLen = length( vDeltaPos );\n        float fVelLen = length(vDeltaVel);\n        float fCombinedRadius = 20.0;\n        if ( fLen > 0.0 && fLen < fCombinedRadius )\n        {\n            vec2 vNormal = normalize(vDeltaPos);\n            \n            if ( fVelLen > 0.0 )\n            {\n                float fProj = dot( vNormal, vDeltaVel );\n\n                if ( fProj < 0.0 )\n                {\n                    \/\/ cancel vel in normal dir\n                    vec2 vImpulse = -fProj * vNormal;\n                    \n                    \/\/ Push away\n                    float fPenetration = fCombinedRadius - fLen;\n                    vImpulse += vNormal * fPenetration * 5.0 * fTimestep;\n                    \n                    \n\t\t\t\t    if ( CanBePushed( otherEntity, entity ) )\n                    {\n                    \tentity.vVel.xz += vImpulse * 0.5;\n                    }\n                    else\n                    {\n                    \tentity.vVel.xz += vImpulse;\n                    }\n                }\n            }            \n        }        \n    }    \n}\n\nvoid Player_GiveHealth( inout Entity entity, float fAmount, bool mega )\n{    \n    if ( mega )\n    {\n\t    entity.fHealth = min( entity.fHealth + fAmount, 200.0 );\n    }\n    else\n    {\n        if ( entity.fHealth < 100.0 )\n        {\n\t\t    entity.fHealth = min( entity.fHealth + fAmount, 100.0 );\n        }\n\t}\n}\n\nvoid Player_GiveArmor( inout Entity entity, float fAmount, bool mega )\n{\n    if ( mega )\n    {\n\t    entity.fArmor = min( entity.fArmor + fAmount, 200.0 );\n    }\n    else\n    {\n        if ( entity.fArmor < 100.0 )\n        {\n\t\t    entity.fArmor = min( entity.fArmor + fAmount, 100.0 );\n        }\n\t}\n\n}\n\n#define PICKUP_RADIUS 25.\n\nbool Fireball_Hit( Entity fireball, Entity other )\n{\n    if ( fireball.iSubType == ENTITY_SUB_TYPE_FIREBALL  )\n    {\n        if ( other.iId != int(fireball.fArmor) )\n        {                    \t\n            if ( Entity_CanReceiveDamage( other ) )\n            {\n                if ( length( other.vPos.xz - fireball.vPos.xz ) < (12. + 16.0) )\n                {\n                \treturn true;\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n            \nvoid Entity_Interact( inout Entity entity, float fTimestep )\n{    \n    \/\/ Apply actions to this entity based on every other entity\n    \n    float fSpawnQueueSlot = 0.0;\n    \n    for ( int iOtherEntityIndex=0; iOtherEntityIndex<int(ENTITY_MAX_COUNT); iOtherEntityIndex++ )\n    {\n        Entity otherEntity = Entity_Read( STATE_CHANNEL, iOtherEntityIndex );\n\n        if ( entity.iType == ENTITY_TYPE_NONE )\n        {\n            if ( iOtherEntityIndex == entity.iId )\n            {\n\t            entity.fTarget = fSpawnQueueSlot;                \n    \t        break;\n            }\n\n\t        \/\/ Set this entity's position in spawn queue\n            if ( otherEntity.iType == ENTITY_TYPE_NONE )\n            {\n                fSpawnQueueSlot++;\n            }                    \n        }\n        else\n        {        \n            \/\/ Ignore self\n            if ( iOtherEntityIndex == entity.iId )\n            {\n                continue;\n            }\n\n            Entity_Collide( entity, otherEntity, fTimestep );\n\n            if ( Entity_IsAlivePlayer( entity ) )\n            {\n                if ( otherEntity.iType == ENTITY_TYPE_ITEM )\n                {\n                    if ( distance(entity.vPos.xz, otherEntity.vPos.xz) < PICKUP_RADIUS)\n                    {\n                        if( otherEntity.iSubType == ENTITY_SUB_TYPE_ITEM_HEALTH_BONUS )\n                        {\n                            Player_GiveHealth( entity, 1.0, true );\n\t\t\t\t            entity.iEvent = EVENT_HEALTH_BONUS;                            \n                        }\n                        else\n                        if( otherEntity.iSubType == ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS )\n                        {\n                            Player_GiveArmor( entity, 1.0, false );\n\t\t\t\t            entity.iEvent = EVENT_ARMOR_BONUS;                            \n                        }\n                        else\n                        if ( otherEntity.iSubType == ENTITY_SUB_TYPE_ITEM_MEDIKIT )\n                        {\n                            Player_GiveHealth( entity, 25.0, false );\n\t\t\t\t            entity.iEvent = EVENT_MEDIKIT;                            \n                        }\n                        else\n                        if ( otherEntity.iSubType == ENTITY_SUB_TYPE_ITEM_STIMPACK )\n                        {\n                            Player_GiveHealth( entity, 10.0, false );\n\t\t\t\t            entity.iEvent = EVENT_STIMPACK;\n                        }\n                        else\n                        if ( otherEntity.iSubType == ENTITY_SUB_TYPE_ITEM_GREENARMOR )\n                        {\n                            Player_GiveArmor( entity, 100.0, false );\n\t\t\t\t            entity.iEvent = EVENT_GREENARMOR;\n                        }\n                        else\n                        if ( otherEntity.iSubType == ENTITY_SUB_TYPE_ITEM_BLUEARMOR )\n                        {\n                            Player_GiveArmor( entity, 200.0, true );\n\t\t\t\t            entity.iEvent = EVENT_BLUEARMOR;\n                        }\n                        else\n                        if ( otherEntity.iSubType == ENTITY_SUB_TYPE_ITEM_SHOTGUN )\n                        {\n                            if ( entity.fHaveShotgun == 0. )\n                            {\n\t                    \t\tentity.fUseWeapon = 2.;                        \n\t\t\t\t\t            entity.iEvent = EVENT_SHOTGUN;\n                            }\n                            \t\n                            entity.fHaveShotgun = 1.;\n                        }\n                    }\n                }\n            }\n            else\n            if ( entity.iType == ENTITY_TYPE_ITEM )\n            {\n                if ( Entity_IsAlivePlayer( otherEntity ) )\n                {\n                    if ( distance(entity.vPos.xz, otherEntity.vPos.xz) < PICKUP_RADIUS)\n                    {\n                        entity.iType = ENTITY_TYPE_NONE;\n                    }\n                }\n            }\n            if ( entity.iType == ENTITY_TYPE_FIREBALL )\n            {\n                if ( Fireball_Hit( entity, otherEntity ) )\n                {\n                    entity.iSubType = ENTITY_SUB_TYPE_FIREBALL_IMPACT;\n                    entity.fTimer = 0.3;\n                }\n            }\n            \n            \/\/ Process damage from other\n            if ( otherEntity.iType == ENTITY_TYPE_BULLET )\n            {\n                \/\/ Bullet is applying damage to this entity\n                if ( otherEntity.fTarget == float(entity.iId) )\n                {\n                    Entity_ApplyDamage( entity, otherEntity.fHealth, int( otherEntity.fArmor ) );\n                }\n            }\n            else\n            if ( otherEntity.iType == ENTITY_TYPE_FIREBALL )\n            {\n                if ( Fireball_Hit( otherEntity, entity ) )\n                {\n                    Entity_ApplyDamage( entity, otherEntity.fHealth, int( otherEntity.fArmor ) );\n                }\n            }\n            else\n            if ( otherEntity.iType == ENTITY_TYPE_BARREL && otherEntity.iSubType == ENTITY_SUB_TYPE_BARREL_APPLY_DAMAGE )\n            {\n                \/\/ Todo : trace?\n                float fBlastRadius = 250.0;\n                float fMaxDamage = 50.0;\n                \n                vec3 vSeparation = entity.vPos - otherEntity.vPos;\n                float fDamage = fMaxDamage * clamp( 1.0 - length( vSeparation.xz ) \/ fBlastRadius, 0.0, 1.0 );\n                \n                if ( Entity_CanSee( otherEntity, entity ) )\n                {\n\t\t\t\t    Entity_ApplyDamage( entity, fDamage, otherEntity.iId );\n                }\n            }\n        }        \n    }\n}\n\nvoid Entity_Move( inout Entity entity, float fTimestep )\n{    \n    if( ( entity.iType == ENTITY_TYPE_PLAYER ) \t||\n        ( entity.iType == ENTITY_TYPE_ENEMY ) \t||\n        ( entity.iType == ENTITY_TYPE_BARREL )\n      )\n    {\n        \/\/vec2 vPrevPos = entity.vPos.xz;\n\n        Entity_UpdateSlideBox( entity, fTimestep );\n\n        \/\/Map_UpdateSector( g_mapInfo, vPrevPos, entity.vPos.xz, entity.fSectorId );\n    }\n    \n    if( ( entity.iType == ENTITY_TYPE_PLAYER )\t||\n        ( entity.iType == ENTITY_TYPE_ENEMY )  \t||\n        ( entity.iType == ENTITY_TYPE_BARREL ) \t|| \n        ( entity.iType == ENTITY_TYPE_ITEM ) \t||\n        ( entity.iType == ENTITY_TYPE_DECORATION )\n      )\n    {\n    \tEntity_Fall( entity, fTimestep );    \n    }\n    \n    if ( entity.iType == ENTITY_TYPE_BULLET )\n    {\n        entity.vPos.y += 10.0 * fTimestep;\n    }\n    \n    if ( entity.iType == ENTITY_TYPE_FIREBALL )\n    {\n        if ( entity.iSubType == ENTITY_SUB_TYPE_FIREBALL )\n        {\n\t        vec2 vPrevPos = entity.vPos.xz;\n\n            float fMaxTraceDist = length( entity.vVel ) * fTimestep;\n            vec3 vDir = normalize( entity.vVel );\n\n            TraceResult traceResult = Map_Trace( MAP_CHANNEL, g_mapInfo, entity.vPos, vDir, entity.iSectorId, fMaxTraceDist );\n\n            if ( traceResult.fDist > 0.0 )\n            {\n            \tentity.vPos += vDir * traceResult.fDist;\n            }\n\n        \tMap_UpdateSector( MAP_CHANNEL, g_mapInfo, vPrevPos, entity.vPos.xz, entity.iSectorId );\n            \n            if ( traceResult.fDist > 0.0 && traceResult.fDist < fMaxTraceDist  )\n            {\n                entity.iSubType = ENTITY_SUB_TYPE_FIREBALL_IMPACT;\n                entity.fTimer = 0.3;\n            }\n\t\t}\n    }\n}\n\nfloat RayCircleIntersect( vec2 vRayOrigin, vec2 vRayDir, vec2 vCircleOrigin, float fRadius2 )\n{\n    vec2 vRayOriginToCircleOrigin = vCircleOrigin - vRayOrigin;\n    float fProjection = dot( vRayOriginToCircleOrigin, vRayDir );        \n    vec2 vClosestPos = vRayOrigin + vRayDir * fProjection;\n    vec2 vClosestToCircle = vCircleOrigin - vClosestPos;\n    float fClosestDist2 = dot( vClosestToCircle, vClosestToCircle );\n    if ( fClosestDist2 < fRadius2 )\n    {\n        float fHalfChordLength = sqrt( fRadius2 - fClosestDist2 );\n        float fHitT = fProjection - fHalfChordLength;\n\n        return fHitT;\n\t}\n\n    return -1.0;\n}\n\nfloat Entity_Trace( vec3 vRayOrigin, vec3 vRayDir, int iIgnoreEnt, out Entity hitEntity )\n{\n    hitEntity.iId = -1;\n    float fHitEntityDist = FAR_CLIP;\n    \n    float fOrigDirLen = length( vRayDir.xz );\n    \n    vec2 vFlatRayDir = vRayDir.xz \/ fOrigDirLen;\n\n    for ( int iTraceEntityIndex=0; iTraceEntityIndex<int(ENTITY_MAX_COUNT); iTraceEntityIndex++ )\n    {\n        if ( iTraceEntityIndex == iIgnoreEnt )\n            continue;\n        \n        Entity entity = Entity_Read( STATE_CHANNEL, iTraceEntityIndex );\n\n        \n        \/\/ TODO: Entity_GetSize function?\n        float fRadius = 0.0;\n        float fHeight = 0.0;\n        if ( entity.iType == ENTITY_TYPE_BARREL )\n        {\n            fRadius = 12.0;\n            fHeight = 32.0;            \n        }\n        \n        if ( entity.iType == ENTITY_TYPE_ENEMY || entity.iType == ENTITY_TYPE_PLAYER )\n        {\n            fRadius = 15.0;\n            fHeight = 54.0;            \n        }\n \n        if ( fRadius > 0.0 )\n        {\n            float fHitT = RayCircleIntersect( vRayOrigin.xz, vFlatRayDir, entity.vPos.xz, fRadius * fRadius );\n            fHitT \/= fOrigDirLen;\n\t\t\tif ( fHitT > 0.0 && fHitT < fHitEntityDist )\n            {\n                float fEntHitY = vRayOrigin.y + vRayDir.y * fHitT - entity.vPos.y;\n                \n                if ( fEntHitY > 0. && fEntHitY < fHeight )\n                {\n                    fHitEntityDist = fHitT;\n                    hitEntity = entity;\n                }\n            }\n \t   }\n\t}\n    \n    return fHitEntityDist;\n}\n\nint Entity_GetSpawnQueueSlotType( int iSpawnQueueSlot, inout Entity spawningEntity, out int iSpawnSubType )\n{\n    iSpawnSubType = 0;\n    \n    int iOtherSpawnQueueSlot = 0;\n    for ( int iOtherEntityIndex=0; iOtherEntityIndex<int(ENTITY_MAX_COUNT); iOtherEntityIndex++ )\n    {\n        spawningEntity = Entity_Read( STATE_CHANNEL, iOtherEntityIndex );\n\n        \/\/ spawn fired bullets\n        if ( FlagSet( spawningEntity.iFrameFlags, ENTITY_FRAME_FLAG_FIRE_WEAPON ) )\n        {\n            WeaponDef weaponDef = Entity_GetWeaponDef( spawningEntity );\n\n            int iNewSlot = iOtherSpawnQueueSlot + weaponDef.iProjectileCount;\n            if ( iNewSlot >= iSpawnQueueSlot ) \n            {\n                if ( weaponDef.fWeaponType == WEAPON_TYPE_FIREBALL )\n                {\n\t                return ENTITY_TYPE_FIREBALL;\n                }\n                else\n                {\n\t                return ENTITY_TYPE_BULLET;\n                }                    \n            }\n            iOtherSpawnQueueSlot = iNewSlot;\n        }\n        \n        \/\/ spawn dropped items\n        \/\/ spawn fired bullets\n        if ( FlagSet( spawningEntity.iFrameFlags, ENTITY_FRAME_FLAG_DROP_ITEM ) )\n        {\n            bool doSpawn = false;\n            \n            if ( spawningEntity.iSubType == ENTITY_SUB_TYPE_ENEMY_SERGEANT )\n            {\n                iSpawnSubType = ENTITY_SUB_TYPE_ITEM_SHOTGUN;\n                doSpawn = true;\n            }\n            \n            if ( doSpawn )\n            {\n                int iNewSlot = iOtherSpawnQueueSlot + 1;\n                if ( iNewSlot >= iSpawnQueueSlot ) \n                {                \n                    return ENTITY_TYPE_ITEM;                    \n                }\n\t            iOtherSpawnQueueSlot = iNewSlot;\n            }\n        }\n        \n    }\n    \n    return ENTITY_TYPE_NONE;\n}\n\nbool Entity_SpawnOther( inout Entity entity )\n{\n    if ( entity.iType == ENTITY_TYPE_NONE )\n    {\n        Entity spawningEntity;\n        \n        int iSpawnQueueSlot = int(entity.fTarget);\n        int iSpawnSubType;\n        int iSpawnType = Entity_GetSpawnQueueSlotType( iSpawnQueueSlot, spawningEntity, iSpawnSubType );\n        \n        if ( iSpawnType == ENTITY_TYPE_BULLET )\n        {\n            Entity_Clear( entity );\n            entity.iType = ENTITY_TYPE_BULLET;\n            entity.iSubType = ENTITY_SUB_TYPE_BULLET_WALL;\n            \n            WeaponDef weaponDef = Entity_GetWeaponDef( spawningEntity );\n            \n            vec3 vRayOrigin = spawningEntity.vPos + vec3(0,40.,0);\n            \/\/ adjust Y to aim at target\n            float dy = tan(spawningEntity.fPitch);\n            if ( int(spawningEntity.fTarget) != ENTITY_NONE )\n            {\n\t\t        Entity targetEntity;\n                \n                targetEntity = Entity_Read( STATE_CHANNEL, int(spawningEntity.fTarget) );\n                \n                vec3 vTargetPos = targetEntity.vPos;\n                \n                if( targetEntity.iType == ENTITY_TYPE_BARREL )\n                {\n                    vTargetPos.y += 30.0;\n                }\n                else\n                {\n                    vTargetPos.y += 40.0;                    \n\t\t\t\t}\n                \n                vec3 vToTarget = vTargetPos - vRayOrigin;\n                dy = vToTarget.y \/ length(vToTarget.xz);\n            }\n            float fSRand = Hash( float(iSpawnQueueSlot) + iTime) * 2.0 - 1.0;\n            float fSpread = weaponDef.fSpread;\n            float fYaw = spawningEntity.fYaw + fSRand * fSpread;            \n            vec3 vRayDir = normalize( vec3(sin(fYaw), dy, cos(fYaw)) );\n\n            Entity hitEntity;\n            float fHitDist = Entity_Trace( vRayOrigin, vRayDir, spawningEntity.iId, hitEntity );\n            \n            TraceResult traceResult = Map_Trace( MAP_CHANNEL, g_mapInfo, vRayOrigin, vRayDir, spawningEntity.iSectorId, fHitDist );\n\t\t\t\n            if ( hitEntity.iType == ENTITY_TYPE_ENEMY || hitEntity.iType == ENTITY_TYPE_PLAYER )\n            {\n\t            entity.iSubType = ENTITY_SUB_TYPE_BULLET_FLESH;                \n            }\n            \n            \/\/ Not sure why this > 0 test is required. Oh well...\n            if ( traceResult.fDist > 0.0 &&  traceResult.fDist < fHitDist  )\n            {\n                fHitDist = traceResult.fDist;\n                hitEntity.iId = -1;\n\t            entity.iSubType = ENTITY_SUB_TYPE_BULLET_WALL;\n            }\n            \n            entity.vPos = vRayOrigin + vRayDir * fHitDist + vec3(0,-8,0);\n            float fRand = Hash(float(iSpawnQueueSlot) + iTime + 1.234);\n            entity.fHealth = weaponDef.fBaseDamagePerProjectile + weaponDef.fRandomDamagePerProjectile * fRand; \/\/ Damage to deal\n            entity.fTimer = 0.3; \/\/ Impact effect timer\n            entity.fTarget = float( hitEntity.iId ); \/\/ Which entity did we hit (cleared on first frame)\n            entity.fArmor = float( spawningEntity.iId ); \/\/ Who fired the bullet\n            entity.iSectorId = traceResult.iSector;\n\n            return true;\n        }\n        else\n        if ( iSpawnType == ENTITY_TYPE_FIREBALL )\n        {\n            Entity_Clear( entity );\n            entity.iType = ENTITY_TYPE_FIREBALL;\n            entity.iSubType = ENTITY_SUB_TYPE_FIREBALL;\n            \n            WeaponDef weaponDef = Entity_GetWeaponDef( spawningEntity );\n            \n            entity.vPos = spawningEntity.vPos + vec3(0,40.,0);\n            \/\/ adjust Y to aim at target\n            float dy = 0.0;\n            if ( int(spawningEntity.fTarget) != ENTITY_NONE )\n            {\n\t\t        Entity targetEntity;\n                \n                targetEntity = Entity_Read( STATE_CHANNEL, int( spawningEntity.fTarget ) );\n                \n                vec3 vTargetPos = targetEntity.vPos;\n                \n                if( targetEntity.iType == ENTITY_TYPE_BARREL )\n                {\n                    vTargetPos.y += 30.0;\n                }\n                else\n                {\n                    vTargetPos.y += 40.0;                    \n\t\t\t\t}\n                \n                vec3 vToTarget = vTargetPos - entity.vPos;\n                dy = vToTarget.y \/ length(vToTarget.xz);\n            }\n            float fSRand = Hash( float(iSpawnQueueSlot) + iTime) * 2.0 - 1.0;\n            float fSpread = weaponDef.fSpread;\n            float fYaw = spawningEntity.fYaw + fSRand * fSpread;            \n            entity.vVel = normalize( vec3(sin(fYaw), dy, cos(fYaw)) );\n            float fMoveSpeed = 200.0;\n            entity.vVel *= fMoveSpeed;\n\n            entity.fHealth = weaponDef.fBaseDamagePerProjectile; \/\/ Damage to deal\n            entity.fTimer = 5.0; \/\/ Travel timeout\n            entity.fArmor = float( spawningEntity.iId ); \/\/ Who fired the bullet\n            entity.iSectorId = spawningEntity.iSectorId;\n\n            return true;\n        }\n        else\n        if ( iSpawnType == ENTITY_TYPE_ITEM )\n        {\n            Entity_Clear( entity );\n            entity.iType = ENTITY_TYPE_ITEM;\n            entity.iSubType = iSpawnSubType;\n            entity.vPos = spawningEntity.vPos + vec3(0, 24, 0);\n            entity.vVel = vec3(0, 2, 0);\n            entity.iSectorId = spawningEntity.iSectorId;\n            \n            return true;\n        }            \n    }\n    \n    return false;\n}\n\nvoid Entity_Update( inout Entity entity, float fTimestep )\n{    \n    entity.iFrameFlags = 0;\n    entity.iEvent = 0;\n    entity.fTookDamage = 0.;\n\n    \/\/ This is first to ensure consistent state\n    if( Entity_SpawnOther( entity ) )\n    {\n        return;\n    }\n        \n    Entity_Think( entity, fTimestep );\n\n    Entity_Interact( entity, fTimestep );\n    \n    Entity_Move( entity, fTimestep );    \n}\n\nvec4 DrawMap( vec2 vTexCoord )\n{\n    if ( vTexCoord.y < 0.0 )\n    {\n        return vec4(0,0,0,1);\n    }    \n        \n    float fScale = 10.0;\n        \n    vec2 vPixelWorldPos = vTexCoord;    \n    vPixelWorldPos -= vec2(200, 150); \n    vPixelWorldPos *= fScale;\n    vPixelWorldPos += vec2(1056, -3616);\n    \n    fScale *= 1.1;\n    \n    \/\/for(int iSectorIndex=0; iSectorIndex<MAX_SECTOR_COUNT; iSectorIndex++)\n    for(int iSectorIndex=0; iSectorIndex < g_mapInfo.iSectorCount; iSectorIndex++)\n    {\n        \/\/if ( iSectorIndex > g_mapInfo.iSectorCount )\n          \/\/  break;\n\n        Sector sector = Map_ReadSector( MAP_CHANNEL, iSectorIndex );\n\n        \/*if ( Map_PointInSector( vPixelWorldPos, sector ) )\n{\nvResult = vec3(1,0,0);\n}*\/\n\n\n        for(int iSideDefIndex=0; iSideDefIndex<sector.iSideDefCount; iSideDefIndex++)\n        {\n            SideDef sideDef = Map_ReadSideDefInfo( MAP_CHANNEL, iSectorIndex, iSideDefIndex );                        \n\n            vec2 vSideDir = normalize( sideDef.vB - sideDef.vA );\n\n            float fProj = dot( vSideDir, vPixelWorldPos - sideDef.vA );\n            fProj = clamp( fProj, 0.0, sideDef.fLength );\n\n            vec2 vClosest = sideDef.vA + vSideDir * fProj;\n            float fDist = length( vClosest - vPixelWorldPos );\n\n            if (fDist < fScale * .5 )\n            {\n                if ( sideDef.iNextSector != SECTOR_NONE )\n                {\n                    return vec4(1,1,0,1);\n                }\n                else\n                {\n                    return vec4(1,0,0,1);\n                }\n            }\n        }\t\t\t\n    }\n        \n    return vec4(0.0);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    fragColor = vec4(0.0);\n\n    g_controls = ReadControls();\n    \n    g_mapInfo = ReadMapInfo( MAP_CHANNEL );\n    g_gameState = GameState_Read( STATE_CHANNEL );\n    \n    float fTimestep = iTimeDelta;\/\/1.0 \/ 60.0;\n\n    bool bShouldOutputGameState = all( lessThanEqual( floor(fragCoord.xy), vec2( 2, 0 ) ) );\n    int iOutputEntityId = Entity_GetOutputId( fragCoord );\n    bool bShouldOutputEntity = Entity_IdValid( iOutputEntityId );\n    \n    if ( !bShouldOutputEntity && !bShouldOutputGameState )\n    {\n#ifdef ALLOW_MAP        \n        if ( iFrame != 1 )\n#endif            \n        {\n        \tfragColor = texelFetch( iChannel1, ivec2(floor(fragCoord)), 0 );\n\t        return;\n        }\n        \n#ifdef ALLOW_MAP        \n        fragColor = DrawMap( fragCoord - vec2(0, 32));\n        return;\n#endif        \n        \n        \/\/fragColor.rgb = vec3( 1,0,0);\n        \/\/discard;\n    }\n    \n    if ( bShouldOutputGameState )\n    {\n        if ( iFrame == 0 )\n        {\n            GameState_Reset( g_gameState, iMouse );\n        }        \n    }\n    int iMainGameState = g_gameState.iMainState;\n        \n    if ( bShouldOutputEntity )\n    {\n        Entity outputEntity;\n        outputEntity = Entity_Read( STATE_CHANNEL, iOutputEntityId );\n        \n        if ( iMainGameState == MAIN_GAME_STATE_BOOT )\n        {\n            Entity_Clear( outputEntity );\n        }\n\n        if ( iMainGameState == MAIN_GAME_STATE_INIT_LEVEL )\n        {\n            Entity_MapSpawn( outputEntity, iOutputEntityId );\n        }               \n        else if ( iMainGameState == MAIN_GAME_STATE_GAME_RUNNING )\n        {        \n        \tEntity_Update( outputEntity, fTimestep );\n        }\n        \n        Entity_Store( outputEntity, fragColor, fragCoord );        \n    }\n    \n    if ( bShouldOutputGameState )\n    {\n        \/\/ Update GameState  \n\n        Entity playerEnt;\n        playerEnt = Entity_Read( STATE_CHANNEL, 0 );\n                \n\t\tg_gameState.fStateTimer += fTimestep;\n        \n        if ( iMainGameState == MAIN_GAME_STATE_BOOT )\n        {\n            g_gameState.iMainState = MAIN_GAME_STATE_SKILL_SELECT;\t\t\t\n        }\n        \n        if ( iMainGameState == MAIN_GAME_STATE_SKILL_SELECT )\n        {\n            if ( g_controls.menuConfirm || g_gameState.fStateTimer > 2.0 )\n            {\n                g_gameState.iMainState = MAIN_GAME_STATE_INIT_LEVEL;\n\t            g_gameState.fStateTimer = 0.0;\n            }            \n        }\n        \n        if ( iMainGameState == MAIN_GAME_STATE_GAME_RUNNING )\n        {\n        \tg_gameState.fGameTime += fTimestep;        \n\n            \n            bool bPlayerNearExit = (distance( playerEnt.vPos.xz, vec2( 2930, -4768 ) ) < 100.0);        \n            if ( bPlayerNearExit && g_controls.open )\n            {\n                g_gameState.iMainState = MAIN_GAME_STATE_WIN;\n\t            g_gameState.fStateTimer = 0.0;\n            }   \n\n            if ( playerEnt.fHealth <= 0.0 && playerEnt.fTimer <= 0.0 )\n            {\n                if ( g_controls.menuConfirm )\n                {\n                    g_gameState.iMainState = MAIN_GAME_STATE_INIT_LEVEL;\n\t\t            g_gameState.fStateTimer = 0.0;\n                }\n            }\n            \n            if ( playerEnt.fHealth > 0.0 )\n            {\n                \/\/ This does debounce logic for us\n                if ( Key_IsToggled( iChannelKeyboard, KEY_TAB ) )\n                {\n                    g_gameState.fMap = 1.0;\n                }\n                else\n                {\n                    g_gameState.fMap = 0.0;                \n                }\n            }\n            \n            \/\/ Apply \/ update HUD effects\n            {\n                if ( playerEnt.iEvent == EVENT_HEALTH_BONUS )\n                {\n                    g_gameState.fHudFx += 0.25;\n\n                    g_gameState.iMessage = MESSAGE_HEALTH_BONUS;\n                    g_gameState.fMessageTimer = 3.0;\n                }\n                else if ( playerEnt.iEvent == EVENT_ARMOR_BONUS )\n                {\n                    g_gameState.fHudFx += 0.25;\n\n                    g_gameState.iMessage = MESSAGE_ARMOR_BONUS;\n                    g_gameState.fMessageTimer = 3.0;\n                }\n                else if ( playerEnt.iEvent == EVENT_STIMPACK )\n                {\n                    g_gameState.fHudFx += 0.5;\n\n                    g_gameState.iMessage = MESSAGE_STIMPACK;\n                    g_gameState.fMessageTimer = 3.0;\n                }\n                else if ( playerEnt.iEvent == EVENT_MEDIKIT )\n                {\n                    g_gameState.fHudFx += 0.5;\n\n                    g_gameState.iMessage = MESSAGE_MEDIKIT;\n                    g_gameState.fMessageTimer = 3.0;\n                }\n                else if ( playerEnt.iEvent == EVENT_GREENARMOR )\n                {\n                    g_gameState.fHudFx += 1.0;\n                    \n                    g_gameState.iMessage = MESSAGE_GREENARMOR;\n                    g_gameState.fMessageTimer = 3.0;\n                }\n                else if ( playerEnt.iEvent == EVENT_BLUEARMOR )\n                {\n                    g_gameState.fHudFx += 1.0;\n                    \n                    g_gameState.iMessage = MESSAGE_BLUEARMOR;\n                    g_gameState.fMessageTimer = 3.0;\n                }\n                else if ( playerEnt.iEvent == EVENT_DIED )\n                {\n                    g_gameState.fHudFx -= 1.0;\n                } \n                else if ( playerEnt.iEvent == EVENT_SHOTGUN)\n                {\n                    g_gameState.iMessage = MESSAGE_SHOTGUN;\n                    g_gameState.fMessageTimer = 3.0;\n                }\n\n                if ( playerEnt.fTookDamage > 0.0 )\n                {\n                    g_gameState.fHudFx -= playerEnt.fTookDamage \/ 8.0;\n                }\n                \n                if ( g_gameState.fHudFx > 0.0 )\n                {\n                    g_gameState.fHudFx = max( 0.0, g_gameState.fHudFx - fTimestep );\n                }        \n                else\n                if ( g_gameState.fHudFx < 0.0 )\n                {\n                    g_gameState.fHudFx = min( 0.0, g_gameState.fHudFx + fTimestep );            \n                }     \n                g_gameState.fHudFx = clamp( g_gameState.fHudFx, -1.0, 1.0 );                \n                \n                \/\/ Update message timer;\n                g_gameState.fMessageTimer = max( 0.0, g_gameState.fMessageTimer - fTimestep );\n            }\n            \n        }\n\n        if ( iMainGameState == MAIN_GAME_STATE_INIT_LEVEL )\n        {\n\t\t\tg_gameState.fGameTime = 0.0;\n\t\t\tg_gameState.iMainState = MAIN_GAME_STATE_GAME_RUNNING;\n            g_gameState.fStateTimer = 0.0;\n        }\n        \n        g_gameState.vPrevMouse = iMouse;\n                \n        GameState_Store( g_gameState, fragColor, fragCoord );\n    }        \n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\/\/ Scene Rendering\n\n\/\/#define DEBUG_IDENTIFY_TEXTURES\n\/\/#define DEBUG_IDENTIFY_TEXTURE 21.\n\/\/#define DEBUG_IDENTIFY_UNDEFINED_TEXTURES\n\/\/#define DEBUG_ENTITY_INFO\n\/\/#define DEBUG_VALUES\n\/\/#define TEXTURE_PREVIEW 54.0\n\n#define LINUX_WORKAROUND\n\n#define MAP_CHANNEL iChannel0\n#define STATE_CHANNEL iChannel1\n\n\/\/ ----------------- 8< -------------------------- 8< -------------------------- 8< --------------\n\/\/ Common code follows\n\n#define NO_UNROLL(X) (X + min(0,iFrame))\n#define NO_UNROLLU(X) (X + uint(min(0,iFrame)))\n\nbool Map_PointInSector( sampler2D mapSampler, vec2 vPos, Sector sector )\n{\n    float fInOutTest = 0.0;\n    \n    for(int iSideDefIndex=0; iSideDefIndex< NO_UNROLL( sector.iSideDefCount ); iSideDefIndex++)\n    {        \n        SideDef sideDef = Map_ReadSideDefInfo( mapSampler, sector.iSectorId, iSideDefIndex );\n        \n        vec2 vPosToA = sideDef.vA - vPos;\n        vec2 vPosToB = sideDef.vB - vPos;\n        \n        if ( vPosToA.y > 0.0 && vPosToB.y > 0.0 )\n        \tcontinue;\n        if ( vPosToB.y <= 0.0 && vPosToA.y <= 0.0 )\n        \tcontinue;               \n        \n        float fCross = Cross2d( vPosToA, vPosToB );\n        if ( vPosToA.y > vPosToB.y )\n            fCross = -fCross;\n        if ( fCross < 0.0 )\n        {\n            fInOutTest++;\n        }        \n    }\n    \n    return mod( fInOutTest, 2.0 ) >= 1.0;    \n}\n\nbool Map_PointInSector( sampler2D mapSampler, MapInfo mapInfo, vec2 vPos, int iSectorId )\n{\n    if ( !Map_ValidSectorId(mapInfo, iSectorId) )\n    {\n        return false;\n    }\n\n    Sector sector = Map_ReadSector( mapSampler, iSectorId );\n\n    return Map_PointInSector( mapSampler, vPos, sector );\n}\n\nint Map_SeekSector( sampler2D mapSampler, MapInfo mapInfo, vec2 vPos )\n{    \n    for(int iSectorIndex=0; iSectorIndex<NO_UNROLL( mapInfo.iSectorCount ); iSectorIndex++)\n    {        \n        if ( Map_PointInSector( mapSampler, mapInfo, vPos, iSectorIndex ) )\n        {\n            return iSectorIndex;\n        }        \n    }\n\n    return SECTOR_NONE;\n}\n\n\nvoid Map_UpdateSector( sampler2D mapSampler, MapInfo mapInfo, vec2 vPrev, vec2 vPos, inout int iSectorId )\n{    \n    if ( vPrev == vPos )\n    {\n        return;\n    }\n    \n    if ( !Map_PointInSector( mapSampler, mapInfo, vPos, iSectorId ) )\n    {\n        int iNewSectorId = Map_SeekSector( mapSampler, mapInfo, vPos );\n        \n        if ( iNewSectorId != SECTOR_NONE )\n        {\n        \tiSectorId = iNewSectorId;\n        }                \n    }\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Trace\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nTraceResult Map_Trace( sampler2D mapSampler, MapInfo mapInfo, vec3 vRayOrigin, vec3 vRayDir, int iSectorId, float fMaxDist )\n{\n    TraceResult result;\n    \n    result.iTexture = 0u;\n    result.vTexture = vec3(0.0);\n    result.fDist = 0.0;\n    result.fLightLevel = 0.0;\n    result.iSector = SECTOR_NONE;\n    \n    while(true)\n    {\n        if ( iSectorId == SECTOR_NONE )\n        {\n            break;\n        }\n        \n        Sector sector = Map_ReadSector( mapSampler, iSectorId );\n        \n        TraceSectorState sectorState;\n        sectorState.iNextSector = SECTOR_NONE;        \n        sectorState.fEnterDist = result.fDist;\n        sectorState.bNoUpper = false;\n        result.fDist = fMaxDist;\n        result.iSector = iSectorId;\n        \n        for(int iSideDefIndex=0; iSideDefIndex<NO_UNROLL( sector.iSideDefCount); iSideDefIndex++)\n        {\n            SideDef sideDef = Map_ReadSideDefInfo( mapSampler, iSectorId, iSideDefIndex );                        \n\n            TraceSideDef( mapSampler, vRayOrigin, vRayDir, result, sectorState, sector, sideDef );\n        }\n\n        \/\/ Test floor \/ ceiling\n        if ( sectorState.fExitY < sector.fFloorHeight )\n        {\n            result.fDist = (sector.fFloorHeight - vRayOrigin.y) \/ vRayDir.y;\n            vec3 vFloorPos = vRayOrigin + vRayDir * result.fDist;\n            result.vTexture.st = vec2( vFloorPos.xz );\n            result.iTexture = sector.iFloorTexture;\n            result.fLightLevel = 0.0;\n            sectorState.iNextSector = SECTOR_NONE;\n        }\n        else\n        if ( sectorState.fExitY > sector.fCeilingHeight && !sectorState.bNoUpper )\n        {\n            result.fDist = (sector.fCeilingHeight - vRayOrigin.y) \/ vRayDir.y;\n            vec3 vCeilingPos = vRayOrigin + vRayDir * result.fDist;\n            result.vTexture.st = vec2( vCeilingPos.xz );\n            result.iTexture = sector.iCeilingTexture;\n            result.fLightLevel = 0.0;\n            sectorState.iNextSector = SECTOR_NONE;\n        }        \n\n        iSectorId = sectorState.iNextSector;\n    }\n    \n    if ( result.iTexture == 1u )\n        result.fDist = FAR_CLIP;\n    \n    return result;\n}\n\n\n\/\/ End of common code\n\/\/ ----------------- 8< -------------------------- 8< -------------------------- 8< --------------\n\n\n\/\/ ---- 8< ---- GLSL Number Printing - @P_Malin ---- 8< ----\n\/\/ Creative Commons CC0 1.0 Universal (CC-0) \n\/\/ https:\/\/www.shadertoy.com\/view\/4sBSWW\n\nfloat DigitBin(const in int x)\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue(const in vec2 vStringUV, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces)\n{\n    if ((vStringUV.y < 0.0) || (vStringUV.y >= 1.0)) return 0.0;\n\tfloat fLog10Value = log2(abs(fValue)) \/ log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringUV.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((fValue < 0.0) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n\t\t\t\tif(fDigitIndex < 0.0) fDigitIndex += 1.0;\n\t\t\t\tfloat fDigitValue = (abs(fValue \/ (pow(10.0, fDigitIndex))));\n                float kFix = 0.0001;\n                fCharBin = DigitBin(int(floor(mod(kFix+fDigitValue, 10.0))));\n\t\t\t}\t\t\n\t\t}\n\t}\n    return floor(mod((fCharBin \/ pow(2.0, floor(fract(vStringUV.x) * 4.0) + (floor(vStringUV.y * 5.0) * 4.0))), 2.0));\n}\n\n\/\/ ---- 8< -------- 8< -------- 8< -------- 8< ----\n\n#define ENABLE_SPRITES\n\n#define DRAW_SKY\n#define HEAD_BOB\n\n#define QUANTIZE_FINAL_IMAGE\n#define QUANTIZE_TEXTURES\n#define PIXELATE_TEXTURES\n\n\n#define DISCARD_BACKGROUND\n\nconst float kDepthFadeScale = (1.0 \/ 3500.0);\nconst float kExtraLight = 0.0;\n\nvec3 SampleTexture( uint iTexture, const in vec2 vUV );\n\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget )\n{\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n\t\n    const float kFOV = 1.8;\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * kFOV);\n\n\treturn vDir;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\n\n#ifdef ENABLE_SPRITES\n\nvoid Sprite( vec3 vRayOrigin, vec3 vRayDir, vec3 vPos, vec2 vSpriteDir, int iSectorId, vec4 vSpriteInfo, inout TraceResult traceResult )\n{\n\tif ( vSpriteInfo.z <= 0.0 )\n        return;\n    \n    vec2 vSize = vSpriteInfo.zw;\n    \n\tvec2 vA = vPos.xz - vSpriteDir * 0.5 * vSize.x;\n\tvec2 vB = vPos.xz + vSpriteDir * 0.5 * vSize.x;\n    vec2 vD = vB - vA;\n    vec2 vOA = vA - vRayOrigin.xz;\n    float rcpdenom = 1.0 \/ Cross2d( vRayDir.xz, vD ); \n    float fHitT = Cross2d( vOA, vD ) * rcpdenom;   \n    \n    float fDepthBias = 0.0;\/\/-vSize.x * .5;\n    \n    if ( fHitT > 0.0 && (fHitT + fDepthBias) < traceResult.fDist )\n    {\n\t    float fHitU = Cross2d( vOA, vRayDir.xz ) * rcpdenom;\n        float fHitY = vRayDir.y * fHitT + vRayOrigin.y;\n        float fSpriteX = fHitU * vSize.x;\n        float fSpriteY = fHitY - vPos.y;\n        if( (fSpriteX >= 0.0) && (fSpriteX < vSize.x) )\n        {\n            if( (fSpriteY >= 0.0 ) && (fSpriteY < vSize.y) )\n            {             \t\t\t\t\n                vec2 vSpritePixel = floor( vec2( fSpriteX, fSpriteY ) );\n                vec2 vUV = (vSpritePixel + vSpriteInfo.xy + 0.5 ) \/ iChannelResolution[2].xy;                \n                if ( vUV.x > 1.0 ) vUV.x = 2.0 - vUV.x;\n                vec4 vSpriteSample = texture( iChannel2, vUV );\n                if ( vSpriteSample.a > 0.0 )\n                {\n\t\t\t\t\ttraceResult.fDist = fHitT;                    \n                    traceResult.vTexture.rgb = vSpriteSample.rgb;\n                    traceResult.iSector = iSectorId;\n                    traceResult.fLightLevel = 0.0;\n                }                \n            }\n        }\n    }   \n}\n\n#endif\n\nvoid DebugValueSprite( vec3 vRayOrigin, vec3 vRayDir, vec3 vPos, vec2 vSpriteDir, float fValue, vec3 vColor, bool bNoDepthTest, inout TraceResult traceResult )\n{    \n    vec2 vSize = vec2(4.0, 6.0);\n    \n\tvec2 vA = vPos.xz;\n\tvec2 vB = vPos.xz + vSpriteDir;\n    vec2 vD = vB - vA;\n    vec2 vOA = vA - vRayOrigin.xz;\n    float rcpdenom = 1.0 \/ Cross2d( vRayDir.xz, vD ); \n    float fHitT = Cross2d( vOA, vD ) * rcpdenom;    \n    \n    if ( fHitT > 0.0 && (fHitT < traceResult.fDist || bNoDepthTest ) )\n    {\n\t    float fHitU = Cross2d( vOA, vRayDir.xz ) * rcpdenom;\n        float fHitY = vRayDir.y * fHitT + vRayOrigin.y;\n        float fSpriteX = fHitU;\n        float fSpriteY = fHitY - vPos.y;\n\n        {                        \n            vec2 vSpritePixel = vec2( fSpriteX, fSpriteY ) \/ vSize;\n\n            float fText = PrintValue( vSpritePixel, fValue, 4.0, 2.0 );\n\n            if ( fText > 0.0 )\n            {\n                traceResult.fDist = fHitT;                    \n                traceResult.vTexture.rgb = vColor;\n                traceResult.iSector = 0;\n                traceResult.fLightLevel = 0.0;\n            }                \n        }\n    }   \n}\n\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Sprite Crop Sheet Info\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define SPR_RIGHT(V) vec2((V.x + V.z), V.y)\n#define SPR_ABOVE(V) vec2(V.x, (V.y + V.w))\n\nconst vec4 kSpriteNone\t\t\t\t= vec4( 0 );\n\nconst vec4 kSpriteBarrel\t\t\t= vec4(\tSPR_RIGHT(kSpriteNone),\t\t\t\t\t23,32);\nconst vec4 kSpriteBarrelExpl\t\t= vec4(\tSPR_RIGHT(kSpriteBarrel),\t\t\t\t32,32);\n\nconst vec4 kSpriteFireball\t\t\t= vec4(\tSPR_RIGHT(kSpriteBarrelExpl),\t\t\t20,20);\nconst vec4 kSpriteFireball2\t\t\t= vec4(\tSPR_RIGHT(kSpriteFireball),\t\t\t\t24,24);\n\nconst vec4 kSpriteHealthBonus\t\t= vec4(\tSPR_RIGHT(kSpriteFireball2),\t\t\t16,16);\nconst vec4 kSpriteArmorBonus\t\t= vec4(\tSPR_ABOVE(kSpriteHealthBonus),\t\t\t16,15);\nconst vec4 kSpriteMedikit\t\t\t= vec4(\tSPR_RIGHT(kSpriteHealthBonus),\t\t\t28,19);\nconst vec4 kSpriteStimpack\t\t\t= vec4(\tSPR_RIGHT(kSpriteMedikit),\t\t\t\t16,19);\nconst vec4 kSpriteBlueArmor\t\t\t= vec4(\tSPR_RIGHT(kSpriteStimpack),\t\t\t\t32,24);\nconst vec4 kSpriteGreenArmor\t\t= vec4(\tSPR_RIGHT(kSpriteBlueArmor),\t\t\t32,24);\nconst vec4 kSpriteShotgun\t\t\t= vec4(\tSPR_RIGHT(kSpriteGreenArmor),\t\t\t32,16);\n\nconst vec4 kSpriteWallImpact1\t\t= vec4(\tSPR_RIGHT(kSpriteShotgun),\t\t\t\t6,6);\nconst vec4 kSpriteWallSmokeImpact1\t= vec4(\tSPR_RIGHT(kSpriteWallImpact1),\t\t\t8,16);\nconst vec4 kSpriteFleshImpact1\t\t= vec4(\tSPR_RIGHT(kSpriteWallSmokeImpact1),\t\t8,8);\n\nconst vec4 kSpriteBloodyMess\t\t= vec4(\tSPR_RIGHT(kSpriteFleshImpact1) + vec2(0,16),\t\t42,16);\nconst vec4 kSpriteDeadTrooper \t\t= vec4(\tSPR_RIGHT(kSpriteBloodyMess),\t\t\t42,16);\nconst vec4 kSpriteDeadSergeant \t\t= vec4(\tSPR_RIGHT(kSpriteDeadTrooper),\t\t\t42,16);\nconst vec4 kSpriteDeadImp \t\t\t= vec4(\tSPR_RIGHT(kSpriteDeadSergeant),\t\t\t42,16);\n\nconst vec4 kSpriteBarrelExpl2\t\t= vec4(\t480,0,\t\t\t\t\t\t\t\t\t38,48);\n\nconst vec4 kSpriteFloorLamp\t\t\t= vec4(\t480,48,\t\t\t\t\t\t\t\t\t23,48);\nconst vec4 kSpriteTallTechnoPillar\t= vec4(\tSPR_ABOVE(kSpriteFloorLamp),\t\t\t38,128);\n\nconst vec4 kSpriteEnemyBegin = vec4(0, 32., 32, 52);\n\n\n#define SPRITE_ENEMY_ACTION_STAND \t\t0.\n#define SPRITE_ENEMY_ACTION_ATTACK\t\t1.\n#define SPRITE_ENEMY_ACTION_WALK1 \t\t2.\n#define SPRITE_ENEMY_ACTION_WALK2 \t\t3.\n#define SPRITE_ENEMY_ACTION_PAIN \t\t4.\n#define SPRITE_ENEMY_ACTION_DIE \t\t5.\n\n#define SPRITE_ENEMY_ACTION_COUNT \t\t6\n\n#define SPRITE_ENEMY_ACTION_DEAD\t\t10.\n\n#define SPRITE_ENEMY_TYPE_TROOPER \t0.\n#define SPRITE_ENEMY_TYPE_IMP \t\t1.\n#define SPRITE_ENEMY_TYPE_SERGEANT \t2.\n\n#define SPRITE_ENEMY_TYPE_COUNT     3\n\nvec4 GetEnemySprite( int iType, float fAction, float fDirection )\n{\n    vec2 vGridPos = vec2( float(iType) + fDirection * float(SPRITE_ENEMY_TYPE_COUNT), fAction );\n    vec2 vPos = kSpriteEnemyBegin.xy +kSpriteEnemyBegin.zw * vGridPos;\n\treturn vec4( vPos, kSpriteEnemyBegin.zw );\n}\n\n#ifdef TEXTURE_PREVIEW\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float fTexture = TEXTURE_PREVIEW;\n    \n    vec2 vTexCoord = floor( fragCoord.xy ) \/ 2.5;\n    fragColor.rgb = SampleTexture( fTexture, vTexCoord );    \n    fragColor.a = 1.0;\n}\n#else\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vOrigUV = fragCoord.xy \/ iResolution.xy;\n    \n    vec2 vResolution = min( iResolution.xy, vec2( 320.0, 200.0 - 32.0 ) );\n    \n    vec2 vUV = fragCoord.xy \/ vResolution;\n    if ( any( lessThan( vUV, vec2(0) ) ) ||  any( greaterThanEqual( vUV, vec2(1.) )) )\n             discard;\n    \n\tvec3 vCameraPos = vec3(0.0);\n\tvec3 vCameraTarget = vec3(0.0);\n        \n    vec2 vMouse = (iMouse.xy \/ iResolution.xy);\n\t\n    \n    Entity playerEnt = Entity_Read( STATE_CHANNEL, 0 );\n    vCameraPos = playerEnt.vPos;\n    \n    float fDeathFall = 0.0;\n    \n    \/\/ Death\n    if( playerEnt.fHealth <= 0.0 )\n    {\n        fDeathFall = 1.0 - (playerEnt.fTimer \/ 1.5);\n    }\n    \n    vCameraPos.y += 6.0 + 34.0 * (1.0 - fDeathFall);\n\n    Sector playerSector = Map_ReadSector( MAP_CHANNEL, playerEnt.iSectorId );\n\n    \n    #ifdef HEAD_BOB\n\tfloat fBob = sin(vCameraPos.x* 0.04) * 4.0; \/\/ head bob\n    vCameraPos.y += fBob;\n    #endif\n        \n    \/\/ Door crush\n    vCameraPos.y = min( vCameraPos.y, playerSector.fCeilingHeight - 1.0 );\n    vCameraPos.y = max( vCameraPos.y, playerSector.fFloorHeight + 0.001 );\n    \n    vCameraTarget = vCameraPos;\n\n    \/\/ Mouselook\n    float fSinPitch = sin(playerEnt.fPitch);\n    float fCosPitch = cos(playerEnt.fPitch);\n    vCameraTarget.y += fSinPitch;\n    \/\/playerEnt.fYaw += (vMouse.x - 0.5 )* 3.0;\n\n    vCameraTarget.x += sin( playerEnt.fYaw ) * fCosPitch;\n    vCameraTarget.z += cos( playerEnt.fYaw ) * fCosPitch;\n    \n    \n    vec2 vWindowCoord =\t(vUV * 2.0 - 1.0) * vec2(vResolution.x \/ vResolution.y, 1.0);\n\t\n    vec3 vRayOrigin = vCameraPos;\n    vec3 vRayDir = GetCameraRayDir( vWindowCoord, vCameraPos, vCameraTarget );\n    \n    float fNoFog = 0.0;\n\tMapInfo mapInfo = ReadMapInfo( MAP_CHANNEL );\n    \n\tTraceResult traceResult;\t\n    traceResult = Map_Trace( MAP_CHANNEL, mapInfo, vRayOrigin, vRayDir, playerEnt.iSectorId, FAR_CLIP );\n\n\tvec3 vForwards = normalize(vCameraTarget - vCameraPos); \n    \n    \/\/ sky    \n    #ifdef DRAW_SKY    \n    if ( traceResult.iTexture == 1u )\n    {\n        fNoFog = 1.0;\n        float fSkyU = (atan(vForwards.x, vForwards.z) * 768.0 \/ radians(180.0)) + vUV.x * vResolution.x;\n        float fSkyV = (vUV.y + fSinPitch) * 210.0 + 41.0;\n        fSkyV = min( fSkyV, 255.0 );\n        \n    \ttraceResult.vTexture.st = vec2(fSkyU, fSkyV);\n\t    traceResult.fLightLevel = 100.0f;\n    }\n    \/\/ add extra light for sky, will be clamped to 1.0 later\n\t#endif    \n\n    \/\/ Resovle level textures here\n\ttraceResult.vTexture.rgb = SampleTexture( traceResult.iTexture, traceResult.vTexture.st );    \n    \n\n    #ifdef ENABLE_SPRITES\n\tvec2 vSpriteDir = -normalize(vec2(-vForwards.z, vForwards.x));\n\t    \n    for( int iEnt=0; iEnt<int(ENTITY_MAX_COUNT); iEnt++)\n    {\n        float fFlipSprite = 1.0;\n        vec4 vSpriteInfo = kSpriteNone;\n\t\tEntity entity = Entity_Read( STATE_CHANNEL, iEnt );\n        if ( entity.iType == ENTITY_TYPE_BARREL )\n        {\n            if( entity.iSubType == ENTITY_SUB_TYPE_BARREL_EXPLODING && entity.fTimer < 0.05 )\n            {\n                vSpriteInfo = kSpriteBarrelExpl2;                                      \n\t\t\t\tentity.iSectorId = 0; \/\/ hack fullbright\n    \t\t}\n            else\n            if( entity.iSubType == ENTITY_SUB_TYPE_BARREL_EXPLODING && entity.fTimer < 0.2 )\n            {                   \n                vSpriteInfo = kSpriteBarrelExpl;\n\t\t\t\tentity.iSectorId = 0; \/\/ hack fullbright\n            }\n            else\n            {\n                vSpriteInfo = kSpriteBarrel;                \n            }\n        }            \n        else\n        if ( entity.iType == ENTITY_TYPE_ITEM )\n        {\n            if ( entity.iSubType == ENTITY_SUB_TYPE_ITEM_HEALTH_BONUS )\n            {\n\t            vSpriteInfo = kSpriteHealthBonus;\n            }\n            else if ( entity.iSubType == ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS )\n            {\n\t            vSpriteInfo = kSpriteArmorBonus;\n            }\n            else if ( entity.iSubType == ENTITY_SUB_TYPE_ITEM_MEDIKIT )\n            {\n\t            vSpriteInfo = kSpriteMedikit;\n            }\n            else if ( entity.iSubType == ENTITY_SUB_TYPE_ITEM_STIMPACK )\n            {\n\t            vSpriteInfo = kSpriteStimpack;\n            }\n            else if ( entity.iSubType == ENTITY_SUB_TYPE_ITEM_GREENARMOR )\n            {\n\t            vSpriteInfo = kSpriteGreenArmor;\n            }\n            else if ( entity.iSubType == ENTITY_SUB_TYPE_ITEM_BLUEARMOR )\n            {\n\t            vSpriteInfo = kSpriteBlueArmor;\n            }\n            else if ( entity.iSubType == ENTITY_SUB_TYPE_ITEM_SHOTGUN )\n            {\n\t            vSpriteInfo = kSpriteShotgun;\n            }\n            \n            else\n            {\n\t            vSpriteInfo = kSpriteFireball;                \n            }            \n        }\n        else\n        if ( entity.iType == ENTITY_TYPE_DECORATION )\n        {\n    \t    if ( entity.iSubType == ENTITY_SUB_TYPE_DECORATION_BLOODY_MESS )\n\t        {\n\t            vSpriteInfo = kSpriteBloodyMess;\n            }\n            else\n    \t    if ( entity.iSubType == ENTITY_SUB_TYPE_DECORATION_DEAD_TROOPER )\n\t        {\n\t            vSpriteInfo = kSpriteDeadTrooper;\n            }\n            else\n    \t    if ( entity.iSubType == ENTITY_SUB_TYPE_DECORATION_DEAD_SERGEANT )\n\t        {\n\t            vSpriteInfo = kSpriteDeadSergeant;\n            }\n            else\n    \t    if ( entity.iSubType == ENTITY_SUB_TYPE_DECORATION_DEAD_IMP )\n\t        {\n\t            vSpriteInfo = kSpriteDeadImp;\n            }      \n            else\n            if ( entity.iSubType == ENTITY_SUB_TYPE_DECORATION_FLOOR_LAMP )\n            {\n                vSpriteInfo = kSpriteFloorLamp;\n                entity.iSectorId = 0; \/\/ hack fullbright\n            }\n            else\n            if ( entity.iSubType == ENTITY_SUB_TYPE_DECORATION_TALL_TECHNO_PILLAR )\n            {\n                vSpriteInfo = kSpriteTallTechnoPillar;\n            }\n        }            \n        else\n        if ( entity.iType == ENTITY_TYPE_ENEMY )\n        {\n            float fAction = SPRITE_ENEMY_ACTION_STAND;\n            \n            if ( int(entity.fArmor) == ENEMY_STATE_FIRE )\n            {\n                fAction = SPRITE_ENEMY_ACTION_ATTACK;\n            }\n            else\n            if ( int(entity.fArmor) == ENEMY_STATE_PAIN )\n            {\n                fAction = SPRITE_ENEMY_ACTION_PAIN;\n\t\t\t}\n            else\n            if ( int(entity.fArmor) == ENEMY_STATE_DIE )\n            {\n                if ( iChannelResolution[2].y < 360.0 )\n                {\t                    \n            \t\tfAction = SPRITE_ENEMY_ACTION_PAIN;\n                }\n                else\n                {\n            \t\tfAction = SPRITE_ENEMY_ACTION_DIE;\n                }\n            }\n            else\n                if ( int(entity.fArmor) == ENEMY_STATE_WALK_RANDOM || int(entity.fArmor) == ENEMY_STATE_WALK_TO_TARGET )\n                {\n                    if( fract( entity.fTimer ) < 0.5 )\n                    {\n                        fAction = SPRITE_ENEMY_ACTION_WALK1;\n                    }\n                    else\n                    {\n                        fAction = SPRITE_ENEMY_ACTION_WALK2;\n                    }\n                }\n            else\n            {\n                fAction = SPRITE_ENEMY_ACTION_STAND;\n            }\n            \n            vec3 vCamToEnt = entity.vPos - playerEnt.vPos;\n            float fCameraYaw = atan( vCamToEnt.z, vCamToEnt.x );\n            float fRelativeYaw = fCameraYaw + entity.fYaw + radians(90.0 + 22.5);\n            float fDirection = (fRelativeYaw \/ radians(45.0)) + 16.0;\n            fDirection = mod( floor(fDirection), 8.0 );\n            if ( fDirection > 4.0 ) \n            {\n                fDirection = 8.0 - fDirection;\n                fFlipSprite = -1.0;\n            }\n            \n            vSpriteInfo = GetEnemySprite( entity.iSubType, fAction, fDirection );\n        }\n        else if ( entity.iType == ENTITY_TYPE_BULLET )\n        {\n            if ( entity.iSubType == ENTITY_SUB_TYPE_BULLET_WALL )\n            {\n                if ( entity.fTimer > (0.3 - 0.1) )\n                {                    \n            \t\tvSpriteInfo = kSpriteWallImpact1;\n                    \/\/ entity.fSectorId = 0.; hack fullbright\n                    \n                }\n                else\n                {\n            \t\tvSpriteInfo = kSpriteWallSmokeImpact1;\n                }\n            }\n            else\n            if ( entity.iSubType == ENTITY_SUB_TYPE_BULLET_FLESH )\n            {\n            \tvSpriteInfo = kSpriteFleshImpact1;\n            }                \n        }    \n        else if ( entity.iType == ENTITY_TYPE_FIREBALL )\n        {\n            entity.vPos.y -= 16.0; \/\/ Centre fireball\n            if ( entity.iSubType == ENTITY_SUB_TYPE_FIREBALL ) \n            {                \n\t\t\t\tvSpriteInfo = kSpriteFireball;\n                entity.iSectorId = 0; \/\/ hack fullbright\n            }\n            else\n            {\n                vSpriteInfo = kSpriteFireball2;\n                entity.iSectorId = 0; \/\/ hack fullbright\n            }\n        }\n        \n        Sprite( vRayOrigin, vRayDir, entity.vPos, fFlipSprite * vSpriteDir, entity.iSectorId, vSpriteInfo, traceResult );\n        \n        \/\/ Debug\n\t\t#ifdef DEBUG_ENTITY_INFO\n\t\t{\n            bool bNoDepthTest = false;\n            if( entity.iType == ENTITY_TYPE_ENEMY )\n            {\n            \tDebugValueSprite( vRayOrigin, vRayDir, entity.vPos + vec3(0,48,0), vSpriteDir, entity.fArmor, vec3(1), bNoDepthTest, traceResult );\n            }\n\n            if( entity.iType != ENTITY_TYPE_NONE )\n            {\n\t            \/\/ Show health\n            \tDebugValueSprite( vRayOrigin, vRayDir, entity.vPos + vec3(0,32,0), vSpriteDir, entity.fHealth, vec3(1,0,0), bNoDepthTest, traceResult );\n\t            \/\/ Show timer\n            \tDebugValueSprite( vRayOrigin, vRayDir, entity.vPos + vec3(0,24,0), vSpriteDir, entity.fTimer, vec3(0,0,1), bNoDepthTest, traceResult );\n\n                \/\/ Show sector id\n                \/\/DebugValueSprite( vRayOrigin, vRayDir, entity.vPos + vec3(0,16,0), vSpriteDir, entity.fSectorId, vec3(1), bNoDepthTest, traceResult );\n                DebugValueSprite( vRayOrigin, vRayDir, entity.vPos + vec3(0,16,0), vSpriteDir, float(entity.iSubType), vec3(1), bNoDepthTest, traceResult );\n            }\n        }\n        #endif\n    }        \n    #endif\t\n    \n    \/\/ Calculate light levels\n    Sector sector = Map_ReadSector( MAP_CHANNEL, traceResult.iSector );    \n\ttraceResult.fLightLevel = clamp( sector.fLightLevel + traceResult.fLightLevel + kExtraLight, 0.0, 1.0);\n\n    float fFlash = 0.0;\n    {\n        if(  playerEnt.fHealth > 0.0 )\n        {    \n            float fIntensity;\n            float fReloadTime;\n            float fTimeScale;\n            if ( playerEnt.fUseWeapon == 2.0 )\n            {\n                fReloadTime = 1.0;\n                fTimeScale = 15.0;\n                fIntensity = 0.2;\n                fFlash = 1.0 -  playerEnt.fTimer;\n            }\n            else\n            {\n                fReloadTime = 0.5;\n                fIntensity = 0.1;\n                fTimeScale = 20.0;\n            }\t  \n            fFlash = (fReloadTime -  playerEnt.fTimer) * fTimeScale;\n            fFlash = (1.0 - clamp(fFlash, 0.0, 1.0)) * fIntensity;\n        }        \n    }\n    \n    float fLightLevel = clamp( traceResult.fLightLevel, 0.0, 1.0 );\n    fLightLevel = pow( fLightLevel, 1.5);\n    float fDepth = dot(vRayDir, vForwards) * traceResult.fDist;\n    float fDepthFade = fDepth * kDepthFadeScale;\n    float fApplyFog = 1.0 - fNoFog;\n    fDepthFade -= fFlash;\n    fLightLevel = clamp( fLightLevel - fDepthFade * fApplyFog, 0.0, 1.0 );   \n    \/\/fLightLevel = fLightLevel * fLightLevel;\n    \n    vec3 vResult = traceResult.vTexture.rgb * fLightLevel;\n    \n    vResult = clamp(vResult * 1.2, 0.0, 1.0);\n\n    \n\t\/*\n\t\t\/\/ Debug entity trace\n        \n        float fEntId = -1.0;\n\t\tfloat fEntTraceDist = Entity_Trace( vRayOrigin, vRayDir, 0.0, fEntId );\n        \n        if ( fEntTraceDist < FAR_CLIP )\n        {\n            if ( fEntTraceDist < traceResult.fDist )\n            {\n\t            vResult = vec3( 1, 0, 0 );\n            }\n            else\n            {\n\t            vResult = vec3( 0, 0, 0.5 );                \n\t\t\t}\n        }\n    }*\/\n    \n    #ifdef DISCARD_BACKGROUND    \n    if(traceResult.iSector == SECTOR_NONE)\n    {\n        vResult.rgb = vec3(1,0,1);\n        \/\/discard;\n    }\n\t#endif    \n    \n    #ifdef QUANTIZE_FINAL_IMAGE\n    vResult = Quantize(vResult, 32.0);\n    #endif\n    \n\tfragColor = vec4(vResult, 1.0);\n\n\t#ifdef DEBUG_VALUES\n    vec2 vFontUV = fragCoord \/ vec2( 8, 16 );\n    vFontUV.y -= 7.0;\n    float fFontX = vFontUV.x;\n    fragColor.rgb = mix( fragColor.rgb, vec3(0,0,1), PrintValue(vFontUV, playerEnt.vPos.x, 4., 0.) ); \n    vFontUV.x -= 8.;\n    fragColor.rgb = mix( fragColor.rgb, vec3(0,0,1), PrintValue(vFontUV, playerEnt.vPos.y, 4., 0.) ); \n    vFontUV.x -= 8.;\n    fragColor.rgb = mix( fragColor.rgb, vec3(0,0,1), PrintValue(vFontUV, playerEnt.vPos.z, 4., 0.) ); \n\tvFontUV.x = fFontX;\n    \n    vFontUV.y -= 1.2;\n    fragColor.rgb = mix( fragColor.rgb, vec3(1,0,1), PrintValue(vFontUV, float(playerEnt.iSectorId), 4., 0.) );\n    #endif\n}\n#endif\n\n\/\/ Textures\n#define TEX_X 0u\n#define TEX_F_SKY1 1u\n#define TEX_NUKAGE3 2u\n#define TEX_FLOOR7_1 3u\n#define TEX_FLOOR4_8 4u\n#define TEX_CEIL5_1 5u\n#define TEX_FLAT5_5 6u\n#define TEX_FLAT20 7u\n#define TEX_FLOOR5_1 8u\n#define TEX_CEIL5_2 9u\n#define TEX_CEIL3_5 10u\n#define TEX_TLITE6_5 11u\n#define TEX_FLAT14 12u\n#define TEX_FLAT18 13u\n#define TEX_TLITE6_4 14u\n#define TEX_FLOOR7_2 15u\n#define TEX_STEP2 16u\n#define TEX_TLITE6_1 17u\n#define TEX_FLOOR1_1 18u\n#define TEX_FLOOR5_2 19u\n#define TEX_FLOOR6_2 20u\n#define TEX_FLAT23 21u\n#define TEX_TLITE6_6 22u\n#define TEX_DOOR3 23u\n#define TEX_LITE3 24u\n#define TEX_STARTAN3 25u\n#define TEX_BROWN1 26u\n#define TEX_DOORSTOP 27u\n#define TEX_COMPUTE2 28u\n#define TEX_STEP6 29u\n#define TEX_BROWN144 30u\n#define TEX_SUPPORT2 31u\n#define TEX_STARG3 32u\n#define TEX_DOORTRAK 33u\n#define TEX_SLADWALL 34u\n#define TEX_TEKWALL4 35u\n#define TEX_SW1COMP 36u\n#define TEX_BIGDOOR2 37u\n#define TEX_STARGR1 38u\n#define TEX_BROWNGRN 39u\n#define TEX_NUKE24 40u\n#define TEX_BROWN96 41u\n#define TEX_BRNBIGR 42u\n#define TEX_BRNBIGL 43u\n#define TEX_BRNBIGC 44u\n#define TEX_STARTAN1 45u\n#define TEX_EXITDOOR 46u\n#define TEX_SW1STRTN 47u\n#define TEX_BIGDOOR4 48u\n#define TEX_EXITSIGN 49u\n#define TEX_TEKWALL1 50u\n#define TEX_COMPTALL 51u\n#define TEX_COMPSPAN 52u\n#define TEX_PLANET1 53u\n#define TEX_COMPTILE 54u\n#define TEX_STEP1 55u\n#define TEX_COMPUTE3 56u\n\n\n\/*\nfloat hash(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nvec3 SampleTexture( const in float fTexture, const in vec2 _vUV )\n{\n    vec2 vTexureSize = vec2(64);    \n    float fXCount = 10.0; \/\/ TODO : base on resolution?\n    \n    vec2 vTexturePos = vec2( mod( floor(fTexture), fXCount ), floor( fTexture \/ fXCount ) ) * vTexureSize;\n    \n    vec2 vPixel = vTexturePos + fract(_vUV \/ vTexureSize) * vTexureSize;\n    \n    vec2 vSampleUV = vPixel \/ iChannelResolution[1].xy;\n    \n    vec4 vSample = texture( iChannel1, vSampleUV );\n    \n    return vSample.xyz;\n}\n*\/\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Texture Helpers\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nfloat hash2D(vec2 p)\n{\n\treturn Hash( dot( p, vec2(1.0, 41.0) ) );\t\n}\n\nfloat noise1D( float p )\n{\n\tfloat fl = floor(p);\n\t\n\tfloat h0 = Hash( fl );\n\tfloat h1 = Hash( fl + 1.0 );\n\t\n\tfloat fr = p - fl;\n\tfloat fr2 = fr * fr;\n\tfloat fr3 = fr2 * fr;\n\t\n\tfloat t1 = 3.0 * fr2 - 2.0 * fr3;\t\n\tfloat t0 = 1.0 - t1;\n\t\n\treturn h0 * t0\n\t\t + h1 * t1;\n}\n\nfloat noise2D( vec2 p, float r )\n{\n\tvec2 fl = floor(p);\n\n\tfloat h00 = hash2D( mod(fl + vec2(0.0, 0.0), r) );\n\tfloat h10 = hash2D( mod(fl + vec2(1.0, 0.0), r) );\n\tfloat h01 = hash2D( mod(fl + vec2(0.0, 1.0), r) );\n\tfloat h11 = hash2D( mod(fl + vec2(1.0, 1.0), r) );\n\t\n\tvec2 fr = p - fl;\n\t\n\tvec2 fr2 = fr * fr;\n\tvec2 fr3 = fr2 * fr;\n\t\n\tvec2 t1 = 3.0 * fr2 - 2.0 * fr3;\t\n\tvec2 t0 = 1.0 - t1;\n\t\n\treturn h00 * t0.x * t0.y\n\t\t + h10 * t1.x * t0.y\n\t\t + h01 * t0.x * t1.y\n\t\t + h11 * t1.x * t1.y;\n}\n\nfloat fbm( vec2 p, float per )\n{\n\tfloat val = 0.0;\n\tfloat tot = 0.0;\n\tfloat mag = 0.5;\n\n\tp += 0.5;\n\tp = p * (1.0 \/ 8.0);\n\tval += noise2D(p, 4.0) * mag; tot+=mag; p=p*2.0 + 1.234; mag*=per;\t\n\tval += noise2D(p, 8.0) * mag; tot+=mag; p=p*2.0 + 2.456; mag*=per;\n\tval += noise2D(p, 16.0) * mag; tot+=mag; p=p*2.0 + 3.678; mag*=per;\n\tval += noise2D(p, 32.0) * mag; tot+=mag;\n\n\treturn val * (1.0 \/ tot);\n}\n\nfloat Indent(vec2 vTexCoord, vec2 vHigh, vec2 vLow, float fHighIntensity, float fLowIntensity)\n{\n\tvec2 vMin = min(vLow, vHigh);\n\tvec2 vMax = max(vLow, vHigh);\n\tif((vTexCoord.x < vMin.x) || (vTexCoord.x > vMax.x) || (vTexCoord.y < vMin.y) || (vTexCoord.y > vMax.y))\n\t\treturn 1.0;\n\n\tif((vTexCoord.x == vHigh.x) || (vTexCoord.y == vHigh.y))\n\t{\n\t\treturn fHighIntensity;\n\t}\n\t\n\tif((vTexCoord.x == vLow.x) || (vTexCoord.y == vLow.y))\n\t{\n\t\treturn fLowIntensity;\n\t}\n\t\n\treturn 1.0;\n}\n\nvec4 SmoothBump(const in vec2 vTexCoord, const in vec2 vMin, const in vec2 vMax, const in vec2 vLightDir, const in float fSize)\n{\n\tvec2 vNearest = min( max(vTexCoord, vMin), vMax );\n\tvec2 vDelta = vNearest - vTexCoord;\n    float fDeltaLen = length(vDelta);\n\tfloat fDist = (fDeltaLen - fSize) \/ fSize;\n\tvec2 vDir = vDelta;\n    if(fDeltaLen > 0.0) vDir = vDir \/ fDeltaLen;\n\tfloat fShade = dot(vDir, vLightDir);\n\t\/\/return clamp(1.0 - (fDist \/ fSize), 0.0, 1.0) * fShade;\n\tfShade *= clamp(1.0 - abs((fDist)), 0.0, 1.0);\n\treturn vec4( fShade, fDist, (vTexCoord - vMin + fSize) \/ (vMax - vMin + fSize * 2.0) );\n}\n\n\nfloat wrap( const in float x , const in float r )\n{\n\treturn fract( x * (1.0 \/ r) ) * r;\n}\n\nvec4 Hexagon( vec2 vUV )\n{\n\tvec2 vIndex;\n\t\n\tfloat fRow = floor(vUV.y);\n\t\n\tvec2 vLocalUV = vUV;\n\tfloat fRowEven = wrap(fRow, 2.0);\n\tif(fRowEven < 0.5)\n\t{\n\t\tvLocalUV.x += 0.5;\n\t}\n\t\n\tvIndex = floor(vLocalUV);\n\t\n\tvec2 vTileUV = fract(vLocalUV);\n\t{\n\t\tfloat m = 2.0 \/ 3.0;\n\t\tfloat c = 2.0 \/ 3.0;\n\t\tif((vTileUV.x *m + c) < vTileUV.y)\n\t\t{\n\t\t\tif(fRowEven < 0.5)\n\t\t\t{\n\t\t\t\tvIndex.x -= 1.0;\n\t\t\t}\n\t\t\tfRowEven = 1.0 - fRowEven;\t\t\t\t\n\t\t\tvIndex.y += 1.0;\n\t\t}\n\t}\n\t\n\t{\n\t\tfloat m = -2.0 \/ 3.0;\n\t\tfloat c = 4.0 \/ 3.0;\n\t\tif((vTileUV.x *m + c) < vTileUV.y)\n\t\t{\n\t\t\tif(fRowEven >= 0.5)\n\t\t\t{\n\t\t\t\tvIndex.x += 1.0;\n\t\t\t}\n\t\t\tfRowEven = 1.0 - fRowEven;\t\t\t\t\n\t\t\tvIndex.y += 1.0;\n\t\t}\n\t}\n\t\n\tvec2 vCenter = vIndex - vec2(0.0, -1.0 \/ 3.0);\n\tif(fRowEven > 0.5)\n\t{\n\t\tvCenter.x += 0.5;\n\t}\n\t\n\tvec2 vDelta = vUV - vCenter;\n\t\n\t\/\/vDelta = abs(vDelta);\n\t\n\tfloat d1 = vDelta.x;\n\tfloat d2 = dot(vDelta, normalize(vec2(2.0\/3.0, 1.0)));\n\tfloat d3 = dot(vDelta, normalize(vec2(-2.0\/3.0, 1.0)));\n\t\n\td2 *= 0.9;\n\td3 *= 0.9;\n\t\n\tfloat fDist = max( abs(d1), abs(d2) );\n\tfDist = max( fDist, abs(d3) );\n\t\n\tfloat fTest = max(max(-d1, -d2), d3);\n\t\n\treturn vec4(vIndex, abs(fDist), fTest);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Textures\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec3 TexNukage3( vec2 vTexCoord, float fRandom)\n{\n\tfloat fBlend = 0.0;\n\tfBlend = smoothstep(0.8, 0.0, fRandom);\n\tfBlend = min(fBlend, smoothstep(1.0, 0.8, fRandom));\n\tfBlend *= 1.5;\n\tvec3 col = mix( vec3(11.0, 23.0, 7.0), vec3(46.0, 83, 39.0), fBlend) \/ 255.0;\n\t\n\treturn col;\n}\n\nvoid AddMountain( inout float fShade, const in vec2 vUV, const in float fRandom, const in float fHRandom, const in float fXPos, const in float fWidth, const in float fHeight, const in float fFog)\n{\n\tfloat fYPos = 1.0 - smoothstep( 0.0, 1.0, abs(fract(fXPos - vUV.x + vUV.y * 0.05 + 0.5) - 0.5) * fWidth );\n\tfYPos += fHRandom * 0.05 + fRandom * 0.05;\n\tfYPos *= fHeight;\n\tfloat fDist = fYPos - vUV.y;\n\tif(fDist > 0.0)\n\t{\n\t\tfShade = fRandom * ((1.0 - clamp(sqrt(fDist) * 2.0, 0.0, 1.0)) * 0.3 + 0.1);\n\t\tfShade = mix(fShade, 0.6 + 0.1 * fRandom, fFog);\n\t}\t\n}\n\nvec3 TexFSky1(vec2 vTexCoord, float fRandom, float fHRandom)\n{\n\tfloat fShade = 0.6 + 0.1 * fRandom;\n\t\n\tvec2 vUV = vTexCoord * (1.0 \/ vec2(256.0, 128.0));\n\tvUV.y = 1.0 - vUV.y;\n\t\n\tAddMountain( fShade, vUV, fRandom, fHRandom, 0.25, 1.0, 0.85, 0.5 );\n\tAddMountain( fShade, vUV, fRandom, fHRandom, 1.5, 4.0, 0.78, 0.2 );\n\tAddMountain( fShade, vUV, fRandom, fHRandom, 1.94, 2.51, 0.8, 0.0 );\n\n\t\n\treturn vec3(fShade);\n}\n\nvec3 TexFloor7_1( vec2 vTexCoord, float fRandom, vec3 vCol1, vec3 vCol2 )\n{\n\tvec3 col = mix( vCol1, vCol2, fRandom * fRandom * 2.5) \/ 255.0;\n\t\n\treturn col;\n}\n\nvec3 TexFlat5_5( vec2 vTexCoord, float fRandom )\n{\n\tvec3 col = mix( vec3(63.0, 47.0, 23.0), vec3(147.0, 123.0, 99.0), fRandom) \/ 255.0;\n\t\n\tcol *= mod(vTexCoord.x, 2.0) * 0.15 + 0.85;\n\t\n\treturn col;\n}\n\nvec3 TexFloor4_8( vec2 vTexCoord, float fRandom, vec3 vColA, vec3 vColB )\n{\n\tvec3 col = mix( vColA, vColB, fRandom * fRandom) \/ 255.0;\n\n\tvec4 vHex = Hexagon( vTexCoord.yx \/ 32.0 );\n    \n    float fShadow = (clamp((0.5 - vHex.z) * 15.0, 0.0, 1.0) * 0.5 + 0.5);\n    float fHighlight = 1.0 + clamp(1.0 - (abs(0.45 - vHex.w)) * 32.0, 0.0, 1.0) * 0.5;\n    \n\tcol = col * (clamp((0.5 - vHex.z) * 2.0, 0.0, 1.0) * 0.25 + 0.75);\n    col = col * fHighlight;\n\tcol = col * fShadow;\n\t\n\treturn col;\n}\n\nvec3 TexCeil3_5( vec2 vTexCoord, float fRandom )\n{\n\tvec3 col = vec3(1.0);\n\t\n\tvec2 vTileCoord = vTexCoord;\n\tvTileCoord.x -= 17.0;\n\tif( (vTileCoord.x >= 0.0) && (vTileCoord.x < 32.0) ) \n\t\tvTileCoord.y -= 58.0;\n\telse \n\t\tvTileCoord.y -= 11.0;\n\tvTileCoord.x = mod(vTileCoord.x, 32.0);\n\tvTileCoord.y = mod(vTileCoord.y, 64.0);\n\t\t\n\tvec2 vBoxClosest = clamp(vTileCoord, vec2(4.0, 4.0), vec2(28.0, 60.0));\n\tvec2 vDelta = vTileCoord - vBoxClosest;\n\tfloat fDist2 = dot(vDelta, vDelta);\n\n\tconst float fLight1 = 59.0 \/ 255.0;\n\tconst float fMed1 = 55.0 \/ 255.0;\n\tconst float fDark1 = 47.0 \/ 255.0;\n\tconst float fDark2 = 39.0 \/ 255.0;\n\n\tfloat fShade = fMed1;\t\n\tfShade = mix( fShade, fLight1, smoothstep(0.6, 0.45, fRandom) );\n\tfShade = mix( fShade, fDark1, smoothstep(0.45, 0.35, fRandom) );\n\t\n\tfShade = mix( fShade, fDark1, step(1.5, fDist2) );\n\tfShade = mix( fShade, fDark2, step(13.5, fDist2) );\n\t\t\n\tcol *= fShade;\n\t\n\tif((vTileCoord.x < 12.0) || (vTileCoord.x > 20.0) || (vTileCoord.y < 12.0) || (vTileCoord.y > 52.0))\n\t{\n\t\tfloat fRRow = floor(mod(vTileCoord.y - 3.5, 7.5));\n\t\tfloat fRColumn = mod(vTileCoord.x - 15.0, 10.0);\n\t\tif((fRRow == 2.0) && (fRColumn == 0.0))\n\t\t{\n\t\t\tcol -= 0.05;\n\t\t}\n\t\tif((fRRow <= 2.0) && (fRColumn <= 2.0))\n\t\t{\n\t\t\tvec2 vOffset = vec2(fRRow - 1.0, fRColumn - 1.0);\n\t\t\tfloat fDist2 = dot(vOffset, vOffset) \/ 2.0;\n\t\t\tcol += clamp(1.0 - fDist2, 0.0, 1.0) * 0.05;\n\t\t}\n\t}\n\t\n\treturn col;\n}\n\nvec3 TexRandom( vec2 vTexCoord, float fRandom, vec3 vCol0, vec3 vCol1 )\n{\n\treturn mix( vCol0, vCol1, fRandom * fRandom);\n}\n\nfloat SdBox( vec2 vPos, vec2 vSize )\n{\n  vec2 d = abs(vPos) - vSize;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat SdBox( vec2 vPos, vec2 vMin, vec2 vMax )\n{\n    vec2 vMid = (vMin + vMax) * .5;\n    return SdBox( vPos - vMid, (vMax - vMin) * .5 );\n}\n\nfloat BigDoorYellowStripes( vec2 vTexCoord )\n{\n    float fDist = 0.0;\n\n    float fIndentSize = 5.0;\n\n    vTexCoord.x = 64. - abs(vTexCoord.x - 64.);\n    \n    vTexCoord.x = 32. - abs(vTexCoord.x - 32.);\n    \n    float d;\n    d =  min( fIndentSize, -SdBox( vTexCoord, vec2(13,116), vec2(48, 124) ) );\n    fDist = max( fDist, d );\n    \n    float fCorner = clamp( vTexCoord.x - vTexCoord.y + 105., 0.0, 5.0 );\n    fDist = min( fDist, fCorner );\n    \n    return fDist;\n}\n\nfloat BigDoorIndent( vec2 vTexCoord )\n{\n    float fDist = 0.0;\n\n    float d;\n\n    float fIndentSize = 4.0;    \n    \n    d = min( fIndentSize, -SdBox( vTexCoord, vec2(82,19), vec2(93,75) ) );\n    fDist = max( fDist, d );\n        \n    d = min( fIndentSize, -SdBox( vTexCoord, vec2(54,20), vec2(68,74) ) );\n    fDist = max( fDist, d );\n    \n    d = min( fIndentSize, -SdBox( vTexCoord, vec2(15, 19), vec2(68, 49) ) );\n    float fCorner = clamp( vTexCoord.x + vTexCoord.y - 50.0, 0.0, 5.0 );\n    d = min( d, fCorner );    \n    fDist = max( fDist, d );\n    \n    d = min( fIndentSize, -SdBox( vTexCoord, vec2(100, 21), vec2(112, 74) ) );    \n    fDist = max( fDist, d );\n\n    d = min( fIndentSize, -SdBox( vTexCoord, vec2(50,123), vec2(79,126) ) );\n    fDist = max( fDist, d );\n    \n    fIndentSize = 2.0;\n    \n    d = min( fIndentSize, -SdBox( vTexCoord, vec2(41,59), vec2(50,110) ) );\n    fDist = max( fDist, d );\n    \n    fIndentSize = 0.5;\n\n    d = min( fIndentSize, SdBox( vTexCoord, vec2(1, 114), vec2(126, 126) ) );\n    fDist = max( fDist, d );\n    \n    \/\/ Rivets\n    {\n        vec2 vCoord = vTexCoord;\n\n        float m = 10.0;\n        float yMax = 128.0;\n        fIndentSize = 0.5;\n        \n        vCoord.x = 64. - abs(vCoord.x - 64.);\n        \n        if ( vCoord.x > 10.0 )\n        {\n            vCoord.x -= 8.0;\n            m = 6.0;\n            \n            yMax = 80.;\n            fIndentSize = 0.25;\n        }\n\n        if ( vCoord.y < yMax )\n        {\n            vCoord.y = mod(vCoord.y, m);\n\n            d = min( 0.0, -fIndentSize + SdBox( vCoord, vec2(2, 3), vec2(4, 5) ) );\n            fDist += d;\n        }\n    }\n    \n    d = min( 1.0, BigDoorYellowStripes( vTexCoord ) );\n    fDist += d;\n \n    return fDist \/ 5.0;\n}\n\nvec3 TexBigDoor2( vec2 vTexCoord, float fRandom, float fHRandom, vec3 vCol0 )\n{\n    float fShade = 1.0;\n    \n    fShade = 1.0 + (BigDoorIndent( vTexCoord ) - BigDoorIndent( vTexCoord  + vec2(.5, 1.))) * 2.0;\n    \n    vec3 vCol = vCol0 * (0.8 + fHRandom * 0.2);\n    \n\tfloat fMirrorX = 64. - abs(vTexCoord.x - 64.);\n    if ( fMirrorX < 6.0 )\n    {\n        vCol *= 0.75;\n    }\n\n    \n    float f = BigDoorYellowStripes( vTexCoord );\n    if ( f > 0.0 )\n    {\n        if ( mod(vTexCoord.x + vTexCoord.y, 16.0) > 8.0)\n        {\n    \t\tvCol = vec3(175,123,31) \/255.;\n\t\t}\n        else\n        {\n    \t\tvCol = vec3(47)\/255.;\n        }\n    }\n    \n    vCol *= (fHRandom + vTexCoord.y \/ 128.0) * 0.2 + 0.8;\n    vCol *= fRandom * 0.3 + 0.7;\n    \n    float fStreak = 1.0 - clamp( fract(fHRandom * 8.0 + vTexCoord.y \/ 128.0) * 3.0, 0.0, 1.0);\n    fStreak = fStreak * (fHRandom * fHRandom * 0.7 + 0.3);\n    vCol = mix(vCol, vec3(95,67,35)\/255., fStreak );\n    \n\treturn vCol * fShade; \n}\n\nvec3 TexDoor3(vec2 vTexCoord, float fRandom, float fHRandom)\n{\n\tfloat fVNoise = fHRandom + fRandom;\n\tfloat fStreak = clamp(abs(fract(fVNoise) - 0.5) * 3.0, 0.0, 1.0);\n\tfStreak = fStreak * fStreak;\n\t\n\tfloat fShade = 1.0;\n\t\n\tfShade = 1.0 - abs((vTexCoord.y \/ 72.0) - 0.5) * 2.0;\n\tfShade = fShade * fShade;\n\tfShade = fShade * 0.2 + 0.3;\n\t\n\tfShade = fShade * (fHRandom * 0.2 + 0.8);\n\t\n\tfShade *= Indent( vTexCoord, vec2(8.0, 8.0), vec2(64.0 - 8.0, 72.0 - 16.0), 0.8, 1.2);\n\tfShade *= Indent( vTexCoord, vec2(8.0, 72.0 - 15.0), vec2(64.0 - 8.0, 72.0 - 8.0), 0.8, 1.2);\n\t\n\tfShade *= Indent( vTexCoord, vec2(64.0 - 11.0, 46.0), vec2(46.0, 32.0), 0.8, 1.2);\n\tfShade *= Indent( vTexCoord, vec2(64.0 - 11.0, 56.0), vec2(46.0, 52.0), 0.8, 1.2);\n\t\n\tfShade += fRandom * 0.1;\n\n\tfloat fStreakTopAmount = smoothstep( 32.0, 0.0, vTexCoord.y );\n\tfloat fStreakBottomAmount = smoothstep( 72.0 -32.0, 72.0, vTexCoord.y );\n\t\n\tfShade *= 1.0 - fStreak * max(fStreakTopAmount, fStreakBottomAmount) * 0.2;\n\t\n\tif( (vTexCoord.x > 8.0) && (vTexCoord.x < 52.0) )\n\t{\n\t\tvec2 vRepeatCoord = mod( vTexCoord, vec2( 8.0, 48.0 ) );\n\t\tvRepeatCoord += vec2(4.0, -12.0);\n\t\tif( vRepeatCoord.x == 4.0 )\n\t\t{\n\t\t\tif(vRepeatCoord.y == 0.0)\n\t\t\t{\n\t\t\t\tfShade += 0.1;\n\t\t\t}\n\t\t\tif(vRepeatCoord.y > 0.0)\n\t\t\t{\n\t\t\t\tfShade *= clamp(vRepeatCoord.y \/ 16.0, 0.0, 1.0) * 0.3 + 0.7;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn vec3(fShade);\n}\n\nvec3 TexLite3( vec2 vTexCoord )\n{\n\tvec2 vLocalCoord = vTexCoord;\n\tvLocalCoord.y = mod(vLocalCoord.y, 8.0 );\n\t\n\tvec2 vClosest = min( max( vLocalCoord, vec2(4.0, 3.5) ), vec2(32.0 - 5.0, 3.5) );\n\tvec2 vDelta = vLocalCoord - vClosest;\n\tfloat fDist = max(abs(vDelta.x), abs(vDelta.y)) \/ 3.9;\n\t\n\treturn vec3(1.0 - fDist * 0.65);\n}\n\nvec3 TexTLite6_4( vec2 vTexCoord, float fRandom, vec3 vFlatCol, vec3 vLightCol )\n{\n\tvec2 vLocalCoord = vTexCoord;\n\tvLocalCoord = mod(vLocalCoord, 64.0 );\n\t\n    vec2 vAbsLocal = abs( vLocalCoord - 32. );\n    \n    float fDist = (vAbsLocal.x + vAbsLocal.y) \/ 16.0;\n    fDist = fDist * fDist;\n    \n    if ( fDist > 1.0 )\n    {\n        return vFlatCol * (0.5 + fRandom * 0.5);\n    }\n    \n    float fLight = clamp(1.0 - fDist * fDist, 0.0, 1.0);\n\treturn min( vec3(1.0), vLightCol * (fLight * 0.75 + 0.25) + pow( fLight, 5.0 ) * 0.4);    \n}\n\nvec3 TexTLite6_5( vec2 vTexCoord, float fRandom, vec3 vFlatCol, vec3 vLightCol )\n{\n\tvec2 vLocalCoord = vTexCoord;\n\tvLocalCoord = mod(vLocalCoord, 32.0 );\n\t\n    float fDist = length( vLocalCoord - 16. ) \/ 8.0;\n    \n    if ( fDist > 1.0 )\n    {\n        return vFlatCol * (0.5 + fRandom * 0.5);\n    }\n    \n    float fLight = clamp(1.0 - fDist * fDist, 0.0, 1.0);\n\treturn min( vec3(1.0), vLightCol * (fLight * 0.75 + 0.25) + pow( fLight, 5.0 ) * 0.4);    \n}\n   \n\nvec3 TexStartan3( vec2 vTexCoord, float fRandom, vec3 col0, vec3 col1 )\n{\n\tvec3 col = col0;\n\t\n\tfloat fVNoise = noise1D(vTexCoord.x * 0.5) - ((vTexCoord.y) \/ 128.0) + fRandom;\n\tfloat fStreak = clamp(abs(fract(fVNoise) - 0.5) * 3.0, 0.0, 1.0);\n\tfStreak = fStreak * fStreak;\n\t\t\n\tfloat fBlend2 = smoothstep( 0.0, 32.0, abs(vTexCoord.x - 64.0) );\n\tfBlend2 *= fBlend2;\n\tfBlend2 *= fStreak * 0.5 + 0.5;\n\tcol = mix( col, col1, fBlend2 * 0.5);\n\t\n\tfloat fBlend = smoothstep( 24.0, 56.0, abs(vTexCoord.x - 64.0) );\n\tfBlend *= fBlend;\n\tfBlend *= fStreak * 0.7 + 0.3;\n\tcol = mix( col, col1 * 1.1, fBlend);\n\t\n\tcol *= fRandom * fRandom * 0.3 + 0.7;\n\n\tvec2 vCoord = vTexCoord;\n\tvCoord.x = mod(vCoord.x, 32.0);\n\t\n\tfloat fStreakHL = fStreak * 0.075 + 0.075;\n\t\n\tfloat fDistMin = 1.0;\n\tfloat fShade = 0.0;\n\t\n\tvec4 vBump = SmoothBump( vCoord, vec2(6.0, 8.0), vec2(32.0 - 5.0, 9.0), normalize(vec2(0.0, 1.0)), 3.0 );\n\tfShade += vBump.x * 0.1;\n\tfDistMin = min(fDistMin, vBump.y);\n\tfShade += ((vBump.w >= 0.0) && (vBump.w <= 1.0)) ? (1.0 - vBump.w) * fStreakHL : 0.0;\n\tvBump = SmoothBump( vCoord, vec2(6.0, 20.0), vec2(32.0 - 6.0, 40.0), normalize(vec2(0.0, 1.0)), 3.0 ); \n\tfShade += vBump.x * 0.1;\n\tfShade += ((vBump.w >= 0.0) && (vBump.w <= 1.0)) ? (1.0 - vBump.w) * fStreakHL : 0.0;\n\tfDistMin = min(fDistMin, vBump.y);\n\n\tvBump = SmoothBump( vCoord, vec2(6.0, 64.0), vec2(32.0 - 6.0, 65.0), normalize(vec2(0.0, 1.0)), 3.0 );\n\tfShade += vBump.x * 0.1;\n\tfShade += ((vBump.w >= 0.0) && (vBump.w <= 1.0)) ? (1.0 - vBump.w) * fStreakHL : 0.0;\n\tfDistMin = min(fDistMin, vBump.y);\n\tvBump = SmoothBump( vCoord, vec2(6.0, 76.0), vec2(32.0 - 6.0, 110.0), normalize(vec2(0.0, 1.0)), 3.0 ) ;\n\tfShade += vBump.x * 0.1;\n\tfShade += ((vBump.w >= 0.0) && (vBump.w <= 1.0)) ? (1.0 - vBump.w) * fStreakHL : 0.0;\n\tfDistMin = min(fDistMin, vBump.y);\n\n\tvBump = SmoothBump( vTexCoord, vec2(-16.0, 50.0), vec2(256.0, 52.0), normalize(vec2(0.0, 1.0)), 3.0 );\n\tfShade += vBump.x * 0.1;\n\tfShade += ((vBump.w >= 0.0) && (vBump.w <= 1.0)) ? (1.0 - vBump.w) * fStreakHL : 0.0;\n\tfDistMin = min(fDistMin, vBump.y);\n\tvBump = SmoothBump( vTexCoord, vec2(-16.0, 122.0), vec2(256.0, 200.0), normalize(vec2(0.0, 1.0)), 3.0 );\n\tfShade += vBump.x * 0.05;\n\tfDistMin = min(fDistMin, vBump.y);\n\n\tcol *= 1.0 + fShade * 3.0;\n\n\tcol *= clamp((1.0 - fDistMin) * 1.0, 0.0, 1.0) * 0.3 + 0.7;\n\n\treturn col;\n}\n\nvec3 TexBrown1( vec2 vTexCoord, float fRandom, float fHRandom, vec3 vColA, vec3 vColB, vec3 vDirtCol )\n{\n\tvec3 col = mix( vColA, vColB, fRandom * fRandom) \/ 255.0;\n\n\tif(vTexCoord.x >= 64.0)\n\t{\n\t\tcol = col * vec3(1.0, 0.848, 0.646);\n\t\t\n\t\tcol = mix( col, vec3( 0.111, 0.414, 0.3), clamp((fRandom -0.5) * 2.0, 0.0, 1.0)); \/\/ green bits\n\t}\n\t\n\tfloat fVNoise = fHRandom + fRandom;\n\t\n\tfloat fStreak = clamp(abs(fract(fVNoise) - 0.5) * 3.0, 0.0, 1.0);\n\tfStreak = fStreak * fStreak;\n\n\tvec2 vRepeatCoord = vTexCoord;\n\tvRepeatCoord.x = mod(vRepeatCoord.x, 13.0);\n\t\n\tvec4 vBump = SmoothBump( vRepeatCoord, vec2( 5.0, 6.0 ), vec2( 5.0, 12.0), vec2(0.0, 1.0), 1.5);\n\tfloat fMask = clamp(1.0 - vBump.y, 0.0, 1.0);\n\t\n\tfloat fStreakAmount = 1.0;\n\tfStreakAmount *= smoothstep( 0.0, 8.0, vRepeatCoord.y );\n\tfloat fStreakWidth = smoothstep( 64.0, 12.0, vRepeatCoord.y );\n\tfloat fBase1Dist = smoothstep( 24.0, 75.0, vRepeatCoord.y ) * step(vRepeatCoord.y, 75.0);\n\tfloat fBase2Dist = smoothstep( 96.0, 127.0, vRepeatCoord.y );\/\/ * step(75.0, vRepeatCoord.y);\n\tfloat fBaseDist = max(fBase1Dist, fBase2Dist);\n\tfStreakWidth = max( fStreakWidth, fBaseDist);\n\tfloat fTop2Dist = smoothstep( 127.0, 75.0, vRepeatCoord.y ) * step(75.0, vRepeatCoord.y);\n\tfStreakWidth = max(fStreakWidth, fTop2Dist);\n\tfloat fStreakX = abs(vRepeatCoord.x - 5.0) \/ 8.0;\n\tfStreakAmount *= fStreakWidth;\n\tfStreakAmount *= smoothstep( fStreakWidth, 0.0, fStreakX);\n\tfStreakAmount = max(fStreakAmount, (fBaseDist - 0.75) * 4.0);\n\tfStreakAmount *= 1.0 - fMask; \n\tcol = mix(col, vDirtCol, fStreakAmount * (fStreak * 0.5 + 0.5) );\n\t\n\tcol += ((vBump.w >= 0.0) && (vBump.w <= 1.0)) ? (vBump.w) * (1.0-vBump.y) * 0.05 : 0.0;\n\t\n\tif((vTexCoord.y == 17.0) || (vTexCoord.y == 73.0)) col *= 0.9;\n\tif((vTexCoord.y == 19.0) || (vTexCoord.y == 75.0)) col *= 1.2;\n\n\tcol *= 1.0 + clamp(vBump.x, -1.0, 0.0) * 0.6;\n\t\t\n\treturn col;\n}\n\nvec3 TexDoorstop( vec2 vTexCoord, float fRandom )\n{\n\tfloat fShade = 1.0 - abs(vTexCoord.x - 3.4) \/ 4.0;\n\t\n\tfShade = fShade * 0.2 + 0.2;\n\t\n\tfloat fSin = sin((vTexCoord.y - 16.0) * 3.14150 * 4.0 \/ 128.0) * 0.5 + 0.5;\n\tfShade *= 0.8 + fRandom * 1.2 * fSin;\n\t\n\treturn vec3(fShade);\n}\n\nvoid DrawScreen(inout vec3 col, const in vec2 vTexCoord, const in vec2 vPos, const in vec2 vSize, const in vec3 vCol)\n{\n\tvec2 vScreenCoord = vTexCoord - vPos;\n\tcol *= Indent( vScreenCoord, vSize, vec2(-1.0), 1.2, 0.5);\n\n\tif((vScreenCoord.x >= 0.0) && (vScreenCoord.y >= 0.0) && (vScreenCoord.x < vSize.x) && (vScreenCoord.y < vSize.y))\n\t{\n\t\tcol = vCol;\n\t}\n}\n\nbool Screen( inout vec3 col, const in vec2 vTexCoord, const in vec2 vPos, const in vec2 vSize, out vec2 vUV )\n{\n\tvec2 vScreenCoord = vTexCoord - vPos;\n\tcol *= Indent( vScreenCoord, vSize, vec2(-1.0), 1.2, 0.5);\n\n    vUV = vScreenCoord \/ vSize;\n    \n\tif((vScreenCoord.x >= 0.0) && (vScreenCoord.y >= 0.0) && (vScreenCoord.x < vSize.x) && (vScreenCoord.y < vSize.y))\n\t{\n        return true;\n\t}\n    return false;\n}\n\n\nvec3 TexCompute2( vec2 vTexCoord, float fRandom )\n{\n    fRandom = 1.0 - fRandom * fRandom;\n\tvec3 col = vec3(35.0 \/ 255.0);\n\t\n\tcol *= Indent( vTexCoord, vec2( -8.0, 0.0), vec2(300.0, 10.0), 1.3, 0.5);\n\tcol *= Indent( vTexCoord, vec2( -8.0, 11.0), vec2(300.0, 27.0), 1.3, 0.5);\n\tcol *= Indent( vTexCoord, vec2( -8.0, 28.0), vec2(300.0, 43.0), 1.3, 0.5);\n\t{\n\t\tvec2 vLocalCoord = vTexCoord;\n\t\tvLocalCoord.x = mod(vLocalCoord.x, 21.0);\n\t\tcol *= Indent( vLocalCoord, vec2( 0.0, 44.0), vec2(20.0, 55.0), 1.3, 0.5);\n\t}\n\n\tif(vTexCoord.y < 40.0)\n\t{\n\t\tvec2 vTileSize = vec2(48.0, 14.0);\n\t\tvec2 vIndex = floor(vTexCoord \/ vTileSize);\n\n\t\tfloat fIndex = vIndex.x + vIndex.y * 13.0;\n\t\tvec2 vMin = vIndex * vTileSize + vec2(Hash(fIndex) * 32.0, 4.0);\n\t\tvec2 vSize = vec2(8.0 + Hash(fIndex + 1.0) * 32.0, 4.0);\n\n\t\tvec3 vCol = vec3(0.0);\n\t\tfloat iIndex = floor(mod(fIndex, 5.0));\n\t\tif( iIndex < 0.5 ) \n\t\t{\n\t\t\tvCol = mix(vec3(0.0, 0.5, 0.0), vec3(0.0, 0.25, 0.0), fRandom);\n\t\t}\n\t\telse if(iIndex < 1.5)\n\t\t{\n\t\t\tvCol = mix(vec3(1.0, 0.6, 0.02), vec3(0.1), fRandom);\n\t\t}\n\t\telse if(iIndex < 2.5)\n\t\t{\n\t\t\tvCol = vec3(fRandom * 0.5);\n\t\t}\n\t\telse if(iIndex < 3.5)\n\t\t{\n\t\t\tvCol = vec3(fRandom * 0.25);\n\t\t}\n\t\telse if(iIndex < 4.5)\n\t\t{\n\t\t\tvCol = mix(vec3(0.0, 0.0, 0.5), vec3(0.1), fRandom);\n\t\t}\n\t\tDrawScreen(col, vTexCoord, vMin, vSize, vCol);\n\t}\n\n\treturn col;\n}\n\nvec3 TexStep6( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n\tvec3 col = mix( vec3(87.0, 67.0, 51.0), vec3(119.0, 95.0, 75.0), fRandom) \/ 255.0;\n\n\tcol *= Indent( vTexCoord, vec2(-1.0, 3.0), vec2(32.0, 1.0), 1.3, 0.7);\n\tcol *= Indent( vTexCoord, vec2(-1.0, 8.0), vec2(32.0, 0.0), 1.3, 0.9);\n\n\tfloat fStreak = clamp((vTexCoord.y \/ 16.0) * 1.5 - fHRandom, 0.0, 1.0);\n\n\tcol *= fStreak * 0.3 + 0.7;\n\t\n\treturn col;\n}\n\nvec3 TexSupport2( vec2 vTexCoord, float fRandom )\n{\n\tvec3 col;\n\tfloat fShade = 0.5;\n\t\n\tfloat f1 = abs(fract((vTexCoord.y + 32.0) \/ 70.0) - 0.5) * 2.0;\n\tfloat f2 = abs(fract((vTexCoord.x + 16.0) \/ 16.0) - 0.5) * 2.0;\n\tfShade += f1 * 0.75 + f2 * 0.25;\n\tfShade = fShade * fShade;\n\n\tfShade = fShade * 0.2 + 0.05;\n\tfShade *= 1.0 + fRandom * 0.4;\n\n\tvec2 vLocalCoord = vTexCoord;\n\tif((vLocalCoord.y < 64.0) || (vLocalCoord.y > 75.0))\n\t{\n\t\tif(vLocalCoord.y > 64.0) vLocalCoord.y -= 8.0;\n\t\tvLocalCoord = mod( vLocalCoord, vec2(20.0, 16.0));\n\t\tfloat fIndent = Indent( vLocalCoord, vec2(8.0, 8.0), vec2(16.0, 15.0), 0.9, 1.1);\n\t\tfShade += fIndent - 1.0;\n\t}\n\t\n\tcol = vec3(fShade);\n\t\n\treturn col;\n}\n\nvec3 TexDoorTrak( vec2 vTexCoord, float fRandom )\n{\n\tfloat fShade = fRandom * 0.5;\n\tfShade *= mod(vTexCoord.x, 2.0) * 0.6 + 0.4;\n\treturn vec3(fShade);\n}\n\nvec3 TexBrown144( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n\tvec3 col = mix( vec3(39.0, 39.0, 39.0), vec3(51.0, 43.0, 19.0), fRandom) \/ 255.0;\n\t\n\tfloat fBlend = fHRandom - 0.1;\n\tfBlend = clamp(fBlend, 0.0, 1.0);\n\tcol = mix( col, col * 2.0 * vec3(0.893, 0.725, 0.161), fBlend);\n\treturn col;\n}\n\nvec3 TexNuke24( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n\tvec3 col = mix( vec3(51.0, 43.0, 19.0), vec3(79.0, 59, 35.0), fRandom) \/ 255.0;\n\tvec3 colNuke = mix( vec3(11.0, 23.0, 7.0), vec3(46.0, 83, 39.0), fRandom) * 2.5 \/ 255.0;\n\tfloat fBlend = -0.25 -fHRandom + vTexCoord.y \/ 12.0;\/\/ * 3.0;\n\tfBlend = clamp(fBlend, 0.0, 1.0);\n    fBlend= fBlend * fBlend;\n\tcol = mix( col, colNuke, fBlend);    \n\treturn col;\n}\n\nvec3 TexPlanet1( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n    float fShade;\n    float fMirrorY = 64.0 - abs(vTexCoord.y - 64.0);\n    \n    fShade = cos( 3.14 * (fMirrorY - 36.0) \/ 36.0 ) * 0.5 + 0.5;\n    fShade *= fRandom * 0.5 + 0.5;\n\n    float fStreak = clamp(0.0, 1.0, fHRandom + fMirrorY \/ 32.0);\n    fShade *= fStreak;\n    \n\tvec3 col = mix( vec3(59), vec3(147), fShade) \/ 255.0;\n\n    vec2 vMin = vec2(4,7);\n    vec2 vMax = vec2(58,60);\n    \n    float fIndex = 0.0;\n    \n    if ( vTexCoord.x > 128.0 )\n    {\n        vMin.x += 128.;\n        vMax.x += 128.;\n        \n        fIndex += 2.0;\n    }\n    else\n    if ( vTexCoord.x > 64.0 )\n    {\n        vMin.x += 64.;\n        vMax.x += 64.;\n        \n        fIndex += 1.0;\n    }\n    \n    if ( vTexCoord.y > 64.0 )\n    {\n        vMin.y += 62.;\n        vMax.y += 62.;\n        \n        fIndex += 3.0;\n    }\n    \n    if ( all( greaterThanEqual( vTexCoord, vMin ) ) &&\n         all( lessThanEqual( vTexCoord, vMax ) ))\n    {\n        col = vec3(0.0);\n        \n        vec2 vUV = (vTexCoord - (vMin + 1.0)) \/ (vMax - vMin - 2.);\n\t    if ( all( greaterThanEqual( vUV, vec2(0.0) ) ) &&\n    \t     all( lessThan( vUV, vec2(1.0) ) ))\n    \t{\n            col = vec3(0.0);\n\n            float fSize = mod((1.0 + fIndex) * 1.45, 1.0);\n            float fOffset = mod((1.0 + fIndex) * 1.84, 1.0);\n            \n            vec2 vXY = vUV * 2.0 - 1.0;\n            vXY += fOffset;\n            float l = length(vXY);\n\n            vec3 vPlanetCol = vec3(0.5,0.2,.4) + vec3(8.3,2.24,5.89) * fIndex;\n            vPlanetCol = mod( vPlanetCol, vec3(1));\n            vPlanetCol *= vec3(1., .2, .01);\n            vPlanetCol = normalize(vPlanetCol);\n            \n            if ( fIndex == 4.0 )\n            {\n            \tcol = vPlanetCol * max( 0.0, fRandom - l * 0.5 );\n            }\n            else\n            {\n            \t\/\/ planet                       \n                if ( l < fSize )\n                {                \n                    col = vPlanetCol;\n\n                    vec3 vLight = vec3(0.1,0.5,.4) + vec3(5.435,32.345,32.923) * fIndex;\n                    vLight = mod( vLight, 1.0);\n                    vLight.xy = vLight.xy * 2.0 - 1.0;\n                    vLight = normalize(vLight);\n\n\n                    vec2 vD = vXY;\n                    vec3 vNorm = vec3(vD, sqrt( fSize * fSize - l * l ));\n                    float fPlanetShade = max(0.0, dot( vNorm, vLight));\n                    col *= fPlanetShade; \n                }\n                else\n                {\n                    float f = min(1.0, fRandom \/ .75);\n                    col = vec3(1.) * pow( f, 100.0) * 0.25;\n                    \/*\n                    if ( fRandom > 0.75 )\n                    {\n                        col = vec3(0.5);\n                    }*\/\n                }\n            }\n            \n            \n            col += 0.1;\n            \/\/ sheen\n            col += max(0.0, 1.0 - (vUV.x + vUV.y) * 2.0) * 0.3;\n        }\n        \n    }\n\t\/\/if( Screen( col, const in vec2 vTexCoord, const in vec2 vPos, const in vec2 vSize, out vec2 vUV )\n    \n    \n\treturn col;    \n}\n\nfloat Line( vec2 vCoord, vec2 vA, vec2 vB )\n{\n    vec2 vDelta = vB - vA;\n    vec2 vDir = normalize(vDelta);\n    vec2 vOffset = vCoord - vA;\n    \n    float fProj = dot( vOffset, vDir );\n    \n     fProj = clamp( fProj, 0.0, length(vDelta) );\n    vec2 vClosest = vA + vDir * fProj;\n    \n    float d = max(0.0, 1.0 - length( vClosest - vCoord ) * 0.25);\n    return d * d * d;\n    \/\/return 0.0;\n}\n\nvec3 TexExitSign( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n    vec3 vCol = vec3(59) \/ 255.;\n    \n    vec2 vBevelMin = vec2(1,1);\n    vec2 vBevelMax = vec2(30,14);\n   \n    if ( vTexCoord.y == (vBevelMin.y-1.) )\n    {\n        vCol *= 1.5;\n    }\n    if ( vTexCoord.y == (vBevelMax.y+1.) )\n    {\n        vCol *= 0.5;\n    }\n    if ( vTexCoord.x == (vBevelMin.x-1.) )\n    {\n        vCol *= 1.1;\n    }\n    if ( vTexCoord.x == (vBevelMax.x+1.) )\n    {\n        vCol *= 0.75;\n    }\n    \n    if ( all( greaterThanEqual(vTexCoord, vec2(2,2) ) ) &&\n        all( lessThanEqual(vTexCoord, vec2(29,13) ) )         \n    )\n    {\n        vCol = vec3(0.0);\n        \n        vec3 vLetterCol = vec3(227,0,0) \/ 255.;\n        vLetterCol *= 1.0 - (vTexCoord.y \/ 30.0);\n        \n        \/\/ Verticals\n        vec2 vA = vec2(4,4);\n        vec2 vB = vec2(4,11);\n        \n        if ( vTexCoord.x > 23. ) \n        {\n            vA.x = vB.x = 25.0;\n    \t}\n        else\n        if ( vTexCoord.x > 15. ) \n        {\n            vA.x = vB.x = 20.0;\n            \n        }\n                \n        vCol = mix( vCol, vLetterCol, Line( vTexCoord, vA, vB ) );\n        \n        \/\/ Horizontals\n        vA = vec2(4,4);\n        vB = vec2(9,4);\n        \n        if ( vTexCoord.x > 20. ) \n        {\n            vA.x = 22.;\n            vB.x = 28.;\n        }\n        else\n        if ( vTexCoord.y > 10. ) \n        {\n            vA.y = 11.;\n            vB.y = 11.;\n        }\n        else\n        if ( vTexCoord.y > 4. ) \n        {\n            vA.y = 7.;\n            vB.y = 7.;\n            vB.x = 7.;\n        }\n        \n        vCol = mix( vCol, vLetterCol, Line( vTexCoord, vA, vB ) );\n                \n        vCol = mix( vCol, vLetterCol, Line( vTexCoord, vec2(11,4), vec2(18,11) ) );\n        vCol = mix( vCol, vLetterCol, Line( vTexCoord, vec2(11,11), vec2(18,4) ) );\n    }\n    \n    return vCol;\n}\n\n\n\nfloat IsTile( vec2 vTexCoord )\n{\n    float y = 63.5 - abs( vTexCoord.y - 63.5);\n    \n    float f = y - 5.0;\n    float fm = f;\n    \n    float fRepeat = 29. - 13.;\n    \n    float x = 64. - abs(vTexCoord.x - 64.);\n    \n    if ( f > 0.0 && f < fRepeat * 3.5 )\n    {\n    \tfm = mod( fm, fRepeat ); \n    }\n    else\n    {\n        fm = 0.0;\n    }\n        \n    if ( fm > 7.0)\n    {\n\t    if ( x > 23. )\n            return 1.0;\n    }\n    else\n    {\n\t    if ( x > 31. )\n            return 1.0;\n    }\n    return 0.0;\n}\n\nvec3 TexCompTile( vec2 vTexCoord, float fRandom )\n{   \n    \/\/ Blue\n    vec3 vCol0 = vec3(0.0, 0.0, 35.0 \/ 255.0);\n    vec3 vCol1 = vec3(0.0, 0.0, 200.0 \/ 255.0);\n    vec3 blueCol = mix( vCol0, vCol1, fRandom * fRandom * 2.5);\n    \n    if ( IsTile(vTexCoord) > 0.0 )\n    {\n        return blueCol;\n    }\n    \n    vec3 col = vec3(39.\/255.);\n    if ( IsTile( vTexCoord - 1. ) > 0.0 )\n    {\n        col += 0.1;\n    }\n    else\n    if ( IsTile( vTexCoord + 1. ) > 0.0 )\n    {\n        col -= 0.1;\n    }\n    \n    if ( vTexCoord.x == 0.0 ) col += 0.1;\n    if ( vTexCoord.x == 127.0 ) col -= 0.1;\n    if ( vTexCoord.y == 0.0 ) col += 0.1;\n    if ( vTexCoord.y == 127.0 ) col -= 0.1;\n    if ( vTexCoord.y == 64.0 ) col += 0.1;\n    if ( vTexCoord.y == 63.0 ) col -= 0.1;\n    \n    \n    return col;\n}\n\nvec3 TexTekWall1( vec2 vTexCoord, float fRandom )\n{\n\tvec3 col = mix( vec3(39.0, 39.0, 39.0), vec3(51.0, 51.0, 51.0), fRandom * fRandom) \/ 255.0;\n\t\n\treturn col;\n}\n\nvoid TexAddSwitch( inout vec3 col, vec2 vTexCoord, float fRandom )\n{    \n    vec2 vMin = vec2(16., 72.);\n    vec2 vMax = vec2(47., 103.);\n\n    if ( all( greaterThanEqual( vTexCoord, vMin ) ) && \n        all( lessThanEqual( vTexCoord, vMax ) ))\n    {\n        col = vec3( 0.5 );\n        \n        col *= Indent(vTexCoord, vMax, vMin, 0.5, 1.5);\n        \n        DrawScreen( col, vTexCoord, vec2(22,91), vec2(9,8), vec3(1,0,0));\n        DrawScreen( col, vTexCoord, vec2(22,77), vec2(9,8), vec3(0,.3,0));\n        \n        col *= Indent(vTexCoord, vec2(38,79), vec2(39,96), 0.5, 1.1);\n\n        vec2 vSwMin = vec2(37,81);\n        vec2 vSwMax = vSwMin + vec2(3,2);\n        if ( all( greaterThanEqual( vTexCoord, vSwMin ) ) && \n        \tall( lessThanEqual( vTexCoord, vSwMax ) ))\n        {\n            col = vec3(0.5, 0.4, 0.3);\n            col *= Indent(vTexCoord, vSwMax, vSwMin, 0.5, 1.5);\n        }\n        \n        col *= fRandom * 0.5 + 0.5;\n    }    \n}\n\nvec3 SampleTexture( uint iTexture, const in vec2 _vUV )\n{\n    vec3 vCol0 = vec3(0.6);\n    vec3 vCol1 = vec3(119.0, 79.0, 43.0) \/ 255.0;\n    vec3 vCol2 = vec3(0);\n    \n    uint iOrigTexture = iTexture;\n    \n        \n    vec3 col = vec3(1.0, 1.0, 1.0);\n#ifdef DEBUG_IDENTIFY_UNDEFINED_TEXTURES    \n    col = vec3(1.0, 0.0, 1.0);\n#endif  \n    \n#ifdef DEBUG_IDENTIFY_TEXTURE\n    if ( fTexture == DEBUG_IDENTIFY_TEXTURE && (fract(iTime) < 0.5))\n    {\n        return vec3(1.0, 0.0, 1.0);\n    }\n#endif     \n    \n    vec2 vUV = _vUV;\n    \n    vec2 vSize = vec2(64.0);\n    float fPersistence = 0.8;\n\tfloat fNoise2Freq = 0.5;\n    vec2 vRandomStreak = vec2(0.0);\n    \n    \/\/ Direct Substitutes\n    if ( iTexture == TEX_FLOOR1_1 )\n    {\n        iTexture = TEX_FLAT14;\n    }\n    else \n    if ( iTexture == TEX_BROWN96 )\n    {\n        iTexture = TEX_BROWN1;\n    }\n    else\n    if ( iTexture == TEX_COMPTALL)\n    {\n        iTexture = TEX_STARGR1;\n    }\n    else\n    if ( iTexture == TEX_DOORSTOP )\n    {\n        iTexture = TEX_DOORTRAK;\n    }\n    else\n    if ( iTexture == TEX_FLAT20 )\n    {\n        iTexture = TEX_DOORSTOP;\n    }\n\telse\n    if (iTexture == TEX_TEKWALL4\n       || iTexture == TEX_STEP2)\n    {\n        \/\/ start area pillars\n        iTexture = TEX_TEKWALL1;\n    }\n    else\n    if (iTexture == TEX_STEP1)\n    {\n        \/\/ Comp room steps (lights added later)\n        iTexture = TEX_STEP6;\n    }\n    else\n    if ( iTexture == TEX_SLADWALL)\n    {\n        iTexture = TEX_BROWNGRN;\n    }\n    else\n    if ( iTexture == TEX_EXITDOOR )\n    {\n        iTexture = TEX_DOOR3;\n    }\n    else\n\tif ( iTexture == TEX_FLAT23 )\n    {\n        iTexture = TEX_FLAT18;\n    }         \n        \n        \n    \n    if ( iTexture == TEX_FLOOR4_8)\n    {\n        \/\/ start area\n\t    vCol0 = vec3(30.0, 30.0, 30.0);\n        vCol1 = vec3(150.0, 150.0, 150.0);\n    }\n\telse        \n    if ( iTexture == TEX_FLOOR5_1)\n    {\n        \/\/ Corridor to outside\n        iTexture = TEX_FLOOR4_8;\n        vCol0 = vec3(51.0, 43.0, 19.0);\n        vCol1 = vec3(150.0, 150.0, 150.0);\n    }\n\telse        \n    if ( iTexture == TEX_FLOOR5_2 )\n    {\n        \/\/ imp\/nukage room\n        iTexture = TEX_FLOOR4_8;\n        vCol0 = vec3(51.0, 43.0, 19.0);\n\t\tvCol1 = vec3(79.0, 59, 35.0);\n    }\n    \n    if ( iTexture == TEX_TLITE6_5)\n    {\n\t\tvCol0 = vec3(.2);        \n\t\tvCol1 = vec3(1,0,0);\n    }\n    if ( iTexture == TEX_TLITE6_6 )\n    {\n        iTexture = TEX_TLITE6_5;\n        vCol0 = vec3(.25, .2, .1);\n        vCol1 = vec3(.8,.6,.4);\n    }\n\n    if ( iTexture == TEX_TLITE6_4 )\n    {\n        vCol0 = vec3(.25, .2, .1);\n        vCol1 = vec3(.8,.6,.4);\n    }\n    else\n    if ( iTexture == TEX_TLITE6_1 )\n    {\n        iTexture = TEX_TLITE6_4;\n\t\tvCol0 = vec3(.2);        \n\t\tvCol1 = vec3(1);\n    }\n\n    if ( iTexture == TEX_BIGDOOR2 )\n    {\n    \tvCol0 = vec3(119) \/255.;\n    }\n    else\n    if ( iTexture == TEX_BIGDOOR4 )\n    {\n        iTexture = TEX_BIGDOOR2;\n    \tvCol0 = vec3(103,83,63) \/255.;\n    }\n    \n    if ( iTexture == TEX_FLOOR7_1 )\n    {\n\t    vCol0 = vec3(51.0, 43.0, 19.0);\n        vCol1 = vec3(79.0, 59, 35.0);\n\t}\n    \n    if ( iTexture == TEX_CEIL5_2 )\n    {\n        iTexture = TEX_FLOOR7_1;\n\t    vCol0 = vec3(51.0, 43.0, 19.0) * .75;\n        vCol1 = vec3(79.0, 59, 35.0) * .75;\n\t}\n    \n    if ( iTexture == TEX_BROWN1 )\n    {\n        vCol0 = vec3(119.0, 95.0, 63.0);\n        vCol1 = vec3(147.0, 123.0, 99.0);\n        vCol2 = vec3(0.3, 0.2, 0.1);\n    }\n    else\n    if ( iTexture == TEX_BROWNGRN )\n    {\n        iTexture = TEX_BROWN1;\n        vCol1 = vec3(43,35,15);\n        vCol0 = vec3(47.0, 47.0, 47.0);\n        \/\/vCol1 = vec3(147.0, 123.0, 99.0);\n        \/\/vCol1 = vec3(123.0, 127.0, 99.0);\n        vCol2 = vec3(19,35,11) \/ 255.;\n    }\n    \n    if ( iTexture == TEX_FLAT14 )\n    {\n        \/\/ Blue noise\n \t\tvCol0 = vec3(0.0, 0.0, 35.0 \/ 255.0);\n        vCol1 = vec3(0.0, 0.0, 200.0 \/ 255.0);\n\t\tfPersistence = 2.0;\n    }\n    else\n    if ( iTexture == TEX_CEIL5_1 )\n    {\n        \/\/ Comp room side ceil\n        iTexture = TEX_FLAT14;        \n \t\tvCol0 = vec3(30.0 \/ 255.0);\n        vCol1 = vec3(15.0 \/ 255.0);\n\t\tfPersistence = 2.0;\n    }\n    else\n    if ( iTexture == TEX_FLAT18 )\n    {\n        \/\/ Comp room side floor\n        iTexture = TEX_FLAT14;        \n \t\tvCol0 = vec3(70.0 \/ 255.0);\n        vCol1 = vec3(40.0 \/ 255.0);\n\t\tfPersistence = 2.0;\n    }   \n    else\n    if ( iTexture == TEX_COMPSPAN )\n    {\n        \/\/ Comp room wall lower\n        iTexture = TEX_FLAT14;        \n \t\tvCol0 = vec3(70.0 \/ 255.0);\n        vCol1 = vec3(30.0 \/ 255.0);\n\t\tfPersistence = 1.0;\n    }\n    else\n    if ( iTexture == TEX_FLOOR6_2 )\n    {\n        \/\/ secret shotgun area ceil\n        iTexture = TEX_FLAT14;        \n \t\tvCol0 = vec3(120.0 \/ 255.0);\n        vCol1 = vec3(0.0 \/ 255.0);\n\t\tfPersistence = 1.25;\n    }\n\n    if ( iTexture == TEX_FLOOR7_2 )\n    {\n        \/\/ Green armor ceil\n        iTexture = TEX_FLAT14;\n \t\tvCol0 = vec3(85,89,60)\/255.;\n        vCol1 = vec3(0.0, 0.0, 0);\n\t\tfPersistence = 0.5;\n    }\n    \n    if ( iTexture == TEX_COMPUTE3 )\n    {\n        iTexture = TEX_COMPUTE2;\n    }       \n\n\tif(iTexture == TEX_NUKAGE3)\n\t{\n        float fTest = fract(floor(iTime * 6.0) * (1.0 \/ 3.0));\n        if( fTest < 0.3 )\n        {\n\t        vUV += 0.3 * vSize;\n        }\n        else if(fTest < 0.6)\n        {\n            vUV = vUV.yx - 0.3; \n        }\n        else\n        {\n            vUV = vUV + 0.45;\n        }\n\t}\n    \n    if ( iTexture == TEX_STARTAN1 )\n    {\n        iTexture = TEX_STARTAN3;\n        vCol0 = vec3(131.0, 101.0, 75.0) \/ 255.0;\n        vCol1 = vec3(131.0, 101.0, 75.0) \/ 255.0;\n    }\n    else\n    if ( iTexture == TEX_STARG3 )\n    {\n        iTexture = TEX_STARTAN3;\n\t\tvCol0 = vec3(0.6);\n\t\tvCol1 = vec3(123,127,99) \/ 255.0;\n    }\n    else\n    if ( iTexture == TEX_STARGR1 )\n    {\n        iTexture = TEX_STARTAN3;\n\t\tvCol0 = vec3(0.6);\n\t\tvCol1 = vec3(0.6);  \n    }\n    else\n    if ( iTexture == TEX_SW1STRTN )\n    {\n        iTexture = TEX_STARTAN3;\n        vCol0 = vec3(131.0, 101.0, 75.0) \/ 255.0;\n        vCol1 = vec3(131.0, 101.0, 75.0) \/ 255.0;\n    }   \n    \n    \/\/ Should be a sidedef flag\n    if ( iOrigTexture == TEX_TEKWALL1 )\n    {\n        vUV.x = mod(vUV.x + floor(iTime * 50.0), 64.);\n    }\n    \n\t\n\tif(iTexture == TEX_NUKAGE3) { fPersistence = 1.0; }\n\tif(iTexture == TEX_F_SKY1) { vSize = vec2(256.0, 128.0); fNoise2Freq = 0.3; }\n    if(iTexture == TEX_FLOOR7_1 ||\n      iTexture == TEX_CEIL5_2 ) { vSize = vec2(64.0, 32.0); fPersistence = 1.0; }\t\n    if(iTexture == TEX_FLAT5_5) { fPersistence = 3.0; }\n    if(iTexture == TEX_FLOOR4_8) { fPersistence = 0.3; }\n    if(iTexture == TEX_CEIL3_5) { fPersistence = 0.9; }\t\n    if(iTexture == TEX_DOOR3) { vSize = vec2(64.0, 72.0); }\t\n    if(iTexture == TEX_LITE3) { vSize = vec2(32.0, 128.0); }\t\n    if(iTexture == TEX_STARTAN3) { vSize = vec2(128.0); fPersistence = 1.0; }\t\n    if(iTexture == TEX_STARGR1) { vSize = vec2(128.0); fPersistence = 1.0; }\t    \n    if(iTexture == TEX_BIGDOOR2) { vSize = vec2(128.0, 128.0); fPersistence = 0.5; vRandomStreak = vec2(0,128.); }\t    \n\tif(iTexture == TEX_BROWN1) { vSize = vec2(128.0); fPersistence = 0.7; }\t\n\tif(iTexture == TEX_BROWNGRN) { vSize = vec2(128.0); fPersistence = 0.7; }\t    \n    if(iTexture == TEX_DOORSTOP) { vSize = vec2(8.0, 128.0); fPersistence = 0.7; }\n    if(iTexture == TEX_COMPUTE2) { vSize = vec2(256.0, 56.0); fPersistence = 1.5; }\n    if(iTexture == TEX_STEP6) { vSize = vec2(32.0, 16.0); fPersistence = 0.9; }\n    if(iTexture == TEX_SUPPORT2) { vSize = vec2(64.0, 128.0); }\n    if(iTexture == TEX_DOORTRAK) { vSize = vec2(8.0, 128.0); }\n    if(iTexture == TEX_TEKWALL1) {  fPersistence = 1.0;vSize = vec2(64.0, 64.0); }\n    if(iTexture == TEX_TLITE6_5) { fPersistence = 1.0; vSize = vec2(64.0, 64.0); }\n    if(iTexture == TEX_TLITE6_4) { fPersistence = 1.0; vSize = vec2(64.0, 64.0); }\n    if(iTexture == TEX_NUKE24) { vSize = vec2(64.0,24.0); }\n    if(iTexture == TEX_COMPTILE) { vSize = vec2(128.); vRandomStreak = vec2(16.0, 0); }\n    if(iTexture == TEX_PLANET1) { vSize = vec2(256.0, 128.0); vRandomStreak = vec2(0.0, 255.); }\n    if(iTexture == TEX_EXITSIGN) { vSize = vec2(64,16); }\n\t\n#ifdef PREVIEW\n\t     if(fTexture == TEX_DOOR3) {\tvSize = vec2(128.0, 128.0); }\t\n\telse if(fTexture == TEX_COMPUTE2) { vSize = vec2(256.0, 64.0); }\n#endif\n\t\n\t\n#ifdef PREVIEW\n    vec2 vTexCoord = floor(fract(vUV) * vSize);\n#else\n    vec2 vTexCoord = fract(vUV \/ vSize) * vSize;\n    #ifdef PIXELATE_TEXTURES\n    vTexCoord = floor(vTexCoord);\n    #endif\n    vTexCoord.y = vSize.y - vTexCoord.y - 1.0;\n#endif\n    \n\tfloat fHRandom = noise1D(vTexCoord.x * fNoise2Freq);\n    float fHOffset =  - ((vTexCoord.y) \/ vSize.y);\n\n    vec2 vRandomCoord = vTexCoord + float(iTexture);\n    vRandomCoord += fHRandom * vRandomStreak;\n\tfloat fRandom = fbm( vRandomCoord, fPersistence );\n\n\tif(iTexture == TEX_NUKAGE3) \tcol = TexNukage3( vTexCoord, fRandom );\n\tif(iTexture == TEX_F_SKY1) \tcol = TexFSky1( vTexCoord, fRandom, fHRandom );\n    if(iTexture == TEX_FLOOR7_1) \tcol = TexFloor7_1( vTexCoord, fRandom, vCol0, vCol1 );\n    if(iTexture == TEX_FLAT5_5) \tcol = TexFlat5_5( vTexCoord, fRandom );\n    if(iTexture == TEX_FLOOR4_8) \tcol = TexFloor4_8( vTexCoord, fRandom, vCol0, vCol1 );\n    if(iTexture == TEX_CEIL3_5) \tcol = TexCeil3_5( vTexCoord, fRandom );\n\tif(iTexture == TEX_FLAT14) \tcol = TexRandom( vTexCoord, fRandom, vCol0, vCol1 );\n\tif(iTexture == TEX_DOOR3) \t\tcol = TexDoor3( vTexCoord, fRandom, fHRandom + fHOffset);\n\tif(iTexture == TEX_LITE3) \t\tcol = TexLite3( vTexCoord );\n    if(iTexture == TEX_STARTAN3) \tcol = TexStartan3( vTexCoord, fRandom, vCol0, vCol1 );\n\tif(iTexture == TEX_BIGDOOR2) \tcol = TexBigDoor2( vTexCoord, fRandom, fHRandom, vCol0 );\n    if(iTexture == TEX_BROWN1) \tcol = TexBrown1( vTexCoord, fRandom, fHRandom + fHOffset, vCol0, vCol1, vCol2 );\n    if(iTexture == TEX_DOORSTOP) \tcol = TexDoorstop( vTexCoord, fRandom );\n    if(iTexture == TEX_COMPUTE2) \tcol = TexCompute2( vTexCoord, fRandom );\n    if(iTexture == TEX_STEP6) \t\tcol = TexStep6( vTexCoord, fRandom, fHRandom + fHOffset );\n    if(iTexture == TEX_SUPPORT2) \tcol = TexSupport2( vTexCoord, fRandom );\n\tif(iTexture == TEX_DOORTRAK) \tcol = TexDoorTrak( vTexCoord, fRandom );\n\tif(iTexture == TEX_BROWN144) \tcol = TexBrown144( vTexCoord, fRandom, fHRandom  + fHOffset );\n    if(iTexture == TEX_TEKWALL1)\tcol = TexTekWall1( vTexCoord, fRandom );\n    if(iTexture == TEX_TLITE6_5)\tcol = TexTLite6_5( vTexCoord, fRandom, vCol0, vCol1 );\n    if(iTexture == TEX_TLITE6_4)\tcol = TexTLite6_4( vTexCoord, fRandom, vCol0, vCol1 );\n    if(iTexture == TEX_NUKE24) \tcol = TexNuke24( vTexCoord, fRandom, fHRandom );\n\tif(iTexture == TEX_PLANET1)\tcol = TexPlanet1( vTexCoord, fRandom, fHRandom );\n#ifndef LINUX_WORKAROUND\n\tif(iTexture == TEX_EXITSIGN)\tcol = TexExitSign( vTexCoord, fRandom, fHRandom );\n#endif\n\t\n    if (iTexture == TEX_COMPTILE)\tcol = TexCompTile( vTexCoord, fRandom );\n        \n    if ( iOrigTexture == TEX_SW1STRTN )\n    {\n        TexAddSwitch( col, vTexCoord, fRandom );\n    }\n    else\n    if (iOrigTexture == TEX_STEP1)\n    {\n        \/\/\/ Add lights\n        vec2 d = vTexCoord - vec2(16,8);\n        col *= max(0.3, 1.0 - 0.005 * dot(d,d) );\n    }    \n        \n    #ifdef QUANTIZE_TEXTURES\n    col = Quantize(col, 32.0);\n    #endif\n   \n#ifdef DEBUG_IDENTIFY_TEXTURES\n    vec2 vFontUV = fract(_vUV * vec2(.08) * vec2(1., 2.) ) * 3.0 \/ vec2(1., 2.);\n    if ( PrintValue(vFontUV, fOrigTexture, 2., 0.) > 0.0 )\n    {\n        col = vec3(1.,0,0);\n    }\n#endif    \n\n    return col;\n}\n\n","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n#define FAR_CLIP 1000000.0\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Util\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec3 Quantize( const in vec3 col, float fLevels )\n{\n\treturn floor( col * fLevels + 0.5 ) * (1.0 \/ fLevels);\n}\n\nfloat Cross2d( const in vec2 vA, const in vec2 vB )\n{   \n    return vA.x * vB.y - vA.y * vB.x;\n}\n\nvoid SetFlag( inout int iBits, int iFlag )\n{\n    iBits |= iFlag;\n}\n\n\nbool FlagSet( int iBits, int iFlag )\n{\n    return (iBits & iFlag) != 0;\n}\n\n\nfloat Hash(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Keyboard\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\nconst int KEY_COMMA = 188;\nconst int KEY_PER   = 190;\n\nconst int KEY_1 = \t49;\nconst int KEY_2 = \t50;\nconst int KEY_3 = \t51;\nconst int KEY_ENTER = 13;\nconst int KEY_SHIFT = 16;\nconst int KEY_CTRL  = 17;\nconst int KEY_ALT   = 18;\nconst int KEY_TAB\t= 9;\n\nbool Key_IsPressed( sampler2D samp, int key)\n{\n    return texelFetch( samp, ivec2(key, 0), 0 ).x > 0.0;    \n}\n\nbool Key_IsToggled(sampler2D samp, int key)\n{\n    return texelFetch( samp, ivec2(key, 2), 0 ).x > 0.0;    \n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Packing\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nfloat BytePack2( vec2 val )\n{ \n    return dot( floor(val), vec2(1, 256) );\n}\n\nfloat BytePack2( float x, float y )\n{\n    return BytePack2( vec2( x, y ) );\n}\n\nvec2 ByteUnpack2( float x )\n{\n    return mod( floor(vec2(x) \/ vec2(1, 256)), 256. );\n}\n\nfloat BytePack3( vec3 val )\n{ \n    return dot( floor(val), vec3(1, 256, 65536) );\n}\n\nfloat BytePack3( float x, float y, float z )\n{\n    return BytePack3( vec3( x, y, z ) );\n}\n\nvec3 ByteUnpack3( float x )\n{\n    return mod( floor(vec3(x) \/ vec3(1, 256, 65536)), 256. );\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Data Storage\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec4 LoadVec4( sampler2D sampler, in ivec2 vAddr )\n{\n    return texelFetch( sampler, vAddr, 0 );\n}\n\nvec3 LoadVec3( sampler2D sampler, in ivec2 vAddr )\n{\n    return LoadVec4( sampler, vAddr ).xyz;\n}\n\nbool AtAddress( vec2 p, ivec2 c ) { return all( equal( floor(p), vec2(c) ) ); }\n\nvoid StoreVec4( in ivec2 vAddr, in vec4 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in ivec2 vAddr, in vec3 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Game State\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \nvec4 ReadStateData( sampler2D stateSampler, ivec2 address )\n{\n    return LoadVec4( stateSampler, address );\n}\n\n#define MAIN_GAME_STATE_BOOT\t\t\t0\n#define MAIN_GAME_STATE_SKILL_SELECT\t1\n#define MAIN_GAME_STATE_INIT_LEVEL\t\t2\n#define MAIN_GAME_STATE_GAME_RUNNING\t3\n#define MAIN_GAME_STATE_WIN\t\t\t\t4\n\nstruct GameState\n{\n    int iMainState;\n    float fStateTimer;\n    float fSkill;\n    float fGameTime;\n    \n    vec4 vPrevMouse;\n    \n    float fMap;\n    float fHudFx;\n    \n    int iMessage;\n    float fMessageTimer;\n};\n\nvoid GameState_Reset( out GameState gameState, vec4 vMouse )\n{\n    gameState.iMainState = MAIN_GAME_STATE_BOOT;\n\tgameState.fSkill = 0.;\n    gameState.fGameTime = 0.;\n    gameState.fStateTimer = 0.;\n    \n    gameState.vPrevMouse = vMouse;\n    \n    gameState.fMap = 0.0;\n    gameState.fHudFx = 0.0;\n    \n    gameState.iMessage = -1;\n    gameState.fMessageTimer = 0.0;\n}\n\nGameState GameState_Read( sampler2D stateSampler )\n{\n    GameState gameState;\n    \n    ivec2 vAddress = ivec2( 0 );\n    \n    vec4 vData0 = ReadStateData( stateSampler, vAddress );\n    vAddress.x++;\n\n    vec4 vData1 = ReadStateData( stateSampler, vAddress );\n    vAddress.x++;\n\n    vec4 vData2 = ReadStateData( stateSampler, vAddress );\n    vAddress.x++;\n\n    gameState.iMainState = int(vData0.x);\n    gameState.fSkill = vData0.y;\n    gameState.fGameTime = vData0.z;\n    gameState.fStateTimer = vData0.w;    \n\n    gameState.vPrevMouse = vData1;\n    \n    gameState.fMap = vData2.x;\n    gameState.fHudFx = vData2.y;\n\n    gameState.iMessage = int(vData2.z);\n    gameState.fMessageTimer = vData2.w;\n    \n    return gameState;\n}\n\nvoid GameState_Store( GameState gameState, inout vec4 fragColor, in vec2 fragCoord )\n{    \n    vec4 vData0 = vec4( gameState.iMainState, gameState.fSkill, gameState.fGameTime, gameState.fStateTimer );    \n\n    vec4 vData1 = vec4( gameState.vPrevMouse );    \n\n    vec4 vData2 = vec4( gameState.fMap, gameState.fHudFx, gameState.iMessage, gameState.fMessageTimer );\n\n    ivec2 vAddress = ivec2( 0 );\n    StoreVec4( vAddress, vData0, fragColor, fragCoord );\n    vAddress.x++;\n\n    StoreVec4( vAddress, vData1, fragColor, fragCoord );\n    vAddress.x++;\n\n    StoreVec4( vAddress, vData2, fragColor, fragCoord );\n    vAddress.x++;\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Map Data\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec4 ReadMapData( sampler2D mapSampler, ivec2 address )\n{\n    return LoadVec4( mapSampler, address );\n}\n    \n#define MAX_SECTOR_COUNT 96\n#define MAX_SIDEDEF_COUNT 32\n\n#define SECTOR_NONE -1\n\nstruct MapInfo\n{\n    int iSectorCount;\n};\n    \nMapInfo ReadMapInfo( sampler2D mapSampler )\n{\n    MapInfo mapInfo;\n    \n    vec4 vData = ReadMapData( mapSampler, ivec2(0.0, 0.0) );\n    \n    mapInfo.iSectorCount = int(vData.x);\n    \n    return mapInfo;\n}\n\nstruct Sector\n{\n    int iSectorId;   \n    int iSideDefCount;\n    float fLightLevel;\n\n    float fFloorHeight;\n    float fCeilingHeight;\n\n    uint iFloorTexture;\n    uint iCeilingTexture;\n};\n    \nivec2 GetSectorAddress( int iSectorId )\n{\n    return ivec2(0, 1 + iSectorId );\n}\n\nivec2 GetSideDefAddress( int iSectorId, int iSideDefIndex )\n{\n    return ivec2(2 + iSideDefIndex * 3, 1 + iSectorId );\n}\n    \nSector Map_ReadSector( sampler2D mapSampler, int iSectorId )\n{\n    Sector sector;\n    \n    sector.iSectorId = iSectorId;\n    \n    ivec2 vAddress = GetSectorAddress( iSectorId );\n    \n    vec4 vData0 = ReadMapData(mapSampler, vAddress);\n    vAddress.x += 1;\n\n\n    vec4 vData1 = ReadMapData(mapSampler, vAddress);\n    vAddress.x += 1;\n\n    sector.fLightLevel = vData0.x;\n    sector.iSideDefCount = int(vData0.y);\n\n    sector.fFloorHeight = vData1.x;\n    sector.fCeilingHeight = vData1.y;\n    sector.iFloorTexture = uint(vData1.z);\n    sector.iCeilingTexture = uint(vData1.w);\n    \n    return sector;\n}\n\nstruct SideDef\n{\n    vec2 vA;\n    vec2 vB;\n    float fLength;\n    \n    int iNextSector;\n    \n    float fLightLevel;\n    \n    uint iUpperTexture;\n    uint iMiddleTexture;\n    uint iLowerTexture;    \n    \n    float fFlags;\n};\n\nSideDef Map_ReadSideDefInfo( sampler2D mapSampler, int iSectorId, int iSideDefIndex )\n{\n    SideDef sideDef;\n    \n    ivec2 vAddress = GetSideDefAddress( iSectorId, iSideDefIndex );\n    \n    vec4 vData0 = ReadMapData(mapSampler, vAddress);\n    vAddress.x += 1;\n\n    sideDef.vA = vData0.xy;\n    sideDef.vB = vData0.zw;\n    \n    vec4 vData1 = ReadMapData(mapSampler, vAddress);\n    vAddress.x += 1;\n\n    sideDef.fLength = vData1.x;\n    sideDef.fLightLevel = vData1.y;    \n    sideDef.iMiddleTexture = uint(vData1.z);\n    sideDef.iNextSector = int(vData1.w);\n    \n    vec4 vData2 = ReadMapData(mapSampler, vAddress);\n    sideDef.iLowerTexture = uint(vData2.x);\n    sideDef.iUpperTexture = uint(vData2.y);\n    sideDef.fFlags = vData2.z;\n    \n    return sideDef;\n}\n\n\/\/ Return:\n\/\/   ray t value\n\/\/   sidedef u value\n\/\/   edge crossing direction\nvec3 Map_SideDefIntersectLine( SideDef sideDef, vec2 vRayPos, vec2 vRayDir )\n{\n    vec2 vEdgeDir = sideDef.vB - sideDef.vA;\n    vec2 vOA = sideDef.vA - vRayPos;\n    float fDenom = Cross2d( vRayDir, vEdgeDir );\n    float fRcpDenom = 1.0 \/ fDenom;\n    \n    vec3 vHitTUD;\n    vHitTUD.x = Cross2d( vOA, vEdgeDir ) * fRcpDenom;\n    vHitTUD.y = Cross2d( vOA, vRayDir ) * fRcpDenom;\n    vHitTUD.z = fDenom;\n    \n    return vHitTUD;    \n}\n\nbool Map_ValidSectorId( MapInfo mapInfo, int iSectorId )\n{\n    return ( iSectorId >= 0 && iSectorId < mapInfo.iSectorCount );\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Trace\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nstruct TraceResult\n{\n    float fDist;\n    uint iTexture;\n    vec3 vTexture; \/\/ UV during trace. Resolved to RGB for sprite rendering\n  \tfloat fLightLevel;\n    int iSector;\n};\n\nstruct TraceSectorState\n{\n    float fEnterDist;\n    float fExitY;\n    int iNextSector;\n    bool bNoUpper;\n};\n\nvoid TraceSideDef( sampler2D mapSampler, vec3 vRayOrigin, vec3 vRayDir, inout TraceResult result, inout TraceSectorState sectorState, Sector sector, SideDef sideDef )\n{    \n\tvec3 vHitTUD = Map_SideDefIntersectLine( sideDef, vRayOrigin.xz, vRayDir.xz );\n    float fHitT = vHitTUD.x;\n    float fHitU = vHitTUD.y;\n    float fDenom = vHitTUD.z;\n\n    if( \n        \/\/ We hit the edge between the endpoints\n        (fHitU >= 0.0) && (fHitU < 1.0) &&\n        \/\/ Hit point is further than sector entrance distance\n        (fHitT > sectorState.fEnterDist) && \n        \/\/ Track closest hit\n        (fHitT < result.fDist) && \n        \/\/ Ignore faces entering sector\n        (fDenom < 0.0)\n      )\n    {\n        float fHitY = vRayDir.y * fHitT + vRayOrigin.y;\n        sectorState.fExitY = fHitY;\n        result.fDist = fHitT;\n        \n        if( (sectorState.fExitY > sector.fFloorHeight) )                \n        {\n            sectorState.iNextSector = SECTOR_NONE;\n            if( sideDef.iNextSector == SECTOR_NONE && sideDef.iMiddleTexture != 0u && (sectorState.fExitY < sector.fCeilingHeight ) )\n            {\n                result.vTexture.st = vec2(fHitU * sideDef.fLength, fHitY);\n                result.iTexture = sideDef.iMiddleTexture;\n                result.fLightLevel = sideDef.fLightLevel;\n                sectorState.bNoUpper = false;\n            }\n            else\n            {\n                Sector nextSector = Map_ReadSector( mapSampler, sideDef.iNextSector );\n                                \n\t\t        bool bNoUpper = mod(sideDef.fFlags, 2.0) != 0.0;\n\n\t            if (sectorState.fExitY < sector.fCeilingHeight || bNoUpper )\n                {                                    \n                    if( nextSector.fFloorHeight > sector.fFloorHeight && fHitY > sector.fFloorHeight && fHitY < nextSector.fFloorHeight)\n                    {\n                        result.vTexture.st = vec2(fHitU * sideDef.fLength, fHitY - nextSector.fFloorHeight);\n                        result.iTexture = sideDef.iLowerTexture;\n                        result.fLightLevel = sideDef.fLightLevel;\n                        sectorState.bNoUpper = false;\n                    }            \n                    else\n                    if( sideDef.iUpperTexture != 0u && nextSector.fCeilingHeight < sector.fCeilingHeight && fHitY < sector.fCeilingHeight && fHitY > nextSector.fCeilingHeight)\n                    {\n                        result.vTexture.st = vec2(fHitU * sideDef.fLength, fHitY - nextSector.fCeilingHeight);\n                        result.iTexture = sideDef.iUpperTexture;\n                        result.fLightLevel = sideDef.fLightLevel;\n                        sectorState.bNoUpper = false;\n                    }\n                    else\n                    {\n                        sectorState.bNoUpper = bNoUpper;\n                        sectorState.iNextSector = sideDef.iNextSector;                          \n                    }\n                }\n            }\n        }\n    }\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Entity Management\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define ENTITY_TYPE_NONE -1\n\nstruct Entity\n{\n    int iId;\n    \n    int iType;\n    int iSubType;\n    int iSectorId;    \n\n    vec3 vPos;\n    float fYaw;\n    float fPitch;\n    \n    vec3 vVel;\n    float fYawVel;\n    \n    float fHealth;\n    float fArmor;    \n    \n    float fUseWeapon;    \n    float fHaveShotgun;\n    \n    float fTookDamage; \/\/ For HUD damage indicator\n    int iEvent; \/\/ Message event for UI \"Picked up an armor bonus\" etc.\n    \n    float fTimer; \/\/ Weapon reload for player, think timer for AI\n    float fTarget; \/\/ AI nemesis and also used for player aim up \/ down \n    int iFrameFlags;\n};\n    \n#define ENTITY_DATA_YPOS 8\n#define ENTITY_DATA_SIZE 4\n\n#define ENTITY_MAX_COUNT 128\n    \n#define ENTITY_NONE -1\n    \nint Entity_GetOutputId( vec2 fragCoord )\n{\n    if (\n           int(fragCoord.y) < ENTITY_DATA_YPOS\n        || int(fragCoord.y) >= (ENTITY_DATA_YPOS + ENTITY_DATA_SIZE)\n        || int(fragCoord.x) >= ENTITY_MAX_COUNT\n       )\n    {\n        return ENTITY_NONE;        \n    }\n\n    return int(floor(fragCoord.x));\n}\n\nbool Entity_IdValid( int iEntityId )\n{\n    return ( iEntityId >= 0 && iEntityId < ENTITY_MAX_COUNT );\n}\n\nvoid Entity_Clear( inout Entity entity )\n{\n    entity.iType = ENTITY_TYPE_NONE;\n    entity.vPos = vec3(0);\n    entity.iSectorId = SECTOR_NONE;\n    entity.fYaw = 0.0;\n    entity.vVel = vec3(0);\n    entity.fYawVel = 0.0;\n    entity.fPitch = 0.0;\n    entity.fHealth = 0.0;\n    entity.fArmor = 0.0;\n    entity.fTimer = 0.0;\n    entity.fTarget = float(ENTITY_NONE);\n    entity.iFrameFlags = 0;    \n    entity.fUseWeapon = 1.;\n    entity.fHaveShotgun = 0.;\n    entity.fTookDamage = 0.;\n    entity.iEvent = 0;\n}\n\nEntity Entity_Read( sampler2D stateSampler, int iEntityId )\n{\n    Entity entity;\n    \n    entity.iId = iEntityId;\n    \n    ivec2 vAddress = ivec2( iEntityId, ENTITY_DATA_YPOS );\n    \n    vec4 vData0 = ReadStateData( stateSampler, vAddress );\n    vec3 vUnpacked0x = ByteUnpack3( vData0.x ) - 1.;\n    vAddress.y++;\n    \n    \n    entity.iType = int(vUnpacked0x.x);\n    entity.iSubType = int(vUnpacked0x.y);\n    entity.iSectorId = int(vUnpacked0x.z);\n    \n    entity.iFrameFlags = int(vData0.y);\n    \n    entity.fTarget = vData0.z;\n    entity.fTimer = vData0.w;\n    \n    vec4 vData1 = ReadStateData( stateSampler, vAddress );\n    vAddress.y++;\n\n    entity.vPos = vData1.xyz;\n    entity.fYaw = vData1.w;\n\n    vec4 vData2 = ReadStateData( stateSampler, vAddress );\n    vAddress.y++;\n\n    entity.vVel = vData2.xyz;\n    entity.fYawVel = vData2.w;\n\n    vec4 vData3 = ReadStateData( stateSampler, vAddress );\n    vec2 vUnpacked3x = ByteUnpack2(vData3.x);\n    vec2 vUnpacked3y = ByteUnpack2(vData3.y);\n    vec2 vUnpacked3z = ByteUnpack2(vData3.z) -1.;\n    vAddress.y++;\n    \n    entity.fHealth = vUnpacked3x.x;\n    entity.fArmor = vUnpacked3x.y;\n    float fPackedWeaponInfo = vData3.y;\n    entity.fUseWeapon = vUnpacked3y.x;\n    entity.fHaveShotgun = vUnpacked3y.y;\n    entity.fTookDamage = vUnpacked3z.x;\n    entity.iEvent = int(vUnpacked3z.y);\n    entity.fPitch = vData3.w;\n    \n    return entity;\n}\n\nvoid Entity_Store( Entity entity, inout vec4 fragColor, in vec2 fragCoord )\n{\n    if ( !Entity_IdValid( entity.iId ) ) \n        return;\n\n    float fPacked0 = BytePack3( vec3(entity.iType, entity.iSubType, entity.iSectorId ) + 1. );\n\n    entity.fHealth = floor( clamp( entity.fHealth, 0.0, 255.0 ) );\n    entity.fArmor = floor( clamp( entity.fArmor, 0.0, 255.0 ) );\n    float fPackedHealthAndArmor = BytePack2( vec2( entity.fHealth, entity.fArmor ) ); \n\tfloat fPackedWeaponInfo = BytePack2( vec2( entity.fUseWeapon, entity.fHaveShotgun ) );\n\tfloat fPackedEvents = BytePack2( vec2( entity.fTookDamage, entity.iEvent ) + 1. );\n    \n    ivec2 vAddress = ivec2( entity.iId, ENTITY_DATA_YPOS );\n    \n    vec4 vData0 = vec4( fPacked0, entity.iFrameFlags, entity.fTarget, entity.fTimer );    \n    vec4 vData1 = vec4( entity.vPos, entity.fYaw );\n    vec4 vData2 = vec4( entity.vVel, entity.fYawVel );\n    vec4 vData3 = vec4( fPackedHealthAndArmor, fPackedWeaponInfo, fPackedEvents, entity.fPitch );\n\n    StoreVec4( vAddress, vData0, fragColor, fragCoord );\n    vAddress.y++;\n\n    StoreVec4( vAddress, vData1, fragColor, fragCoord );\n    vAddress.y++;\n\n    StoreVec4( vAddress, vData2, fragColor, fragCoord );\n    vAddress.y++;\n\n    StoreVec4( vAddress, vData3, fragColor, fragCoord );\n    vAddress.y++;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Weapon Defs\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define WEAPON_TYPE_PISTOL\t\t0.\n#define WEAPON_TYPE_SHOTGUN\t\t1.\n#define WEAPON_TYPE_FIREBALL\t2.\n\nstruct WeaponDef\n{\n    float fWeaponType;\n    float fReloadTime;\n    int iProjectileCount;\n    float fBaseDamagePerProjectile;\n    float fRandomDamagePerProjectile;\n    float fSpread;\n};\n\nWeaponDef Weapon_GetDef( float fWeaponType, bool bEnemy )\n{\n    WeaponDef weaponDef;\n\n    if ( fWeaponType == WEAPON_TYPE_SHOTGUN )\n    {\n        weaponDef.fWeaponType = WEAPON_TYPE_SHOTGUN;\n        weaponDef.fReloadTime = 1.0;\n        weaponDef.iProjectileCount = bEnemy ? 3 : 7;\n        weaponDef.fBaseDamagePerProjectile = bEnemy ? 3.0 : 5.0;\n        weaponDef.fRandomDamagePerProjectile = bEnemy ? 12.0 : 10.0;\n        weaponDef.fSpread = radians(4.0);\n    }\n    else\n    if ( fWeaponType == WEAPON_TYPE_FIREBALL )\n    {\n        weaponDef.fWeaponType = WEAPON_TYPE_FIREBALL;\n        weaponDef.fReloadTime = 1.0;\n        weaponDef.iProjectileCount = 1;\n        weaponDef.fBaseDamagePerProjectile = 5.0;\n        weaponDef.fRandomDamagePerProjectile = 0.0;\n        weaponDef.fSpread = radians(0.0);\n    }\n    else\n    {\n        \/\/ Pistol\n        weaponDef.fWeaponType = WEAPON_TYPE_PISTOL;\n        weaponDef.fReloadTime = 0.5;\n        weaponDef.iProjectileCount = 1;\n        weaponDef.fBaseDamagePerProjectile = bEnemy ? 3.0 : 5.0;\n        weaponDef.fRandomDamagePerProjectile = bEnemy ? 12.0 : 10.0;\n        weaponDef.fSpread = bEnemy ? radians(4.0) : 0.0;\n    }\n    \n    return weaponDef;\n}\n    \n#define ENTITY_TYPE_PLAYER \t0\n\n#define ENTITY_TYPE_BARREL \t1\n#define ENTITY_SUB_TYPE_BARREL_INACTIVE\t\t\t0\n#define ENTITY_SUB_TYPE_BARREL_EXPLODING\t\t1\n#define ENTITY_SUB_TYPE_BARREL_APPLY_DAMAGE\t\t2\n\n#define ENTITY_TYPE_ITEM \t2\n#define ENTITY_SUB_TYPE_ITEM_HEALTH_BONUS \t0\n#define ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS \t1\n#define ENTITY_SUB_TYPE_ITEM_SHOTGUN \t\t2\n#define ENTITY_SUB_TYPE_ITEM_STIMPACK\t\t3\n#define ENTITY_SUB_TYPE_ITEM_GREENARMOR\t\t4\n#define ENTITY_SUB_TYPE_ITEM_BLUEARMOR\t\t5\n#define ENTITY_SUB_TYPE_ITEM_MEDIKIT\t\t6\n\n#define ENTITY_TYPE_DECORATION 3\n#define ENTITY_SUB_TYPE_DECORATION_BLOODY_MESS\t\t\t0\n#define ENTITY_SUB_TYPE_DECORATION_DEAD_TROOPER\t\t\t1\n#define ENTITY_SUB_TYPE_DECORATION_DEAD_SERGEANT\t\t2\n#define ENTITY_SUB_TYPE_DECORATION_DEAD_IMP\t\t\t\t3\n#define ENTITY_SUB_TYPE_DECORATION_TALL_TECHNO_PILLAR\t4\n#define ENTITY_SUB_TYPE_DECORATION_FLOOR_LAMP\t\t\t5\n\n#define ENTITY_TYPE_ENEMY\t4\n#define ENTITY_SUB_TYPE_ENEMY_TROOPER \t\t0\n#define ENTITY_SUB_TYPE_ENEMY_IMP \t\t\t1\n#define ENTITY_SUB_TYPE_ENEMY_SERGEANT \t\t2\n\n#define ENTITY_TYPE_BULLET 5\n#define\tENTITY_SUB_TYPE_BULLET_WALL\t\t\t0\n#define\tENTITY_SUB_TYPE_BULLET_FLESH\t\t1\n\n#define ENTITY_TYPE_DOOR 6\n\n#define ENTITY_TYPE_PLATFORM 7\n\n#define ENTITY_TYPE_FIREBALL 8\n#define ENTITY_SUB_TYPE_FIREBALL 0\n#define ENTITY_SUB_TYPE_FIREBALL_IMPACT 1\n\n\n#define ENTITY_FRAME_FLAG_FIRE_WEAPON\t\t1\n#define ENTITY_FRAME_FLAG_DROP_ITEM\t\t\t2\n\n\n#define ENEMY_STATE_IDLE\t\t\t\t0\n#define ENEMY_STATE_PAIN\t\t\t\t1\n#define ENEMY_STATE_WALK_RANDOM\t\t\t2\n#define ENEMY_STATE_WALK_TO_TARGET\t\t3\n#define ENEMY_STATE_STAND\t\t\t\t4\n#define ENEMY_STATE_FIRE\t\t\t\t5\n#define ENEMY_STATE_DIE\t\t\t\t\t6\n\n\n#define EVENT_HEALTH_BONUS \t1\n#define EVENT_ARMOR_BONUS \t2\n#define EVENT_SHOTGUN \t\t3\n#define EVENT_STIMPACK\t\t4\n#define EVENT_GREENARMOR\t5\n#define EVENT_BLUEARMOR\t\t6\n#define EVENT_MEDIKIT\t\t7\n#define EVENT_DIED\t\t\t8\n\n#define MESSAGE_NONE\t\t\t-1\n#define MESSAGE_HEALTH_BONUS \t0\n#define MESSAGE_ARMOR_BONUS \t1\n#define MESSAGE_SHOTGUN \t\t2\n#define MESSAGE_STIMPACK\t\t3\n#define MESSAGE_GREENARMOR\t\t4\n#define MESSAGE_BLUEARMOR\t\t5\n#define MESSAGE_MEDIKIT\t\t\t6\n#define MESSAGE_HUD_TEXT\t\t7\n#define MESSAGE_CHOOSE_SKILL\t8\n#define MESSAGE_SKILL_1\t\t\t9\n#define MESSAGE_SKILL_2\t\t\t10\n#define MESSAGE_SKILL_3\t\t\t11\n#define MESSAGE_SKILL_4\t\t\t12\n#define MESSAGE_SKILL_5\t\t\t13\n#define MESSAGE_HANGAR\t\t\t14\n#define MESSAGE_FINISHED\t\t15\n#define MESSAGE_KILLS\t\t\t16\n#define MESSAGE_ITEMS\t\t\t17\n#define MESSAGE_SECRET\t\t\t18\n#define MESSAGE_TIME\t\t\t19\n#define MESSAGE_SELECT\t\t\t20\n#define MESSAGE_COUNT\t\t\t21\n\n","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"4lf3Rj","date":"1379021959","viewed":15736,"name":"Hot Shower","username":"Kali","description":"Using a tile-folded version of the \"p=abs(p)\/dot(p,p)-c\" fractal (ashamedly named by me \"kaliset\"),  to render a hot particle-like flow and then applying some distortions to make it look like this kind of \"planet\" object is being hit by it.","likes":363,"published":1,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"\/media\/a\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"\/media\/ap\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"\/media\/a\/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"\/media\/ap\/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\/\/ rendering params\nconst float sphsize=.7; \/\/ planet size\nconst float dist=.27; \/\/ distance for glow and distortion\nconst float perturb=.3; \/\/ distortion amount of the flow around the planet\nconst float displacement=.015; \/\/ hot air effect\nconst float windspeed=.4; \/\/ speed of wind flow\nconst float steps=110.; \/\/ number of steps for the volumetric rendering\nconst float stepsize=.025; \nconst float brightness=.43;\nconst vec3 planetcolor=vec3(0.55,0.4,0.3);\nconst float fade=.005; \/\/fade by distance\nconst float glow=3.5; \/\/ glow amount, mainly on hit side\n\n\n\/\/ fractal params\nconst int iterations=13; \nconst float fractparam=.7;\nconst vec3 offset=vec3(1.5,2.,-1.5);\n\n\nfloat wind(vec3 p) {\n\tfloat d=max(0.,dist-max(0.,length(p)-sphsize)\/sphsize)\/dist; \/\/ for distortion and glow area\n\tfloat x=max(0.2,p.x*2.); \/\/ to increase glow on left side\n\tp.y*=1.+max(0.,-p.x-sphsize*.25)*1.5; \/\/ left side distortion (cheesy)\n\tp-=d*normalize(p)*perturb; \/\/ spheric distortion of flow\n\tp+=vec3(iTime*windspeed,0.,0.); \/\/ flow movement\n\tp=abs(fract((p+offset)*.1)-.5); \/\/ tile folding \n\tfor (int i=0; i<iterations; i++) {  \n\t\tp=abs(p)\/dot(p,p)-fractparam; \/\/ the magic formula for the hot flow\n\t}\n\treturn length(p)*(1.+d*glow*x)+d*glow*x; \/\/ return the result with glow applied\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\/\/ get ray dir\t\n\tvec2 uv = fragCoord.xy \/ iResolution.xy-.5;\n\tvec3 dir=vec3(uv,1.);\n\tdir.x*=iResolution.x\/iResolution.y;\n\tvec3 from=vec3(0.,0.,-2.+texture(iChannel0,uv*.5+iTime).x*stepsize); \/\/from+dither\n\n\t\/\/ volumetric rendering\n\tfloat v=0., l=-0.0001, t=iTime*windspeed*.2;\n\tfor (float r=10.;r<steps;r++) {\n\t\tvec3 p=from+r*dir*stepsize;\n\t\tfloat tx=texture(iChannel0,uv*.2+vec2(t,0.)).x*displacement; \/\/ hot air effect\n\t\tif (length(p)-sphsize-tx>0.)\n\t\t\/\/ outside planet, accumulate values as ray goes, applying distance fading\n\t\t\tv+=min(50.,wind(p))*max(0.,1.-r*fade); \n\t\telse if (l<0.) \n\t\t\/\/inside planet, get planet shading if not already \n\t\t\/\/loop continues because of previous problems with breaks and not always optimizes much\n\t\t\tl=pow(max(.53,dot(normalize(p),normalize(vec3(-1.,.5,-0.3)))),4.)\n\t\t\t*(.5+texture(iChannel1,uv*vec2(2.,1.)*(1.+p.z*.5)+vec2(tx+t*.5,0.)).x*2.);\n\t\t}\n\tv\/=steps; v*=brightness; \/\/ average values and apply bright factor\n\tvec3 col=vec3(v*1.25,v*v,v*v*v)+l*planetcolor; \/\/ set color\n\tcol*=1.-length(pow(abs(uv),vec2(5.)))*14.; \/\/ vignette (kind of)\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"llySRh","date":"1482751515","viewed":15727,"name":"iResolution, iMouse, iDate, etc","username":"FabriceNeyret2","description":"Utils:  (more here: [url]https:\/\/shadertoyunofficial.wordpress.com\/[\/url])\n- see current values ( resolution of screen & texture, mouse, keyboard, time, sound )\n- ready-to-use code + comments ( keyboard, printing... )\n- draw & blend antialiased lines\/disc","likes":235,"published":3,"flags":48,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"\/media\/a\/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"\/media\/ap\/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rn","filepath":"\/media\/a\/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","previewfilepath":"\/media\/ap\/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","type":"music","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"\/presets\/tex00.jpg","previewfilepath":"\/presets\/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"\/media\/a\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"\/media\/ap\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/=== original link for citation: https:\/\/www.shadertoy.com\/view\/llySRh\n\/\/find many other tricks here: https:\/\/shadertoyunofficial.wordpress.com\/\n\n\/\/ --- content:\n\/\/ - 2D and 3D rotations\n\/\/ - hue\n\/\/ - printing chars, text, ints, floats\n\/\/ - key togggles ( + main special codes )\n\/\/ - events ( mouse just clicked, texture loaded )\n\/\/ - antialiased line drawing \n\/\/ - hash ( 1D, 2D, 3D, etc ).\n\n\n\/\/ --- compatibility tricks ------------------------------------------\n\n\/\/ all compatibility issues: https:\/\/shadertoyunofficial.wordpress.com\/2016\/07\/22\/compatibility-issues-in-shadertoy-webglsl\/\n\/\/ force OpenGL on Windows: \n\/\/       chrome:    chrome.exe --use-angle=gles\n\/\/       firefox:   URL:  about:config   ; search \u201cangle\u201d; click on webgl.disable-angle to switch\n\/\/ online Windows, etc: https:\/\/www.browserling.com\/ [ may still be using OpenGL ]\n\/\/                      https:\/\/www.onworks.net\/     [ may still be using OpenGL ]\n\n\/\/ --- rotations -----------------------------------------------------\n\n\/\/ 2D, or one axis after the other:\n#define rot2(a)      mat2(cos(a),-sin(a),sin(a),cos(a)) \/\/ V.xy *= rot2(a.z)\n\n\/\/ 3D rot around an arbitrary axis\n#define rot(P,A,a) ( mix( A*dot(P,A), P, cos(a) ) + sin(a)*cross(P,A) )\n\n\n\/\/ --- short approx hue -------------- https:\/\/www.shadertoy.com\/view\/ll2cDc\n\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n#define hsv(h,s,v)    (v) * ( 1. + (s)* ( .6 * cos( 6.3*(v)  + vec3(0,23,21)  ) - .4 ) )\n\/\/ short exact:\n\/\/#define hsv(h,s,v)  (v) * ( 1. + (s)* clamp(  abs( fract( h + vec3(3,2,1)\/3. ) * 6. - 3. ) - 2., -1.,0.) )\n\n\n\/\/ --- polar and complexes -------- https:\/\/shadertoyunofficial.wordpress.com\/2019\/01\/02\/programming-tricks-in-shadertoy-glsl\/\n \n#define CS(a)        vec2( cos(a), sin(a) )\n#define cart2pol(U)  vec2( length(U), atan((U).y,(U).x) )\n#define pol2cart(U) ( (U).x * CS( (U).y ) )\n\n\/\/ add, sub;  mul or div by float : just use +, -, *, \/\n#define cmod(Z)     length(Z)\n#define carg(Z)     atan( (Z).y, (Z).x )\n#define conj(Z)     vec2( (Z).x, -(Z).y )\n#define cmul(A,B) ( mat2( A, -(A).y, (A).x ) * (B) )  \/\/ by deMoivre formula\n#define cinv(Z)   ( vec2( (Z).x, -(Z).y ) \/ dot(Z,Z) ) \n#define cdiv(A,B)   cmul( A, cinv(B) )\n\/\/#define cpow(Z,v)   pol2cart( vec2( pow(cmod(Z),v) , (v) * carg(Z) ) )\n#define cpow(A,B)   cexp( cmul( B, clog(A) ) )\n#define cexp(Z)     pol2cart( vec2( exp((Z).x), (Z).y ) )\n#define clog(Z)     vec2( log(cmod(Z)), carg(Z) )\n\n\n\/\/ --- printing chars, integers and floats ---------------------------\n\n\/\/ --- access to the image of ascii code c\n\n\/\/ 2 implementations.\n\/\/ Use #if 1 for extensive text use (with no superimposition nor color-appearance change)\n\n#define IMMEDIATE_DRAW 0 \n\n#if IMMEDIATE_DRAW \/\/  (allows for superimposition and appearance change).\n\nvec4 char(vec2 p, int c) {\n    vec2 dFdx = dFdx(p\/16.), dFdy = dFdy(p\/16.);\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n    \/\/if (p.x<.25|| p.x>.75 || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5); \/\/ strange bug with an old driver\n\treturn textureGrad( iChannel0, p\/16. + fract( vec2(c, 15-c\/16) \/ 16. ), \n                        dFdx, dFdy );\n  \/\/ variants:\n  \/\/float l = log2(length(fwidth(p\/16.*iResolution.xy)));\n  \/\/return textureLod( iChannel0, p\/16. + fract( vec2(c, 15-c\/16) \/ 16. ), l);\n                   \/\/ manual MIPmap to avoid border artifact. Should be textureLod, but don't available everywhere\n}\n#  define draw_char() vec4(0)  \/\/ stub the final call function is used\n\n#else \/\/ Deferred draw (call draw_char() ). Run and compiles faster.\n      \/\/     First only determine the valid char id at cur pixel \n      \/\/     then call the draw char once at the end.\n\nint char_id = -1; vec2 char_pos, dfdx, dfdy; \nvec4 char(vec2 p, int c) {\n    vec2 dFdx = dFdx(p\/16.), dFdy = dFdy(p\/16.);\n \/\/ if ( p.x>.25&& p.x<.75 && p.y>.0&& p.y<1. )  \/\/ normal char box\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ) \/\/ thighly y-clamped to allow dense text\n        char_id = c, char_pos = p, dfdx = dFdx, dfdy = dFdy;\n    return vec4(0);\n}\nvec4 draw_char() {\n    int c = char_id; vec2 p = char_pos;\n    return c < 0 \n        ? vec4(0,0,0,1e5)\n        : textureGrad( iChannel0, p\/16. + fract( vec2(c, 15-c\/16) \/ 16. ), \n                       dfdx, dfdy );\n}\n#endif\n\n\/\/ --- display int4\n#if 0\nvec4 pInt(vec2 p, float n) {  \/\/ webGL2 variant with dynamic size\n    vec4 v = vec4(0);\n    for (int i = int(n); i>0; i\/=10, p.x += .5 )\n        v += char(p, 48+ i%10 );\n    return v;\n}\n#else\nvec4 pInt(vec2 p, float n) {\n    vec4 v = vec4(0);\n    if (n < 0.) \n        v += char(p - vec2(-.5,0), 45 ),\n        n = -n;\n\n    for (float i = 3.; i>=0.; i--) \n        n \/=  9.999999, \/\/ 10., \/\/ for windows :-(\n        v += char(p - .5*vec2(i,0), 48+ int(fract(n)*10.) );\n    return v;\n}\n#endif\n\n\/\/ --- display float4.4\nvec4 pFloat(vec2 p, float n) {\n    vec4 v = vec4(0);\n    if (n < 0.) v += char(p - vec2(-.5,0), 45 ), n = -n;\n    float upper = floor(n);\n    float lower = fract(n)*1e4 + .5;  \/\/ mla fix for rounding lost decimals\n    if (lower >= 1e4) { lower -= 1e4; upper++; }\n    v += pInt(p,upper); p.x -= 2.;\n    v += char(p, 46);   p.x -= .5;\n    v += pInt(p,lower);\n    return v;\n}\n\n\/\/ printing full IEEE floats (right or left justified): see https:\/\/www.shadertoy.com\/view\/7dfyRH , https:\/\/www.shadertoy.com\/view\/7sscz7\n\n\/\/ --- chars\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.5;\n#define C(c) spc O+= char(U,64+CAPS+c);\n\/\/ NB: use either char.x ( pixel mask ) or char.w ( distance field + 0.5 )\n \n\n\/\/ --- key toggles -----------------------------------------------------\n\n\/\/ FYI: LEFT:37  UP:38  RIGHT:39  DOWN:40   PAGEUP:33  PAGEDOWN:34  END : 35  HOME: 36\n\/\/ Modifiers: SHIFT: 16 CTRL: 17 ALT: 18\n\/\/ Advice:  Mode: keyToggle(key)  Action: keydown(key)+keyclick(modifier)\n#define keyToggle(ascii)  ( texelFetch(iChannel3,ivec2(ascii,2),0).x > 0.)\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define shift             ( texelFetch(iChannel3,ivec2(16,0),0).x  > 0.)\n#define ctrl              ( texelFetch(iChannel3,ivec2(17,0),0).x  > 0.)\n#define alt               ( texelFetch(iChannel3,ivec2(18,0),0).x  > 0.)\n#define modifier          ( int(shift) +2*int(ctrl) + 4*int(alt) )\n\n\n\/\/ --- events ----------------------------------------------------------\n\n\/\/ --- mouse side events https:\/\/www.shadertoy.com\/view\/3dcBRS\n#define mouseUp      ( iMouse.z < 0. )                  \/\/ mouse up even:   mouse button released (well, not just that frame)\n#define mouseDown    ( iMouse.z > 0. && iMouse.w > 0. ) \/\/ mouse down even: mouse button just clicked\n#define mouseClicked ( iMouse.w < 0. )                  \/\/ mouse clicked:   mouse button currently clicked\n\n\/\/ --- texture loaded\n#define textureLoaded(i) ( iChannelResolution[i].x > 0. ) \n\n\/\/ --- (re)init at resolution change or at texture (delayed) load:\n\/\/ in buffX, store iResolution.x or iChannelResolution[i] somewhere. e.g. (0,0).w\n\/\/ if ( currentVal != storedVal ) init; storeVal.\n\n\n\/\/ --- antialiased line drawing ------ https:\/\/www.shadertoy.com\/view\/4dcfW8\n\n#define S(d,r,pix) smoothstep( .75, -.75, (d)\/(pix)-(r))   \/\/ antialiased draw. r >= 1.\n\/\/ segment with disc ends: seamless distance to segment\nfloat line(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    float h = clamp(dot(p, b) \/ dot(b, b), 0., 1.);   \/\/ proj coord on line\n    return length(p - b * h);                         \/\/ dist to segment\n}\n\/\/ line segment without disc ends ( sometime useful with semi-transparency )\nfloat line0(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    float h = dot(p, b) \/ dot(b, b),                  \/\/ proj coord on line\n          c = clamp(h, 0., 1.);\n    return h==c ? length(p - b * h) : 1e5;            \/\/ dist to strict segment\n}\n    \/\/ You might directly return smoothstep( 3.\/R.y, 0., dist),\n    \/\/     but more efficient to factor all lines.\n    \/\/ Indeed we can even return dot(,) and take sqrt at the end of polyline:\n    \/\/ p -= b*h; return dot(p,p);\n\n\n\/\/ for polylines with acute angles, see: https:\/\/www.shadertoy.com\/view\/fdVXRh\n\n\n\/\/ --- old fashioned float-based hash. Might give user-dependant results --------------------\n\n\/\/ nowadays integer noise is safer. see especially: https:\/\/www.shadertoy.com\/results?query=integer+hash+-\n\/\/                         my variants:  vec3\u2192vec3: https:\/\/www.shadertoy.com\/view\/NtjyWw\n\/\/                                      vec2\u2192float: https:\/\/www.shadertoy.com\/view\/fsKBzw\n#define hash(p)  fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n#define hash2(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n#define hash3(p) fract(sin((p)*mat3(127.1,311.7, 74.7,  269.5,183.3,246.1,  113.5,271.9,124.6))*43758.5453123)\n#define hash2x3(p) fract(sin((p)*mat3x2(127.1,311.7,  269.5,183.3,  113.5,271.9))*43758.5453123)\n\/\/ attention: on windows, it is better to use sin(mod(... , 2pi))\n\nvoid mainImage( out vec4 O,  vec2 uv ) \/\/ === demos it all ==================================\n{\n    O -= O;\n    vec2 R = iResolution.xy, U;\n    uv \/= R.y;    \n    int lod = int(mod(iTime,10.));\n    \n    U = ( uv - vec2(.0,.9) ) * 16.;  caps C(18) low C(5)C(19)C(15)C(12) caps C(-6)  \/\/ \"Resol\"\n                             U.x-=1.; low C(19)C(3)C(18)C(5)C(5)C(14)               \/\/ \"screen\"\n    U = ( uv - vec2(.6,.9) ) * 16.;   low C(20)C(5)C(24)C(20)                       \/\/ \"text\"\n    U = ( uv - vec2(.85,.9) ) * 16.;  low C(12)C(15)C(4) spc C(-48+lod)             \/\/ \"lod\"\n    U = ( uv - vec2(1.15,.9) ) * 16.;  low C(19)C(15)C(21)C(14)C(4)                 \/\/ \"sound\"\n\n    U = ( uv - vec2(.0,.6) ) * 16.;  caps C(13) low C(15)C(21)C(19)C(5) caps C(-6)  \/\/ \"mouse\"\n    U = ( uv - vec2(.5,.6) ) * 16.;  caps C(20) low C(9)C(13)C(5) caps C(-6)        \/\/ \"Time\"\n    U = ( uv - vec2(1.45,.55) ) * 16.;  caps C(11) low C(5)C(25) caps C(-6)         \/\/ \"Key\"\n\n    \n    U = ( uv - vec2(.1,.8) ) * 8.;        \/\/ --- column 1\n    O += pInt(U, R.x);  U.y += .8;   \/\/ window resolution\n    O += pInt(U, R.y);  U.y += .8;\n    O += pFloat((U-vec2(-1,.35))*1.5, R.x\/R.y);  U.y += .8;\n  \/\/O += pInt(U, iResolution.z);  U.y += .8;\n    U.y += .8;\n    O += pInt(U, iMouse.x);  U.y += .8;        \/\/ mouse location\n    O += pInt(U, iMouse.y);  U.y += .8;\n    U.y += .4;\n    O += pInt(U, iMouse.z);  U.y += .8;        \/\/ last mouse-click location \n    O += pInt(U, iMouse.w);  U.y += .8;\n    \n    U = ( uv - vec2(.5,.8) ) * 8.;        \/\/ --- column 2\n\n    if ( !textureLoaded(1) )                   \/\/ texture not loaded yet\n        if (U.x>0. && U.y>-1.5 && U.x<2.5 && U.y<1.5) O.r+= .5;\n    O += pInt(U, iChannelResolution[1].x);  U.y += .8; \/\/ texture ( video )\n    O += pInt(U, iChannelResolution[1].y);  U.y += .8; \/\/ see LOD in column 2b\n    \/\/O += pInt(U, iChannelResolution[1].z);  U.y += .8;\n    U.y += .8;\n\n    O += pFloat(U, iTime);         U.y += .8;  \/\/ time\n    O += pInt(U, float(iFrame));   U.y += .8;  \/\/ iFrame\n    O += pFloat(U, 1.\/iTimeDelta); U.y += .8;  \/\/ FPS\n    \n    U.y += .8;\n\n    O += pInt(U, iDate.w\/3600.);          U.x -= 2.5;\n    O += pInt(U, mod(iDate.w\/60.,60.));   U.x -= 2.5;\n    O += pFloat(U, mod(iDate.w,60.));  \n\n    U = ( uv - vec2(.8,.8) ) * 8.;        \/\/ --- column 2b\n\n    if (textureSize(iChannel1,0).x==1 &&  iChannelResolution[1].x > 1.) \/\/ video\/sound lock by stupid new web media policy.\n        if (U.x>0. && U.y>-1.5 && U.x<2.5 && U.y<1.5) O.r+= .5; \/\/ Colored bg on fonts turned BW later: in immediate mode, should be defered.\n                                                                \/\/ Or transform char\/draw_char for they directly return BW.\n    ivec2 S = textureSize(iChannel1,lod);\n    O += pInt(U, float(S.x));  U.y += .8; \/\/ texture LOD\n    O += pInt(U, float(S.y));  U.y += .4;\n    U *= 2.; O += pFloat(U, iChannelTime[1]);      \/\/ iChannelTime\n\n    U = ( uv - vec2(.6,.2) ) * 16.;  caps C(8) low C(15)C(21)C(18)  \/\/ \"Hour\"\n    U = ( uv - vec2(.95,.2) ) * 16.;  caps C(13) low C(9)C(14)      \/\/ \"Min\"\n    U = ( uv - vec2(1.25,.2) ) * 16.;  caps C(19) low C(5)C(3)      \/\/ \"Sec\"\n\n    U = ( uv - vec2(1.1,.8) ) * 8.;        \/\/ --- column 3\n\n    O += pInt(U, iChannelResolution[2].x);  U.y += .8; \/\/ sound texture\n    O += pInt(U, iChannelResolution[2].y);  U.y += .8;\n    \/\/ O += pInt(U, iChannelResolution[2].z);  U.y += .8;\n\n    O += pInt(U, iSampleRate\/1e4);          U.x -= 2.; \/\/ iSampleRate\n    O += pInt(U, mod(iSampleRate,1e4)); \n\n    U = ( uv - vec2(1.4,.45) ) * 8.;       \/\/ --- column 4\n    \n    bool b = false;\n    for (int i=0; i<256; i++)\n        if (keyDown(i) )  O += pInt(U, float(i)),  \/\/ keypressed ascii \n                           b=true, U.y += .1 *8.;\n    if (b==false) O += pInt(U, -1.);\n        \n    O += draw_char().xxxx;\n#if IMMEDIATE_DRAW\n    O = O.xxxx;\n#endif\n   \/\/O*=9.;\n    \n    \/\/ --- non-fonts stuff\n    \n    U = (uv*R.y\/R-.9)\/.1; \n    if (min(U.x,U.y)>0.) O = hue(U.x),  \/\/ --- hue (already in sRGB final space)\n                             O*=O;      \/\/ just to fight the final sRGB convertion\n    \n    U = (uv -vec2(.9*R.x\/R.y,.8))*10.;              \/\/ --- line drawing\n    float pix = 10.\/R.y;               \/\/ pixel size\n    O+= S( line( U,vec2(0,0),vec2(1.1,.85)), 3., pix);\n    O+= S( line0(U,vec2(0.5,0),vec2(1.6,.85)), 3., pix);\n\n    U = (uv -.8*R\/R.y)*10.;                        \/\/ --- circle, discs, transp and blend\n    O += S( abs(length(U-vec2(.2,1)) -.5), 1., pix); \/\/ disc. -.5: relative units. 1: pixel units\n    O += S( length(U-vec2(1.1,1)) -.5, 0., pix) * vec4(1,0,0,1)*.5; \/\/ vec4(pureCol)*opacity\n    O += (1.-O.a)*S( length(U-vec2(1.1,.3)) -.5, 0., pix) * vec4(0,1,0,1); \/\/ blend below prevs\n    vec4 C = S( length(U-vec2(1.1,-.3)) -.5, 0., pix) * vec4(0,0,1,1)*.5;  \/\/ blend above prevs\n    O = C + (1.-C.a)*O;\n    \n    U = uv -vec2(.9*R.x\/R.y,.7);        \/\/ --- random numbers\n    if ( U.x > 0. && U.y > 0. && U.y < .08 ) \n        U.x > .05*R.x\/R.y ? O.rgb += hash(U) : O.rgb += hash2x3(U);\n    \n    \/\/ --- color space corrections\n    O = pow(O, vec4(1.\/2.2) ); \/\/ shader result must be in sRGB colorspace -> gamma correction\n                               \/\/ note that it is very close to sqrt(O).\n    \/\/ similarly, color operations must be done in flat space, while textures are sRGB-encoded: pow(texture(),vec4(2.2)) or ~square.\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ === standard  Main() ==========================\n\n\/\/#define R    iResolution.xy\n#define T(U) texelFetch( iChannel0, ivec2(U), 0 )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( 2.*u - R ) \/ R.y;\n\n    O = T(u);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"\/\/ cubemaps provides 6 x 1024x1024 textures.\n\/\/ - power of 2 allows correct MIPmapping, ease quadtrees, etc.\n\/\/ - secure 1024 size whatever the window size.\n\/\/ - attention: only half-floats, no texelFetch, \n\/\/              different MIPmap LODmax; take T( vec2(0,0), 10. )\n\/\/              iResolution = 1024 rather than screen size.\n\n#define T(U)       texture( iChannel0, vec3(U,1)  ) \/\/ access. U in [-1,1]\n\/\/#define T(U,l)   textureLod( iChannel0, vec3(U,1), l  ) \n\n\nvoid mainCubemap( out vec4 O, vec2 U, vec3 o, vec3 D )\n{\n    O = vec4(0); \/\/ or side effect on border pixels\n    if ( D.z < max(abs(D.x),abs(D.y)) ) return;\n    U.y = 1024. - U.y;              \/\/ like buffA, but 1024 x 1024.\n    \n    \/\/ ... your stuff here ......................\n}","name":"Cube A","description":"","type":"cubemap"}]},{"ver":"0.1","info":{"id":"fstyD4","date":"1653482786","viewed":15714,"name":"Coastal Landscape","username":"bitless","description":"I wanted to do something in the spirit of Van Gogh. It looks better on the full screen.","likes":467,"published":1,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Author: bitless\n\/\/ Title: Coastal Landscape\n\n\/\/ Thanks to Patricio Gonzalez Vivo & Jen Lowe for \"The Book of Shaders\"\n\/\/ and Fabrice Neyret (FabriceNeyret2) for https:\/\/shadertoyunofficial.wordpress.com\/\n\/\/ and Inigo Quilez (iq) for  https:\/\/iquilezles.org\/www\/index.htm\n\/\/ and whole Shadertoy community for inspiration.\n\n#define p(t, a, b, c, d) ( a + b*cos( 6.28318*(c*t+d) ) ) \/\/IQ's palette function (https:\/\/www.iquilezles.org\/www\/articles\/palettes\/palettes.htm)\n#define sp(t) p(t,vec3(.26,.76,.77),vec3(1,.3,1),vec3(.8,.4,.7),vec3(0,.12,.54)) \/\/sky palette\n#define hue(v) ( .6 + .76 * cos(6.3*(v) + vec4(0,23,21,0) ) ) \/\/hue\n\n\/\/ \"Hash without Sine\" by Dave_Hoskins.\n\/\/ https:\/\/www.shadertoy.com\/view\/4djSRW\nfloat hash12(vec2 p)\n{\n  vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n  vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec2 rotate2D (vec2 st, float a){\n    return  mat2(cos(a),-sin(a),sin(a),cos(a))*st;\n}\n\nfloat st(float a, float b, float s) \/\/AA bar\n{\n    return smoothstep (a-s, a+s, b);\n}\n\nfloat noise( in vec2 p ) \/\/gradient noise\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n    \n    vec2 u = f*f*(3.-2.*f);\n\n    return mix( mix( dot( hash22( i+vec2(0,0) ), f-vec2(0,0) ), \n                     dot( hash22( i+vec2(1,0) ), f-vec2(1,0) ), u.x),\n                mix( dot( hash22( i+vec2(0,1) ), f-vec2(0,1) ), \n                     dot( hash22( i+vec2(1,1) ), f-vec2(1,1) ), u.x), u.y);\n}\n\nvoid mainImage( out vec4 O, in vec2 g)\n{\n    vec2 r = iResolution.xy\n        ,uv = (g+g-r)\/r.y\n        ,sun_pos = vec2(r.x\/r.y*.42,-.53) \/\/sun position \n        ,tree_pos = vec2(-r.x\/r.y*.42,-.2) \/\/tree position \n        ,sh, u, id, lc, t;\n\n    vec3 f, c;\n    float xd, yd, h, a, l;\n    vec4 C;\n    \n    float sm = 3.\/r.y; \/\/smoothness factor for AA\n\n    sh = rotate2D(sun_pos, noise(uv+iTime*.25)*.3); \/\/big noise on the sky\n     \n    if (uv.y > -.4) \/\/drawing the sky\n    {\n        u = uv + sh;\n        \n        yd = 60.; \/\/number of rings \n        \n        id =  vec2((length(u)+.01)*yd,0); \/\/segment id: x - ring number, y - segment number in the ring  \n        xd = floor(id.x)*.09; \/\/number of ring segments\n        h = (hash12(floor(id.xx))*.5+.25)*(iTime+10.)*.25; \/\/ring shift\n        t = rotate2D (u,h); \/\/rotate the ring to the desired angle\n    \n        id.y = atan(t.y,t.x)*xd;\n        lc = fract(id); \/\/segment local coordinates\n        id -= lc;\n    \n        \/\/ determining the coordinates of the center of the segment in uv space\n        t = vec2(cos((id.y+.5)\/xd)*(id.x+.5)\/yd,sin((id.y+.5)\/xd)*(id.x+.5)\/yd); \n        t = rotate2D(t,-h) - sh;\n    \n        h = noise(t*vec2(.5,1)-vec2(iTime*.2,0)) \/\/clouds\n            * step(-.25,t.y); \/\/do not draw clouds below -.25\n        h = smoothstep (.052,.055, h);\n        \n        \n        lc += (noise(lc*vec2(1,4)+id))*vec2(.7,.2); \/\/add fine noise\n        \n        f = mix (sp(sin(length(u)-.1))*.35, \/\/sky background\n                mix(sp(sin(length(u)-.1)+(hash12(id)-.5)*.15),vec3(1),h), \/\/mix sky color and clouds\n                st(abs(lc.x-.5),.4,sm*yd)*st(abs(lc.y-.5),.48,sm*xd));\n    };\n\n    if (uv.y < -.35) \/\/drawing water\n    {\n\n        float cld = noise(-sh*vec2(.5,1)  - vec2(iTime*.2,0)); \/\/cloud density opposite the center of the sun\n        cld = 1.- smoothstep(.0,.15,cld)*.5;\n\n        u = uv*vec2(1,15);\n        id = floor(u);\n\n        for (float i = 1.; i > -1.; i--) \/\/drawing a wave and its neighbors from above and below\n        {\n            if (id.y+i < -5.)\n            {\n                lc = fract(u)-.5;\n                lc.y = (lc.y+(sin(uv.x*12.-iTime*3.+id.y+i))*.25-i)*4.; \/\/set the waveform and divide it into four strips\n                h = hash12(vec2(id.y+i,floor(lc.y))); \/\/the number of segments in the strip and its horizontal offset\n                \n                xd = 6.+h*4.;\n                yd = 30.;\n                lc.x = uv.x*xd+sh.x*9.; \/\/divide the strip into segments\n                lc.x += sin(iTime * (.5 + h*2.))*.5; \/\/add a cyclic shift of the strips horizontally\n                h = .8*smoothstep(5.,.0,abs(floor(lc.x)))*cld+.1; \/\/determine brightness of the sun track \n                f = mix(f,mix(vec3(0,.1,.5),vec3(.35,.35,0),h),st(lc.y,0.,sm*yd)); \/\/mix the color of the water and the color of the track for the background of the water \n                lc += noise(lc*vec2(3,.5))*vec2(.1,.6); \/\/add fine noise to the segment\n                \n                f = mix(f,                                                                         \/\/mix the background color \n                    mix(hue(hash12(floor(lc))*.1+.56).rgb*(1.2+floor(lc.y)*.17),vec3(1,1,0),h)     \/\/and the stroke color\n                    ,st(lc.y,0.,sm*xd)\n                    *st(abs(fract(lc.x)-.5),.48,sm*xd)*st(abs(fract(lc.y)-.5),.3,sm*yd)\n                    );\n            }\n        }\n    }\n    \n    O = vec4(f,1);\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ drawing the grass\n    a = 0.;\n    u = uv+noise(uv*2.)*.1 + vec2(0,sin(uv.x*1.+3.)*.4+.8);\n    \n    f = mix(vec3(.7,.6,.2),vec3(0,1,0),sin(iTime*.2)*.5+.5); \/\/color of the grass, changing from green to yellow and back again\n    O = mix(O,vec4(f*.4,1),step(u.y,.0)); \/\/draw grass background\n\n    xd = 60.;  \/\/grass size\n    u = u*vec2(xd,xd\/3.5); \n    \n\n    if (u.y < 1.2)\n    {\n        for (float y = 0.; y > -3.; y--)\n          {\n            for (float x = -2.; x <3.; x++)\n            {\n                id = floor(u) + vec2(x,y);\n                lc = (fract(u) + vec2(1.-x,-y))\/vec2(5,3);\n                h = (hash12(id)-.5)*.25+.5; \/\/shade and length for an individual blade of grass\n\n                lc-= vec2(.3,.5-h*.4);\n                lc.x += sin(((iTime*1.7+h*2.-id.x*.05-id.y*.05)*1.1+id.y*.5)*2.)*(lc.y+.5)*.5;\n                t = abs(lc)-vec2(.02,.5-h*.5);\n                l =  length(max(t,0.)) + min(max(t.x,t.y),0.); \/\/distance to the segment (blade of grass)\n\n                l -= noise (lc*7.+id)*.1; \/\/add fine noise\n                C = vec4(f*.25,st(l,.1,sm*xd*.09)); \/\/grass outline                \n                C = mix(C,vec4(f                  \/\/grass foregroud\n                            *(1.2+lc.y*2.)  \/\/the grass is a little darker at the root\n                            *(1.8-h*2.5),1.)    \/\/brightness variations for individual blades of grass\n                            ,st(l,.04,sm*xd*.09));\n                \n                O = mix (O,C,C.a*step (id.y,-1.));\n                a = max (a, C.a*step (id.y,-5.));  \/\/a mask to cover the trunk of the tree with grasses in the foreground\n            }\n        }\n    }\n\n    float T = sin(iTime*.5); \/\/tree swing cycle\n \n    if (abs(uv.x+tree_pos.x-.1-T*.1) < .6) \/\/ drawing the tree\n    {\n        u = uv + tree_pos;\n        \/\/ draw the trunk of the tree first\n        u.x -= sin(u.y+1.)*.2*(T+.75); \/\/the trunk bends in the wind\n        u += noise(u*4.5-7.)*.25; \/\/trunk curvature\n        \n        xd = 10., yd = 60.; \n        t = u * vec2(1,yd); \/\/divide the trunk into segments\n        h = hash12(floor(t.yy)); \/\/horizontal shift of the segments and the color tint of the segment  \n        t.x += h*.01;\n        t.x *= xd;\n        \n        lc = fract(t); \/\/segment local coordinates\n        \n        float m = st(abs(t.x-.5),.5,sm*xd)*step(abs(t.y+20.),45.); \/\/trunk mask\n        C = mix(vec4(.07) \/\/outline color\n                ,vec4(.5,.3,0,1)*(.4+h*.4) \/\/foreground color \n                ,st(abs(lc.y-.5),.4,sm*yd)*st(abs(lc.x-.5),.45,sm*xd));\n        C.a = m;\n        \n        xd = 30., yd = 15.;\n        \n        for (float xs =0.;xs<4.;xs++) \/\/drawing four layers of foliage\n        {\n            u = uv + tree_pos + vec2 (xs\/xd*.5 -(T +.75)*.15,-.7); \/\/crown position\n            u += noise(u*vec2(2,1)+vec2(-iTime+xs*.05,0))*vec2(-.25,.1)*smoothstep (.5,-1.,u.y+.7)*.75; \/\/leaves rippling in the wind\n    \n            t = u * vec2(xd,1.);\n            h = hash12(floor(t.xx)+xs*1.4); \/\/number of segments for the row\n            \n            yd = 5.+ h*7.;\n            t.y *= yd;\n    \n            sh = t;\n            lc = fract(t);\n            h = hash12(t-lc); \/\/segment color shade\n    \n            \n            t = (t-lc)\/vec2(xd,yd)+vec2(0,.7);\n            \n            m = (step(0.,t.y)*step (length(t),.45) \/\/the shape of the crown - the top \n                + step (t.y,0.)*step (-0.7+sin((floor(u.x)+xs*.5)*15.)*.2,t.y)) \/\/the bottom\n                *step (abs(t.x),.5) \/\/crown size horizontally\n                *st(abs(lc.x-.5),.35,sm*xd*.5); \n    \n            lc += noise((sh)*vec2(1.,3.))*vec2(.3,.3); \/\/add fine noise\n            \n            f = hue((h+(sin(iTime*.2)*.5+.5))*.2).rgb-t.x; \/\/color of the segment changes cyclically\n    \n            C = mix(C,\n                    vec4(mix(f*.15,f*.6*(.7+xs*.2), \/\/mix outline and foreground color\n                        st(abs(lc.y-.5),.47,sm*yd)*st(abs(lc.x-.5),.2,sm*xd)),m)\n                    ,m);\n        }\n\n        O = mix (O,C,C.a*(1.-a));\n    }\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"MlKGWK","date":"1477948808","viewed":15713,"name":"ValleyRace","username":"kuvkar","description":"Star-wars inspired valley racing scene. There's still some aliasing I might fix but I don't think it's too bad. ","likes":101,"published":3,"flags":32,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n    fragColor.rgb = texture(iChannel1, uv).rgb;\n    fragColor.rgb = smoothstep(0.0, 1.0, fragColor.rgb);\n    fragColor.rgb += 0.006 * 0.5 * (rand(uv + iTime) + rand(uv + vec2(0.1) + iTime));\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0 \/ 2.2));\n    \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rn","filepath":"\/media\/a\/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"\/media\/ap\/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"\/media\/a\/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"\/media\/ap\/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"\/media\/a\/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"\/media\/ap\/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/**\n Shader inspired by Star Wars I pod-racing scene. Spent a long time tweaking shading and geometry, \n I hope it runs reasonably well and looks good, I even tried to optimize this time :)\n*\/\n\n\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\nmat3 rotz(float a) { mat3 rot; rot[0] = vec3(cos(a), -sin(a), 0.0); rot[1] = vec3(sin(a), cos(a), 0.0); rot[2] = vec3(0.0, 0.0, 1.0); return rot; }\n\/\/mat3 transpose(in mat3 m) { mat3 mT; mT[0][0] = m[0][0]; mT[0][1] = m[1][0]; mT[0][2] = m[2][0]; mT[1][0] = m[0][1]; mT[1][1] = m[1][1]; mT[1][2] = m[2][1]; mT[2][0] = m[0][2]; mT[2][1] = m[1][2]; mT[2][2] = m[2][2]; return mT; }\nconst float PI = 3.14159265358;\nconst float PI2 = 3.14159265358 * 0.5;\nconst float TWO_PI = 3.14159265358 * 2.0;\nfloat getShipRoll(float T);\nfloat shadowEnv (in vec3 rp, in vec3 g, in vec3 ld);\n\n\n\/\/ from IQ: https:\/\/iquilezles.org\/articles\/smin\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)\/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\/\/ from IQ: https:\/\/iquilezles.org\/articles\/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\/\/ plane looks down negative z axis. Orientation is controlled by rotation matrix.\nfloat traceQuad(in vec3 ro, in vec3 rd, in vec3 pp, in vec2 sizeXY, in mat3 rt, in vec3 pivot )\n{\n    pp += rt * pivot;\n    vec3 pn = rt * vec3(0.0, .0, -1.00);\n    float a = dot(pp - ro, pn);\n    float b = dot(rd, pn);\n    float t = a \/ b;\n    if (t < 0.0) return t;\n    vec3 hitp = ro + rd * t;\n    hitp = transpose(rt) * (hitp - pp); \/\/ to get to local coordinates\n    if(abs(hitp.x) > sizeXY.x) return -1.;\n    if(abs(hitp.y) > sizeXY.y) return -1.;\n\treturn t;\n}\n\n\/\/ just a small helper function for bounding box tracing\nfloat pmin(float m1, float m2)\n{\n    if (m1 >= 0.0 && m2 >= 0.0) { return min(m1, m2); } \n    return (m1 >= 0.0 && m2 < 0.0) ? m1 : m2;\n}\n\n\/\/ 6 quad checks\n\/\/ returns ray enter and exit hitpoints.\n\/\/ I'm using this as a bounding box to speedup the tracing process.\nvec2 traceBox(in vec3 ro, in vec3 rd, in vec3 bp, in vec3 size, in mat3 rt)\n{\n    vec4 piv = vec4(size, 0.0);\n    float f0 = traceQuad(ro, rd, bp, size.xy, rt, piv.wwz);\n\tfloat f1 = traceQuad(ro, rd, bp, size.xy * 1., rt, -piv.wwz);\n\tfloat f2 = traceQuad(ro, rd, bp, size.zy, rt * roty(PI2), piv.wwx);\n\tfloat f3 = traceQuad(ro, rd, bp, size.zy, rt * roty(PI2), -piv.wwx);\n\tfloat f4 = traceQuad(ro, rd, bp, size.xz, rt * rotx(PI2), -piv.wwy);\n    float f5 = traceQuad(ro, rd, bp, size.xz, rt * rotx(PI2), piv.wwy);\n        \n    float m = pmin(f0, f1); m = pmin(m, f2); m = pmin(m, f3); m = pmin(m, f4); m = pmin(m, f5);\n    if (m < 0.0) return vec2(m);\n    \n    vec2 ret = vec2(m, 1.0);\n    if (f0 > 0. && f0 != ret.x) ret.y = f0;\n    else if (f1 > 0. && f1 != ret.x) ret.y = f1;\n    else if (f2 > 0. && f2 != ret.x) ret.y = f2;\n    else if (f3 > 0. && f3 != ret.x) ret.y = f3;\n    else if (f4 > 0. && f4 != ret.x) ret.y = f4;\n    else if (f5 > 0. && f5 != ret.x) ret.y = f5;\n        \n    return ret;\n}\n\n\/\/ repeats space angularly.\nvec2 repeatPolarAngle(in vec2 ar, float angle)\n{\t\n    ar.x = mod(ar.x, angle);\n    vec2 p = vec2(cos(ar.x), sin(ar.x)) * ar.y;\n    return p;\n}\n\n\/\/ to polar coordinates\nvec2 polar(in vec2 p)\n{\n    return vec2(atan(p.y, p.x), length(p));\n}\n\n\/\/ ship shape slices\nconst float slice = PI * 0.15;\n\nvec2 g_rp_polar = vec2(0.0);\nvec3 g_shipPos = vec3(0.0);\nmat3 g_shipRotation = mat3(1.0);\nvec3 g_hitp_local = vec3(0.0);\nmat3 g_model_correction = mat3(1.0);\nvec2 g_uv = vec2(0.0);\nvec3 lightDir = normalize(vec3(.0, 15.0, -2.0));\nfloat g_camT = 0.0; \nfloat g_shipT = 0.0;\nvec3 g_hitp = vec3(0.0);\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ ship model\n\/\/ basicly a box in a space that's repeated by angle\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nfloat map(in vec3 _rp)\n{\n    _rp -= g_shipPos;\n    _rp = _rp * g_shipRotation;\n    _rp = _rp * g_model_correction;\n    g_rp_polar = polar(_rp.xz);\n    g_hitp_local = _rp;\n    \n    \/\/ ship shape is made by repeating the space in pie-shape fashion\n    vec2 rp_polar_real = polar(_rp.xz);\n\tvec2 rp_polar = abs(rp_polar_real);\n    \n    _rp.xz = repeatPolarAngle(rp_polar, slice);\n    \n    float m = sdBox( _rp, vec3(0.05, 0.0035, 0.05) * 4.0);\n    float m3 = sdBox((_rp + vec3(-0.15, -0.015, 0.)), vec3(0.005, 0.015, 0.012) * vec3(6.0, 4.0, 10.0));\n    \n    \/\/ 2 boxes mixed gives nicer shape\n\tm = mix(m, m3, 0.1);\n    \/\/ mixing with a sphere for a rounded shape\n    m = mix(m, length(_rp - vec3(0.0, 0.05, 0.)) - .2, 0.2);\n\treturn m;\n}\n\n\/\/ gradient\nvec3 grad(in vec3 rp, float sharpness)\n{\n    vec2 off = vec2(sharpness, 0.0);\n    vec3 g = vec3(map(rp + off.xyy) - map(rp - off.xyy),\n                  map(rp + off.yxy) - map(rp - off.yxy),\n                  map(rp + off.yyx) - map(rp - off.yyx));\n    return normalize(g);\n}\n\n\nfloat g_rayExitDistance; \/\/ distance for exitting the bounding box of ship\n\n\/\/ a bit hacky function to get the shading that I wanted.\nfloat lobe(float d, float wrap)\n{\n    d = d + wrap \/ (1.0 + wrap);\n    d \/= sqrt(d);\n    return d;\n}\n\nbool traceShip(in vec3 ro, in vec3 rp, in vec3 rd, inout vec4 outColor)\n{\n    bool hit = false;\n    rp += rd * .3;\n    float dist = 0.0;\n    float fi = 0.0;\n    float closest = 999.0;\n    vec3 closestPos = vec3(0.0);\n    \n    for (int i = 0; i < 25; ++i)\n    {\n        fi = float(i);\n        dist = map(rp);\n        if (dist < closest)\n        {\n           closest = dist;\n           closestPos = rp;\n        }\n        \n        if(dist <= 0.00)\n        {\n            hit = true;\n            break;\n        }\n        rp += rd * max(dist * .85, 0.005);\n        float l = length(ro - rp);\n        if (l > g_rayExitDistance) break;\n    }\n    \n    \/\/ anti-aliasing the outer edges.\n    float AA = dFdx(g_uv.x) * 2.;\n    \n    \/\/ early out if not close enough to edge\n    if(closest > AA) { return false; }\n    \n    \/\/ few iterations for better quality if surface was penetrated a lot.\n    for (int i = 0; i < 3; ++i)\n    {\n        rp += sign(dist) * max(abs(dist), 0.00001) * rd;\n        dist = map(rp);\n    }\n    \n    hit = hit || dist < 0.0;\n    float rayLength = length(ro - rp);\n    \n    \n    \n    if(!hit) rp = closestPos;\n    \n    \/\/ depth test\n\tif (outColor.a < rayLength) return false;\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/ UFO texturing and shading  \/\/\/\/\/\/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \n    float X = (PI * 0.05 + PI + g_rp_polar.x) \/ (2.0 * PI);\n    float b = PI \/ slice * 4.0;\n    X = floor(X * b);\n    bool glass = false;\n    \n    vec4 albedo = (vec4(100,200,250, 0.0) \/ 256.0) * 0.9;\n\n    vec4 color = vec4(0.0);\n\tfloat roughness = 0.15;\n    float worness = 3.0;\n    float refl = 0.05;\n    \n    if (g_hitp_local.y > 0.0 && g_hitp_local.y < 0.025 && (X == 0.0 || X == 1.0 || X == 27.0 || X == 26.0))\n    {\n        albedo.rgb = vec3(.9, .9, .9);\n        glass = true;\n    }\n    \n       \n    vec3 yellow = vec3(.7, 0.2, 0.0);        \n    if (g_hitp_local.y <= -0.01) albedo.rgb = vec3(.1, .1, .0);\n    \n    else if (g_hitp_local.y <= 0.006) albedo.rgb = yellow;\n    else if (abs(g_rp_polar.x - 2.8) <= 0.02) albedo.rgb = yellow;\n    else if (abs(g_rp_polar.x + 2.8) <= 0.02) albedo.rgb = yellow;\n    else if (abs(g_rp_polar.x - .42) <= 0.08) albedo.rgb = yellow;\n    else if (abs(g_rp_polar.x + .42) <= 0.08) albedo.rgb = yellow;\n    else if (abs(g_rp_polar.x + .0) <= 0.08)  albedo.rgb = yellow;\n\n    bool engine = (X >= 12.0 && X <= 15.0);\n    if (g_hitp_local.y > -0.01 && g_hitp_local.y < 0.005 && engine)\n    {\n        color.rgb += (vec3(.5) + 0.35 * sin(abs(g_shipT * getShipRoll(g_shipT) * .03) )) ;\n    }\n\n    vec3 g = grad(rp, 0.0025);\n    \n    \/\/ Bump\n    if(!glass)\n    {\n        vec2 bmpUv = g_hitp_local.xz;\n        \n        vec3 bump = roughness * texture(iChannel2, bmpUv * 5.5).rgb;\n        \n        float bm = 75.0;\n        float damage = sin(bmpUv.y * bm * 0.6) * sin(bmpUv.x * bm) * 0.5;\n        damage += sin(bmpUv.y * bm * 0.3) * sin(bmpUv.x * bm * 0.3);\n        \n        damage = clamp(damage, 0.0, 1.0);\n        roughness += worness * roughness * damage;\n        bump += roughness * texture(iChannel2, g_hitp_local.yz * 5.5).rgb;\n        albedo = mix(albedo, vec4(0.6, 0.2, 0.0, .0), roughness * .8);\n        g = g + bump * 1.;\n        g = normalize(g);\n    }\n\n    float d = dot(g, lightDir);\n    d = clamp(d, 0.0, 1.0);\n    d = lobe(d, 0.1);\n    color += albedo * d;\n\t\n    \/\/ spec\n    float sp = glass ? 13.0 : 80.0;\n    vec3 H = normalize(-rd + lightDir);\n    float Sd = dot(H, g);\n    Sd = clamp(Sd, 0.001, 1.0);\n    Sd = lobe(Sd, 0.);\n    Sd = pow(Sd, sp) * .2;\n\t\n    vec3 envColor = texture(iChannel3, reflect(rd, g)).rgb;\n    color.rgb += glass ? 0.7 * envColor : envColor * max(0.0, (1.0 - roughness)) * refl;\n    \n    \/\/ fres\n    float SCL = 4.; \n    float PWR = 10.0;\n    \n    float Fd = dot(rd, g);\n    Fd = min(1.0, 1.0 + Fd) * 0.5;\n    Fd = lobe(Fd, 0.25);\n    \n    float F = SCL * pow(Fd, PWR);\n    vec3 FCol = vec3(0.2, 0.12, 0.04);\n\tcolor.rgb = mix(color.rgb, FCol, min(F, 1.0) );\n    color += vec4(Sd);\n    \n    float colMix = smoothstep(AA, 0.0, closest);\n    \n    float sh = shadowEnv(rp, vec3(0.0, .2, 0.0), lightDir);\n   \tcolor.rgb *= mix(1.0, sh, 0.75);\n    outColor = mix(outColor, color, colMix);\n    outColor.a = rayLength;\n    g_hitp = rp;\n    \n    return hit;\n}\n\n\n\/\/ \nbool doShip(in vec3 rp, in vec3 rd, inout vec4 color)\n{\n    vec3 ro = rp;\n    vec2 hitBox = traceBox(ro, rd, g_shipPos + vec3(0.0, 0.01, 0.0), vec3(0.24, 0.05, 0.21), g_shipRotation);\n    if (hitBox.x <= 0.) return false;\n    \n    \/\/ bug fix to where 2 seams meet\n    g_rayExitDistance = max (hitBox.y, 2.5);\n    \n    bool hit = traceShip(ro, rp, rd, color);\n    \/\/if(hit) color += vec4(0.1);\n    return hit;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/ ENVIRONMENT \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nfloat ENV_P = 0.05; \/\/ scale for fbm texture uv\nfloat ENV_B = .3; \/\/ multiplier for strength of fbm\nvec3 bgFadeCol = vec3(1.2, .95, .6) * 0.45;\n\n\/\/ clouds\nfloat fbmHI (in vec2 uv)\n{\n\tfloat f = texture(iChannel2, uv).r * 0.5;    \n\tf += texture(iChannel2, uv * 2.0).r * 0.25;    \n\tf += texture(iChannel2, uv * 4.0).r * 0.25 * 0.5;\n\tf += texture(iChannel2, uv * 8.0).r * 0.25 * 0.5 * 0.5;\n\tf += texture(iChannel2, uv * 16.0).r * 0.25 * 0.5 * 0.5 * 0.5;\n    return f;\n}\n\n\/\/ walls\nfloat fbm (in vec2 uv)\n{\n\tfloat f = texture(iChannel2, uv).r * 0.75;    \n\tf += texture(iChannel2, uv * 7.0).r * 0.25 * 0.5;\n    return f;\n}\n\n\/\/ walls\nfloat fbmLO (in vec2 uv)\n{\n\tfloat f = texture(iChannel2, uv).r * 0.75;    \n    return f;\n}\n\nfloat g_fbm;\nvec3 _mapRP;\n\n\/\/ path curving\nfloat getPathOffset(float x)\n{\n    float offset =  sin(x * 0.1) * 2.0 + sin(x * 0.05) * 3. + cos(x * 0.2) * 1.0;\n    return offset * 1.7;\n}\n\nfloat getMapHeight(float x)\n{\n    return 0.5 + (sin(x * 0.05 + sin(x * 0.3))) * 0.5;\n}\n\n\/\/ vertical layer size\nconst float layerSize = .95;\n\n\/\/ valley width\nfloat valleyWidth = 7.;\nfloat g_shadowSharpness = 0.16;\n\nfloat _mapEnv(in vec3 rp)\n{\n    rp.z += getPathOffset(rp.x);\n    float sgnZ = rp.z > 0.0 ? 1.0 : -1.0;\n    \n    float sx2 = sin(rp.x * 0.25);\n    float sx3 = sin(rp.x * 0.0125);\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ tilt of valley\n    float tilt = (-.2 + smoothstep(-.5, .5, sx3)); \n    g_shadowSharpness = clamp(tilt, 0.025, 0.26); \/\/ hack to get shadows look good\n    \/\/ curves on layers\n    float c = sx3 + sx2 * 0.5 + sin(rp.x) * sgnZ * 0.15;\n    rp.y += c;\n    \/\/ layers\n    float fy = fract(rp.y \/ layerSize);\n    float l =  floor(rp.y \/ layerSize) * tilt + smoothstep( 0.0, 0.85, fy) * tilt;\n    rp.z = min(0.0, -abs(rp.z) - valleyWidth + l);\n    \n    \/\/ negative space inside\n    float m = 0.006 * dot(rp.zy, rp.zy) - .5;\n    m = max(-m, sdBox(_mapRP, vec3(10000.0, -c + 5., 10000.0)));\n    m = smin(m, sdBox(_mapRP + vec3(0.0, 1.0, 0.0),vec3(20000.0, 1.0, 20000.0)), .2);\n\treturn m;        \n}\n\n\nfloat groundDetail(in vec3 rp)\n{\n   float F = fbmLO(rp.xz * .01);\n   float amount = 0.25 + sin(rp.x * 0.05) * 0.2;\n   F = smoothstep(amount, amount + .08, F);\n   return smoothstep(.2, 0.0, rp.y) * F;\n}\n\nfloat mapEnvLO(in vec3 rp)\n{\n    _mapRP = rp + getMapHeight(rp.x);\n    g_fbm = fbmLO (abs(rp.xz) * ENV_P) * ENV_B;\n    float d = groundDetail(_mapRP);\n    rp.xy += g_fbm;\n\t\n    return _mapEnv(rp);\n}\n\n\nfloat mapEnv(in vec3 rp)\n{\n    _mapRP = rp + getMapHeight(rp.x);\n    g_fbm = fbm  (abs(rp.xz) * ENV_P) * ENV_B;\n    \n    float d = groundDetail(_mapRP);\n    _mapRP.y += d * .35 * g_fbm;\n    rp.xy += g_fbm;\n    return _mapEnv(rp);\n}\n\n\/\/ environment gradient\nvec3 gradEnv(in vec3 rp, float sharpness)\n{\n    vec2 off = vec2(sharpness, 0.0);\n    vec3 g = vec3(mapEnv(rp + off.xyy) - mapEnv(rp - off.xyy),\n                  mapEnv(rp + off.yxy) - mapEnv(rp - off.yxy),\n                  mapEnv(rp + off.yyx) - mapEnv(rp - off.yyx));\n    return normalize(g);\n}\n\nvec4 tex3D( sampler2D tex, in vec3 p, in vec3 n )\n{\n    vec4 c1 = texture(tex, p.xy);\n    vec4 c2 = texture(tex, p.yz);\n    vec4 c3 = texture(tex, p.xz);\n    \n    vec4 color = abs(dot(n, vec3(0.0, 0.0, 1.0))) * c1;\n    color += abs(dot(n, \tvec3(1.0, 0.0, 0.0))) * c2;\n    color += abs(dot(n, \tvec3(0.0, 1.0, 0.0))) * c3;\n    return clamp(color, 0.0, 1.0);\n}\n\n\n\/\/ tint on the ground texture\nvec4 groundTint = vec4(0.35, 0.25, 0.1, 0.0) * 3.0;\n\n\/\/ shadows and occlusion\nfloat shadowEnv (in vec3 rp, in vec3 g, in vec3 ld)\n{\n\trp += g * 0.03;\n    const int stps = 10;\n\n    float s = 1.0;\n    float occ = 0.0;\n    for (int i = 1; i < stps; ++i)\n    {\n        float stp = .015 * float(i * i);\n\t    rp += ld * stp;\n        float d = mapEnv(rp);\n        occ += clamp(d\/stp, .0, 1.0) * (1.\/float(i));\n        s = min(s, clamp(mapEnv(rp) \/ stp, 0.0, 1.0));\n    }\n    occ \/= 2.0;\n    \n    s = smoothstep(0.0, g_shadowSharpness, s);\n    s = min(s, occ);\n\treturn min(s, 1.);\n}\n\nfloat getCurvature(in vec3 rp, in vec3 g)\n{\n   vec3 gw = fwidth(g);\n   vec3 pw = fwidth(rp);\n   float wfcurvature = length(gw) \/ length(pw);\n   return smoothstep(0.0, 12., wfcurvature);        \n}\n\nvec3 g_groundHitp = vec3(0.0);\n\nbool doEnv(in vec3 rp, in vec3 rd, inout vec4 color)\n{\n    vec3 ro = rp;\n    float dist = 0.0;\n    bool hit = false;\n    float closest = 999.0;\n    vec3 closestPos = vec3(0.0);\n    float AA = 1.0 * dFdx(g_uv).x;\n    float travelled = 0.0;\n    \n    for (int i = 0; i < 45; ++i)\n    {\n        dist = mapEnvLO(rp);\n        if (dist < closest)\n        {\n            closest = dist;\n            closestPos = rp;\n        }\n        \n        if (dist < 0.0)\n        {\n            hit = true;\n            break;\n        }\n        float lg2 = log2(1.0 + travelled * 15.0);\n        float stp = max(0.01 * lg2, dist * (.9 + lg2));\n        rp += rd * stp;\n        travelled += stp;\n        \n        if (travelled > 150.0)\n        {\n            break;\n    \t}\n    }\n    \n    \/\/ detail steps\n    for (int i = 0; i < 35; ++i)\n    {\n        float D = dist * 0.5 * log2(1.0 + travelled);\n        travelled += D;\n        \n        rp += sign(D) * max(abs(D), 0.001) * rd;\n        dist = mapEnv(rp);\n        hit = hit;\/\/ || hitDetail;\n    }\n    \n    closestPos = rp;\n    AA *= travelled * 30.0;\n\tAA = smoothstep(AA, .0, closest);\n    \n    float depth = travelled;\n    hit = hit || AA > .0;\n    \n    if (depth < color.a)\n    {\n        rp = closestPos;\n        g_groundHitp = ro + rd * depth;    \n        \n        if (hit)\n        {\n\t        color.a = depth;\n        }\n        vec3 g = gradEnv(closestPos, 0.05);\n        vec3 tc = (tex3D(iChannel1, closestPos * 0.15, g) * groundTint).rgb;\n        float luma = dot ( vec3(0.2126,0.7152, 0.0722), vec3(fbm(closestPos.xz * 2.1)));\n        float m = groundDetail(closestPos);\n        \n\t\tfloat texLuma = dot ( vec3(0.2126,0.7152, 0.0722), tc); \n        vec3 sand = mix(tc, mix(1., luma, 0.3) * vec3(1., .7, .4), m);\n        tc = mix(tc, sand, .5);\n        \n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/ some curvature details (ice)\n        float c1 = getCurvature(closestPos, g);\n        vec3 p2 = closestPos + vec3(.05, .0, .0);\n        vec3 g2 = gradEnv(p2, .05);\n        float c2 = getCurvature(p2, g2);\n        float curvature = 0.35 * (c1 + c2);\n\t\t\n        tc = mix(tc, vec3(1.0), smoothstep(2., .0, rp.y) * curvature);\n        float sh = shadowEnv(rp, g2, lightDir);\n        tc *= mix(1.0, sh, 0.81);\n        \n        float d = dot(g, lightDir);\n        d = clamp(d, 0.01, 1.0);\n        d = lobe(d, 0.4);\n        \n        color.rgb = mix(color.rgb, tc * d, AA);\n        \n    }\n    \n    g_hitp = rp;\n\treturn hit;  \n}\n\nmat3 lookat(vec3 from, vec3 to)\n{\n    vec3 f = normalize(to - from);\n    vec3 _tmpr = normalize(cross(f, vec3(0.0, .999, 0.0)));\n    vec3 u = normalize(cross(_tmpr, f));\n    vec3 r = normalize(cross(u, f));\n    return mat3(r, u, f);\n}\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/   Ship and camera orientation   \/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nvec3 getCamDirection(float T);\nvec3 getCamPos(float T);\n\nvec3 getShipPos(float T, float o)\n{\n    g_shipT = o + T + 1.5;\n    vec3 cp =  vec3(g_shipT, .6 + sin(g_shipT*.15) * 0.2, .0);\n    cp.z -= getPathOffset(g_shipT);\n    return cp;\n}\n\nvec3 getShipVelocity(float T)\n{\n    vec3 p1 = getShipPos(T, .0);\n\tvec3 p2 = getShipPos(T, 1.0);\n\treturn (p2 - p1);\n}\nvec3 getShipDirection(float T)\n{\n    return normalize(getShipVelocity(T));\n}\n\nfloat getShipRoll(float T)\n{\n    vec3 dirAtT = getShipDirection(T + 1.5);\n    float roll = (cross(dirAtT, getShipDirection(T + .0))).y * 10.0;\n    return clamp(roll, -PI2, PI2);\n}\n\nmat3 getShipRotation(float T)\n{\n    vec3 dirAtT = getShipDirection(T + 1.5);\n    mat3 fw = lookat(vec3(0.0), dirAtT);\n    return fw * rotz(-getShipRoll(T));\n}\n\nbool g_camStill = false;\nconst float SEQ_LENGTH = 250.0;\nconst float CAM_DRIVE_TIME = 50.0;\n\nvoid checkCamStill(float T)\n{\n    g_camStill = mod(T, SEQ_LENGTH) < CAM_DRIVE_TIME;\n}\n\nfloat getCamCurvature(float T)\n{\n    vec3 dirAtT = getCamDirection(T);\n    mat3 fw = lookat(vec3(0.0), dirAtT);\n    return (cross(dirAtT, getCamDirection(T - 1.1))).y;\n}\n\n\nvec3 getCamPos(float T)\n{\n    if (g_camStill) T = floor(T \/ SEQ_LENGTH) * SEQ_LENGTH + CAM_DRIVE_TIME \/ 2.0;\n    float y =  .5 + (.3 * sin(T * 0.05));\n\tvec3 cp = vec3(0.0);\n    if (g_camStill) \n    {\n    \tcp =  vec3(T, y - .15, .1);\n    }\n    else\n    {\n    \tcp =  vec3(T,y, .0);\n\t\tcp.x += sin(T * 0.05) * .5;\n    }\n   \tcp.z -= getPathOffset(cp.x);\n\treturn cp;    \n}\n\nvec3 getCamDirection(float T)\n{\n    \n    vec3 p1 = getCamPos(T - 2.);\n    if(g_camStill) p1 = getCamPos(T);\n    \n    vec3 p2 = getShipPos(T, 0.0);\n    return normalize(p2 - p1);\n}\n\nmat3 getCamRotation(float T)\n{\n    mat3 fw = lookat(vec3(0.0), getCamDirection(T));\n    float roll = getCamCurvature(T) * 8.0;\n    roll = clamp(roll, -PI2, PI2);\n    if(g_camStill) roll = 0.0;\n    return fw * rotz(-roll);\n}\n\nvoid doSky(in vec3 ro, in vec3 rd, inout vec3 col)\n{\n\n    float skyH = 120.0;\n    float dif = skyH - ro.y;\n    float cloudSpeed = iTime * 0.01;\n    vec3 rp = ro + (rd * dif * (1.0 \/ rd.y));\n    vec2 uv = vec2(rp.xz * 0.0001);\n    float f = fbmHI(cloudSpeed * vec2(1.0, 0.0) + uv);\n    f = smoothstep(0.0, 0.8, f);\n    \n    float f2 = fbmHI(cloudSpeed * vec2(1.0, 0.4) + uv * 2.0);\n    f = mix(f, f2, 0.5);\n    col = mix(col, vec3(f - smoothstep(1., 2.5, f + f2)), f);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    g_camT = 100.0 + mod(iTime, 900.0) * 10.0;\n    checkCamStill(g_camT);\n    \n    g_shipRotation = getShipRotation(g_camT);\n    g_model_correction = roty(-PI2);\n\t\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n    uv -= vec2(0.5);\n    uv.y \/= iResolution.x \/ iResolution.y;\n\tg_uv = uv;\n    vec2 im = 2.0 * ((iMouse.xy \/ iResolution.xy) - vec2(0.5));\n    \n    \/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/\/ Camera\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    vec3 rp = getCamPos(g_camT);\n    g_shipPos = getShipPos(g_camT, 0.0);\n\n\tvec3 rd = normalize(vec3(uv, .4));\n    mat3 lkAtMat = getCamRotation(g_camT);\n    \n    rd = normalize(lkAtMat * rd);    \n    fragColor.rgb = vec3(0.0);\n\tfragColor.a = 9999.0;\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/\/ BG mountains + sky  \/\/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    vec3 depthFade = mix(fragColor.rgb, bgFadeCol, min(1.0, pow(fragColor.a * 0.02, 1.)));\n    fragColor.rgb = depthFade;\n    \n    \/\/ sky colors and mountains\n    if (rd.y > 0.0)\n    {\n\t    vec2 polar = vec2(PI + atan(rd.z, rd.x), 1.0);\n    \tfloat H = sin(polar.x * 20.0) * 0.2;\n    \tH += sin(polar.x * 1.0) * 0.4;\n    \tH += sin(polar.x * 5.0) * 2.0;\n    \tH += sin(polar.x * .4) * 0.25;\n        \n\t    vec3 grp = rp + rd * 1000.0;\n\t    float mTop = -25.0;\n    \tfloat mFade = smoothstep(0.0, 5000. * dFdx(g_uv).x, (grp.y + mTop) - H * 10.0);\n        fragColor.rgb = (1.0 - vec3(mFade)) * bgFadeCol;\n        vec3 skyBottom = vec3(.5, .6, .8) * 2.;\n        vec3 skyTop = vec3(0.2, 0.3, 0.7) * 2.1;\n        fragColor.rgb += mix(skyBottom, skyTop, smoothstep(0.0, 0.6, rd.y)) * mFade;\n    }\n    \n\t\/\/ Environment\n    bool env = doEnv(rp, rd, fragColor);\n    \/\/ Ship    \n    bool shipHit = doShip(rp, rd, fragColor);\n    \n    \/\/ ship shadow\n    if (!shipHit)\n    {\n        vec3 dif = (g_shipPos - g_groundHitp);\n        float d = dot(normalize(dif), vec3(0.0, 1.0, 0.0));\n        d = clamp(d, 0.0, 1.0);\n        float x = pow(length(dif * 20.), .7) * (1.0 - d);\n        x = clamp(x, 0.0, 1.0);\n        fragColor.rgb = mix(fragColor.rgb, x * fragColor.rgb, 0.5);\n    }\n    \n    \n    \/\/ clouds\n    if(!env && !shipHit && rd.y > 0.0)\n    {\n        doSky(rp, rd, fragColor.rgb);\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ data for motion blur   \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \n\t\/\/ the pixel at (0, 0) reads previous frame ray direction from pixel (1, 0) \n    \/\/ pixel at (1, 0) stores ray direction with \"time stamp\"\n    float tStamp = mod(float(iFrame), 100.0);\n    if(fragCoord.y < 1.0)\n    {\n        if(fragCoord.x < 1.0)\n        {\n            \/\/ check value from pixel next to this\n\t        vec4 stored = texture(iChannel0, vec2(1.5, 0.5) \/ iChannelResolution[0].xy, -100.0 );\n            if (stored.a != tStamp)\n            {\n                \/\/ store value if it's older than current frame to this pixel\n                fragColor = stored;\n            }\n        }\n        else if (fragCoord.x < 2.0)\n        {\n\t        fragColor.rgb = vec3(0.0, 0.0, 1.0) * lkAtMat;\n            fragColor.a = tStamp;\n        }\n        \/\/ camera matrix information\n        else if (fragCoord.x < 3.0) fragColor.rgb = lkAtMat[0];\n        else if (fragCoord.x < 4.0) fragColor.rgb = lkAtMat[1];\n        else if (fragCoord.x < 5.0) fragColor.rgb = lkAtMat[2];\n        \n    }\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec4 getTexColor(vec2 uv)\n{\n    return texture(iChannel0, uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy\/iResolution.xy;\n\n    vec4 texColor = getTexColor(uv);\n    \n    vec3 prevCamD = texture(iChannel0, vec2(0.5, 0.5) \/ iChannelResolution[0].xy, -100.0 ).rgb;\n\n    mat3 lkAt;\n    lkAt[0] = texture(iChannel0, vec2(2.5, 0.5) \/ iChannelResolution[0].xy, -100.0 ).rgb;\n    lkAt[1] = texture(iChannel0, vec2(3.5, 0.5) \/ iChannelResolution[0].xy, -100.0 ).rgb;\n    lkAt[2] = texture(iChannel0, vec2(4.5, 0.5) \/ iChannelResolution[0].xy, -100.0 ).rgb;\n    \n    float stpX = (1.0 \/ iResolution.x);\n    float stpY = (1.0 \/ iResolution.y);\n    \n    vec3 dif = prevCamD * transpose(lkAt);\n    dif.x *= -1.0;\n    dif *= log2(1.0 + dot(dif, dif) * 1000.0);\n    vec3 color = texColor.rgb * 1.0;\n    \n    const int stps = 10;\n    float dist = max( (log2(1.0 + texColor.a * 200.0) ) - 4.0, 0.0);\n    float depth = min( dist, 250.0);\n    float ld = length(dif);\n    \n    float w = 1.0;\n    for (int i = 1; i < stps; ++i)\n    {\n        vec2 _uv = uv - dif.xy * depth * float(i) * fwidth(uv) * .35;\n        \n        if (_uv.x >= 0.0 && _uv.x <= 1.0 && _uv.y >= 0.0 && _uv.y <= 1.0)\n        {\n            float wt = 1.0 \/ (float(i) + 1.);\n            w += wt;\n\t        color += getTexColor(_uv).rgb * wt;\n        }\n    }\n    \n    color \/= w;\n    fragColor.rgb = color;\n}","name":"Buf B","description":"","type":"buffer"}]}];    var gUseScreenshots = piIsMobile();
    var gThemeName = "classic";



    </script>
</head>

<!-- <body onload="resultsInit(12,null,null)"> -->
<body onload="resultsInitStatic(12,null,null)">

<!-- header =================================================================================== -->


<div id="header">

    <div id="headerBlock1">
        <a href="/" id="headerTitle">Shadertoy</a>
        <form name="formSearch" action="/results" method="get" style="display:inline-block;">
        <div  id="headerSearch">
            <input type="search" id="mySearch" name="query" placeholder="Search..." value=""/>
        </div>
        </form>
    </div>

    <div id="headerBlock2">
            <a class="headerLinks" href="/browse">Browse</a>
        <a class="headerLinks" href="/new">New</a>
        <a class="headerLinks" href="/signin">Sign In</a>
        </div>
</div>
<!-- content ================================================================================== -->

<div id="content">

  <div id="controls">
    <div>
      <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
      Sort:      </div>
      <div class="controlOptions"><div class="pageButtonsCurrent" href="/results?query=&sort=popular&filter=">Popular</div><a class="pageButtons" href="/results?query=&sort=newest&filter=">Newest</a><a class="pageButtons" href="/results?query=&sort=love&filter=">Love</a><a class="pageButtons" href="/results?query=&sort=hot&filter=">Hot</a></div>
    </div>

    <div id="controlFilter">
      <div style="display:flex;margin-right:8px;align-items:center;">Filter:</div>
      <div class="controlOptions"> <a class="pageButtons" href="/results?query=&sort=popular&filter=multipass">Multipass</a><a class="pageButtons" href="/results?query=&sort=popular&filter=soundoutput">GPU Sound</a><a class="pageButtons" href="/results?query=&sort=popular&filter=vr">VR</a><a class="pageButtons" href="/results?query=&sort=popular&filter=soundinput">Microphone</a><a class="pageButtons" href="/results?query=&sort=popular&filter=musicstream">Soundcloud</a><a class="pageButtons" href="/results?query=&sort=popular&filter=webcam">Webcam</a></div>
    </div>

    <div>
        <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
        View:</div>
        <div><a class="pageButtons" href="/slideshow?query=&sort=popular">Slideshow</a></div>
    </div>

    <div class="navigation" id="navTop" ><span style="padding-right:8px;">Results (74098):</span><div class="controlOptions"><a id="pageButtonFirst" class="pageButtons" href="results?query=&sort=popular&from=0&num=12">1</a><span>...</span><a id="pageButton"0 class="pageButtons" href="results?query=&sort=popular&from=372&num=12">32</a><a id="pageButton"1 class="pageButtons" href="results?query=&sort=popular&from=384&num=12">33</a><div id="pageButton"2 class="pageButtonsCurrent" href="results?query=&sort=popular&from=396&num=12">34</div><a id="pageButton"3 class="pageButtons" href="results?query=&sort=popular&from=408&num=12">35</a><a id="pageButton"4 class="pageButtons" href="results?query=&sort=popular&from=420&num=12">36</a><span>...</span><a id="pageButtonLast" class="pageButtons" href="results?query=&sort=popular&from=74088&num=12">6175</a></div>
</div>
  </div>


  <div id="shaderGrid">
    <div class='searchResult'><div class='searchResultContainer' id='Preview_0_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_0_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_0_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_0_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_0_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_0_Thumnail'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_0_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_0_Info'>  <span class='previewText'  id='Preview_0_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_0_TextUser'></span>  <span class='previewStats' id='Preview_0_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_1_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_1_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_1_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_1_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_1_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_1_Thumnail'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_1_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_1_Info'>  <span class='previewText'  id='Preview_1_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_1_TextUser'></span>  <span class='previewStats' id='Preview_1_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_2_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_2_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_2_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_2_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_2_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_2_Thumnail'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_2_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_2_Info'>  <span class='previewText'  id='Preview_2_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_2_TextUser'></span>  <span class='previewStats' id='Preview_2_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_3_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_3_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_3_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_3_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_3_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_3_Thumnail'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_3_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_3_Info'>  <span class='previewText'  id='Preview_3_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_3_TextUser'></span>  <span class='previewStats' id='Preview_3_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_4_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_4_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_4_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_4_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_4_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_4_Thumnail'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_4_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_4_Info'>  <span class='previewText'  id='Preview_4_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_4_TextUser'></span>  <span class='previewStats' id='Preview_4_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_5_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_5_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_5_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_5_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_5_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_5_Thumnail'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_5_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_5_Info'>  <span class='previewText'  id='Preview_5_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_5_TextUser'></span>  <span class='previewStats' id='Preview_5_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_6_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_6_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_6_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_6_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_6_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_6_Thumnail'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_6_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_6_Info'>  <span class='previewText'  id='Preview_6_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_6_TextUser'></span>  <span class='previewStats' id='Preview_6_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_7_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_7_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_7_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_7_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_7_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_7_Thumnail'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_7_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_7_Info'>  <span class='previewText'  id='Preview_7_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_7_TextUser'></span>  <span class='previewStats' id='Preview_7_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_8_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_8_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_8_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_8_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_8_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_8_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_8_Thumnail'>        <img class='previewThumbnailImage' id='Preview_8_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_8_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_8_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_8_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_8_Info'>  <span class='previewText'  id='Preview_8_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_8_TextUser'></span>  <span class='previewStats' id='Preview_8_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_9_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_9_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_9_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_9_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_9_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_9_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_9_Thumnail'>        <img class='previewThumbnailImage' id='Preview_9_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_9_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_9_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_9_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_9_Info'>  <span class='previewText'  id='Preview_9_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_9_TextUser'></span>  <span class='previewStats' id='Preview_9_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_10_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_10_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_10_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_10_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_10_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_10_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_10_Thumnail'>        <img class='previewThumbnailImage' id='Preview_10_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_10_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_10_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_10_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_10_Info'>  <span class='previewText'  id='Preview_10_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_10_TextUser'></span>  <span class='previewStats' id='Preview_10_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_11_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_11_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_11_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_11_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_11_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_11_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_11_Thumnail'>        <img class='previewThumbnailImage' id='Preview_11_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_11_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_11_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_11_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_11_Info'>  <span class='previewText'  id='Preview_11_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_11_TextUser'></span>  <span class='previewStats' id='Preview_11_Stats'></span></div></div>  </div>
  <br>
  <div class="navigation" id="navBottom" ><span style="padding-right:8px;">Results (74098):</span><div class="controlOptions"><a id="pageButtonFirst" class="pageButtons" href="results?query=&sort=popular&from=0&num=12">1</a><span>...</span><a id="pageButton"0 class="pageButtons" href="results?query=&sort=popular&from=372&num=12">32</a><a id="pageButton"1 class="pageButtons" href="results?query=&sort=popular&from=384&num=12">33</a><div id="pageButton"2 class="pageButtonsCurrent" href="results?query=&sort=popular&from=396&num=12">34</div><a id="pageButton"3 class="pageButtons" href="results?query=&sort=popular&from=408&num=12">35</a><a id="pageButton"4 class="pageButtons" href="results?query=&sort=popular&from=420&num=12">36</a><span>...</span><a id="pageButtonLast" class="pageButtons" href="results?query=&sort=popular&from=74088&num=12">6175</a></div>
</div>  <br>      
</div>

<!-- footer ================================================================================== -->

<div id="footer">
    
    <div><span style="color:#ffffff;">Community Forums</span>
      <ul>
      <li><a class="regular" href="/events">Official Events</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/147749602472741">In Facebook (english)</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/1339783682699494">In Facebook (korean)</a></li>
      <li><a class="regular" href="https://discord.gg/XtmMN6E">In Discord</a> (<a class="regular" href="https://discordapp.com/channels/578696555612209173/579531723348639754">direct link</a>)</li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Feedback and Support</span>
      <ul>
      <li><a class="regular" href="https://www.facebook.com/Shadertoy">Facebook</a></li>
      <li><a class="regular" href="https://twitter.com/shadertoy">Twitter</a></li>
      <li><a class="regular" href="https://www.patreon.com/shadertoy">Patreon</a></li>
      <li><a class="regular" href="https://trello.com/b/5hM0CjId">Roadmap</a></li>

      
      </ul>
    </div>

    <div><span style="color:#ffffff;">Shadertoy</span>
      <ul>
      <li><a class="regular" href="/store">Store</a></li>
      <li><a class="regular" href="/howto">Documentation</a></li>
      <li><a class="regular" href="/terms">Terms & Privacy</a></li>
      <li><a class="regular" href="/about">About</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Apps and Plugins</span>
      <ul>
      <li><a class="regular" href="https://itunes.apple.com/us/app/shadertoy/id717961814">Official iPhone App</a> by <a class="user" href="/user/reinder">Reinder</a></li>
      <li><a class="regular" href="https://steamcommunity.com/sharedfiles/filedetails/?id=1726697188">Screensaver</a> by <a class="user" href="/user/kosro">Kosro</a></li>
      <li><a class="regular" href="https://chrome.google.com/webstore/detail/shadertoy-unofficial-plug/ohicbclhdmkhoabobgppffepcopomhgl">Shadertoy plugin</a> by <a class="user" href="/user/patu">Patu</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Tutorials</span>
      <ul>
      <li><a class="regular" href="https://www.youtube.com/watch?v=0ifChJ0nJfM">Shader coding intro</a> by <a class="user" href="/user/iq">iq</a></li>
      <li><a class="regular" href="https://shadertoyunofficial.wordpress.com/">Shadertoy Unofficial</a> by <a class="user" href="/user/FabriceNeyret2">FabriceNeyret2</a></li>
      </ul>
    </div>

</div>

<div id="compliance" style="padding-bottom:6px;visibility:hidden;left:0;top:0px;width:100%;background-color:rgb(200,120,20,0.93);position:absolute;color:#FFFFFF">
    <div style="text-align: center; margin-top:8px">
        We use cookies to give you the best experience on our website. If you continue using Shadertoy, we'll assume that you are happy to receive all cookies on this website. 
        For more information, please review our <a class="regular" href="/terms">Terms & Privacy</a>.
    </div> 
    <div style="text-align: center;margin-top:6px">
        <button type="button" style="width:100px;font-size:inherit" onclick="acceptCompliance()">Accept</button>
    </div>
</div>

<script>
(function runCompliance() 
{
    let showCompliance = 1;
    let allcookies = document.cookie;
    let cookiearray = allcookies.split(';');
    for (var i=0; i<cookiearray.length; i++)
    {
        let name  = cookiearray[i].split('=')[0];
        let value = cookiearray[i].split('=')[1];
        if (name.trim() == "scmp") 
        {
            showCompliance = value;
            break;
        }
    }

    if (showCompliance === 1) 
    {
        var ve = document.getElementById("compliance");
        ve.style.visibility="visible";
    }
})();

function acceptCompliance()
{
    let now = new Date();
    now.setTime( now.getTime() + (5*365*24*60*60*1000) );
    document.cookie="scmp=0;expires=" + now.toUTCString() + ";";

    var ve = document.getElementById("compliance");
    ve.style.visibility="hidden";
}
</script>

</body>
</html>
