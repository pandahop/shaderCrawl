<!DOCTYPE HTML>
<html lang="en">
<head>

    
<script async src="https://www.googletagmanager.com/gtag/js?id=G-7SYLWGZYJ2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-7SYLWGZYJ2');
</script>

<title>Browse (46) - Shadertoy BETA</title>
<meta charset="utf-8" />
<meta name="Keywords" content="shadertoy, shader toy, quilez, inigo, jeremias, pol, fractals, demoscene, computer graphics, mathematics, rendering, demo, 3D, realtime, shader, raytracing, raymarching, webgl, glsl" />
<meta name="Description" content="Build shaders, share them, and learn from the best community." />
<meta name="Author" content="Beautypi" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<link rel="image_src" href="https://www.shadertoy.com/img/logo.png" />
<link rel="apple-touch-icon" href="/img/launch_icon_57.png"/>
<link rel="apple-touch-icon" sizes="72x72" href="/img/launch_icon_72.png"/>
<link rel="apple-touch-icon" sizes="114x114" href="/img/launch_icon_114.png"/>
<link rel="shortcut icon" href="/img/favicon.ico"/>

<style>::-webkit-scrollbar {
    height: 8px;
    width: 8px;
    background: #404040;
}

::-webkit-scrollbar-thumb
{
    background: #909090;
    border-radius: 0ex;
}

::-webkit-scrollbar-corner
{
    background: #000;
}

::-webkit-input-placeholder
{
	font-style:italic;
}
input:-moz-placeholder, textarea:-moz-placeholder
{
	font-style:italic;
}
input.placeholder-text, textarea.placeholder-text
{
	font-style:italic;
}

pre 
{
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
    white-space: -pre-wrap;
    white-space: -o-pre-wrap;
    word-wrap: break-word;
}

@font-face
{
    font-family: Lobster;
    src: url("/img/lobster.otf") format("opentype");
}

div#centerScreen
{
    left: 50%;
    top: 50%;
    position: absolute;
}

a.headerLinks:hover
{
    background-color:#505050;
    color : #ff8020;
}

body
{
    color: #000000;
    font-size:12px;
    font-style:normal;
    font-family:Tahoma,Arial;
    background-repeat: no-repeat;
    //background-attachment: fixed;
    padding:0px;
    margin:0px;
    text-align: left;
    background-color: #d0d0d0;
    background-repeat: repeat;
    user-select: text;
}

a,
a:hover,
a:visited
{
  color : inherit;
}

div#content {
    width: 95%;
    overflow: hidden;
    margin: auto;
    padding: 0px;
    min-height: calc(100vh - 80px);
    //box-sizing: border-box;
}


.notificationCount
{
 background-color:#ff0000;
 padding-left:3px;
 padding-right:1px;
 padding-top:1px;
 padding-bottom:1px;
}

div#header
{
    background-color: #404040;
    top: 0px;
    left: 0px;
    width: 100%;
    padding: 0;
    margin: 0;
    color: #ffffff;
    display: flex;
    flex-direction:row;
}

#headerBlock1
{
    width: 50%;
    display:flex;
    align-items:center;
}

a#headerTitle
{
    font-size: 2.25em;
    font-family: Lobster,Tahoma,Arial;
    text-decoration: none;
    padding-left:32px;
    padding-right:32px;
}

#headerSearch
{
    display: inline-block;
    color: #000000;
    width: 300px;
}

input[type=search]#mySearch
{
    width: 100%;
    border-radius: 6px;
    border: 1px solid black;
    padding:12px;
}

#headerBlock2
{
    width: 50%;
    margin-left: auto;
    display: flex;
    justify-content: flex-end;
}


a#headerTitle:hover
{
    color : #ff8020;
}

a.headerLinks
{
    font-weight: bold;
    padding-top: 14px;
    padding-bottom: 14px;
    padding-left: 14px;
    padding-right: 14px;
    margin:0px;
    text-decoration: none;
    transition: background-color 0.15s linear, color 0.15s linear;
}

#footer
{
    background-color: rgba(64,64,64,0.25);
    color: #000000;
    padding: 0px;
    margin: 0px;
    width: 100%;
    display: flex;
    justify-content: space-between;
    flex-wrap: wrap;
}

#footer div
{
    padding-top:10px;
    padding-bottom:0px;
    padding-left:16px;
    padding-right:16px;
}

#footer div ul
{
    margin-left:0px;
    padding-left:16px;
}

#footer div ul li
{
    padding-top:6px;
}

a.regular
{
    font-weight:bold;
    text-decoration:none
}

a.regular:hover
{
  color : #ff8020;
}

a.user
{
    font-weight:bold;
    text-decoration:none;
}

a.user:hover
{
  color : #ff8020;
  text-decoration: underline;
}

.uiButton
{
    border: none;
    outline: none;
    margin: 0px;
    padding: 0px;
    width: 22px;
    height: 22px;
    position: absolute;
    cursor: pointer;
    border-radius: 4px;
}

.uiButton:hover
{
    box-shadow: inset 0px 0px 1px 1px #808080, 0px 0px 1px 1px #808080;
}

.uiDivBUtton
{
    cursor:pointer;
}

.uiDivBUtton:hover
{
    color: #ffffff;
}


.dialog
{
    display: block;
    background-color: #e0e0e0;
    color: #000000;
    border:1px solid #000;
    padding:0px;
    margin:0px;
    text-align:left;
    border-radius: 4px;
    box-shadow:4px 4px 6px 0px rgba(0,0,0,0.5);
    overflow: hidden;
    z-index:1000;
    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;
}

.dialogHeader
{
    left:0px;
    top: 0px;
    width:100%;
    height:32px;
    position: absolute;
    background-color: #808080;
    cursor:move;
}

.dialogTitle
{
    left: 12px;
    top: 4px;
    position: absolute;
    padding: 0px;
    margin: 0px;
    color:#000000;
    font-size:1.5em;
    text-align: left;
    user-select: none;
    -moz-user-select: -moz-none;
    -webkit-user-select: none;
}

.dialogOverlay
{
    z-index:1000;

    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;

    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    width:100%;
    height:100%;
    position:absolute;

    background-color:rgba(0,0,0,.4);
}

.viewsIcon, .likesIcon
{
    border: none;
    outline: none;
    display:inline-block;
    background-repeat:no-repeat;
    top:0px;
    left:0px;
    padding:0px;
    padding-right: 2px;
    margin:0px;
    position:relative;
}

.userPictureSmall
{
    background-color:#808080;
    border: 1px solid #000000;
    width:32px;
    height:32px;
}

.dialogCloseButton
{
    right:8px;
    top: 4px;
    width:22px;
    height:22px;
    position: absolute;
    background-image: url("/img/close.png");
    cursor: pointer;
    border-radius: 4px;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContentButtons
{
     padding:0;
     border:0;
     text-align: justify;
     left: 24px;
     bottom:40px;
     position:absolute;
}

.dialogButton
{
    text-align: center;
    vertical-align: middle;
    display: inline-block;
    border-radius: 4px;
    font-weight: bold;
    cursor: pointer;
    padding-bottom:5px;
    padding-top:4px;
    padding-left: 8px;
    padding-right: 8px;
    margin-left:4px;
    margin-right:4px;
    text-decoration: none;
    color:#000000;
    width: 80px;
    -moz-transition:    background-color 0.15s linear, color 0.15s linear;
    -webkit-transition: background-color 0.15s linear, color 0.15s linear;
    transition:         background-color 0.15s linear, color 0.15s linear;
}

.dialogButton:hover
{
  background-color:#808080;
  color : #ff8020;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContent
{
    color: inherit;
    overflow: auto;
    width:100%;
    height:100%;
    left: 0px;
    top: 32px;
    position:absolute
}

.dialogContentBody
{
    color: inherit;
    width:100%;
    height:auto;
    padding-top:24px;
    padding-bottom:24px;
    padding-left:24px;
    padding-right:24px;
    text-align: left;
}

.formButton
{
    font-weight:bold;
	color:#ffffff;
	border:none;
    text-align:center;
	background-color:#808080;
    border-radius: 4px;
	padding-left:8px;
	padding-right:8px;
	padding-top:4px;
	padding-bottom:4px;
    cursor:pointer;
    min-width:80px;
    box-sizing: border-box;
}
.formInput {
    border-radius: 6px;
    border: 1px solid black;
    padding: 4px;
    border: none;
}
.formButton:hover {
    background-color: #e0e0e0;
}
.formButton:disabled
{
	color:#b0b0b0;
	background-color:#808080;
}

.formButtonSmall
{
    color:#ffffff;
    border:none;
    text-align:center;
    background-color:#808080;
    border-radius: 4px;
    padding-left:2px;
    padding-right:2px;
    padding-top:2px;
    padding-bottom:2px;
    cursor:pointer;
    min-width:40px;
}

.formButtonSmall:hover
{
    background-color: #e0e0e0;
}

.formButtonSmall:disabled
{
    color:#b0b0b0;
    background-color:#808080;
}

.formButtonSmall.disabled2,
.formButton.disabled2 { color:#b0b0b0; background-color:#808080; pointer-events: none; }

.inputForm
{
    padding-left:2%;
    padding-right:2%;
    resize: none;
    text-align: left;
    background-color:#e0e0e0;
    outline: none;
    border-radius: 4px;
    border: 1px solid #808080;
    color:inherit;
    box-sizing: border-box;
}

.inputForm:focus
{
    border: 1px solid #AFCDD8;
    background-color: #EBF2F4;
}

.transparentPannel
{
    background-color:rgba(64,64,64,0.1);
    padding:16px;
}

.comment, .commentSelf, .commentNew
{
    border-radius: 4px;
    width: 100%;
    margin-left: 0px;
    margin-right: 0px;
    margin-top: 0px;
    margin-bottom: 6px;

    padding: 14px;
    box-sizing: border-box;
    display: grid;
    grid-template-columns: 32px auto 8px;
    grid-template-rows: 1fr;
    grid-gap:8px;
}

.comment:nth-child(even)
{
    background-color: rgba(64,64,64,0.1);
}

.comment:nth-child(odd)
{
    background-color: rgba(128,128,128,0.1);
}

.commentSelf
{
    background-color: rgba(240,160,64,0.1);
}

.commentNew
{
    padding-right: 0px;
    grid-template-columns: 40px auto;
}

.commentContent
{
    vertical-align: top;
    text-align: left;
    word-break: break-all;
    word-break: break-word;
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
}


/* ----------------------- media resolutions ------------------------ */

@media screen and (max-width:799px)
{
    div#header {flex-direction:column; }
    #headerBlock1 { width:100%; }
    #headerBlock2 { width:100%; justify-content: space-around;}
    div#headerSearch {width:200px;}
    input#mySearch { width:200px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:10px; }
}

@media screen and (min-width:800px) and (max-width:1279px)
{
    body { font-size: 9px; }
    div#headerSearch {width: 250px;}
    input#mySearch { width:250px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:11px; }
}

@media screen and (min-width:1280px) and (max-width:1439px)
{
    body { font-size: 10px; }
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1440px) and (max-width:1919px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1920px) and (max-width:2559px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}

@media screen and (min-width:2560px) 
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}
body
{
    background-image: url("/img/themes/classic/background.jpg");
}
</style>

    <script>"use strict"

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piCamera
//
//==============================================================================

function piCamera()
{
    var mMatrix = setIdentity();
    var mMatrixInv = setIdentity();

    var mPosition = [0.0,0.0,0.0];
    var mXRotation = 0.0;
    var mYRotation = 0.0;

    var mPositionTarget = [0.0,0.0,0.0];
    var mXRotationTarget = 0.0;
    var mYRotationTarget = 0.0;

    var me = {};
/*
    me.Set = function( pos, dir, roll) 
             {
                 mMatrix    = setLookat( pos, add(pos,dir), [Math.sin(roll),Math.cos(roll),Math.sin(roll)] );
                 mMatrixInv = invertFast( mMatrix );
             };
*/
    me.SetPos = function(pos)
                {
                    mPosition = pos;
                    //mMatrix[ 3] = -(mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                    //mMatrix[ 7] = -(mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                    //mMatrix[11] = -(mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                };
/*
    me.GlobalMove = function(pos)
                    {
                        mMatrix[ 3] -= (mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                        mMatrix[ 7] -= (mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                        mMatrix[11] -= (mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                        mMatrixInv = invertFast(mMatrix);
                    };
*/
    me.LocalMove = function( dis )
                    {
                        dis = matMulvec( setRotationY(-mYRotation), dis);
                        mPositionTarget = sub(mPositionTarget,dis)
                    };

    me.RotateXY = function( x, y)
                  {
                    mXRotationTarget -= x;
                    mYRotationTarget -= y;
                    mXRotationTarget = Math.min( Math.max( mXRotationTarget, -Math.PI/2), Math.PI/2 );
                  };


    me.CameraExectue = function( dt )
    {
        // smooth position
        mXRotation += (mXRotationTarget-mXRotation) * 12.0*dt;
        mYRotation += (mYRotationTarget-mYRotation) * 12.0*dt;
        mPosition = add(mPosition, mul( sub(mPositionTarget, mPosition), 12.0*dt));

        // Make Camera matrix
        mMatrix = matMul( matMul(setRotationX(mXRotation), 
                                 setRotationY(mYRotation)),  
                                 setTranslation(mPosition));
        mMatrixInv = invertFast(mMatrix);

    }

    me.GetMatrix = function() { return mMatrix; };
    me.GetMatrixInverse = function() { return mMatrixInv; };
    me.SetMatrix = function( mat ) 
                    {
                        mMatrix = mat;
                        mMatrixInv = invertFast(mMatrix);

                        mPosition = getXYZ(matMulpoint(mat, [0.0,0.0,0.0]));
                        mPositionTarget = mPosition;
                    };

    me.GetPos = function() { return getXYZ(matMulpoint(mMatrixInv, [0.0,0.0,0.0])); }
    me.GetDir = function() { return getXYZ(normalize(matMulvec(mMatrixInv, [0.0,0.0,-1.0]))); }

    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piFile
//
//==============================================================================

function piFile( binaryDataArrayBuffer )
{
    // private
    //var mDataView = new DataView( binaryDataArrayBuffer, 0 );
    var mDataView = binaryDataArrayBuffer;
    var mOffset = 0;

    // public members
    var me = {};
    me.mDummy = 0;
/*
    // public functions
    me.Seek = function( off ) { mOffset = off - 3; };
    me.ReadUInt16 = function()  { var res = mDataView.getUint16( mOffset ); mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = mDataView.getUint32( mOffset ); mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = mDataView.getFloat32( mOffset ); mOffset+=4; return res; };
*/

    me.Seek = function( off ) { mOffset = off; };
    me.ReadUInt8  = function()  { var res = (new Uint8Array(mDataView,mOffset))[0]; mOffset+=1; return res; };
    me.ReadUInt16 = function()  { var res = (new Uint16Array(mDataView,mOffset))[0]; mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = (new Uint32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = (new Float32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadFloat32Array = function(n) 
                          { 
                              var src = new Float32Array(mDataView, mOffset);
                              var res = [];  for( var i=0; i<n; i++ ) { res[i] = src[i]; }
                              mOffset += 4*n;
                              return res;
                          };
    me.ReadFloat32ArrayNative = function(n) { var src = new Float32Array(mDataView, mOffset); mOffset += 4*n; return src; };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piMesh
//
//==============================================================================

function piMesh()
{
    this.mChunks = [];
    this.mPrimitiveType = 0;
    this.mVertexFormat = null;
}

/*
piMesh.prototype.normalize = function( ppos, npos )
{
    var numv = this.mVertexData.length;
    var numt = this.mIndices.length;

    for( var i=0; i<numv; i++ )
    {
        //float *v = (float*)piMesh_GetVertexData( me, i, npos );
        //v[0] = 0.0f;
        //v[1] = 0.0f;
        //v[2] = 0.0f;
        this.mVerts[8 * i + 3] = 0.0;
        this.mVerts[8 * i + 4] = 0.0;
        this.mVerts[8 * i + 5] = 0.0;
    }

    for( var i=0; i<numt; i++ )
    {
        piMeshFace *face = me->mFaceData.mIndexArray[0].mBuffer + i;

        const int ft = face->mNum;
        
        vec3 nor = vec3( 0.0f, 0.0f, 0.0f );
        for( int j=0; j<ft; j++ )
        {
            const vec3 va = *((vec3*)piMesh_GetVertexData( me, face->mIndex[ j      ], ppos ));
            const vec3 vb = *((vec3*)piMesh_GetVertexData( me, face->mIndex[(j+1)%ft], ppos ));

            nor += cross( va, vb );
        }

        for( int j=0; j<ft; j++ )
        {
            vec3 *n = (vec3*)piMesh_GetVertexData( me, face->mIndex[j], npos );
            n->x += nor.x;
            n->y += nor.y;
            n->z += nor.z;
        }
    }

    for( var i=0; i<numv; i++ )
    {
        vec3 *v = (vec3*)piMesh_GetVertexData( me, i, npos );
        *v = normalize( *v );
    }
}
*/

piMesh.prototype.createCube = function(renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([ -1.0, -1.0, -1.0,
                                       1.0, -1.0, -1.0,
                                      -1.0,  1.0, -1.0,
                                       1.0,  1.0, -1.0,
                                      -1.0, -1.0,  1.0,
                                       1.0, -1.0,  1.0,
                                      -1.0,  1.0,  1.0,
                                       1.0,  1.0,  1.0 ]),

                        mIndices : new Uint16Array([ 0, 2, 1,   1, 2, 3,   5, 1, 3,   5, 3, 7,   4, 5, 7,   4, 7, 6,   4, 6, 2,   4, 2, 0,   6, 7, 3,   6, 3, 2,   4, 0, 1,   4, 1, 5 ]),
                        mNumVertices : 8,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };

    this.mVertexFormat = { mStride:12, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}

piMesh.prototype.createCubeSharp = function (renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 1.0,
                                    -1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 0.0,

                                     1.0, 1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 0.0,

                                     1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 1.0,
                                    -1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   1.0, 1.0,
                                     1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   1.0, 0.0,

                                    -1.0, 1.0, 1.0,  -1.0, 0.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0,-1.0,  -1.0, 0.0, 0.0,   0.0, 1.0,
                                    -1.0,-1.0,-1.0,  -1.0, 0.0, 0.0,   1.0, 1.0,
                                    -1.0,-1.0, 1.0,  -1.0, 0.0, 0.0,   1.0, 0.0 ]),

                        mIndices : new Uint16Array([0,1,2, 0,2,3,   4,5,6, 4,6,7,    8,9,10,8,10,11,   12,13,14,12,14,15,   16,17,18,16,18,19,   20,21,22,20,22,23]),
                        mNumVertices : 24,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };


    this.mVertexFormat = { mStride:32, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}


piMesh.prototype.createUnitQuad = function (renderer)
{
    this.mPrimitiveType = 0;
    this.mVertexFormat = { mStride:8, mChannels: [ {mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false} ] };

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0,  1.0, 1.0,  1.0]),
                        mIndices : new Uint16Array([0, 2, 1, 1, 2, 3]),
                        mNumVertices : 4,
                        mNumFaces : 2, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };
 
    return true;
}




piMesh.prototype.destroy = function()
{
    //delete this.mVerts;   this.mVerts = null;
    //delete this.mIndices; this.mIndices = null;
}

piMesh.prototype.scale = function (x, y, z)
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] *= x;
            this.mChunks[j].mVerts[stride * i + 1] *= y;
            this.mChunks[j].mVerts[stride * i + 2] *= z;
        }
    }
}

piMesh.prototype.translate = function (x, y, z) 
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] += x;
            this.mChunks[j].mVerts[stride * i + 1] += y;
            this.mChunks[j].mVerts[stride * i + 2] += z;
        }
    }
}

piMesh.prototype.GPULoad = function (renderer)
{
    for( var i=0; i<this.mChunks.length; i++ )
    {
        var vbo = renderer.CreateVertexArray(this.mChunks[i].mVerts, renderer.BUFTYPE.STATIC );
        if (vbo == null)
            return false;

        var ibo = renderer.CreateIndexArray(this.mChunks[i].mIndices, renderer.BUFTYPE.STATIC);
        if (ibo == null)
            return false;

        this.mChunks[i].mVBO = vbo;
        this.mChunks[i].mIBO = ibo;
    }
    return true;
}

piMesh.prototype.GPURender = function (renderer, positions )//, matPrj, matCam )
{
    //renderer.SetShaderConstantMat4F("unMPrj", matPrj, false );

    var num = this.mChunks.length;
    for( var i=0; i<num; i++ )
    {
        //var mat =  matMul( matCam, this.mChunks[i].mTransform );
        //renderer.SetShaderConstantMat4F("unMMod", mat, false);

        renderer.AttachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat, positions );
        renderer.AttachIndexArray(this.mChunks[i].mIBO );
        renderer.DrawPrimitive(renderer.PRIMTYPE.TRIANGLES, this.mChunks[i].mNumFaces * 3, true, 1);
        renderer.DetachIndexArray(this.mChunks[i].mIBO);
        renderer.DetachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat );
    }
}
//==============================================================================
//
// piLibs 2014-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piRenderer
//
//==============================================================================

function piRenderer()
{
    // private members

    var mGL = null;
    var mBindedShader = null;
    var mIs20 = false;
    var mFloat32Textures;
    var mFloat32Filter;
    var mFloat16Textures;
    var mDrawBuffers;
    var mDepthTextures;
    var mDerivatives;
    var mFloat16Filter;
    var mShaderTextureLOD;
    var mAnisotropic;
    var mRenderToFloat32F;
    var mDebugShader;
    var mAsynchCompile;

    var mVBO_Quad = null;
    var mVBO_Tri = null;
    var mVBO_CubePosNor = null;
    var mVBO_CubePos = null;
    var mShaderHeader = ["",""];
    var mShaderHeaderLines = [0,0];

    // public members
    var me = {};

    me.CLEAR      = { Color: 1, Zbuffer : 2, Stencil : 4 };
    me.TEXFMT     = { C4I8 : 0, C1I8 : 1, C1F16 : 2, C4F16 : 3, C1F32 : 4, C4F32 : 5, Z16 : 6, Z24 : 7, Z32 : 8, C3F32:9 };
    me.TEXWRP     = { CLAMP : 0, REPEAT : 1 };
    me.BUFTYPE    = { STATIC : 0, DYNAMIC : 1 };
    me.PRIMTYPE   = { POINTS : 0, LINES : 1, LINE_LOOP : 2, LINE_STRIP : 3, TRIANGLES : 4, TRIANGLE_STRIP : 5 };
    me.RENDSTGATE = { WIREFRAME : 0, FRONT_FACE : 1, CULL_FACE : 2, DEPTH_TEST : 3, ALPHA_TO_COVERAGE : 4 };
    me.TEXTYPE    = { T2D : 0, T3D : 1, CUBEMAP : 2 };
    me.FILTER     = { NONE : 0, LINEAR : 1, MIPMAP : 2, NONE_MIPMAP : 3 };
    me.TYPE       = { UINT8 : 0, UINT16 : 1, UINT32 : 2, FLOAT16: 3, FLOAT32 : 4, FLOAT64: 5 };

    // private functions

    var iFormatPI2GL = function( format )
    {
        if( mIs20 )
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA8,           mGLExternal: mGL.RGBA,             mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.R8,              mGLExternal: mGL.RED,              mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.R16F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA16F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.R32F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA32F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C3F32) return { mGLFormat: mGL.RGB32F,          mGLExternal: mGL.RGB,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT16, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z24)   return { mGLFormat: mGL.DEPTH_COMPONENT24, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z32)   return { mGLFormat: mGL.DEPTH_COMPONENT32F, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        }
        else
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.RED,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT, mGLExternal: mGL.DEPTH_COMPONENT, mGLType: mGL.UNSIGNED_SHORT }
        }

        return null;
     }

    // public functions

    me.Initialize = function( gl )
                    {
                        mGL = gl;

                        mIs20 = !(gl instanceof WebGLRenderingContext);

                        if( mIs20 )
                        {
                            mFloat32Textures  = true;
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = true;
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = true;
                            mDrawBuffers      = true;
                            mDepthTextures    = true;
                            mShaderTextureLOD = true;
                            mAnisotropic = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mGL.getExtension( 'EXT_color_buffer_float');
                            mDebugShader = mGL.getExtension('WEBGL_debug_shaders');
                            mAsynchCompile = mGL.getExtension('KHR_parallel_shader_compile');

							mGL.hint( mGL.FRAGMENT_SHADER_DERIVATIVE_HINT, mGL.NICEST);
                        }
                        else
                        {
                            mFloat32Textures  = mGL.getExtension( 'OES_texture_float' );
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = mGL.getExtension( 'OES_texture_half_float' );
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = mGL.getExtension( 'OES_standard_derivatives' );
                            mDrawBuffers      = mGL.getExtension( 'WEBGL_draw_buffers' );
                            mDepthTextures    = mGL.getExtension( 'WEBGL_depth_texture' );
                            mShaderTextureLOD = mGL.getExtension( 'EXT_shader_texture_lod' );
                            mAnisotropic      = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mFloat32Textures;
                            mDebugShader      = null;
                            mAsynchCompile    = null;
							
							if( mDerivatives !== null) mGL.hint( mDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, mGL.NICEST);
                        }
                        
                        
                        var maxTexSize = mGL.getParameter( mGL.MAX_TEXTURE_SIZE );
                        var maxCubeSize = mGL.getParameter( mGL.MAX_CUBE_MAP_TEXTURE_SIZE );
                        var maxRenderbufferSize = mGL.getParameter( mGL.MAX_RENDERBUFFER_SIZE );
                        var extensions = mGL.getSupportedExtensions();
                        var textureUnits = mGL.getParameter( mGL.MAX_TEXTURE_IMAGE_UNITS );
                        console.log("WebGL (2.0=" + mIs20 + "):" +
                                    " Asynch Compile: "  + ((mAsynchCompile !==null) ? "yes" : "no") +
                                    ", Textures: F32 ["   + ((mFloat32Textures !==null) ? "yes" : "no") +
                                    "], F16 ["   + ((mFloat16Textures !==null) ? "yes" : "no") +
                                    "], Depth [" + ((mDepthTextures   !==null) ? "yes" : "no") +
                                    "], LOD ["    + ((mShaderTextureLOD!==null) ? "yes" : "no") +
                                    "], Aniso ["   + ((mAnisotropic     !==null) ? "yes" : "no") +
                                    "], Units [" + textureUnits +
                                    "], Max Size [" + maxTexSize +
                                    "], Cube Max Size [" + maxCubeSize +
                                    "], Targets: MRT ["            + ((mDrawBuffers     !==null) ? "yes" : "no") +
                                    "], F32 ["     + ((mRenderToFloat32F!==null) ? "yes" : "no") +
                                    "], Max Size [" + maxRenderbufferSize + "]");

                        // create a 2D quad Vertex Buffer
                        var vertices = new Float32Array( [ -1.0, -1.0,   1.0, -1.0,    -1.0,  1.0,     1.0, -1.0,    1.0,  1.0,    -1.0,  1.0] );
                        mVBO_Quad = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                        mGL.bufferData( mGL.ARRAY_BUFFER, vertices, mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 2D triangle Vertex Buffer
                        mVBO_Tri = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0,   3.0, -1.0,    -1.0,  3.0] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePosNor = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0, -1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                               1.0,  1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                               1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                               1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                               1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0,  1.0, -1.0,   0.0,  0.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePos = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0,  1.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        //-------------------------------------------------------------------

                        mShaderHeader[0] = "";
                        mShaderHeaderLines[0] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[0] += "#version 300 es\n" +
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[0] += 6;
                        }
                        else
                        {
                            mShaderHeader[0] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "#endif\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+                                                
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[0] += 26;
                        }

                        //-------------------------------------------------------

                        mShaderHeader[1] = "";
                        mShaderHeaderLines[1] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[1] += "#version 300 es\n"+
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[1] += 6;
                        }
                        else
                        {
                            if( mDerivatives ) { mShaderHeader[1] += "#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n"; mShaderHeaderLines[1]+=3; }
                            if( mShaderTextureLOD  ) { mShaderHeader[1] += "#extension GL_EXT_shader_texture_lod : enable\n"; mShaderHeaderLines[1]++; }
                            mShaderHeader[1] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "#endif\n"+ 
                                                "vec4 texture(     sampler2D   s, vec2 c)                   { return texture2D(s,c); }\n"+
                                                "vec4 texture(     sampler2D   s, vec2 c, float b)          { return texture2D(s,c,b); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c )                  { return textureCube(s,c); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c, float b)          { return textureCube(s,c,b); }\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[1] += 30;
                            if( mShaderTextureLOD )
                            {
                            mShaderHeader[1] += "vec4 textureLod(  sampler2D   s, vec2 c, float b)          { return texture2DLodEXT(s,c,b); }\n";
                            mShaderHeader[1] += "vec4 textureGrad( sampler2D   s, vec2 c, vec2 dx, vec2 dy) { return texture2DGradEXT(s,c,dx,dy); }\n";
                            mShaderHeaderLines[1] += 2;

                            //mShaderHeader[1] += "vec4 texelFetch( sampler2D s, ivec2 c, int l) { return texture2DLodEXT(s,(vec2(c)+0.5)/vec2(800,450),float(l)); }\n";
                            //mShaderHeaderLines[1] += 1;
                            }
                        }

                        return true;
                    };

        me.GetCaps =    function ()
                        {   
                            return { mIsGL20 : mIs20,
                                     mFloat32Textures: mFloat32Textures != null,
                                     mFloat16Textures: mFloat16Textures != null,
                                     mDrawBuffers: mDrawBuffers != null,
                                     mDepthTextures: mDepthTextures != null,
                                     mDerivatives: mDerivatives != null,
                                     mShaderTextureLOD: mShaderTextureLOD != null };
                        };

        me.GetShaderHeaderLines = function (shaderType)
                        {   
                            return mShaderHeaderLines[shaderType];
                        };

        me.CheckErrors = function()
                         {
                                var error = mGL.getError();
                                if( error != mGL.NO_ERROR ) 
                                { 
                                    for( var prop in mGL ) 
                                    {
                                        if( typeof mGL[prop] == 'number' ) 
                                        {
                                            if( mGL[prop] == error )
                                            {
                                                console.log( "GL Error " + error + ": " + prop );
                                                break;
                                            }
                                        }
                                    }
                                }
                         };

        me.Clear =  function( flags, ccolor, cdepth, cstencil )
                    {
                        var mode = 0;
                        if( flags & 1 ) { mode |= mGL.COLOR_BUFFER_BIT;   mGL.clearColor( ccolor[0], ccolor[1], ccolor[2], ccolor[3] ); }
                        if( flags & 2 ) { mode |= mGL.DEPTH_BUFFER_BIT;   mGL.clearDepth( cdepth ); }
                        if( flags & 4 ) { mode |= mGL.STENCIL_BUFFER_BIT; mGL.clearStencil( cstencil ); }
                        mGL.clear( mode );
                    };


        me.CreateTexture = function ( type, xres, yres, format, filter, wrap, buffer)
                           {
                                if( mGL===null ) return null;

                                var id = mGL.createTexture();

                                var glFoTy = iFormatPI2GL( format );
                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                if( type===me.TEXTYPE.T2D )
                                {
                                    mGL.bindTexture( mGL.TEXTURE_2D, id );
//if( buffer==null )
    //mGL.texStorage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres);
//else
                                    mGL.texImage2D( mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap );

                                    if (filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                }
                                else if( type===me.TEXTYPE.T3D )
                                {
                                    if( mIs20 )
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_3D, id );
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_BASE_LEVEL, 0);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAX_LEVEL, Math.log2(xres));
                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_3D);
                                        }
                                        mGL.texImage3D( mGL.TEXTURE_3D, 0, glFoTy.mGLFormat, xres, yres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap );

                                        if (filter === me.FILTER.MIPMAP)
                                            mGL.generateMipmap( mGL.TEXTURE_3D );
                                        mGL.bindTexture( mGL.TEXTURE_3D, null );
                                    }
                                    else 
                                    {
                                        return null;
                                    }
                                }
                                else 
                                {
                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );

                                    // this works great if we know the number of required mipmaps in advance (1, or other)
                                   //mGL.texStorage2D( mGL.TEXTURE_CUBE_MAP, 1, glFoTy.mGLFormat, xres, yres );

                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                    if( filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                    }

                                    if (filter === me.FILTER.MIPMAP)
                                        mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );

                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                }
                        return { mObjectID: id, mXres: xres, mYres: yres, mFormat: format, mType: type, mFilter: filter, mWrap: wrap, mVFlip:false };
                        };

        me.CreateTextureFromImage = function ( type, image, format, filter, wrap, flipY) 
                                {
                                    if( mGL===null ) return null;

                                    var id = mGL.createTexture();

                                    var glFoTy = iFormatPI2GL( format );

                                    var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                    if( type===me.TEXTYPE.T2D )
                                    {
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);

                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.pixelStorei(mGL.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                                        if( mIs20 ) mGL.pixelStorei(mGL.UNPACK_COLORSPACE_CONVERSION_WEBGL, mGL.NONE );

                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);

                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);

                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if( filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                    }
                                    else if( type===me.TEXTYPE.T3D )
                                    {
                                        return null;
                                    }
                                    else 
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );

                                        if( filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                    }
                                    return { mObjectID: id, mXres: image.width, mYres: image.height, mFormat: format, mType: type, mFilter: filter, mWrap:wrap, mVFlip:flipY };
                                };

        me.SetSamplerFilter = function (te, filter, doGenerateMipsIfNeeded) 
                            {
                                if (te.mFilter === filter) return;

                                if (te.mType === me.TEXTYPE.T2D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_3D, null);

                                }
                                else
                                {
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }


                                te.mFilter = filter;
                            };

        me.SetSamplerWrap = function (te, wrap)
                            {
                                if (te.mWrap === wrap) return;

                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, id);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, id);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_3D, null);
                                }

                                te.mWrap = wrap;
                            };

        me.SetSamplerVFlip = function (te, vflip, image)
                            {
                                if (te.mVFlip === vflip) return;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    if( image != null)
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                }
                                else if (te.mType === me.TEXTYPE.CUBEMAP)
                                {
                                    if( image != null)
                                    {
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei( mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
        
                                }

                                te.mVFlip = vflip;
                            };

        me.CreateMipmaps =  function (te)
                            {
                                if( te.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);
                                    mGL.generateMipmap(mGL.TEXTURE_2D);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);
                                }
                                else if( te.mType===me.TEXTYPE.CUBEMAP )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);
                                    mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }
                            };

        me.UpdateTexture =  function( tex, x0, y0, xres, yres, buffer )
                            {
                                var glFoTy = iFormatPI2GL( tex.mFormat );
                                if( tex.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture( mGL.TEXTURE0);
                                    mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                    mGL.texSubImage2D( mGL.TEXTURE_2D, 0, x0, y0, xres, yres, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                }
                            };

        me.UpdateTextureFromImage = function( tex, image )
                                {
                                    var glFoTy = iFormatPI2GL( tex.mFormat );
                                    if( tex.mType===me.TEXTYPE.T2D )
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                        mGL.texImage2D(  mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image );
                                        mGL.bindTexture( mGL.TEXTURE_2D, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                };

        me.DestroyTexture = function( te )
                            {
                                 mGL.deleteTexture( te.mObjectID );
                            };

        me.AttachTextures = function (num, t0, t1, t2, t3) 
                            {
                                if (num > 0 && t0 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                         if (t0.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t0.mObjectID);
                                }

                                if (num > 1 && t1 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE1);
                                         if (t1.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t1.mObjectID);
                                }

                                if (num > 2 && t2 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE2);
                                         if (t2.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t2.mObjectID);
                                }

                                if (num > 3 && t3 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE3);
                                         if (t3.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t3.mObjectID);
                                }
                            };

        me.DettachTextures = function()
                             {
                                mGL.activeTexture(mGL.TEXTURE0);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE1);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE2);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE3);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                             };

        me.CreateRenderTarget = function ( color0, color1, color2, color3, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);

                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_2D, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.DestroyRenderTarget = function ( tex )
                                 {
                                     mGL.deleteFramebuffer(tex.mObjectID);
                                 };

        me.SetRenderTarget = function (tex)
                             {
                                if( tex===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, tex.mObjectID);

                                //mGL.drawBuffers([mGL.COLOR_ATTACHMENT0, mGL.COLOR_ATTACHMENT1]);
                             };

        me.CreateRenderTargetNew = function ( wantColor0, wantZbuffer, xres, yres, samples )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if( wantZbuffer===true )
                                    {
                                        var zb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);

                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.DEPTH_COMPONENT16, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                    }

                                    if( wantColor0 )
                                    {
                                        var cb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, cb);
                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.RGBA8, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.RGBA8, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.RENDERBUFFER, cb);
                                    }

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                    {
                                        return null;
                                    }
                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mXres: xres, mYres:yres, mTex0: color0 };
                                };

        me.CreateRenderTargetCubeMap = function ( color0, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);
                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.SetRenderTargetCubeMap = function (fbo, face)
                             {
                                if( fbo===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                {
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, fbo.mObjectID);
                                    mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X+face, fbo.mTex0.mObjectID, 0);
                                }
                             };


        me.BlitRenderTarget = function( dst, src )
                                {
                                    mGL.bindFramebuffer(mGL.READ_FRAMEBUFFER, src.mObjectID);
                                    mGL.bindFramebuffer(mGL.DRAW_FRAMEBUFFER, dst.mObjectID);
                                    mGL.clearBufferfv(mGL.COLOR, 0, [0.0, 0.0, 0.0, 1.0]);
                                    mGL.blitFramebuffer( 0, 0, src.mXres, src.mYres,
                                                         0, 0, src.mXres, src.mYres,
                                                         mGL.COLOR_BUFFER_BIT, mGL.LINEAR
                                    );
                                };

        me.SetViewport = function( vp )
                         {
                              mGL.viewport( vp[0], vp[1], vp[2], vp[3] );
                         };

        me.SetWriteMask = function( c0, c1, c2, c3, z )
                          {
                              mGL.depthMask(z);
                              mGL.colorMask(c0,c0,c0,c0);
                          };

        me.SetState = function( stateName, stateValue )
                      {
                            if (stateName === me.RENDSTGATE.WIREFRAME)
                            {
                                if( stateValue ) mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.LINE );
                                else             mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.FILL );
                            }
                            else if (stateName === me.RENDSTGATE.FRONT_FACE)
                            {
                                if( stateValue ) mGL.cullFace( mGL.BACK );
                                else             mGL.cullFace( mGL.FRONT );
                            }
                            else if (stateName === me.RENDSTGATE.CULL_FACE)
                            {
                                if( stateValue ) mGL.enable( mGL.CULL_FACE );
                                else             mGL.disable( mGL.CULL_FACE );
                            }
                            else if (stateName === me.RENDSTGATE.DEPTH_TEST)
                            {
                                if( stateValue ) mGL.enable( mGL.DEPTH_TEST );
                                else             mGL.disable( mGL.DEPTH_TEST );
                            }
                            else if (stateName === me.RENDSTGATE.ALPHA_TO_COVERAGE)
                            {
                                if( stateValue ) { mGL.enable(  mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                                else             { mGL.disable( mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                            }
                      };

        me.SetMultisample = function( v)
                    {
                        if( v===true )
                        {
                            mGL.enable(mGL.SAMPLE_COVERAGE);
                            mGL.sampleCoverage(1.0, false);
                        }
                        else
                        {
                            mGL.disable(mGL.SAMPLE_COVERAGE);
                        }
                    };

        me.GetTranslatedShaderSource = function (shader) 
                          {
                            if( mGL===null ) return null;
                            if( mDebugShader===null ) return null;
                            let vfs = mGL.getAttachedShaders(shader.mProgram);
                            let str = mDebugShader.getTranslatedShaderSource(vfs[1]);
                            let parts = str.split("GLSL END"); str = (parts.length<2) ? str : parts[1];
                            return str;
                          };

        me.CreateShader = function (vsSource, fsSource, preventCache, forceSynch, onResolve) 
                          {
                            if( mGL===null ) return;

                            var vs = mGL.createShader( mGL.VERTEX_SHADER   );
                            var fs = mGL.createShader( mGL.FRAGMENT_SHADER );

                            vsSource = mShaderHeader[0] + vsSource;
                            fsSource = mShaderHeader[1] + fsSource;

                            if( preventCache )
                            {
                                let vran = Math.random().toString(36).substring(7);
                                let fran = Math.random().toString(36).substring(7);
                                vsSource += "\n#define K" + vran + "\n";
                                fsSource += "\n#define K" + fran + "\n";
                            }

                            var timeStart = getRealTime();

                            mGL.shaderSource(vs, vsSource);
                            mGL.shaderSource(fs, fsSource);
                            mGL.compileShader(vs);
                            mGL.compileShader(fs);

                            var pr = mGL.createProgram();
                            mGL.attachShader(pr, vs);
                            mGL.attachShader(pr, fs);
                            mGL.linkProgram(pr);

                            //-------------
                            let checkErrors = function()
                            {
                                if (!mGL.getProgramParameter(pr, mGL.LINK_STATUS))
                                {
                                    // vs error
                                    if (!mGL.getShaderParameter(vs, mGL.COMPILE_STATUS))
                                    {
                                        let vsLog = mGL.getShaderInfoLog(vs);
                                        onResolve(false, { mErrorType: 0, mErrorStr: vsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // fs error
                                    else if (!mGL.getShaderParameter(fs, mGL.COMPILE_STATUS))
                                    {
                                        let fsLog = mGL.getShaderInfoLog(fs);
                                        onResolve(false, { mErrorType: 1, mErrorStr: fsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // link error
                                    else
                                    {
                                        let infoLog = mGL.getProgramInfoLog(pr);
                                        onResolve(false, { mErrorType: 2, mErrorStr: infoLog });
                                        mGL.deleteProgram(pr);
                                    }
                                }
                                // no errors
                                else
                                {
                                    let compilationTime = getRealTime() - timeStart;
                                    onResolve(true, { mProgram: pr, mTime: compilationTime });
                                }
                            };

                            // check compilation
                            if (mAsynchCompile === null || forceSynch===true )
                            {
                                checkErrors();
                            }
                            else
                            {
                                let loopCheckCompletion = function ()
                                {
                                    if( mGL.getProgramParameter(pr, mAsynchCompile.COMPLETION_STATUS_KHR) === true )
                                        checkErrors();
                                    else
                                        setTimeout(loopCheckCompletion, 10);
                                };
                                setTimeout(loopCheckCompletion, 10);
                            }
                        };

        me.AttachShader = function( shader )
                          {
                                if( shader===null )
                                {
                                    mBindedShader = null;
                                    mGL.useProgram( null );
                                }
                                else
                                {
                                    mBindedShader = shader;
                                    mGL.useProgram(shader.mProgram);
                                }
                          };

        me.DetachShader = function ()
                        {
                            mGL.useProgram(null);
                        };

        me.DestroyShader = function( tex )
                        {
                            mGL.deleteProgram(tex.mProgram);
                        };

        me.GetAttribLocation = function (shader, name)
                        {
                            return mGL.getAttribLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantLocation = function (shader, name)
                        {
                            return mGL.getUniformLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantMat4F = function( uname, params, istranspose )
                        {
                            var program = mBindedShader;

                            let pos = mGL.getUniformLocation( program.mProgram, uname );
                            if( pos===null )
                                return false;

                            if( istranspose===false )
                            {
                                var tmp = new Float32Array( [ params[0], params[4], params[ 8], params[12],
                                                              params[1], params[5], params[ 9], params[13],
                                                              params[2], params[6], params[10], params[14],
                                                              params[3], params[7], params[11], params[15] ] );
	                            mGL.uniformMatrix4fv(pos,false,tmp);
                            }
                            else
                                mGL.uniformMatrix4fv(pos,false,new Float32Array(params) );
                            return true;
                        };

        me.SetShaderConstant1F_Pos = function(pos, x)
                        {
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1FV_Pos = function(pos, x)
                        {
                            mGL.uniform1fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant1F = function( uname, x )
                        {
                            var pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1I = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1i(pos, x);
                            return true;
                        };
        me.SetShaderConstant1I_Pos = function(pos, x)
                        {
                            mGL.uniform1i(pos, x);
                            return true;
                        };


        me.SetShaderConstant2F = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform2fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant3F = function(uname, x, y, z)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform3f(pos, x, y, z);
                            return true;
                        };

        me.SetShaderConstant1FV = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1fv(pos, new Float32Array(x));
                            return true;
                        };

        me.SetShaderConstant3FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform3fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderConstant4FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform4fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderTextureUnit = function( uname, unit )
                        {
                            var program = mBindedShader;
                            let pos = mGL.getUniformLocation(program.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform1i(pos, unit);
                            return true;
                        };

        me.CreateVertexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, id);
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.CreateIndexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, id );
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.DestroyArray = function( tex )
                        {
                            mGL.destroyBuffer(tex.mObject);
                        };

        me.AttachVertexArray = function( tex, attribs, pos )
                        {
                            let shader = mBindedShader;

                            mGL.bindBuffer( mGL.ARRAY_BUFFER, tex.mObject);

                            var num = attribs.mChannels.length;
                            var stride = attribs.mStride;

                            var offset = 0;
                            for (var i = 0; i < num; i++)
                            {
                                var id = pos[i];
                                mGL.enableVertexAttribArray(id);
                                var dtype = mGL.FLOAT;
                                var dsize = 4;
                                     if( attribs.mChannels[i].mType === me.TYPE.UINT8   ) { dtype = mGL.UNSIGNED_BYTE;  dsize = 1; }
                                else if( attribs.mChannels[i].mType === me.TYPE.UINT16  ) { dtype = mGL.UNSIGNED_SHORT; dsize = 2; }
                                else if( attribs.mChannels[i].mType === me.TYPE.FLOAT32 ) { dtype = mGL.FLOAT;          dsize = 4; }
                                mGL.vertexAttribPointer(id, attribs.mChannels[i].mNumComponents, dtype, attribs.mChannels[i].mNormalize, stride, offset);
                                offset += attribs.mChannels[i].mNumComponents * dsize;
                            }
                        };

        me.AttachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, tex.mObject);
                        };

        me.DetachVertexArray = function (tex, attribs)
                        {
                            let num = attribs.mChannels.length;
                            for (let i = 0; i < num; i++)
                                mGL.disableVertexAttribArray(i);
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, null);
                        };

        me.DetachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, null);
                        };

        me.DrawPrimitive = function( typeOfPrimitive, num, useIndexArray, numInstances )
                        {
                            let glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.POINTS ) glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.LINES ) glType = mGL.LINES;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_LOOP ) glType = mGL.LINE_LOOP;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_STRIP ) glType = mGL.LINE_STRIP;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLES ) glType = mGL.TRIANGLES;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLE_STRIP ) glType = mGL.TRIANGLE_STRIP;

                            if( numInstances<=1 )
                            {
  	                            if( useIndexArray ) mGL.drawElements( glType, num, mGL.UNSIGNED_SHORT, 0 );
	                            else                mGL.drawArrays( glType, 0, num );
                            }
                            else
                            {
                                mGL.drawArraysInstanced(glType, 0, num, numInstances);
                                mGL.drawElementsInstanced( glType, num, mGL.UNSIGNED_SHORT, 0, numInstances);
                            }
                        };


        me.DrawFullScreenTriangle_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 3 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };


        me.DrawUnitQuad_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 6 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };

        me.DrawUnitCube_XYZ_NOR = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                            mGL.vertexAttribPointer( vpos[0], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.vertexAttribPointer( vpos[1], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos[0] );
                            mGL.enableVertexAttribArray( vpos[1] );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos[0] );
                            mGL.disableVertexAttribArray( vpos[1] );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.DrawUnitCube_XYZ = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                            mGL.vertexAttribPointer( vpos, 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.SetBlend = function( enabled )
                    {
                        if( enabled )
                        {
                            mGL.enable( mGL.BLEND );
                            mGL.blendEquationSeparate( mGL.FUNC_ADD, mGL.FUNC_ADD );
                            mGL.blendFuncSeparate( mGL.SRC_ALPHA, mGL.ONE_MINUS_SRC_ALPHA, mGL.ONE, mGL.ONE_MINUS_SRC_ALPHA );
                        }
                        else
                        {
                            mGL.disable( mGL.BLEND );
                        }
                    };

        me.GetPixelData = function( data, offset, xres, yres )
                        {
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.UNSIGNED_BYTE, data, offset);
                        };

        me.GetPixelDataRenderTarget = function( obj, data, xres, yres )
                        {
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, obj.mObjectID);
                            mGL.readBuffer(mGL.COLOR_ATTACHMENT0);
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.FLOAT, data, 0);
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                        };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piShading
//
//==============================================================================

function smoothstep(a, b, x)
{
    x = (x - a) / (b - a);
    if (x < 0) x = 0; else if (x > 1) x = 1;
    return x * x * (3.0 - 2.0 * x);
}

function clamp01(x)
{
    if( x < 0.0 ) x = 0.0;
    if( x > 1.0 ) x = 1.0;
    return x;
}

function clamp(x, a, b)
{
    if( x < a ) x = a;
    if( x > b ) x = b;
    return x;
}

function screen(a, b)
{
    return 1.0 - (1.0 - a) * (1.0 - b);
}

function parabola(x)
{
    return 4.0 * x * (1.0 - x);
}

function min(a, b)
{
    return (a < b) ? a : b;
}

function max(a, b)
{
    return (a > b) ? a : b;
}

function noise( x )
{
    function grad(i, j, x, y)
    {
        var h = 7 * i + 131 * j;
        h = (h << 13) ^ h;
        h = (h * (h * h * 15731 + 789221) + 1376312589);

        var rx = (h & 0x20000000) ? x : -x;
        var ry = (h & 0x10000000) ? y : -y;

        return rx + ry;
    }

    var i = [ Math.floor(x[0]), Math.floor(x[1]) ];
    var f = [ x[0] - i[0], x[1] - i[1] ];
    var w = [ f[0]*f[0]*(3.0-2.0*f[0]), f[1]*f[1]*(3.0-2.0*f[1]) ];

    var a = grad( i[0]+0, i[1]+0, f[0]+0.0, f[1]+0.0 );
    var b = grad( i[0]+1, i[1]+0, f[0]-1.0, f[1]+0.0 );
    var c = grad( i[0]+0, i[1]+1, f[0]+0.0, f[1]-1.0 );
    var d = grad( i[0]+1, i[1]+1, f[0]-1.0, f[1]-1.0 );

    return a + (b-a)*w[0] + (c-a)*w[1] + (a-b-c+d)*w[0]*w[1];
}//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piVecTypes
//
//==============================================================================


function vec3( a, b, c )
{
    return [ a, b, c ];
}

function add( a, b )
{
    return [ a[0]+b[0], a[1]+b[1], a[2]+b[2] ];
}

function sub( a, b )
{
    return [ a[0]-b[0], a[1]-b[1], a[2]-b[2] ];
}

function mul( a, s ) 
{
    return [ a[0]*s, a[1]*s, a[2]*s ];
}

function cross( a, b )
{
    return [ a[1]*b[2] - a[2]*b[1],
             a[2]*b[0] - a[0]*b[2],
             a[0]*b[1] - a[1]*b[0] ];
}

function dot( a, b ) 
{
    return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
}

function normalize( v ) 
{
    var is = 1.0 / Math.sqrt( v[0]*v[0] + v[1]*v[1] + v[2]*v[2] );
    return [ v[0]*is, v[1]*is, v[2]*is ];
}

function createCirclePoint( cen, uuu, vvv, rad, s, t )
{
    return [ cen[0] + rad*(uuu[0]*s + vvv[0]*t),
             cen[1] + rad*(uuu[1]*s + vvv[1]*t),
             cen[2] + rad*(uuu[2]*s + vvv[2]*t) ];
}

function createTangent( a, b, c )
{
    var cb = normalize( [ c[0]-b[0], c[1]-b[1], c[2]-b[2] ] );
    var ba = normalize( [ b[0]-a[0], b[1]-a[1], b[2]-a[2] ] );
    return normalize( [ ba[0]+cb[0], ba[1]+cb[1], ba[2]+cb[2] ] );

}

//===================================

function vec4( a, b, c, d )
{
    return [ a, b, c, d ];
}

function getXYZ( v )
{
    return [ v[0], v[1], v[2] ];
}

//===================================

function setIdentity()
{
    return [ 1.0, 0.0, 0.0, 0.0,
             0.0, 1.0, 0.0, 0.0,
             0.0, 0.0, 1.0, 0.0,
             0.0, 0.0, 0.0, 1.0 ];
}

function setRotationX( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ 1.0,   0.0,   0.0, 0.0,
             0.0,  cost, -sint, 0.0, 
             0.0,  sint,  cost, 0.0,
             0.0,   0.0,   0.0, 1.0 ];
}

function setRotationY( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ cost, 0.0, -sint, 0.0,
              0.0, 1.0,   0.0, 0.0, 
             sint, 0.0,  cost, 0.0,
              0.0, 0.0,   0.0, 1.0 ];
}

function extractRotationEuler( m)
{
    var res = [];
    if (m[0] == 1.0)
    {
        res[0] = Math.atan2(m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;

    }
    else if (m[0] == -1.0)
    {
        res[0] = Math.atan2( m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;
    }
    else
    {
        res[0] = Math.atan2( -m[9], m[10]);
        res[1] = Math.atan2( m[8], Math.sqrt(m[9]*m[9] + m[10]*m[10]));
        res[2] = Math.atan2( m[4], m[0]);
    }
    return res;
}

function setFromQuaternion( q )
{
    var ww = q[3]*q[3];
    var xx = q[0]*q[0];
    var yy = q[1]*q[1];
    var zz = q[2]*q[2];

    return [ ww+xx-yy-zz,                   2.0*(q[0]*q[1] - q[3]*q[2]), 2.0*(q[0]*q[2] + q[3]*q[1]), 0.0,
               2.0*(q[0]*q[1] + q[3]*q[2]),   ww-xx+yy-zz,                 2.0*(q[1]*q[2] - q[3]*q[0]), 0.0,
               2.0*(q[0]*q[2] - q[3]*q[1]),   2.0*(q[1]*q[2] + q[3]*q[0]), ww-xx-yy+zz,                 0.0,
               0.0,                           0.0,                         0.0,                         1.0 ];
}

function setPerspective( fovy, aspect, znear, zfar )
{
    var tan = Math.tan(fovy * Math.PI/180.0);
    var x = 1.0 / (tan*aspect);
    var y = 1.0 / (tan);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0 * zfar * znear) / (zfar - znear);

    return [ x,    0.0,  0.0,  0.0,
             0.0,  y,    0.0,  0.0,
             0.0,  0.0,  c,     d,
             0.0,  0.0, -1.0,  0.0 ];
}

function setLookAt( eye, tar, up )
{
    var dir = [ -tar[0]+eye[0], -tar[1]+eye[1], -tar[2]+eye[2] ];

	var m00 = dir[2]*up[1] - dir[1]*up[2]; 
    var m01 = dir[0]*up[2] - dir[2]*up[0];
    var m02 = dir[1]*up[0] - dir[0]*up[1];
    var im = 1.0/Math.sqrt( m00*m00 + m01*m01 + m02*m02 );
    m00 *= im;
    m01 *= im;
    m02 *= im;

	var m04 = m02*dir[1] - m01*dir[2]; 
    var m05 = m00*dir[2] - m02*dir[0];
    var m06 = m01*dir[0] - m00*dir[1];
    im = 1.0/Math.sqrt( m04*m04 + m05*m05 + m06*m06 );
    m04 *= im;
    m05 *= im;
    m06 *= im;

	var m08 = dir[0];
	var m09 = dir[1];
	var m10 = dir[2];
    im = 1.0/Math.sqrt( m08*m08 + m09*m09 + m10*m10 );
    m08 *= im;
    m09 *= im;
    m10 *= im;

	var m03 = -(m00*eye[0] + m01*eye[1] + m02*eye[2] );
	var m07 = -(m04*eye[0] + m05*eye[1] + m06*eye[2] );
	var m11 = -(m08*eye[0] + m09*eye[1] + m10*eye[2] );

    return [ m00, m01, m02, m03,
             m04, m05, m06, m07,
             m08, m09, m10, m11,
             0.0, 0.0, 0.0, 1.0 ];
}


function setOrtho( left, right, bottom, top, znear, zfar )
{
   var x = 2.0 / (right - left);
   var y = 2.0 / (top - bottom);
   var a = (right + left) / (right - left);
   var b = (top + bottom) / (top - bottom);
   var c = -2.0 / (zfar - znear);
   var d = -(zfar + znear) / ( zfar - znear);

   return [  x, 0.0, 0.0,   a,
           0.0,   y, 0.0,   b,
           0.0, 0.0,   c,   d,
           0.0, 0.0, 0.0, 1.0 ];
}

function setTranslation( p )
{
    return [ 1.0, 0.0, 0.0, p[0],
             0.0, 1.0, 0.0, p[1],
             0.0, 0.0, 1.0, p[2],
             0.0, 0.0, 0.0, 1.0 ];
}

function setScale( s )
{
    return [ s[0], 0.0,  0.0,  0.0,
             0.0,  s[1], 0.0,  0.0,
             0.0,  0.0,  s[2], 0.0,
             0.0,  0.0,  0.0,  1.0];
}

function setProjection( fov, znear, zfar )
{
    var x = 2.0 / (fov[3]+fov[2]);
    var y = 2.0 / (fov[0]+fov[1]);
    var a = (fov[3]-fov[2]) / (fov[3]+fov[2]);
    var b = (fov[0]-fov[1]) / (fov[0]+fov[1]);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0*zfar*znear) / (zfar - znear);
    return [   x, 0.0,    a, 0.0,
             0.0,   y,    b, 0.0,
             0.0, 0.0,    c,   d,
             0.0, 0.0, -1.0, 0.0 ];
   // inverse is:
   //return mat4x4( 1.0/x, 0.0f,  0.0f,   a/x,
   //               0.0f,  1.0/y, 0.0f,   b/x,
   //               0.0f,  0.0f,  0.0f,   -1.0,
   //               0.0f,  0.0f,  1.0f/d, c/d );
}


function invertFast( m )
{
    var inv = [
   
             m[5]  * m[10] * m[15] - 
             m[5]  * m[11] * m[14] - 
             m[9]  * m[6]  * m[15] + 
             m[9]  * m[7]  * m[14] +
             m[13] * m[6]  * m[11] - 
             m[13] * m[7]  * m[10],

             -m[1]  * m[10] * m[15] + 
              m[1]  * m[11] * m[14] + 
              m[9]  * m[2] * m[15] - 
              m[9]  * m[3] * m[14] - 
              m[13] * m[2] * m[11] + 
              m[13] * m[3] * m[10],

             m[1]  * m[6] * m[15] - 
             m[1]  * m[7] * m[14] - 
             m[5]  * m[2] * m[15] + 
             m[5]  * m[3] * m[14] + 
             m[13] * m[2] * m[7] - 
             m[13] * m[3] * m[6],

             -m[1] * m[6] * m[11] + 
              m[1] * m[7] * m[10] + 
              m[5] * m[2] * m[11] - 
              m[5] * m[3] * m[10] - 
              m[9] * m[2] * m[7] + 
              m[9] * m[3] * m[6],

             -m[4]  * m[10] * m[15] + 
              m[4]  * m[11] * m[14] + 
              m[8]  * m[6]  * m[15] - 
              m[8]  * m[7]  * m[14] - 
              m[12] * m[6]  * m[11] + 
              m[12] * m[7]  * m[10],

             m[0]  * m[10] * m[15] - 
             m[0]  * m[11] * m[14] - 
             m[8]  * m[2] * m[15] + 
             m[8]  * m[3] * m[14] + 
             m[12] * m[2] * m[11] - 
             m[12] * m[3] * m[10],

             -m[0]  * m[6] * m[15] + 
              m[0]  * m[7] * m[14] + 
              m[4]  * m[2] * m[15] - 
              m[4]  * m[3] * m[14] - 
              m[12] * m[2] * m[7] + 
              m[12] * m[3] * m[6],


             m[0] * m[6] * m[11] - 
             m[0] * m[7] * m[10] - 
             m[4] * m[2] * m[11] + 
             m[4] * m[3] * m[10] + 
             m[8] * m[2] * m[7] - 
             m[8] * m[3] * m[6],


             m[4]  * m[9] * m[15] - 
             m[4]  * m[11] * m[13] - 
             m[8]  * m[5] * m[15] + 
             m[8]  * m[7] * m[13] + 
             m[12] * m[5] * m[11] - 
             m[12] * m[7] * m[9],



             -m[0]  * m[9] * m[15] + 
              m[0]  * m[11] * m[13] + 
              m[8]  * m[1] * m[15] - 
              m[8]  * m[3] * m[13] - 
              m[12] * m[1] * m[11] + 
              m[12] * m[3] * m[9],

              m[0]  * m[5] * m[15] - 
              m[0]  * m[7] * m[13] - 
              m[4]  * m[1] * m[15] + 
              m[4]  * m[3] * m[13] + 
              m[12] * m[1] * m[7] - 
              m[12] * m[3] * m[5],

              -m[0] * m[5] * m[11] + 
               m[0] * m[7] * m[9] + 
               m[4] * m[1] * m[11] - 
               m[4] * m[3] * m[9] - 
               m[8] * m[1] * m[7] + 
               m[8] * m[3] * m[5],

              -m[4]  * m[9] * m[14] + 
               m[4]  * m[10] * m[13] +
               m[8]  * m[5] * m[14] - 
               m[8]  * m[6] * m[13] - 
               m[12] * m[5] * m[10] + 
               m[12] * m[6] * m[9],

              m[0]  * m[9] * m[14] - 
              m[0]  * m[10] * m[13] - 
              m[8]  * m[1] * m[14] + 
              m[8]  * m[2] * m[13] + 
              m[12] * m[1] * m[10] - 
              m[12] * m[2] * m[9],

              -m[0]  * m[5] * m[14] + 
               m[0]  * m[6] * m[13] + 
               m[4]  * m[1] * m[14] - 
               m[4]  * m[2] * m[13] - 
               m[12] * m[1] * m[6] + 
               m[12] * m[2] * m[5],

              m[0] * m[5] * m[10] - 
              m[0] * m[6] * m[9] - 
              m[4] * m[1] * m[10] + 
              m[4] * m[2] * m[9] + 
              m[8] * m[1] * m[6] - 
              m[8] * m[2] * m[5] ];

    var det = m[0] * inv[0] + m[1] * inv[4] + m[2] * inv[8] + m[3] * inv[12];

    det = 1.0/det;

    for( var i = 0; i<16; i++ ) inv[i] = inv[i] * det;

    return inv;
}

function matMul( a, b )
{
    var res = [];
    for( var i=0; i<4; i++ )
    {
        var x = a[4*i+0];
        var y = a[4*i+1];
        var z = a[4*i+2];
        var w = a[4*i+3];

        res[4*i+0] = x * b[ 0] + y * b[ 4] + z * b[ 8] + w * b[12];
        res[4*i+1] = x * b[ 1] + y * b[ 5] + z * b[ 9] + w * b[13];
        res[4*i+2] = x * b[ 2] + y * b[ 6] + z * b[10] + w * b[14];
        res[4*i+3] = x * b[ 3] + y * b[ 7] + z * b[11] + w * b[15];
    }

    return res;
}

function matMulpoint( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2] + m[ 3],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2] + m[ 7],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] + m[11] ];
}

function matMulvec( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] ];
}


function bound3( infi )
{
    return [ infi, -infi, infi, -infi, infi, -infi ];
}

function bound3_include( a, p )
{
    return [
        (p[0]<a[0]) ? p[0] : a[0],
        (p[0]>a[1]) ? p[0] : a[1],
        (p[1]<a[2]) ? p[1] : a[2],
        (p[1]>a[3]) ? p[1] : a[3],
        (p[2]<a[4]) ? p[2] : a[4],
        (p[2]>a[5]) ? p[2] : a[5] ];
}

function bound3_center( b )
{
    return [ 0.5*(b[0]+b[1]),
             0.5*(b[2]+b[3]),
             0.5*(b[4]+b[5]) ];
}

function bound3_radius( b )
{
    return [ 0.5*(b[1]-b[0]),
             0.5*(b[3]-b[2]),
             0.5*(b[5]-b[4]) ];
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebVR
//
//==============================================================================

function WebVR( isVREnabledCallback, canvasElement )
{
    isVREnabledCallback(false);
    /*


    this.mSupportVR = false;
    this.mHMD = null;

    var me = this;
    var listVRDisplays = function (vrdevs) {
        for (var i = 0; i < vrdevs.length; i++)
        {
            if (vrdevs[i] instanceof VRDisplay)
            {
                me.mHMD = vrdevs[i];
                console.log("WebVR is available.");
                console.log(me.mHMD);
                break;
            }
        }

        isVREnabledCallback(true);
        me.mSupportVR = true;
    }

    if (navigator.getVRDisplays)
    {
        navigator.getVRDisplays().then(listVRDisplays);
    }

    isVREnabledCallback(false);
    this.mCanvas = canvasElement;
    */
}

WebVR.prototype.IsSupported = function()
{
    return false;
    //return this.mSupportVR;
}

WebVR.prototype.GetData = function( id )
{
    return {};
    /*
    var frameData = new VRFrameData();
    var s = this.mHMD.getFrameData(frameData);
    var ss = frameData.pose;
    
    var fovL = this.mHMD.getEyeParameters("left");
    var fovR = this.mHMD.getEyeParameters( "right" );

    // camera info
    var cPos = vec3(0.0, 0.0, 0.0);
    if (ss.position)
        cPos = vec3(-ss.position[0], -ss.position[1], -ss.position[2]);
    var rot = vec4(0.0, 0.0, 0.0, 0.0);
    if (ss.orientation)
        rot = vec4(ss.orientation[0], ss.orientation[1], ss.orientation[2], ss.orientation[3]);
    var cRot = setFromQuaternion(rot);
    var cTra = setTranslation(cPos);
    var cMat = matMul(invertFast(cRot), cTra);
    
    // per eye info
    var lTra = setTranslation( vec3(-fovL.offset[0], -fovL.offset[1], -fovL.offset[2]) );
    var lMat = matMul(lTra, cMat);
    var lPrj = [ Math.tan( fovL.fieldOfView.upDegrees * Math.PI/180.0),
                 Math.tan(fovL.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.rightDegrees * Math.PI / 180.0)];

    var rTra = setTranslation(vec3(-fovR.offset[0], -fovR.offset[1], -fovR.offset[2]));
    var rMat = matMul(rTra, cMat);
    var rPrj = [Math.tan(fovR.fieldOfView.upDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.rightDegrees * Math.PI / 180.0)];

    return {
        mCamera   : { mCamera: cMat },
        mLeftEye  : { mVP:[0,0,fovL.renderWidth,fovL.renderHeight], mProjection:lPrj, mCamera:lMat },
        mRightEye : { mVP:[fovR.renderWidth/2,0,fovR.renderWidth,fovR.renderHeight], mProjection:rPrj, mCamera:rMat }
           };
    */
}

WebVR.prototype.Enable = function( id )
{
    /*
    this.mHMD.requestPresent([{ source: this.mCanvas }]).then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : requestPresent failed.");
        }
    );
    */
}

WebVR.prototype.Disable = function( id )
{
    /*
    if (!this.mHMD.isPresenting)
    {
        return;
    }

    this.mHMD.exitPresent().then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : exitPresent failed.");
        }
    );
    */
}

WebVR.prototype.RequestAnimationFrame = function (id)
{
    //this.mHMD.requestAnimationFrame(id);
}

WebVR.prototype.IsPresenting = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        return true;
    }
    */
    return false;
}

WebVR.prototype.Finish = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        this.mHMD.submitFrame();
    }
    */
}

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebUtils
//
//==============================================================================


// RequestAnimationFrame
window.requestAnimFrame = ( function () { return window.requestAnimationFrame    || window.webkitRequestAnimationFrame ||
                                                 window.mozRequestAnimationFrame || window.oRequestAnimationFrame ||
                                                 window.msRequestAnimationFrame  || function( cb ) { window.setTimeout(cb,1000/60); };
                                        } )();

// performance.now
window.getRealTime = ( function() { if ("performance" in window ) return function() { return window.performance.now(); }
                                                                  return function() { return (new Date()).getTime(); }
                                  } )();

window.URL = window.URL || window.webkitURL;

navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;

function htmlEntities(str) 
{
    return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g,'&apos;');
}

function piDisableTouch()
{
    document.body.addEventListener('touchstart', function(e){ e.preventDefault(); });
}

var piGetTime = function ( timestamp )
{
    if (timestamp == 0)
        return "";
    return new Date(timestamp * 1000).toISOString().substr(0, 10);
}

function piGetCoords( obj )
{
    var x = 0;
    var y = 0; 
    do
    {
         x += obj.offsetLeft;
         y += obj.offsetTop;
    }while( obj = obj.offsetParent );

    return { mX:x, mY:y };
}

function piGetMouseCoords( ev, canvasElement )
{
    var pos = piGetCoords(canvasElement );
    var mcx =                        (ev.pageX - pos.mX) * canvasElement.width / canvasElement.offsetWidth;
    var mcy = canvasElement.height - (ev.pageY - pos.mY) * canvasElement.height / canvasElement.offsetHeight;

    return { mX: mcx, mY: mcy };

}

function piGetSourceElement( e )
{
    var ele = null;
    if( e.target )     ele = e.target;
    if( e.srcElement ) ele = e.srcElement;
    return ele;
}

function piRequestFullScreen( ele )
{
    if( ele==null ) ele =   document.documentElement;
         if( ele.requestFullscreen       ) ele.requestFullscreen();
    else if( ele.msRequestFullscreen     ) ele.msRequestFullscreen();
    else if( ele.mozRequestFullScreen    ) ele.mozRequestFullScreen();
    else if( ele.webkitRequestFullscreen ) ele.webkitRequestFullscreen( Element.ALLOW_KEYBOARD_INPUT );
}

function piIsFullScreen()
{
    return document.fullscreen || document.mozFullScreen || document.webkitIsFullScreen || document.msFullscreenElement || false;
}

function piExitFullScreen()
{
       if( document.exitFullscreen       ) document.exitFullscreen();
  else if( document.msExitFullscreen     ) document.msExitFullscreen();
  else if( document.mozCancelFullScreen  ) document.mozCancelFullScreen();
  else if( document.webkitExitFullscreen ) document.webkitExitFullscreen();
}

function piIsMobile()
{
    return (navigator.userAgent.match(/Android/i) ||
            navigator.userAgent.match(/webOS/i) ||
            navigator.userAgent.match(/iPhone/i) ||
            navigator.userAgent.match(/iPad/i) ||
            navigator.userAgent.match(/iPod/i) ||
            navigator.userAgent.match(/BlackBerry/i) ||
            navigator.userAgent.match(/Windows Phone/i)) ? true : false;
}

function piCreateGlContext( cv, useAlpha, useDepth, usePreserveBuffer, useSupersampling )
{
    var opts = { alpha: useAlpha, 
                 depth: useDepth, 
                 stencil: false, 
                 premultipliedAlpha: false, 
                 antialias: useSupersampling, 
                 preserveDrawingBuffer: usePreserveBuffer, 
                 powerPreference: "high-performance" }; // "low_power", "high_performance", "default"

    var gl = null;
    if( gl === null) gl = cv.getContext( "webgl2", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl2", opts );
    if( gl === null) gl = cv.getContext( "webgl", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl", opts );

    return gl;
}

function piCreateAudioContext()
{
    var res = null;
    try
    {
        if( window.AudioContext ) res = new AudioContext();
        if( res==null && window.webkitAudioContext ) res = new webkitAudioContext();
    }
    catch( e )
    {
        res = null;
    }
    return res;
}

function piHexColorToRGB(str) // "#ff3041"
{
    var rgb = parseInt(str.slice(1), 16);
    var r = (rgb >> 16) & 255;
    var g = (rgb >> 8) & 255;
    var b = (rgb >> 0) & 255;
    return [r, g, b];
}

function piCreateFPSCounter()
{
    var mFrame;
    var mTo;
    var mFPS;

    var iReset = function( time )
    {
        mFrame = 0;
        mTo = time;
        mFPS = 60.0;
    }

    var iCount = function( time )
    {
        mFrame++;

        if( (time-mTo)>500.0 )
        {
            mFPS = 1000.0*mFrame/(time-mTo);
            mFrame = 0;
            mTo = time;
            return true;
        }
        return false;
    }

    var iGetFPS = function()
    {
        return mFPS;
    }
    
    return { Reset : iReset, Count : iCount, GetFPS : iGetFPS };
}

function piCanMediaRecorded(canvas)
{
    if (typeof window.MediaRecorder !== 'function' || typeof canvas.captureStream !== 'function') {
        return false;
    }
    return true;
}

function piCreateMediaRecorder(isRecordingCallback, canvas) 
{
    if (piCanMediaRecorded(canvas) == false)
    {
        return null;
    }
    
    var options = { audioBitsPerSecond : 0, videoBitsPerSecond : 8000000 }; 
	     if (MediaRecorder.isTypeSupported('video/webm;codecs=h264')) options.mimeType = 'video/webm;codecs=h264';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9' )) options.mimeType = 'video/webm;codecs=vp9';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8' )) options.mimeType = 'video/webm;codecs=vp8';
    else                                                              options.mimeType = 'video/webm;';

    var mediaRecorder = new MediaRecorder(canvas.captureStream(), options);
    var chunks = [];
    
    mediaRecorder.ondataavailable = function(e) 
    {
        if (e.data.size > 0) 
        {
            chunks.push(e.data);
        }
    };
 
    mediaRecorder.onstart = function(){ 
        isRecordingCallback( true );
    };
    
    mediaRecorder.onstop = function()
    {
         isRecordingCallback( false );
         let blob     = new Blob(chunks, {type: "video/webm"});
         chunks       = [];
         let videoURL = window.URL.createObjectURL(blob);
         let url      = window.URL.createObjectURL(blob);
         let a        = document.createElement("a");
         document.body.appendChild(a);
         a.style      = "display: none";
         a.href       = url;
         a.download   = "capture.webm";
         a.click();
         window.URL.revokeObjectURL(url);
     };
    
    return mediaRecorder;
}

function piExportToEXR(width, height, numComponents, type, bytes)
{
    var bytesPerComponent = 0;
    if      (type=="Uint")   bytesPerComponent = 4; 
    else if (type=="Half")   bytesPerComponent = 2;
    else if (type=="Float")  bytesPerComponent = 4;

    var tHeader = 258 + (18 * numComponents + 1);
    var tTable = 8 * height;
    var tScanlines = height * (4 + 4 + (numComponents * bytesPerComponent * width));
    var tTotal = tHeader + tTable + tScanlines;

    //console.log("    header size = " + tHeader);
    //console.log("    table size = " + tTable);
    //console.log("    scanlines size = " + tScanlines);
    //console.log("    total = " + tTotal);

    var buffer = new ArrayBuffer(tTotal); 
    var data = new DataView(buffer);

    // Header
    {
        // Header : 4 bytes -> 0x76, 0x2f, 0x31, 0x01
        var c = 0;
        data.setUint8 (c++, 0x76);
        data.setUint8 (c++, 0x2f);
        data.setUint8 (c++, 0x31);
        data.setUint8 (c++, 0x01);

        // Version : 4 bytes -> 2, 0, 0, 0
        data.setUint8 (c++, 0x02);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        
        // Write channel info
        // Write attribute name : "channels"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x73);
            data.setUint8 (c++, 0x0);

            // Write attribute type : "chlist"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : 18 x 3 + 1 = 55
            var attribSize = 18 * numComponents + 1;
            data.setUint8 (c++, attribSize); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            var i;
            for (i = 0; i < numComponents; i++)
            {
                // Attribute : "B" (42) "G" (47) "R" (52)
                if (i==0)       data.setUint8 (c++, 0x42);
                else if (i==1)  data.setUint8 (c++, 0x47);
                else if (i==2)  data.setUint8 (c++, 0x52);
                data.setUint8 (c++, 0x00);
                
                // Value : Float (2), Half (1), Uint (0)
                if      (type=="Uint")   data.setUint8 (c++, 0x00); 
                else if (type=="Half")   data.setUint8 (c++, 0x01);
                else if (type=="Float")  data.setUint8 (c++, 0x02);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);

                // Plinear
                data.setUint8 (c++, 0x01);

                // Reserved
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 

                // X sampling
                data.setUint8 (c++, 0x01); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                
                // Y sampling
                data.setUint8 (c++, 0x01);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
            }
            // End attribute
            data.setUint8 (c++, 0x00);
    
        // Write attribute name : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute type : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : "1"
            data.setUint8 (c++, 0x01); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // Write attribute value : "0" (None)
            data.setUint8 (c++, 0x00);

        // datawindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00); 

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00);

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 

            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // displayWindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x79); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00);

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00); 

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // size
            data.setUint8 (c++, 0x01);
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);
            
            // value 
            data.setUint8 (c++, 0x00);

        // PixelAspectRatio
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x41); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x52); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x00); 

            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);
        
            // size 4
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 1.0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);
        
        // screenWindowCenter
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63);
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x43); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e);
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00);

            // v2f
            data.setUint8 (c++, 0x76); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x00);

            // size 8
            data.setUint8 (c++, 0x08); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

        // screenWindowWidth
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x00); 
            
            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00); 

            // size
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);

            // value
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);

        // End of header
        data.setUint8 (c++, 0x00);
    }
    //console.log("header size = " + c);

    // Scanline table
    var initc = c + height * 8;
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        var jump = initc + scanline * (8 + width * bytesPerComponent * numComponents); 
        data.setUint32 (c, jump, true);
        c += 4; 

        data.setUint32 (c, 0x00, true);
        c += 4;
    }
    //console.log("header + scanlines table size = " + c);

    // Scanlines
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        // Scanline
        data.setUint32(c, scanline, true);
        c += 4;

        // size 24
        var size = width * numComponents * bytesPerComponent; 
        data.setUint32(c, size, true);
        c += 4;

        var numComponentsSource = 4; // number of components in the SOURCE image
        for (var component = 0; component < numComponents ; component ++) 
        {
            for (var pixel = 0 ; pixel < width ; pixel ++) 
            {
                // flip vertical, so we read OpenGL buffers without JS image flipping
                var v = bytes[(height-1-scanline) * width *numComponentsSource + pixel * numComponentsSource + (2-component)];
                if      (type=="Float") data.setFloat32(c, v, true);
                else if (type=="Half")  data.setUint16(c, v, true);

                c += bytesPerComponent;
            }
        }
    }
    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}


function piExportToWAV(numSamples, rate, bits, numChannels, words)
{
    let numBytes = numSamples * numChannels * bits/8;

    let buffer = new ArrayBuffer(44 + numBytes); 
    let data = new DataView(buffer);

    {
        data.setUint32( 0, 0x46464952, true );  // RIFF
        data.setUint32( 4, numBytes + 36, true);
        {
            data.setUint32( 8, 0x45564157, true );  // WAV_WAVE
            data.setUint32( 12, 0x20746D66, true );  // WAV_FMT
            {
                data.setUint32( 16, 16, true);
                data.setUint16( 20, 1, true ); // WAV_FORMAT_PCM
                data.setUint16( 22, numChannels, true);
                data.setUint32( 24, rate, true);
                data.setUint32( 28, rate*numChannels*bits / 8, true);
                data.setUint16( 32, numChannels*bits / 8, true);
                data.setUint16( 34, bits, true);
            }

            data.setUint32( 36, 0x61746164, true);  // WAV_DATA
            {
                data.setUint32( 40, numBytes, true);
                let numWords = numSamples * numChannels;
                for(let i=0; i<numWords; i++ )
                {
                    data.setInt16( 44 + i*2, words[i], true );
                }
            }
        }
    }


    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}

function piTriggerDownload(name, blob)
{
    let url = URL.createObjectURL(blob);
    let aElement = document.createElement("a");
    aElement.href     = url;
    aElement.target   = "_self";
    aElement.download = name;
    document.body.appendChild(aElement);
    aElement.click();
    document.body.removeChild(aElement);
}</script>
    <script>"use strict"

function bufferID_to_assetID( id )
{
    if( id===0 ) return '4dXGR8';
    if( id===1 ) return 'XsXGR8';
    if( id===2 ) return '4sXGR8';
    if( id===3 ) return 'XdfGR8';
    return 'none';
}
function assetID_to_bufferID( id )
{
    if( id==='4dXGR8' ) return 0;
    if( id==='XsXGR8' ) return 1;
    if( id==='4sXGR8' ) return 2;
    if( id==='XdfGR8' ) return 3;
    return -1;
}

function assetID_to_cubemapBuferID( id )
{
    if( id==='4dX3Rr' ) return 0;
    return -1;
}
function cubamepBufferID_to_assetID( id )
{
    if( id===0 ) return '4dX3Rr';
    return 'none';
}

function EffectPass( renderer, is20, isLowEnd, hasShaderTextureLOD, callback, obj, forceMuted, forcePaused, outputGainNode, copyProgram, id, effect  )
{
    this.mID = id;
    this.mInputs  = [null, null, null, null ];
    this.mOutputs = [null, null, null, null ];
    this.mSource = null;

    this.mGainNode = outputGainNode;
    this.mSoundShaderCompiled = false;

    this.mEffect = effect;
    this.mRenderer = renderer;
    this.mProgramCopy = copyProgram; 
    this.mCompilationTime = 0;

    this.mType = "none";
    this.mName = "none";
    this.mFrame = 0;

    this.mShaderTextureLOD = hasShaderTextureLOD;
    this.mIs20 = is20;
    this.mIsLowEnd = isLowEnd;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mForceMuted = forceMuted;
    this.mForcePaused = forcePaused;
}

EffectPass.prototype.MakeHeader_Image = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        // old API
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                   header += "uniform sampler2D iChannel" + i + ";\n";

        // new API (see shadertoy.com/view/wtdGW8)
        header += "uniform struct {\n";
             if( inp===null )                  header += "  sampler2D";
        else if( inp.mInfo.mType==="cubemap" ) header += "  samplerCube";
        else if( inp.mInfo.mType==="volume"  ) header += "  sampler3D";
        else                                  header += "  sampler2D";
        header +=        " sampler;\n";
        header += "  vec3  size;\n";
        header += "  float time;\n";
        header += "  int   loaded;\n";
        header += "}iCh" + i + ";\n";
    }
	header += "void mainImage( out vec4 c, in vec2 f );\n";
    header += "void st_assert( bool cond );\n";
    header += "void st_assert( bool cond, int v );\n";

    if( this.mIs20 ) 
    {
        header += "\nout vec4 shadertoy_out_color;\n" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)shadertoy_out_color.x=-1.0;else if(v==1)shadertoy_out_color.y=-1.0;else if(v==2)shadertoy_out_color.z=-1.0;else shadertoy_out_color.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)shadertoy_out_color.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "shadertoy_out_color = vec4(1.0,1.0,1.0,1.0);" + 
            "vec4 color = vec4(1e20);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "if(shadertoy_out_color.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(shadertoy_out_color.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(shadertoy_out_color.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(shadertoy_out_color.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "shadertoy_out_color = vec4(color.xyz,1.0);" +
        "}";
    }
    else
    {
        header += "" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)gl_FragColor.x=-1.0;else if(v==1)gl_FragColor.y=-1.0;else if(v==2)gl_FragColor.z=-1.0;else gl_FragColor.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)gl_FragColor.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "gl_FragColor = vec4(0.0,0.0,0.0,1.0);" + 
            "vec4 color = vec4(1e20);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "color.w = 1.0;" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(gl_FragColor.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "gl_FragColor = vec4(color.xyz,1.0);"+
        "}";
    }
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 ) 
        this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "void main( void )" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );" +
        "color.w = 1.0;"
    if( this.mIs20 ) 
        this.mImagePassFooterVR +=  "outColor = color;}";
    else
        this.mImagePassFooterVR +=  "gl_FragColor = color;}";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Buffer = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                  header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainImage( out vec4 c,  in vec2 f );\n"

    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +
        "mainImage( color, gl_FragCoord.xy );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
    this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        this.mImagePassFooterVR +="outColor = color; }";
    else
        this.mImagePassFooterVR +="gl_FragColor = color; }";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Cubemap = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                   header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainCubemap( out vec4 c, in vec2 f, in vec3 ro, in vec3 rd );\n"

    header += "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainCubemap( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Sound = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform float     iChannelTime[4];\n" +
              "uniform float     iTimeOffset;\n" +
              "uniform int       iSampleOffset;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n";

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp!==null && inp.mInfo.mType==="cubemap" )
            header += "uniform samplerCube iChannel" + i + ";\n";
        else
            header += "uniform sampler2D iChannel" + i + ";\n";
    }
    header += "\n";
    header += "vec2 mainSound( in int samp, float time );\n";

    if( this.mIs20 )
    {
        header += "out vec4 outColor; void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "int   s = iSampleOffset + int(gl_FragCoord.y-0.2)*512 + int(gl_FragCoord.x-0.2);" +
            "vec2 y = mainSound( s, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "outColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    else
    {
        header += "void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "vec2 y = mainSound( 0, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "gl_FragColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    header += "\n";
    this.mHeader = header;
    this.mHeaderLength = 0;
}


EffectPass.prototype.MakeHeader_Common = function ()
{
    let header = "";
    let headerlength = 0;

    header += "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n";
    headerlength += 2;

    if (this.mIs20)
    {
        header += "out vec4 outColor;\n";
        headerlength += 1;
    }
    header += "void main( void )\n";
    headerlength += 1;

    if (this.mIs20)
        header += "{ outColor = vec4(0.0); }";
    else
        header += "{ gl_FragColor = vec4(0.0); }";
    headerlength += 1;
    header += "\n";
    headerlength += 1;

    this.mHeader = header;
    this.mHeaderLength = headerlength;
}

EffectPass.prototype.MakeHeader = function()
{
         if( this.mType==="image" ) this.MakeHeader_Image();
    else if( this.mType==="sound" ) this.MakeHeader_Sound();
    else if( this.mType==="buffer") this.MakeHeader_Buffer();
    else if( this.mType==="common") this.MakeHeader_Common();
    else if( this.mType==="cubemap") this.MakeHeader_Cubemap();
    else console.log("ERROR 4");
}

EffectPass.prototype.Create_Image = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}
EffectPass.prototype.Destroy_Image = function( wa )
{
}

EffectPass.prototype.Create_Buffer = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}

EffectPass.prototype.Destroy_Buffer = function( wa )
{
}

EffectPass.prototype.Create_Cubemap = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
}

EffectPass.prototype.Destroy_Cubemap = function( wa )
{
}

EffectPass.prototype.Create_Common = function( wa )
{
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.MakeHeader();
}
EffectPass.prototype.Destroy_Common = function( wa )
{
}

EffectPass.prototype.Create_Sound = function (wa)
{
    this.MakeHeader();

    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    this.mSampleRate = 44100;
    this.mPlayTime = 60*3;
    this.mPlaySamples = this.mPlayTime*this.mSampleRate;
    this.mBuffer = wa.createBuffer( 2, this.mPlaySamples, this.mSampleRate );

    //-------------------
    this.mTextureDimensions = 512;
    this.mRenderTexture = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D, 
                                                       this.mTextureDimensions, this.mTextureDimensions,
                                                       this.mRenderer.TEXFMT.C4I8,
                                                       this.mRenderer.FILTER.NONE,
                                                       this.mRenderer.TEXWRP.CLAMP, null);
    this.mRenderFBO = this.mRenderer.CreateRenderTarget(this.mRenderTexture, null, null, null, null, false);

    //-----------------------------

    // ArrayBufferView pixels;
    this.mTmpBufferSamples = this.mTextureDimensions*this.mTextureDimensions;
    this.mData = new Uint8Array( this.mTmpBufferSamples*4 );

    this.mPlaying = false;
}

EffectPass.prototype.Destroy_Sound = function( wa )
{
    if( this.mPlayNode!==null ) this.mPlayNode.stop();
    this.mPlayNode = null;
    this.mBuffer = null;
    this.mData = null;

    this.mRenderer.DestroyRenderTarget(this.mRenderFBO);
    this.mRenderer.DestroyTexture(this.mRenderTexture);
}

EffectPass.prototype.Create = function( passType, wa )
{
    this.mType = passType;
    this.mSource = null;

         if( passType==="image" ) this.Create_Image( wa );
    else if( passType==="sound" ) this.Create_Sound( wa );
    else if( passType==="buffer") this.Create_Buffer( wa );
    else if( passType==="common") this.Create_Common( wa );
    else if( passType==="cubemap") this.Create_Cubemap( wa );
    else alert("ERROR 1");
}

EffectPass.prototype.SetName = function (passName)
{
    this.mName = passName;
}

EffectPass.prototype.SetCode = function (src)
{
    this.mSource = src;
}

EffectPass.prototype.Destroy = function( wa )
{
    this.mSource = null;
         if( this.mType==="image" ) this.Destroy_Image( wa );
    else if( this.mType==="sound" ) this.Destroy_Sound( wa );
    else if( this.mType==="buffer") this.Destroy_Buffer( wa );
    else if( this.mType==="common") this.Destroy_Common( wa );
    else if( this.mType==="cubemap") this.Destroy_Cubemap( wa );
    else alert("ERROR 2");
}

EffectPass.prototype.NewShader_Sound = function( shaderCode, commonShaderCodes)
{
    let vsSource = null;

    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for( let i=0; i<commonShaderCodes.length; i++ )
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    this.mSoundShaderCompiled = false;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader_Image = function ( shaderCode, commonShaderCodes )
{
    this.mSupportsVR = false;

    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    return [vsSource, fsSource];


    /*
    let n1 = shaderCode.indexOf("mainVR(");
    let n2 = shaderCode.indexOf("mainVR (");
    let n3 = shaderCode.indexOf("mainVR  (");
    if( n1>0 || n2>0 || n3>0 )
    {
        let vsSourceVR;
        if( this.mIs20 )
            vsSourceVR = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        else
            vsSourceVR = "attribute in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

        let fsSourceVR = this.mHeader;
        for (let i = 0; i < commonShaderCodes.length; i++) {
            fsSourceVR += commonShaderCodes[i];
        }
        fsSourceVR += shaderCode;
        fsSourceVR += this.mImagePassFooterVR;

        let res = this.mRenderer.CreateShader(vsSource, fsSourceVR, preventCache);
        if( res.mResult == false )
        {
            return res.mInfo;
        }
        if( this.mProgramVR != null )
            this.mRenderer.DestroyShader( this.mProgramVR );

        this.mSupportsVR = true;
        this.mProgramVR = res;
    }
    */
}

EffectPass.prototype.NewShader_Cubemap = function( shaderCode, commonShaderCodes )
{
    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }

    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;

    fsSource += shaderCode;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader_Common = function (shaderCode )
{
    let vsSource = null;
    if (this.mIs20)
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader + shaderCode;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader = function ( commonSourceCodes, preventCache, onResolve)
{
    if( this.mRenderer===null ) return;

    let vs_fs = null;

         if( this.mType==="sound"  ) vs_fs = this.NewShader_Sound(   this.mSource, commonSourceCodes );
    else if( this.mType==="image"  ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="buffer" ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="common" ) vs_fs = this.NewShader_Common(  this.mSource,                   );
    else if( this.mType==="cubemap") vs_fs = this.NewShader_Cubemap( this.mSource, commonSourceCodes );
    else { console.log("ERROR 3: \"" + this.mType + "\""); return; }

    let me = this;
    this.mRenderer.CreateShader(vs_fs[0], vs_fs[1], preventCache, false,
        function (worked, info)
        {
            if (worked === true)
            {
                if (me.mType === "sound")
                {
                    me.mSoundShaderCompiled = true;
                }

                me.mCompilationTime = info.mTime;
                me.mError = false;
                me.mErrorStr = "No Errors";
                if (me.mProgram !== null)
                    me.mRenderer.DestroyShader(me.mProgram);
                me.mTranslatedSource = me.mRenderer.GetTranslatedShaderSource(info);
                me.mProgram = info;
            }
            else
            {
                me.mError = true;
                me.mErrorStr = info.mErrorStr;
            }
            onResolve();
        });
}

EffectPass.prototype.DestroyInput = function( id )
{
    if( this.mInputs[id]===null ) return;

    if( this.mInputs[id].mInfo.mType==="texture" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    if( this.mInputs[id].mInfo.mType==="volume" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="webcam" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video.src = "";

        if( this.mInputs[id].video.srcObject!==null )
        {
        let tracks = this.mInputs[id].video.srcObject.getVideoTracks();
        if( tracks ) tracks[0].stop();
        }
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="video" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="music" || this.mInputs[id].mInfo.mType==="musicstream")
    {
        this.mInputs[id].audio.pause();
        this.mInputs[id].audio.mSound.mFreqData = null;
        this.mInputs[id].audio.mSound.mWaveData = null;
        this.mInputs[id].audio = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="cubemap" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="keyboard" )
    {
        //if( this.mInputs[id].globject != null )
          //  this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="mic" )
    {
        this.mInputs[id].mic = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }

    this.mInputs[id] = null;
}

EffectPass.prototype.TooglePauseInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        else
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.audio.mPaused )
        {
            if( inp.loaded )
            {
                inp.audio.play();
            }
            inp.audio.mPaused = false;
        }
        else
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }

    return null;
}

EffectPass.prototype.StopInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused === false )
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused === false )
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.ResumeInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused )
        {
            inp.audio.play();
            inp.audio.mPaused = false;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.RewindInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp==null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.loaded )
        {
            inp.video.currentTime = 0;
        }
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.loaded )
        {
            inp.audio.currentTime = 0;
        }
    }
}

EffectPass.prototype.MuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = true;
        inp.video.mMuted = true;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 0.0;
        inp.audio.mMuted = true;
    }
}

EffectPass.prototype.UnMuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = false;
        inp.video.mMuted = false;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 1.0;
        inp.audio.mMuted = false;
    }
}

EffectPass.prototype.ToggleMuteInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];
    if( inp===null ) return null;

    if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.video.mMuted;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if( inp.audio.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.audio.mMuted;
    }

    return null;
}

EffectPass.prototype.UpdateInputs = function( wa, forceUpdate, keyboard )
{
   for (let i=0; i<this.mInputs.length; i++ )
   {
        let inp = this.mInputs[i];

        if( inp===null )
        {
            if( forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, null, false, 0, 0, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.image, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mPreview, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if( inp.loaded && forceUpdate )
            {
                if( this.mTextureCallbackFun!==null )
                {
                    let img = (assetID_to_cubemapBuferID(inp.mInfo.mID)===-1) ? inp.image[0] : inp.mImage;
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, img, true, 2, 1, -1.0, this.mID );
                }
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:keyboard.mIcon,mData:keyboard.mData}, false, 6, 0, -1.0, this.mID );
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, -1, this.mID );
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
              if( inp.loaded && inp.audio.mPaused === false && inp.audio.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                      inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                  }

                  if (this.mTextureCallbackFun!==null)
                  {
                           if (inp.mInfo.mType === "music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData}, false, 4, 1, inp.audio.currentTime, this.mID);
                      else if (inp.mInfo.mType === "musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData, info: inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                  }
              }
              else if( inp.loaded===false )
              {
                  if (this.mTextureCallbackFun!==null)
                      this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:null}, false, 4, 0, -1.0, this.mID);
              }
        }
        else if( inp.mInfo.mType==="mic" )
        {
              if( inp.loaded && inp.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                      inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
                  }
                  if( this.mTextureCallbackFun!==null )
                      this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave: ((wa==null)?null:inp.mFreqData) }, false, 5, 1, 0, this.mID );
              }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:null}, true, 9, 1, -1.0, this.mID );
            }
        }
    }
}

EffectPass.prototype.Sampler2Renderer = function (sampler)
{
    let filter = this.mRenderer.FILTER.NONE;
    if (sampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
    if (sampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
    let wrap = this.mRenderer.TEXWRP.REPEAT;
    if (sampler.wrap === "clamp") wrap = this.mRenderer.TEXWRP.CLAMP;
    let vflip = false;
    if (sampler.vflip === "true") vflip = true;

    return { mFilter: filter, mWrap: wrap, mVFlip: vflip };
}

EffectPass.prototype.GetSamplerVFlip = function (id)
{
    let inp = this.mInputs[id];
    return inp.mInfo.mSampler.vflip;
}

EffectPass.prototype.GetTranslatedShaderSource = function ()
{
    return this.mTranslatedSource;
}

EffectPass.prototype.SetSamplerVFlip = function (id, str) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = false;
    if (str === "true") filter = true;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, null);
            inp.mInfo.mSampler.vflip = str;
        }
    }
}

EffectPass.prototype.GetAcceptsVFlip = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return false;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return false;
    return true;
}

EffectPass.prototype.GetSamplerFilter = function (id)
{
    let inp = this.mInputs[id];
    if( inp===null) return;
    return inp.mInfo.mSampler.filter;
}

EffectPass.prototype.SetSamplerFilter = function (id, str, buffers, cubeBuffers) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = renderer.FILTER.NONE;
    if (str === "linear") filter = renderer.FILTER.LINEAR;
    if (str === "mipmap") filter = renderer.FILTER.MIPMAP;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0)
            {
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[0], filter, true);
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[1], filter, true);
                inp.mInfo.mSampler.filter = str;
            }
            else
            {
                renderer.SetSamplerFilter(inp.globject, filter, true);
                inp.mInfo.mSampler.filter = str;
            }
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[0], filter, true);
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[1], filter, true);
        inp.mInfo.mSampler.filter = str;
    }
    else if (inp.mInfo.mType === "keyboard")
    {
        inp.mInfo.mSampler.filter = str;
    }
}

EffectPass.prototype.GetAcceptsMipmapping = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetAcceptsLinear = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return true;
    if (inp.mInfo.mType === "musicstream") return true;
    if (inp.mInfo.mType === "mic")  return true;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return true;
    return false;
}

EffectPass.prototype.GetAcceptsWrapRepeat = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return false;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetSamplerWrap = function (id)
{
    return this.mInputs[id].mInfo.mSampler.wrap;
}

EffectPass.prototype.SetSamplerWrap = function (id, str, buffers)
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let restr = renderer.TEXWRP.REPEAT;
    if (str === "clamp") restr = renderer.TEXWRP.CLAMP;

    if (inp === null) 
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "video") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap") 
    {
        if (inp.loaded)
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "webcam") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[0], restr);
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[1], restr);
        inp.mInfo.mSampler.wrap = str;
    }
}


EffectPass.prototype.GetTexture = function( slot )
{
    let inp = this.mInputs[slot];
    if( inp===null ) return null;
    return inp.mInfo;
}

EffectPass.prototype.SetOutputs = function( slot, id )
{
    this.mOutputs[slot] = id;
}

EffectPass.prototype.SetOutputsByBufferID = function( slot, id )
{
    if( this.mType==="buffer" )
    {
        this.mOutputs[slot] = bufferID_to_assetID( id );

        this.mEffect.ResizeBuffer( id, this.mEffect.mXres, this.mEffect.mYres, false );
    }
    else if( this.mType==="cubemap" )
    {
        this.mOutputs[slot] = cubamepBufferID_to_assetID( id );
        this.mEffect.ResizeCubemapBuffer(id, 1024, 1024 );
    }
}

EffectPass.prototype.NewTexture = function( wa, slot, url, buffers, cubeBuffers, keyboard )
{
    var me = this;
    var renderer = this.mRenderer;

    if( renderer===null ) return;

    let texture = null;

    if( url===null || url.mType===null )
    {
        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( this.mTextureCallbackObj, slot, null, true, 0, 0, -1.0, me.mID );
        me.DestroyInput( slot );
        me.mInputs[slot] = null;
        me.MakeHeader();
        return { mFailed:false, mNeedsShaderCompile:false };
    }
    else if( url.mType==="texture" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.image = new Image();
        texture.image.crossOrigin = '';
        texture.image.onload = function()
        {
            let rti = me.Sampler2Renderer(url.mSampler);

            // O.M.G. FIX THIS
            let channels = renderer.TEXFMT.C4I8;
            if (url.mID === "Xdf3zn" || url.mID === "4sf3Rn" || url.mID === "4dXGzn" || url.mID === "4sf3Rr")
                channels = renderer.TEXFMT.C1I8;
            
            texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.image, channels, rti.mFilter, rti.mWrap, rti.mVFlip);

            texture.loaded = true;
            if( me.mTextureCallbackFun!==null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.image, true, 1, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="volume" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mImage = { mData:null, mXres:1, mYres:0, mZres:0 };
        texture.mPreview = new Image();
        texture.mPreview.crossOrigin = '';

	    var xmlHttp = new XMLHttpRequest();
        if( xmlHttp===null ) return { mFailed:true };

        xmlHttp.open('GET', url.mSrc, true);
        xmlHttp.responseType = "arraybuffer";
        xmlHttp.onerror = function()
        {
            console.log( "Error 1 loading Volume" );
        }
        xmlHttp.onload = function()
        {
            let data = xmlHttp.response;
            if (!data ) { console.log( "Error 2 loading Volume" ); return; }

            let file = piFile(data);

            let signature = file.ReadUInt32();
            texture.mImage.mXres = file.ReadUInt32();
            texture.mImage.mYres = file.ReadUInt32();
            texture.mImage.mZres = file.ReadUInt32();
            let binNumChannels = file.ReadUInt8();
            let binLayout = file.ReadUInt8();
            let binFormat = file.ReadUInt16();
            let format = renderer.TEXFMT.C1I8;
                 if( binNumChannels===1 && binFormat===0 )  format = renderer.TEXFMT.C1I8;
            else if( binNumChannels===2 && binFormat===0 )  format = renderer.TEXFMT.C2I8;
            else if( binNumChannels===3 && binFormat===0 )  format = renderer.TEXFMT.C3I8;
            else if( binNumChannels===4 && binFormat===0 )  format = renderer.TEXFMT.C4I8;
            else if( binNumChannels===1 && binFormat===10 ) format = renderer.TEXFMT.C1F32;
            else if( binNumChannels===2 && binFormat===10 ) format = renderer.TEXFMT.C2F32;
            else if( binNumChannels===3 && binFormat===10 ) format = renderer.TEXFMT.C3F32;
            else if( binNumChannels===4 && binFormat===10 ) format = renderer.TEXFMT.C4F32;
            else return;

            let buffer = new Uint8Array(data, 20); // skip 16 bytes (header of .bin)

            let rti = me.Sampler2Renderer(url.mSampler);

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T3D, texture.mImage.mXres, texture.mImage.mYres, format, rti.mFilter, rti.mWrap, buffer);

            if( texture.globject===null )
            {
                console.log( "Error 4: loading Volume" ); 
                return { mFailed:true };
            }

            if (me.mTextureCallbackFun !== null)
            {
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }

            texture.loaded = true;

            // load icon for it
            texture.mPreview.onload = function()
            {
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }
            texture.mPreview.src = url.mPreviewSrc;
        }
        xmlHttp.send("");


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="volume")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="cubemap" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        let rti = me.Sampler2Renderer(url.mSampler);

        if( assetID_to_cubemapBuferID(url.mID)!==-1 )
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 2, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/cubemap00.png";

            this.mEffect.ResizeCubemapBuffer(0, 1024, 1024 );

        }
        else
        {
            texture.image = [ new Image(), new Image(), new Image(), new Image(), new Image(), new Image() ];

            let numLoaded = 0;
            for (var i=0; i<6; i++ )
            {
                texture.image[i].mId = i;
                texture.image[i].crossOrigin = '';
                texture.image[i].onload = function()
                {
                    var id = this.mId;
                    numLoaded++;
                    if( numLoaded===6 )
                    {
                        texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.CUBEMAP, texture.image, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                        texture.loaded = true;
                        if (me.mTextureCallbackFun !== null)
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, texture.image[0], true, 2, 1, -1.0, me.mID);
                    }
                }

                if( i === 0) 
                {
                    texture.image[i].src = url.mSrc;
                } 
                else 
                {
                    let n = url.mSrc.lastIndexOf(".");
                    texture.image[i].src = url.mSrc.substring(0, n) + "_" + i + url.mSrc.substring(n, url.mSrc.length);
                }
            }
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="cubemap")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="webcam" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        texture.video = document.createElement('video');
    	texture.video.width = 320;
    	texture.video.height = 240;
    	texture.video.autoplay = true;
    	texture.video.loop = true;
        texture.mForceMuted = this.mForceMuted;
        texture.mImage = null;

        let rti = me.Sampler2Renderer(url.mSampler);

        var loadImageInsteadOfWebCam = function()
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.mImage, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 7, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/webcam.png";
        }
        
        loadImageInsteadOfWebCam();

        if( typeof navigator.getUserMedia !== "undefined"  && texture.mForceMuted===false )
        {
            texture.video.addEventListener("canplay", function (e)
            {
				try
				{
                    texture.mImage = null;
                    if( texture.globject != null )
                        renderer.DestroyTexture( texture.globject );
					texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
					texture.loaded = true;
                }
                catch(e)
                {
                    loadImageInsteadOfWebCam();
	                alert( 'Your browser can not transfer webcam data to the GPU.');
                }
            } );

            navigator.mediaDevices.getUserMedia( 
                                { "video": { width: 1280, height: 720 }, "audio": false } )
                                .then( function(stream)
                                       {
                                            texture.video.srcObject = stream;
    	                               } )
                                .catch( function(error)
                                        {
                                            loadImageInsteadOfWebCam();
    		                                alert( 'Unable to capture WebCam. Please reload the page.' );
    	                                } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="mic" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mForceMuted = this.mForceMuted;
        texture.mAnalyser = null;
        let num = 512;
        texture.mFreqData = new Uint8Array( num );
        texture.mWaveData = new Uint8Array( num );

        if( wa === null || typeof navigator.getUserMedia === "undefined" )
        {
            if( !texture.mForceMuted ) alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.mForceMuted = true; 
        }

        if( texture.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, num, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)
            texture.loaded = true;
        }
        else
        {
        navigator.getUserMedia( { "audio": true },
                                function(stream)
                                {
                                  texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, null)
                                  texture.mic = wa.createMediaStreamSource(stream);
                                  texture.mAnalyser = wa.createAnalyser();
                                  texture.mic.connect( texture.mAnalyser );
                                  texture.loaded = true;
    	                        },
                                function(error)
                                {
    		                        alert( 'Unable open Mic. Please reload the page.' );
    	                        } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="video" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.video = document.createElement('video');
    	texture.video.loop = true;
        texture.video.preload = "auto";
        texture.video.mPaused = this.mForcePaused;
        texture.video.mMuted = true;//this.mForceMuted;
    	texture.video.muted  = true;//this.mForceMuted;
        if( this.mForceMuted===true )
            texture.video.volume = 0;
    	texture.video.autoplay = false;
        texture.video.hasFalled = false;
        
        let rti = me.Sampler2Renderer(url.mSampler);

        texture.video.addEventListener("canplay", function (e)
        {
            texture.video.play().then( function()
                                       {
                                           texture.video.mPaused = false;

                                           texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                                           texture.loaded = true;
            
                                           if( me.mTextureCallbackFun!=null )
                                               me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.video, true, 3, 1, -1.0, me.mID );
                                        } )
                               .catch( function(error)
                                       {
                                           console.log( error );
                                       }
                                );
        } );

        texture.video.addEventListener( "error", function(e)
        {
               if( texture.video.hasFalled===true ) { alert("Error: cannot load video" ); return; }
               let str = texture.video.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".mp4";
               texture.video.src = str;
               texture.video.hasFalled = true;
        } );

        texture.video.src = url.mSrc;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="music" || url.mType==="musicstream" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.audio = document.createElement('audio');
    	texture.audio.loop = true;
        texture.audio.mMuted = this.mForceMuted;
        texture.audio.mForceMuted = this.mForceMuted;
        texture.audio.muted = this.mForceMuted;
        if( this.mForceMuted===true )
            texture.audio.volume = 0;
        texture.audio.autoplay = false;
        texture.audio.hasFalled = false;
        texture.audio.mPaused = false;
        texture.audio.mSound = {};

        if( this.mForceMuted===false )
        {
            if(url.mType==="musicstream" && SC === null)
            {
                alert( "Shadertoy: Soundcloud could not be reached" );
                texture.audio.mForceMuted = true;
            }
            }

        if( wa === null && this.mForceMuted===false )
        {
            alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.audio.mForceMuted = true;
        }

        if( texture.audio.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null);
            let num = 512;
            texture.audio.mSound.mFreqData = new Uint8Array( num );
            texture.audio.mSound.mWaveData = new Uint8Array( num );
            texture.loaded = true;
        }

        texture.audio.addEventListener( "canplay", function()
        {
            if( texture===null || texture.audio===null ) return;
            if( this.mForceMuted  ) return;
            if( texture.loaded === true ) return;

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)

            texture.audio.mSound.mSource   = wa.createMediaElementSource( texture.audio );
            texture.audio.mSound.mAnalyser = wa.createAnalyser();
            texture.audio.mSound.mGain     = wa.createGain();

            texture.audio.mSound.mSource.connect(   texture.audio.mSound.mAnalyser );
            texture.audio.mSound.mAnalyser.connect( texture.audio.mSound.mGain );
            texture.audio.mSound.mGain.connect(me.mGainNode);

            texture.audio.mSound.mFreqData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );
            texture.audio.mSound.mWaveData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );

            if( texture.audio.mPaused )
            {
                texture.audio.pause();
            }
            else
            {
                texture.audio.play().then( function() {} ).catch( function(e){console.log("error " + e);} );
            }
            texture.loaded = true;
        } );

        texture.audio.addEventListener( "error", function(e)
        {
               if( this.mForceMuted  ) return;

               if( texture.audio.hasFalled===true ) { return; }
               let str = texture.audio.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".ogg";
               texture.audio.src = str;
               texture.audio.hasFalled = true;
        } );

        if( !texture.audio.mForceMuted )
        {
            if(url.mType==="musicstream")
            {
                SC.resolve(url.mSrc, 
                    function(song) 
                    {
                        if( song.streamable===true )
                        {
                            texture.audio.crossOrigin = 'anonymous';
                            texture.audio.src = song.stream_url;
                            texture.audio.soundcloudInfo = song;
                        }
                        else
                        {
                            alert('Shadertoy: Soundcloud 3 - This track cannot be streamed' );
                        }
                    },
                    function(error)
                    {
                        if (me.mTextureCallbackFun!==null)
                        {
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
                        }
                    } );
            } 
            else
            {
                texture.audio.src = url.mSrc;
            }
        }

        if (me.mTextureCallbackFun!==null)
        {
            if (url.mType === "music")            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
            else if (url.mType === "musicstream") me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null, info: texture.audio.soundcloudInfo}, false, 8, 0, -1.0, me.mID);
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="keyboard" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = true;

        texture.keyboard = {};

        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {mImage: keyboard.mIcon, mData: keyboard.mData}, false, 6, 1, -1.0, me.mID );

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="buffer" )
    {
        texture = {};
        texture.mInfo = url;

        texture.image = new Image();
        texture.image.onload = function()
        {
            if( me.mTextureCallbackFun!==null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {texture: texture.image, data:null}, true, 9, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;
        texture.id = assetID_to_bufferID( url.mID );
        texture.loaded = true;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;

        this.mEffect.ResizeBuffer(texture.id, this.mEffect.mXres, this.mEffect.mYres, false );

        this.SetSamplerFilter(slot, url.mSampler.filter, buffers, cubeBuffers, true);
        this.SetSamplerVFlip(slot, url.mSampler.vflip);
        this.SetSamplerWrap(slot, url.mSampler.wrap, buffers);

        this.MakeHeader();
        return returnValue;
    }
    else
    {
        alert( "input type error" );
        return { mFailed: true };
    }

    return { mFailed: true };
}

EffectPass.prototype.Paint_Image = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];

    //------------------------
    
    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];
    let texIsLoaded = [0, 0, 0, 0 ];
    let texID = [ null, null, null, null];

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
            texIsLoaded[i] = 1;
            resos[3*i+0] = 256;
            resos[3*i+1] = 3;
            resos[3*i+2] = 1;
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;

                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                }
            }
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {

                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                texIsLoaded[i] = 0;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    times[i] = 10.0 + time;
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            let id = inp.id;
            if( inp.loaded===true  )
            {
                texID[i] = buffers[id].mTexture[ buffers[id].mLastRenderDone ];
                texIsLoaded[i] = 1;
                resos[3*i+0] = xres;
                resos[3*i+1] = yres;
                resos[3*i+2] = 1;
                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID[i], filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    let prog = this.mProgram;

    //if( vrData!=null && this.mSupportsVR ) prog = this.mProgramVR;

    this.mRenderer.AttachShader(prog);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F("iFrameRate", fps);

    this.mRenderer.SetShaderConstant1F(  "iCh0.time", times[0] );
    this.mRenderer.SetShaderConstant1F(  "iCh1.time", times[1] );
    this.mRenderer.SetShaderConstant1F(  "iCh2.time", times[2] );
    this.mRenderer.SetShaderConstant1F(  "iCh3.time", times[3] );
    this.mRenderer.SetShaderConstant3F(  "iCh0.size", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iCh1.size", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iCh2.size", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iCh3.size", resos[9], resos[10], resos[11] );
    this.mRenderer.SetShaderConstant1I(  "iCh0.loaded", texIsLoaded[0] );
    this.mRenderer.SetShaderConstant1I(  "iCh1.loaded", texIsLoaded[1] );
    this.mRenderer.SetShaderConstant1I(  "iCh2.loaded", texIsLoaded[2] );
    this.mRenderer.SetShaderConstant1I(  "iCh3.loaded", texIsLoaded[3] );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    if( (vrData !== null) && this.mSupportsVR )
    {
        for (let i=0; i<2; i++ )
        {
            let ei = (i===0) ? vrData.mLeftEye : vrData.mRightEye;

            let vp = [i * xres / 2, 0, xres / 2, yres];

            this.mRenderer.SetViewport(vp);

            let fov = ei.mProjection;
            let corA = [ -fov[2], -fov[1], -1.0 ];
            let corB = [  fov[3], -fov[1], -1.0 ];
            let corC = [  fov[3],  fov[0], -1.0 ];
            let corD = [ -fov[2],  fov[0], -1.0 ];
            let apex = [ 0.0, 0.0, 0.0 ];

            let ma = invertFast( ei.mCamera );
            corA = matMulpoint( ma, corA ); 
            corB = matMulpoint( ma, corB ); 
            corC = matMulpoint( ma, corC ); 
            corD = matMulpoint( ma, corD ); 
            apex = matMulpoint( ma, apex ); 

            let corners = [ corA[0], corA[1], corA[2], 
                            corB[0], corB[1], corB[2], 
                            corC[0], corC[1], corC[2], 
                            corD[0], corD[1], corD[2],
                            apex[0], apex[1], apex[2]];

            this.mRenderer.SetShaderConstant3FV("unCorners", corners);
            this.mRenderer.SetShaderConstant4FV("unViewport", vp);

            this.mRenderer.DrawUnitQuad_XY(l1);
        }
    }
    else 
    {
        this.mRenderer.SetViewport([0, 0, xres, yres]);
        this.mRenderer.DrawFullScreenTriangle_XY( l1 );
    }

    this.mRenderer.DettachTextures();
}

EffectPass.prototype.iRenderSound = function(d, callback )
{
    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds() ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    this.mRenderer.SetRenderTarget(this.mRenderFBO);

    this.mRenderer.SetViewport([0, 0, this.mTextureDimensions, this.mTextureDimensions]);
    this.mRenderer.AttachShader(this.mProgram);
    this.mRenderer.SetBlend( false );

    let texID = [null, null, null, null];
    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
    }

    this.mRenderer.AttachTextures(4, texID[0], texID[1], texID[2], texID[3]);

    let l2 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iTimeOffset");
    let l3 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iSampleOffset");
    this.mRenderer.SetShaderConstant4FV("iDate", dates);
    this.mRenderer.SetShaderConstant3FV("iChannelResolution", resos);
    this.mRenderer.SetShaderConstant1F("iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit("iChannel0", 0);
    this.mRenderer.SetShaderTextureUnit("iChannel1", 1);
    this.mRenderer.SetShaderTextureUnit("iChannel2", 2);
    this.mRenderer.SetShaderTextureUnit("iChannel3", 3);

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    //--------------------------------
    let numSamples = this.mTmpBufferSamples;
    let numBlocks = this.mPlaySamples / numSamples;
    for (let j=0; j<numBlocks; j++ )
    {
        let off = j*numSamples;
        
        this.mRenderer.SetShaderConstant1F_Pos(l2, off / this.mSampleRate);
        this.mRenderer.SetShaderConstant1I_Pos(l3, off );
        this.mRenderer.DrawUnitQuad_XY(l1);

        this.mRenderer.GetPixelData(this.mData, 0, this.mTextureDimensions, this.mTextureDimensions);

        callback( off, this.mData, numSamples );
    }

    this.mRenderer.DetachShader();
    this.mRenderer.DettachTextures();
    this.mRenderer.SetRenderTarget(null);
}

EffectPass.prototype.Paint_Sound = function( wa, d )
{
    let bufL = this.mBuffer.getChannelData(0); // Float32Array
    let bufR = this.mBuffer.getChannelData(1); // Float32Array

    this.iRenderSound( d, function(off, data, numSamples)
                         {
                            for( let i=0; i<numSamples; i++ )
                            {
                                bufL[off+i] = -1.0 + 2.0*(data[4*i+0]+256.0*data[4*i+1])/65535.0;
                                bufR[off+i] = -1.0 + 2.0*(data[4*i+2]+256.0*data[4*i+3])/65535.0;
                            }
                         }
                     );
}

EffectPass.prototype.SetUniforms = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    //------------------------
    
    let texID = [ null, null, null, null];

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
        }
        else if( inp.mInfo.mType=="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
    
                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                }
            }

        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
           if( inp.loaded===true )
           { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                times[i] = 10.0 + time;
            }

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = buffers[inp.id].mTexture[ buffers[inp.id].mLastRenderDone ];
                resos[3*i+0] = buffers[inp.id].mResolution[0];
                resos[3*i+1] = buffers[inp.id].mResolution[1];
                resos[3*i+2] = 1;
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    this.mRenderer.AttachShader(this.mProgram);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F(  "iFrameRate", fps );

    this.mRenderer.SetShaderConstant1F(  "iChannel[0].time",       times[0] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[1].time",       times[1] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[2].time",       times[2] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[3].time",       times[3] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[0].resolution", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[1].resolution", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[2].resolution", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[3].resolution", resos[9], resos[10], resos[11] );
}

EffectPass.prototype.ProcessInputs = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
        }
        else if( inp.mInfo.mType==="volume" )
        {
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );
                }
                else if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                if( inp.audio.mForceMuted === true )
                {
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                let id = inp.id;
                let texID = buffers[id].mTexture[ buffers[id].mLastRenderDone ];

                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID, filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
				let id = inp.id;
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }
}

EffectPass.prototype.Paint_Cubemap = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face )
{
    this.ProcessInputs(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
    this.SetUniforms(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    let vp = [0, 0, xres, yres];

    this.mRenderer.SetViewport(vp);

    let corA = [-1.0, -1.0, -1.0];
    let corB = [ 1.0, -1.0, -1.0];
    let corC = [ 1.0,  1.0, -1.0];
    let corD = [-1.0,  1.0, -1.0];
    let apex = [ 0.0,  0.0,  0.0];

         if( face===0 ) { corA=[ 1.0,  1.0,  1.0]; corB=[ 1.0,  1.0, -1.0]; corC=[ 1.0, -1.0, -1.0]; corD=[ 1.0, -1.0,  1.0]; }
    else if( face===1 ) { corA=[-1.0,  1.0, -1.0]; corB=[-1.0,  1.0,  1.0]; corC=[-1.0, -1.0,  1.0]; corD=[-1.0, -1.0, -1.0]; }
    else if( face===2 ) { corA=[-1.0,  1.0, -1.0]; corB=[ 1.0,  1.0, -1.0]; corC=[ 1.0,  1.0,  1.0]; corD=[-1.0,  1.0,  1.0]; }
    else if( face===3 ) { corA=[-1.0, -1.0,  1.0]; corB=[ 1.0, -1.0,  1.0]; corC=[ 1.0, -1.0, -1.0]; corD=[-1.0, -1.0, -1.0]; }
    else if( face===4 ) { corA=[-1.0,  1.0,  1.0]; corB=[ 1.0,  1.0,  1.0]; corC=[ 1.0, -1.0,  1.0]; corD=[-1.0, -1.0,  1.0]; }
    else if( face===5 ) { corA=[ 1.0,  1.0, -1.0]; corB=[-1.0,  1.0, -1.0]; corC=[-1.0, -1.0, -1.0]; corD=[ 1.0, -1.0, -1.0]; }

    let corners = [ corA[0], corA[1], corA[2], 
                    corB[0], corB[1], corB[2], 
                    corC[0], corC[1], corC[2], 
                    corD[0], corD[1], corD[2],
                    apex[0], apex[1], apex[2]];

    this.mRenderer.SetShaderConstant3FV("unCorners", corners);
    this.mRenderer.SetShaderConstant4FV("unViewport", vp);

    this.mRenderer.DrawUnitQuad_XY(l1);

    this.mRenderer.DettachTextures();
}

EffectPass.prototype.Paint = function( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, bufferNeedsMimaps, buffers, cubeBuffers, keyboard, effect )
{
    if( this.mType==="sound" )
    {
        if (this.mSoundShaderCompiled === true)
        {
            // make sure all textures are loaded
            for (let i=0; i<this.mInputs.length; i++ )
            {
                let inp = this.mInputs[i];
                if (inp === null) continue;

                if (inp.mInfo.mType === "texture" && !inp.loaded) return;
                if (inp.mInfo.mType === "cubemap" && !inp.loaded) return;
            }

            this.Paint_Sound(wa, da);
            this.mSoundShaderCompiled = false;
        }
        if (this.mFrame === 0)
        {
            if (this.mPlaying===true)
            {
                this.mPlayNode.disconnect();
                this.mPlayNode.stop();
                this.mPlayNode = null;
            }
            this.mPlaying = true;

            this.mPlayNode = wa.createBufferSource();
            this.mPlayNode.buffer = this.mBuffer;
            this.mPlayNode.connect(this.mGainNode);
            this.mPlayNode.start(0);
        }
        this.mFrame++;
    }
    else if( this.mType==="image" )
    {
        this.mRenderer.SetRenderTarget( null );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );
        this.mFrame++;
    }
    else if( this.mType==="common" )
    {
    }
    else if( this.mType==="buffer" )
    {
        this.mEffect.ResizeBuffer(bufferID, this.mEffect.mXres, this.mEffect.mYres, false );

        let buffer = buffers[bufferID];

        let dstID = 1 - buffer.mLastRenderDone;

        this.mRenderer.SetRenderTarget( buffer.mTarget[dstID] );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }

        // make thumbnail
        //if( this.mTextureCallbackFun != null )
        /*
        {
            this.mRenderer.SetRenderTarget( buffer.mThumbnailRenderTarget );
            let v = [0, 0, buffer.mThumbnailRes[0], buffer.mThumbnailRes[1]];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            this.mRenderer.SetShaderConstant4FV("v", v);
            this.mRenderer.AttachTextures(1, buffer.mTexture[dstID], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);
            this.mRenderer.DettachTextures();
            this.mRenderer.DetachShader();
            this.mRenderer.GetPixelData( new Uint8Array(buffer.mThumbnailBuffer.data.buffer), buffer.mThumbnailRes[0], buffer.mThumbnailRes[1] );
            this.mRenderer.SetRenderTarget(null);
        }
        */
        buffers[bufferID].mLastRenderDone = 1 - buffers[bufferID].mLastRenderDone;
        this.mFrame++;
    }
    else if( this.mType==="cubemap" )
    {
        this.mEffect.ResizeCubemapBuffer(bufferID, 1024, 1024, false );

        let buffer = cubeBuffers[bufferID];

        xres = buffer.mResolution[0];
        yres = buffer.mResolution[1];
        let dstID = 1 - buffer.mLastRenderDone;
        for( let face=0; face<6; face++ )
        {
            this.mRenderer.SetRenderTargetCubeMap( buffer.mTarget[dstID], face );
            this.Paint_Cubemap( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
        }
        this.mRenderer.SetRenderTargetCubeMap( null, 0 );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }
        cubeBuffers[bufferID].mLastRenderDone = 1 - cubeBuffers[bufferID].mLastRenderDone;

        this.mFrame++;
    }
}

EffectPass.prototype.StopOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;
    this.mPlayNode.disconnect();
}

EffectPass.prototype.ResumeOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;

    wa.resume()
    this.mPlayNode.connect( this.mGainNode );
}

EffectPass.prototype.StopOutput_Image = function( wa )
{
}

EffectPass.prototype.ResumeOutput_Image = function( wa )
{
}

EffectPass.prototype.StopOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.StopInput(j);

    if( this.mType==="sound" )
         this.StopOutput_Sound( wa );
    else
         this.StopOutput_Image( wa );
}

EffectPass.prototype.ResumeOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.ResumeInput(j);

    if( this.mType==="sound" )
         this.ResumeOutput_Sound( wa );
    else
         this.ResumeOutput_Image( wa );
}

EffectPass.prototype.GetCompilationTime = function()
{
    return this.mCompilationTime;
}

//============================================================================================================
function Screenshots()
{
    // private
    let mTexture = null;
    let mTarget = null;
    let mXres = 0;
    let mYres = 0;
    let mCubemapToEquirectProgram;
    let mRenderer = null;

    // public
    var me = {};

    me.Initialize = function(renderer)
    {
        mRenderer = renderer;
        let caps = mRenderer.GetCaps();
        let is20 = caps.mIsGL20;

        let vsSourceC, fsSourceC;
        if( is20 )
        {
            vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; out vec4 outColor; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); outColor = texture(t, rd); }";
        }
        else
        {
            vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); gl_FragColor = texture(t, rd); }";
        }

        let compileShader = function (worked, info)
        {
            if (worked === false)
            {
                console.log("Failed to compile cubemap resample shader (" + errorType + "): " + log);
            }
            else
            {
                mCubemapToEquirectProgram = info;
            }
        }
        mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, compileShader);

        return true;
    };

    me.Allocate = function( xres, yres )
    {
        if( xres>mXres || yres>mYres )
        {
            let texture = mRenderer.CreateTexture(mRenderer.TEXTYPE.T2D, xres, yres, mRenderer.TEXFMT.C4F32, mRenderer.FILTER.NONE, mRenderer.TEXWRP.CLAMP, null);
            let target = mRenderer.CreateRenderTarget( texture, null, null, null, null, false);

            if( mXres!==0 )
            {
                mRenderer.DestroyTexture(mTexture);
                mRenderer.DestroyRenderTarget(mTarget);
            }

            mTexture = texture;
            mTarget = target;
            mXres = xres;
            mYres = yres;
        }
    };

    me.GetProgram = function()
    {
        return mCubemapToEquirectProgram;
    };
    me.GetTarget = function()
    {
        return mTarget;
    };

    return me;
};

//============================================================================================================

function Effect(vr, ac, canvas, callback, obj, forceMuted, forcePaused, resizeCallback, crashCallback )
{
    let xres = canvas.width;
    let yres = canvas.height;

    let me = this;
    this.mCanvas = canvas;
    this.mCreated = false;
    this.mRenderer = null;
    this.mAudioContext = ac;
    this.mGLContext = null;
    this.mWebVR = vr;
    this.mRenderingStereo = false;
    this.mXres = xres;
    this.mYres = yres;
    this.mForceMuted = forceMuted;
    if( ac===null ) this.mForceMuted = true;
    this.mForcePaused = forcePaused;
    this.mGainNode = null;
    this.mPasses = [];
    this.mFrame = 0;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mMaxBuffers = 4;
    this.mMaxCubeBuffers = 1;
    this.mMaxPasses = this.mMaxBuffers + 1 + 1 + 1 + 1; // some day decouple passes from buffers (4 buffers + common + Imagen + sound + cubemap)
    this.mBuffers = [];
    this.mCubeBuffers = [];
    this.mScreenshotSytem = null;
    this.mCompilationTime = 0;
    this.mIsLowEnd = piIsMobile();

    this.mGLContext = piCreateGlContext(canvas, false, false, true, false); // need preserve-buffe to true in order to capture screenshots
    if (this.mGLContext === null)
    {
        return;
    }

    canvas.addEventListener("webglcontextlost", function (event)
        {
            event.preventDefault();
            crashCallback();
        }, false);

    this.mRenderer = piRenderer();
    if (!this.mRenderer.Initialize(this.mGLContext))
        return;

    this.mScreenshotSytem = Screenshots();
    if (!this.mScreenshotSytem.Initialize(this.mRenderer))
        return;

    var caps = this.mRenderer.GetCaps();
    this.mIs20 = caps.mIsGL20;
    this.mShaderTextureLOD = caps.mShaderTextureLOD;
    //-------------
    if( ac!==null )
    {   
        this.mGainNode = ac.createGain();
        if( !forceMuted )
        {
            this.mGainNode.connect( ac.destination);
        }
        if (this.mForceMuted )
            this.mGainNode.gain.value = 0.0;
        else
            this.mGainNode.gain.value = 1.0;
    }

    //-------------
    let vsSourceC, fsSourceC;
    if( this.mIs20 )
    {
        vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { outColor = textureLod(t, gl_FragCoord.xy / v.zw, 0.0); }";
    }
    else
    {
        vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; void main() { gl_FragColor = texture2D(t, gl_FragCoord.xy / v.zw, -100.0); }";
    }

    this.mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, function(worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to copy buffers : " + info.mErrorStr);
            else me.mProgramCopy = info;
        });

    let vsSourceD, fsSourceD;
    if( this.mIs20 )
    {
        vsSourceD = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { vec2 uv = gl_FragCoord.xy / v.zw; outColor = texture(t, vec2(uv.x,1.0-uv.y)); }";
    }
    else
    {
        vsSourceD = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; void main() { vec2 uv = gl_FragCoord.xy / v.zw; gl_FragColor = texture2D(t, vec2(uv.x,1.0-uv.y)); }";
    }

    this.mRenderer.CreateShader(vsSourceD, fsSourceD, false, true, function (worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to downscale buffers : " + info.mErrorStr);
            else me.mProgramDownscale = info;
        });


    // set all buffers and cubemaps to null
    for( let i=0; i<this.mMaxBuffers; i++ )
    {
        this.mBuffers[i] = { mTexture: [null, null], 
                             mTarget:  [null, null], 
                             mResolution: [0, 0],
                             mLastRenderDone: 0,
                             mThumbnailRenderTarget: null,
                             mThumbnailTexture: null,
                             mThumbnailBuffer:  null,
                             mThumbnailRes: [0, 0] };
    }

    for( let i=0; i<this.mMaxCubeBuffers; i++ )
    {
        this.mCubeBuffers[i] = { mTexture: [null, null], 
                                mTarget:  [null, null], 
                                mResolution: [0, 0],
                                mLastRenderDone: 0,
                                mThumbnailRenderTarget: null,
                                mThumbnailTexture: null,
                                mThumbnailBuffer:  null,
                                mThumbnailRes: [0, 0] };
    }

    //-------

    let keyboardData = new Uint8Array( 256*3 );
    for (let j=0; j<(256*3); j++ ) { keyboardData[j] = 0; }
    let kayboardTexture = this.mRenderer.CreateTexture( this.mRenderer.TEXTYPE.T2D, 256, 3, this.mRenderer.TEXFMT.C1I8, this.mRenderer.FILTER.NONE, this.mRenderer.TEXWRP.CLAMP, null);
    let keyboardImage = new Image();
    if( callback!==null )
        keyboardImage.src = "/img/keyboard.png"; // don't load PNG if no UI 
    this.mKeyboard = { mData: keyboardData, mTexture: kayboardTexture, mIcon: keyboardImage };

    let iResize = function( xres, yres )
    {
        me.mCanvas.width = xres;
        me.mCanvas.height = yres;
        me.mXres = xres;
        me.mYres = yres;
        me.ResizeBuffers(xres, yres);
        resizeCallback(xres, yres);
    };

    let bestAttemptFallback = function()
    {
        let devicePixelRatio = window.devicePixelRatio || 1;
        let xres = Math.round(me.mCanvas.offsetWidth  * devicePixelRatio) | 0;
        let yres = Math.round(me.mCanvas.offsetHeight * devicePixelRatio) | 0;
        iResize(xres, yres);
    };

    if(!window.ResizeObserver)
    {
        console.log("WARNING: This browser doesn't support ResizeObserver.");
        bestAttemptFallback();
        window.addEventListener("resize", bestAttemptFallback);
    }
    else
    {
        this.mRO = new ResizeObserver( function(entries, observer)
        {
            var entry = entries[0];
            if (!entry['devicePixelContentBoxSize'])
            {
                observer.unobserve(me.mCanvas);
                console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (2)");
                bestAttemptFallback();
                window.addEventListener("resize", bestAttemptFallback);
            }
            else
            {
                let box = entry.devicePixelContentBoxSize[0];
                let xres = box.inlineSize;
                let yres = box.blockSize;
                iResize(xres, yres);
            }
        });
        try
        {
            this.mRO.observe(this.mCanvas, { box: ["device-pixel-content-box"] });
            //this.mRO.observe(this.mCanvas);
        }
        catch (e)
        {
            console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (1)");
            bestAttemptFallback();
            window.addEventListener("resize", bestAttemptFallback);
        }
    }

    this.mCreated = true;
}

Effect.prototype.ResizeCubemapBuffer = function(i, xres, yres )
{
    let oldXres = this.mCubeBuffers[i].mResolution[0];
    let oldYres = this.mCubeBuffers[i].mResolution[1];

    if( this.mCubeBuffers[i].mTexture[0]===null || oldXres !== xres || oldYres !== yres )
    {
        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);
        let target1 = this.mRenderer.CreateRenderTargetCubeMap( texture1, null, false);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target2 = this.mRenderer.CreateRenderTargetCubeMap( texture2, null, false);

        // Store new buffers
        this.mCubeBuffers[i].mTexture = [texture1,texture2], 
        this.mCubeBuffers[i].mTarget =  [target1, target2 ], 
        this.mCubeBuffers[i].mLastRenderDone = 0;
        this.mCubeBuffers[i].mResolution[0] = xres;
        this.mCubeBuffers[i].mResolution[1] = yres;
    }
}

Effect.prototype.ResizeBuffer = function( i, xres, yres, skipIfNotExists )
{
    if( skipIfNotExists && this.mBuffers[i].mTexture[0]===null ) return;

    let oldXres = this.mBuffers[i].mResolution[0];
    let oldYres = this.mBuffers[i].mResolution[1];

    if( oldXres !== xres || oldYres !== yres )
    {
        let needCopy = (this.mBuffers[i].mTexture[0]!==null);

        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[0].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[0].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[1].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[1].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target1 = this.mRenderer.CreateRenderTarget( texture1, null, null, null, null, false);
        let target2 = this.mRenderer.CreateRenderTarget( texture2, null, null, null, null, false);

        if( needCopy )
        {
            let v = [0, 0, Math.min(xres, oldXres), Math.min(yres, oldYres)];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            let vOld = [0, 0, oldXres, oldYres];
            this.mRenderer.SetShaderConstant4FV("v", vOld);

            // Copy old buffers 1 to new buffer
            this.mRenderer.SetRenderTarget(target1);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[0], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Copy old buffers 2 to new buffer
            this.mRenderer.SetRenderTarget(target2);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[1], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Deallocate old memory
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[0]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[0]);
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[1]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[1]);
            //this.mRenderer.DestroyTexture(this.mBuffers[i].thumbnailTexture);
        }

        // Store new buffers
        this.mBuffers[i].mTexture = [texture1,texture2], 
        this.mBuffers[i].mTarget =  [target1, target2 ], 
        this.mBuffers[i].mLastRenderDone = 0;
        this.mBuffers[i].mResolution[0] = xres;
        this.mBuffers[i].mResolution[1] = yres;
    }
}

Effect.prototype.saveScreenshot = function(passid)
{
    let pass = this.mPasses[passid];

    if( pass.mType === "buffer" )
    {
        let bufferID = assetID_to_bufferID( this.mPasses[passid].mOutputs[0] );

        let texture = this.mBuffers[bufferID].mTarget[ this.mBuffers[bufferID].mLastRenderDone ];

        let numComponents = 3;
        let width = texture.mTex0.mXres;
        let height = texture.mTex0.mYres;
        let type = "Float"; // Other options Float, Half, Uint
        let bytes = new Float32Array(width * height * 4 );//numComponents);
        this.mRenderer.GetPixelDataRenderTarget( texture, bytes, width, height );
        let blob = piExportToEXR(width, height, numComponents, type, bytes);

        // Offer download automatically to the user
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "cubemap" )
    {
        let xres = 4096;
        let yres = 2048;
        this.mScreenshotSytem.Allocate( xres, yres );

        let cubeBuffer = this.mCubeBuffers[0];

        let target = this.mScreenshotSytem.GetTarget();
        this.mRenderer.SetRenderTarget( target );

        let program = this.mScreenshotSytem.GetProgram();

        this.mRenderer.AttachShader(program);
        let l1 = this.mRenderer.GetAttribLocation(program, "pos");
        this.mRenderer.SetViewport( [0, 0, xres, yres] );
        this.mRenderer.AttachTextures(1, cubeBuffer.mTexture[ cubeBuffer.mLastRenderDone ], null, null, null);
        this.mRenderer.DrawUnitQuad_XY(l1);
        this.mRenderer.DettachTextures();
        this.mRenderer.SetRenderTarget( null );

        let data = new Float32Array(xres*yres*4);
        this.mRenderer.GetPixelDataRenderTarget( target, data, xres, yres );

        let blob = piExportToEXR(xres, yres, 3, "Float", data );
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "sound" )
    {
        let offset = 0;
        const bits = 16;
        const numChannels = 2;
        let words = new Int16Array(60*pass.mSampleRate*numChannels );

        pass.iRenderSound( new Date(), function(off, data, numSamples)
                                         {
                                            for( let i=0; i<numSamples; i++ )
                                            {
                                                words[offset++] = (data[4*i+0]+256.0*data[4*i+1]) - 32767;
                                                words[offset++] = (data[4*i+2]+256.0*data[4*i+3]) - 32767;
                                            }
                                         }
                                     );

        let blob = piExportToWAV( 60*pass.mSampleRate, pass.mSampleRate, bits, numChannels, words);

        piTriggerDownload("sound.wav", blob);
    }    
}

Effect.prototype.ResizeBuffers = function(xres, yres)
{
    for (let i=0; i<this.mMaxBuffers; i++ )
    {
        this.ResizeBuffer(i, xres, yres, true);
    }
}

Effect.prototype.IsEnabledVR = function ()
{
    if (this.mRenderingStereo) return true;
    return false;
}

Effect.prototype.EnableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( this.mRenderingStereo ) return;

    this.mRenderingStereo = true;
    this.mWebVR.Enable();
}

Effect.prototype.DisableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( !this.mRenderingStereo ) return;

    this.mRenderingStereo = false;
    this.mWebVR.Disable();
}

Effect.prototype.GetTexture = function( passid, slot ) { return this.mPasses[passid].GetTexture( slot ); }
Effect.prototype.NewTexture = function (passid, slot, url) { return this.mPasses[passid].NewTexture( this.mAudioContext, slot, url, this.mBuffers, this.mCubeBuffers, this.mKeyboard ); }
Effect.prototype.SetOutputs = function( passid, slot, url ) { this.mPasses[passid].SetOutputs( slot, url ); }
Effect.prototype.SetOutputsByBufferID = function( passid, slot, id ) { this.mPasses[passid].SetOutputsByBufferID( slot, id ); }
Effect.prototype.GetAcceptsLinear = function (passid, slot) { return this.mPasses[passid].GetAcceptsLinear(slot); }
Effect.prototype.GetAcceptsMipmapping = function (passid, slot) { return this.mPasses[passid].GetAcceptsMipmapping(slot); }
Effect.prototype.GetAcceptsWrapRepeat = function (passid, slot) { return this.mPasses[passid].GetAcceptsWrapRepeat(slot); }
Effect.prototype.GetAcceptsVFlip = function (passid, slot) { return this.mPasses[passid].GetAcceptsVFlip(slot); }
Effect.prototype.SetSamplerFilter = function (passid, slot, str) { this.mPasses[passid].SetSamplerFilter(slot, str, this.mBuffers, this.mCubeBuffers); }
Effect.prototype.GetTranslatedShaderSource = function (passid) { return this.mPasses[passid].GetTranslatedShaderSource(); }
Effect.prototype.GetSamplerFilter = function (passid, slot) { return this.mPasses[passid].GetSamplerFilter(slot); }
Effect.prototype.SetSamplerWrap = function (passid, slot, str) { this.mPasses[passid].SetSamplerWrap(slot, str, this.mBuffers); }
Effect.prototype.GetSamplerWrap = function (passid, slot) { return this.mPasses[passid].GetSamplerWrap(slot); }
Effect.prototype.SetSamplerVFlip = function (passid, slot, str) { this.mPasses[passid].SetSamplerVFlip(slot, str); }
Effect.prototype.GetSamplerVFlip = function (passid, slot) { return this.mPasses[passid].GetSamplerVFlip(slot); }

Effect.prototype.GetHeaderSize = function (passid)
{
    return this.mPasses[passid].mHeaderLength + 
           this.mRenderer.GetShaderHeaderLines(1);
}

Effect.prototype.ToggleVolume = function()
{
    this.mForceMuted = !this.mForceMuted;

    // outp
    if (this.mForceMuted)
        this.mGainNode.gain.value = 0.0;
    else
        this.mGainNode.gain.value = 1.0;

    // inp
    let num = this.mPasses.length;
    for( let j=0; j<num; j++ )
    {
        for( let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            if( this.mForceMuted )
                this.mPasses[j].MuteInput( this.mAudioContext, i );
            else
                this.mPasses[j].UnMuteInput( this.mAudioContext, i );
        }
    }

    return this.mForceMuted;
}

Effect.prototype.SetKeyDown = function( passid, k )
{
    if( this.mKeyboard.mData[ k + 0*256 ] == 255 ) return;

    this.mKeyboard.mData[ k + 0*256 ] = 255;
    this.mKeyboard.mData[ k + 1*256 ] = 255;
    this.mKeyboard.mData[ k + 2*256 ] = 255 - this.mKeyboard.mData[ k + 2*256 ];
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }
}

Effect.prototype.SetKeyUp = function( passid, k )
{
    this.mKeyboard.mData[ k + 0*256 ] = 0;
    this.mKeyboard.mData[ k + 1*256 ] = 0;
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }
}

Effect.prototype.StopOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].StopOutput( wa );
    }
}

Effect.prototype.ResumeOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].ResumeOutput( wa );
    }
}

Effect.prototype.PauseInput = function( passid, id )
{
    return this.mPasses[passid].TooglePauseInput( this.mAudioContext, id );
}

Effect.prototype.ToggleMuteInput = function( passid, id )
{
    return this.mPasses[passid].ToggleMuteInput( this.mAudioContext, id );
}

Effect.prototype.RewindInput = function( passid, id )
{
    this.mPasses[passid].RewindInput( this.mAudioContext, id );
}

Effect.prototype.UpdateInputs = function( passid, forceUpdate )
{
   this.mPasses[passid].UpdateInputs( this.mAudioContext, forceUpdate, this.mKeyboard );
}

Effect.prototype.ResetTime = function()
{
    this.mFrame = 0;
    this.mAudioContext.resume()

    let num = this.mPasses.length;
    for( let i=0; i<num; i++ )
    {
        this.mPasses[i].mFrame = 0;
        for( let j=0; j<this.mPasses[i].mInputs.length; j++ )
            this.mPasses[i].RewindInput(this.mAudioContext, j)
    }
}

Effect.prototype.RequestAnimationFrame = function (id)
{
    if (this.mRenderingStereo && this.mWebVR.IsPresenting())
    {
        this.mWebVR.RequestAnimationFrame(id);
    }
    else
    {
        requestAnimFrame(id);
    }
}

Effect.prototype.Paint = function(time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, isPaused)
{
    let wa = this.mAudioContext;
    let da = new Date();
    let vrData = null; if (this.mRenderingStereo) vrData = this.mWebVR.GetData();
    let xres = this.mXres / 1;
    let yres = this.mYres / 1;

    if( this.mFrame===0 )
    {
        for( let i=0; i<this.mMaxBuffers; i++ )
        {
            if( this.mBuffers[i].mTexture[0]!==null )
            {
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[0] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[1] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
				
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[0] );
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[1] );
            }
        }
        for( let i=0; i<this.mMaxCubeBuffers; i++ )
        {
            if( this.mCubeBuffers[i].mTexture[0]!==null )
            {
                for( let face=0; face<6; face++ )
                {
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[0], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[1], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
					this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[0] );
				    this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[1] );
                }
            }
        }
    }

    let num = this.mPasses.length;

    // render sound first
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "sound" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "buffer" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;
        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="buffer" && inp.id === bufferID && inp.mInfo.mSampler.filter === "mipmap")
                {
                    needMipMaps = true;
                    break;
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render cubemap buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "cubemap" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = 0;//assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;

        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="cubemap" )
                {
                    if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0 && inp.mInfo.mSampler.filter === "mipmap" )
                    {
                        needMipMaps = true;
                        break;
                    }
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render image last
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "image" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }   

    // erase keypresses
    for (let k=0; k<256; k++ )
    {
       this.mKeyboard.mData[ k + 1*256 ] = 0;
    }
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    if( this.mRenderingStereo ) this.mWebVR.Finish();

    this.mFrame++;
}

Effect.prototype.NewShader = function( passid, preventCache, onResolve )
{
    let commonSourceCodes = [];
    for (let i=0; i<this.mPasses.length; i++ )
    {
        if( this.mPasses[i].mType==="common")
        {
            commonSourceCodes.push(this.mPasses[i].mSource);
        }
    }

    this.mPasses[passid].NewShader(commonSourceCodes, preventCache, onResolve );
}

Effect.prototype.GetNumPasses = function()
{
    return this.mPasses.length;
}

Effect.prototype.GetNumOfType = function(passtype)
{
    let id = 0;
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType===passtype )
        {
            id++;
        }
    }
    return id;
}

Effect.prototype.GetPassType = function( id ) { return this.mPasses[id].mType; }
Effect.prototype.GetPassName = function( id ) { return this.mPasses[id].mName; }
Effect.prototype.GetCode = function( id ) { return this.mPasses[id].mSource; }
Effect.prototype.SetCode = function( id, source ) { this.mPasses[id].SetCode(source); }
Effect.prototype.GetError = function (id) { return this.mPasses[id].mError; }
Effect.prototype.GetErrorStr = function (id) { return this.mPasses[id].mErrorStr; }
Effect.prototype.GetErrorGlobal = function()
{
    for (let i = 0; i < this.mPasses.length; i++)
    {
        if (this.mPasses[i].mError)
        {
            return true;
        }
    }
    return false;
}

Effect.prototype.Load = function (jobj )
{
    if (jobj.ver !== "0.1")
    {
        console.log("Wrong Format");
        return false;
    }

    let numPasses = jobj.renderpass.length;

    if( numPasses<1 || numPasses>this.mMaxPasses )
    {
        console.log("Corrupted Shader - " + numPasses);
        return false;
    }

    this.mPasses = [];
    for (let j = 0; j < numPasses; j++)
    {
        let rpass = jobj.renderpass[j];

        // skip sound passes if in thumbnail mode
        if( this.mForceMuted && rpass.type === "sound" ) continue;

        let wpass = new EffectPass(this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                   this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode,
                                   this.mProgramDownscale, j, this);

        wpass.Create(rpass.type, this.mAudioContext);

        let numInputs = rpass.inputs.length;

        for (let i = 0; i < 4; i++)
        {
            wpass.NewTexture(this.mAudioContext, i, null, null, null);
        }
        for (let i = 0; i < numInputs; i++)
        {
            let lid  = rpass.inputs[i].channel;
            let styp = rpass.inputs[i].type;
            let sid  = rpass.inputs[i].id;
            let ssrc = rpass.inputs[i].filepath;
            let psrc = rpass.inputs[i].previewfilepath;
            let samp = rpass.inputs[i].sampler;

            wpass.NewTexture(this.mAudioContext, lid, { mType: styp, mID: sid, mSrc: ssrc, mSampler: samp, mPreviewSrc: psrc }, this.mBuffers, this.mCubeBuffers, this.mKeyboard);
        }

        for (let i = 0; i < 4; i++)
        {
            wpass.SetOutputs(i, null);
        }

        let numOutputs = rpass.outputs.length;
        for (let i = 0; i < numOutputs; i++)
        {
            let outputID = rpass.outputs[i].id;
            let outputCH = rpass.outputs[i].channel;
            wpass.SetOutputs(outputCH, outputID);
        }

        // create some hardcoded names. This should come from the DB
        let rpassName = "";
        if (rpass.type === "common" ) rpassName = "Common";
        if (rpass.type === "sound"  ) rpassName = "Sound";
        if (rpass.type === "image"  ) rpassName = "Image";
        if (rpass.type === "buffer") rpassName = "Buffer " + String.fromCharCode(65 + assetID_to_bufferID(wpass.mOutputs[0]));
        if (rpass.type === "cubemap") rpassName = "Cube A";// " + String.fromCharCode(65 + assetID_to_bufferID(this.mPasses[j].mOutputs[0]));
        wpass.SetName(rpassName);
        wpass.SetCode(rpass.code);

        this.mPasses.push(wpass);
    }
    return true;
}

Effect.prototype.CompileSome = function ( passes, preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    for (let j = 0; j < passes.length; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(passes[j], preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < me.mPasses.length; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.Compile = function (preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(j, preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < numPasses; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.GetCompilationTime = function( id )
{
    return this.mPasses[id].GetCompilationTime()/1000.0;
}
Effect.prototype.GetTotalCompilationTime = function()
{
    return this.mCompilationTime/1000.0;
}

Effect.prototype.DestroyPass = function( id )
{
   this.mPasses[id].Destroy( this.mAudioContext );
   this.mPasses.splice(id, 1);
}

Effect.prototype.AddPass = function( passType, passName, onResolve )
{
    let shaderStr = null;

    if( passType==="sound"   ) shaderStr = "vec2 mainSound( int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n}";
    if( passType==="buffer"  ) shaderStr = "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}";
    if( passType==="common"  ) shaderStr = "vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}";
    if( passType==="cubemap" ) shaderStr = "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rayDir;\n\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}";

    let id = this.GetNumPasses();
    this.mPasses[id] = new EffectPass( this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                       this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode, 
                                       this.mProgramDownscale, id, this );

    this.mPasses[id].Create( passType, this.mAudioContext );
    this.mPasses[id].SetName( passName );
    this.mPasses[id].SetCode( shaderStr );
    this.NewShader(id, false, function ()
    {
        onResolve();
    });

    return { mId : id, mShader : shaderStr };
}

// this should be removed once we have MultiPass 2.0 and passes render to arbitrary buffers
Effect.prototype.IsBufferPassUsed = function( bufferID )
{
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType !== "buffer" ) continue;
        if( this.mPasses[j].mOutputs[0] === bufferID_to_assetID(bufferID) ) return true;
    }
    return false;
}

Effect.prototype.Save = function()
{
    var result = {};

    result.ver = "0.1";

    result.renderpass = [];

    let numPasses = this.mPasses.length;
    for (let j=0; j<numPasses; j++ )
    {
        result.renderpass[j] = {};

        result.renderpass[j].outputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            let outputID = this.mPasses[j].mOutputs[i];
            if( outputID===null ) continue;
            result.renderpass[j].outputs.push( { channel: i, id: outputID } );
        }
        result.renderpass[j].inputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            if( this.mPasses[j].mInputs[i]===null ) continue;
            result.renderpass[j].inputs.push( {channel: i,
                                               type    : this.mPasses[j].mInputs[i].mInfo.mType,
                                               id      : this.mPasses[j].mInputs[i].mInfo.mID,
                                               filepath: this.mPasses[j].mInputs[i].mInfo.mSrc,
                                               sampler : this.mPasses[j].mInputs[i].mInfo.mSampler });
        }

        result.renderpass[j].code = this.mPasses[j].mSource;
        result.renderpass[j].name = this.mPasses[j].mName
        result.renderpass[j].description = "";
        result.renderpass[j].type = this.mPasses[j].mType;
    }

    result.flags = this.calcFlags();

    return result;
}

Effect.prototype.calcFlags = function ()
{
    let flagVR = false;
    let flagWebcam = false;
    let flagSoundInput = false;
    let flagSoundOutput = false;
    let flagKeyboard = false;
    let flagMultipass = false;
    let flagMusicStream = false;

    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        let pass = this.mPasses[j];

        if (pass.mType === "sound") flagSoundOutput = true;
        if (pass.mType === "buffer") flagMultipass = true;

        for (let i = 0; i < 4; i++)
        {
            if (pass.mInputs[i] === null) continue;

            if (pass.mInputs[i].mInfo.mType === "webcam") flagWebcam = true;
            else if (pass.mInputs[i].mInfo.mType === "keyboard") flagKeyboard = true;
            else if (pass.mInputs[i].mInfo.mType === "mic") flagSoundInput = true;
            else if (pass.mInputs[i].mInfo.mType === "musicstream") flagMusicStream = true;
        }

        let n1 = pass.mSource.indexOf("mainVR(");
        let n2 = pass.mSource.indexOf("mainVR (");
        if (n1 > 0 || n2 > 0) flagVR = true;
    }

    return {
        mFlagVR: flagVR,
        mFlagWebcam: flagWebcam,
        mFlagSoundInput: flagSoundInput,
        mFlagSoundOutput: flagSoundOutput,
        mFlagKeyboard: flagKeyboard,
        mFlagMultipass: flagMultipass,
        mFlagMusicStream: flagMusicStream
    };
}</script>
    <script>"use strict"

const kMaxCompileTime = 10.0;

function iReportCrash(shaderID)
{
    let req = new XMLHttpRequest();
    req.onload = function ()
    {
        let jsn = req.response;
        if (jsn === null) return;
        if (jsn.result === 0)
        {
            // yep
        }
    };
    req.open("POST", "/shadertoy", true);
    req.responseType = "json";
    req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    req.send( "s=" + shaderID + "&r=2" );
}
</script>
    <script>"use strict"

var gActive = -1;
var mShaders = [];
var gNumCanvases = 0;

function myrefresh( id, slot, img, forceFrame, gui, guiID, renderID, time )
{
    if( mShaders[id].mReady===false ) return;
    if( forceFrame )
    {
        if (mShaders[id].mScreenshot === false)
        {
            mShaders[id].gEffect.Paint(mShaders[id].mTime / 1000.0, 1.0 / 60.0, 60.0, 0, 0, 0, 0, false);
        }
    }
}

function startRendering()
{
    if( gActive<0 ) return;
    if( mShaders[gActive].mReady===false ) return;
    if( mShaders[gActive].mScreenshot===true ) return;

    let time = getRealTime();

    mShaders[gActive].mFPS.Count( time );
    mShaders[gActive].mTime = mShaders[gActive].mTime0 + (time - mShaders[gActive].mTo);
    let dtime = 1000.0/60.0;
    mShaders[gActive].gEffect.Paint( mShaders[gActive].mTime/1000.0, dtime/1000.0, mShaders[gActive].mFPS.GetFPS(), 0,0,0,0, false);

    requestAnimFrame( startRendering );
}

function iLoadAndCompile(jsn, i )
{
    var shaderObj = jsn[i];
    if (shaderObj === null) return;

    var resizeCB = function (xres, yres) { myrefresh(i, 0, null, true, false, 0, -1.0) };
    var crashCB = function () { alert('crash');/*iReportCrash(gShaderIDs[i])*/ };
    mShaders[i].gEffect = new Effect(null, null, mShaders[i].mPreview.mCanvas, myrefresh, i, true, true, resizeCB, crashCB);

    if (!mShaders[i].gEffect.Load(shaderObj)) return;

    mShaders[i].gEffect.Compile(false, function (worked)
    {
        if (worked === true)
        {
            previewShowRender(mShaders[i].mPreview);

            mShaders[i].mScreenshot = false;
            mShaders[i].mReady = true;
            mShaders[i].mTime = 10.0 * 1000.0;
            mShaders[i].mTime0 = 0.0;
            mShaders[i].mTo = 0.0;
            mShaders[i].mFPS = piCreateFPSCounter();
            mShaders[i].mPreview.mCanvas.addEventListener("mouseout", function (ev) { gActive = -1; }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseover", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.add('isVisible'); }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseout", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.remove('isVisible'); }, true);
            mShaders[i].mPreview.mCanvas.addEventListener("mouseover", function (ev)
            {
                let ele = piGetSourceElement(ev);
                if (ele.mId === undefined) return;

                gActive = ele.mId;
                if (!mShaders[gActive].mReady) return;
                let time = getRealTime();
                mShaders[gActive].mTo = time;
                mShaders[gActive].mTime0 = mShaders[gActive].mTime;
                mShaders[gActive].mFPS.Reset(time);

                startRendering();
            }, true);


            /*
            let compilationTime = mShaders[i].gEffect.GetTotalCompilationTime();
            if (compilationTime > kMaxCompileTime)
            {
                iReportCrash(mShaders[i].mShaderID);
            }*/

            myrefresh(i, null, null, true, false, 0, -1.0);
        }
        else
        {
            mShaders[i].mReady = false;
            previewShowError(mShaders[i].mPreview);
        }
    });
};


function iProcessShader( jsn, i )
{
    var shaderObj = jsn[i];
    if( shaderObj===null ) return;

    if ((shaderObj.info.usePreview === 0 && !gUseScreenshots) || (mShaders[i].mPreviewReady !== 1))
    {
        iLoadAndCompile(jsn, i);
    }
    else
    {
        mShaders[i].mScreenshot = true;
        if( shaderObj.info.usePreview === 1 )
            previewShowScreenshot(mShaders[i].mPreview, 1); // comp
        else if (gUseScreenshots)
            previewShowScreenshot(mShaders[i].mPreview, 2); // sett
    }

    if( i<(jsn.length-1) ) setTimeout( function(){iProcessShader(jsn,i+1);}, 10 );
}

function iInitUI(numCanvases, uiCallback, windowTitle)
{
    gNumCanvases = numCanvases;
    document.getElementById("mySearch").focus();

    //-----------------------------------------------------------------
    // window
    //-----------------------------------------------------------------
    if (windowTitle !== null) {
        document.title = windowTitle;
    }

    //-----------------------------------------------------------------
    // ui
    //-----------------------------------------------------------------
    var num = Math.min(gShaders.length, gNumCanvases);

    //var base = document.getElementsByClassName( "searchResult" );

    for (let i = 0; i < gNumCanvases; i++)
    {
        let pv = createPreview(i);

        if (i >= num) {
            previewHide(pv);
            continue;
        }

        let shaderID = gShaders[i].info.id;
        
        if (pv.mUI !== null && uiCallback !== null) {
            pv.mUI.addEventListener('click', function (ev) {
                uiCallback(shaderID);
                ev.preventDefault();
            }, false);
        }
        
        previewShowLoading(pv);
        
        mShaders[i] = {};
        mShaders[i].mShaderID = shaderID;
        mShaders[i].mPreview = pv;
        mShaders[i].mScreenshot = false;
        mShaders[i].mPreview.mLink.href = "/view/" + shaderID;
        mShaders[i].mPreviewReady = 0;
        mShaders[i].mReady = false;
        mShaders[i].gEffect = null;

        previewLoadScreenshot(mShaders[i].mPreview,
            function () { mShaders[i].mPreviewReady = 1; if (mShaders[i].mReady === false) previewShowScreenshot(mShaders[i].mPreview, 0); },
            function () { mShaders[i].mPreviewReady = 2; },
            shaderID);
    }

    if (num <= 0) {
        return;
    }
}

function iInitShaders(jsn)
{
    for (let i = 0; i < jsn.length; i++)
    {
        let shaderObj = jsn[i];
        if (shaderObj === null) continue;
        let inf = shaderObj.info;
        mShaders[i].mPreview.mTextA.textContent = inf.name;
        mShaders[i].mPreview.mTextB.innerHTML = "<a class='user' href='/user/" + htmlEntities(inf.username) + "'>" + htmlEntities(inf.username) + "</a>";
        mShaders[i].mPreview.mTextC.innerHTML = "<img src='/img/themes/" + gThemeName + "/views.png' class='viewsIcon'></img>" + inf.viewed + "    &nbsp;&nbsp;  <img src='/img/themes/" + gThemeName + "/likes.png' class='likesIcon'></img>" + inf.likes;
    }

    setTimeout(function () { iProcessShader(jsn, 0); }, 10);
}

function resultsInitStatic(numCanvases, uiCallback, windowTitle)
{
    iInitUI(numCanvases, uiCallback, windowTitle);

    iInitShaders(gShaders);
}

function resultsInit(numCanvases, uiCallback, windowTitle)
{	
    iInitUI(numCanvases, uiCallback, windowTitle);

    var num = Math.min(gShaderIDs.length, gNumCanvases);

    var mHttpReq = new XMLHttpRequest();

    mHttpReq.abort();

    var str = "{ \"shaders\" : [";
    for( let i=0; i<num; i++ )
    {
         str += "\"" + gShaderIDs[i] + "\"";
         if( i!==(num-1) ) str += ", ";
    }
    str += "] }";

    str = "s=" + encodeURIComponent( str ) + "&nt=0&nl=0&np=0";

    mHttpReq.open( "POST", "/shadertoy", true );
    mHttpReq.responseType = "json";
    mHttpReq.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    mHttpReq.onload = function ()
    {
        let jsn = this.response;
        if( jsn===null )
        {
            console.log( "Could not load shaders" );
            return;
        }

        iInitShaders(jsn);
    }
    mHttpReq.send( str );
}</script>
    <style>
    .shaderPreview
    {
    display: block;
    background-color: #000000;
    background-image: url("/img/loading.gif");
    background-repeat: no-repeat;
    background-position: center;
    padding: 0px;
    margin: 0px;
    border: 0px solid #000000;
    border-radius: 8px;
    width:100%;
    height:100%;
    position: absolute;
    overflow:hidden;
    }

    .previewInfo
    {
    width: 100%;
    left: 0px;
    top: 2px;
    position: relative;
    visibility: hidden;
    }

    .previewCanvas
    {
    left: 0px;
    top: 0px;
    padding: 0px;
    margin: 0px;
    position: absolute;
    cursor: pointer;
    width:100%;
    height:100%;
    border-radius: 8px;
    border: 0px solid #000000;
    backgroundColor: transparent;
visibility: hidden;
opacity:0;
transition: opacity 1.0s ease;
    }

    .previewText
    {
        text-overflow: ellipsis;
    white-space: nowrap;
    padding-right: 1px;
    }

    .previewTextUser
    {
    text-overflow: ellipsis;
    white-space: nowrap;
    padding-left: 3px;
    }

    .previewStats
    {
    padding-right: 1px;
    right: 0px;
    top: 0px;
    position: absolute;
    }

    .previewErrorContainer
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    visibility:hidden;
    }

    .previewErrorMessage
    {
    top:50%;
    position:absolute;
    width:100%;
    text-align:center;
    padding:0;
    margin:auto;
    color:#ff0000;
    font-size:2em;
    font-style:italic;
    }

    .previewNoGLContainter
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    position:absolute;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    pointer-events:none;
    visibility:hidden;
    font-size:2em;
    }

    .previewNoGLMessage
    {
    width:86%;
    height:90%;
    padding-left:7%;
    padding-right:7%;
    padding-top:10%;
    padding-bottom:0px;
    color:#ff0000;
    position:absolute;
    visibility:hidden;
    }

    .previewThumbnailContainer
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    visibility:hidden;
    border-radius:8px;
    border:0px solid #000000;
    }

    .previewThumbnailImage
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    border-radius:8px;
    border:0px solid #000000;
opacity: 0.0;
transition: opacity 1.0s ease;
    }

    .previewThumbnailIcon
    {
    width:64px;
    height:32px;
    left:0px;
    top:0px;
    padding:0px;
    padding-top:12px;
    margin:0px;
    position:absolute;
    color:#ffffff;
    background-color:#ff8020;
    font-weight:bold;
    border-radius:0px 0px 8px 0px;
    text-align:center;
    //visibility:hidden;
    }


    .previewUIContainter
    {
    display: block;
    right:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    //cursor:pointer;
    //pointer-events:none;
    //visibility:hidden;
    }
</style>

<script>
    function previewHide(me)
    {
    me.mBase.style.visibility = "hidden";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";
    }

    function previewShowRender(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "visible";
me.mCanvas.style.opacity = 1.0;
    me.mCanvas.style.borderRadius ="8px;";
//  me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    }

    function previewShowScreenshot(me, message)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "visible";
me.mThumbnailImg.style.opacity = 1.0;
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    me.mThumbnailWar1.style.visibility = (message===1)?"visible":"hidden";
    me.mThumbnailWar2.style.visibility = (message===2)?"visible":"hidden";
    }

    function previewShowLoading(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";

    me.mLink.style.visibility = "visible";
    me.mBase.style.backgroundColor = "#ff0000;"
    me.mCont.style.visibility = "visible";
    }

    function previewShowNoWebGL(me, shaderID)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "visible";
    me.mError.style.visibility = "visible";
    me.mThumbnailImgNoWebGL.onerror = function(ev) 
                                      { 
                                            me.mThumbnailImgNoWebGL.style.visibility="hidden"; 
                                            me.mMessageNoWebGL.style.visibility="visible"; 
                                      };
    me.mThumbnailImgNoWebGL.src = "/media/shaders/" + shaderID + ".jpg";
    }

    function previewShowError(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "visible";
    me.mCont.style.visibility = "visible";
    }

    function previewLoadScreenshot( me, cbSuccess, cbError, shaderID )
    {
    var url = "/media/shaders/" + shaderID + ".jpg";
    me.mThumbnailImg.onload = cbSuccess;
    me.mThumbnailImg.onerror = function(ev) { cbError(); };
    me.mThumbnailImg.src = url;
    }
        
    function createPreview(id)
    {
        var bar = document.getElementById( "Preview_"+id+"_Canvas" );
        bar.width = bar.offsetWidth;
        bar.height = bar.offsetHeight;
        bar.mId = id;

        return { mBase: document.getElementById( "Preview_"+id+"_Container" ),
        mLink: document.getElementById( "Preview_"+id+"_Link" ),
        mCanvas: bar,
        mCont: document.getElementById( "Preview_"+id+"_Info" ),
        mTextA: document.getElementById( "Preview_"+id+"_Text" ),
        mTextB: document.getElementById( "Preview_"+id+"_TextUser" ),
        mTextC: document.getElementById( "Preview_"+id+"_Stats" ),
        mNoWebGL: document.getElementById( "Preview_"+id+"_NoWebGL" ),
        mError: document.getElementById( "Preview_"+id+"_Error" ),
        mCanvas2D: document.getElementById( "Preview_"+id+"_Thumnail" ),
        mThumbnailImg: document.getElementById( "Preview_"+id+"_ThumnailImage" ),
        mThumbnailWar1: document.getElementById( "Preview_"+id+"_ThumnailWarning1" ),
        mThumbnailWar2: document.getElementById( "Preview_"+id+"_ThumnailWarning2" ),
        mThumbnailImgNoWebGL: document.getElementById( "Preview_"+id+"_ThumnailImageNoWebGL" ),
        mMessageNoWebGL: document.getElementById( "Preview_"+id+"_MessageNoWebGL"),
        mUI: document.getElementById( "Preview_"+id+"_UI" )
        };
    }
</script>

    <style>

    div#shaderGrid
    {
        width:100%;
        padding:0px;
        margin:0px;
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        grid-template-rows: repeat(3, 1fr);
        grid-column-gap: 64px;
        grid-row-gap: 24px;
    }
    .searchResult
    {
        margin: 0px;
        padding: 0px;
        width: 100%;
    }
    .searchResultContainer
    {
        width: 100%;
        padding-bottom:56.25%;
        height: 0;
        position: relative;
    }
    .navigation
    {
        display:flex;
        align-items:center;
    }
    div#navBottom
    {
        display:none;
        justify-content:center;
    }
    a.pageButtons, .pageButtonsCurrent
    {
        border-style: solid;
        border-width: 1px;
        border-color: #808080;
        text-align: center;
        vertical-align: middle;
        margin-left: 12px;
        display: inline-block;
        border-radius: 4px;
		font-weight:bold;
        cursor: pointer;
        padding-bottom:5px;
        padding-top:4px;
        padding-left: 8px;
        padding-right: 8px;
        margin:8px;
    }
    a.pageButtons
    {
        text-decoration: none;
        -moz-transition:    background-color 0.15s linear, color 0.15s linear;
        -webkit-transition: background-color 0.15s linear, color 0.15s linear;
        transition:         background-color 0.15s linear, color 0.15s linear;
    }
    a.pageButtons:hover
    {
      background-color:#808080;
      color : #ff8020;
    }
    .pageButtonsCurrent
    {
        background-color: #808080;
        color:#000000;
    }
    div#controls
    {
        width:100%;
        padding-top:16px;
        padding-bottom:16px;
        display:flex;
        justify-content:space-between; 
        flex-wrap:wrap;
    }
    div#controls > div
    {
        display:inline-flex;
    }
    .controlOptions
    {
        display:inline-block;
    }

    /* ----------------------- media resolutions ------------------------ */

    @media screen and (max-width:799px) 
    {
        div#shaderGrid  { grid-template-columns: 1fr; grid-template-rows: repeat(12, 1fr); grid-column-gap: 0px; grid-row-gap: 16px; }
        div#controls
        {
            width:100%;
            display:flex;
            justify-content:flex-start; 
            flex-wrap:wrap;
        }
        div#controls > div
        {
            display:inline-flex;
            width:100%;
            margin-left: 0px;
            margin-right: 0px;
            padding-bottom:16px;
        }
        div#navBottom
        {
            display: flex;
        }
    }
    
    </style>
    <script>
    var gShaders=[{"ver":"0.1","info":{"id":"4ddcRn","date":"1519502550","viewed":12390,"name":"stochastic path tracer v1","username":"otaviogood","description":"I tried my best to put the laws of physics into a shader. :) This has many material properties. Proper reflection \/ refraction. Filtered light rays, like in the red glass. Gold has rgb reflectance. Emission. Diffuse \/ specular. Sub surface scattering.","likes":161,"published":3,"flags":32,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/*--------------------------------------------------------------------------------------\nLicense CC0 - http:\/\/creativecommons.org\/publicdomain\/zero\/1.0\/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^This means do anything you want with this code. Because we are programmers, not lawyers.\n\nI tried to make a physically correct renderer as much as possible. For materials, it supports:\n- Proper reflection \/ refraction.\n- Filtered light rays like in the red glass.\n- Gold has rgb reflectance.\n- Emission.\n- Diffuse \/ specular.\n- Sub surface scattering, like in water.\n- Scattering in air or whereever for fog.\n\n- Support for ray traced and ray marched geometry in the same scene.\n- Antialiasing.\n\n-Otavio Good\n*\/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv=fragCoord.xy\/iResolution.xy;\n\tvec4 c=texture(iChannel0,uv);\n\tfragColor=vec4(sqrt((c.xyz*4096.0) \/ c.w), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"\/media\/a\/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"\/media\/ap\/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/*--------------------------------------------------------------------------------------\nLicense CC0 - http:\/\/creativecommons.org\/publicdomain\/zero\/1.0\/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^This means do anything you want with this code. Because we are programmers, not lawyers.\n\nI tried to make a physically correct renderer as much as possible. For materials, it supports:\n- Proper reflection \/ refraction.\n- Filtered light rays like in the red glass.\n- Gold has rgb reflectance.\n- Emission.\n- Diffuse \/ specular.\n- Sub surface scattering, like in water.\n- Scattering in air or whereever for fog.\n\n- Support for ray traced and ray marched geometry in the same scene.\n- Antialiasing.\n\n-Otavio Good\n*\/\n\n\/\/ Number of samples per pixel - bigger takes more compute\n#define NUM_SAMPLES 1\n\/\/ Number of times the ray bounces off things before terminating\n#define NUM_ITERS 7\n\n\/\/ ---- general helper functions \/ constants ----\n#define saturate(a) clamp(a, 0.0, 1.0)\nconst int BIG_INT = 2000000000;\nconst float PI=3.14159265;\nconst float farPlane = 1024.0;\n\nvec3 RotateX(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\/\/ Find 2 perpendicular vectors to the input vector.\nmat3 MakeBasis(vec3 normal) {\n\tmat3 result;\n    result[0] = normal;\n    if (abs(normal.y) > 0.5) {\n        result[1] = normalize(cross(normal, vec3(1.0, 0.0, 0.0)));\n    } else {\n        result[1] = normalize(cross(normal, vec3(0.0, 1.0, 0.0)));\n    }\n    result[2] = normalize(cross(normal, result[1]));\n    return result;\n}\n\n\n\/\/ ---- Hash functions ----\n\/\/ This is the single state variable for the random number generator.\nuint randomState = uint(123456789);\n\n\/\/ ---- Hash functions - deterministic ----\nfloat Hashf1i1(uint seed) {\n    \/\/ polynomial hashing thing\n    uint s2 = seed * seed;\n    uint s3 = s2 * seed;\n\n    uint a = (s2 * uint(60449) + uint(30011)) % uint(101159);\n    uint b = s3 * uint(4111) % uint(104729);\n    uint z = a ^ b;\n    return float(z & uint(0xffff)) \/ float(0xffff);  \/\/ Why this constant?\n}\nvec2 Hashf2i1(uint n) {\n    float a = Hashf1i1(n+uint(3));\n    float b = Hashf1i1(n+uint(11));\n    return vec2(a, b);\n}\nvec3 Hashf3i1(uint n) {\n    float a = Hashf1i1(n+uint(3));\n    float b = Hashf1i1(n+uint(11));\n    float c = Hashf1i1(n+uint(17));\n    return vec3(a, b, c);\n}\n\/\/ ---- Random functions use one state var to change things up ----\nuint GetRand() {\n    \/\/ simple xor shift random number generator https:\/\/en.wikipedia.org\/wiki\/Xorshift\n    randomState ^= randomState << 13;\n    randomState ^= randomState >> 17;\n    randomState ^= randomState << 5;\n    return randomState;\n}\n\/\/ Combine random state with integer polynomial hash function to get a random [0..1]\nfloat Randf1i1(uint seed) {\n    \/\/ simple xor shift random number generator https:\/\/en.wikipedia.org\/wiki\/Xorshift\n    randomState ^= randomState << 13;\n    randomState ^= randomState >> 17;\n    randomState ^= randomState << 5;\n\n    \/\/ polynomial hashing thing\n    uint s2 = seed * seed;\n    uint s3 = s2 * seed;\n\n    uint a = (s2 * uint(60449) + uint(30011)) % uint(101159);\n    uint b = s3 * uint(4111) % uint(104729);\n    uint z = a ^ b ^ randomState;\n    return float(z & uint(0xffff)) \/ float(0xffff);\n}\nvec3 Randf3i1(uint n) {\n    float a = Randf1i1(n);\n    float b = Randf1i1(n + uint(7));\n    float c = Randf1i1(n + uint(13));\n    return vec3(a, b, c);\n}\nvec2 Randf2i1(uint n) {\n    float a = Randf1i1(n + uint(3));\n    float b = Randf1i1(n + uint(11));\n    return vec2(a, b);\n}\n\/\/ Returns random number sampled from a circular gaussian distribution\n\/\/ https:\/\/en.wikipedia.org\/wiki\/Box%E2%80%93Muller_transform\nvec2 RandGaussian(uint n) {\n    vec2 u = Randf2i1(n);\n    u.x = max(u.x, 0.00000003); \/\/ We don't want log() to fail because it's 0.\n    float a = sqrt(-2.0 * log(u.x));\n    return vec2(a * cos(2.0*PI*u.y), a * sin(2.0 * PI * u.y));\n}\n\/\/ Randomly sample the lifetime of a ray moving through particles\nfloat RayLifetime(float p, uint seed) {\n    \/\/ p = prob. of collision with particle per unit distance traveled\n    if (p < 0.00000003) return farPlane;  \/\/ Lower than this and the math seems to fail.\n    float unif = Randf1i1(seed);  \/\/ uniform(0, 1)\n    \/\/ This random shouldn't be allowed to hit 0 because log() is undefined.\n    unif = max(0.00000000000001, unif);\n    \/\/ p can't be 0 because log(1) == 0 and it divides by 0. Can't be 1 because log(0) is undefined.\n    p = min(p, .999999);\n    \/\/float g = math.floor(math.log(unif) \/ math.log(1 - p))  # natural logs\n    \/\/ g = number of successes before failure\n    float g = log(unif) \/ log(1.0 - p);\n    return g;\n}\n\n\n\/\/ ---- noise functions ----\nfloat Hash1d(float u)\n{\n    return fract(sin(u)*143.9);\n}\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(sin(f)*110003.9);\n}\nfloat mixP(float f0, float f1, float a)\n{\n    return mix(f0, f1, a*a*(3.0-2.0*a));\n}\nconst vec2 zeroOne = vec2(0.0, 1.0);\nfloat noise2d(vec2 uv)\n{\n    vec2 fr = fract(uv.xy);\n    vec2 fl = floor(uv.xy);\n    float h00 = Hash2d(fl);\n    float h10 = Hash2d(fl + zeroOne.yx);\n    float h01 = Hash2d(fl + zeroOne);\n    float h11 = Hash2d(fl + zeroOne.yy);\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\n}\nfloat noise3d(vec3 uv)\n{\n    vec3 fr = fract(uv.xyz);\n    vec3 fl = floor(uv.xyz);\n    float h000 = Hash3d(fl);\n    float h100 = Hash3d(fl + zeroOne.yxx);\n    float h010 = Hash3d(fl + zeroOne.xyx);\n    float h110 = Hash3d(fl + zeroOne.yyx);\n    float h001 = Hash3d(fl + zeroOne.xxy);\n    float h101 = Hash3d(fl + zeroOne.yxy);\n    float h011 = Hash3d(fl + zeroOne.xyy);\n    float h111 = Hash3d(fl + zeroOne.yyy);\n    return mixP(\n        mixP(mixP(h000, h100, fr.x),\n             mixP(h010, h110, fr.x), fr.y),\n        mixP(mixP(h001, h101, fr.x),\n             mixP(h011, h111, fr.x), fr.y)\n        , fr.z);\n}\n\/\/ Random point *ON* sphere\n\/\/ Not sure which is faster - this function, or normalizing RandPointInSphere().\nvec3 RandPointOnSphere(uint seed) {\n    vec2 uv = Randf2i1(seed);\n    float theta = 2.0 * PI * uv.x;\n    float psi = acos(2.0 * uv.y - 1.0);\n    float x = cos(theta) * sin(psi);\n    float y = sin(theta) * sin(psi);\n    float z = cos(psi);\n    return vec3(x, y, z);\n}\n\/\/ Random point *IN* sphere\n\/\/ This is biased!!! About 1\/32 of the time, it will return a point in box instead of a sphere.\nvec3 RandPointInSphere(uint seed) {\n    return RandPointOnSphere(seed);\n    vec3 p = Randf3i1(seed) * 2.0 - 1.0;\n    if (length(p) <= 1.0) return p;\n    p = Randf3i1(seed) * 2.0 - 1.0;\n    if (length(p) <= 1.0) return p;\n    p = Randf3i1(seed) * 2.0 - 1.0;\n    if (length(p) <= 1.0) return p;\n    p = Randf3i1(seed) * 2.0 - 1.0;\n    if (length(p) <= 1.0) return p;\n    p = Randf3i1(seed) * 2.0 - 1.0;\n    if (length(p) <= 1.0) return p;\n    return p;\n}\n\n\/\/ ---- Environment maps ----\n\/\/ Make a procedural environment map with a giant softbox light and 4 lights around the sides.\nvec3 GetEnvMap2(vec3 rayDir)\n{\n    \/\/ fade bottom to top so it looks like the softbox is casting light on a floor\n    \/\/ and it's bouncing back\n    vec3 final = vec3(1.0) * dot(rayDir, vec3(0.0, 1.0, 0.0)) * 0.5 + 0.5;\n    final *= 0.125;\n    \/\/ overhead softbox, stretched to a rectangle\n    if ((rayDir.y > abs(rayDir.x)*1.0) && (rayDir.y > abs(rayDir.z*0.25))) final = vec3(2.0)*rayDir.y;\n    \/\/ fade the softbox at the edges with a rounded rectangle.\n    float roundBox = length(max(abs(rayDir.xz\/max(0.0,rayDir.y))-vec2(0.9, 4.0),0.0))-0.1;\n    final += vec3(0.8)* pow(saturate(1.0 - roundBox*0.5), 6.0);\n    \/\/ purple lights from side\n    final += vec3(8.0,6.0,7.0) * saturate(0.001\/(1.0 - abs(rayDir.x)));\n    \/\/ yellow lights from side\n    final += vec3(8.0,7.0,6.0) * saturate(0.001\/(1.0 - abs(rayDir.z)));\n    return vec3(final);\n}\n\n\/\/ Courtyard environment map texture with extra sky brightness for HDR look.\nvec3 GetEnvMap(vec3 rayDir) {\n    vec3 tex = texture(iChannel1, rayDir).xyz;\n    tex = tex * tex;  \/\/ gamma correct\n    vec3 light = vec3(0.0);\n    \/\/ overhead softbox, stretched to a rectangle\n    if ((rayDir.y > abs(rayDir.x+0.6)*0.29) && (rayDir.y > abs(rayDir.z*2.5))) light = vec3(2.0)*rayDir.y;\n    vec3 texp = pow(tex, vec3(14.0));\n    light *= texp;  \/\/ Masked into the existing texture's sky\n    return (tex + light*3.0)*1.0;\n}\n\nvec3 sunDir = normalize(vec3(0.93, 1.0, 1.0));\nconst vec3 sunCol = vec3(250.0, 220.0, 200.0) \/ 155.0;\nconst vec3 horizonCol = vec3(0.95, 0.9, 0.85)*1.0;\nconst vec3 skyCol = vec3(0.03,0.46,1.0)*0.9;\nconst vec3 groundCol = vec3(0.8,0.7,0.55)*1.1;\n\/\/ This function basically is a procedural environment map that makes the sun\nvec3 GetSunColorSmall(vec3 rayDir)\n{\n\tvec3 localRay = normalize(rayDir);\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\tfloat sunIntensity = 0.05 \/ dist;\n    sunIntensity += exp(-dist*150.0)*7000.0;\n\tsunIntensity = min(sunIntensity, 40000.0);\n\treturn sunCol * sunIntensity*0.002;\n}\n\n\/\/ Procedural desert environment map\nvec3 GetEnvMap3(vec3 rayDir)\n{\n    \/\/ fade the sky color, multiply sunset dimming\n    vec3 finalColor = mix(horizonCol, skyCol, pow(saturate(rayDir.y), 0.25))*0.95;\n    \/\/ make clouds - just a horizontal plane with noise\n    float n = noise2d(rayDir.xz\/rayDir.y*1.0);\n    n += noise2d(rayDir.xz\/rayDir.y*2.0)*0.5;\n    n += noise2d(rayDir.xz\/rayDir.y*4.0)*0.25;\n    n += noise2d(rayDir.xz\/rayDir.y*8.0)*0.125;\n    float nc = pow(abs(n), 3.0);\n    nc = nc * saturate(abs(rayDir.y * 4.0));  \/\/ fade clouds in distance\n\tfloat dist = 1.0 - (dot(rayDir, sunDir) * 0.5 + 0.5);\n    vec3 cloudCol = (vec3(1.0,0.6,0.2)\/dist*1.05+sunCol*1.0)*0.75*saturate((rayDir.y+0.2)*5.0);\n    finalColor = mix(finalColor, cloudCol, saturate(nc*0.0625));\n\n    \/\/ Background mountains\n    float n2 = noise2d(rayDir.xz * 8.0)*1.7;\n    n2 += noise2d(rayDir.xz * 16.0) * 0.5;\n    n2 += noise2d(rayDir.xz * 32.0) * 0.25;\n    n2 += noise2d(rayDir.xz * 64.0) * 0.125;\n    n2 += 1.5;\n    vec3 mountainCol = (horizonCol * 0.75 + skyCol * 0.25) * 0.6 - rayDir.y*2.0;\n    finalColor = mix(finalColor, mountainCol, saturate((n2*0.025-rayDir.y)*256.0));\n\n    \/\/ Foreground mountains\n    n2 = noise2d(-rayDir.xz * 8.0)*1.7;\n    n2 += noise2d(-rayDir.xz * 16.0) * 0.5;\n    n2 += noise2d(-rayDir.xz * 32.0) * 0.25;\n    n2 += noise2d(-rayDir.xz * 64.0) * 0.125;\n    n2 += 1.0;\n    mountainCol = (horizonCol * 0.95 + skyCol * 0.05) * 0.4;\n    finalColor = mix(finalColor, mountainCol, saturate((n2*0.0125-rayDir.y)*256.0));\n\n    \/\/ Ground color fade\n    n += noise2d(rayDir.xz\/rayDir.y*16.0)*0.35;\n    vec3 groundTex = groundCol - (n-1.25)*0.15;\n    finalColor = mix(finalColor, (groundTex)*0.9, saturate(-rayDir.y*164.0));\n\n    \/\/ add the sun\n    finalColor += GetSunColorSmall(rayDir);\n    return finalColor;\n}\n\n\/\/ ---- Ray intersection functions and data structures ----\nstruct RayHit\n{\n    vec3 hit;\n    vec3 norm;\n    float t;\n};\nRayHit NewRayHit()\n{\n    RayHit rh;\n    rh.t = farPlane;\n    rh.hit = vec3(0.0);\n    rh.norm = vec3(0.0);\n    return rh;\n}\nstruct Ray\n{\n    vec3 p0, dirNormalized;\n    int hash;\n    int outside;  \/\/ 1 ray is outside, -1 ray is inside, 0 terminate ray tracing iteration\n};\nstruct SceneHit\n{\n    vec3 hitPos;\n    vec3 hitNormal;\n    float t;\n    int objIndex;\n    int materialIndex;\n};\n\n\/\/ As the ray bounces, it records hits in these vars.\nstruct ColorHit {\n    vec3 diffuse;\n    vec3 emission;\n};\nColorHit colorHits[NUM_ITERS];\nint colorHitIndex;\nvoid ResetColorHitList() {\n    colorHitIndex = 0;\n    for (int i = 0; i < NUM_ITERS; i++) {\n        colorHits[i].emission.x = -1.0;\n    }\n}\nvoid SaveHit(in vec3 diffuse, in vec3 emission) {\n    colorHits[colorHitIndex] = ColorHit(diffuse, emission);\n    colorHitIndex++;\n}\n\n\/\/ dirVec MUST BE NORMALIZED FIRST!!!!\nfloat SphereIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 spherePos, float rad)\n{\n    vec3 radialVec = pos - spherePos;\n    float b = dot(radialVec, dirVecPLZNormalizeMeFirst);\n    float c = dot(radialVec, radialVec) - rad * rad;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    return -b - sqrt(h);\n}\n\n\/\/ outside is 1 to intersect from the outside of the sphere, -1 to intersect from inside of sphere.\nRayHit SphereIntersect3(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 spherePos, float rad, int outside)\n{\n    RayHit rh = NewRayHit();\n    vec3 delta = spherePos - pos;\n    float projdist = dot(delta, dirVecPLZNormalizeMeFirst);\n    vec3 proj = dirVecPLZNormalizeMeFirst * projdist;\n    vec3 bv = proj - delta;\n    float b2 = dot(bv, bv);\n    if (b2 > rad*rad) return rh;  \/\/ Ray missed the sphere\n    float x = sqrt(rad*rad - b2);\n    rh.t = projdist - (x * float(outside));\n    rh.hit = pos + dirVecPLZNormalizeMeFirst * rh.t;\n    rh.norm = normalize(rh.hit - spherePos);  \/\/ Normal still points outwards if collision from inside.\n    return rh;\n}\n\nvec3 ElementwiseEqual(in vec3 a, in float b) {\n\treturn abs(sign(a - b));\n}\n\n\/\/ https:\/\/tavianator.com\/fast-branchless-raybounding-box-intersections\/\nRayHit BoxIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 boxPos, vec3 rad, int outside)\n{\n    vec3 bmin = boxPos - rad;\n    vec3 bmax = boxPos + rad;\n    vec3 rayInv = 1.0 \/ dirVecPLZNormalizeMeFirst;\n\n    vec3 t1 = (bmin - pos) * rayInv;\n    vec3 t2 = (bmax - pos) * rayInv;\n\n    vec3 vmin = min(t1, t2);\n    vec3 vmax = max(t1, t2);\n\n    float tmin = max(vmin.z, max(vmin.x, vmin.y));\n    float tmax = min(vmax.z, min(vmax.x, vmax.y));\n    if (outside == -1) {\n        float temp = tmin;\n        tmin = tmax;\n        tmax = temp;\n    }\n\n    RayHit rh = NewRayHit();\n    \/\/rh.tMin = bignum;\n    \/\/rh.tMax = bignum;\n    if ((tmax <= tmin) || (tmin <= 0.0)) return rh;\n    rh.t = tmin;\n    \/\/rh.tMax = tmax;\n    rh.hit = pos + dirVecPLZNormalizeMeFirst * rh.t;\n    \/\/rh.hitMax = pos + dirVecPLZNormalizeMeFirst * rh.tMax;\n    \/\/ optimize me!\n    if (t1.x == tmin) rh.norm = vec3(-1.0, 0.0, 0.0);\n    if (t2.x == tmin) rh.norm = vec3(1.0, 0.0, 0.0);\n    if (t1.y == tmin) rh.norm = vec3(0.0, -1.0, 0.0);\n    if (t2.y == tmin) rh.norm = vec3(0.0, 1.0, 0.0);\n    if (t1.z == tmin) rh.norm = vec3(0.0, 0.0, -1.0);\n    if (t2.z == tmin) rh.norm = vec3(0.0, 0.0, 1.0);\n    \/\/rh.norm = ElementwiseEqual(t1, tmin) - ElementwiseEqual(t2, tmin);\n    \/\/ optimize me!\n    \/\/if (t1.x == tmax) rh.normMax = -vec3(-1.0, 0.0, 0.0);\n    \/\/if (t2.x == tmax) rh.normMax = -vec3(1.0, 0.0, 0.0);\n    \/\/if (t1.y == tmax) rh.normMax = -vec3(0.0, -1.0, 0.0);\n    \/\/if (t2.y == tmax) rh.normMax = -vec3(0.0, 1.0, 0.0);\n    \/\/if (t1.z == tmax) rh.normMax = -vec3(0.0, 0.0, -1.0);\n    \/\/if (t2.z == tmax) rh.normMax = -vec3(0.0, 0.0, 1.0);\n    \/\/rh.normMax = ElementwiseEqual(t1, tmax) - ElementwiseEqual(t2, tmax);\n    \/\/rh.norm *= float(outside);\n    \/\/rh.norm = normalize(rh.norm);\n    \/\/rh.normMax = ElementwiseEqual(t1, tmax) - ElementwiseEqual(t2, tmax);\n    \/\/rh.material = material;\n    return rh;\n}\n\n\/\/ ---- Scattering vars ----\n\/\/ Scattering needs a stack because it's all about what you're moving through.\n\/\/ So if you move through fog and then through glass, when you come out of the glass,\n\/\/ you're back into the fog.\n\n\/\/ This is the scatter var for the outer-most place. RGB diffuse, density.\nvec4 globalScatter = vec4(0.8, 0.8, 0.8, 0.0);\n\/\/ Scatter stack\nvec4 scatterStack[NUM_ITERS*2];  \/\/ Size correct?\nint scatterStackIndex;\nvoid PushScatter(in vec4 s) {\n    scatterStack[scatterStackIndex] = s;\n    scatterStackIndex++;\n}\nvec4 PopScatter() {\n    scatterStackIndex--;\n    return scatterStack[scatterStackIndex];\n}\nvec4 PeekScatter() {\n    return scatterStack[scatterStackIndex-1];\n}\nvoid InitScatterStack(in vec4 s) {\n    scatterStackIndex = 0;\n    PushScatter(s);\n}\n\n\/\/ ---- Materials ----\n\/\/ Linear reflectance values from http:\/\/blog.selfshadow.com\/publications\/s2012-shading-course\/hoffman\/s2012_pbs_physics_math_notes.pdf\n\/\/ In w, refrective index - https:\/\/en.wikipedia.org\/wiki\/List_of_refractive_indices\n\/\/ These can be calculated from each other: https:\/\/en.wikipedia.org\/wiki\/Schlick%27s_approximation\nconst vec4 refDebug = vec4(1.0,1.0,1.0, 1.005);\nconst vec4 refNone = vec4(0.0,0.0,0.0, 1.0);\nconst vec4 refWater = vec4(0.02,0.02,0.02, 1.330);\nconst vec4 refPlasticGlassLow = vec4(0.03,0.03,0.03, 1.42);\nconst vec4 refGlassWindow = vec4(0.043,0.043,0.043,1.52);\nconst vec4 refPlasticHigh = vec4(0.05,0.05,0.05, 1.58);\nconst vec4 refGlassHigh = vec4(0.08,0.08,0.08,1.79);  \/\/ Ruby\nconst vec4 refDiamond = vec4(0.172,0.172,0.172,2.417);\n\/\/ Metals - refractive index is placeholder and shouldn't be used I guess\nconst vec4 refIron = vec4(0.56,0.57,0.58,1.0);\nconst vec4 refCopper = vec4(0.95,0.64,0.54,1.0);\nconst vec4 refGold = vec4(1.0, 0.71, 0.29,1.0);\nconst vec4 refAluminum = vec4(0.91,0.92,0.92,1.0);\nconst vec4 refSilver = vec4(0.95,0.93,0.88,1.0);\n\nstruct Material {\n\tvec4 reflectRefract;\n    float refMult;\n    bool doRefraction;\n    vec3 diffuse;\n    vec3 emission;\n    vec3 filterDiffuseDensity;  \/\/ This is like a cheap scatter. Not sure I like it.\n    vec4 scatter;  \/\/ Diffuse in xyz, scatter probability in w.\n};\nconst int defaultMaterialIndex = 3;\nconst int NUM_MATERIALS = 7;\nMaterial materials[NUM_MATERIALS] = Material[NUM_MATERIALS](\n  Material(refWater, 1.0, true, vec3(1.0), vec3(0.0), vec3(1.0), vec4(0.3, 0.6, 0.6, 0.4)),\n  Material(refGlassWindow, 1.0, true, vec3(0.0), vec3(0.0), vec3(0.99, 0.2, 0.05), vec4(0.0)),\n  Material(refGold, 1.0, false, vec3(0.0), vec3(0.0), vec3(0.0), vec4(0.0)),\n  Material(refPlasticGlassLow, 1.0, false, vec3(0.1, 0.4, 0.6), vec3(0.0), vec3(0.0), vec4(0.0)),\n  Material(refPlasticGlassLow, 0.0, false, vec3(1.0), vec3(0.0), vec3(0.0), vec4(0.0)),\n  \/\/Material(refPlasticGlassLow, 1.0, false, vec3(1.0), vec3(0.0), vec3(0.0), vec4(0.0)),\n  Material(refNone, 1.0, false, vec3(0.0), vec3(14.0, 8.0, 3.0)*2.4, vec3(0.0), vec4(0.0)),\n  Material(refAluminum, 1.0, false, vec3(0.0), vec3(0.0), vec3(0.0), vec4(0.0))\n);\n\n\/\/ ---- Intersect the ray with the scene, ray-trace style ----\nSceneHit SceneIntersect(const in Ray ray) {\n    SceneHit result;\n    result.hitNormal = vec3(0.0);\n    result.t = farPlane;\n    result.objIndex = BIG_INT;\n    result.materialIndex = defaultMaterialIndex;\n    vec4 sA = vec4(0.0, 0.0, 0.75, 1.5);\n    for (int i = 0; i < 8; i++) {\n        sA.xyz = (Hashf3i1(uint(i+5)) - 0.5) * 12.0;\n        sA.y *= 0.5;\n        sA.y += 2.5;\n        \/\/sA.xyz += Randf1i1(uint(float(i)+iTime*60.0)) * sA.xyz * 0.93;\n        sA.w = (Hashf1i1(uint(i+23)) + 0.75) * 0.8251;\n        float tall = 0.25;\n        \/\/if ((i & 7) == 0) {\n        \/\/    sA.y += 2.0;\n        \/\/    sA.w *= 0.152;\n        \/\/    tall = 8.0*Hashf1i1(uint(i+23));\n        \/\/}\n        RayHit rh = SphereIntersect3(ray.p0, ray.dirNormalized, sA.xyz, sA.w, ray.outside);\n\t\t\/\/RayHit rh = BoxIntersect(ray.p0, ray.dirNormalized, sA.xyz, vec3(sA.w, sA.w*tall, sA.w), ray.outside);\n        if ((rh.t > 0.0) && (rh.t < result.t)) {\n            result.objIndex = i+27;\/\/3;\/\/ i&3;\n\t\t    result.materialIndex = (i&1)*4+1;\n            \/\/if ((i & 7) == 0) result.objIndex =4 + ((i\/8)&1);\n            result.t = rh.t;\n            result.hitPos = rh.hit;\n            result.hitNormal = rh.norm;\n        }\n    }\n    for (int i = 0; i < NUM_MATERIALS; i++) {\n        float alpha = float(i) \/ float(NUM_MATERIALS);\n        sA.xyz = vec3(sin(alpha * PI * 2.0), 0.0, cos(alpha * PI * 2.0)) * 5.05;\n        sA.y = -3.5;\n        sA.w = 1.0;\n        RayHit rh = SphereIntersect3(ray.p0, ray.dirNormalized, sA.xyz, sA.w, ray.outside);\n        if ((rh.t > 0.0) && (rh.t < result.t)) {\n            result.objIndex = i;\n\t\t    result.materialIndex = i+7;\n            result.t = rh.t;\n            result.hitPos = rh.hit;\n            result.hitNormal = rh.norm;\n        }\n    }\n    \/*RayHit rh = SphereIntersect3(ray.p0, ray.dirNormalized, vec3(0.0, -2.75, 0.0), 0.5, ray.outside);\n    if ((rh.t > 0.0) && (rh.t < result.t)) {\n        result.objIndex = 0;\n        result.materialIndex = 0;\n        result.t = rh.t;\n        result.hitPos = rh.hit;\n        result.hitNormal = rh.norm;\n    }*\/\n\n    return result;\n}\n\n\/\/ ---- Also support ray marching, not just ray tracing. ----\n\/\/ k should be negative. -4.0 works nicely.\n\/\/ smooth blending function\nfloat smin(float a, float b, float k)\n{\n\treturn log2(exp2(k*a)+exp2(k*b))\/k;\n}\n\/\/ min function that supports materials in the y component\nvec2 matmin(vec2 a, vec2 b)\n{\n    if (a.x < b.x) return a;\n    else return b;\n}\nvec2 matmax(vec2 a, vec2 b)\n{\n    if (a.x > b.x) return a;\n    else return b;\n}\n\/\/ signed box distance field\nfloat sdBox(vec3 p, vec3 radius)\n{\n  vec3 dist = abs(p) - radius;\n  return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(max(dist, 0.0));\n}\n\n\/\/ Noise generator from https:\/\/otaviogood.github.io\/noisegen\/\n\/\/ Params: 2D, Seed 1, Waves 6, Octaves 3, Smooth 1.25\nfloat NoiseGen(vec2 p) {\n    \/\/ This is a bit faster if we use 2 accumulators instead of 1.\n    \/\/ Timed on Linux\/Chrome\/TitanX Pascal\n    float wave0 = 0.0;\n    float wave1 = 0.0;\n    wave0 += sin(dot(p, vec2(-1.699, -1.719))) * 0.2639797486;\n    wave1 += sin(dot(p, vec2(3.196, -0.147))) * 0.1524620373;\n    wave0 += sin(dot(p, vec2(3.654, 3.161))) * 0.0761552832;\n    wave1 += sin(dot(p, vec2(1.047, 4.757))) * 0.0751807404;\n    wave0 += sin(dot(p, vec2(-4.889, 0.548))) * 0.0740187224;\n    wave1 += sin(dot(p, vec2(-5.403, -4.576))) * 0.0427534381;\n    return wave0+wave1;\n}\n\n\/\/ This is the distance function that defines the ray marched scene's geometry.\n\/\/ The input is a position in space.\n\/\/ outside is 1 if the ray is intersecting with the outside of objects, -1 for insides (backface)\n\/\/ The output is the distance to the nearest surface, and a material index\nvec2 DistanceToObject(vec3 p, int outside)\n{\n    \/\/float dist = p.y;\n    \/\/dist = length(p) - 1.4;\n    \/\/dist = smin(dist, length(p + vec3(2.25, -4.0, -4.0)) - 2.95, -0.95);\n    float dist = 1000000.0;\n    float noise = NoiseGen(p.xz*2.0)*0.1;\n\n    vec2 water = vec2(dist, 5.0);\n    \/\/water = matmin(water, vec2(length(p.xz + vec2(7.0, -5.0))-0.5, 3.0));\n    float cyl = length(vec2(p.y,abs(p.x)) + vec2(-5.5, -6.0)) - 0.5;\n    cyl = max(cyl, abs(p.z)-18.0);\n    \/\/water = matmin(water, vec2(cyl, 6.0));\n    float rad = length(p.xz)*4.0;\n    \/\/ Make water radial waves (computationally expensive)\n    noise = noise*0.4 -sin(rad)\/rad;\n    float waterBox = sdBox(p + vec3(0.0, 5.1+noise, 0.0), vec3(6.0, 0.5, 6.5));\n    waterBox = smin(waterBox, length(p+vec3(0.0,2.95,0.0))-0.6, -3.95);\n    water = matmin(water, vec2(waterBox, 0.0));\n    float pool = sdBox(p + vec3(3.0, 5., 0.0), vec3(3.0, 0.5, 6.5));\n    \/\/pool = max(pool, -(length(p.xz) - 4.0));\n    \/\/water = matmin(water, vec2(pool, 5.0));\n    \/\/water = matmin(water, vec2(sdBox(p + vec3(1.0, -6.1, 0.0), vec3(0.6, 0.1, 8.04)), 6.0));\n    \/\/water = matmin(water, vec2(sdBox(p + vec3(1.0, -6.15, 0.0), vec3(0.8, 0.1, 8.4)), 3.0));\n    \n    float room = -sdBox(p + vec3(0.0, 0.0, 0.0), vec3(18.0, 18.5, 18.0));\n    \/\/water = matmin(water, vec2(room, 2.0));\n\n    \/\/water = matmin(water, vec2(length(p+vec3(0.0,2.5,0.0))-0.5, 1.0));\n    \/\/water = matmin(water, vec2(length(p+vec3(2.0,3.6,6.0))-1.0, 3.0));\n\n    vec3 p2 = RotateX(p, -0.5) + vec3(0.0, -0.0, 0.0);\n    float d = sdBox(p2, vec3(4.0,2.0,4.0));\n    d = max(d, p2.y+(p2.x * p2.x + p2.z*p2.z) * 0.3);\n    \/\/water = matmin(water, vec2(d, 2.0));\n\n    return water * vec2(float(outside), 1.0);\n}\n\nSceneHit SceneMarch(const in Ray ray) {\n    SceneHit result;\n    result.hitNormal = vec3(0.0);\n    \/\/result.t = farPlane;\n    result.objIndex = BIG_INT;\n    result.materialIndex = defaultMaterialIndex;\n    vec2 distAndMat = vec2(0.0, -1.0);  \/\/ Distance and material\n\t\/\/ ----------------------------- Ray march the scene ------------------------------\n\tconst float maxDepth = 48.0; \/\/ farthest distance rays will travel\n    const float smallVal = 0.0625*0.125;\n\tresult.t = 0.0;\/\/ smallVal*1.0 * float(ray.outside);\n    const float safety = 0.975;\n    \/\/ First, escape if we are touching a surface already.\n    \/\/ Get the ray out of the negative part of the distance field. (rough hack)\n    float jump = smallVal;\n    for (int i = 0; i < 16; i++) {\n        \/\/ Step along the ray.\n        result.hitPos = (ray.p0 + ray.dirNormalized * result.t);\n        distAndMat = DistanceToObject(result.hitPos, ray.outside);\n\n        if (abs(distAndMat.x) >= smallVal) break;\n        \/\/ move down the ray a safe amount\n        result.t += jump;\/\/safety;\/\/* float(ray.outside);\n        \/\/result.t += distAndMat.x*2.0;\/\/safety;\/\/* float(ray.outside);\n        jump *= 2.0;  \/\/ This is not super good. Fix me eventually.\n        if (result.t > maxDepth) break;\n    }\n\t\/\/ ray marching time\n    for (int i = 110; i >= 0; i--)\t\/\/ This is the count of the max times the ray actually marches.\n    {\n        \/\/ Step along the ray.\n        result.hitPos = (ray.p0 + ray.dirNormalized * result.t);\n        \/\/ This is _the_ function that defines the \"distance field\".\n        \/\/ It's really what makes the scene geometry. The idea is that the\n        \/\/ distance field returns the distance to the closest object, and then\n        \/\/ we know we are safe to \"march\" along the ray by that much distance\n        \/\/ without hitting anything. We repeat this until we get really close\n        \/\/ and then break because we have effectively hit the object.\n        distAndMat = DistanceToObject(result.hitPos, ray.outside);\n\n        \/\/ If we are very close to the object, let's call it a hit and exit this loop.\n        if (abs(distAndMat.x) < smallVal) break;\n        \/\/ move down the ray a safe amount\n        result.t += distAndMat.x*safety;\n        if (i == 0) result.t = maxDepth+0.01;\n        if (result.t > maxDepth) break;\n    }\n\n\t\/\/ --------------------------------------------------------------------------------\n\t\/\/ If a ray hit an object, calculate the normal and save the hit info.\n    if ((result.t <= maxDepth) && (result.t > 0.0))\n\t{\n        float dist = distAndMat.x;\n        \/\/ calculate the normal from the distance field. The distance field is a volume, so if you\n        \/\/ sample the current point and neighboring points, you can use the difference to get\n        \/\/ the normal.\n        vec3 smallVec = vec3(smallVal, 0, 0);\n        \/\/ Normals still point out even if we're on the inside.\n        float mid = DistanceToObject(result.hitPos, 1).x;\n        vec3 normalU = vec3(mid - DistanceToObject(result.hitPos - smallVec.xyy, 1).x,\n                           mid - DistanceToObject(result.hitPos - smallVec.yxy, 1).x,\n                           mid - DistanceToObject(result.hitPos - smallVec.yyx, 1).x);\n        result.hitNormal = normalize(normalU);\n        result.objIndex = int(distAndMat.y);\n        result.materialIndex = int(distAndMat.y);\n\t}\n    else\n    {\n        \/\/ Our ray trace hit nothing. Set object index to big int.\n        result.hitNormal = vec3(0.0);\n        result.t = farPlane;\n        result.objIndex = BIG_INT;\n        result.materialIndex = BIG_INT;\n    }\n    return result;\n}\n\n\/\/ ---- Main ray trace function ----\n\/\/ Trace a ray, hit, apply material, save hit, and return the bounced ray\nRay TraceOneRay(const in Ray ray) {\n    vec3 diffuse = vec3(1.0);\n    vec3 emission = vec3(0.0);\n\n    \/\/ Send a ray out into the scene. Combine both ray marching and ray tracing.\n    Ray newRay;\n    newRay.hash = ray.hash + 389;\n    newRay.outside = ray.outside;\n    SceneHit resultA = SceneIntersect(ray);\n    SceneHit resultB = SceneMarch(ray);\n    SceneHit result;\n    \/\/ Take closest hit.\n    if (resultA.t < resultB.t) {\n        result = resultA;\n    } else {\n        result = resultB;\n    }\n\n    vec4 currentScatter = PeekScatter();\n    Material material = materials[result.materialIndex % materials.length()];\n    \/\/ Calculate how far the ray goes before hitting a random scattering particle.\n    float lifetime = RayLifetime(currentScatter.w, uint(ray.hash + 257));\n    if (result.t < min(farPlane, lifetime)) {\n\n        \/\/ Debug normal visualization\n        \/\/emission = result.hitNormal * 0.5 + 0.5;\n        \/\/newRay.outside = 0;\n        \/\/SaveHit(diffuse, emission);\n        \/\/return newRay;\n\n        \/\/mat3 basis = MakeBasis(result.hitNormal);\n        newRay.p0 = result.hitPos;\n\n        vec4 refMaterial = material.reflectRefract;\n        float reflectance = material.refMult;\n        float fresnel = refMaterial.z;\n        \/\/ If reflectance is different for different wavelengths, then let's change from\n        \/\/ rgb to r, g, or b stochastically while not losing energy. So we will end up\n        \/\/ tracing a ray representing a single wavelength of light.\n        \/\/ This can be done unconditionally because if xyz are the same, it doesn't matter anyway.\n        float choice = Randf1i1(uint(ray.hash+257));\n        if ((refMaterial.x != refMaterial.y) || (refMaterial.y != refMaterial.z)) {\n            \/\/ If we have already split to single wavelength, don't do it again.\n            if ( ((refMaterial.x == 0.0) && (refMaterial.y == 0.0)) ||\n                ((refMaterial.y == 0.0) && (refMaterial.z == 0.0)) ||\n                ((refMaterial.z == 0.0) && (refMaterial.x == 0.0)) ) {\n                \/\/ Take the non-zero component as the fresnel value.\n                fresnel = dot(refMaterial.xyz, vec3(1.0));\n            } else {\n                \/\/ .333 chance of switching to each single channel - r, g, or b.\n                if (choice < 0.33333) {\n                    fresnel = refMaterial.x;\n                    diffuse *= vec3(1.0, 0.0, 0.0);\n                } else if (choice < 0.66666) {\n                    fresnel = refMaterial.y;\n                    diffuse *= vec3(0.0, 1.0, 0.0);\n                } else diffuse *= vec3(0.0, 0.0, 1.0);\n                diffuse *= 3.0;  \/\/ To make up for stochastically dropping 2 out of 3 channels\n            }\n        }\n        \/\/ Schlick's approximation\n        float oneMinusCos = 1.0 - saturate(dot(ray.dirNormalized, -result.hitNormal* float(ray.outside)));\n        float reflectProb = fresnel + (1.0-fresnel) * pow(oneMinusCos, 5.0);\n        reflectProb *= reflectance;\n        if (Randf1i1(uint(abs(ray.hash))) < reflectProb) {\n            \/\/ reflect\n\t        vec3 reflection = reflect(ray.dirNormalized, result.hitNormal);\/\/ * float(ray.outside));\n            newRay.dirNormalized = normalize(reflection);\n            \/\/ Already did the probability of reflection before, so no need to multiply anything.\n            \/\/diffuse *= vec3(1.0);\n        } else {\n            if (material.doRefraction) {\n                \/\/ refract\n                \/\/ todo: check total internal reflection\n                float refractionIndex = 1.0 \/ refMaterial.w;  \/\/ 1.33 is water, 1.5 is glass.\n                if (ray.outside == -1) refractionIndex = 1.0 \/ refractionIndex;\n                vec3 refraction = refract(ray.dirNormalized, result.hitNormal * float(ray.outside), refractionIndex);\n                newRay.dirNormalized = normalize(refraction);\n                if (ray.outside == 1) {\n                    PushScatter(material.scatter);\n                } else {\n                    PopScatter();\n                }\n                newRay.outside = -ray.outside;\n                \/\/if (ray.outside == -1) diffuse.g *= 4.0;\/\/ DEBUGDEBUG******************\n            } else {\n                \/\/ Diffuse light\n                \/\/ Get a random vector in the hemisphere pointing along the normal.\n\t            vec3 rand = RandPointOnSphere(uint(ray.hash));\n                vec3 bounce = rand * sign(dot(result.hitNormal, rand));\n                newRay.dirNormalized = bounce;\n                \/\/ Lambert shading model\n                float intensity = dot(bounce, result.hitNormal);\n                diffuse *= material.diffuse;\/\/ * intensity;\n                emission = material.emission;\n                if (result.materialIndex == 5) {\n                    \/\/ checkerboard because it's a ray tracer. :)\n                    \/\/diffuse *= float((int(newRay.p0.x+8.0) & 1) ^ (int(newRay.p0.y+8.0) & 1) ^ (int(newRay.p0.z+8.0) & 1) ) * 0.2 + 0.8;\n                }\n                if (result.materialIndex == 3) {\n\t            \tdiffuse = max(Hashf3i1(uint(result.objIndex*17)), vec3(0.2))*0.75;\n                }\n                \/\/emission = pow(Hashf3i1(uint(result.objIndex*5)), vec3(55.0)) * 150.0;\n                \/\/emission += emission.yzx * 0.904;\n                \/\/emission += emission.zxy * 0.91;\n            }\n\n        }\n    } else {\n        if (lifetime < farPlane) {\n            \/\/ Scattering\n            newRay.p0 = ray.p0 + ray.dirNormalized * lifetime;\n            newRay.dirNormalized = RandPointOnSphere(uint(ray.hash+211));\n            diffuse *= currentScatter.xyz;\n        } else {\n            emission = GetEnvMap(ray.dirNormalized);\n            newRay.outside = 0;  \/\/ This terminates the ray.\n        }\n    }\n    \/\/ Filtering\n    \/\/vec3 internal = Hashf3i1(uint(result.objIndex))*0.3+0.7;\n    vec3 internal = material.filterDiffuseDensity.xyz;\n    \/\/ Filter proportional to how long the ray moves inside the object\n    \/\/ This can also be done with scattering, but this should converge quicker.\n    if (ray.outside == -1) diffuse *= pow(internal, vec3(abs(result.t)));\n\n    \/\/ Save the ray hit in a list so we can calculate color of the pixel later on.\n    SaveHit(diffuse, emission);\n    return newRay;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uint randomState = uint(123456789);\n    vec2 position = ( gl_FragCoord.xy \/ iResolution.xy );\n    \/\/ read original buffer so we can accumulate pixel values into back it.\n\tvec4 backpixel = texture(iChannel0, position);\n    \/\/ If we use the mouse to change the view, reset the pixel accumulation buffer\n    if (iMouse.z > 0.0) backpixel = vec4(0.0);\n\n\t\/\/ ---------------- First, set up the camera rays for ray marching ----------------\n\tvec2 uv_orig = fragCoord.xy\/iResolution.xy * 2.0 - 1.0;\n    float zoom = 1.7;\n    vec2 uv = uv_orig \/ zoom;\n\n\t\/\/ Camera up vector.\n\tvec3 camUp=vec3(0,1,0);\n\n\t\/\/ Camera lookat.\n\tvec3 camLookat=vec3(0,-2.25,0);\n\n    \/\/ camera orbit with mouse movement\n    float mx=iMouse.x\/iResolution.x*PI*2.0-0.7;\/\/ + Randf1i1(uint(iTime*360.0))*0.51; \/\/ + iTime*3.1415 *0.666*0.0625*0.0625;\n\tfloat my=-iMouse.y\/iResolution.y*10.0;\/\/ - sin(iTime * 0.31)*0.5;\/\/*PI\/2.01;\n\tvec3 camPos = vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(12.2);\n    \/\/ If mouse is in bottom left corner, then use pre-set camera angle.\n    if ((dot(iMouse.xy, vec2(1.0)) <= 8.0)) camPos = vec3(12.0, 0.0, 2.0);\n\n\t\/\/ Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\n\tvec3 upNorm=cross(camVec, sideNorm);\n\tvec3 worldFacing=(camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x\/iResolution.y) + uv.y * upNorm;\n\tvec3 rayVec = normalize(worldPix - camPos);\n\n\t\/\/ --------------------------------------------------------------------------------\n    vec3 colorSum = vec3(0.0);\n    \/\/ Loop through for a few samples and average the pixel colors from ray tracing.\n    for (int s = 0; s < NUM_SAMPLES; s++) {\n        InitScatterStack(globalScatter);\n        ResetColorHitList();\n        Ray ray;\n        ray.outside = 1;\n        ray.p0 = camPos;\n        \/\/ Anti-aliasing: Randomly jitter the ray direction by a gaussian distribution.\n        vec2 gauss = RandGaussian(uint(iTime*60.0));\n        float antialias = dFdx(uv.xy).x\/1.5;\n        ray.dirNormalized = normalize(rayVec +\n                                      sideNorm*gauss.x*antialias +\n                                      upNorm * gauss.y*antialias);\n\n        \/\/ Make a hash value for the ray so we can get random numbers\n        int width = int(iResolution.x);\n        int height = int(iResolution.y);\n        ray.hash = int(fragCoord.x) + int(fragCoord.y) * width + s * width*height +\n            int(iTime*60.0)*width*height*NUM_SAMPLES;\n        ray.hash ^= int(GetRand());\n        \/\/ THIS MAKES IT NON-DETERMINISTIC, but seeds the random better.\n        ray.hash += int(iDate.w*60.0);\n\n        \/\/ Trace a ray from the camera outwards, bounce the ray off objects and keep\n        \/\/ tracing until NUM_ITERS or until it hits the background.\n        for (int i = 0; i < NUM_ITERS; i++) {\n            if (i == (NUM_ITERS-1)) break;\n            ray = TraceOneRay(ray);\n            if (ray.outside == 0) break;\n        }\n        \/*int i = 0;\n        do {\n            ray = TraceOneRay(ray);\n            i++;\n        } while ((ray.outside != 0) && (i < NUM_ITERS-1));*\/\n\n        \/\/ Once we're done iterating through rays from the camera outwards, we have a\n        \/\/ list of hits. Now we can go from the light source toward the camera and apply\n        \/\/ the color filters and emissions as we go.\n\t    vec4 finalColor = vec4(0.0, 0.0, 0.0, 0.0);\n        for (int i = NUM_ITERS-1; i >= 0; i--) {\n            if (colorHits[i].emission.x != -1.0) {\n                finalColor.xyz *= colorHits[i].diffuse;\n                finalColor.xyz += colorHits[i].emission;\n                \/\/finalColor.xyzw = finalColor.yzwx;  \/\/ Debug ray depth\n            }\n        }\n        colorSum += finalColor.xyz;\n    }\n    colorSum \/= float(NUM_SAMPLES);\n\n    \/\/ output the final color\n\tfragColor = vec4(saturate(colorSum\/4096.0),1.0) + backpixel;\n}\n\n\n","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"WdyGzy","date":"1570410707","viewed":12376,"name":"Lattice Boltzmann ","username":"wyatt","description":"It's really cool that you can represent a fluid as just up down left right energy","likes":253,"published":3,"flags":32,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ LENS FLAIR EFFECT\n#define R iResolution.xy\n#define T(U) texture(iChannel0,(U)\/R)\nvec4 F (vec2 U,vec2 r) {\n\tvec4 t = T(U+r);\n    return exp(-.01*dot(r,r))*(exp(2.*t)-1.);\n}\nvoid mainImage( out vec4 Q, vec2 U )\n{\n   \n   Q = vec4(0);\n    for (float i = 0.; i < 7.; i+=1.1) {\n    \tQ += F(U,+vec2(-i,i));\n    \tQ += F(U,+vec2(i,i));\n    \tQ += F(U,-vec2(-i,i));\n    \tQ += F(U,-vec2(i,i));\n    }\n    Q = T(U)*0.15+ 1e-5*Q;\n    Q = atan(Q);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"\/media\/previz\/buffer03.png","previewfilepath":"\/media\/previz\/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ FLUID EVOLUTION\n#define R iResolution.xy\n#define T(U) texture(iChannel0,(U)\/R)\n#define D(U) texture(iChannel1,(U)\/R)\n#define B(U) texture(iChannel2,(U)\/R)\n\/\/ Velocity\nvec2 v (vec4 b) {\n\treturn vec2(b.x-b.y,b.z-b.w);\n}\n\/\/ Pressure\nfloat p (vec4 b) {\n\treturn 0.25*(b.x+b.y+b.z+b.w);\n}\n\/\/ TRANSLATE COORD BY Velocity THEN LOOKUP STATE\nvec4 A(vec2 U) {\n    U-=.5*v(T(U));\n    U-=.5*v(T(U));\n\treturn T(U);\n}\nvoid mainImage( out vec4 Q, in vec2  U)\n{\n    \/\/ THIS PIXEL\n    Q = A(U);\n    \/\/ NEIGHBORHOOD\n    vec4 \n        n = A(U+vec2(0,1)),\n        e = A(U+vec2(1,0)),\n        s = A(U-vec2(0,1)),\n        w = A(U-vec2(1,0));\n    \/\/ GRADIENT of PRESSURE\n    float px = 0.25*(p(e)-p(w));\n    float py = 0.25*(p(n)-p(s)); \n    \n    \t\t\/\/ boundary Energy exchange in :   \n    Q += 0.25*(n.w + e.y + s.z + w.x)\n        \t\/\/ boundary Energy exchange out :\n        \t-p(Q)\n        \t\/\/ dV\/dt = dP\/dx,  dEnergy In dTime = dEnergy in dSpace\n        \t-vec4(px,-px,py,-py);\n    \n    \/\/ get value from picture buffer\n    float z = .8-length(B(U).xyz);\n    \/\/ some kind of viscolsity thing \n    Q = mix(mix(Q,0.25*(n+e+s+w),.01),vec4(p(Q)),.01*(1.-z));\n    \/\/ gravity polarizes energy! pretty cool imo\n    Q.zw -= 0.001*z*vec2(1,-1);\n    \/\/ Init with no velocity and some pressure\n    if (iFrame < 1||(iMouse.z>0.&&length(U-iMouse.xy)<R.y\/5.)) Q = vec4(.2);\n    \/\/ At boundarys turn all kinetic energy into potential energy\n    if(U.x<3.||R.x-U.x<3.||U.y<3.||R.y-U.y<3.)Q = vec4(p(Q));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"\/media\/previz\/buffer03.png","previewfilepath":"\/media\/previz\/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\/\/ TRANSLATE LOCATION FIELD WITH v(A(coord)), INIT WITH FragCoord\n#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)\/R)\n#define d(U) texture(iChannel1,(U)\/R)\n#define C(U) texture(iChannel2,(U)\/R)\nvec2 v (vec4 b) {\n\treturn vec2(b.x-b.y,b.z-b.w);\n}\nvec4 D(vec2 U) {\n    U-=.5*v(A(U));\n    U-=.5*v(A(U));\n\treturn d(U);\n}\nvoid mainImage( out vec4 Q, in vec2  U)\n{\n    Q = D(U);\n    \n    vec4 \n        q = A(U),\n        n = A(U+vec2(0,1)),\n        e = A(U+vec2(1,0)),\n        s = A(U-vec2(0,1)),\n        w = A(U-vec2(1,0)),\n        N = D(U+vec2(0,1)),\n        E = D(U+vec2(1,0)),\n        S = D(U-vec2(0,1)),\n        W = D(U-vec2(1,0));\n    Q += 0.25*((n.w-q.z)*(N-Q) + (e.y-q.x)*(E-Q) + (s.z-q.w)*(S-Q) + (w.x-q.y)*(W-Q));\n    \n    if (iFrame < 1||(iMouse.z>0.&&length(U-iMouse.xy)<R.y\/5.)) Q = vec4(U,0,0);\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[{"id":"4sfGRn","filepath":"\/media\/a\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"\/media\/ap\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"\/media\/previz\/buffer03.png","previewfilepath":"\/media\/previz\/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/\/ LOOK UP PICTURE IN LOCATION FROM BUFFER D\n#define R iResolution.xy\n#define T(U) texture(iChannel0,(U)\/R)\n#define D(U) texture(iChannel1,(U)\/R)\nvoid mainImage( out vec4 Q, vec2 U )\n{\n    Q = texture(iChannel2,D(U).xy\/R);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\/\/ Lighting on Buffer B\n#define R iResolution.xy\n#define T(U) texture(iChannel0,(U)\/R)\n\nvoid mainImage( out vec4 Q, vec2 U )\n{\n   Q =  1.2-2.2*T(U);\n    Q.xyz = Q.xyz+.5*normalize(Q.xyz);\n   float\n       n = length(T(U+vec2(0,1))),\n       e = length(T(U+vec2(1,0))),\n       s = length(T(U-vec2(0,1))),\n       w = length(T(U-vec2(1,0)));\n    vec3 no = normalize(vec3(e-w,n-s,1));\n    float d = dot(reflect(no,vec3(0,0,1)),normalize(vec3(1)));\n    Q *= 8.*exp(-3.*d*d);\n}","name":"Buffer C","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"XdfGz8","date":"1362046351","viewed":12364,"name":"pyroclastic explosion","username":"simesgreen","description":"explosion with pyroclastic noise","likes":151,"published":1,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[],"code":"\/\/ volume explosion shader\n\/\/ simon green \/ nvidia 2012\n\/\/ http:\/\/developer.download.nvidia.com\/assets\/gamedev\/files\/gdc12\/GDC2012_Mastering_DirectX11_with_Unity.pdf\n\n\/\/ sorry, port from HLSL!\n#define float3 vec3\n#define float4 vec4\n\n\/\/ parameters\n\/\/ be nice if we had sliders for these!\nconst int _MaxSteps = 64;\nconst float _StepDistanceScale = 0.5;\nconst float _MinStep = 0.001;\nconst float _DistThreshold = 0.005;\n\nconst int _VolumeSteps = 32;\nconst float _StepSize = 0.02; \nconst float _Density = 0.1;\n\nconst float _SphereRadius = 0.5;\nconst float _NoiseFreq = 4.0;\nconst float _NoiseAmp = -0.5;\nconst float3 _NoiseAnim = float3(0, -1, 0);\n\n\/\/ iq's nice integer-less noise function\n\n\/\/ matrix to rotate the noise octaves\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    p = m*p*2.02; f += 0.03125*abs(noise( p ));\t\n    return f\/0.9375;\n}\n\n\n\/\/ distance field stuff\nfloat sphereDist(float3 p, float4 sphere)\n{\n    return length(p - sphere.xyz) - sphere.w;\n}\n\n\/\/ returns signed distance to nearest surface\n\/\/ displace is displacement from original surface (0, 1)\nfloat distanceFunc(float3 p, out float displace)\n{\t\n\t\/\/float d = length(p) - _SphereRadius;\t\/\/ distance to sphere\n\tfloat d = length(p) - (sin(iTime*0.25)+0.5);\t\/\/ animated radius\n\t\n\t\/\/ offset distance with pyroclastic noise\n\t\/\/p = normalize(p) * _SphereRadius;\t\/\/ project noise point to sphere surface\n\tdisplace = fbm(p*_NoiseFreq + _NoiseAnim*iTime);\n\td += displace * _NoiseAmp;\n\t\n\treturn d;\n}\n\n\/\/ calculate normal from distance field\nfloat3 dfNormal(float3 pos)\n{\n    float eps = 0.001;\n    float3 n;\n    float s;\n#if 0\n    \/\/ central difference\n    n.x = distanceFunc( float3(pos.x+eps, pos.y, pos.z), s ) - distanceFunc( float3(pos.x-eps, pos.y, pos.z), s );\n    n.y = distanceFunc( float3(pos.x, pos.y+eps, pos.z), s ) - distanceFunc( float3(pos.x, pos.y-eps, pos.z), s );\n    n.z = distanceFunc( float3(pos.x, pos.y, pos.z+eps), s ) - distanceFunc( float3(pos.x, pos.y, pos.z-eps), s );\n#else\n    \/\/ forward difference (faster)\n    float d = distanceFunc(pos, s);\n    n.x = distanceFunc( float3(pos.x+eps, pos.y, pos.z), s ) - d;\n    n.y = distanceFunc( float3(pos.x, pos.y+eps, pos.z), s ) - d;\n    n.z = distanceFunc( float3(pos.x, pos.y, pos.z+eps), s ) - d;\n#endif\n\n    return normalize(n);\n}\n\n\/\/ color gradient \n\/\/ this should be in a 1D texture really\nfloat4 gradient(float x)\n{\n\tconst float4 c0 = float4(4, 4, 4, 1);\t\/\/ hot white\n\tconst float4 c1 = float4(1, 1, 0, 1);\t\/\/ yellow\n\tconst float4 c2 = float4(1, 0, 0, 1);\t\/\/ red\n\tconst float4 c3 = float4(0.4, 0.4, 0.4, 4);\t\/\/ grey\n\t\n\tfloat t = fract(x*3.0);\n\tfloat4 c;\n\tif (x < 0.3333) {\n\t\tc =  mix(c0, c1, t);\n\t} else if (x < 0.6666) {\n\t\tc = mix(c1, c2, t);\n\t} else {\n\t\tc = mix(c2, c3, t);\n\t}\n\t\/\/return float4(x);\n\t\/\/return float4(t);\n\treturn c;\n}\n\n\/\/ shade a point based on position and displacement from surface\nfloat4 shade(float3 p, float displace)\n{\t\n\t\/\/ lookup in color gradient\n\tdisplace = displace*1.5 - 0.2;\n\tdisplace = clamp(displace, 0.0, 0.99);\n\tfloat4 c = gradient(displace);\n\t\/\/c.a *= smoothstep(1.0, 0.8, length(p));\n\t\n\t\/\/ lighting\n\tfloat3 n = dfNormal(p);\n\tfloat diffuse = n.z*0.5+0.5;\n\t\/\/float diffuse = max(0.0, n.z);\n\tc.rgb = mix(c.rgb, c.rgb*diffuse, clamp((displace-0.5)*2.0, 0.0, 1.0));\n\t\n\t\/\/return float4(float3(displace), 1);\n\t\/\/return float4(dfNormal(p)*float3(0.5)+float3(0.5), 1);\n\t\/\/return float4(diffuse);\n\t\/\/return gradient(displace);\n\treturn c;\n}\n\n\/\/ procedural volume\n\/\/ maps position to color\nfloat4 volumeFunc(float3 p)\n{\n\tfloat displace;\n\tfloat d = distanceFunc(p, displace);\n\tfloat4 c = shade(p, displace);\n\treturn c;\n}\n\n\/\/ sphere trace\n\/\/ returns hit position\nfloat3 sphereTrace(float3 rayOrigin, float3 rayDir, out bool hit, out float displace)\n{\n\tfloat3 pos = rayOrigin;\n\thit = false;\n\tdisplace = 0.0;\t\n\tfloat d;\n\t\/\/float3 hitPos;\n\tfloat disp;\n\tfor(int i=0; i<_MaxSteps; i++) {\n\t\td = distanceFunc(pos, disp);\n        \tif (d < _DistThreshold) {\n\t\t\thit = true;\n\t\t\tdisplace = disp;\n\t\t\t\/\/hitPos = pos;\n        \t\t\/\/break;\t\/\/ early exit from loop doesn't work in ES?\n        \t}\n\t\t\/\/d = max(d, _MinStep);\n\t\tpos += rayDir*d*_StepDistanceScale;\n\t}\n\t\n\treturn pos;\n\t\/\/return hitPos;\n}\n\n\n\/\/ ray march volume from front to back\n\/\/ returns color\nfloat4 rayMarch(float3 rayOrigin, float3 rayStep, out float3 pos)\n{\n\tfloat4 sum = float4(0, 0, 0, 0);\n\tpos = rayOrigin;\n\tfor(int i=0; i<_VolumeSteps; i++) {\n\t\tfloat4 col = volumeFunc(pos);\n\t\tcol.a *= _Density;\n\t\tcol.a = min(col.a, 1.0);\n\t\t\n\t\t\/\/ pre-multiply alpha\n\t\tcol.rgb *= col.a;\n\t\tsum = sum + col*(1.0 - sum.a);\t\n#if 0\n\t\t\/\/ exit early if opaque\n        \tif (sum.a > _OpacityThreshold)\n            \t\tbreak;\n#endif\t\t\n\t\tpos += rayStep;\n\t}\n\treturn sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy \/ iResolution.xy;\n    vec2 p = q*2.0-1.0;\n    p.x *= iResolution.x \/ iResolution.y;\n\t\n    float rotx = (iMouse.y \/ iResolution.y)*4.0;\n    float roty = 0.2*iTime - (iMouse.x \/ iResolution.x)*4.0;\n\t\n    \/\/ camera\n    vec3 ro = 2.0*normalize(vec3(cos(roty), cos(rotx), sin(roty)));\n    vec3 ww = normalize(vec3(0.0,0.0,0.0) - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    \/\/ sphere trace distance field\n    bool hit;\n    float displace;\n    vec3 hitPos = sphereTrace(ro, rd, hit, displace);\n\n    vec4 col = vec4(0, 0, 0, 1);\n    if (hit) {\n\t\t\/\/ shade\n   \t\tcol = shade(hitPos, displace);\t\/\/ opaque version\n\t\t\/\/col = rayMarch(hitPos, rd*_StepSize, hitPos);\t\/\/ volume render\n    }\n\n    fragColor = col;\n}\n","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"MsXGzM","date":"1365838258","viewed":12361,"name":"Voronoi - rocks","username":"iq","description":"3D Voronoi (very slow!)","likes":92,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"\/media\/a\/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"\/media\/ap\/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Copyright Inigo Quilez, 2013 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work neither\n\/\/ as it is or altered, here on Shadertoy or anywhere else, in any\n\/\/ form including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it or train a neural\n\/\/ network with it without permission. I share this Work for educational\n\/\/ purposes, and you can link to it, through an URL, proper attribution\n\/\/ and unmodified screenshot, as part of your educational material. If\n\/\/ these conditions are too restrictive please contact me and we'll\n\/\/ definitely work it out.\n\n\nfloat fbm( vec3 p, vec3 n )\n{\n\tp *= 0.15;\n    n = abs(n);\n\tfloat x = texture( iChannel3, p.yz ).x;\n\tfloat y = texture( iChannel3, p.zx ).x;\n\tfloat z = texture( iChannel3, p.xy ).x;\n\n\treturn (x*n.x + y*n.y + z*n.z);\n}\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\nvec3 random3f( vec3 p )\n{\n#if 1\n\treturn textureLod( iChannel0, (p.xy + vec2(3.0,1.0)*p.z+0.5)\/256.0, 0.0 ).xyz;\n#else\n    return fract(sin(vec3( dot(p,vec3(1.0,57.0,113.0)), \n                           dot(p,vec3(57.0,113.0,1.0)),\n                           dot(p,vec3(113.0,1.0,57.0))))*43758.5453);\n#endif\t\n}\nvec3 voronoi( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + random3f( p + b );\n        float d = dot( r, r );\n\n        if( d < res.x )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            res = vec2( d, res.x );\t\t\t\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n\nvec3 map( in vec3 p )\n{\n\tvec3 q = vec3( 4.0*fract(0.5+p.x\/4.0)-2.0, p.y, 4.0*fract(0.5+p.z\/4.0)-2.0 );\n\tvec2 id = floor( 0.5+p.xz\/4.0 );\n    q.xz += 0.5*(-1.0+2.0*vec2(hash(id.x+113.0*id.y),hash(13.0*id.x+57.0*id.y)));\n\tq.y -= 0.5;\n\tfloat d1 = length(q) - 1.0;\n\n\tfloat d2 = p.y;\n    d1 = min( d1, d2 );\n\td1 = min( d1, length(q.xz)-0.1 );\n#if 0\n    return vec3( d1, 1.0, 0.0 );\n#else\n\tfloat h = 0.5+0.5*clamp(1.0-p.y,0.0,1.0);\n\t\/\/p.y += 0.2*iTime;\n\tvec3 v = voronoi(2.0*p);\n\tfloat f = clamp( 3.5*(v.y-v.x), 0.0, 1.0 );\n\td1 -= 0.2*f*h;\n\t\n    return vec3( 0.5*d1, mix(1.0,f,h), v.z );\n#endif\t\n}\n\nfloat map2( in vec3 p )\n{\n\tvec3 q = vec3( 4.0*fract(0.5+p.x\/4.0)-2.0, p.y, 4.0*fract(0.5+p.z\/4.0)-2.0 );\n\tvec2 id = floor( 0.5+p.xz\/4.0 );\n    q.xz += 0.5*(-1.0+2.0*vec2(hash(id.x+113.0*id.y),hash(13.0*id.x+57.0*id.y)));\n\tq.y -= 0.5;\n\n\treturn length(q.xz) - 1.1;\n\n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n\tfloat maxd = 20.0;\n\tfloat precis = 0.0001;\n    float h = 1.0;\n    float t = 0.0;\n    float m = -1.0;\n\tfloat o = 0.0;\n    for( int i=0; i<64; i++ )\n    {\n        if( h<(precis*t)||t>maxd ) break;\n        t += h;\n\t    vec3 res = map( ro+rd*t );\n        h = res.x;\n\t\to = res.y;\n\t    m = res.z;\n    }\n\n    if( t>maxd ) m=-1.0;\n    return vec3( t, o, m );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.0001,0.0,0.0);\n\n\treturn normalize( vec3(\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n}\n\nfloat calcCurvature( in vec3 pos, in vec3 nor )\n{\n\tfloat totao = 0.0;\n    for( int aoi=0; aoi<4; aoi++ )\n    {\n\t\tvec3 aopos = normalize(hash3(float(aoi)*213.47));\n\t\taopos = aopos - dot(nor,aopos)*nor;\n\t\taopos = pos + aopos*0.05;\n        float dd = clamp( map( aopos ).x*300.0, 0.0, 1.0 );\n        totao += dd;\n    }\n\t\n    return smoothstep( 0.2, 1.0, totao\/4.0 );\n}\n\nvec3 doBumpMap( in vec3 pos, in vec3 nor, float amount )\n{\n    float e = 0.001;\n    float b = 0.01;\n    \n\tfloat ref = fbm( 48.0*pos, nor );\n    vec3 gra = -b*vec3( fbm(48.0*vec3(pos.x+e, pos.y, pos.z),nor)-ref,\n                        fbm(48.0*vec3(pos.x, pos.y+e, pos.z),nor)-ref,\n                        fbm(48.0*vec3(pos.x, pos.y, pos.z+e),nor)-ref )\/e;\n\n\tamount *= 0.2 + 0.8*smoothstep( 0.3, 0.45, fbm(4.0*pos,nor) );\n\n\tvec3 tgrad = gra - nor * dot ( nor , gra );\n    return normalize ( nor - amount*tgrad );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy \/ iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x\/iResolution.y;\n    vec2 m = iMouse.xy\/iResolution.xy;\n\t\n    \/\/ camera\n    float r2 = p.x*p.x*0.32 + p.y*p.y;\n    p *= 0.5 + 0.5*(7.0-sqrt(37.5-11.5*r2))\/(r2+1.0);\n\tfloat an = 0.04*iTime - 7.0*m.x;\n    vec3 ro = 3.1*normalize(vec3(sin(an),0.1+0.6-0.4*m.y, cos(an)));\n    vec3 ta = vec3( 0.0, 0.75, 0.0 );\n\tfloat rl = 0.5*sin(0.35*an);\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(rl),cos(rl),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n\t\/\/ render\n    vec3 col = vec3(0.0);\n\n\t\/\/ raymarch\n    vec3 tmat = intersect(ro,rd);\n    if( tmat.z>-0.5 )\n    {\n        \/\/ geometry\n        vec3  pos = ro + tmat.x*rd;\n        vec3  nor = calcNormal(pos);\n        float cur = calcCurvature(pos,nor);\n\n\t\t\/\/ occlusion (rock to rock)\n\t\tfloat occ = clamp(pow(tmat.y,5.0)*3.0,0.0,1.0);\n\t\t\/\/ occlusion (between balls and floor)\n\t\tif( pos.y<0.2 ) \n\t\t\tocc *= clamp( map2(pos), 0.0, 0.6 )\/0.6;\n\t\telse\n\t\t    occ *= clamp((pos.y-0.2)\/1.2,0.0,1.0);\n\t\t\n        \/\/ material\n\t\tvec3 qpos = pos;\n\t\t\/\/qpos.y += 0.2*iTime;\n\t\tvec3 snor = nor;;\n\t\tnor = doBumpMap( 0.2*qpos, nor, 0.5 );\n\t\tvec4 mate = vec4(0.7,0.57,0.5,1.0);\n\t\tmate.xyz *= fbm( 15.0*qpos, nor );\n\t\tmate.xyz += 0.08*sin( tmat.z*10.0 + vec3(0.0,0.5,1.0) );\n\t\tmate.xyz *= 0.8 + 0.4*hash(tmat.z);\n\t\tmate *= smoothstep( 0.0, 1.0, fbm( 4.0*qpos, nor ) );\n        float ru = cur*smoothstep( 0.4, 0.7, fbm(4.0*qpos,snor) );\n        mate = mix( mate, vec4(1.4,1.3,1.2,0.0), ru );\n        vec3 green = 0.5*vec3(0.4,0.25,0.0);\n\t\tgreen += 0.025*sin( 10.0*texture(iChannel3,0.03*qpos.xz).x + vec3(3.0,1.0,2.0) );\n\t\tmate.xyz = mix( mate.xyz, green, smoothstep(0.7,1.0,nor.y)*smoothstep(0.4,0.5,fbm( 0.1*qpos.zyx, nor ))*smoothstep(0.1,0.9,fbm( 10.0*qpos.zyx, nor )) );\n\t\t\n\t\t\/\/ lighting\n        float amb = clamp(0.4+0.6*nor.y,0.0,1.0);\n        float spe = pow(clamp(dot(-rd,nor),0.0,1.0),16.0);\n\t\tcol = mate.xyz*2.0*amb*(0.05+0.95*occ) + mate.w*spe*occ*vec3(0.8);\n\t    col *= vec3(1.0,1.0,0.95);\n\n        \/\/ fog\n\t\tcol *= 3.0*exp( -0.4*tmat.x );\n\t}\n\n\t\/\/ gamma\n\tcol = pow( col, vec3(0.45) );\n\n\t\/\/ vigneting\n\tcol *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.15 );\n\n    fragColor = vec4( col,1.0 );\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"ldX3zr","date":"1360969163","viewed":12305,"name":"Hypnotic ripples","username":"Cha","description":"Hypnotic ripples... yah...  usefeul comment sorry... XDD\nSimple shader to start doing sth.","likes":112,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec2 center = vec2(0.5,0.5);\nfloat speed = 0.035;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float invAr = iResolution.y \/ iResolution.x;\n\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n\t\t\n\tvec3 col = vec4(uv,0.5+0.5*sin(iTime),1.0).xyz;\n   \n     vec3 texcol;\n\t\t\t\n\tfloat x = (center.x-uv.x);\n\tfloat y = (center.y-uv.y) *invAr;\n\t\t\n\t\/\/float r = -sqrt(x*x + y*y); \/\/uncoment this line to symmetric ripples\n\tfloat r = -(x*x + y*y);\n\tfloat z = 1.0 + 0.5*sin((r+iTime*speed)\/0.013);\n\t\n\ttexcol.x = z;\n\ttexcol.y = z;\n\ttexcol.z = z;\n\t\n\tfragColor = vec4(col*texcol,1.0);\n}\n\n\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"lt3BW2","date":"1541047763","viewed":12302,"name":"Combination SDF","username":"iq","description":"The three basic boolean operations that help combine shape, in discrete and smooth form. BEWARE these operators produce a bound to the real SDF of the final shape, so they will slow down your raymarcher.","likes":90,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ The MIT License\n\/\/ Copyright \u00a9 2018 Inigo Quilez\n\/\/ Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\/\/ Smooth vs sharp boolean operations for combining shapes\n\n\/\/ Related techniques:\n\/\/\n\/\/ Elongation  : https:\/\/www.shadertoy.com\/view\/Ml3fWj\n\/\/ Rounding    : https:\/\/www.shadertoy.com\/view\/Mt3BDj\n\/\/ Onion       : https:\/\/www.shadertoy.com\/view\/MlcBDj\n\/\/ Metric      : https:\/\/www.shadertoy.com\/view\/ltcfDj\n\/\/ Combination : https:\/\/www.shadertoy.com\/view\/lt3BW2\n\/\/ Repetition  : https:\/\/www.shadertoy.com\/view\/3syGzz\n\/\/ Extrusion2D : https:\/\/www.shadertoy.com\/view\/4lyfzw\n\/\/ Revolution2D: https:\/\/www.shadertoy.com\/view\/4lyfzw\n\/\/\n\/\/ More information here: https:\/\/iquilezles.org\/articles\/distfunctions\n\n\nfloat opUnion( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opIntersection( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25\/k;\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    return -opSmoothUnion(d1,-d2,k);\n    \n    \/\/float h = max(k-abs(-d1-d2),0.0);\n    \/\/return max(-d1, d2) + h*h*0.25\/k;\n}\n\nfloat opSmoothIntersection( float d1, float d2, float k )\n{\n    return -opSmoothUnion(-d1,-d2,k);\n\n    \/\/float h = max(k-abs(d1-d2),0.0);\n    \/\/return max(d1, d2) + h*h*0.25\/k;\n}\n\n\/\/-------------------------------------------------\n\nfloat sdSphere( in vec3 p, in float r )\n{\n    return length(p)-r;\n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) - r;\n}\n\n\/\/---------------------------------\n\nfloat map(in vec3 pos)\n{\n    float d = 1e10;\n    \n    \n    float an = sin(iTime);\n\n    \/\/ opUnion\n    {\n    vec3 q = pos - vec3(-2.0,0.0,-1.3);\n    float d1 = sdSphere( q-vec3(0.0,0.5+0.3*an,0.0), 0.55 );\n    float d2 = sdRoundBox(q, vec3(0.6,0.2,0.7), 0.1 ); \n    float dt = opUnion(d1,d2);\n    d = min( d, dt );\n  \t}\n    \n    \/\/ opSmoothUnion\n    {\n    vec3 q = pos - vec3(-2.0,0.0,1.0);\n    float d1 = sdSphere( q-vec3(0.0,0.5+0.3*an,0.0), 0.55 );\n    float d2 = sdRoundBox(q, vec3(0.6,0.2,0.7), 0.1 ); \n    float dt = opSmoothUnion(d1,d2, 0.25);\n    d = min( d, dt );\n    }\n\n\n    \/\/ opSubtraction\n    {\n    vec3 q = pos - vec3(0.0,0.0,-1.3);\n    float d1 = sdSphere( q-vec3(0.0,0.5+0.3*an,0.0), 0.55 );\n    float d2 = sdRoundBox(q, vec3(0.6,0.2,0.7), 0.1 ); \n    float dt = opSubtraction(d1,d2);\n    d = min( d, dt );\n    }\n\n    \/\/ opSmoothSubtraction\n    {\n    vec3 q = pos - vec3(0.0,0.0,1.0);\n    float d1 = sdSphere( q-vec3(0.0,0.5+0.3*an,0.0), 0.55 );\n    float d2 = sdRoundBox(q, vec3(0.6,0.2,0.7), 0.1 ); \n    float dt = opSmoothSubtraction(d1,d2, 0.25);\n    d = min( d, dt );\n    }\n\n    \/\/ opIntersection\n    {\n    vec3 q = pos - vec3(2.0,0.0,-1.3);\n    float d1 = sdSphere( q-vec3(0.0,0.5+0.3*an,0.0), 0.55 );\n    float d2 = sdRoundBox(q, vec3(0.6,0.2,0.7), 0.1 ); \n    float dt = opIntersection(d1,d2);\n    d = min( d, dt );\n    }\n    \n    \/\/ opSmoothIntersection\n    {\n    vec3 q = pos - vec3(2.0,0.0,1.0);\n    float d1 = sdSphere( q-vec3(0.0,0.5+0.3*an,0.0), 0.55 );\n    float d2 = sdRoundBox(q-vec3(0.0,0.5,0.0), vec3(0.6,0.2,0.7), 0.1 ); \n    float dt = opSmoothIntersection(d1,d2, 0.25);\n    d = min( d, dt );\n    }\n\n    return d;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    const float ep = 0.0001;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep ) );\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\n{\n\tfloat res = 1.0;\n    float t = tmin;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, k*h\/t );\n        t += clamp( h, 0.02, 0.20 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        \/\/ pixel coordinates\n        vec2 o = vec2(float(m),float(n)) \/ float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))\/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)\/iResolution.y;\n        #endif\n \n        vec3 ro = vec3(0.0,4.0,8.0);\n        vec3 rd = normalize(vec3(p-vec2(0.0,1.8),-3.5));\n\n        float t = 7.0;\n        for( int i=0; i<64; i++ )\n        {\n            vec3 p = ro + t*rd;\n            float h = map(p);\n            if( abs(h)<0.001 || t>11.0 ) break;\n            t += h;\n        }\n\n        vec3 col = vec3(0.0);\n\n        if( t<11.0 )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            vec3  lig = normalize(vec3(1.0,0.8,-0.2));\n            float dif = clamp(dot(nor,lig),0.0,1.0);\n            float sha = calcSoftshadow( pos, lig, 0.001, 1.0, 16.0 );\n            float amb = 0.5 + 0.5*nor.y;\n            col = vec3(0.05,0.1,0.15)*amb + \n                  vec3(1.00,0.9,0.80)*dif*sha;\n        }\n\n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot \/= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"XljGDz","date":"1428379120","viewed":12276,"name":"Protophore","username":"otaviogood","description":"I put together this fractal and then watched some tutorials on how to light sports cars for photography. I think the key is to get the giant softbox up top with just the right fade at the edges. I also ray march 1 reflection.","likes":228,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[],"code":"\/*--------------------------------------------------------------------------------------\nLicense CC0 - http:\/\/creativecommons.org\/publicdomain\/zero\/1.0\/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^This means do anything you want with this code. Because we are programmers, not lawyers.\n\n-Otavio Good\n*\/\n\n\/\/ Number of times the fractal repeats\n#define RECURSION_LEVELS 4\n\/\/ Animation splits the sphere in different directions\n\/\/ This ended up running a significantly slower fps and not looking very different. :(\n\/\/#define SPLIT_ANIM\n\nfloat localTime = 0.0;\nfloat marchCount;\n\nfloat PI=3.14159265;\n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvec3 RotateX(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\n\n\/*vec3 GetEnvColor(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 tex = texture(iChannel0, rayDir).xyz;\n\ttex = tex * tex;\t\/\/ gamma correct\n    return tex;\n}*\/\n\n\/\/ This is a procedural environment map with a giant overhead softbox,\n\/\/ 4 lights in a horizontal circle, and a bottom-to-top fade.\nvec3 GetEnvColor2(vec3 rayDir, vec3 sunDir)\n{\n    \/\/ fade bottom to top so it looks like the softbox is casting light on a floor\n    \/\/ and it's bouncing back\n    vec3 final = vec3(1.0) * dot(-rayDir, sunDir) * 0.5 + 0.5;\n    final *= 0.125;\n    \/\/ overhead softbox, stretched to a rectangle\n    if ((rayDir.y > abs(rayDir.x)*1.0) && (rayDir.y > abs(rayDir.z*0.25))) final = vec3(2.0)*rayDir.y;\n    \/\/ fade the softbox at the edges with a rounded rectangle.\n    float roundBox = length(max(abs(rayDir.xz\/max(0.0,rayDir.y))-vec2(0.9, 4.0),0.0))-0.1;\n    final += vec3(0.8)* pow(saturate(1.0 - roundBox*0.5), 6.0);\n    \/\/ purple lights from side\n    final += vec3(8.0,6.0,7.0) * saturate(0.001\/(1.0 - abs(rayDir.x)));\n    \/\/ yellow lights from side\n    final += vec3(8.0,7.0,6.0) * saturate(0.001\/(1.0 - abs(rayDir.z)));\n    return vec3(final);\n}\n\n\/*vec3 GetEnvColorReflection(vec3 rayDir, vec3 sunDir, float ambient)\n{\n\tvec3 tex = texture(iChannel0, rayDir).xyz;\n\ttex = tex * tex;\n    vec3 texBack = texture(iChannel0, rayDir).xyz;\n    vec3 texDark = pow(texBack, vec3(50.0)).zzz;\t\/\/ fake hdr texture\n    texBack += texDark*0.5 * ambient;\n    return texBack*texBack*texBack;\n}*\/\n\nvec3 camPos = vec3(0.0), camFacing;\nvec3 camLookat=vec3(0,0.0,0);\n\n\/\/ polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)\/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 matMin(vec2 a, vec2 b)\n{\n\tif (a.x < b.x) return a;\n\telse return b;\n}\n\nfloat spinTime;\nvec3 diagN = normalize(vec3(-1.0));\nfloat cut = 0.77;\nfloat inner = 0.333;\nfloat outness = 1.414;\nfloat finWidth;\nfloat teeth;\nfloat globalTeeth;\n\nvec2 sphereIter(vec3 p, float radius, float subA)\n{\n    finWidth = 0.1;\n    teeth = globalTeeth;\n    float blender = 0.25;\n    vec2 final = vec2(1000000.0, 0.0);\n    for (int i = 0; i < RECURSION_LEVELS; i++)\n    {\n#ifdef SPLIT_ANIM\n        \/\/ rotate top and bottom of sphere opposite directions\n        p = RotateY(p, spinTime*sign(p.y)*0.05\/blender);\n#endif\n        \/\/ main sphere\n        float d = length(p) - radius*outness;\n#ifdef SPLIT_ANIM\n        \/\/ subtract out disc at the place where rotation happens so we don't have artifacts\n        d = max(d, -(max(length(p) - radius*outness + 0.1, abs(p.y) - finWidth*0.25)));\n#endif\n\n        \/\/ calc new position at 8 vertices of cube, scaled\n        vec3 corners = abs(p) + diagN * radius;\n        float lenCorners = length(corners);\n        \/\/ subtract out main sphere hole, mirrored on all axises\n        float subtracter = lenCorners - radius * subA;\n        \/\/ make mirrored fins that go through all vertices of the cube\n        vec3 ap = abs(-p) * 0.7071;\t\/\/ 1\/sqrt(2) to keep distance field normalized\n        subtracter = max(subtracter, -(abs(ap.x-ap.y) - finWidth));\n        subtracter = max(subtracter, -(abs(ap.y-ap.z) - finWidth));\n        subtracter = max(subtracter, -(abs(ap.z-ap.x) - finWidth));\n        \/\/ subtract sphere from fins so they don't intersect the inner spheres.\n        \/\/ also animate them so they are like teeth\n        subtracter = min(subtracter, lenCorners - radius * subA + teeth);\n        \/\/ smoothly subtract out that whole complex shape\n        d = -smin(-d, subtracter, blender);\n        \/\/vec2 sphereDist = sphereB(abs(p) + diagN * radius, radius * inner, cut);\t\/\/ recurse\n        \/\/ do a material-min with the last iteration\n        final = matMin(final, vec2(d, float(i)));\n\n#ifndef SPLIT_ANIM\n        corners = RotateY(corners, spinTime*0.25\/blender);\n#endif\n        \/\/ Simple rotate 90 degrees on X axis to keep things fresh\n        p = vec3(corners.x, corners.z, -corners.y);\n        \/\/ Scale things for the next iteration \/ recursion-like-thing\n        radius *= inner;\n        teeth *= inner;\n        finWidth *= inner;\n        blender *= inner;\n    }\n    \/\/ Bring in the final smallest-sized sphere\n    float d = length(p) - radius*outness;\n    final = matMin(final, vec2(d, 6.0));\n    return final;\n}\n\nvec2 DistanceToObject(vec3 p)\n{\n    vec2 distMat = sphereIter(p, 5.2 \/ outness, cut);\n    return distMat;\n}\n\n\/\/ dirVec MUST BE NORMALIZED FIRST!!!!\nfloat SphereIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 spherePos, float rad)\n{\n    vec3 radialVec = pos - spherePos;\n    float b = dot(radialVec, dirVecPLZNormalizeMeFirst);\n    float c = dot(radialVec, radialVec) - rad * rad;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    return -b - sqrt(h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    localTime = iTime - 0.0;\n\t\/\/ ---------------- First, set up the camera rays for ray marching ----------------\n\tvec2 uv = fragCoord.xy\/iResolution.xy * 2.0 - 1.0;\n    float zoom = 1.7;\n    uv \/= zoom;\n\n\t\/\/ Camera up vector.\n\tvec3 camUp=vec3(0,1,0);\n\n\t\/\/ Camera lookat.\n\tcamLookat=vec3(0,0.0,0);\n\n    \/\/ debugging camera\n    float mx=iMouse.x\/iResolution.x*PI*2.0-0.7 + localTime*3.1415 * 0.0625*0.666;\n\tfloat my=-iMouse.y\/iResolution.y*10.0 - sin(localTime * 0.31)*0.5;\/\/*PI\/2.01;\n\tcamPos += vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(12.2);\n\n\t\/\/ Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\n\tvec3 upNorm=cross(camVec, sideNorm);\n\tvec3 worldFacing=(camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x\/iResolution.y) + uv.y * upNorm;\n\tvec3 rayVec = normalize(worldPix - camPos);\n\n\t\/\/ ----------------------------------- Animate ------------------------------------\n    localTime = iTime*0.5;\n    \/\/ This is a wave function like a triangle wave, but with flat tops and bottoms.\n    \/\/ period is 1.0\n    float rampStep = min(3.0,max(1.0, abs((fract(localTime)-0.5)*1.0)*8.0))*0.5-0.5;\n    rampStep = smoothstep(0.0, 1.0, rampStep);\n    \/\/ lopsided triangle wave - goes up for 3 time units, down for 1.\n    float step31 = (max(0.0, (fract(localTime+0.125)-0.25)) - min(0.0,(fract(localTime+0.125)-0.25))*3.0)*0.333;\n\n    spinTime = step31 + localTime;\n    \/\/globalTeeth = 0.0 + max(0.0, sin(localTime*3.0))*0.9;\n    globalTeeth = rampStep*0.99;\n    cut = max(0.48, min(0.77, localTime));\n\t\/\/ --------------------------------------------------------------------------------\n\tvec2 distAndMat = vec2(0.5, 0.0);\n\tfloat t = 0.0;\n\t\/\/float inc = 0.02;\n\tfloat maxDepth = 24.0;\n\tvec3 pos = vec3(0,0,0);\n    marchCount = 0.0;\n    \/\/ intersect with sphere first as optimization so we don't ray march more than is needed.\n    float hit = SphereIntersect(camPos, rayVec, vec3(0.0), 5.6);\n    if (hit >= 0.0)\n    {\n        t = hit;\n        \/\/ ray marching time\n        for (int i = 0; i < 290; i++)\t\/\/ This is the count of the max times the ray actually marches.\n        {\n            pos = camPos + rayVec * t;\n            \/\/ *******************************************************\n            \/\/ This is _the_ function that defines the \"distance field\".\n            \/\/ It's really what makes the scene geometry.\n            \/\/ *******************************************************\n            distAndMat = DistanceToObject(pos);\n            \/\/ adjust by constant because deformations mess up distance function.\n            t += distAndMat.x * 0.7;\n            \/\/if (t > maxDepth) break;\n            if ((t > maxDepth) || (abs(distAndMat.x) < 0.0025)) break;\n            marchCount+= 1.0;\n        }\n    }\n    else\n    {\n        t = maxDepth + 1.0;\n        distAndMat.x = 1000000.0;\n    }\n    \/\/ --------------------------------------------------------------------------------\n\t\/\/ Now that we have done our ray marching, let's put some color on this geometry.\n\n\tvec3 sunDir = normalize(vec3(3.93, 10.82, -1.5));\n\tvec3 finalColor = vec3(0.0);\n\n\t\/\/ If a ray actually hit the object, let's light it.\n\t\/\/if (abs(distAndMat.x) < 0.75)\n    if (t <= maxDepth)\n\t{\n        \/\/ calculate the normal from the distance field. The distance field is a volume, so if you\n        \/\/ sample the current point and neighboring points, you can use the difference to get\n        \/\/ the normal.\n        vec3 smallVec = vec3(0.005, 0, 0);\n        vec3 normalU = vec3(distAndMat.x - DistanceToObject(pos - smallVec.xyy).x,\n                           distAndMat.x - DistanceToObject(pos - smallVec.yxy).x,\n                           distAndMat.x - DistanceToObject(pos - smallVec.yyx).x);\n\n        vec3 normal = normalize(normalU);\n\n        \/\/ calculate 2 ambient occlusion values. One for global stuff and one\n        \/\/ for local stuff\n        float ambientS = 1.0;\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.1).x*10.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2).x*5.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4).x*2.5);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.8).x*1.25);\n        float ambient = ambientS * saturate(DistanceToObject(pos + normal * 1.6).x*1.25*0.5);\n        ambient *= saturate(DistanceToObject(pos + normal * 3.2).x*1.25*0.25);\n        ambient *= saturate(DistanceToObject(pos + normal * 6.4).x*1.25*0.125);\n        ambient = max(0.035, pow(ambient, 0.3));\t\/\/ tone down ambient with a pow and min clamp it.\n        ambient = saturate(ambient);\n\n        \/\/ calculate the reflection vector for highlights\n        vec3 ref = reflect(rayVec, normal);\n        ref = normalize(ref);\n\n        \/\/ Trace a ray for the reflection\n        float sunShadow = 1.0;\n        float iter = 0.1;\n        vec3 nudgePos = pos + normal*0.02;\t\/\/ don't start tracing too close or inside the object\n\t\tfor (int i = 0; i < 40; i++)\n        {\n            float tempDist = DistanceToObject(nudgePos + ref * iter).x;\n\t        sunShadow *= saturate(tempDist*50.0);\n            if (tempDist <= 0.0) break;\n            \/\/iter *= 1.5;\t\/\/ constant is more reliable than distance-based\n            iter += max(0.00, tempDist)*1.0;\n            if (iter > 4.2) break;\n        }\n        sunShadow = saturate(sunShadow);\n\n        \/\/ ------ Calculate texture color ------\n        vec3 texColor;\n        texColor = vec3(1.0);\/\/ vec3(0.65, 0.5, 0.4)*0.1;\n        texColor = vec3(0.85, 0.945 - distAndMat.y * 0.15, 0.93 + distAndMat.y * 0.35)*0.951;\n        if (distAndMat.y == 6.0) texColor = vec3(0.91, 0.1, 0.41)*10.5;\n        \/\/texColor *= mix(vec3(0.3), vec3(1.0), tex3d(pos*0.5, normal).xxx);\n        texColor = max(texColor, vec3(0.0));\n        texColor *= 0.25;\n\n        \/\/ ------ Calculate lighting color ------\n        \/\/ Start with sun color, standard lighting equation, and shadow\n        vec3 lightColor = vec3(0.0);\/\/ sunCol * saturate(dot(sunDir, normal)) * sunShadow*14.0;\n        \/\/ sky color, hemisphere light equation approximation, ambient occlusion\n        lightColor += vec3(0.1,0.35,0.95) * (normal.y * 0.5 + 0.5) * ambient * 0.2;\n        \/\/ ground color - another hemisphere light\n        lightColor += vec3(1.0) * ((-normal.y) * 0.5 + 0.5) * ambient * 0.2;\n\n\n        \/\/ finally, apply the light to the texture.\n        finalColor = texColor * lightColor;\n        \/\/if (distAndMat.y == ceil(mod(localTime, 4.0))) finalColor += vec3(0.0, 0.41, 0.72)*0.925;\n\n        \/\/ reflection environment map - this is most of the light\n        vec3 refColor = GetEnvColor2(ref, sunDir)*sunShadow;\n        finalColor += refColor * 0.35 * ambient;\/\/ * sunCol * sunShadow * 9.0 * texColor.g;\n\n        \/\/ fog\n\t\tfinalColor = mix(vec3(1.0, 0.41, 0.41) + vec3(1.0), finalColor, exp(-t*0.0007));\n        \/\/ visualize length of gradient of distance field to check distance field correctness\n        \/\/finalColor = vec3(0.5) * (length(normalU) \/ smallVec.x);\n\t}\n    else\n    {\n\t    finalColor = GetEnvColor2(rayVec, sunDir);\/\/ + vec3(0.1, 0.1, 0.1);\n    }\n    \/\/finalColor += marchCount * vec3(1.0, 0.3, 0.91) * 0.001;\n\n    \/\/ vignette?\n    \/\/finalColor *= vec3(1.0) * saturate(1.0 - length(uv\/2.5));\n    \/\/finalColor *= 1.95;\n\n\t\/\/ output the final color with sqrt for \"gamma correction\"\n\tfragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n\n\n","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"Xsd3DB","date":"1452030293","viewed":12272,"name":"Wave Propagation Effect","username":"tomkh","description":"A simple water propagation effect based on PolyCube version [url]http:\/\/polycu.be\/edit\/?h=W2L7zN[\/url]","likes":211,"published":1,"flags":32,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"\/media\/a\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"\/media\/ap\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/\n\/\/ A simple water effect by Tom@2016\n\/\/\n\/\/ based on PolyCube version:\n\/\/    http:\/\/polycu.be\/edit\/?h=W2L7zN\n\/\/\n\/\/ As people give me too much credit for this one,\n\/\/ it's based on: http:\/\/freespace.virgin.net\/hugo.elias\/graphics\/x_water.htm\n\/\/ A very old Hugo Elias water tutorial :)\n\/\/\n\/\/ Note:\n\/\/   I could use one buffer only as in https:\/\/www.shadertoy.com\/view\/4sd3WB\n\/\/   with a clever trick to utilize two channels\n\/\/   and keep buffer A in x\/r and buffer B in y\/g.\n\/\/   However, now I render every second simulation step,\n\/\/   so the animation is more dynamic.\n\/\/\n\/\/ Here is 1-buffer version for comparison:\n\/\/   https:\/\/www.shadertoy.com\/view\/4dK3Ww\n\/\/\n\n#define TEXTURED 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy\/iResolution.xy;\n\n#if TEXTURED == 1\n    \n    vec3 e = vec3(vec2(1.)\/iResolution.xy,0.);\n    float p10 = texture(iChannel0, q-e.zy).x;\n    float p01 = texture(iChannel0, q-e.xz).x;\n    float p21 = texture(iChannel0, q+e.xz).x;\n    float p12 = texture(iChannel0, q+e.zy).x;\n    \n    \/\/ Totally fake displacement and shading:\n    vec3 grad = normalize(vec3(p21 - p01, p12 - p10, 1.));\n    vec4 c = texture(iChannel1, fragCoord.xy*2.\/iChannelResolution[1].xy + grad.xy*.35);\n    vec3 light = normalize(vec3(.2,-.5,.7));\n    float diffuse = dot(grad,light);\n    float spec = pow(max(0.,-reflect(light,grad).z),32.);\n    fragColor = mix(c,vec4(.7,.8,1.,1.),.25)*max(diffuse,0.) + spec;\n    \n#else\n    \n    float h = texture(iChannel0, q).x;\n    float sh = 1.35 - h*2.;\n    vec3 c =\n       vec3(exp(pow(sh-.75,2.)*-10.),\n            exp(pow(sh-.50,2.)*-20.),\n            exp(pow(sh-.25,2.)*-10.));\n    fragColor = vec4(c,1.);\n\n#endif\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/\n\/\/ A simple water effect by Tom@2016\n\/\/\n\/\/ based on PolyCube version:\n\/\/    http:\/\/polycu.be\/edit\/?h=W2L7zN\n\/\/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec3 e = vec3(vec2(1.)\/iResolution.xy,0.);\n   vec2 q = fragCoord.xy\/iResolution.xy;\n   \n   vec4 c = texture(iChannel0, q);\n   \n   float p11 = c.x;\n   \n   float p10 = texture(iChannel1, q-e.zy).x;\n   float p01 = texture(iChannel1, q-e.xz).x;\n   float p21 = texture(iChannel1, q+e.xz).x;\n   float p12 = texture(iChannel1, q+e.zy).x;\n   \n   float d = 0.;\n    \n   if (iMouse.z > 0.) \n   {\n      \/\/ Mouse interaction:\n      d = smoothstep(4.5,.5,length(iMouse.xy - fragCoord.xy));\n   }\n   else\n   {\n      \/\/ Simulate rain drops\n      float t = iTime*2.;\n      vec2 pos = fract(floor(t)*vec2(0.456665,0.708618))*iResolution.xy;\n      float amp = 1.-step(.05,fract(t));\n      d = -amp*smoothstep(2.5,.5,length(pos - fragCoord.xy));\n   }\n\n   \/\/ The actual propagation:\n   d += -(p11-.5)*2. + (p10 + p01 + p21 + p12 - 2.);\n   d *= .99; \/\/ dampening\n   d *= min(1.,float(iFrame)); \/\/ clear the buffer at iFrame == 0\n   d = d*.5 + .5;\n   \n   fragColor = vec4(d, 0, 0, 0);\n}\n","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/\/\n\/\/ A simple water effect by Tom@2016\n\/\/\n\/\/ based on PolyCube version:\n\/\/    http:\/\/polycu.be\/edit\/?h=W2L7zN\n\/\/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec3 e = vec3(vec2(1.)\/iResolution.xy,0.);\n   vec2 q = fragCoord.xy\/iResolution.xy;\n   \n   vec4 c = texture(iChannel0, q);\n   \n   float p11 = c.x;\n   \n   float p10 = texture(iChannel1, q-e.zy).x;\n   float p01 = texture(iChannel1, q-e.xz).x;\n   float p21 = texture(iChannel1, q+e.xz).x;\n   float p12 = texture(iChannel1, q+e.zy).x;\n   \n   float d = 0.;\n    \n   if (iMouse.z > 0.) \n   {\n      \/\/ Mouse interaction:\n      d = smoothstep(4.5,.5,length(iMouse.xy - fragCoord.xy));\n   }\n   else\n   {\n      \/\/ Simulate rain drops\n      float t = iTime*2.;\n      vec2 pos = fract(floor(t)*vec2(0.456665,0.708618))*iResolution.xy;\n      float amp = 1.-step(.05,fract(t));\n      d = -amp*smoothstep(2.5,.5,length(pos - fragCoord.xy));\n   }\n\n   \/\/ The actual propagation:\n   d += -(p11-.5)*2. + (p10 + p01 + p21 + p12 - 2.);\n   d *= .99; \/\/ dampening\n   d *= min(1.,float(iFrame)); \/\/ clear the buffer at iFrame == 0\n   d = d*.5 + .5;\n   \n   fragColor = vec4(d, 0, 0, 0);\n}\n","name":"Buf B","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"4lfcDr","date":"1504273098","viewed":12222,"name":"Path tracing cornellbox with MIS","username":"cschied","description":"path tracing in the cornell box","likes":131,"published":3,"flags":0,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define INFINITY 9999999.0\n#define PI 3.141592653589\n#define NUM_SAMPLES 32\n#define NUM_BOUNCES 3\n\nfloat light_size;\nfloat light_area;\n\/\/vec3 light_position = vec3(0, 0.97, 0);\nvec3 light_position;\nvec3 light_normal;\nint seed;\nvec4 light_albedo;\nint flat_idx;\n\n\n\nvec2\nsample_disk(vec2 uv)\n{\n\tfloat theta = 2.0 * 3.141592653589 * uv.x;\n\tfloat r = sqrt(uv.y);\n\treturn vec2(cos(theta), sin(theta)) * r;\n}\n\nvec3\nsample_cos_hemisphere(vec2 uv)\n{\n\tvec2 disk = sample_disk(uv);\n\treturn vec3(disk.x, sqrt(max(0.0, 1.0 - dot(disk, disk))), disk.y);\n}\n\nmat3\nconstruct_ONB_frisvad(vec3 normal)\n{\n\tmat3 ret;\n\tret[1] = normal;\n\tif(normal.z < -0.999805696) {\n\t\tret[0] = vec3(0.0, -1.0, 0.0);\n\t\tret[2] = vec3(-1.0, 0.0, 0.0);\n\t}\n\telse {\n\t\tfloat a = 1.0 \/ (1.0 + normal.z);\n\t\tfloat b = -normal.x * normal.y * a;\n\t\tret[0] = vec3(1.0 - normal.x * normal.x * a, b, -normal.x);\n\t\tret[2] = vec3(b, 1.0 - normal.y * normal.y * a, -normal.y);\n\t}\n\treturn ret;\n}\n\nvoid\nencrypt_tea(inout uvec2 arg)\n{\n\tuvec4 key = uvec4(0xa341316c, 0xc8013ea4, 0xad90777d, 0x7e95761e);\n\tuint v0 = arg[0], v1 = arg[1];\n\tuint sum = 0u;\n\tuint delta = 0x9e3779b9u;\n\n\tfor(int i = 0; i < 32; i++) {\n\t\tsum += delta;\n\t\tv0 += ((v1 << 4) + key[0]) ^ (v1 + sum) ^ ((v1 >> 5) + key[1]);\n\t\tv1 += ((v0 << 4) + key[2]) ^ (v0 + sum) ^ ((v0 >> 5) + key[3]);\n\t}\n\targ[0] = v0;\n\targ[1] = v1;\n}\n\nvec2\nget_random()\n{\n  \tuvec2 arg = uvec2(flat_idx, seed++);\n  \tencrypt_tea(arg);\n  \treturn fract(vec2(arg) \/ vec2(0xffffffffu));\n}\n\nstruct Ray\n{\n\tvec3 origin, dir;\n};\n\nstruct AABB\n{\n\tvec3 min_, max_;\n};\n\nmat4\nrotate_y(float a)\n{\n\tmat4 ret = mat4(1.0);\n\tret[0][0] = ret[2][2] = cos(a);\n\tret[0][2] = sin(a);\n\tret[2][0] = -ret[0][2];\n\treturn ret;\n}\n\nvec3\nsample_light(vec2 rng)\n{\n\treturn light_position + vec3(rng.x - 0.5, 0, rng.y - 0.5) * light_size;\n}\n\nbool\nintersect_aabb(in Ray ray, in AABB aabb, inout float t_min, inout float t_max)\n{\n\tvec3 div = 1.0 \/ ray.dir;\n\tvec3 t_1 = (aabb.min_ - ray.origin) * div;\n\tvec3 t_2 = (aabb.max_ - ray.origin) * div;\n\n\tvec3 t_min2 = min(t_1, t_2);\n\tvec3 t_max2 = max(t_1, t_2);\n\n\tt_min = max(max(t_min2.x, t_min2.y), max(t_min2.z, t_min));\n\tt_max = min(min(t_max2.x, t_max2.y), min(t_max2.z, t_max));\n\n\treturn t_min < t_max;\n}\n\nvec3\nray_at(in Ray ray, float t)\n{\n\treturn ray.origin + t * ray.dir;\n}\n\nfloat\nintersect_plane(\n\tRay ray,\n    vec3 center,\n    vec3 normal)\n{\n    float denom = dot(ray.dir, normal);\n    float t = dot(center - ray.origin, normal) \/ denom;\n\treturn t > 0.0 ? t : INFINITY;\n}\n\nfloat\nintersect_box(Ray ray, out vec3 normal, vec3 size)\n{\n\tfloat t_min = 0.0;\n\tfloat t_max = 999999999.0;\n\tif(intersect_aabb(ray, AABB(-size, size), t_min, t_max)) {\n\t\tvec3 p = ray_at(ray, t_min);\n\t\tp \/= size;\n\t\tif(abs(p.x) > abs(p.y)) {\n\t\t\tif(abs(p.x) > abs(p.z)) {\n\t\t\t\tnormal = vec3(p.x > 0.0 ? 1.0 : -1.0, 0, 0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnormal = vec3(0, 0, p.z > 0.0 ? 1.0 : -1.0);\n\t\t\t}\n\t\t}\n\t\telse if(abs(p.y) > abs(p.z)) {\n\t\t\tnormal = vec3(0, p.y > 0.0 ? 1.0 : -1.0, 0);\n\t\t}\n\t\telse {\n\t\t\tnormal = vec3(0, 0, p.z > 0.0 ? 1.0 : -1.0);\n\t\t}\n\n\t\treturn t_min;\n\t}\n\n\treturn INFINITY;\n}\n\nfloat\nintersect_light(Ray ray)\n{\n\tfloat t = intersect_plane(ray, light_position, light_normal);\n\n\tvec3 p = ray_at(ray, t);\n\tif(all(lessThan(abs(light_position - p).xz, vec2(light_size * 0.5)))) {\n\t\treturn t;\n\t}\n\n\treturn INFINITY;\n}\n\nfloat\nintersect(Ray ray, inout vec3 p, inout vec3 normal, out vec4 albedo)\n{\n\tfloat t_min = INFINITY;\n\n\talbedo = vec4(0.0);\n\n\t{\n\t\tfloat t = intersect_light(ray);\n\t\tif(t < t_min) {\n\t\t\t\/\/albedo = vec3(100);\n\t\t\talbedo = light_albedo;\n\t\t\t\/\/albedo = vec3(dot(ray.dir, light_normal) < 0.0 ? 1.0 : 0.0);\n\t\t\tnormal = light_normal;\n\t\t\tt_min  = t;\n\t\t\tp = ray_at(ray, t);\n\t\t}\n\t}\n\n\t{\n\t\tvec3 normal_tmp;\n\t\tRay ray_tmp = ray;\n\t\t\/\/mat4 r = rotate_y(scene_time);\n\t\tmat4 r = rotate_y(0.3);\n\t\tray_tmp.origin -= vec3(-0.35, -0.5, -0.35);\n\t\tray_tmp.dir = vec3(r * vec4(ray_tmp.dir, 0));\n\t\tray_tmp.origin = vec3(r * vec4(ray_tmp.origin, 1.0));\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp, vec3(0.25, 0.5, 0.25));\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\talbedo = vec4(0.7, 0.7, 0.7, 0);\n\t\t\tnormal = vec3(transpose(r) * vec4(normal_tmp, 0.0));\n\t\t}\n\t}\n\n\t{\n\t\tvec3 normal_tmp;\n\t\tRay ray_tmp = ray;\n\t\tray_tmp.origin -= vec3(0.5, -0.75, 0.35);\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp, vec3(0.25, 0.25, 0.25));\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\talbedo = vec4(0.7, 0.7, 0.7, 0);\n\t\t\tnormal = normal_tmp;\n\t\t}\n\t}\n\n\t\/\/ left\n\t{\n\t\tvec3 n = vec3(1, 0, 0);\n\t\tfloat t = intersect_plane(ray, vec3(-1, 0, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThanEqual(p_tmp.yz, vec2(1))) && all(greaterThanEqual(p_tmp.yz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tnormal = n;\n\t\t\t\tp = p_tmp;\n\n\t\t\t\tt_min = t;\n\n\t\t\t\talbedo = vec4(0.9, 0.1, 0.1, 0);\n\t\t\t}\n\t\t}\n\t}\n\t\/\/ right\n\t{\n\t\tvec3 n = vec3(-1, 0, 0);\n\t\tfloat t = intersect_plane(ray, vec3(1, 0, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThanEqual(p_tmp.yz, vec2(1))) && all(greaterThanEqual(p_tmp.yz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tnormal = n;\n\t\t\t\tp = p_tmp;\n\n\t\t\t\tt_min = t;\n\n\t\t\t\talbedo = vec4(0.1, 0.9, 0.1, 0);\n\t\t\t}\n\t\t}\n\t}\n\t\/\/ floor\n\t{\n\t\tvec3 n = vec3(0, 1, 0);\n\t\tfloat t = intersect_plane(ray, vec3(0, -1, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThan(p_tmp.xz, vec2(1))) && all(greaterThan(p_tmp.xz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tnormal = n;\n\t\t\t\tp = p_tmp;\n\t\t\t\talbedo = vec4(0.7, 0.7, 0.7, 0);\n\n\t\t\t\tt_min = t;\n\t\t\t}\n\t\t}\n\t}\n\t\/\/ ceiling\n\t{\n\t\tvec3 n = vec3(0, -1, 0);\n\t\tfloat t = intersect_plane(ray, vec3(0, 1, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThan(p_tmp.xz, vec2(1))) && all(greaterThan(p_tmp.xz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tnormal = n;\n\t\t\t\tp = p_tmp;\n\t\t\t\talbedo = vec4(0.7, 0.7, 0.7, 0);\n\n\t\t\t\tt_min = t;\n\t\t\t}\n\t\t}\n\t}\n\t\/\/ back wall\n\t{\n\t\tvec3 n = vec3(0, 0, 1);\n\t\tfloat t = intersect_plane(ray, vec3(0, 0, -1), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThan(p_tmp.xy, vec2(1))) && all(greaterThan(p_tmp.xy,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tnormal = n;\n\t\t\t\tp = p_tmp;\n\t\t\t\talbedo = vec4(0.7, 0.7, 0.7, 0);\n\n\t\t\t\tt_min = t;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tnormal = normalize(normal);\n\n\treturn t_min;\n}\n\nbool\ntest_visibility(vec3 p1, vec3 p2)\n{\n\tconst float eps = 1e-5;\n\n\tRay r = Ray(p1, normalize(p2 - p1));\n\tr.origin += eps * r.dir;\n\n\tvec3 n, p;\n\tvec4 a; \/\/ ignored\n\tfloat t_shadow = intersect(r, p, n, a);\n\n\treturn t_shadow > distance(p1, p2) - 2.0 * eps;\n}\n\nvec3\npt_mis(Ray ray)\n{\n\tvec3 contrib = vec3(0);\n\tvec3 tp = vec3(1.0);\n\n\tvec3 position, normal;\n\tvec4 albedo;\n\tfloat t = intersect(ray, position, normal, albedo);\n\n\tif(t == INFINITY)\n\t\treturn vec3(0.0);\n\n\tif(albedo.a > 0.0) { \/* hight light source *\/\n\t\treturn albedo.rgb * albedo.a;\n\t}\n\n\tfor(int i = 0; i < NUM_BOUNCES; i++) {\n\t\tmat3 onb = construct_ONB_frisvad(normal);\n\n\t\t{ \/* NEE *\/\n\t\t\tvec3 pos_ls = sample_light(get_random());\n\t\t\tvec3 l_nee = pos_ls - position;\n\t\t\tfloat rr_nee = dot(l_nee, l_nee);\n\t\t\tl_nee \/= sqrt(rr_nee);\n\t\t\tfloat G = max(0.0, dot(normal, l_nee)) * max(0.0, -dot(l_nee, light_normal)) \/ rr_nee;\n\n\t\t\tif(G > 0.0) {\n\t\t\t\tfloat light_pdf = 1.0 \/ (light_area * G);\n\t\t\t\tfloat brdf_pdf = 1.0 \/ PI;\n\n\t\t\t\tfloat w = light_pdf \/ (light_pdf + brdf_pdf);\n\n\t\t\t\tvec3 brdf = albedo.rgb \/ PI;\n\n\t\t\t\tif(test_visibility(position, pos_ls)) {\n\t\t\t\t\tvec3 Le = light_albedo.rgb * light_albedo.a;\n\t\t\t\t\tcontrib += tp * (Le * w * brdf) \/ light_pdf;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t{ \/* brdf *\/\n\t\t\tvec3 dir = normalize(onb * sample_cos_hemisphere(get_random()));\n\n\t\t\tvec3 brdf = albedo.rgb \/ PI;\n\n\t\t\tRay ray_next = Ray(position, dir);\n\t\t\tray_next.origin += ray_next.dir * 1e-5;\n\n\t\t\tvec3 position_next, normal_next;\n\t\t\tvec4 albedo_next;\n\t\t\tfloat t = intersect(ray_next, position_next, normal_next, albedo_next);\n\n\t\t\tif(t == INFINITY)\n\t\t\t\tbreak;\n\n\t\t\tfloat brdf_pdf = 1.0 \/ PI;\n\n\t\t\tif(albedo_next.a > 0.0) { \/* hit light_source *\/\n\t\t\t\tfloat G = max(0.0, dot(ray_next.dir, normal)) * max(0.0, -dot(ray_next.dir, normal_next)) \/ (t * t);\n\t\t\t\tif(G <= 0.0) \/* hit back side of light source *\/\n\t\t\t\t\tbreak;\n\n\t\t\t\tfloat light_pdf = 1.0 \/ (light_area * G);\n\n\t\t\t\tfloat w = brdf_pdf \/ (light_pdf + brdf_pdf);\n\n\t\t\t\tvec3 Le = light_albedo.rgb * light_albedo.a;\n\t\t\t\tcontrib += tp * (Le * w * brdf) \/ brdf_pdf;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttp *= brdf \/ brdf_pdf;\n\n\t\t\tposition = position_next;\n\t\t\tnormal = normal_next;\n\t\t\talbedo = albedo_next;\n\t\t}\n\t}\n\n\treturn contrib;\n}\n\nvoid\nmainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tlight_size = 0.5;\n\tlight_area = light_size * light_size;\n\tlight_position = vec3(0.5 * sin(iTime), 0.90, 0.5 * cos(iTime));\n\tlight_normal = vec3(0, -1, 0);\n\tseed = 0;\n\tlight_albedo = vec4(1, 1, 1, 2.0 \/ (light_size * light_size));\n\tflat_idx = int(dot(gl_FragCoord.xy, vec2(1, 4096)));\n\n\n\tvec2 p = fragCoord.xy \/ vec2(iResolution) - vec2(0.5);\n\tfloat a = float(iResolution.x) \/ float(iResolution.y);\n\tif(a < 1.0)\n\t\tp.y \/= a;\n\telse\n\t\tp.x *= a;\n\n\tvec3 cam_center = vec3(0, 0, 3.125);\n\n\tvec3 s = vec3(0);\n\tfor(int i = 0; i < NUM_SAMPLES; i++) {\n\t\tRay ray;\n\t\tray.origin = cam_center;\n\t\tvec2 r = get_random();\n\t\tvec3 ray_dir = normalize(vec3(p + r.x * dFdx(p) + r.y * dFdy(p), -1));\n\t\tray.dir = ray_dir;\n\t\tvec3 c = pt_mis(ray);\n\t\ts += c;\n\t}\n\n\tfragColor = vec4(pow(s \/ float(NUM_SAMPLES), vec3(1.0 \/ 2.2)), 1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"tdjyzz","date":"1586448367","viewed":12147,"name":"Tree in the wind","username":"Maurogik","description":"Falling leaves and a full day\/night cycle.\nOnce again, it started as a simple tree experiment and got complicated really fast.","likes":329,"published":3,"flags":96,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"llB3Wh","filepath":"https:\/\/soundcloud.com\/musa-muh-nur\/nature-sounds-beautiful","previewfilepath":"https:\/\/soundcloud.com\/musa-muh-nur\/nature-sounds-beautiful","type":"musicstream","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/   _____                 _         _   _                     _           _ \n\/\/  \/__   \\_ __ ___  ___  (_)_ __   | |_| |__   ___  __      _(_)_ __   __| |\n\/\/    \/ \/\\\/ '__\/ _ \\\/ _ \\ | | '_ \\  | __| '_ \\ \/ _ \\ \\ \\ \/\\ \/ \/ | '_ \\ \/ _` |\n\/\/   \/ \/  | | |  __\/  __\/ | | | | | | |_| | | |  __\/  \\ V  V \/| | | | | (_| |\n\/\/   \\\/   |_|  \\___|\\___| |_|_| |_|  \\__|_| |_|\\___|   \\_\/\\_\/ |_|_| |_|\\__,_|\n\/\/                                                                                                       \n\/\/\n\/\/----------------------------------------------------------------------------------------\n\/\/     ___                                                    _  _    \n\/\/    \/ __\\ _   _     \/\\\/\\    __ _  _   _  _ __  ___    __ _ (_)| | __\n\/\/   \/__\\\/\/| | | |   \/    \\  \/ _` || | | || '__|\/ _ \\  \/ _` || || |\/ \/\n\/\/  \/ \\\/  \\| |_| |  \/ \/\\\/\\ \\| (_| || |_| || |  | (_) || (_| || ||   < \n\/\/  \\_____\/ \\__, |  \\\/    \\\/ \\__,_| \\__,_||_|   \\___\/  \\__, ||_||_|\\_\\\n\/\/          |___\/                                      |___\/          \n\/\/\n\/\/----------------------------------------------------------------------------------------\n\n\/\/The day\/night cyle takes around 1 a minute, so sit back and relax.\n\n\/\/Text ascii art using : http:\/\/patorjk.com\/software\/taag\/\n\nfloat tonemapOp(float v)\n{\n    v = pow(v, 2.0);\n    v = v \/ (1.0 + v);\n    return pow(v, 1.0\/2.0) * 1.025;\n}\n\nvec3 tonemap(vec3 colour)\n{\n    float inputLuminance = max(0.0001, rbgToluminance(colour));\n    vec3 normalisedColour = colour \/ inputLuminance;\n    \n    vec3 tonemapColour;\n    tonemapColour.r = tonemapOp(colour.r);\n    tonemapColour.g = tonemapOp(colour.g);\n    tonemapColour.b = tonemapOp(colour.b);\n    float tonemappedLuminance = tonemapOp(inputLuminance);\n    \n    tonemapColour = (tonemapColour \/ max(0.0001, rbgToluminance(tonemapColour)));\n    \n    return tonemappedLuminance * mix(normalisedColour, tonemapColour, min(1.0, 0.35*inputLuminance));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n      \n\tvec4 colour = texture(iChannel0, uv);\n    \n    \/\/Vignette\n    colour.rgb *= smoothstep(1.15, 0.3, length(uv - 0.5*oz.xx));\n    \n\t\/\/Tonemap\n    float toeStrength = 1.25;\n    colour.rgb = tonemap(colour.rgb * toeStrength); colour.rgb = pow(colour.rgb, toeStrength*oz.xxx);\n    \n    \/\/Gamma\n    colour = pow(colour, vec4(1.0\/2.2));\n    fragColor = colour;\n    \n    \/\/Dithering\n    fragColor += ((hash12(fragCoord)) - 0.5)*4.0\/255.0;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\/\/   __  _                            _                   _       \n\/\/  \/ _\\| |__    __ _  _ __  ___   __| |   ___  ___    __| |  ___ \n\/\/  \\ \\ | '_ \\  \/ _` || '__|\/ _ \\ \/ _` |  \/ __|\/ _ \\  \/ _` | \/ _ \\\n\/\/  _\\ \\| | | || (_| || |  |  __\/| (_| | | (__| (_) || (_| ||  __\/\n\/\/  \\__\/|_| |_| \\__,_||_|   \\___| \\__,_|  \\___|\\___\/  \\__,_| \\___|\n\/\/                                                                \n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ SDF functions from mercury : http:\/\/mercury.sexy\/hg_sdf\/ \/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define PI 3.14159265359\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\n\/\/             PRIMITIVE DISTANCE FUNCTIONS\n\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\n\/\/ Conventions:\n\/\/\n\/\/ Everything that is a distance function is called fSomething.\n\/\/ The first argument is always a point in 2 or 3-space called <p>.\n\/\/ Unless otherwise noted, (if the object has an intrinsic \"up\"\n\/\/ side or direction) the y axis is \"up\" and the object is\n\/\/ centered at the origin.\n\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nfloat fSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n\/\/ Capsule: A Cylinder with round caps on both sides\nfloat fCapsule(vec3 p, float r, float c)\n{\n    return mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\n\/\/ Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b)\n{\n    vec3  ab = b - a;\n    float t  = saturate(dot(p - a, ab) \/ dot(ab, ab));\n    return length((ab * t + a) - p);\n}\n\n\/\/ Capsule version 2: between two end points <a> and <b> with radius r\nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    return fLineSegment(p, a, b) - r;\n}\n\n\/\/ Cone with correct distances to tip and base circle. Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height)\n{\n    vec2  q         = vec2(length(p.xz), p.y);\n    vec2  tip       = q - vec2(0.0, height);\n    vec2  mantleDir = normalize(vec2(height, radius));\n    float mantle    = dot(tip, mantleDir);\n    float d         = max(mantle, -q.y);\n    float projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\n    \/\/ distance to tip\n    if((q.y > height) && (projected < 0.0))\n    {\n        d = max(d, length(tip));\n    }\n\n    \/\/ distance to base ring\n    if((q.x > radius) && (projected > length(vec2(height, radius))))\n    {\n        d = max(d, length(q - vec2(radius, 0.0)));\n    }\n    return d;\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\n\/\/                DOMAIN MANIPULATION OPERATORS\n\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\n\/\/ Conventions:\n\/\/\n\/\/ Everything that modifies the domain is named pSomething.\n\/\/\n\/\/ Many operate only on a subset of the three dimensions. For those,\n\/\/ you must choose the dimensions that you want manipulated\n\/\/ by supplying e.g. <p.x> or <p.zx>\n\/\/\n\/\/ <inout p> is always the first argument and modified in place.\n\/\/\n\/\/ Many of the operators partition space into cells. An identifier\n\/\/ or cell index is returned, if possible. This return value is\n\/\/ intended to be optionally used e.g. as a random seed to change\n\/\/ parameters of the distance functions inside the cells.\n\/\/\n\/\/ Unless stated otherwise, for cell index 0, <p> is unchanged and cells\n\/\/ are centered on the origin so objects don't have to be moved to fit.\n\/\/\n\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\n\/\/ Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n\/\/ Read like this: R(p.xz, a) rotates \"x towards z\".\n\/\/ This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a)\n{\n    p = cos(a) * p + sin(a) * vec2(p.y, -p.x);\n}\n\n\/\/ Repeat around the origin by a fixed angle.\n\/\/ For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions)\n{\n    float angle = 2.0 * PI \/ repetitions;\n    float a     = atan(p.y, p.x) + angle \/ 2.;\n    float r     = length(p);\n    float c     = floor(a \/ angle);\n    a           = mod(a, angle) - angle \/ 2.;\n    p           = vec2(cos(a), sin(a)) * r;\n    \/\/ For an odd number of repetitions, fix cell index of the cell in -x direction\n    \/\/ (cell index would be e.g. -5 and 5 in the two halves of the cell):\n    if(abs(c) >= (repetitions \/ 2.0))\n        c = abs(c);\n    return c;\n}\n\n\/\/ Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size)\n{\n    vec2 c = floor((p + size * 0.5) \/ size);\n    p      = mod(p + size * 0.5, size) - size * 0.5;\n    return c;\n}\n\n\/\/ Repeat in three dimensions\nvec3 pMod3(inout vec3 p, vec3 size)\n{\n    vec3 c = floor((p + size * 0.5) \/ size);\n    p      = mod(p + size * 0.5, size) - size * 0.5;\n    return c;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Intersectors and other things from IQ\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ https:\/\/iquilezles.org\/articles\/smin\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25\/k;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25\/k;\n}\n\n\n\/\/ vertical\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdOctogon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.9238795325, 0.3826834323, 0.4142135623 );\n    p = abs(p);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\n\/\/ plane degined by p (p.xyz must be normalized)\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)\/dot(rd,p.xyz);\n}\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)\/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x\/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat opExtrusion( in vec3 p, in float dist, in float h )\n{\n    vec2 w = vec2( dist, abs(p.z) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\n\/\/From https:\/\/iquilezles.org\/articles\/sphereshadow\nfloat sphSoftShadow( in vec3 ro, in vec3 rd, in vec3 sph, in float ra, in float k )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n\n    return (b>0.0) ? step(-0.0001,c) : smoothstep( -0.5, 0.5, h*k\/b );\n}\n\nvec3 opCheapBend( in vec3 p, float bend )\n{\n    float k = bend;\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return q;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Hashes from Dave Hopkins \n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ Hash without Sine\n\/\/ Creative Commons Attribution-ShareAlike 4.0 International Public License\n\/\/ Created by David Hoskins.\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n\/\/----------------------------------------------------------------------------------------\n\/\/\/  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/\/  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Common Shader Code\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\n#define NON_CONST_ZERO (min(iFrame,0)) \n#define NON_CONST_ZERO_U uint(min(iFrame,0)) \n\nconst vec2 oz = vec2(1.0, 0.0);\n\nconst float kGoldenRatio = 1.618;\nconst float kGoldenRatioConjugate = 0.618;\n\nconst float kPI         = 3.14159265359;\nconst float kTwoPI      = 2.0 * kPI;\n\nconst float kMaxDist = 10000.;\nconst float kTimeScale = 1.0;\n\nfloat kIsotropicScatteringPhase = (1.0 \/ (4.0 * kPI));\n\nvec3 roughFresnel(vec3 f0, float cosA, float roughness)\n{\n    \/\/ Schlick approximation\n    return f0 + (oz.xxx - f0) * (pow(1.0 - cosA, 5.0)) * (1.0 - roughness);\n}\n\nfloat linearstep(float start, float end, float x)\n{\n    float range = end - start;\n    return saturate((x - start) \/ range);\n}\n\nfloat henyeyGreensteinPhase_schlick(float cosA, float g)\n{\n    float k = 1.55*g - 0.55*g*g*g;\n    float f = 1.0 - k * cosA;\n\treturn (1.0 - k * k) \/ (4.0 * kPI * f*f);\n}\n\nfloat henyeyGreensteinPhase(float cosA, float g)\n{\n    return henyeyGreensteinPhase_schlick(cosA, g);\n\t\/*float g2 = g*g;\n    return 1.0 \/ (4.0 * kPI) *\n        ((1.0 - g2)\/pow(1.0 + g2 - 2.0*g*cosA, 1.5));*\/\n}\n\nfloat rayleighPhase(float rayDotSun)\n{\n    float k = (3.0 \/ 4.0) * kIsotropicScatteringPhase;\n    return k * (1.0 + rayDotSun * rayDotSun);\n}\n\nfloat rbgToluminance(vec3 rgb)\n{\n    return (rgb.r * 0.3) + (rgb.g * 0.59) + (rgb.b * 0.11);\n}\n\nvec3 fixNormalBackFacingness(vec3 rayDirWS, vec3 normalWS)\n{\n    normalWS -= max(0.0, dot(normalWS, rayDirWS)) * rayDirWS;\n    return normalWS;\n}\n\n\/\/This is NOT a good way of converting from wavelgnth to RGB\nvec3 wavelengthToRGB(float wavelength)\n{\n    const float kLambdaR = 680.0;\n    const float kLambdaG = 550.0;\n    const float kLambdaB = 440.0;\n    \n    vec3 colour = oz.xxx - saturate(vec3(abs(wavelength-kLambdaR), abs(wavelength-kLambdaG), abs(wavelength-kLambdaB))\/150.0);\n\treturn colour;  \n}\n\n\n#define USE_SPHERE 0\n#define USE_TUBE 0\n#define USE_SKY 1\n#define USE_ATM 1\n#define USE_SUN 1\n\n\nconst float kSunRadius = 1.0\/180.0*kPI;\nconst float kCosSunRadius = cos(kSunRadius);\nconst float kTanSunRadius = tan(kSunRadius);\nconst float kSunDiskSolidAngle = 2.0*kPI*(1.0 - kCosSunRadius);\n\nconst float kAtmDensity = 1.0;\n\nconst vec3 kRayleighScatteringCoefsKm = vec3(5.8e-3, 1.35e-2, 3.31e-2) * kAtmDensity;\nconst float kRayleighAtmHeightKm = 8.0;\n\nconst float kMieAtmHeightKm = 1.2;\nconst float kMieScatteringCoefsKm = 0.0075 * kAtmDensity * 2.0;\n\nconst float kEarthRadiusKm = 6000.0;\n\nconst float kMultipleScatteringFakery = 0.5;\n\n\nvec3 s_dirToSunWS = normalize(vec3(0.4, -0.01, 0.5));\nvec3 s_sunColour = oz.yyy;\nvec3 s_cloudSunColour = oz.yyy;\nvec3 s_sunRadiance  = oz.yyy;\nvec3 s_averageSkyColour = oz.yyy;\nfloat s_timeOfDay = 0.0f;\nfloat s_time = 0.0f;\nfloat s_earthRotationRad = 0.0f;\nvec3 s_eyePositionWS = oz.xxx;\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Shared SDF\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nconst float kMatMapleLeaf = 0.0;\nconst float kMatFallingMapleLeaf = 1.0;\nconst float kMatMapleBark = 2.0;\nconst float kMatGrass = 3.0;\nconst float kMatMountains = 4.0;\nconst float kMatPines = 5.0;\n\nconst uint kRenderFilter = 0u;\nconst uint kShadowMapFilter = 1u;\n\nconst vec3 kWindVelocityWS = -oz.xyy * 0.75;\n\nconst vec3 kTreePosWS = vec3(0.0, 0.0, -8.0);\n\n\/\/2 triangles and some displacement\nfloat fMapleLeaf(vec3 posLeaf, float scale, float rand, bool doDetail, out vec4 material)\n{\n    posLeaf = opCheapBend(posLeaf.xzy, (rand-0.5) * 10.0).xzy;\n    \n    float normalisedHeight = saturate(0.5 + (posLeaf.y\/scale));\n    material = vec4(kMatMapleLeaf, 1.0, 0.0, 0.0);\n    \n    vec3 posTri = posLeaf - oz.yxy * scale;\n    posTri.y = -posTri.y;\n    \n    if(doDetail)\n    {\n    \tposTri.y += max(0.0, cos(abs(posTri.x)*6.0*kPI)) * 0.035;\n    }\n\n    float pointyBits = 0.0;\n    float dist2D = sdTriangleIsosceles(posTri.xy, vec2(scale*1.2, scale*2.0));\n    float innerStick = linearstep(0.01, 0.0, abs(posTri.x));\n    innerStick = max(innerStick, linearstep(0.02, 0.0, abs(abs(posTri.x)-1.75*(posTri.y-1.4*scale))));\n        \n    if(doDetail)\n    {\n        pointyBits = abs(fract((-0.08 + posTri.y + abs(posTri.x)*2.0)*8.0) - 0.5) * 0.1 \n            * saturate(1.0 - abs(-posTri.y\/scale + 0.4)*1.);\n\n        dist2D -= pointyBits;\n    }\n    \n    float distToMid = (1.0 - 2.0*abs(normalisedHeight - 0.2));\n    dist2D += distToMid*0.02;\n\n    posTri.y -= scale * 0.75;\n    posTri.x = abs(posTri.x) - scale * 1.3;\n    pR(posTri.xy,  kPI * 0.35);\n    \n    float distTriSides = sdTriangleIsosceles(posTri.xy, vec2(scale*0.55, scale*1.3));\n    innerStick = max(innerStick, linearstep(0.01, 0.0, abs(posTri.x)));\n    if(doDetail)\n    {    \n        pointyBits = abs(fract((-0.03 + posTri.y + abs(posTri.x)*2.0)*8.0) - 0.5) * 0.1 \n            * saturate(1.0 - abs(-posTri.y\/scale + 0.35)*2.5);\n        distTriSides -= pointyBits;\n    }\n\tdist2D = min(dist2D, distTriSides);\n    \n    float inside = max(0.0, -dist2D\/scale);\n    material.z = inside;\n    material.w = floor(rand * 100.0) + innerStick*0.99;\n    \n    if(doDetail)\n    {\n    \tdist2D -= abs(fract((posLeaf.y\/scale)*5.0)-0.5) * 0.02;\n    }\n    \n    float minDist = opExtrusion(posLeaf, dist2D, 0.005);\n    \n    if(doDetail)\n    {\n        vec3 posStick = posLeaf + oz.yxy * scale * 0.5;\n        float stickProgress = saturate(-posStick.y\/scale);\n        posStick.z += stickProgress*stickProgress*scale*0.3*(rand - 0.5);\n    \tfloat stickDist = fCapsule(posStick, -oz.yxy * scale * 1.0, oz.yyy, 0.003);\n        if(stickDist < minDist)\n        {\n            minDist = stickDist;\n        }        \n    }\n    \n    return minDist;\n}\n\nfloat fBranchSDF(vec3 posBranch, float len, float rad, float rand, out vec4 material)\n{\n    float branchHalfLen = len * 0.5;\n    float progressAlong = posBranch.y \/ (2.0*branchHalfLen);    \n    float branchRad = rad * (1.0 - progressAlong * 0.8);\n    \n    float wave = sin((rand + posBranch.y)\/len * 12.0)*0.25*rad;\n    posBranch.xz += oz.xx * wave;\n\tfloat minDist = fCapsule(posBranch - oz.yxy * branchHalfLen, branchRad, branchHalfLen);\n    \n    float u = atan(posBranch.z, posBranch.x);\n    material = vec4(kMatMapleBark, 0.0\/*overriden for AO*\/, u, progressAlong);\n\n    return minDist;\n}\n\nfloat fBranchSDF(vec3 posWS, float scale, float rand, out vec4 material)\n{\n    float branchLen = 1.0 * scale;\n    float branchRad = 0.03 * scale;\n\n    return fBranchSDF(posWS, branchLen, branchRad, rand, material);\n}\n\nfloat fSmallBranchesSDF(vec3 posWS, float branchDist, float branchProgress, out vec4 material)\n{\n    float branchLen = clamp(branchDist * 2.0, 0.5, 2.0);\n    \n    \/\/Shift until it looks good\n    posWS += vec3(0.53, 1.0, 0.53);\n    \n    vec3 posBranches = posWS;\n    vec3 id = pMod3(posBranches, oz.xxx * 2.0);\n    id.x += pModPolar(posBranches.yz, 3.0);\n    float rand = hash13(id * 789.5336);\n    posBranches.xz += sin((posBranches.y + rand) * 2.0 * kPI) * 0.05;\n    pR(posBranches.xy, (rand - 0.5) * kPI * 0.25);\n    float rad = 0.05 * (1.3 - ((posBranches.y\/branchLen) + 0.5));\n    float minDist = fCapsule(posBranches, rad, branchLen);\n    \n    posBranches = posWS + oz.xxx;\n    id = oz.xxx * 235.68 + pMod3(posBranches, oz.xxx * 2.0);\n    id.x += pModPolar(posBranches.yx, 3.0);\n    rand = hash13(id * 789.5336);\n    posBranches.xz += sin((posBranches.y + rand) * 2.0 * kPI) * 0.05;\n    pR(posBranches.yz, (rand - 0.5) * kPI * 0.25);\n    rad = 0.05 * (1.3 - ((posBranches.y\/branchLen) + 0.5));\n    minDist = min(minDist, fCapsule(posBranches, rad, branchLen));\n    \n    \/\/Remove branches near the center of the tree\n    minDist += saturate(0.7 - branchProgress);\n    \n    \/\/Remove small branches away from main branches\n    minDist = smax(minDist, branchDist - 3.0, 0.75);\n    \/\/Remove small branches past the end of the main branch\n    minDist += saturate((branchProgress - 1.4)*3.0);\n    \n    material = vec4(kMatMapleBark, 0.0\/*overriden for AO*\/, 0.001, branchProgress);\n    return minDist;\n}\n\nfloat fCanopy(vec3 posTreeSpace, float branchesDist, vec4 branchMaterial, out vec4 material)\n{\n    const float leafSize = 0.15;\n    const float leafRep = 0.4;\n    \n    vec3 leavesPos = posTreeSpace;\n    vec3 leafId = pMod3(leavesPos, oz.xxx * leafRep);\n    float leafRand = hash13(leafId * 347.0468);\n    leavesPos.xzy += (leafRand - 0.5) * oz.xxx * leafRep * 0.5;\n    pR(leavesPos.xz, leafRand * kPI);\n    float leavesDist = fMapleLeaf(leavesPos, leafSize, leafRand, false, material);\n    \n    leavesPos = posTreeSpace + oz.xxx * leafRep * 0.5;\n    pR(leavesPos.xz, kGoldenRatio * kPI);\n    leafId = pMod3(leavesPos, oz.xxx * leafRep);\n    leafRand = hash13(leafId * 347.0468);\n    pR(leavesPos.xz, leafRand * kPI);\n    leavesPos.xzy += (leafRand - 0.5) * oz.xxx * leafRep * 0.2;\n    leavesDist = min(leavesDist, fMapleLeaf(leavesPos, leafSize, leafRand, false, material));\n    \n    \/\/Remove leaves that are too far from branches, and too close to the trunk, and to far past the main branches\n    float branchStart = linearstep(0.6, 0.4, branchMaterial.w);\n    float branchEnd = linearstep(1.3, 1.42, branchMaterial.w);\n    leavesDist = max(leavesDist, branchesDist - (0.27 - branchEnd*0.17) + branchStart);\n    \n    return leavesDist;\n}\n\nfloat fFallenLeavesSet(vec3 posTreeSpace, float iter, float groundY, out vec4 material)\n{\n    float iterRand = fract(iter * kGoldenRatio);\n    float repSize = 0.25 + iter * 0.2;\n    vec3 leafPos = posTreeSpace - iter * kWindVelocityWS * 4.0;\n    leafPos.y = groundY - min(0.25, 0.75 - dot(leafPos.xz, leafPos.xz)*(0.01 - iter*0.002)*0.75);\n    vec2 leafId = pMod2(leafPos.xz, oz.xx * repSize);\n    float rand = hash12((leafId + oz.xx*iterRand*25.0) * 93.67);\n\n    leafPos.xz += (rand - 0.5) * oz.xx * repSize * (0.5);\n\tleafPos.y += abs(rand-0.5)*2.0 * 0.75;\n    \n    pR(leafPos.yz, kPI * (0.2 + rand * 0.8));\n    pR(leafPos.xy, kPI * 2.0 * rand);\n\n    return fMapleLeaf(leafPos, 0.15, rand, true, \/*out*\/material);\n}\n\nfloat fFallenLeaves(vec3 posTreeSpace, float groundY, out vec4 material)\n{\n    float minDist = kMaxDist;\n    \n    if(groundY < 1.)\n    {\n        vec4 fallenLeavesMaterial;\n        float fallenLeavesDist = fFallenLeavesSet(posTreeSpace, 0.0, groundY - 0.3, \/*out*\/fallenLeavesMaterial);\n        if(fallenLeavesDist < minDist)\n        {\n            minDist = fallenLeavesDist;\n            material = fallenLeavesMaterial;\n        }\n\n        fallenLeavesDist = fFallenLeavesSet(posTreeSpace, 1.0, groundY - 0.2, \/*out*\/fallenLeavesMaterial);\n        if(fallenLeavesDist < minDist)\n        {\n            minDist = fallenLeavesDist;\n            material = fallenLeavesMaterial;\n        }\n\n        fallenLeavesDist = fFallenLeavesSet(posTreeSpace, 2.0, groundY, \/*out*\/fallenLeavesMaterial);\n        if(fallenLeavesDist < minDist)\n        {\n            minDist = fallenLeavesDist;\n            material = fallenLeavesMaterial;\n        }  \n   \n    }\n    else\n    {\n        minDist = min(minDist, groundY - 0.75);\n    }\n    \n    return minDist;\n}\n\nfloat fTreeSDF(vec3 posTreeSpace, float groundY, out vec4 material)\n{\n    float minDist = kMaxDist;\n    float treeBoundingSphereDist = fSphere(posTreeSpace - oz.yxy * 8.0, 9.0);\n    \n    \/\/ If we're far from the tree and falling leaves, bail\n    if(treeBoundingSphereDist > 12.0)\n    {\n        return treeBoundingSphereDist - 10.0;\n    }\n    \n    \/\/ Falling leaves\n    {\n        vec3 leafPos = posTreeSpace - oz.yxy * 10.0;\n        pR(leafPos.xy, -kPI * 0.25);\/\/Rotate to match wind direction\n        float leafId = pModPolar(leafPos.xz, 9.0);\n        float leafRand = hash11(leafId * 68.76);\n        leafPos.x -= 4.0 + leafRand * 2.0;\n        float fallDuration = 20.0;\n        float fallTime = (s_time*1.75 + leafRand * fallDuration);\n        float iter = floor(fallTime \/ fallDuration);\n        fallTime = fallTime - iter * fallDuration;\n\t\t\n        leafPos.y += 2.0 + fallTime;\n        float xOff = sin(fallTime * 0.75 + iter * kPI) + cos(fallTime * 1.5 + iter * kPI) * 0.5;\n        leafPos.x += xOff*1.0;\n        \n        if(length(leafPos) > 0.3)\n        {\n            minDist = length(leafPos) - 0.2;\n        }\n        else\n        {\n            pR(leafPos.yz, xOff * 0.5 * kPI);\n            pR(leafPos.xy, fallTime * (leafRand + 1.0) + iter * kPI);\n\n            vec4 fallingLeavesMaterial;\n            float fallingLeavesDist = fMapleLeaf(leafPos, 0.15, leafRand, true, \/*out*\/fallingLeavesMaterial);\n            fallingLeavesMaterial.x = kMatFallingMapleLeaf;\n            if(fallingLeavesDist < minDist)\n            {\n                minDist = fallingLeavesDist;\n                material = fallingLeavesMaterial;\n            }\n        }\n    }\n    \n    \/\/ If we're far from the tree, bail early\n    if(treeBoundingSphereDist > 1.0)\n    {\n        return min(minDist, treeBoundingSphereDist);\n    }\n    \n    vec4 trunkMaterial;\n    vec3 trunkPos = posTreeSpace;\n    \n    float trunkDist = fBranchSDF(trunkPos, 10.0, 0.5, 0.0, trunkMaterial);\n        \n    if(trunkDist < minDist)\n    {\n        minDist = trunkDist;\n        material = trunkMaterial;\n    }\n    \n    float minBranchDist = kMaxDist;\n    vec4 minBranchMaterial;\n    \n    \n    float winFlexOffset = dot(sin(posTreeSpace * 0.1), oz.xxx) * 2.0 * kPI;\n    float windFlexAmount = min(8.0, trunkDist)\/8.0;\n    vec3 windOffset = vec3(kWindVelocityWS.x, 0.5, kWindVelocityWS.z) * \n        (sin(s_time * 4.0 + winFlexOffset)) * \n        0.05 * windFlexAmount;\n        \n    \n    vec4 branchMaterial;\n    vec3 branchPos;\n    float branchDist, id, rand;\n    \n    branchPos = trunkPos;\n    id = pModPolar(branchPos.xz, 6.0);\n    rand = hash11(id * 736.884);\n    branchPos.y -= 4.0 + 1.0 * rand;\n    pR(branchPos.xy, -kPI * (0.32 + rand * 0.1));\n    \n    branchDist = fBranchSDF(branchPos, 5.75, rand, branchMaterial);\n    if(branchDist < minBranchDist)\n    {\n        minBranchDist = branchDist;\n        minBranchMaterial = branchMaterial;\n    }\n    \n    branchPos = trunkPos;\n    pR(branchPos.xz, -kPI * 0.35);\n    id = pModPolar(branchPos.xz, 5.0);\n    rand = hash11(id * 736.884);\n    branchPos.y -= 7.5 + 1.0 * rand;\n    pR(branchPos.xy, -kPI * (0.35 - rand * 0.05));\n   \n    branchDist = fBranchSDF(branchPos, 5.0, 0.0, branchMaterial);\n    if(branchDist < minBranchDist)\n    {\n        minBranchDist = branchDist;\n        minBranchMaterial = branchMaterial;\n    }\n    \n    branchPos = trunkPos;\n    pR(branchPos.xz, -kPI * 0.65);\n    id = pModPolar(branchPos.xz, 3.0);\n    rand = hash11(id * 736.884);\n    branchPos.y -= 9.5 + 0.5 * rand;\n    pR(branchPos.xy, -kPI * (0.22 - 0.1 * rand));\n    \n    branchDist = fBranchSDF(branchPos, 4.0, 0.0, branchMaterial);\n    if(branchDist < minBranchDist)\n    {\n        minBranchDist = branchDist;\n        minBranchMaterial = branchMaterial;\n    }\n    \n    if(minBranchDist < minDist)\n    {\n        minDist = minBranchDist;\n        material = minBranchMaterial;\n    }\n    \n    \n    vec4 smallBranchesMaterial;\n    float smallBranchesDist = fSmallBranchesSDF(trunkPos + windOffset * 0.25, minBranchDist, minBranchMaterial.w, \n                                                \/*out*\/smallBranchesMaterial);\n    if(smallBranchesDist < minDist)\n    {\n        minDist = smallBranchesDist;\n        material = smallBranchesMaterial;\n    }\n\n    vec4 leavesMaterial;\n\tfloat leavesDist = fCanopy(trunkPos + windOffset, smallBranchesDist, minBranchMaterial, \n                               \/*out*\/leavesMaterial);\n    \n    if(leavesDist < minDist)\n    {\n        minDist = leavesDist;\n        material = leavesMaterial;\n    }\n    \n\t\/\/ Ambient occlusion is stronger at the center of the tree\n    vec3 posToCanopyCenter = vec3(0.0, 10.0, 0.0) - posTreeSpace;\n    material.y = min(1.0, dot(posToCanopyCenter, posToCanopyCenter) \/ 36.0);\n\n    return minDist;\n}\n\nfloat fGrassBladeSet(vec3 grassPosWS, float iter, float scale, float flattenAmount, inout vec4 material)\n{\n    float iterRand = hash11(iter * 967.367);\n\tfloat height = 0.45 * max(1.0, scale);\n    vec2 repSize = vec2(0.15, 0.15) * scale;\n    \n    \n    float windOffset = iterRand * 5.0 + cos(grassPosWS.z * 2.0)*1.0;\n    float wind = sin(s_time * 2.5 + windOffset + 2.0 * grassPosWS.x) * (1.0 - flattenAmount);\n    \n    \/\/Offset each set to prevet overlap\n    grassPosWS.xz += repSize * kGoldenRatio * iter * oz.xx;\n    \/\/Rotate each set in a different direction\n    pR(grassPosWS.xz, (0.25 + (iterRand - 0.5) * 0.5) * kPI);\n    \n    vec2 id = pMod2(grassPosWS.xz, repSize);\n    float rand = hash12(id);\n    \n    float normalisedHeight = saturate(grassPosWS.y \/ height);\n        \n    \/\/Rotate\/bend each blade with the wind\n    pR(grassPosWS.yz, (normalisedHeight * (0.05 + rand * 0.1) + wind * 0.025) * kPI);\n    grassPosWS.xz += (hash22(id * 37.3468) - 0.5*oz.xx) * repSize * 0.75;\n    \n    \/\/Rotate the blade arount Y to get a variety of normal directions\n    pR(grassPosWS.xz, (rand - 0.5) * 2.0 * kPI);\n    \n    const float kConeInvAngle = 0.485*PI;\n    const vec2 kRefConeSinCos = vec2(sin(kConeInvAngle), cos(kConeInvAngle));\n    float grassD = sdCone(grassPosWS - oz.yxy*height, vec3(kRefConeSinCos, height));  \n    grassD = max(grassD, abs(grassPosWS.x) - 0.005);\n    \n    grassD += flattenAmount * 0.2;\n    \n    float ambientVis = min(1.0, 1.7 * normalisedHeight)*(1.0-flattenAmount);\n    material = vec4(kMatGrass, normalisedHeight, min(material.z, ambientVis), rand);\n    \n    return grassD * 0.8;\n}\n\nfloat fGrass(vec3 posWS, float groundY, float leavesDist, out vec4 material)\n{      \n    vec3 grassPosWS;\n    \n    grassPosWS = posWS;\n    grassPosWS.y = groundY + max(0.0, length(posWS.xz - s_eyePositionWS.xz) - 15.0) \/ 60.0;\n    \n    \/\/ Early ouut if far from the ground\n    if(grassPosWS.y > 1.0)\n    {\n        return grassPosWS.y - 0.2;\n    }\n    \n    material.z = 1.0;\n    \n    float flattenAmount = linearstep(0.1, 0.0, leavesDist);\n    float grassDist = kMaxDist;    \n    \n\tgrassDist = min(grassDist, fGrassBladeSet(grassPosWS, 1.0, 1.0, flattenAmount, \/*out*\/material));\n    grassDist = min(grassDist, fGrassBladeSet(grassPosWS, 2.0, 2.0, flattenAmount, \/*out*\/material));\n    \n    material.z *= linearstep(0.0, 0.3, leavesDist);\n\n    return grassDist;\n}\n\nfloat noiseFbm(vec2 uv, sampler2D noiseSampler)\n{\n    float fbm = 0.0;\n    float noise;\n    \n    noise = textureLod(noiseSampler, uv * 1.0, 0.0).r;\n    fbm += noise * 1.0;\n    noise = textureLod(noiseSampler, uv * 1.5, 0.0).r;\n    fbm += noise * 0.55;\n    noise = textureLod(noiseSampler, uv * 3.0, 0.0).r;\n    fbm += noise * 0.35;\n    noise = textureLod(noiseSampler, uv * 4.5, 0.0).r;\n    fbm += noise * 0.25;    \n    return fbm;\n}\n\nfloat fSDF(vec3 posWS, uint filterId, sampler2D noiseSampler, out vec4 material)\n{    \n    float mountainNoise = noiseFbm(posWS.xz * 0.0001 + oz.xx * 0.28, noiseSampler);\n    \n\tfloat minDist = kMaxDist;\n    \n    float groundY = fSphere(posWS - vec3(-10.0, -500.0, -20.0), 500.0);\n    \n    float distantGroundDist = (mountainNoise - 0.25) * 30.0 + fSphere(posWS - vec3(100.0, -4995.0, 500.0), 5000.0);\n    \n    float allMountainsDist = kMaxDist;\n    \/\/ Distant mountains\n    if(filterId != kShadowMapFilter)\n    {\n        \/\/ Far left\n        float scale = 1.65;\n        vec3 moutainPosWS = posWS - scale*vec3(300.0, -100.0, 1400.0);\n        float mountainDist = mountainNoise * 60.0 * scale * linearstep(-scale*150.0, scale*100.0, posWS.y) +\n            fCone(moutainPosWS, scale*700.0, scale*600.0); \n        if(mountainDist < allMountainsDist)\n        {\n            allMountainsDist = mountainDist;\n            material = vec4(kMatMountains, scale, mountainNoise, 100.0);\n        }\n\n        \/\/ A bit to the right\n        scale = 2.7;\n        moutainPosWS = posWS - scale*vec3(600.0, -100.0, 1000.0);\n        mountainDist = mountainNoise * 40.0 * scale * linearstep(-scale*100.0, scale*100.0, posWS.y) +\n            fCone(moutainPosWS, scale*500.0, scale*340.0); \n        if(mountainDist < allMountainsDist)\n        {\n            allMountainsDist = mountainDist;\n            material = vec4(kMatMountains, scale, mountainNoise, 100.0);\n        }\n\n        scale = 4.45;\n        moutainPosWS = posWS - scale*vec3(1000.0, -200.0, 900.0);\n        mountainDist = mountainNoise * 40.0 * scale * linearstep(-scale*100.0, scale*100.0, posWS.y) +\n            fCone(moutainPosWS, scale*550.0, scale*400.0); \n        if(mountainDist < allMountainsDist)\n        {\n            allMountainsDist = mountainDist;\n            material = vec4(kMatMountains, scale, mountainNoise, 100.0);\n        }\n\n        scale = 0.85;\n        moutainPosWS = posWS - scale*vec3(50.0, -120.0, 850.0);\n        mountainDist = mountainNoise * 80.0 * scale +\n            fCone(moutainPosWS, scale*700.0, scale*250.0); \n        if(mountainDist < allMountainsDist)\n        {\n            allMountainsDist = mountainDist;\n            material = vec4(kMatMountains, scale, mountainNoise, 100.0);\n        }\n\n        \/\/ Far right\n        scale = 4.0;\n        moutainPosWS = posWS - scale*vec3(1480.0, -100.0, -700.0);\n        mountainDist = mountainNoise * 50.0 * scale +\n            fCone(moutainPosWS, scale*300.0, scale*350.0); \n        if(mountainDist < allMountainsDist)\n        {\n            allMountainsDist = mountainDist;\n            material = vec4(kMatMountains, scale, mountainNoise, 100.0);\n        }\n\n        scale = 2.0;\n        moutainPosWS = posWS - scale*vec3(1700.0, -200.0, -600.0);\n        mountainDist = mountainNoise * 50.0 * scale +\n            fCone(moutainPosWS, scale*600.0, scale*350.0); \n        if(mountainDist < allMountainsDist)\n        {\n            allMountainsDist = mountainDist;\n            material = vec4(kMatMountains, scale, mountainNoise, 100.0);\n        }\n        \n        minDist = min(allMountainsDist, minDist);\n\t}\n    \n    \/\/ Fallen leaves\n    float fallenLeavesDist = kMaxDist;\n    if(filterId != kShadowMapFilter)\n    {\n        vec4 fallenLeavesMat;\n        fallenLeavesDist = fFallenLeaves(posWS - kTreePosWS, groundY, \/*out*\/ fallenLeavesMat);\n        \n        if(fallenLeavesDist < minDist)\n        {\n            minDist = fallenLeavesDist;\n            material = fallenLeavesMat;\n        }\n    }\n    \n    \/\/ Grass\n    vec4 grassMaterial;\n    float grassDist = kMaxDist;\n    if(filterId != kShadowMapFilter)\n    {\n        grassDist = fGrass(posWS, groundY, fallenLeavesDist, \/*out*\/ grassMaterial);\n        \n        if(grassDist < minDist)\n        {\n            minDist = grassDist;\n            material = grassMaterial;\n        }\n    }\n    \n    if(filterId != kShadowMapFilter && \n       groundY < minDist)\n    {\n        minDist = groundY;\n    \tmaterial = vec4(kMatGrass, 0.0, saturate(grassDist \/ 0.2) * 0.3, 0.0);\n        \/\/material = vec4(kMatMountains, 0.01, mountainNoise, grassDist*50.0);\n    }\n    \n    \/\/ Tree\n    vec4 treeMaterial;\n\tfloat treeDist = fTreeSDF(posWS - kTreePosWS, groundY, \/*out*\/ treeMaterial);\n    \n    if(treeDist < minDist)\n    {\n        minDist = treeDist;\n        material = treeMaterial;\n    }\n    \n    \/\/ Pine cones\n    float pineDist = kMaxDist;\n\n    if(filterId != kShadowMapFilter)\n    {\n        float pineGroundDist = min(distantGroundDist, allMountainsDist + \n                                   max(0.0, posWS.y - min(300.0, (1.0 - mountainNoise)*1000.0)) * 0.05);\n        \n        if(pineGroundDist > 25.0)\n        {\n            pineDist = pineGroundDist - 15.0;\n        }\n        else\n        {\n            vec3 posPine = posWS;\n            posPine.y = pineGroundDist;\n            vec2 pineId = pMod2(posPine.xz, oz.xx * 25.0);\n            posPine .xz += hash22(pineId * 17.12) * 10.0;\n            pineDist = fCone(posPine, 2.0, 15.0 + 4.0 * hash12(pineId * 17.12));\n\n            posPine = posWS + oz.xxx * 12.5;\n            posPine.y = pineGroundDist;\n            pineId = pMod2(posPine.xz, oz.xx * 15.0);\n            posPine .xz += hash22(pineId * 17.12) * 5.0;\n            pineDist = min(pineDist, fCone(posPine, 2.0, 10.0 + 2.0 * hash12(pineId * 17.12)));\n        }\n        \n        if( pineDist < minDist)\n        {\n            minDist = pineDist;\n            material = vec4(kMatPines, pineGroundDist, mountainNoise, 1.0);\n        }\n    }\n\t\n    \n    if(filterId != kShadowMapFilter && \n       distantGroundDist < minDist)\n    {\n        minDist = distantGroundDist;\n        material = vec4(kMatMountains, 1.0, mountainNoise, pineDist);\n    }\n    \n    return minDist;\n}\n\nfloat fSDF(vec3 p, sampler2D noiseSampler)\n{\n    vec4 mat;\n    return fSDF(p, kRenderFilter, noiseSampler, mat);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Lighting\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec3 getSky(vec3 rayDirWS, float roughness, out vec3 transmittance)\n{\n    float r = max(0.0001, (rayDirWS.y + 0.1)\/1.1);\n    float cosineLobeAverage = 2.0\/kPI;\n    r = mix(r, cosineLobeAverage, roughness);\n    \n    float normalisedTravelledDensity = exp(-r)\/r;\n    \n\tfloat rayDotSun = dot(rayDirWS, s_dirToSunWS);\n    float sr = max(0.0001, (s_dirToSunWS.y + 0.12)\/1.12);    \n    \n    float rayleighPhase = rayleighPhase(rayDotSun) \/ kIsotropicScatteringPhase;\n    rayleighPhase = mix(rayleighPhase, 1.0, roughness);\n        \n    vec3 rayleighTransmittance = exp(-(kRayleighScatteringCoefsKm) * kRayleighAtmHeightKm * normalisedTravelledDensity);\n    vec3 rayleighScattering = oz.xxx - rayleighTransmittance;\n    vec3 rMsCoefs = kRayleighScatteringCoefsKm * kRayleighScatteringCoefsKm * 1000.0;\n    vec3 rayleighMultipleScattering = kMultipleScatteringFakery * mix(rayleighScattering, s_averageSkyColour, 0.5);\n    \n    \/\/Hand tweaked earth shadowing \/ sky darkening\n    float earthShadow = smoothstep(-0.15, 0.1, s_dirToSunWS.y + rayDotSun*0.02);\n    \n\tvec3 sunTransmittance = max(0.00025*oz.xxx, \/\/Max to prevent the sky from being pitch black at night\n\t\tearthShadow * mix(rayleighTransmittance, oz.xxx, 0.2 + 0.8*saturate((s_dirToSunWS.y)*3.0)));\n        \n    vec3 sky = (rayleighScattering * sunTransmittance + \n                earthShadow * rayleighTransmittance * rayleighMultipleScattering) *\n        rayleighPhase;\n\n    float mieTransmittance = exp(-kMieScatteringCoefsKm*kMieAtmHeightKm*normalisedTravelledDensity);\n    float mieG = 0.75 - roughness*0.6;\n    sky = sky * mieTransmittance + henyeyGreensteinPhase_schlick(rayDotSun, mieG) \/ kIsotropicScatteringPhase\n        * s_cloudSunColour * earthShadow * (1.0 - mieTransmittance);\n   \n    transmittance = mieTransmittance * rayleighTransmittance;\n    return sky;\n}\n\nvec3 getSky(vec3 rayDirWS, float roughness)\n{\n    vec3 unused;\n    return getSky(rayDirWS, roughness, unused);\n}\n\nvoid initScene(vec3 eyePosWS, float time)\n{\n    s_eyePositionWS = eyePosWS;\n    s_time = time * 1.0;\n    s_dirToSunWS = normalize(vec3(0.4, 0.0, 0.5));\n    \n    float sunRotationPhase = kPI * 0.025;\n    s_timeOfDay = fract(0.5 + (s_time * sunRotationPhase \/ (2.0 * kPI))) - 0.5;\n    s_earthRotationRad = s_time * sunRotationPhase - sin(s_time * sunRotationPhase*2.0)*0.4;\n    \n    pR(s_dirToSunWS.yz, s_earthRotationRad);\n    \n    float sr = max(0.0001, (s_dirToSunWS.y + 0.0)\/1.0);\n    \n    s_sunColour = float(USE_SUN) * exp(-kRayleighScatteringCoefsKm*kRayleighAtmHeightKm*\n        exp(-sr)\/sr);\n\ts_sunRadiance = s_sunColour*5.0 \/ kSunDiskSolidAngle;\n\n    sr = max(0.02, (s_dirToSunWS.y + 0.01)\/1.01);\n    s_cloudSunColour = float(USE_SUN) * exp(-kRayleighScatteringCoefsKm*kRayleighAtmHeightKm*\n        exp(-sr)\/sr);\n        \n\ts_averageSkyColour = getSky(oz.yxy, 0.5);\n}\n\nvec3 applyAtmosphere(vec3 sceneColour, vec3 rayDirWS, float travelledDist, float shadow)\n{   \n    float rayDotSun = dot(rayDirWS, s_dirToSunWS);\n    float rayleighPhase = rayleighPhase(rayDotSun) \/ kIsotropicScatteringPhase;\n    \n    float r = max(0.05, (rayDirWS.y + 0.1)\/1.1);\n    float normalisedTravelledDensity = exp(-r)\/r;\n    \n    float distKm = min(kRayleighAtmHeightKm, travelledDist \/ 1000.0);\n    vec3 rayleighTransmittance = exp(-kRayleighScatteringCoefsKm*distKm*normalisedTravelledDensity);\n    \n    float sr = max(0.0001, (s_dirToSunWS.y + 0.12)\/1.12);\n    \n    \/\/Hand tweaked earth shadowing \/ sky darkening\n\tfloat earthShadow = smoothstep(-0.15, 0.1, s_dirToSunWS.y + rayDotSun*0.02);\n    \n\tvec3 sunTransmittance = max(0.00025*oz.xxx, \/\/Max to prevent the sky from being pitch black at night\n\t\tearthShadow * mix(rayleighTransmittance, oz.xxx, 0.2 + 0.8*saturate((s_dirToSunWS.y)*3.0)));   \n    \n    vec3 rayleighLighting = mix(s_averageSkyColour, rayleighPhase * sunTransmittance, shadow);\n    vec3 rayleighInscatter = rayleighLighting * (oz.xxx - rayleighTransmittance);\n\n    distKm = min(kMieAtmHeightKm, travelledDist \/ 1000.0);\n    float mieTransmittance = exp(-kMieScatteringCoefsKm*distKm*normalisedTravelledDensity);\n    float mieG = 0.7;\n    vec3 mieLighting = mix(s_averageSkyColour, henyeyGreensteinPhase_schlick(rayDotSun, mieG) * \n        s_cloudSunColour * earthShadow * 4.0 * kPI, shadow);\n    vec3 mieInscatter = mieLighting * (1.0 - mieTransmittance);\n    \n    vec3 atmTransmittance = rayleighTransmittance*mieTransmittance;\n    vec3 atmInscatter = rayleighInscatter*mieTransmittance + mieInscatter;\n    sceneColour = sceneColour * atmTransmittance + atmInscatter;\n    \n    \n    return sceneColour;\n}\n\n\nfloat diskLight(vec3 rayDirWS, vec3 dirToLightWS,\n           float cosAngularRadius, float roughness)\n{    \n    float brdfDiskSolidAngle = 2.0*kPI*(1.0 - (cosAngularRadius-roughness*1.0));\n    float diskSolidAngle = 2.0*kPI*(1.0 - cosAngularRadius);\n    float brightness = (max(0.00001, diskSolidAngle)\/max(0.00001, brdfDiskSolidAngle));\n    \n    float sharpness = 1.0 - roughness;\n\n    float vDotL = dot(rayDirWS, dirToLightWS);\n    \n    float cosRadiusStart = cosAngularRadius - 0.0001 - roughness*1.0;\n    float cosRadiusEnd = cosAngularRadius + 0.0001 + roughness*1.0;\n    float diskVisibility = linearstep(\n        cosRadiusStart, \n        cosRadiusEnd,\n    \tvDotL)*2.0;\n    \n    float brdfPower = 7.0 - 6.0*sqrt(roughness);\n\n    diskVisibility = pow(diskVisibility, brdfPower);\n\n    \/\/Integral S = (x^n dx) is F = x^(n+1) * 1\/(n+1)\n    \/\/Integral over range [A, B] is F(B) - F(A)\n    float powIntegral = 1.0\/(brdfPower + 1.0);\n\tfloat normalisationFactor = powIntegral;\n    \/\/Renormalize\n    diskVisibility \/= max(0.00001, normalisationFactor);\n    \n    diskVisibility = min(1.0, diskVisibility * brightness);\n\n    return diskVisibility;\n}\n\nvec3 getSun(vec3 rayDirWS, vec3 normalWS, float roughness)\n{\n    float sharpness = 1.0 - roughness;\n\n    float vDotL = dot(rayDirWS, s_dirToSunWS);\n    \n    vec3 sunDisk = diskLight(rayDirWS, \n                             s_dirToSunWS, kCosSunRadius, roughness)\n        * s_sunRadiance;\n    \n    float bloomBlend = linearstep(\n        kCosSunRadius - (1.0 - kCosSunRadius)*10.0 - roughness * 1.0,\n        kCosSunRadius + roughness * 1.0,\n        vDotL);\n    \n    sunDisk += pow(bloomBlend, 4.0) * s_sunColour * 2.0 * sharpness;\n    return sunDisk;\n}\n\nvec3 getSkyAndSun(vec3 rayDirWS)\n{\n    vec3 sky = getSky(rayDirWS, 0.0);\n    sky += getSun(rayDirWS, s_dirToSunWS, 0.0);\n    \n    return sky;\n}\n\nvec3 computeSphereLighting(vec3 posWS, vec3 coneDirWS, float roughness, vec4 lightSphere, vec3 colour,\n                      out float visibility)\n{\n    vec3 posToSphereWS = lightSphere.xyz - posWS;\n    float distToSphereCenter = length(posToSphereWS);\n    float sqDistToSphere = distToSphereCenter * distToSphereCenter;\n    float sqSphereRadius = lightSphere.a * lightSphere.a;\n    \n    float distToDisk = (1.0\/max(0.001, distToSphereCenter)) * max(0.001, sqDistToSphere - sqSphereRadius);\n    float diskRadius = (lightSphere.a\/distToSphereCenter)*sqrt(max(0.001, sqDistToSphere - sqSphereRadius));\n    \n    float cosSphereAngularRadius = clamp(distToDisk\/sqrt(distToDisk*distToDisk + \n                                        diskRadius*diskRadius), -1.0, 1.0);\n    vec3 posToSphereDirWS = posToSphereWS\/distToSphereCenter;\n    \n    float sphereLighting = diskLight(coneDirWS, posToSphereDirWS, \n                                     cosSphereAngularRadius, roughness);\n    \n    \/\/The point to light can be inside the sphere, blend to 1.0 at the center\n    sphereLighting = mix(1.0, sphereLighting, min(1.0, sqDistToSphere\/sqSphereRadius));\n    \n\tvisibility = sphereLighting;\n    \n    return colour * sphereLighting;\n}\n\nvec3 computeLighting(vec3 posWS, vec3 rayDirWS, vec3 normalWS, float roughness, float ambientVis, float shadow)\n{\n    vec3 lightingConeDirWS = normalize(mix(rayDirWS, normalWS, roughness*roughness*0.75));\n    \n    vec3 sky = getSky(lightingConeDirWS, roughness);\n\n    vec3 ambient = sky;\n    \n#if USE_ATM\n    vec3 skyUpColour = s_averageSkyColour;\n#else\n    vec3 skyUpColour = getSky(oz.yxy, 1.0);\n#endif        \n    \n    vec4 treeSphere = vec4(kTreePosWS + oz.yxy * 9.5, 5.5);\n    \n    vec3 groundPosWS = posWS + lightingConeDirWS * (posWS.y\/max(0.0001, -lightingConeDirWS.y));\n    \n    float treeShadow;\n    computeSphereLighting(groundPosWS, s_dirToSunWS, roughness, vec4(treeSphere.xyz, treeSphere.a + 2.0), oz.yyy, treeShadow);\n    vec3 vecToTreePosWS = posWS - kTreePosWS;\n    vec3 treeLeavesAlbedo = vec3(0.5, 0.0075, 0.005);\n    \n    vec3 sunLight = smoothstep(0.05, 0.15, s_dirToSunWS.y) * s_sunColour;\n    vec3 groundAlbedo = vec3(0.005, 0.35, 0.015);\n\n    vec3 groundColour = (groundAlbedo * 0.63 + 0.04) * ((1.0 - treeShadow) * sunLight + skyUpColour);\n    ambient = mix(ambient, groundColour, \n                  smoothstep(0.001+roughness*1.5, -0.001-roughness*1.5, lightingConeDirWS.y));\n\n\t\/\/Fallen leaves lighting\n    {\n        vec3 leavesCenterWS = kTreePosWS - oz.yxy * 0.5;\n        vec3 posToDiskCenterWS = leavesCenterWS - posWS;\n        vec3 posToDiskCenterDirWS =  normalize(posToDiskCenterWS);\n\n        vec3 leavesLighting = treeLeavesAlbedo * (0.35 * (1.0 - treeShadow) * sunLight + skyUpColour);\n\n        float diff = linearstep(-1.0 + min(1.0, -posToDiskCenterWS.y\/10.0), \n                                0.0 + min(1.0, -posToDiskCenterWS.y\/10.0), \n                                dot(posToDiskCenterDirWS, lightingConeDirWS));\n        diff *= 1.0 - min(1.0, dot(posToDiskCenterWS, posToDiskCenterWS)\/150.0);\n        ambient *= 1.0 - diff;  \n        ambient += diff * leavesLighting;           \n    }\n    \n    float sphereVisibility;\n    vec3 sphereLight = computeSphereLighting(posWS, lightingConeDirWS, roughness, \n                                         treeSphere, treeLeavesAlbedo * (skyUpColour + 0.5 * sunLight), \n                                         sphereVisibility);\n    ambient *= mix(1.0 - sphereVisibility, 1.0, 0.0*roughness);\n    ambient += sphereLight;\n    \n    ambient *= ambientVis;\n    ambient += getSun(lightingConeDirWS, normalWS, roughness) * shadow;\n\n    return ambient;\n}\n\nvec3 computeLighting(vec3 posWS, vec3 rayDirWS, vec3 normalWS, float roughness)\n{\n    return computeLighting(posWS, rayDirWS, normalWS, roughness, 1.0, 1.0);\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ Cameras \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nconst float kCameraPlaneDist = 1.35;\n\nfloat s_pixelConeWithAtUnitLength = 0.0;\n\nvec2 getScreenspaceUvFromRayDirectionWS(\n    vec3 rayDirectionWS,\n\tvec3 cameraForwardWS,\n\tvec3 cameraUpWS,\n\tvec3 cameraRightWS,\n\tfloat aspectRatio)\n{\n    vec3 eyeToCameraPlaneCenterWS = cameraForwardWS * kCameraPlaneDist;\n    \/\/ project rayDirectionWs onto camera forward\n    float projDist                 = dot(rayDirectionWS, cameraForwardWS);\n    vec3  eyeToPosOnCameraPlaneWS = rayDirectionWS \/ projDist * kCameraPlaneDist;\n    vec3  vecFromPlaneCenterWS       = eyeToPosOnCameraPlaneWS - eyeToCameraPlaneCenterWS;\n\n    float xDist = dot(vecFromPlaneCenterWS, cameraRightWS);\n    float yDist = dot(vecFromPlaneCenterWS, cameraUpWS);\n    \n    xDist \/= aspectRatio;\n    xDist = xDist * 0.5 + 0.5;\n    yDist = yDist * 0.5 + 0.5;\n\n    return vec2(xDist, yDist);\n}\n\nvoid computeCamera(float time, vec2 mouseNorm, vec4 iMouse, vec2 iResolution,\n                   out vec3 rayOriginWS,\n                   out vec3 cameraForwardWS,\n                   out vec3 cameraUpWS,\n                   out vec3 cameraRightWS\n                  )\n{\n\ts_pixelConeWithAtUnitLength = (1.0 \/ iResolution.y) \/ kCameraPlaneDist;\n\n    rayOriginWS = vec3(-17.8, 2.0, -9.07);\n    \n\tvec3 lookAtTarget = vec3( 0.0, 5.0, 0.0);\n\t\n    cameraForwardWS = normalize(lookAtTarget - rayOriginWS);\n\n    cameraRightWS = normalize(cross(oz.yxy, cameraForwardWS));\n    cameraUpWS = normalize(cross(cameraForwardWS, cameraRightWS));\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ Shadow mapping \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nconst float kShadowMapRangeWS = 14.0;\n\nvec3 getShadowForwardDirWS(vec3 dirToSunWS)\n{\n    vec3 shadowPlaneForwardWS = dirToSunWS;\n    shadowPlaneForwardWS.y = max(0.005, shadowPlaneForwardWS.y);\n    shadowPlaneForwardWS = normalize(shadowPlaneForwardWS);\n    \n    return shadowPlaneForwardWS;\n}\n\nvec3 getShadowUvFromPosWS(vec3 posWS)\n{\n    vec3 shadowPlaneForwardWS = getShadowForwardDirWS(s_dirToSunWS);\n    vec3 shadowPlaneRightWS = normalize(cross(oz.yxy, shadowPlaneForwardWS));\n    vec3 shadowPlaneUpWS = cross(shadowPlaneForwardWS, shadowPlaneRightWS);\n    \n    vec3 shadowPlaneCenterWS = kTreePosWS + oz.yxy * 7.0 - oz.xyy * 4.0;   \n    \n    vec3 centerToPosWS = posWS - shadowPlaneCenterWS;\n    \n    vec3 uvSNorm;\n    uvSNorm.x = dot(centerToPosWS, shadowPlaneRightWS);\n    uvSNorm.y = dot(centerToPosWS, shadowPlaneUpWS);\n    uvSNorm.z = dot(shadowPlaneForwardWS, centerToPosWS);\n    \n    uvSNorm \/= kShadowMapRangeWS;\n    \n    return vec3(uvSNorm.xy * 0.5 + 0.5*oz.xx, uvSNorm.z);\n}\n\nvec3 uvSNormToShadowRayStartWS(vec2 uvSNorm, vec3 shadowPlaneForwardWS)\n{   \n    vec3 shadowPlaneRightWS = normalize(cross(oz.yxy, shadowPlaneForwardWS));\n    vec3 shadowPlaneUpWS = cross(shadowPlaneForwardWS, shadowPlaneRightWS);\n    \n    vec3 rayStartWS = kTreePosWS + oz.yxy * 7.0 - oz.xyy * 4.0 +\n        (uvSNorm.x * shadowPlaneRightWS + uvSNorm.y * shadowPlaneUpWS) * kShadowMapRangeWS;\n    \n    return rayStartWS;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sf3Rn","filepath":"\/media\/a\/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"\/media\/ap\/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/   __  _                 _                                           \n\/\/  \/ _\\| |__    __ _   __| |  ___ __      __  _ __ ___    __ _  _ __  \n\/\/  \\ \\ | '_ \\  \/ _` | \/ _` | \/ _ \\\\ \\ \/\\ \/ \/ | '_ ` _ \\  \/ _` || '_ \\ \n\/\/  _\\ \\| | | || (_| || (_| || (_) |\\ V  V \/  | | | | | || (_| || |_) |\n\/\/  \\__\/|_| |_| \\__,_| \\__,_| \\___\/  \\_\/\\_\/   |_| |_| |_| \\__,_|| .__\/ \n\/\/                                                              |_|    \n\n\n#define ITER_SHADOW 128\nfloat marchShadow(vec3 rayOriginWS, vec3 rayDirWS, float t, float mt, out float lastDist)\n{\n    float d;\n    float minVisibility = 1.0;\n    lastDist = 100.0;\n    \n    vec4 material;\n    \n    for(int i = NON_CONST_ZERO; i < ITER_SHADOW && t < mt; ++i)\n    {\n        float coneWidth = max(0.00001, kTanSunRadius * t);\n        \n        vec3 posWS = rayOriginWS + rayDirWS*t;\n        d = fSDF(posWS, kShadowMapFilter, iChannel2, material);\n        \n        float stepMinVis = (d) \/ max(0.0001, coneWidth * 0.5);\n        if(stepMinVis <= minVisibility)\n        {\n            minVisibility = stepMinVis;\n            lastDist = t;\n        }\n        \n        t += max(0.01, d);           \n        \n        if(minVisibility < 0.01)\n        {\n            minVisibility = 0.0;\n        }\n    }\n      \n    return smoothstep(0.0, 1.0, minVisibility);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n    vec2 uvSNorm = uv * 2.0 - oz.xx;\n    \n    initScene(oz.xxx, iTime);\n        \n    vec3 shadowPlaneForwardWS = getShadowForwardDirWS(s_dirToSunWS);\n    \n\tvec3 rayStartWS = uvSNormToShadowRayStartWS(uvSNorm, shadowPlaneForwardWS);\n    \n    float offsetFromShadowPlane = min(100.0, rayStartWS.y\/shadowPlaneForwardWS.y);\n    rayStartWS -= shadowPlaneForwardWS * offsetFromShadowPlane;\n    \n    float shadowDist = 0.0;\n    float shadow = marchShadow(rayStartWS, shadowPlaneForwardWS, offsetFromShadowPlane - kShadowMapRangeWS, offsetFromShadowPlane + 100., shadowDist);\n    \n    shadowDist -= offsetFromShadowPlane;\n\n    fragColor = vec4(shadow, shadowDist\/kShadowMapRangeWS, 0.0, 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4sf3Rn","filepath":"\/media\/a\/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"\/media\/ap\/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"\/media\/a\/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"\/media\/ap\/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/\/   __                                                                           _      _               \n\/\/  \/ _\\  ___  ___  _ __    ___   _ __  __ _  _   _  _ __ ___    __ _  _ __  ___ | |__  (_) _ __    __ _ \n\/\/  \\ \\  \/ __|\/ _ \\| '_ \\  \/ _ \\ | '__|\/ _` || | | || '_ ` _ \\  \/ _` || '__|\/ __|| '_ \\ | || '_ \\  \/ _` |\n\/\/  _\\ \\| (__|  __\/| | | ||  __\/ | |  | (_| || |_| || | | | | || (_| || |  | (__ | | | || || | | || (_| |\n\/\/  \\__\/ \\___|\\___||_| |_| \\___| |_|   \\__,_| \\__, ||_| |_| |_| \\__,_||_|   \\___||_| |_||_||_| |_| \\__, |\n\/\/                                            |___\/                                                |___\/ \n\nfloat fMaterialSDF(vec3 samplePosWS, float dist, vec4 material)\n{\n    if(abs(material.x - kMatMountains) < 0.1)\n    {\n        vec2 uv = samplePosWS.xz * 0.0015;\n       \tfloat mountainNoise = noiseFbm(uv \/ material.y, iChannel2);\n        \n        dist -= mountainNoise * 5.0 * material.y;\n    }\n    else if(abs(material.x - kMatMapleBark) < 0.1)\n    {\n        float progressAlongBranch = material.w;\n        float u = material.z\/kPI;\n\n        vec2 branchUv = vec2(u * 0.5, progressAlongBranch * 0.5);\n\n        dist -= textureLod(iChannel2, branchUv, 0.0).r * 0.05; \n    }\n    else if(abs(material.x - kMatPines) < 0.1)\n    {\n        float pineGroundDist = material.y;\n        float mountainNoise = material.z;\n        dist -= sin(pineGroundDist*kPI)*0.5*(1.0 - pineGroundDist\/20.0);\n    }\n    return dist;\n}\n\nvec3 getNormalWS(vec3 p, float dt)\n{\n    vec3 normalWS = oz.yyy;\n    for( int i = NON_CONST_ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        vec3 samplePosWS = p + e * dt;\n        vec4 mat;\n        float dist = fSDF(samplePosWS, kRenderFilter, iChannel2, mat);\n        normalWS += e*fMaterialSDF(samplePosWS, dist, mat);\n    }\n    return normalize(normalWS);    \n}\n\nfloat sampleShadowMap(vec3 p, float startOffset)\n{\n    float shadowMapRangeWS = 14.0;\n    \n    vec3 uv_depth = getShadowUvFromPosWS(p);\n    \n    vec2 shadow_depth = textureLod(iChannel1, uv_depth.xy, 0.0).xy;\n    \n    if(shadow_depth.y > (uv_depth.z + startOffset \/ kShadowMapRangeWS))\n    {\n        return shadow_depth.x;\n    }\n    else\n    {\n        return 1.0;\n    }\n}\n\nfloat globalShadow(vec3 posWS, vec3 rayDirWS)\n{    \n    float softness = 0.01;\n    \n    \/\/ Far left\n    float scale = 1.65;\n    vec3 moutainPosWS = scale*vec3(300.0, -100.0, 1400.0);\n    moutainPosWS += scale*vec3(-200.0, 100.0, 0.0);\n    float mountainShadow = sphSoftShadow(posWS, rayDirWS, moutainPosWS, scale*600.0 * 0.85, softness);\n\n    \/\/ A bit to the right\n    scale = 2.7;\n    moutainPosWS = scale*vec3(600.0, -100.0, 1000.0);\n    moutainPosWS += scale*vec3(-50.0, 0.0, 0.0);\n    mountainShadow *= sphSoftShadow(posWS, rayDirWS, moutainPosWS, scale*500.0 * 0.6, softness);\n\n    scale = 4.45;\n    moutainPosWS = scale*vec3(1000.0, -200.0, 900.0);\n    mountainShadow *= sphSoftShadow(posWS, rayDirWS, moutainPosWS, scale*500.0 * 0.7, softness);\n\n    return mountainShadow;;\n   \n}\n\nfloat getShadow(vec3 p, vec3 sd)\n{\n\treturn sampleShadowMap(p, 0.1);\n}\n\nfloat cloudNoiseFbm(vec2 uv)\n{\n    float maxNoise = 0.0;\n    float noise = 0.0;\n    \n    float amplitude = 1.0;\n    float scale = 1.0;\n    \n    vec2 windOffset = oz.yy;\n    \n    for(int i = NON_CONST_ZERO; i < 7; ++i)\n    {\n        windOffset += s_time\/scale * 0.0015 * kWindVelocityWS.xz;\n        \n        noise += amplitude * textureLod(iChannel2, uv*scale - windOffset, 0.0).r;\n    \tmaxNoise += amplitude;\n    \tamplitude *= 0.5;\n        scale *= 2.0;\n    }\n    \n    return noise \/ maxNoise;\n}\n\nvec3 computeFinalLighting(float marchedDist, vec3 rayOriginWS, vec3 rayDirWS,\n                          vec4 material)\n{    \n    vec3 endPointWS = rayOriginWS + rayDirWS * marchedDist;\n\n    vec3 sceneColour = oz.yyy;\n    \n    if(marchedDist < kMaxDist)\n    {\n        float coneWidth = max(0.001, s_pixelConeWithAtUnitLength * (marchedDist - 10.0));\n        float normalDt = coneWidth;\n        vec3 normalWS = getNormalWS(endPointWS, normalDt);\n        normalWS = fixNormalBackFacingness(rayDirWS, normalWS);\n        \n        vec3 worldShadowOffset = oz.yxy * 1000.0 * linearstep(0.1, 0.2, s_timeOfDay);\n        float worldShadow = globalShadow(endPointWS + worldShadowOffset, s_dirToSunWS);\n        float atmShadow = saturate(worldShadow + (s_dirToSunWS.y - 0.0615)*15.0);\n     \tfloat shadow = getShadow(endPointWS, s_dirToSunWS) * worldShadow;        \n        \n        vec3 albedo = oz.xyx;\n        vec3 f0Reflectance = oz.xxx * 0.04;\n        float roughness = 0.6;\n        vec4 emissive = oz.yyyy;\n        float ambientVis = 1.0;\n\n        if(abs(material.x - kMatMapleLeaf) < 0.1\n               || abs(material.x - kMatFallingMapleLeaf) < 0.1)\n        {\n            ambientVis = max(0.25, material.y);\n            shadow *= material.y;\n            \n            float inside = material.z;\n            float leafRand = floor(material.w) \/ 100.0;\n            float tint = min(1.0, leafRand*leafRand*0.5 + inside);\n                \n            albedo = mix(vec3(0.5, 0.0075, 0.005), vec3(0.5, 0.15, 0.005), tint*tint);\n\n            float stick = max(0.0, fract(material.w) - 0.75*inside);\n\t\t\talbedo = mix(albedo, vec3(0.2, 0.04, 0.005), stick);\n            \/\/Backlighting\n            emissive.rgb = henyeyGreensteinPhase(dot(s_dirToSunWS, rayDirWS), 0.5)\n                * shadow * albedo * albedo * s_sunColour * (1.0 - stick) * 4.0;\n            \/\/emissive.a = 1.0;\n            vec2 uv = material.yz;\n\n            roughness = 0.7 - stick*0.2;\n        }\n        else if(abs(material.x - kMatMapleBark) < 0.1)\n        {\n            float progressAlongBranch = material.w;\n            ambientVis = max(0.25, material.y);\n            float u = material.z;\n            \n            vec2 branchUv = vec2(u, progressAlongBranch);\n            roughness = 0.6;\n\n            albedo = vec3(0.2, 0.04, 0.005);\n        }\n        else if(abs(material.x - kMatGrass) < 0.1)\n        {\n            float normalisedHeight = material.y;\n            ambientVis = 0.15 + 0.85*material.z;\n            shadow *= min(1.0, material.z * 3.0);\n            float grassRand = material.w;\n            \n            albedo = mix(vec3(0.005, 0.35, 0.015), vec3(0.1, 0.35, 0.015), \n                         saturate(normalisedHeight*normalisedHeight + (grassRand - 0.5)));\n\n            \/\/Backlighting\n            emissive.rgb = henyeyGreensteinPhase(dot(s_dirToSunWS, rayDirWS), 0.5)\n                * shadow * albedo * albedo * s_sunColour * 4.0 * normalisedHeight;\n            \n            roughness = 0.75;\n        }\n        else if(abs(material.x - kMatMountains) < 0.1)\n        {\n            float mountainNoise = material.z;\n            float mountainScale = material.y;\n            float detailNoise = noiseFbm(endPointWS.xz * (0.002 \/ mountainScale), iChannel2);\n            float noise = (detailNoise * 0.5 + mountainNoise) \/ 1.5;\n            float treeDist = material.w;\n            \n            albedo = 0.5*vec3(0.15, 0.025, 0.001);\n            roughness = 0.85;\n            \n            float rocks = linearstep(1.15, 1.3, detailNoise * 0.3 + noise * 0.7);\n            albedo = mix(albedo, oz.xxx * 0.1, rocks);\n            roughness = mix(0.85, 0.5, rocks);\n            \n            float snowAmount = saturate((noise - 0.5)*2.0 + (endPointWS.y - 550.0)\/300.0);\n            albedo = mix(albedo, oz.xxx, snowAmount);\n            roughness = mix(roughness, 1.0, snowAmount);\n            \n            ambientVis = (0.5 + 0.5*saturate(treeDist*0.1));\n            shadow *= saturate(treeDist*0.1);\n        }\n        else if(abs(material.x - kMatPines) < 0.1)\n        {\n            float mountainNoise = material.z;\n            float bottomToTop = material.y \/ 20.0;\n            \n            albedo = mix(0.5*vec3(0.005, 0.15, 0.01), 0.25*vec3(0.005, 0.1, 0.05), linearstep(1.0, 1.2, mountainNoise));\n            ambientVis = (0.5 + 0.5*bottomToTop);\n            shadow *= saturate(bottomToTop * 5.0);\n            roughness = 0.85;\n        }        \n            \n        \/\/Lighting part\n        {            \n            vec3 reflectedRayDirWS = reflect(rayDirWS, normalWS);\n            float rDotN = max(0.0001, dot(reflectedRayDirWS, normalWS));\n            vec3 fresnelReflectance = roughFresnel(f0Reflectance, rDotN, roughness);\n\n            vec3 diffuse = albedo * computeLighting(endPointWS, normalWS, normalWS, 1.0, ambientVis, shadow);\n            vec3 specular = computeLighting(endPointWS, reflectedRayDirWS, normalWS, roughness, ambientVis, shadow);\n            vec3 surfaceLighting = mix(diffuse, specular, fresnelReflectance);\n            sceneColour = surfaceLighting * (1.0 - emissive.a) + emissive.rgb;\n        }\n        \n        sceneColour = applyAtmosphere(sceneColour, rayDirWS, marchedDist, atmShadow);\n    }\n    else\n    {\n        vec3 skyColour = getSkyAndSun(rayDirWS);\n    \tsceneColour = skyColour;\n        \n        \/\/Stars\n        float scale = 3.0;\n        vec3 stars = oz.yyy;\n        for(uint i = NON_CONST_ZERO_U; i < 4u; ++i)\n        {\n            vec3 rd = rayDirWS;\n            rd.y = max(0.0001, (rd.y + 0.5) \/ 1.5);\n            vec2 uv = rd.xz\/rd.y;\n            uv.y += s_earthRotationRad;\n            uv += oz.xx * float(i) * kGoldenRatio;\n            \n            vec2 id = pMod2(uv, oz.xx * 0.1 * scale) + oz.xx * float(i) * kGoldenRatio;\n\n            vec2 rand = hash22(id * 73.157);\n            uv += (rand - 0.5*oz.xx) * 0.1 * scale;\n            \n            float starHeat = hash12(id * 73.157);\n            vec3 starColour = oz.xxx * 0.75 + 0.5 * hash32(id * 953.56);\n\t\t\tstarHeat *= starHeat;\n            float startFade = linearstep((0.5 + starHeat*0.5)*0.003\/rd.y, 0.0, length(uv));\n            stars += startFade * startFade * starColour * 0.04 * (0.5 + starHeat*starHeat) * scale * scale;\n            \n            scale *= 0.5;\n        }\n        \n        vec3 skyTransmittance;\n        getSky(rayDirWS, 0.0, skyTransmittance);\n        stars = stars * skyTransmittance;\n        \n        float cloudPlaneInterDist = 4000.0\/max(0.0001, rayDirWS.y + 0.13);\n        vec3 cloudPosWS = rayOriginWS + rayDirWS * cloudPlaneInterDist;\n        \n        float rayDotSun = dot(s_dirToSunWS, rayDirWS);\n        float earthShadow = smoothstep(-0.06, -0.04, s_dirToSunWS.y + (rayDotSun - 0.5)*0.035);\n        \n        vec2 cloudUv = fract(cloudPosWS.xz * 0.0000035); \n        vec2 cloudShadowUv = cloudUv + s_dirToSunWS.xz * 0.002; \n        \n        float cloudNoise = cloudNoiseFbm(cloudUv);\n        \n        float phase = henyeyGreensteinPhase_schlick(dot(rayDirWS, s_dirToSunWS), 0.7);\n        float cloudTransmittance = 1.0 - smoothstep(0.6, 0.7, cloudNoise);\n        float cloudShadow = 1.0 - 0.9*smoothstep(0.5, 0.8, cloudNoiseFbm(cloudShadowUv));\n        vec3 cloudInscatter = s_averageSkyColour + max(oz.xxx * 0.00035, s_cloudSunColour * earthShadow) *\n            (1.0 + phase * 1.0 * kPI) * cloudShadow;\n        \n        cloudInscatter = applyAtmosphere(cloudInscatter, rayDirWS, cloudPlaneInterDist, 1.0);\n        \n        sceneColour += stars;\n        sceneColour = sceneColour * cloudTransmittance + (1.0 - cloudTransmittance) * cloudInscatter;\n    }\n    \n    return sceneColour;\n}\n\nfloat fogNoiseFbm(vec3 uvw)\n{\n    float maxNoise = 0.0;\n    float noise = 0.0;\n    \n    float amplitude = 1.0;\n    \n    for(int i = NON_CONST_ZERO; i < 3; ++i)\n    {\n        noise += amplitude * textureLod(iChannel3, uvw, 0.0).r;\n    \tmaxNoise += amplitude;\n    \tamplitude *= 0.5;\n        uvw *= 2.0;\n    }\n    \n    return noise \/ maxNoise;\n}\n\n#define ITER 1024\nfloat march(vec3 rayOriginWS, vec3 rayDirWS, float rand, out vec3 sceneColour, out float responsiveness)\n{\n    float phase = 4.0 * kPI * \n        (henyeyGreensteinPhase_schlick(dot(rayDirWS, s_dirToSunWS), 0.7) + \n        kIsotropicScatteringPhase);\n        \n    vec4 material;\n    \n    vec3 inscatter = oz.yyy;\n    float transmittance = 1.0;\n    \n    float t = 0.001;\n    float d;\n    \n    for(int i = NON_CONST_ZERO; i < ITER; ++i)\n    {\n        float coneWidth = max(0.001, s_pixelConeWithAtUnitLength * (t - 10.0));\n        \n        vec3 posWS = rayOriginWS + rayDirWS*t;\n        d = fSDF(posWS, kRenderFilter, iChannel2, material);\n        \n        t += d;\n        \n        if(i >= ITER - 1)\n        {\n            t = kMaxDist;\n        }              \n        \n        if(d < coneWidth || t >= kMaxDist)\n        {\n            break;\n        }\n        \n        \n        \/\/ Add some fog at the bottom of the tree, because shadowing from leaves looks cool !\n#if 1\n        vec3 fogVolumeCenterWs = kTreePosWS - oz.yxy * 99.0;\n        float distToFogVolume = fCapsule(posWS, fogVolumeCenterWs, \n                                         fogVolumeCenterWs,\n                                         100.0);\n        float distToTree = length((kTreePosWS - s_dirToSunWS * oz.xyx * 5.0) - posWS);\n        \n        float densityBias = ( max(0.0, distToTree - 2.0) * 0.035 + 0.2 ) +\n            linearstep(0.0, 10.0, distToFogVolume);\n        \n        if(densityBias < 1.0)\n        {\n            float fogNoise = fogNoiseFbm((posWS - oz.yxy * 0.75 * s_time) * 0.025);\n            fogNoise = max(0.0, fogNoise - densityBias);\n            fogNoise = saturate(fogNoise * 2.0);\n\n            float scatteringCoef = fogNoise * 0.1;\n\n            float stepTransmittance = exp(-scatteringCoef*d);\n\n            posWS = rayOriginWS + rayDirWS*(t - d*rand);\n            float shadow = sampleShadowMap(posWS, 0.0) * linearstep(0.0575, 0.1, s_dirToSunWS.y);;\n\n                vec3 stepLighting =  s_sunColour * shadow * phase;\n            stepLighting += s_averageSkyColour;\n\n            inscatter += transmittance * (1.0 - stepTransmittance) * stepLighting;\n            transmittance *= stepTransmittance;\n        }\n#endif\n        \n    }\n      \n    sceneColour = computeFinalLighting(t, rayOriginWS, rayDirWS, material);\n    \n    sceneColour = sceneColour * transmittance + inscatter;\n    \n    responsiveness = abs(material.x - kMatFallingMapleLeaf) < 0.1 ? 1.0f : 0.0f;\n    \n    return t;\n}\n\n\nvec3 applyBloom(vec3 colour, vec2 uv, vec2 subPixelJitter)\n{\n#if 1\n    float totalWeight = 0.0;\n    vec3 bloom = oz.yyy;\n    \n    float kernel = 1.0;\n    \/\/Super sample low mips to get less blocky bloom\n    for(float xo = -kernel; xo < kernel + 0.1; xo += 0.5)\n    {\n        for(float yo = -kernel; yo < kernel + 0.1; yo += 0.5)\n        {\n            vec2 vo = vec2(xo, yo);\n            float weight = (kernel*kernel*2.0) - dot(vo, vo);\n            vo += 0.5 * (subPixelJitter);\n            vec2 off = vo*(0.5\/kernel)\/iResolution.xy;\n            \n            if(weight > 0.0)\n            {\n                float maxBloom = 5.0;\n                bloom += weight * min(maxBloom*oz.xxx, textureLod(iChannel0, uv + off*exp2(5.0), 5.0).rgb);totalWeight += weight;\n                bloom += weight * min(maxBloom*oz.xxx, textureLod(iChannel0, uv + off*exp2(6.0), 6.0).rgb);totalWeight += weight;\n                bloom += weight * min(maxBloom*oz.xxx, textureLod(iChannel0, uv + off*exp2(7.0), 7.0).rgb);totalWeight += weight;\n            }\n        }\n    }\n\n    bloom.rgb \/= totalWeight;\n    \n    colour.rgb = colour.rgb * 0.8 + pow(bloom, oz.xxx*1.5) * 0.3;\n#endif\n    \n    return colour;\n}\n\n\n#define TAA 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 subPixelJitter = fract(hash22(fragCoord)\n                                + float(iFrame%256) * kGoldenRatio * oz.xx) - 0.5*oz.xx;\n    \n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n    float jitterAmount = float(TAA);\n    \n    vec2 uvJittered = (fragCoord.xy + jitterAmount * subPixelJitter) \/ iResolution.xy;\n    \n    float aspectRatio = iResolution.x\/iResolution.y;\n    vec2 uvSNorm = uvJittered * 2.0 - vec2(1.0);\n    uvSNorm.x *= aspectRatio;\n    \n    vec2 mouseUNorm = iMouse.xy\/iResolution.xy;\n    vec2 mouseNorm = mouseUNorm*2.0 - vec2(1.0);\n    \n    vec3 rayOriginWS;\n    \n    \/\/ ---- Camera setup ---- \/\/\n    vec3 cameraForwardWS, cameraUpWS, cameraRightWS;\n    computeCamera(iTime, mouseNorm, iMouse, iResolution.xy, rayOriginWS, cameraForwardWS, cameraUpWS, cameraRightWS);\n    vec3  rayDirWS = normalize(uvSNorm.x*cameraRightWS + uvSNorm.y*cameraUpWS + kCameraPlaneDist*cameraForwardWS);\n    \n    initScene(rayOriginWS, iTime);\n    \n    \/\/ ---- TAA part ---- \/\/  \n    float prevTime = iTime - iTimeDelta;\n    vec3 prevCameraPosWS, prevCameraForwardWS, prevCameraUpWS, prevCameraRightWS;\n    computeCamera(prevTime, mouseNorm, iMouse, iResolution.xy, prevCameraPosWS, \n                  prevCameraForwardWS, prevCameraUpWS, prevCameraRightWS);\n    \n    \/\/ ---- Render scene ---- \/\/\n    float responsiveness;\n    vec3 sceneColour;\n    float tt = march(rayOriginWS, rayDirWS, hash12(fragCoord), sceneColour, responsiveness);\n    \n    float nightTimeStrength = linearstep(-0.15, -0.6, s_dirToSunWS.y);\n    \n    float exposure = 1.0 + nightTimeStrength*150.0;\n    sceneColour *= exposure;\n    \n    sceneColour = applyBloom(sceneColour, uv, subPixelJitter);\n        \n    \/\/ ---- Flares ---- \/\/\n    {\n        float sunVisibility = sampleShadowMap(rayOriginWS, 0.0) * globalShadow(rayOriginWS, s_dirToSunWS);\n        float numApertureBlades = 8.0;\n\n        vec2 sunUv = getScreenspaceUvFromRayDirectionWS(s_dirToSunWS,\n                                                           cameraForwardWS, cameraUpWS, cameraRightWS, aspectRatio);\n        vec2 sunUvSNorm = sunUv * 2.0 - vec2(1.0);\n    \tsunUvSNorm.x *= aspectRatio;\n        \n        vec2 sunUvDirSNorm = normalize(sunUvSNorm);\n        \n        float rDotL = dot(rayDirWS, s_dirToSunWS);\n        \n        vec2 uvToSunSNorm = sunUvSNorm - uvSNorm;\n        float starBurst = 0.5 + 0.5*cos(1.5 * kPI + atan(uvToSunSNorm.x, uvToSunSNorm.y) * numApertureBlades);\n        float startFade = linearstep(0.97, 1.0, rDotL);\n        float starWidth = linearstep(0.5, 1.0, rDotL);\n        starBurst = pow(starBurst, max(1.0, 500.0 - starWidth*starWidth * 501.0))*startFade;\n\n        vec3 totalFlares = starBurst * 1.5 * linearstep(0.875, 1.0, rDotL*rDotL) * oz.xxx;\n\n        vec2 flareCenterUvSNorm;\n        \n        flareCenterUvSNorm = sunUvSNorm * 2.0;\n        totalFlares += 0.5 * vec3(0.1, 0.15, 0.01) * \n            linearstep(0.05, 0.0, sdOctogon(flareCenterUvSNorm - uvSNorm, 0.35));\n        \n        flareCenterUvSNorm = sunUvSNorm * 1.5;\n        totalFlares += 0.65 * vec3(0.015, 0.12, 0.09) * \n            linearstep(0.03, 0.0, sdOctogon(flareCenterUvSNorm - uvSNorm, 0.2));\n        \n        flareCenterUvSNorm = sunUvSNorm * 0.25;\n        totalFlares += 2.5 * vec3(0.1, 0.1, 0.1) * \n            linearstep(0.01, 0.0, sdOctogon(flareCenterUvSNorm - uvSNorm, 0.1));\n        \n        flareCenterUvSNorm = sunUvSNorm * 0.1;\n        totalFlares += 4.0 * vec3(0.11, 0.11, 0.1) * \n            linearstep(0.02, 0.0, sdOctogon(flareCenterUvSNorm - uvSNorm, 0.05));\n        \n        flareCenterUvSNorm = sunUvSNorm * -0.12;\n        totalFlares += 3.5 * vec3(0.15, 0.05, 0.025) * \n            linearstep(0.01, 0.0, sdOctogon(flareCenterUvSNorm - uvSNorm, 0.15));\n        \n        flareCenterUvSNorm = sunUvSNorm * -0.25;\n        totalFlares += 0.8 * vec3(0.02, 0.15, 0.1) * \n            linearstep(0.02, 0.0, sdOctogon(flareCenterUvSNorm - uvSNorm, 0.25));\n        \n        \/\/First coloured circle\n        {\n            flareCenterUvSNorm = sunUvSNorm * 0.5;\n\n            float distToDisk = length(flareCenterUvSNorm - uvSNorm) - length(flareCenterUvSNorm * 2.0);\n            float ci = smoothstep(0.2, 0.01, abs(distToDisk));\n            float colourRamp = linearstep(-0.2, 0.2, distToDisk);\n            vec2 uvToSunDir = normalize(uvToSunSNorm);\n            vec3 repColour = wavelengthToRGB(300.0 + colourRamp * 500.0);\n\n            totalFlares += 0.25 * repColour * ci * linearstep(0.75, 1.0, dot(sunUvDirSNorm, uvToSunDir));\n        }\n        \n        \/\/Second coloured circle\n        {\n            flareCenterUvSNorm = sunUvSNorm * 0.5;\n\n            float distToDisk = length(flareCenterUvSNorm - uvSNorm) - length(flareCenterUvSNorm * 1.6);\n            float ci = smoothstep(0.4, 0.0, abs(distToDisk));\n            float colourRamp = linearstep(-0.8, 0.8, distToDisk);\n\t\t\tvec2 uvToSunDir = normalize(uvToSunSNorm);\n            vec3 repColour = wavelengthToRGB(300.0 + colourRamp * 500.0);\n            totalFlares += 0.25 * repColour * ci * linearstep(0.98, 1.0, dot(sunUvDirSNorm, uvToSunDir));\n        }\n        \n        \n        flareCenterUvSNorm = sunUvSNorm * -1.4;\n        totalFlares += 0.8 * vec3(0.1, 0.15, 0.075) * \n            linearstep(0.015, 0.0, sdOctogon(flareCenterUvSNorm - uvSNorm, 0.17));\n        \n        \n        flareCenterUvSNorm = sunUvSNorm * -2.0;\n        totalFlares += 3.0 * vec3(0.1, 0.05, 0.02) * \n            linearstep(0.4, 0.0, sdOctogon(flareCenterUvSNorm - uvSNorm, 0.1));\n        \n        sceneColour += totalFlares * 0.2 * s_sunColour * sunVisibility * linearstep(3.2, 2.0, length(sunUvSNorm));\n    }\n    \n    vec2 prevFrameUv = uv;\n    vec4 prevData = texture(iChannel0, prevFrameUv);\n    \n    float defaultBlendToCurrent = (2.0\/9.0)*max(1.0, iTimeDelta\/0.066);\n    float blendedResp = mix(prevData.a, responsiveness, defaultBlendToCurrent);\n    float blendToCurrent = mix(defaultBlendToCurrent, 1.0, blendedResp);\n    \/\/Increase TAA at night to get stars trails\n    blendToCurrent = min(1.0, mix(blendToCurrent, iTimeDelta, nightTimeStrength));\n    \n#if !TAA    \n    blendToCurrent = 1.0;\n#endif\n    \n    \/\/Clamp to prevent the sun from leaving a trail\n    sceneColour = min(oz.xxx * 3.0, sceneColour);\n    sceneColour = max(oz.yyy, mix(prevData.rgb, sceneColour, blendToCurrent));\n    \n    fragColor = vec4(sceneColour, responsiveness);\n}","name":"Buffer B","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"Xlc3Rf","date":"1470438705","viewed":12145,"name":"Worley Hyperdisc - Ocean Planet","username":"CaliCoastReplay","description":"3rd mix of the Worley noise shader at https:\/\/www.shadertoy.com\/view\/Xl33Wn , the hyperbolic disc from : https:\/\/www.shadertoy.com\/view\/XllSWf , and starfield from https:\/\/www.shadertoy.com\/view\/4scXWB .  Try it at high-res!","likes":72,"published":1,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/Adapted from:  https:\/\/www.shadertoy.com\/view\/Xl33Wn\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 \/ 3.0, 2.0 \/ 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) \/ (6.0 * d + e)), d \/ (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 \/ 3.0, 1.0 \/ 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat length2(vec2 p){\n    return dot(p,p);\n}\nfloat noise(vec2 p )\n{\n    return fract(sin(fract(sin(p.x)*(41.13311))+ p.y)*31.0011);\n}\n\nfloat worley(vec2 p) {\n float d = 1e30;\n for (int xo = -1; xo <= 1; ++xo) {\n  for (int yo = -1; yo <= 1; ++yo) {\n   vec2 tp = floor(p) + vec2(xo, yo);\n   d = min(d, length2(p - tp - noise(tp)));\n  }\n }\n  return 3.0*exp(-4.4*abs((2.5*d)-1.0));\n}\n\nfloat fworley(vec2 p)\n{\n    return sqrt(sqrt(sqrt(worley(p * 11.0 + 0.15 * iTime) * \n                          sqrt(worley(p*50.0+ 0.18+ -0.12*iTime)) *\n                         sqrt(sqrt(worley(p*-10.0+0.3*iTime))))));\n}\n\n\n\/\/hyperbolic disc\/radial distortion adapted from https:\/\/www.shadertoy.com\/view\/XllSWf\nvec2 HyperbolicDisc(vec2 fragCoord) {    \n    fragCoord -= iResolution.xy * 0.29;\n    fragCoord \/= iResolution.x;\n    float r = length(fragCoord);\n    vec2 d = fragCoord \/ r *1.5 ;\n    fragCoord = d \/ atanh(r * (2.5 )) \/ 2.0;\n    fragCoord *= iResolution.x;\n    fragCoord += iResolution.xy *0.212;\n    fragCoord += 1.59+ sin(iTime\/10.0);\n    return fragCoord;\n}\n\nfloat flare( vec2 U )                            \/\/ rotating hexagon \n{\tvec2 A = sin(vec2(0, 1.57) + iDate.w);\n    U = abs( U * mat2(A, -A.y, A.x) ) * mat2(2,0,1,1.7); \n    return .2\/max(U.x,U.y);                      \/\/ glowing-spiky approx of step(max,.2)\n  \/\/return .2*pow(max(U.x,U.y), -2.);\n \n}\n\n#define r(x)     fract(1e4*sin((x)*541.17))      \/\/ rand, signed rand   in 1, 2, 3D.\n#define sr2(x)   ( r(vec2(x,x+.1)) *2.-1. )\n#define sr3(x)   ( r(vec4(x,x+.1,x+.2,0)) *2.-1. )\n\nvec4 stars( vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    U =  (U+U - R) \/ R.y;\n\tO -= O+.3;\n    for (float i=0.; i<99.; i++)\n        O += flare (U - sr2(i)*R\/R.y )           \/\/ rotating flare at random location\n              * r(i+.2)                          \/\/ random scale\n              * (1.+sin(iDate.w+r(i+.3)*6.))*.1  \/\/ time pulse\n            \/\/* (1.+.1*sr3(i+.4));               \/\/ random color - uncorrelated\n              * (1.+.1*sr3(i));                  \/\/ random color - correlated\n    return O;\n}\n\nvec4 fake_planet( vec2 fragCoord )\n{\n    vec4 fragColor;\n    vec2 fragCoord2;\n    fragCoord2.x += sin(iTime\/3.5)*12.0;\n    fragCoord2.y += cos(iTime\/3.5)*12.0;\n    fragCoord2 = HyperbolicDisc(fragCoord);\n    vec2 uv = fragCoord2.xy \/ iResolution.xy;\n    float wolo = fworley(uv*iResolution.xy \/ 1919.0) + fworley((uv*iResolution.xy + sin(iTime*2.0)) \/ 3200.0)\n         + fworley((uv*iResolution.xy - sin(iTime*2.0)) \/ 4800.0);\n \twolo *= .85*exp(-length2(abs(0.5*uv-0.9)));\n    fragColor = vec4(wolo * vec3(0.1*wolo*wolo, 0.3*wolo, 1.2*pow(wolo, 0.90-wolo)), 1.0);\n    vec3 hsv = rgb2hsv(fragColor.xyz);\n    hsv.z *= sqrt(hsv.z) * 1.1+ cos(iTime\/13.0)*0.4;\n    hsv.x += hsv.z\/200.0 * sin(iTime\/2.0)*2.0;\n    hsv.y -= hsv.z\/102.0;\n    fragColor.xyz = hsv2rgb(hsv);\n    return fragColor;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 starColor = stars(fragColor, fragCoord);\n    vec4 planetColor = fake_planet(fragCoord);\n    float distanceToCenter = 0.0;\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n    float xDist = uv.x - 0.35;\n    float yDist = uv.y - 0.35;\n    distanceToCenter += sqrt(xDist*xDist\/.29 + yDist*yDist);\n    if (distanceToCenter > 0.60)\n    \tfragColor =starColor\/2.0;\n    else        \n    {\n        float falloff =  1.0-distanceToCenter;\n    \tfragColor = planetColor * falloff *falloff * falloff * 1.90;\n    }\n\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"lslGWr","date":"1367919742","viewed":12135,"name":"Simplicity","username":"JoshP","description":"Beauty in simplicity.","likes":271,"published":1,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[],"code":"\/\/ http:\/\/www.fractalforums.com\/new-theories-and-research\/very-simple-formula-for-fractal-patterns\/\nfloat field(in vec3 p) {\n\tfloat strength = 7. + .03 * log(1.e-6 + fract(sin(iTime) * 4373.11));\n\tfloat accum = 0.;\n\tfloat prev = 0.;\n\tfloat tw = 0.;\n\tfor (int i = 0; i < 32; ++i) {\n\t\tfloat mag = dot(p, p);\n\t\tp = abs(p) \/ mag + vec3(-.5, -.4, -1.5);\n\t\tfloat w = exp(-float(i) \/ 7.);\n\t\taccum += w * exp(-strength * pow(abs(mag - prev), 2.3));\n\t\ttw += w;\n\t\tprev = mag;\n\t}\n\treturn max(0., 5. * accum \/ tw - .7);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = 2. * fragCoord.xy \/ iResolution.xy - 1.;\n\tvec2 uvs = uv * iResolution.xy \/ max(iResolution.x, iResolution.y);\n\tvec3 p = vec3(uvs \/ 4., 0) + vec3(1., -1.3, 0.);\n\tp += .2 * vec3(sin(iTime \/ 16.), sin(iTime \/ 12.),  sin(iTime \/ 128.));\n\tfloat t = field(p);\n\tfloat v = (1. - exp((abs(uv.x) - 1.) * 6.)) * (1. - exp((abs(uv.y) - 1.) * 6.));\n\tfragColor = mix(.4, 1., v) * vec4(1.8 * t * t * t, 1.4 * t * t, t, 1.0);\n}","name":"","description":"","type":"image"}]}];    var gUseScreenshots = piIsMobile();
    var gThemeName = "classic";



    </script>
</head>

<!-- <body onload="resultsInit(12,null,null)"> -->
<body onload="resultsInitStatic(12,null,null)">

<!-- header =================================================================================== -->


<div id="header">

    <div id="headerBlock1">
        <a href="/" id="headerTitle">Shadertoy</a>
        <form name="formSearch" action="/results" method="get" style="display:inline-block;">
        <div  id="headerSearch">
            <input type="search" id="mySearch" name="query" placeholder="Search..." value=""/>
        </div>
        </form>
    </div>

    <div id="headerBlock2">
            <a class="headerLinks" href="/browse">Browse</a>
        <a class="headerLinks" href="/new">New</a>
        <a class="headerLinks" href="/signin">Sign In</a>
        </div>
</div>
<!-- content ================================================================================== -->

<div id="content">

  <div id="controls">
    <div>
      <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
      Sort:      </div>
      <div class="controlOptions"><div class="pageButtonsCurrent" href="/results?query=&sort=popular&filter=">Popular</div><a class="pageButtons" href="/results?query=&sort=newest&filter=">Newest</a><a class="pageButtons" href="/results?query=&sort=love&filter=">Love</a><a class="pageButtons" href="/results?query=&sort=hot&filter=">Hot</a></div>
    </div>

    <div id="controlFilter">
      <div style="display:flex;margin-right:8px;align-items:center;">Filter:</div>
      <div class="controlOptions"> <a class="pageButtons" href="/results?query=&sort=popular&filter=multipass">Multipass</a><a class="pageButtons" href="/results?query=&sort=popular&filter=soundoutput">GPU Sound</a><a class="pageButtons" href="/results?query=&sort=popular&filter=vr">VR</a><a class="pageButtons" href="/results?query=&sort=popular&filter=soundinput">Microphone</a><a class="pageButtons" href="/results?query=&sort=popular&filter=musicstream">Soundcloud</a><a class="pageButtons" href="/results?query=&sort=popular&filter=webcam">Webcam</a></div>
    </div>

    <div>
        <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
        View:</div>
        <div><a class="pageButtons" href="/slideshow?query=&sort=popular">Slideshow</a></div>
    </div>

    <div class="navigation" id="navTop" ><span style="padding-right:8px;">Results (74098):</span><div class="controlOptions"><a id="pageButtonFirst" class="pageButtons" href="results?query=&sort=popular&from=0&num=12">1</a><span>...</span><a id="pageButton"0 class="pageButtons" href="results?query=&sort=popular&from=516&num=12">44</a><a id="pageButton"1 class="pageButtons" href="results?query=&sort=popular&from=528&num=12">45</a><div id="pageButton"2 class="pageButtonsCurrent" href="results?query=&sort=popular&from=540&num=12">46</div><a id="pageButton"3 class="pageButtons" href="results?query=&sort=popular&from=552&num=12">47</a><a id="pageButton"4 class="pageButtons" href="results?query=&sort=popular&from=564&num=12">48</a><span>...</span><a id="pageButtonLast" class="pageButtons" href="results?query=&sort=popular&from=74088&num=12">6175</a></div>
</div>
  </div>


  <div id="shaderGrid">
    <div class='searchResult'><div class='searchResultContainer' id='Preview_0_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_0_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_0_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_0_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_0_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_0_Thumnail'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_0_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_0_Info'>  <span class='previewText'  id='Preview_0_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_0_TextUser'></span>  <span class='previewStats' id='Preview_0_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_1_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_1_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_1_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_1_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_1_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_1_Thumnail'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_1_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_1_Info'>  <span class='previewText'  id='Preview_1_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_1_TextUser'></span>  <span class='previewStats' id='Preview_1_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_2_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_2_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_2_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_2_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_2_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_2_Thumnail'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_2_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_2_Info'>  <span class='previewText'  id='Preview_2_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_2_TextUser'></span>  <span class='previewStats' id='Preview_2_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_3_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_3_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_3_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_3_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_3_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_3_Thumnail'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_3_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_3_Info'>  <span class='previewText'  id='Preview_3_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_3_TextUser'></span>  <span class='previewStats' id='Preview_3_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_4_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_4_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_4_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_4_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_4_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_4_Thumnail'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_4_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_4_Info'>  <span class='previewText'  id='Preview_4_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_4_TextUser'></span>  <span class='previewStats' id='Preview_4_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_5_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_5_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_5_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_5_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_5_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_5_Thumnail'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_5_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_5_Info'>  <span class='previewText'  id='Preview_5_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_5_TextUser'></span>  <span class='previewStats' id='Preview_5_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_6_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_6_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_6_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_6_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_6_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_6_Thumnail'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_6_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_6_Info'>  <span class='previewText'  id='Preview_6_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_6_TextUser'></span>  <span class='previewStats' id='Preview_6_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_7_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_7_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_7_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_7_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_7_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_7_Thumnail'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_7_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_7_Info'>  <span class='previewText'  id='Preview_7_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_7_TextUser'></span>  <span class='previewStats' id='Preview_7_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_8_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_8_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_8_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_8_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_8_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_8_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_8_Thumnail'>        <img class='previewThumbnailImage' id='Preview_8_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_8_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_8_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_8_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_8_Info'>  <span class='previewText'  id='Preview_8_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_8_TextUser'></span>  <span class='previewStats' id='Preview_8_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_9_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_9_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_9_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_9_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_9_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_9_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_9_Thumnail'>        <img class='previewThumbnailImage' id='Preview_9_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_9_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_9_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_9_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_9_Info'>  <span class='previewText'  id='Preview_9_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_9_TextUser'></span>  <span class='previewStats' id='Preview_9_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_10_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_10_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_10_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_10_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_10_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_10_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_10_Thumnail'>        <img class='previewThumbnailImage' id='Preview_10_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_10_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_10_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_10_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_10_Info'>  <span class='previewText'  id='Preview_10_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_10_TextUser'></span>  <span class='previewStats' id='Preview_10_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_11_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_11_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_11_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_11_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_11_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_11_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_11_Thumnail'>        <img class='previewThumbnailImage' id='Preview_11_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_11_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_11_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_11_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_11_Info'>  <span class='previewText'  id='Preview_11_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_11_TextUser'></span>  <span class='previewStats' id='Preview_11_Stats'></span></div></div>  </div>
  <br>
  <div class="navigation" id="navBottom" ><span style="padding-right:8px;">Results (74098):</span><div class="controlOptions"><a id="pageButtonFirst" class="pageButtons" href="results?query=&sort=popular&from=0&num=12">1</a><span>...</span><a id="pageButton"0 class="pageButtons" href="results?query=&sort=popular&from=516&num=12">44</a><a id="pageButton"1 class="pageButtons" href="results?query=&sort=popular&from=528&num=12">45</a><div id="pageButton"2 class="pageButtonsCurrent" href="results?query=&sort=popular&from=540&num=12">46</div><a id="pageButton"3 class="pageButtons" href="results?query=&sort=popular&from=552&num=12">47</a><a id="pageButton"4 class="pageButtons" href="results?query=&sort=popular&from=564&num=12">48</a><span>...</span><a id="pageButtonLast" class="pageButtons" href="results?query=&sort=popular&from=74088&num=12">6175</a></div>
</div>  <br>      
</div>

<!-- footer ================================================================================== -->

<div id="footer">
    
    <div><span style="color:#ffffff;">Community Forums</span>
      <ul>
      <li><a class="regular" href="/events">Official Events</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/147749602472741">In Facebook (english)</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/1339783682699494">In Facebook (korean)</a></li>
      <li><a class="regular" href="https://discord.gg/XtmMN6E">In Discord</a> (<a class="regular" href="https://discordapp.com/channels/578696555612209173/579531723348639754">direct link</a>)</li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Feedback and Support</span>
      <ul>
      <li><a class="regular" href="https://www.facebook.com/Shadertoy">Facebook</a></li>
      <li><a class="regular" href="https://twitter.com/shadertoy">Twitter</a></li>
      <li><a class="regular" href="https://www.patreon.com/shadertoy">Patreon</a></li>
      <li><a class="regular" href="https://trello.com/b/5hM0CjId">Roadmap</a></li>

      
      </ul>
    </div>

    <div><span style="color:#ffffff;">Shadertoy</span>
      <ul>
      <li><a class="regular" href="/store">Store</a></li>
      <li><a class="regular" href="/howto">Documentation</a></li>
      <li><a class="regular" href="/terms">Terms & Privacy</a></li>
      <li><a class="regular" href="/about">About</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Apps and Plugins</span>
      <ul>
      <li><a class="regular" href="https://itunes.apple.com/us/app/shadertoy/id717961814">Official iPhone App</a> by <a class="user" href="/user/reinder">Reinder</a></li>
      <li><a class="regular" href="https://steamcommunity.com/sharedfiles/filedetails/?id=1726697188">Screensaver</a> by <a class="user" href="/user/kosro">Kosro</a></li>
      <li><a class="regular" href="https://chrome.google.com/webstore/detail/shadertoy-unofficial-plug/ohicbclhdmkhoabobgppffepcopomhgl">Shadertoy plugin</a> by <a class="user" href="/user/patu">Patu</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Tutorials</span>
      <ul>
      <li><a class="regular" href="https://www.youtube.com/watch?v=0ifChJ0nJfM">Shader coding intro</a> by <a class="user" href="/user/iq">iq</a></li>
      <li><a class="regular" href="https://shadertoyunofficial.wordpress.com/">Shadertoy Unofficial</a> by <a class="user" href="/user/FabriceNeyret2">FabriceNeyret2</a></li>
      </ul>
    </div>

</div>

<div id="compliance" style="padding-bottom:6px;visibility:hidden;left:0;top:0px;width:100%;background-color:rgb(200,120,20,0.93);position:absolute;color:#FFFFFF">
    <div style="text-align: center; margin-top:8px">
        We use cookies to give you the best experience on our website. If you continue using Shadertoy, we'll assume that you are happy to receive all cookies on this website. 
        For more information, please review our <a class="regular" href="/terms">Terms & Privacy</a>.
    </div> 
    <div style="text-align: center;margin-top:6px">
        <button type="button" style="width:100px;font-size:inherit" onclick="acceptCompliance()">Accept</button>
    </div>
</div>

<script>
(function runCompliance() 
{
    let showCompliance = 1;
    let allcookies = document.cookie;
    let cookiearray = allcookies.split(';');
    for (var i=0; i<cookiearray.length; i++)
    {
        let name  = cookiearray[i].split('=')[0];
        let value = cookiearray[i].split('=')[1];
        if (name.trim() == "scmp") 
        {
            showCompliance = value;
            break;
        }
    }

    if (showCompliance === 1) 
    {
        var ve = document.getElementById("compliance");
        ve.style.visibility="visible";
    }
})();

function acceptCompliance()
{
    let now = new Date();
    now.setTime( now.getTime() + (5*365*24*60*60*1000) );
    document.cookie="scmp=0;expires=" + now.toUTCString() + ";";

    var ve = document.getElementById("compliance");
    ve.style.visibility="hidden";
}
</script>

</body>
</html>
