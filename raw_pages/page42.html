<!DOCTYPE HTML>
<html lang="en">
<head>

    
<script async src="https://www.googletagmanager.com/gtag/js?id=G-7SYLWGZYJ2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-7SYLWGZYJ2');
</script>

<title>Browse (43) - Shadertoy BETA</title>
<meta charset="utf-8" />
<meta name="Keywords" content="shadertoy, shader toy, quilez, inigo, jeremias, pol, fractals, demoscene, computer graphics, mathematics, rendering, demo, 3D, realtime, shader, raytracing, raymarching, webgl, glsl" />
<meta name="Description" content="Build shaders, share them, and learn from the best community." />
<meta name="Author" content="Beautypi" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<link rel="image_src" href="https://www.shadertoy.com/img/logo.png" />
<link rel="apple-touch-icon" href="/img/launch_icon_57.png"/>
<link rel="apple-touch-icon" sizes="72x72" href="/img/launch_icon_72.png"/>
<link rel="apple-touch-icon" sizes="114x114" href="/img/launch_icon_114.png"/>
<link rel="shortcut icon" href="/img/favicon.ico"/>

<style>::-webkit-scrollbar {
    height: 8px;
    width: 8px;
    background: #404040;
}

::-webkit-scrollbar-thumb
{
    background: #909090;
    border-radius: 0ex;
}

::-webkit-scrollbar-corner
{
    background: #000;
}

::-webkit-input-placeholder
{
	font-style:italic;
}
input:-moz-placeholder, textarea:-moz-placeholder
{
	font-style:italic;
}
input.placeholder-text, textarea.placeholder-text
{
	font-style:italic;
}

pre 
{
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
    white-space: -pre-wrap;
    white-space: -o-pre-wrap;
    word-wrap: break-word;
}

@font-face
{
    font-family: Lobster;
    src: url("/img/lobster.otf") format("opentype");
}

div#centerScreen
{
    left: 50%;
    top: 50%;
    position: absolute;
}

a.headerLinks:hover
{
    background-color:#505050;
    color : #ff8020;
}

body
{
    color: #000000;
    font-size:12px;
    font-style:normal;
    font-family:Tahoma,Arial;
    background-repeat: no-repeat;
    //background-attachment: fixed;
    padding:0px;
    margin:0px;
    text-align: left;
    background-color: #d0d0d0;
    background-repeat: repeat;
    user-select: text;
}

a,
a:hover,
a:visited
{
  color : inherit;
}

div#content {
    width: 95%;
    overflow: hidden;
    margin: auto;
    padding: 0px;
    min-height: calc(100vh - 80px);
    //box-sizing: border-box;
}


.notificationCount
{
 background-color:#ff0000;
 padding-left:3px;
 padding-right:1px;
 padding-top:1px;
 padding-bottom:1px;
}

div#header
{
    background-color: #404040;
    top: 0px;
    left: 0px;
    width: 100%;
    padding: 0;
    margin: 0;
    color: #ffffff;
    display: flex;
    flex-direction:row;
}

#headerBlock1
{
    width: 50%;
    display:flex;
    align-items:center;
}

a#headerTitle
{
    font-size: 2.25em;
    font-family: Lobster,Tahoma,Arial;
    text-decoration: none;
    padding-left:32px;
    padding-right:32px;
}

#headerSearch
{
    display: inline-block;
    color: #000000;
    width: 300px;
}

input[type=search]#mySearch
{
    width: 100%;
    border-radius: 6px;
    border: 1px solid black;
    padding:12px;
}

#headerBlock2
{
    width: 50%;
    margin-left: auto;
    display: flex;
    justify-content: flex-end;
}


a#headerTitle:hover
{
    color : #ff8020;
}

a.headerLinks
{
    font-weight: bold;
    padding-top: 14px;
    padding-bottom: 14px;
    padding-left: 14px;
    padding-right: 14px;
    margin:0px;
    text-decoration: none;
    transition: background-color 0.15s linear, color 0.15s linear;
}

#footer
{
    background-color: rgba(64,64,64,0.25);
    color: #000000;
    padding: 0px;
    margin: 0px;
    width: 100%;
    display: flex;
    justify-content: space-between;
    flex-wrap: wrap;
}

#footer div
{
    padding-top:10px;
    padding-bottom:0px;
    padding-left:16px;
    padding-right:16px;
}

#footer div ul
{
    margin-left:0px;
    padding-left:16px;
}

#footer div ul li
{
    padding-top:6px;
}

a.regular
{
    font-weight:bold;
    text-decoration:none
}

a.regular:hover
{
  color : #ff8020;
}

a.user
{
    font-weight:bold;
    text-decoration:none;
}

a.user:hover
{
  color : #ff8020;
  text-decoration: underline;
}

.uiButton
{
    border: none;
    outline: none;
    margin: 0px;
    padding: 0px;
    width: 22px;
    height: 22px;
    position: absolute;
    cursor: pointer;
    border-radius: 4px;
}

.uiButton:hover
{
    box-shadow: inset 0px 0px 1px 1px #808080, 0px 0px 1px 1px #808080;
}

.uiDivBUtton
{
    cursor:pointer;
}

.uiDivBUtton:hover
{
    color: #ffffff;
}


.dialog
{
    display: block;
    background-color: #e0e0e0;
    color: #000000;
    border:1px solid #000;
    padding:0px;
    margin:0px;
    text-align:left;
    border-radius: 4px;
    box-shadow:4px 4px 6px 0px rgba(0,0,0,0.5);
    overflow: hidden;
    z-index:1000;
    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;
}

.dialogHeader
{
    left:0px;
    top: 0px;
    width:100%;
    height:32px;
    position: absolute;
    background-color: #808080;
    cursor:move;
}

.dialogTitle
{
    left: 12px;
    top: 4px;
    position: absolute;
    padding: 0px;
    margin: 0px;
    color:#000000;
    font-size:1.5em;
    text-align: left;
    user-select: none;
    -moz-user-select: -moz-none;
    -webkit-user-select: none;
}

.dialogOverlay
{
    z-index:1000;

    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;

    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    width:100%;
    height:100%;
    position:absolute;

    background-color:rgba(0,0,0,.4);
}

.viewsIcon, .likesIcon
{
    border: none;
    outline: none;
    display:inline-block;
    background-repeat:no-repeat;
    top:0px;
    left:0px;
    padding:0px;
    padding-right: 2px;
    margin:0px;
    position:relative;
}

.userPictureSmall
{
    background-color:#808080;
    border: 1px solid #000000;
    width:32px;
    height:32px;
}

.dialogCloseButton
{
    right:8px;
    top: 4px;
    width:22px;
    height:22px;
    position: absolute;
    background-image: url("/img/close.png");
    cursor: pointer;
    border-radius: 4px;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContentButtons
{
     padding:0;
     border:0;
     text-align: justify;
     left: 24px;
     bottom:40px;
     position:absolute;
}

.dialogButton
{
    text-align: center;
    vertical-align: middle;
    display: inline-block;
    border-radius: 4px;
    font-weight: bold;
    cursor: pointer;
    padding-bottom:5px;
    padding-top:4px;
    padding-left: 8px;
    padding-right: 8px;
    margin-left:4px;
    margin-right:4px;
    text-decoration: none;
    color:#000000;
    width: 80px;
    -moz-transition:    background-color 0.15s linear, color 0.15s linear;
    -webkit-transition: background-color 0.15s linear, color 0.15s linear;
    transition:         background-color 0.15s linear, color 0.15s linear;
}

.dialogButton:hover
{
  background-color:#808080;
  color : #ff8020;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContent
{
    color: inherit;
    overflow: auto;
    width:100%;
    height:100%;
    left: 0px;
    top: 32px;
    position:absolute
}

.dialogContentBody
{
    color: inherit;
    width:100%;
    height:auto;
    padding-top:24px;
    padding-bottom:24px;
    padding-left:24px;
    padding-right:24px;
    text-align: left;
}

.formButton
{
    font-weight:bold;
	color:#ffffff;
	border:none;
    text-align:center;
	background-color:#808080;
    border-radius: 4px;
	padding-left:8px;
	padding-right:8px;
	padding-top:4px;
	padding-bottom:4px;
    cursor:pointer;
    min-width:80px;
    box-sizing: border-box;
}
.formInput {
    border-radius: 6px;
    border: 1px solid black;
    padding: 4px;
    border: none;
}
.formButton:hover {
    background-color: #e0e0e0;
}
.formButton:disabled
{
	color:#b0b0b0;
	background-color:#808080;
}

.formButtonSmall
{
    color:#ffffff;
    border:none;
    text-align:center;
    background-color:#808080;
    border-radius: 4px;
    padding-left:2px;
    padding-right:2px;
    padding-top:2px;
    padding-bottom:2px;
    cursor:pointer;
    min-width:40px;
}

.formButtonSmall:hover
{
    background-color: #e0e0e0;
}

.formButtonSmall:disabled
{
    color:#b0b0b0;
    background-color:#808080;
}

.formButtonSmall.disabled2,
.formButton.disabled2 { color:#b0b0b0; background-color:#808080; pointer-events: none; }

.inputForm
{
    padding-left:2%;
    padding-right:2%;
    resize: none;
    text-align: left;
    background-color:#e0e0e0;
    outline: none;
    border-radius: 4px;
    border: 1px solid #808080;
    color:inherit;
    box-sizing: border-box;
}

.inputForm:focus
{
    border: 1px solid #AFCDD8;
    background-color: #EBF2F4;
}

.transparentPannel
{
    background-color:rgba(64,64,64,0.1);
    padding:16px;
}

.comment, .commentSelf, .commentNew
{
    border-radius: 4px;
    width: 100%;
    margin-left: 0px;
    margin-right: 0px;
    margin-top: 0px;
    margin-bottom: 6px;

    padding: 14px;
    box-sizing: border-box;
    display: grid;
    grid-template-columns: 32px auto 8px;
    grid-template-rows: 1fr;
    grid-gap:8px;
}

.comment:nth-child(even)
{
    background-color: rgba(64,64,64,0.1);
}

.comment:nth-child(odd)
{
    background-color: rgba(128,128,128,0.1);
}

.commentSelf
{
    background-color: rgba(240,160,64,0.1);
}

.commentNew
{
    padding-right: 0px;
    grid-template-columns: 40px auto;
}

.commentContent
{
    vertical-align: top;
    text-align: left;
    word-break: break-all;
    word-break: break-word;
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
}


/* ----------------------- media resolutions ------------------------ */

@media screen and (max-width:799px)
{
    div#header {flex-direction:column; }
    #headerBlock1 { width:100%; }
    #headerBlock2 { width:100%; justify-content: space-around;}
    div#headerSearch {width:200px;}
    input#mySearch { width:200px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:10px; }
}

@media screen and (min-width:800px) and (max-width:1279px)
{
    body { font-size: 9px; }
    div#headerSearch {width: 250px;}
    input#mySearch { width:250px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:11px; }
}

@media screen and (min-width:1280px) and (max-width:1439px)
{
    body { font-size: 10px; }
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1440px) and (max-width:1919px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1920px) and (max-width:2559px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}

@media screen and (min-width:2560px) 
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}
body
{
    background-image: url("/img/themes/classic/background.jpg");
}
</style>

    <script>"use strict"

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piCamera
//
//==============================================================================

function piCamera()
{
    var mMatrix = setIdentity();
    var mMatrixInv = setIdentity();

    var mPosition = [0.0,0.0,0.0];
    var mXRotation = 0.0;
    var mYRotation = 0.0;

    var mPositionTarget = [0.0,0.0,0.0];
    var mXRotationTarget = 0.0;
    var mYRotationTarget = 0.0;

    var me = {};
/*
    me.Set = function( pos, dir, roll) 
             {
                 mMatrix    = setLookat( pos, add(pos,dir), [Math.sin(roll),Math.cos(roll),Math.sin(roll)] );
                 mMatrixInv = invertFast( mMatrix );
             };
*/
    me.SetPos = function(pos)
                {
                    mPosition = pos;
                    //mMatrix[ 3] = -(mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                    //mMatrix[ 7] = -(mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                    //mMatrix[11] = -(mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                };
/*
    me.GlobalMove = function(pos)
                    {
                        mMatrix[ 3] -= (mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                        mMatrix[ 7] -= (mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                        mMatrix[11] -= (mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                        mMatrixInv = invertFast(mMatrix);
                    };
*/
    me.LocalMove = function( dis )
                    {
                        dis = matMulvec( setRotationY(-mYRotation), dis);
                        mPositionTarget = sub(mPositionTarget,dis)
                    };

    me.RotateXY = function( x, y)
                  {
                    mXRotationTarget -= x;
                    mYRotationTarget -= y;
                    mXRotationTarget = Math.min( Math.max( mXRotationTarget, -Math.PI/2), Math.PI/2 );
                  };


    me.CameraExectue = function( dt )
    {
        // smooth position
        mXRotation += (mXRotationTarget-mXRotation) * 12.0*dt;
        mYRotation += (mYRotationTarget-mYRotation) * 12.0*dt;
        mPosition = add(mPosition, mul( sub(mPositionTarget, mPosition), 12.0*dt));

        // Make Camera matrix
        mMatrix = matMul( matMul(setRotationX(mXRotation), 
                                 setRotationY(mYRotation)),  
                                 setTranslation(mPosition));
        mMatrixInv = invertFast(mMatrix);

    }

    me.GetMatrix = function() { return mMatrix; };
    me.GetMatrixInverse = function() { return mMatrixInv; };
    me.SetMatrix = function( mat ) 
                    {
                        mMatrix = mat;
                        mMatrixInv = invertFast(mMatrix);

                        mPosition = getXYZ(matMulpoint(mat, [0.0,0.0,0.0]));
                        mPositionTarget = mPosition;
                    };

    me.GetPos = function() { return getXYZ(matMulpoint(mMatrixInv, [0.0,0.0,0.0])); }
    me.GetDir = function() { return getXYZ(normalize(matMulvec(mMatrixInv, [0.0,0.0,-1.0]))); }

    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piFile
//
//==============================================================================

function piFile( binaryDataArrayBuffer )
{
    // private
    //var mDataView = new DataView( binaryDataArrayBuffer, 0 );
    var mDataView = binaryDataArrayBuffer;
    var mOffset = 0;

    // public members
    var me = {};
    me.mDummy = 0;
/*
    // public functions
    me.Seek = function( off ) { mOffset = off - 3; };
    me.ReadUInt16 = function()  { var res = mDataView.getUint16( mOffset ); mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = mDataView.getUint32( mOffset ); mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = mDataView.getFloat32( mOffset ); mOffset+=4; return res; };
*/

    me.Seek = function( off ) { mOffset = off; };
    me.ReadUInt8  = function()  { var res = (new Uint8Array(mDataView,mOffset))[0]; mOffset+=1; return res; };
    me.ReadUInt16 = function()  { var res = (new Uint16Array(mDataView,mOffset))[0]; mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = (new Uint32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = (new Float32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadFloat32Array = function(n) 
                          { 
                              var src = new Float32Array(mDataView, mOffset);
                              var res = [];  for( var i=0; i<n; i++ ) { res[i] = src[i]; }
                              mOffset += 4*n;
                              return res;
                          };
    me.ReadFloat32ArrayNative = function(n) { var src = new Float32Array(mDataView, mOffset); mOffset += 4*n; return src; };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piMesh
//
//==============================================================================

function piMesh()
{
    this.mChunks = [];
    this.mPrimitiveType = 0;
    this.mVertexFormat = null;
}

/*
piMesh.prototype.normalize = function( ppos, npos )
{
    var numv = this.mVertexData.length;
    var numt = this.mIndices.length;

    for( var i=0; i<numv; i++ )
    {
        //float *v = (float*)piMesh_GetVertexData( me, i, npos );
        //v[0] = 0.0f;
        //v[1] = 0.0f;
        //v[2] = 0.0f;
        this.mVerts[8 * i + 3] = 0.0;
        this.mVerts[8 * i + 4] = 0.0;
        this.mVerts[8 * i + 5] = 0.0;
    }

    for( var i=0; i<numt; i++ )
    {
        piMeshFace *face = me->mFaceData.mIndexArray[0].mBuffer + i;

        const int ft = face->mNum;
        
        vec3 nor = vec3( 0.0f, 0.0f, 0.0f );
        for( int j=0; j<ft; j++ )
        {
            const vec3 va = *((vec3*)piMesh_GetVertexData( me, face->mIndex[ j      ], ppos ));
            const vec3 vb = *((vec3*)piMesh_GetVertexData( me, face->mIndex[(j+1)%ft], ppos ));

            nor += cross( va, vb );
        }

        for( int j=0; j<ft; j++ )
        {
            vec3 *n = (vec3*)piMesh_GetVertexData( me, face->mIndex[j], npos );
            n->x += nor.x;
            n->y += nor.y;
            n->z += nor.z;
        }
    }

    for( var i=0; i<numv; i++ )
    {
        vec3 *v = (vec3*)piMesh_GetVertexData( me, i, npos );
        *v = normalize( *v );
    }
}
*/

piMesh.prototype.createCube = function(renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([ -1.0, -1.0, -1.0,
                                       1.0, -1.0, -1.0,
                                      -1.0,  1.0, -1.0,
                                       1.0,  1.0, -1.0,
                                      -1.0, -1.0,  1.0,
                                       1.0, -1.0,  1.0,
                                      -1.0,  1.0,  1.0,
                                       1.0,  1.0,  1.0 ]),

                        mIndices : new Uint16Array([ 0, 2, 1,   1, 2, 3,   5, 1, 3,   5, 3, 7,   4, 5, 7,   4, 7, 6,   4, 6, 2,   4, 2, 0,   6, 7, 3,   6, 3, 2,   4, 0, 1,   4, 1, 5 ]),
                        mNumVertices : 8,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };

    this.mVertexFormat = { mStride:12, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}

piMesh.prototype.createCubeSharp = function (renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 1.0,
                                    -1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 0.0,

                                     1.0, 1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 0.0,

                                     1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 1.0,
                                    -1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   1.0, 1.0,
                                     1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   1.0, 0.0,

                                    -1.0, 1.0, 1.0,  -1.0, 0.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0,-1.0,  -1.0, 0.0, 0.0,   0.0, 1.0,
                                    -1.0,-1.0,-1.0,  -1.0, 0.0, 0.0,   1.0, 1.0,
                                    -1.0,-1.0, 1.0,  -1.0, 0.0, 0.0,   1.0, 0.0 ]),

                        mIndices : new Uint16Array([0,1,2, 0,2,3,   4,5,6, 4,6,7,    8,9,10,8,10,11,   12,13,14,12,14,15,   16,17,18,16,18,19,   20,21,22,20,22,23]),
                        mNumVertices : 24,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };


    this.mVertexFormat = { mStride:32, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}


piMesh.prototype.createUnitQuad = function (renderer)
{
    this.mPrimitiveType = 0;
    this.mVertexFormat = { mStride:8, mChannels: [ {mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false} ] };

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0,  1.0, 1.0,  1.0]),
                        mIndices : new Uint16Array([0, 2, 1, 1, 2, 3]),
                        mNumVertices : 4,
                        mNumFaces : 2, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };
 
    return true;
}




piMesh.prototype.destroy = function()
{
    //delete this.mVerts;   this.mVerts = null;
    //delete this.mIndices; this.mIndices = null;
}

piMesh.prototype.scale = function (x, y, z)
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] *= x;
            this.mChunks[j].mVerts[stride * i + 1] *= y;
            this.mChunks[j].mVerts[stride * i + 2] *= z;
        }
    }
}

piMesh.prototype.translate = function (x, y, z) 
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] += x;
            this.mChunks[j].mVerts[stride * i + 1] += y;
            this.mChunks[j].mVerts[stride * i + 2] += z;
        }
    }
}

piMesh.prototype.GPULoad = function (renderer)
{
    for( var i=0; i<this.mChunks.length; i++ )
    {
        var vbo = renderer.CreateVertexArray(this.mChunks[i].mVerts, renderer.BUFTYPE.STATIC );
        if (vbo == null)
            return false;

        var ibo = renderer.CreateIndexArray(this.mChunks[i].mIndices, renderer.BUFTYPE.STATIC);
        if (ibo == null)
            return false;

        this.mChunks[i].mVBO = vbo;
        this.mChunks[i].mIBO = ibo;
    }
    return true;
}

piMesh.prototype.GPURender = function (renderer, positions )//, matPrj, matCam )
{
    //renderer.SetShaderConstantMat4F("unMPrj", matPrj, false );

    var num = this.mChunks.length;
    for( var i=0; i<num; i++ )
    {
        //var mat =  matMul( matCam, this.mChunks[i].mTransform );
        //renderer.SetShaderConstantMat4F("unMMod", mat, false);

        renderer.AttachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat, positions );
        renderer.AttachIndexArray(this.mChunks[i].mIBO );
        renderer.DrawPrimitive(renderer.PRIMTYPE.TRIANGLES, this.mChunks[i].mNumFaces * 3, true, 1);
        renderer.DetachIndexArray(this.mChunks[i].mIBO);
        renderer.DetachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat );
    }
}
//==============================================================================
//
// piLibs 2014-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piRenderer
//
//==============================================================================

function piRenderer()
{
    // private members

    var mGL = null;
    var mBindedShader = null;
    var mIs20 = false;
    var mFloat32Textures;
    var mFloat32Filter;
    var mFloat16Textures;
    var mDrawBuffers;
    var mDepthTextures;
    var mDerivatives;
    var mFloat16Filter;
    var mShaderTextureLOD;
    var mAnisotropic;
    var mRenderToFloat32F;
    var mDebugShader;
    var mAsynchCompile;

    var mVBO_Quad = null;
    var mVBO_Tri = null;
    var mVBO_CubePosNor = null;
    var mVBO_CubePos = null;
    var mShaderHeader = ["",""];
    var mShaderHeaderLines = [0,0];

    // public members
    var me = {};

    me.CLEAR      = { Color: 1, Zbuffer : 2, Stencil : 4 };
    me.TEXFMT     = { C4I8 : 0, C1I8 : 1, C1F16 : 2, C4F16 : 3, C1F32 : 4, C4F32 : 5, Z16 : 6, Z24 : 7, Z32 : 8, C3F32:9 };
    me.TEXWRP     = { CLAMP : 0, REPEAT : 1 };
    me.BUFTYPE    = { STATIC : 0, DYNAMIC : 1 };
    me.PRIMTYPE   = { POINTS : 0, LINES : 1, LINE_LOOP : 2, LINE_STRIP : 3, TRIANGLES : 4, TRIANGLE_STRIP : 5 };
    me.RENDSTGATE = { WIREFRAME : 0, FRONT_FACE : 1, CULL_FACE : 2, DEPTH_TEST : 3, ALPHA_TO_COVERAGE : 4 };
    me.TEXTYPE    = { T2D : 0, T3D : 1, CUBEMAP : 2 };
    me.FILTER     = { NONE : 0, LINEAR : 1, MIPMAP : 2, NONE_MIPMAP : 3 };
    me.TYPE       = { UINT8 : 0, UINT16 : 1, UINT32 : 2, FLOAT16: 3, FLOAT32 : 4, FLOAT64: 5 };

    // private functions

    var iFormatPI2GL = function( format )
    {
        if( mIs20 )
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA8,           mGLExternal: mGL.RGBA,             mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.R8,              mGLExternal: mGL.RED,              mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.R16F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA16F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.R32F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA32F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C3F32) return { mGLFormat: mGL.RGB32F,          mGLExternal: mGL.RGB,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT16, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z24)   return { mGLFormat: mGL.DEPTH_COMPONENT24, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z32)   return { mGLFormat: mGL.DEPTH_COMPONENT32F, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        }
        else
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.RED,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT, mGLExternal: mGL.DEPTH_COMPONENT, mGLType: mGL.UNSIGNED_SHORT }
        }

        return null;
     }

    // public functions

    me.Initialize = function( gl )
                    {
                        mGL = gl;

                        mIs20 = !(gl instanceof WebGLRenderingContext);

                        if( mIs20 )
                        {
                            mFloat32Textures  = true;
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = true;
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = true;
                            mDrawBuffers      = true;
                            mDepthTextures    = true;
                            mShaderTextureLOD = true;
                            mAnisotropic = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mGL.getExtension( 'EXT_color_buffer_float');
                            mDebugShader = mGL.getExtension('WEBGL_debug_shaders');
                            mAsynchCompile = mGL.getExtension('KHR_parallel_shader_compile');

							mGL.hint( mGL.FRAGMENT_SHADER_DERIVATIVE_HINT, mGL.NICEST);
                        }
                        else
                        {
                            mFloat32Textures  = mGL.getExtension( 'OES_texture_float' );
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = mGL.getExtension( 'OES_texture_half_float' );
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = mGL.getExtension( 'OES_standard_derivatives' );
                            mDrawBuffers      = mGL.getExtension( 'WEBGL_draw_buffers' );
                            mDepthTextures    = mGL.getExtension( 'WEBGL_depth_texture' );
                            mShaderTextureLOD = mGL.getExtension( 'EXT_shader_texture_lod' );
                            mAnisotropic      = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mFloat32Textures;
                            mDebugShader      = null;
                            mAsynchCompile    = null;
							
							if( mDerivatives !== null) mGL.hint( mDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, mGL.NICEST);
                        }
                        
                        
                        var maxTexSize = mGL.getParameter( mGL.MAX_TEXTURE_SIZE );
                        var maxCubeSize = mGL.getParameter( mGL.MAX_CUBE_MAP_TEXTURE_SIZE );
                        var maxRenderbufferSize = mGL.getParameter( mGL.MAX_RENDERBUFFER_SIZE );
                        var extensions = mGL.getSupportedExtensions();
                        var textureUnits = mGL.getParameter( mGL.MAX_TEXTURE_IMAGE_UNITS );
                        console.log("WebGL (2.0=" + mIs20 + "):" +
                                    " Asynch Compile: "  + ((mAsynchCompile !==null) ? "yes" : "no") +
                                    ", Textures: F32 ["   + ((mFloat32Textures !==null) ? "yes" : "no") +
                                    "], F16 ["   + ((mFloat16Textures !==null) ? "yes" : "no") +
                                    "], Depth [" + ((mDepthTextures   !==null) ? "yes" : "no") +
                                    "], LOD ["    + ((mShaderTextureLOD!==null) ? "yes" : "no") +
                                    "], Aniso ["   + ((mAnisotropic     !==null) ? "yes" : "no") +
                                    "], Units [" + textureUnits +
                                    "], Max Size [" + maxTexSize +
                                    "], Cube Max Size [" + maxCubeSize +
                                    "], Targets: MRT ["            + ((mDrawBuffers     !==null) ? "yes" : "no") +
                                    "], F32 ["     + ((mRenderToFloat32F!==null) ? "yes" : "no") +
                                    "], Max Size [" + maxRenderbufferSize + "]");

                        // create a 2D quad Vertex Buffer
                        var vertices = new Float32Array( [ -1.0, -1.0,   1.0, -1.0,    -1.0,  1.0,     1.0, -1.0,    1.0,  1.0,    -1.0,  1.0] );
                        mVBO_Quad = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                        mGL.bufferData( mGL.ARRAY_BUFFER, vertices, mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 2D triangle Vertex Buffer
                        mVBO_Tri = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0,   3.0, -1.0,    -1.0,  3.0] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePosNor = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0, -1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                               1.0,  1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                               1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                               1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                               1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0,  1.0, -1.0,   0.0,  0.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePos = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0,  1.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        //-------------------------------------------------------------------

                        mShaderHeader[0] = "";
                        mShaderHeaderLines[0] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[0] += "#version 300 es\n" +
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[0] += 6;
                        }
                        else
                        {
                            mShaderHeader[0] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "#endif\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+                                                
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[0] += 26;
                        }

                        //-------------------------------------------------------

                        mShaderHeader[1] = "";
                        mShaderHeaderLines[1] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[1] += "#version 300 es\n"+
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[1] += 6;
                        }
                        else
                        {
                            if( mDerivatives ) { mShaderHeader[1] += "#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n"; mShaderHeaderLines[1]+=3; }
                            if( mShaderTextureLOD  ) { mShaderHeader[1] += "#extension GL_EXT_shader_texture_lod : enable\n"; mShaderHeaderLines[1]++; }
                            mShaderHeader[1] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "#endif\n"+ 
                                                "vec4 texture(     sampler2D   s, vec2 c)                   { return texture2D(s,c); }\n"+
                                                "vec4 texture(     sampler2D   s, vec2 c, float b)          { return texture2D(s,c,b); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c )                  { return textureCube(s,c); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c, float b)          { return textureCube(s,c,b); }\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[1] += 30;
                            if( mShaderTextureLOD )
                            {
                            mShaderHeader[1] += "vec4 textureLod(  sampler2D   s, vec2 c, float b)          { return texture2DLodEXT(s,c,b); }\n";
                            mShaderHeader[1] += "vec4 textureGrad( sampler2D   s, vec2 c, vec2 dx, vec2 dy) { return texture2DGradEXT(s,c,dx,dy); }\n";
                            mShaderHeaderLines[1] += 2;

                            //mShaderHeader[1] += "vec4 texelFetch( sampler2D s, ivec2 c, int l) { return texture2DLodEXT(s,(vec2(c)+0.5)/vec2(800,450),float(l)); }\n";
                            //mShaderHeaderLines[1] += 1;
                            }
                        }

                        return true;
                    };

        me.GetCaps =    function ()
                        {   
                            return { mIsGL20 : mIs20,
                                     mFloat32Textures: mFloat32Textures != null,
                                     mFloat16Textures: mFloat16Textures != null,
                                     mDrawBuffers: mDrawBuffers != null,
                                     mDepthTextures: mDepthTextures != null,
                                     mDerivatives: mDerivatives != null,
                                     mShaderTextureLOD: mShaderTextureLOD != null };
                        };

        me.GetShaderHeaderLines = function (shaderType)
                        {   
                            return mShaderHeaderLines[shaderType];
                        };

        me.CheckErrors = function()
                         {
                                var error = mGL.getError();
                                if( error != mGL.NO_ERROR ) 
                                { 
                                    for( var prop in mGL ) 
                                    {
                                        if( typeof mGL[prop] == 'number' ) 
                                        {
                                            if( mGL[prop] == error )
                                            {
                                                console.log( "GL Error " + error + ": " + prop );
                                                break;
                                            }
                                        }
                                    }
                                }
                         };

        me.Clear =  function( flags, ccolor, cdepth, cstencil )
                    {
                        var mode = 0;
                        if( flags & 1 ) { mode |= mGL.COLOR_BUFFER_BIT;   mGL.clearColor( ccolor[0], ccolor[1], ccolor[2], ccolor[3] ); }
                        if( flags & 2 ) { mode |= mGL.DEPTH_BUFFER_BIT;   mGL.clearDepth( cdepth ); }
                        if( flags & 4 ) { mode |= mGL.STENCIL_BUFFER_BIT; mGL.clearStencil( cstencil ); }
                        mGL.clear( mode );
                    };


        me.CreateTexture = function ( type, xres, yres, format, filter, wrap, buffer)
                           {
                                if( mGL===null ) return null;

                                var id = mGL.createTexture();

                                var glFoTy = iFormatPI2GL( format );
                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                if( type===me.TEXTYPE.T2D )
                                {
                                    mGL.bindTexture( mGL.TEXTURE_2D, id );
//if( buffer==null )
    //mGL.texStorage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres);
//else
                                    mGL.texImage2D( mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap );

                                    if (filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                }
                                else if( type===me.TEXTYPE.T3D )
                                {
                                    if( mIs20 )
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_3D, id );
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_BASE_LEVEL, 0);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAX_LEVEL, Math.log2(xres));
                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_3D);
                                        }
                                        mGL.texImage3D( mGL.TEXTURE_3D, 0, glFoTy.mGLFormat, xres, yres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap );

                                        if (filter === me.FILTER.MIPMAP)
                                            mGL.generateMipmap( mGL.TEXTURE_3D );
                                        mGL.bindTexture( mGL.TEXTURE_3D, null );
                                    }
                                    else 
                                    {
                                        return null;
                                    }
                                }
                                else 
                                {
                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );

                                    // this works great if we know the number of required mipmaps in advance (1, or other)
                                   //mGL.texStorage2D( mGL.TEXTURE_CUBE_MAP, 1, glFoTy.mGLFormat, xres, yres );

                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                    if( filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                    }

                                    if (filter === me.FILTER.MIPMAP)
                                        mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );

                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                }
                        return { mObjectID: id, mXres: xres, mYres: yres, mFormat: format, mType: type, mFilter: filter, mWrap: wrap, mVFlip:false };
                        };

        me.CreateTextureFromImage = function ( type, image, format, filter, wrap, flipY) 
                                {
                                    if( mGL===null ) return null;

                                    var id = mGL.createTexture();

                                    var glFoTy = iFormatPI2GL( format );

                                    var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                    if( type===me.TEXTYPE.T2D )
                                    {
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);

                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.pixelStorei(mGL.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                                        if( mIs20 ) mGL.pixelStorei(mGL.UNPACK_COLORSPACE_CONVERSION_WEBGL, mGL.NONE );

                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);

                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);

                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if( filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                    }
                                    else if( type===me.TEXTYPE.T3D )
                                    {
                                        return null;
                                    }
                                    else 
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );

                                        if( filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                    }
                                    return { mObjectID: id, mXres: image.width, mYres: image.height, mFormat: format, mType: type, mFilter: filter, mWrap:wrap, mVFlip:flipY };
                                };

        me.SetSamplerFilter = function (te, filter, doGenerateMipsIfNeeded) 
                            {
                                if (te.mFilter === filter) return;

                                if (te.mType === me.TEXTYPE.T2D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_3D, null);

                                }
                                else
                                {
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }


                                te.mFilter = filter;
                            };

        me.SetSamplerWrap = function (te, wrap)
                            {
                                if (te.mWrap === wrap) return;

                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, id);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, id);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_3D, null);
                                }

                                te.mWrap = wrap;
                            };

        me.SetSamplerVFlip = function (te, vflip, image)
                            {
                                if (te.mVFlip === vflip) return;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    if( image != null)
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                }
                                else if (te.mType === me.TEXTYPE.CUBEMAP)
                                {
                                    if( image != null)
                                    {
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei( mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
        
                                }

                                te.mVFlip = vflip;
                            };

        me.CreateMipmaps =  function (te)
                            {
                                if( te.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);
                                    mGL.generateMipmap(mGL.TEXTURE_2D);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);
                                }
                                else if( te.mType===me.TEXTYPE.CUBEMAP )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);
                                    mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }
                            };

        me.UpdateTexture =  function( tex, x0, y0, xres, yres, buffer )
                            {
                                var glFoTy = iFormatPI2GL( tex.mFormat );
                                if( tex.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture( mGL.TEXTURE0);
                                    mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                    mGL.texSubImage2D( mGL.TEXTURE_2D, 0, x0, y0, xres, yres, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                }
                            };

        me.UpdateTextureFromImage = function( tex, image )
                                {
                                    var glFoTy = iFormatPI2GL( tex.mFormat );
                                    if( tex.mType===me.TEXTYPE.T2D )
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                        mGL.texImage2D(  mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image );
                                        mGL.bindTexture( mGL.TEXTURE_2D, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                };

        me.DestroyTexture = function( te )
                            {
                                 mGL.deleteTexture( te.mObjectID );
                            };

        me.AttachTextures = function (num, t0, t1, t2, t3) 
                            {
                                if (num > 0 && t0 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                         if (t0.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t0.mObjectID);
                                }

                                if (num > 1 && t1 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE1);
                                         if (t1.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t1.mObjectID);
                                }

                                if (num > 2 && t2 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE2);
                                         if (t2.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t2.mObjectID);
                                }

                                if (num > 3 && t3 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE3);
                                         if (t3.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t3.mObjectID);
                                }
                            };

        me.DettachTextures = function()
                             {
                                mGL.activeTexture(mGL.TEXTURE0);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE1);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE2);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE3);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                             };

        me.CreateRenderTarget = function ( color0, color1, color2, color3, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);

                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_2D, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.DestroyRenderTarget = function ( tex )
                                 {
                                     mGL.deleteFramebuffer(tex.mObjectID);
                                 };

        me.SetRenderTarget = function (tex)
                             {
                                if( tex===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, tex.mObjectID);

                                //mGL.drawBuffers([mGL.COLOR_ATTACHMENT0, mGL.COLOR_ATTACHMENT1]);
                             };

        me.CreateRenderTargetNew = function ( wantColor0, wantZbuffer, xres, yres, samples )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if( wantZbuffer===true )
                                    {
                                        var zb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);

                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.DEPTH_COMPONENT16, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                    }

                                    if( wantColor0 )
                                    {
                                        var cb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, cb);
                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.RGBA8, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.RGBA8, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.RENDERBUFFER, cb);
                                    }

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                    {
                                        return null;
                                    }
                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mXres: xres, mYres:yres, mTex0: color0 };
                                };

        me.CreateRenderTargetCubeMap = function ( color0, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);
                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.SetRenderTargetCubeMap = function (fbo, face)
                             {
                                if( fbo===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                {
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, fbo.mObjectID);
                                    mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X+face, fbo.mTex0.mObjectID, 0);
                                }
                             };


        me.BlitRenderTarget = function( dst, src )
                                {
                                    mGL.bindFramebuffer(mGL.READ_FRAMEBUFFER, src.mObjectID);
                                    mGL.bindFramebuffer(mGL.DRAW_FRAMEBUFFER, dst.mObjectID);
                                    mGL.clearBufferfv(mGL.COLOR, 0, [0.0, 0.0, 0.0, 1.0]);
                                    mGL.blitFramebuffer( 0, 0, src.mXres, src.mYres,
                                                         0, 0, src.mXres, src.mYres,
                                                         mGL.COLOR_BUFFER_BIT, mGL.LINEAR
                                    );
                                };

        me.SetViewport = function( vp )
                         {
                              mGL.viewport( vp[0], vp[1], vp[2], vp[3] );
                         };

        me.SetWriteMask = function( c0, c1, c2, c3, z )
                          {
                              mGL.depthMask(z);
                              mGL.colorMask(c0,c0,c0,c0);
                          };

        me.SetState = function( stateName, stateValue )
                      {
                            if (stateName === me.RENDSTGATE.WIREFRAME)
                            {
                                if( stateValue ) mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.LINE );
                                else             mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.FILL );
                            }
                            else if (stateName === me.RENDSTGATE.FRONT_FACE)
                            {
                                if( stateValue ) mGL.cullFace( mGL.BACK );
                                else             mGL.cullFace( mGL.FRONT );
                            }
                            else if (stateName === me.RENDSTGATE.CULL_FACE)
                            {
                                if( stateValue ) mGL.enable( mGL.CULL_FACE );
                                else             mGL.disable( mGL.CULL_FACE );
                            }
                            else if (stateName === me.RENDSTGATE.DEPTH_TEST)
                            {
                                if( stateValue ) mGL.enable( mGL.DEPTH_TEST );
                                else             mGL.disable( mGL.DEPTH_TEST );
                            }
                            else if (stateName === me.RENDSTGATE.ALPHA_TO_COVERAGE)
                            {
                                if( stateValue ) { mGL.enable(  mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                                else             { mGL.disable( mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                            }
                      };

        me.SetMultisample = function( v)
                    {
                        if( v===true )
                        {
                            mGL.enable(mGL.SAMPLE_COVERAGE);
                            mGL.sampleCoverage(1.0, false);
                        }
                        else
                        {
                            mGL.disable(mGL.SAMPLE_COVERAGE);
                        }
                    };

        me.GetTranslatedShaderSource = function (shader) 
                          {
                            if( mGL===null ) return null;
                            if( mDebugShader===null ) return null;
                            let vfs = mGL.getAttachedShaders(shader.mProgram);
                            let str = mDebugShader.getTranslatedShaderSource(vfs[1]);
                            let parts = str.split("GLSL END"); str = (parts.length<2) ? str : parts[1];
                            return str;
                          };

        me.CreateShader = function (vsSource, fsSource, preventCache, forceSynch, onResolve) 
                          {
                            if( mGL===null ) return;

                            var vs = mGL.createShader( mGL.VERTEX_SHADER   );
                            var fs = mGL.createShader( mGL.FRAGMENT_SHADER );

                            vsSource = mShaderHeader[0] + vsSource;
                            fsSource = mShaderHeader[1] + fsSource;

                            if( preventCache )
                            {
                                let vran = Math.random().toString(36).substring(7);
                                let fran = Math.random().toString(36).substring(7);
                                vsSource += "\n#define K" + vran + "\n";
                                fsSource += "\n#define K" + fran + "\n";
                            }

                            var timeStart = getRealTime();

                            mGL.shaderSource(vs, vsSource);
                            mGL.shaderSource(fs, fsSource);
                            mGL.compileShader(vs);
                            mGL.compileShader(fs);

                            var pr = mGL.createProgram();
                            mGL.attachShader(pr, vs);
                            mGL.attachShader(pr, fs);
                            mGL.linkProgram(pr);

                            //-------------
                            let checkErrors = function()
                            {
                                if (!mGL.getProgramParameter(pr, mGL.LINK_STATUS))
                                {
                                    // vs error
                                    if (!mGL.getShaderParameter(vs, mGL.COMPILE_STATUS))
                                    {
                                        let vsLog = mGL.getShaderInfoLog(vs);
                                        onResolve(false, { mErrorType: 0, mErrorStr: vsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // fs error
                                    else if (!mGL.getShaderParameter(fs, mGL.COMPILE_STATUS))
                                    {
                                        let fsLog = mGL.getShaderInfoLog(fs);
                                        onResolve(false, { mErrorType: 1, mErrorStr: fsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // link error
                                    else
                                    {
                                        let infoLog = mGL.getProgramInfoLog(pr);
                                        onResolve(false, { mErrorType: 2, mErrorStr: infoLog });
                                        mGL.deleteProgram(pr);
                                    }
                                }
                                // no errors
                                else
                                {
                                    let compilationTime = getRealTime() - timeStart;
                                    onResolve(true, { mProgram: pr, mTime: compilationTime });
                                }
                            };

                            // check compilation
                            if (mAsynchCompile === null || forceSynch===true )
                            {
                                checkErrors();
                            }
                            else
                            {
                                let loopCheckCompletion = function ()
                                {
                                    if( mGL.getProgramParameter(pr, mAsynchCompile.COMPLETION_STATUS_KHR) === true )
                                        checkErrors();
                                    else
                                        setTimeout(loopCheckCompletion, 10);
                                };
                                setTimeout(loopCheckCompletion, 10);
                            }
                        };

        me.AttachShader = function( shader )
                          {
                                if( shader===null )
                                {
                                    mBindedShader = null;
                                    mGL.useProgram( null );
                                }
                                else
                                {
                                    mBindedShader = shader;
                                    mGL.useProgram(shader.mProgram);
                                }
                          };

        me.DetachShader = function ()
                        {
                            mGL.useProgram(null);
                        };

        me.DestroyShader = function( tex )
                        {
                            mGL.deleteProgram(tex.mProgram);
                        };

        me.GetAttribLocation = function (shader, name)
                        {
                            return mGL.getAttribLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantLocation = function (shader, name)
                        {
                            return mGL.getUniformLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantMat4F = function( uname, params, istranspose )
                        {
                            var program = mBindedShader;

                            let pos = mGL.getUniformLocation( program.mProgram, uname );
                            if( pos===null )
                                return false;

                            if( istranspose===false )
                            {
                                var tmp = new Float32Array( [ params[0], params[4], params[ 8], params[12],
                                                              params[1], params[5], params[ 9], params[13],
                                                              params[2], params[6], params[10], params[14],
                                                              params[3], params[7], params[11], params[15] ] );
	                            mGL.uniformMatrix4fv(pos,false,tmp);
                            }
                            else
                                mGL.uniformMatrix4fv(pos,false,new Float32Array(params) );
                            return true;
                        };

        me.SetShaderConstant1F_Pos = function(pos, x)
                        {
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1FV_Pos = function(pos, x)
                        {
                            mGL.uniform1fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant1F = function( uname, x )
                        {
                            var pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1I = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1i(pos, x);
                            return true;
                        };
        me.SetShaderConstant1I_Pos = function(pos, x)
                        {
                            mGL.uniform1i(pos, x);
                            return true;
                        };


        me.SetShaderConstant2F = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform2fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant3F = function(uname, x, y, z)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform3f(pos, x, y, z);
                            return true;
                        };

        me.SetShaderConstant1FV = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1fv(pos, new Float32Array(x));
                            return true;
                        };

        me.SetShaderConstant3FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform3fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderConstant4FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform4fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderTextureUnit = function( uname, unit )
                        {
                            var program = mBindedShader;
                            let pos = mGL.getUniformLocation(program.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform1i(pos, unit);
                            return true;
                        };

        me.CreateVertexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, id);
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.CreateIndexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, id );
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.DestroyArray = function( tex )
                        {
                            mGL.destroyBuffer(tex.mObject);
                        };

        me.AttachVertexArray = function( tex, attribs, pos )
                        {
                            let shader = mBindedShader;

                            mGL.bindBuffer( mGL.ARRAY_BUFFER, tex.mObject);

                            var num = attribs.mChannels.length;
                            var stride = attribs.mStride;

                            var offset = 0;
                            for (var i = 0; i < num; i++)
                            {
                                var id = pos[i];
                                mGL.enableVertexAttribArray(id);
                                var dtype = mGL.FLOAT;
                                var dsize = 4;
                                     if( attribs.mChannels[i].mType === me.TYPE.UINT8   ) { dtype = mGL.UNSIGNED_BYTE;  dsize = 1; }
                                else if( attribs.mChannels[i].mType === me.TYPE.UINT16  ) { dtype = mGL.UNSIGNED_SHORT; dsize = 2; }
                                else if( attribs.mChannels[i].mType === me.TYPE.FLOAT32 ) { dtype = mGL.FLOAT;          dsize = 4; }
                                mGL.vertexAttribPointer(id, attribs.mChannels[i].mNumComponents, dtype, attribs.mChannels[i].mNormalize, stride, offset);
                                offset += attribs.mChannels[i].mNumComponents * dsize;
                            }
                        };

        me.AttachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, tex.mObject);
                        };

        me.DetachVertexArray = function (tex, attribs)
                        {
                            let num = attribs.mChannels.length;
                            for (let i = 0; i < num; i++)
                                mGL.disableVertexAttribArray(i);
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, null);
                        };

        me.DetachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, null);
                        };

        me.DrawPrimitive = function( typeOfPrimitive, num, useIndexArray, numInstances )
                        {
                            let glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.POINTS ) glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.LINES ) glType = mGL.LINES;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_LOOP ) glType = mGL.LINE_LOOP;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_STRIP ) glType = mGL.LINE_STRIP;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLES ) glType = mGL.TRIANGLES;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLE_STRIP ) glType = mGL.TRIANGLE_STRIP;

                            if( numInstances<=1 )
                            {
  	                            if( useIndexArray ) mGL.drawElements( glType, num, mGL.UNSIGNED_SHORT, 0 );
	                            else                mGL.drawArrays( glType, 0, num );
                            }
                            else
                            {
                                mGL.drawArraysInstanced(glType, 0, num, numInstances);
                                mGL.drawElementsInstanced( glType, num, mGL.UNSIGNED_SHORT, 0, numInstances);
                            }
                        };


        me.DrawFullScreenTriangle_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 3 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };


        me.DrawUnitQuad_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 6 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };

        me.DrawUnitCube_XYZ_NOR = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                            mGL.vertexAttribPointer( vpos[0], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.vertexAttribPointer( vpos[1], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos[0] );
                            mGL.enableVertexAttribArray( vpos[1] );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos[0] );
                            mGL.disableVertexAttribArray( vpos[1] );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.DrawUnitCube_XYZ = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                            mGL.vertexAttribPointer( vpos, 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.SetBlend = function( enabled )
                    {
                        if( enabled )
                        {
                            mGL.enable( mGL.BLEND );
                            mGL.blendEquationSeparate( mGL.FUNC_ADD, mGL.FUNC_ADD );
                            mGL.blendFuncSeparate( mGL.SRC_ALPHA, mGL.ONE_MINUS_SRC_ALPHA, mGL.ONE, mGL.ONE_MINUS_SRC_ALPHA );
                        }
                        else
                        {
                            mGL.disable( mGL.BLEND );
                        }
                    };

        me.GetPixelData = function( data, offset, xres, yres )
                        {
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.UNSIGNED_BYTE, data, offset);
                        };

        me.GetPixelDataRenderTarget = function( obj, data, xres, yres )
                        {
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, obj.mObjectID);
                            mGL.readBuffer(mGL.COLOR_ATTACHMENT0);
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.FLOAT, data, 0);
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                        };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piShading
//
//==============================================================================

function smoothstep(a, b, x)
{
    x = (x - a) / (b - a);
    if (x < 0) x = 0; else if (x > 1) x = 1;
    return x * x * (3.0 - 2.0 * x);
}

function clamp01(x)
{
    if( x < 0.0 ) x = 0.0;
    if( x > 1.0 ) x = 1.0;
    return x;
}

function clamp(x, a, b)
{
    if( x < a ) x = a;
    if( x > b ) x = b;
    return x;
}

function screen(a, b)
{
    return 1.0 - (1.0 - a) * (1.0 - b);
}

function parabola(x)
{
    return 4.0 * x * (1.0 - x);
}

function min(a, b)
{
    return (a < b) ? a : b;
}

function max(a, b)
{
    return (a > b) ? a : b;
}

function noise( x )
{
    function grad(i, j, x, y)
    {
        var h = 7 * i + 131 * j;
        h = (h << 13) ^ h;
        h = (h * (h * h * 15731 + 789221) + 1376312589);

        var rx = (h & 0x20000000) ? x : -x;
        var ry = (h & 0x10000000) ? y : -y;

        return rx + ry;
    }

    var i = [ Math.floor(x[0]), Math.floor(x[1]) ];
    var f = [ x[0] - i[0], x[1] - i[1] ];
    var w = [ f[0]*f[0]*(3.0-2.0*f[0]), f[1]*f[1]*(3.0-2.0*f[1]) ];

    var a = grad( i[0]+0, i[1]+0, f[0]+0.0, f[1]+0.0 );
    var b = grad( i[0]+1, i[1]+0, f[0]-1.0, f[1]+0.0 );
    var c = grad( i[0]+0, i[1]+1, f[0]+0.0, f[1]-1.0 );
    var d = grad( i[0]+1, i[1]+1, f[0]-1.0, f[1]-1.0 );

    return a + (b-a)*w[0] + (c-a)*w[1] + (a-b-c+d)*w[0]*w[1];
}//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piVecTypes
//
//==============================================================================


function vec3( a, b, c )
{
    return [ a, b, c ];
}

function add( a, b )
{
    return [ a[0]+b[0], a[1]+b[1], a[2]+b[2] ];
}

function sub( a, b )
{
    return [ a[0]-b[0], a[1]-b[1], a[2]-b[2] ];
}

function mul( a, s ) 
{
    return [ a[0]*s, a[1]*s, a[2]*s ];
}

function cross( a, b )
{
    return [ a[1]*b[2] - a[2]*b[1],
             a[2]*b[0] - a[0]*b[2],
             a[0]*b[1] - a[1]*b[0] ];
}

function dot( a, b ) 
{
    return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
}

function normalize( v ) 
{
    var is = 1.0 / Math.sqrt( v[0]*v[0] + v[1]*v[1] + v[2]*v[2] );
    return [ v[0]*is, v[1]*is, v[2]*is ];
}

function createCirclePoint( cen, uuu, vvv, rad, s, t )
{
    return [ cen[0] + rad*(uuu[0]*s + vvv[0]*t),
             cen[1] + rad*(uuu[1]*s + vvv[1]*t),
             cen[2] + rad*(uuu[2]*s + vvv[2]*t) ];
}

function createTangent( a, b, c )
{
    var cb = normalize( [ c[0]-b[0], c[1]-b[1], c[2]-b[2] ] );
    var ba = normalize( [ b[0]-a[0], b[1]-a[1], b[2]-a[2] ] );
    return normalize( [ ba[0]+cb[0], ba[1]+cb[1], ba[2]+cb[2] ] );

}

//===================================

function vec4( a, b, c, d )
{
    return [ a, b, c, d ];
}

function getXYZ( v )
{
    return [ v[0], v[1], v[2] ];
}

//===================================

function setIdentity()
{
    return [ 1.0, 0.0, 0.0, 0.0,
             0.0, 1.0, 0.0, 0.0,
             0.0, 0.0, 1.0, 0.0,
             0.0, 0.0, 0.0, 1.0 ];
}

function setRotationX( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ 1.0,   0.0,   0.0, 0.0,
             0.0,  cost, -sint, 0.0, 
             0.0,  sint,  cost, 0.0,
             0.0,   0.0,   0.0, 1.0 ];
}

function setRotationY( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ cost, 0.0, -sint, 0.0,
              0.0, 1.0,   0.0, 0.0, 
             sint, 0.0,  cost, 0.0,
              0.0, 0.0,   0.0, 1.0 ];
}

function extractRotationEuler( m)
{
    var res = [];
    if (m[0] == 1.0)
    {
        res[0] = Math.atan2(m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;

    }
    else if (m[0] == -1.0)
    {
        res[0] = Math.atan2( m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;
    }
    else
    {
        res[0] = Math.atan2( -m[9], m[10]);
        res[1] = Math.atan2( m[8], Math.sqrt(m[9]*m[9] + m[10]*m[10]));
        res[2] = Math.atan2( m[4], m[0]);
    }
    return res;
}

function setFromQuaternion( q )
{
    var ww = q[3]*q[3];
    var xx = q[0]*q[0];
    var yy = q[1]*q[1];
    var zz = q[2]*q[2];

    return [ ww+xx-yy-zz,                   2.0*(q[0]*q[1] - q[3]*q[2]), 2.0*(q[0]*q[2] + q[3]*q[1]), 0.0,
               2.0*(q[0]*q[1] + q[3]*q[2]),   ww-xx+yy-zz,                 2.0*(q[1]*q[2] - q[3]*q[0]), 0.0,
               2.0*(q[0]*q[2] - q[3]*q[1]),   2.0*(q[1]*q[2] + q[3]*q[0]), ww-xx-yy+zz,                 0.0,
               0.0,                           0.0,                         0.0,                         1.0 ];
}

function setPerspective( fovy, aspect, znear, zfar )
{
    var tan = Math.tan(fovy * Math.PI/180.0);
    var x = 1.0 / (tan*aspect);
    var y = 1.0 / (tan);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0 * zfar * znear) / (zfar - znear);

    return [ x,    0.0,  0.0,  0.0,
             0.0,  y,    0.0,  0.0,
             0.0,  0.0,  c,     d,
             0.0,  0.0, -1.0,  0.0 ];
}

function setLookAt( eye, tar, up )
{
    var dir = [ -tar[0]+eye[0], -tar[1]+eye[1], -tar[2]+eye[2] ];

	var m00 = dir[2]*up[1] - dir[1]*up[2]; 
    var m01 = dir[0]*up[2] - dir[2]*up[0];
    var m02 = dir[1]*up[0] - dir[0]*up[1];
    var im = 1.0/Math.sqrt( m00*m00 + m01*m01 + m02*m02 );
    m00 *= im;
    m01 *= im;
    m02 *= im;

	var m04 = m02*dir[1] - m01*dir[2]; 
    var m05 = m00*dir[2] - m02*dir[0];
    var m06 = m01*dir[0] - m00*dir[1];
    im = 1.0/Math.sqrt( m04*m04 + m05*m05 + m06*m06 );
    m04 *= im;
    m05 *= im;
    m06 *= im;

	var m08 = dir[0];
	var m09 = dir[1];
	var m10 = dir[2];
    im = 1.0/Math.sqrt( m08*m08 + m09*m09 + m10*m10 );
    m08 *= im;
    m09 *= im;
    m10 *= im;

	var m03 = -(m00*eye[0] + m01*eye[1] + m02*eye[2] );
	var m07 = -(m04*eye[0] + m05*eye[1] + m06*eye[2] );
	var m11 = -(m08*eye[0] + m09*eye[1] + m10*eye[2] );

    return [ m00, m01, m02, m03,
             m04, m05, m06, m07,
             m08, m09, m10, m11,
             0.0, 0.0, 0.0, 1.0 ];
}


function setOrtho( left, right, bottom, top, znear, zfar )
{
   var x = 2.0 / (right - left);
   var y = 2.0 / (top - bottom);
   var a = (right + left) / (right - left);
   var b = (top + bottom) / (top - bottom);
   var c = -2.0 / (zfar - znear);
   var d = -(zfar + znear) / ( zfar - znear);

   return [  x, 0.0, 0.0,   a,
           0.0,   y, 0.0,   b,
           0.0, 0.0,   c,   d,
           0.0, 0.0, 0.0, 1.0 ];
}

function setTranslation( p )
{
    return [ 1.0, 0.0, 0.0, p[0],
             0.0, 1.0, 0.0, p[1],
             0.0, 0.0, 1.0, p[2],
             0.0, 0.0, 0.0, 1.0 ];
}

function setScale( s )
{
    return [ s[0], 0.0,  0.0,  0.0,
             0.0,  s[1], 0.0,  0.0,
             0.0,  0.0,  s[2], 0.0,
             0.0,  0.0,  0.0,  1.0];
}

function setProjection( fov, znear, zfar )
{
    var x = 2.0 / (fov[3]+fov[2]);
    var y = 2.0 / (fov[0]+fov[1]);
    var a = (fov[3]-fov[2]) / (fov[3]+fov[2]);
    var b = (fov[0]-fov[1]) / (fov[0]+fov[1]);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0*zfar*znear) / (zfar - znear);
    return [   x, 0.0,    a, 0.0,
             0.0,   y,    b, 0.0,
             0.0, 0.0,    c,   d,
             0.0, 0.0, -1.0, 0.0 ];
   // inverse is:
   //return mat4x4( 1.0/x, 0.0f,  0.0f,   a/x,
   //               0.0f,  1.0/y, 0.0f,   b/x,
   //               0.0f,  0.0f,  0.0f,   -1.0,
   //               0.0f,  0.0f,  1.0f/d, c/d );
}


function invertFast( m )
{
    var inv = [
   
             m[5]  * m[10] * m[15] - 
             m[5]  * m[11] * m[14] - 
             m[9]  * m[6]  * m[15] + 
             m[9]  * m[7]  * m[14] +
             m[13] * m[6]  * m[11] - 
             m[13] * m[7]  * m[10],

             -m[1]  * m[10] * m[15] + 
              m[1]  * m[11] * m[14] + 
              m[9]  * m[2] * m[15] - 
              m[9]  * m[3] * m[14] - 
              m[13] * m[2] * m[11] + 
              m[13] * m[3] * m[10],

             m[1]  * m[6] * m[15] - 
             m[1]  * m[7] * m[14] - 
             m[5]  * m[2] * m[15] + 
             m[5]  * m[3] * m[14] + 
             m[13] * m[2] * m[7] - 
             m[13] * m[3] * m[6],

             -m[1] * m[6] * m[11] + 
              m[1] * m[7] * m[10] + 
              m[5] * m[2] * m[11] - 
              m[5] * m[3] * m[10] - 
              m[9] * m[2] * m[7] + 
              m[9] * m[3] * m[6],

             -m[4]  * m[10] * m[15] + 
              m[4]  * m[11] * m[14] + 
              m[8]  * m[6]  * m[15] - 
              m[8]  * m[7]  * m[14] - 
              m[12] * m[6]  * m[11] + 
              m[12] * m[7]  * m[10],

             m[0]  * m[10] * m[15] - 
             m[0]  * m[11] * m[14] - 
             m[8]  * m[2] * m[15] + 
             m[8]  * m[3] * m[14] + 
             m[12] * m[2] * m[11] - 
             m[12] * m[3] * m[10],

             -m[0]  * m[6] * m[15] + 
              m[0]  * m[7] * m[14] + 
              m[4]  * m[2] * m[15] - 
              m[4]  * m[3] * m[14] - 
              m[12] * m[2] * m[7] + 
              m[12] * m[3] * m[6],


             m[0] * m[6] * m[11] - 
             m[0] * m[7] * m[10] - 
             m[4] * m[2] * m[11] + 
             m[4] * m[3] * m[10] + 
             m[8] * m[2] * m[7] - 
             m[8] * m[3] * m[6],


             m[4]  * m[9] * m[15] - 
             m[4]  * m[11] * m[13] - 
             m[8]  * m[5] * m[15] + 
             m[8]  * m[7] * m[13] + 
             m[12] * m[5] * m[11] - 
             m[12] * m[7] * m[9],



             -m[0]  * m[9] * m[15] + 
              m[0]  * m[11] * m[13] + 
              m[8]  * m[1] * m[15] - 
              m[8]  * m[3] * m[13] - 
              m[12] * m[1] * m[11] + 
              m[12] * m[3] * m[9],

              m[0]  * m[5] * m[15] - 
              m[0]  * m[7] * m[13] - 
              m[4]  * m[1] * m[15] + 
              m[4]  * m[3] * m[13] + 
              m[12] * m[1] * m[7] - 
              m[12] * m[3] * m[5],

              -m[0] * m[5] * m[11] + 
               m[0] * m[7] * m[9] + 
               m[4] * m[1] * m[11] - 
               m[4] * m[3] * m[9] - 
               m[8] * m[1] * m[7] + 
               m[8] * m[3] * m[5],

              -m[4]  * m[9] * m[14] + 
               m[4]  * m[10] * m[13] +
               m[8]  * m[5] * m[14] - 
               m[8]  * m[6] * m[13] - 
               m[12] * m[5] * m[10] + 
               m[12] * m[6] * m[9],

              m[0]  * m[9] * m[14] - 
              m[0]  * m[10] * m[13] - 
              m[8]  * m[1] * m[14] + 
              m[8]  * m[2] * m[13] + 
              m[12] * m[1] * m[10] - 
              m[12] * m[2] * m[9],

              -m[0]  * m[5] * m[14] + 
               m[0]  * m[6] * m[13] + 
               m[4]  * m[1] * m[14] - 
               m[4]  * m[2] * m[13] - 
               m[12] * m[1] * m[6] + 
               m[12] * m[2] * m[5],

              m[0] * m[5] * m[10] - 
              m[0] * m[6] * m[9] - 
              m[4] * m[1] * m[10] + 
              m[4] * m[2] * m[9] + 
              m[8] * m[1] * m[6] - 
              m[8] * m[2] * m[5] ];

    var det = m[0] * inv[0] + m[1] * inv[4] + m[2] * inv[8] + m[3] * inv[12];

    det = 1.0/det;

    for( var i = 0; i<16; i++ ) inv[i] = inv[i] * det;

    return inv;
}

function matMul( a, b )
{
    var res = [];
    for( var i=0; i<4; i++ )
    {
        var x = a[4*i+0];
        var y = a[4*i+1];
        var z = a[4*i+2];
        var w = a[4*i+3];

        res[4*i+0] = x * b[ 0] + y * b[ 4] + z * b[ 8] + w * b[12];
        res[4*i+1] = x * b[ 1] + y * b[ 5] + z * b[ 9] + w * b[13];
        res[4*i+2] = x * b[ 2] + y * b[ 6] + z * b[10] + w * b[14];
        res[4*i+3] = x * b[ 3] + y * b[ 7] + z * b[11] + w * b[15];
    }

    return res;
}

function matMulpoint( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2] + m[ 3],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2] + m[ 7],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] + m[11] ];
}

function matMulvec( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] ];
}


function bound3( infi )
{
    return [ infi, -infi, infi, -infi, infi, -infi ];
}

function bound3_include( a, p )
{
    return [
        (p[0]<a[0]) ? p[0] : a[0],
        (p[0]>a[1]) ? p[0] : a[1],
        (p[1]<a[2]) ? p[1] : a[2],
        (p[1]>a[3]) ? p[1] : a[3],
        (p[2]<a[4]) ? p[2] : a[4],
        (p[2]>a[5]) ? p[2] : a[5] ];
}

function bound3_center( b )
{
    return [ 0.5*(b[0]+b[1]),
             0.5*(b[2]+b[3]),
             0.5*(b[4]+b[5]) ];
}

function bound3_radius( b )
{
    return [ 0.5*(b[1]-b[0]),
             0.5*(b[3]-b[2]),
             0.5*(b[5]-b[4]) ];
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebVR
//
//==============================================================================

function WebVR( isVREnabledCallback, canvasElement )
{
    isVREnabledCallback(false);
    /*


    this.mSupportVR = false;
    this.mHMD = null;

    var me = this;
    var listVRDisplays = function (vrdevs) {
        for (var i = 0; i < vrdevs.length; i++)
        {
            if (vrdevs[i] instanceof VRDisplay)
            {
                me.mHMD = vrdevs[i];
                console.log("WebVR is available.");
                console.log(me.mHMD);
                break;
            }
        }

        isVREnabledCallback(true);
        me.mSupportVR = true;
    }

    if (navigator.getVRDisplays)
    {
        navigator.getVRDisplays().then(listVRDisplays);
    }

    isVREnabledCallback(false);
    this.mCanvas = canvasElement;
    */
}

WebVR.prototype.IsSupported = function()
{
    return false;
    //return this.mSupportVR;
}

WebVR.prototype.GetData = function( id )
{
    return {};
    /*
    var frameData = new VRFrameData();
    var s = this.mHMD.getFrameData(frameData);
    var ss = frameData.pose;
    
    var fovL = this.mHMD.getEyeParameters("left");
    var fovR = this.mHMD.getEyeParameters( "right" );

    // camera info
    var cPos = vec3(0.0, 0.0, 0.0);
    if (ss.position)
        cPos = vec3(-ss.position[0], -ss.position[1], -ss.position[2]);
    var rot = vec4(0.0, 0.0, 0.0, 0.0);
    if (ss.orientation)
        rot = vec4(ss.orientation[0], ss.orientation[1], ss.orientation[2], ss.orientation[3]);
    var cRot = setFromQuaternion(rot);
    var cTra = setTranslation(cPos);
    var cMat = matMul(invertFast(cRot), cTra);
    
    // per eye info
    var lTra = setTranslation( vec3(-fovL.offset[0], -fovL.offset[1], -fovL.offset[2]) );
    var lMat = matMul(lTra, cMat);
    var lPrj = [ Math.tan( fovL.fieldOfView.upDegrees * Math.PI/180.0),
                 Math.tan(fovL.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.rightDegrees * Math.PI / 180.0)];

    var rTra = setTranslation(vec3(-fovR.offset[0], -fovR.offset[1], -fovR.offset[2]));
    var rMat = matMul(rTra, cMat);
    var rPrj = [Math.tan(fovR.fieldOfView.upDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.rightDegrees * Math.PI / 180.0)];

    return {
        mCamera   : { mCamera: cMat },
        mLeftEye  : { mVP:[0,0,fovL.renderWidth,fovL.renderHeight], mProjection:lPrj, mCamera:lMat },
        mRightEye : { mVP:[fovR.renderWidth/2,0,fovR.renderWidth,fovR.renderHeight], mProjection:rPrj, mCamera:rMat }
           };
    */
}

WebVR.prototype.Enable = function( id )
{
    /*
    this.mHMD.requestPresent([{ source: this.mCanvas }]).then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : requestPresent failed.");
        }
    );
    */
}

WebVR.prototype.Disable = function( id )
{
    /*
    if (!this.mHMD.isPresenting)
    {
        return;
    }

    this.mHMD.exitPresent().then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : exitPresent failed.");
        }
    );
    */
}

WebVR.prototype.RequestAnimationFrame = function (id)
{
    //this.mHMD.requestAnimationFrame(id);
}

WebVR.prototype.IsPresenting = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        return true;
    }
    */
    return false;
}

WebVR.prototype.Finish = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        this.mHMD.submitFrame();
    }
    */
}

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebUtils
//
//==============================================================================


// RequestAnimationFrame
window.requestAnimFrame = ( function () { return window.requestAnimationFrame    || window.webkitRequestAnimationFrame ||
                                                 window.mozRequestAnimationFrame || window.oRequestAnimationFrame ||
                                                 window.msRequestAnimationFrame  || function( cb ) { window.setTimeout(cb,1000/60); };
                                        } )();

// performance.now
window.getRealTime = ( function() { if ("performance" in window ) return function() { return window.performance.now(); }
                                                                  return function() { return (new Date()).getTime(); }
                                  } )();

window.URL = window.URL || window.webkitURL;

navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;

function htmlEntities(str) 
{
    return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g,'&apos;');
}

function piDisableTouch()
{
    document.body.addEventListener('touchstart', function(e){ e.preventDefault(); });
}

var piGetTime = function ( timestamp )
{
    if (timestamp == 0)
        return "";
    return new Date(timestamp * 1000).toISOString().substr(0, 10);
}

function piGetCoords( obj )
{
    var x = 0;
    var y = 0; 
    do
    {
         x += obj.offsetLeft;
         y += obj.offsetTop;
    }while( obj = obj.offsetParent );

    return { mX:x, mY:y };
}

function piGetMouseCoords( ev, canvasElement )
{
    var pos = piGetCoords(canvasElement );
    var mcx =                        (ev.pageX - pos.mX) * canvasElement.width / canvasElement.offsetWidth;
    var mcy = canvasElement.height - (ev.pageY - pos.mY) * canvasElement.height / canvasElement.offsetHeight;

    return { mX: mcx, mY: mcy };

}

function piGetSourceElement( e )
{
    var ele = null;
    if( e.target )     ele = e.target;
    if( e.srcElement ) ele = e.srcElement;
    return ele;
}

function piRequestFullScreen( ele )
{
    if( ele==null ) ele =   document.documentElement;
         if( ele.requestFullscreen       ) ele.requestFullscreen();
    else if( ele.msRequestFullscreen     ) ele.msRequestFullscreen();
    else if( ele.mozRequestFullScreen    ) ele.mozRequestFullScreen();
    else if( ele.webkitRequestFullscreen ) ele.webkitRequestFullscreen( Element.ALLOW_KEYBOARD_INPUT );
}

function piIsFullScreen()
{
    return document.fullscreen || document.mozFullScreen || document.webkitIsFullScreen || document.msFullscreenElement || false;
}

function piExitFullScreen()
{
       if( document.exitFullscreen       ) document.exitFullscreen();
  else if( document.msExitFullscreen     ) document.msExitFullscreen();
  else if( document.mozCancelFullScreen  ) document.mozCancelFullScreen();
  else if( document.webkitExitFullscreen ) document.webkitExitFullscreen();
}

function piIsMobile()
{
    return (navigator.userAgent.match(/Android/i) ||
            navigator.userAgent.match(/webOS/i) ||
            navigator.userAgent.match(/iPhone/i) ||
            navigator.userAgent.match(/iPad/i) ||
            navigator.userAgent.match(/iPod/i) ||
            navigator.userAgent.match(/BlackBerry/i) ||
            navigator.userAgent.match(/Windows Phone/i)) ? true : false;
}

function piCreateGlContext( cv, useAlpha, useDepth, usePreserveBuffer, useSupersampling )
{
    var opts = { alpha: useAlpha, 
                 depth: useDepth, 
                 stencil: false, 
                 premultipliedAlpha: false, 
                 antialias: useSupersampling, 
                 preserveDrawingBuffer: usePreserveBuffer, 
                 powerPreference: "high-performance" }; // "low_power", "high_performance", "default"

    var gl = null;
    if( gl === null) gl = cv.getContext( "webgl2", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl2", opts );
    if( gl === null) gl = cv.getContext( "webgl", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl", opts );

    return gl;
}

function piCreateAudioContext()
{
    var res = null;
    try
    {
        if( window.AudioContext ) res = new AudioContext();
        if( res==null && window.webkitAudioContext ) res = new webkitAudioContext();
    }
    catch( e )
    {
        res = null;
    }
    return res;
}

function piHexColorToRGB(str) // "#ff3041"
{
    var rgb = parseInt(str.slice(1), 16);
    var r = (rgb >> 16) & 255;
    var g = (rgb >> 8) & 255;
    var b = (rgb >> 0) & 255;
    return [r, g, b];
}

function piCreateFPSCounter()
{
    var mFrame;
    var mTo;
    var mFPS;

    var iReset = function( time )
    {
        mFrame = 0;
        mTo = time;
        mFPS = 60.0;
    }

    var iCount = function( time )
    {
        mFrame++;

        if( (time-mTo)>500.0 )
        {
            mFPS = 1000.0*mFrame/(time-mTo);
            mFrame = 0;
            mTo = time;
            return true;
        }
        return false;
    }

    var iGetFPS = function()
    {
        return mFPS;
    }
    
    return { Reset : iReset, Count : iCount, GetFPS : iGetFPS };
}

function piCanMediaRecorded(canvas)
{
    if (typeof window.MediaRecorder !== 'function' || typeof canvas.captureStream !== 'function') {
        return false;
    }
    return true;
}

function piCreateMediaRecorder(isRecordingCallback, canvas) 
{
    if (piCanMediaRecorded(canvas) == false)
    {
        return null;
    }
    
    var options = { audioBitsPerSecond : 0, videoBitsPerSecond : 8000000 }; 
	     if (MediaRecorder.isTypeSupported('video/webm;codecs=h264')) options.mimeType = 'video/webm;codecs=h264';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9' )) options.mimeType = 'video/webm;codecs=vp9';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8' )) options.mimeType = 'video/webm;codecs=vp8';
    else                                                              options.mimeType = 'video/webm;';

    var mediaRecorder = new MediaRecorder(canvas.captureStream(), options);
    var chunks = [];
    
    mediaRecorder.ondataavailable = function(e) 
    {
        if (e.data.size > 0) 
        {
            chunks.push(e.data);
        }
    };
 
    mediaRecorder.onstart = function(){ 
        isRecordingCallback( true );
    };
    
    mediaRecorder.onstop = function()
    {
         isRecordingCallback( false );
         let blob     = new Blob(chunks, {type: "video/webm"});
         chunks       = [];
         let videoURL = window.URL.createObjectURL(blob);
         let url      = window.URL.createObjectURL(blob);
         let a        = document.createElement("a");
         document.body.appendChild(a);
         a.style      = "display: none";
         a.href       = url;
         a.download   = "capture.webm";
         a.click();
         window.URL.revokeObjectURL(url);
     };
    
    return mediaRecorder;
}

function piExportToEXR(width, height, numComponents, type, bytes)
{
    var bytesPerComponent = 0;
    if      (type=="Uint")   bytesPerComponent = 4; 
    else if (type=="Half")   bytesPerComponent = 2;
    else if (type=="Float")  bytesPerComponent = 4;

    var tHeader = 258 + (18 * numComponents + 1);
    var tTable = 8 * height;
    var tScanlines = height * (4 + 4 + (numComponents * bytesPerComponent * width));
    var tTotal = tHeader + tTable + tScanlines;

    //console.log("    header size = " + tHeader);
    //console.log("    table size = " + tTable);
    //console.log("    scanlines size = " + tScanlines);
    //console.log("    total = " + tTotal);

    var buffer = new ArrayBuffer(tTotal); 
    var data = new DataView(buffer);

    // Header
    {
        // Header : 4 bytes -> 0x76, 0x2f, 0x31, 0x01
        var c = 0;
        data.setUint8 (c++, 0x76);
        data.setUint8 (c++, 0x2f);
        data.setUint8 (c++, 0x31);
        data.setUint8 (c++, 0x01);

        // Version : 4 bytes -> 2, 0, 0, 0
        data.setUint8 (c++, 0x02);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        
        // Write channel info
        // Write attribute name : "channels"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x73);
            data.setUint8 (c++, 0x0);

            // Write attribute type : "chlist"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : 18 x 3 + 1 = 55
            var attribSize = 18 * numComponents + 1;
            data.setUint8 (c++, attribSize); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            var i;
            for (i = 0; i < numComponents; i++)
            {
                // Attribute : "B" (42) "G" (47) "R" (52)
                if (i==0)       data.setUint8 (c++, 0x42);
                else if (i==1)  data.setUint8 (c++, 0x47);
                else if (i==2)  data.setUint8 (c++, 0x52);
                data.setUint8 (c++, 0x00);
                
                // Value : Float (2), Half (1), Uint (0)
                if      (type=="Uint")   data.setUint8 (c++, 0x00); 
                else if (type=="Half")   data.setUint8 (c++, 0x01);
                else if (type=="Float")  data.setUint8 (c++, 0x02);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);

                // Plinear
                data.setUint8 (c++, 0x01);

                // Reserved
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 

                // X sampling
                data.setUint8 (c++, 0x01); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                
                // Y sampling
                data.setUint8 (c++, 0x01);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
            }
            // End attribute
            data.setUint8 (c++, 0x00);
    
        // Write attribute name : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute type : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : "1"
            data.setUint8 (c++, 0x01); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // Write attribute value : "0" (None)
            data.setUint8 (c++, 0x00);

        // datawindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00); 

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00);

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 

            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // displayWindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x79); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00);

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00); 

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // size
            data.setUint8 (c++, 0x01);
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);
            
            // value 
            data.setUint8 (c++, 0x00);

        // PixelAspectRatio
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x41); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x52); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x00); 

            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);
        
            // size 4
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 1.0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);
        
        // screenWindowCenter
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63);
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x43); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e);
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00);

            // v2f
            data.setUint8 (c++, 0x76); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x00);

            // size 8
            data.setUint8 (c++, 0x08); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

        // screenWindowWidth
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x00); 
            
            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00); 

            // size
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);

            // value
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);

        // End of header
        data.setUint8 (c++, 0x00);
    }
    //console.log("header size = " + c);

    // Scanline table
    var initc = c + height * 8;
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        var jump = initc + scanline * (8 + width * bytesPerComponent * numComponents); 
        data.setUint32 (c, jump, true);
        c += 4; 

        data.setUint32 (c, 0x00, true);
        c += 4;
    }
    //console.log("header + scanlines table size = " + c);

    // Scanlines
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        // Scanline
        data.setUint32(c, scanline, true);
        c += 4;

        // size 24
        var size = width * numComponents * bytesPerComponent; 
        data.setUint32(c, size, true);
        c += 4;

        var numComponentsSource = 4; // number of components in the SOURCE image
        for (var component = 0; component < numComponents ; component ++) 
        {
            for (var pixel = 0 ; pixel < width ; pixel ++) 
            {
                // flip vertical, so we read OpenGL buffers without JS image flipping
                var v = bytes[(height-1-scanline) * width *numComponentsSource + pixel * numComponentsSource + (2-component)];
                if      (type=="Float") data.setFloat32(c, v, true);
                else if (type=="Half")  data.setUint16(c, v, true);

                c += bytesPerComponent;
            }
        }
    }
    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}


function piExportToWAV(numSamples, rate, bits, numChannels, words)
{
    let numBytes = numSamples * numChannels * bits/8;

    let buffer = new ArrayBuffer(44 + numBytes); 
    let data = new DataView(buffer);

    {
        data.setUint32( 0, 0x46464952, true );  // RIFF
        data.setUint32( 4, numBytes + 36, true);
        {
            data.setUint32( 8, 0x45564157, true );  // WAV_WAVE
            data.setUint32( 12, 0x20746D66, true );  // WAV_FMT
            {
                data.setUint32( 16, 16, true);
                data.setUint16( 20, 1, true ); // WAV_FORMAT_PCM
                data.setUint16( 22, numChannels, true);
                data.setUint32( 24, rate, true);
                data.setUint32( 28, rate*numChannels*bits / 8, true);
                data.setUint16( 32, numChannels*bits / 8, true);
                data.setUint16( 34, bits, true);
            }

            data.setUint32( 36, 0x61746164, true);  // WAV_DATA
            {
                data.setUint32( 40, numBytes, true);
                let numWords = numSamples * numChannels;
                for(let i=0; i<numWords; i++ )
                {
                    data.setInt16( 44 + i*2, words[i], true );
                }
            }
        }
    }


    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}

function piTriggerDownload(name, blob)
{
    let url = URL.createObjectURL(blob);
    let aElement = document.createElement("a");
    aElement.href     = url;
    aElement.target   = "_self";
    aElement.download = name;
    document.body.appendChild(aElement);
    aElement.click();
    document.body.removeChild(aElement);
}</script>
    <script>"use strict"

function bufferID_to_assetID( id )
{
    if( id===0 ) return '4dXGR8';
    if( id===1 ) return 'XsXGR8';
    if( id===2 ) return '4sXGR8';
    if( id===3 ) return 'XdfGR8';
    return 'none';
}
function assetID_to_bufferID( id )
{
    if( id==='4dXGR8' ) return 0;
    if( id==='XsXGR8' ) return 1;
    if( id==='4sXGR8' ) return 2;
    if( id==='XdfGR8' ) return 3;
    return -1;
}

function assetID_to_cubemapBuferID( id )
{
    if( id==='4dX3Rr' ) return 0;
    return -1;
}
function cubamepBufferID_to_assetID( id )
{
    if( id===0 ) return '4dX3Rr';
    return 'none';
}

function EffectPass( renderer, is20, isLowEnd, hasShaderTextureLOD, callback, obj, forceMuted, forcePaused, outputGainNode, copyProgram, id, effect  )
{
    this.mID = id;
    this.mInputs  = [null, null, null, null ];
    this.mOutputs = [null, null, null, null ];
    this.mSource = null;

    this.mGainNode = outputGainNode;
    this.mSoundShaderCompiled = false;

    this.mEffect = effect;
    this.mRenderer = renderer;
    this.mProgramCopy = copyProgram; 
    this.mCompilationTime = 0;

    this.mType = "none";
    this.mName = "none";
    this.mFrame = 0;

    this.mShaderTextureLOD = hasShaderTextureLOD;
    this.mIs20 = is20;
    this.mIsLowEnd = isLowEnd;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mForceMuted = forceMuted;
    this.mForcePaused = forcePaused;
}

EffectPass.prototype.MakeHeader_Image = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        // old API
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                   header += "uniform sampler2D iChannel" + i + ";\n";

        // new API (see shadertoy.com/view/wtdGW8)
        header += "uniform struct {\n";
             if( inp===null )                  header += "  sampler2D";
        else if( inp.mInfo.mType==="cubemap" ) header += "  samplerCube";
        else if( inp.mInfo.mType==="volume"  ) header += "  sampler3D";
        else                                  header += "  sampler2D";
        header +=        " sampler;\n";
        header += "  vec3  size;\n";
        header += "  float time;\n";
        header += "  int   loaded;\n";
        header += "}iCh" + i + ";\n";
    }
	header += "void mainImage( out vec4 c, in vec2 f );\n";
    header += "void st_assert( bool cond );\n";
    header += "void st_assert( bool cond, int v );\n";

    if( this.mIs20 ) 
    {
        header += "\nout vec4 shadertoy_out_color;\n" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)shadertoy_out_color.x=-1.0;else if(v==1)shadertoy_out_color.y=-1.0;else if(v==2)shadertoy_out_color.z=-1.0;else shadertoy_out_color.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)shadertoy_out_color.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "shadertoy_out_color = vec4(1.0,1.0,1.0,1.0);" + 
            "vec4 color = vec4(1e20);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "if(shadertoy_out_color.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(shadertoy_out_color.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(shadertoy_out_color.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(shadertoy_out_color.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "shadertoy_out_color = vec4(color.xyz,1.0);" +
        "}";
    }
    else
    {
        header += "" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)gl_FragColor.x=-1.0;else if(v==1)gl_FragColor.y=-1.0;else if(v==2)gl_FragColor.z=-1.0;else gl_FragColor.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)gl_FragColor.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "gl_FragColor = vec4(0.0,0.0,0.0,1.0);" + 
            "vec4 color = vec4(1e20);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "color.w = 1.0;" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(gl_FragColor.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "gl_FragColor = vec4(color.xyz,1.0);"+
        "}";
    }
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 ) 
        this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "void main( void )" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );" +
        "color.w = 1.0;"
    if( this.mIs20 ) 
        this.mImagePassFooterVR +=  "outColor = color;}";
    else
        this.mImagePassFooterVR +=  "gl_FragColor = color;}";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Buffer = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                  header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainImage( out vec4 c,  in vec2 f );\n"

    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +
        "mainImage( color, gl_FragCoord.xy );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
    this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        this.mImagePassFooterVR +="outColor = color; }";
    else
        this.mImagePassFooterVR +="gl_FragColor = color; }";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Cubemap = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                   header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainCubemap( out vec4 c, in vec2 f, in vec3 ro, in vec3 rd );\n"

    header += "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainCubemap( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Sound = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform float     iChannelTime[4];\n" +
              "uniform float     iTimeOffset;\n" +
              "uniform int       iSampleOffset;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n";

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp!==null && inp.mInfo.mType==="cubemap" )
            header += "uniform samplerCube iChannel" + i + ";\n";
        else
            header += "uniform sampler2D iChannel" + i + ";\n";
    }
    header += "\n";
    header += "vec2 mainSound( in int samp, float time );\n";

    if( this.mIs20 )
    {
        header += "out vec4 outColor; void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "int   s = iSampleOffset + int(gl_FragCoord.y-0.2)*512 + int(gl_FragCoord.x-0.2);" +
            "vec2 y = mainSound( s, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "outColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    else
    {
        header += "void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "vec2 y = mainSound( 0, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "gl_FragColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    header += "\n";
    this.mHeader = header;
    this.mHeaderLength = 0;
}


EffectPass.prototype.MakeHeader_Common = function ()
{
    let header = "";
    let headerlength = 0;

    header += "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n";
    headerlength += 2;

    if (this.mIs20)
    {
        header += "out vec4 outColor;\n";
        headerlength += 1;
    }
    header += "void main( void )\n";
    headerlength += 1;

    if (this.mIs20)
        header += "{ outColor = vec4(0.0); }";
    else
        header += "{ gl_FragColor = vec4(0.0); }";
    headerlength += 1;
    header += "\n";
    headerlength += 1;

    this.mHeader = header;
    this.mHeaderLength = headerlength;
}

EffectPass.prototype.MakeHeader = function()
{
         if( this.mType==="image" ) this.MakeHeader_Image();
    else if( this.mType==="sound" ) this.MakeHeader_Sound();
    else if( this.mType==="buffer") this.MakeHeader_Buffer();
    else if( this.mType==="common") this.MakeHeader_Common();
    else if( this.mType==="cubemap") this.MakeHeader_Cubemap();
    else console.log("ERROR 4");
}

EffectPass.prototype.Create_Image = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}
EffectPass.prototype.Destroy_Image = function( wa )
{
}

EffectPass.prototype.Create_Buffer = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}

EffectPass.prototype.Destroy_Buffer = function( wa )
{
}

EffectPass.prototype.Create_Cubemap = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
}

EffectPass.prototype.Destroy_Cubemap = function( wa )
{
}

EffectPass.prototype.Create_Common = function( wa )
{
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.MakeHeader();
}
EffectPass.prototype.Destroy_Common = function( wa )
{
}

EffectPass.prototype.Create_Sound = function (wa)
{
    this.MakeHeader();

    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    this.mSampleRate = 44100;
    this.mPlayTime = 60*3;
    this.mPlaySamples = this.mPlayTime*this.mSampleRate;
    this.mBuffer = wa.createBuffer( 2, this.mPlaySamples, this.mSampleRate );

    //-------------------
    this.mTextureDimensions = 512;
    this.mRenderTexture = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D, 
                                                       this.mTextureDimensions, this.mTextureDimensions,
                                                       this.mRenderer.TEXFMT.C4I8,
                                                       this.mRenderer.FILTER.NONE,
                                                       this.mRenderer.TEXWRP.CLAMP, null);
    this.mRenderFBO = this.mRenderer.CreateRenderTarget(this.mRenderTexture, null, null, null, null, false);

    //-----------------------------

    // ArrayBufferView pixels;
    this.mTmpBufferSamples = this.mTextureDimensions*this.mTextureDimensions;
    this.mData = new Uint8Array( this.mTmpBufferSamples*4 );

    this.mPlaying = false;
}

EffectPass.prototype.Destroy_Sound = function( wa )
{
    if( this.mPlayNode!==null ) this.mPlayNode.stop();
    this.mPlayNode = null;
    this.mBuffer = null;
    this.mData = null;

    this.mRenderer.DestroyRenderTarget(this.mRenderFBO);
    this.mRenderer.DestroyTexture(this.mRenderTexture);
}

EffectPass.prototype.Create = function( passType, wa )
{
    this.mType = passType;
    this.mSource = null;

         if( passType==="image" ) this.Create_Image( wa );
    else if( passType==="sound" ) this.Create_Sound( wa );
    else if( passType==="buffer") this.Create_Buffer( wa );
    else if( passType==="common") this.Create_Common( wa );
    else if( passType==="cubemap") this.Create_Cubemap( wa );
    else alert("ERROR 1");
}

EffectPass.prototype.SetName = function (passName)
{
    this.mName = passName;
}

EffectPass.prototype.SetCode = function (src)
{
    this.mSource = src;
}

EffectPass.prototype.Destroy = function( wa )
{
    this.mSource = null;
         if( this.mType==="image" ) this.Destroy_Image( wa );
    else if( this.mType==="sound" ) this.Destroy_Sound( wa );
    else if( this.mType==="buffer") this.Destroy_Buffer( wa );
    else if( this.mType==="common") this.Destroy_Common( wa );
    else if( this.mType==="cubemap") this.Destroy_Cubemap( wa );
    else alert("ERROR 2");
}

EffectPass.prototype.NewShader_Sound = function( shaderCode, commonShaderCodes)
{
    let vsSource = null;

    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for( let i=0; i<commonShaderCodes.length; i++ )
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    this.mSoundShaderCompiled = false;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader_Image = function ( shaderCode, commonShaderCodes )
{
    this.mSupportsVR = false;

    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    return [vsSource, fsSource];


    /*
    let n1 = shaderCode.indexOf("mainVR(");
    let n2 = shaderCode.indexOf("mainVR (");
    let n3 = shaderCode.indexOf("mainVR  (");
    if( n1>0 || n2>0 || n3>0 )
    {
        let vsSourceVR;
        if( this.mIs20 )
            vsSourceVR = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        else
            vsSourceVR = "attribute in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

        let fsSourceVR = this.mHeader;
        for (let i = 0; i < commonShaderCodes.length; i++) {
            fsSourceVR += commonShaderCodes[i];
        }
        fsSourceVR += shaderCode;
        fsSourceVR += this.mImagePassFooterVR;

        let res = this.mRenderer.CreateShader(vsSource, fsSourceVR, preventCache);
        if( res.mResult == false )
        {
            return res.mInfo;
        }
        if( this.mProgramVR != null )
            this.mRenderer.DestroyShader( this.mProgramVR );

        this.mSupportsVR = true;
        this.mProgramVR = res;
    }
    */
}

EffectPass.prototype.NewShader_Cubemap = function( shaderCode, commonShaderCodes )
{
    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }

    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;

    fsSource += shaderCode;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader_Common = function (shaderCode )
{
    let vsSource = null;
    if (this.mIs20)
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader + shaderCode;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader = function ( commonSourceCodes, preventCache, onResolve)
{
    if( this.mRenderer===null ) return;

    let vs_fs = null;

         if( this.mType==="sound"  ) vs_fs = this.NewShader_Sound(   this.mSource, commonSourceCodes );
    else if( this.mType==="image"  ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="buffer" ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="common" ) vs_fs = this.NewShader_Common(  this.mSource,                   );
    else if( this.mType==="cubemap") vs_fs = this.NewShader_Cubemap( this.mSource, commonSourceCodes );
    else { console.log("ERROR 3: \"" + this.mType + "\""); return; }

    let me = this;
    this.mRenderer.CreateShader(vs_fs[0], vs_fs[1], preventCache, false,
        function (worked, info)
        {
            if (worked === true)
            {
                if (me.mType === "sound")
                {
                    me.mSoundShaderCompiled = true;
                }

                me.mCompilationTime = info.mTime;
                me.mError = false;
                me.mErrorStr = "No Errors";
                if (me.mProgram !== null)
                    me.mRenderer.DestroyShader(me.mProgram);
                me.mTranslatedSource = me.mRenderer.GetTranslatedShaderSource(info);
                me.mProgram = info;
            }
            else
            {
                me.mError = true;
                me.mErrorStr = info.mErrorStr;
            }
            onResolve();
        });
}

EffectPass.prototype.DestroyInput = function( id )
{
    if( this.mInputs[id]===null ) return;

    if( this.mInputs[id].mInfo.mType==="texture" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    if( this.mInputs[id].mInfo.mType==="volume" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="webcam" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video.src = "";

        if( this.mInputs[id].video.srcObject!==null )
        {
        let tracks = this.mInputs[id].video.srcObject.getVideoTracks();
        if( tracks ) tracks[0].stop();
        }
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="video" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="music" || this.mInputs[id].mInfo.mType==="musicstream")
    {
        this.mInputs[id].audio.pause();
        this.mInputs[id].audio.mSound.mFreqData = null;
        this.mInputs[id].audio.mSound.mWaveData = null;
        this.mInputs[id].audio = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="cubemap" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="keyboard" )
    {
        //if( this.mInputs[id].globject != null )
          //  this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="mic" )
    {
        this.mInputs[id].mic = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }

    this.mInputs[id] = null;
}

EffectPass.prototype.TooglePauseInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        else
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.audio.mPaused )
        {
            if( inp.loaded )
            {
                inp.audio.play();
            }
            inp.audio.mPaused = false;
        }
        else
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }

    return null;
}

EffectPass.prototype.StopInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused === false )
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused === false )
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.ResumeInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused )
        {
            inp.audio.play();
            inp.audio.mPaused = false;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.RewindInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp==null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.loaded )
        {
            inp.video.currentTime = 0;
        }
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.loaded )
        {
            inp.audio.currentTime = 0;
        }
    }
}

EffectPass.prototype.MuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = true;
        inp.video.mMuted = true;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 0.0;
        inp.audio.mMuted = true;
    }
}

EffectPass.prototype.UnMuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = false;
        inp.video.mMuted = false;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 1.0;
        inp.audio.mMuted = false;
    }
}

EffectPass.prototype.ToggleMuteInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];
    if( inp===null ) return null;

    if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.video.mMuted;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if( inp.audio.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.audio.mMuted;
    }

    return null;
}

EffectPass.prototype.UpdateInputs = function( wa, forceUpdate, keyboard )
{
   for (let i=0; i<this.mInputs.length; i++ )
   {
        let inp = this.mInputs[i];

        if( inp===null )
        {
            if( forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, null, false, 0, 0, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.image, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mPreview, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if( inp.loaded && forceUpdate )
            {
                if( this.mTextureCallbackFun!==null )
                {
                    let img = (assetID_to_cubemapBuferID(inp.mInfo.mID)===-1) ? inp.image[0] : inp.mImage;
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, img, true, 2, 1, -1.0, this.mID );
                }
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:keyboard.mIcon,mData:keyboard.mData}, false, 6, 0, -1.0, this.mID );
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, -1, this.mID );
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
              if( inp.loaded && inp.audio.mPaused === false && inp.audio.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                      inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                  }

                  if (this.mTextureCallbackFun!==null)
                  {
                           if (inp.mInfo.mType === "music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData}, false, 4, 1, inp.audio.currentTime, this.mID);
                      else if (inp.mInfo.mType === "musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData, info: inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                  }
              }
              else if( inp.loaded===false )
              {
                  if (this.mTextureCallbackFun!==null)
                      this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:null}, false, 4, 0, -1.0, this.mID);
              }
        }
        else if( inp.mInfo.mType==="mic" )
        {
              if( inp.loaded && inp.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                      inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
                  }
                  if( this.mTextureCallbackFun!==null )
                      this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave: ((wa==null)?null:inp.mFreqData) }, false, 5, 1, 0, this.mID );
              }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:null}, true, 9, 1, -1.0, this.mID );
            }
        }
    }
}

EffectPass.prototype.Sampler2Renderer = function (sampler)
{
    let filter = this.mRenderer.FILTER.NONE;
    if (sampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
    if (sampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
    let wrap = this.mRenderer.TEXWRP.REPEAT;
    if (sampler.wrap === "clamp") wrap = this.mRenderer.TEXWRP.CLAMP;
    let vflip = false;
    if (sampler.vflip === "true") vflip = true;

    return { mFilter: filter, mWrap: wrap, mVFlip: vflip };
}

EffectPass.prototype.GetSamplerVFlip = function (id)
{
    let inp = this.mInputs[id];
    return inp.mInfo.mSampler.vflip;
}

EffectPass.prototype.GetTranslatedShaderSource = function ()
{
    return this.mTranslatedSource;
}

EffectPass.prototype.SetSamplerVFlip = function (id, str) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = false;
    if (str === "true") filter = true;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, null);
            inp.mInfo.mSampler.vflip = str;
        }
    }
}

EffectPass.prototype.GetAcceptsVFlip = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return false;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return false;
    return true;
}

EffectPass.prototype.GetSamplerFilter = function (id)
{
    let inp = this.mInputs[id];
    if( inp===null) return;
    return inp.mInfo.mSampler.filter;
}

EffectPass.prototype.SetSamplerFilter = function (id, str, buffers, cubeBuffers) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = renderer.FILTER.NONE;
    if (str === "linear") filter = renderer.FILTER.LINEAR;
    if (str === "mipmap") filter = renderer.FILTER.MIPMAP;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0)
            {
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[0], filter, true);
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[1], filter, true);
                inp.mInfo.mSampler.filter = str;
            }
            else
            {
                renderer.SetSamplerFilter(inp.globject, filter, true);
                inp.mInfo.mSampler.filter = str;
            }
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[0], filter, true);
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[1], filter, true);
        inp.mInfo.mSampler.filter = str;
    }
    else if (inp.mInfo.mType === "keyboard")
    {
        inp.mInfo.mSampler.filter = str;
    }
}

EffectPass.prototype.GetAcceptsMipmapping = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetAcceptsLinear = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return true;
    if (inp.mInfo.mType === "musicstream") return true;
    if (inp.mInfo.mType === "mic")  return true;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return true;
    return false;
}

EffectPass.prototype.GetAcceptsWrapRepeat = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return false;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetSamplerWrap = function (id)
{
    return this.mInputs[id].mInfo.mSampler.wrap;
}

EffectPass.prototype.SetSamplerWrap = function (id, str, buffers)
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let restr = renderer.TEXWRP.REPEAT;
    if (str === "clamp") restr = renderer.TEXWRP.CLAMP;

    if (inp === null) 
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "video") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap") 
    {
        if (inp.loaded)
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "webcam") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[0], restr);
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[1], restr);
        inp.mInfo.mSampler.wrap = str;
    }
}


EffectPass.prototype.GetTexture = function( slot )
{
    let inp = this.mInputs[slot];
    if( inp===null ) return null;
    return inp.mInfo;
}

EffectPass.prototype.SetOutputs = function( slot, id )
{
    this.mOutputs[slot] = id;
}

EffectPass.prototype.SetOutputsByBufferID = function( slot, id )
{
    if( this.mType==="buffer" )
    {
        this.mOutputs[slot] = bufferID_to_assetID( id );

        this.mEffect.ResizeBuffer( id, this.mEffect.mXres, this.mEffect.mYres, false );
    }
    else if( this.mType==="cubemap" )
    {
        this.mOutputs[slot] = cubamepBufferID_to_assetID( id );
        this.mEffect.ResizeCubemapBuffer(id, 1024, 1024 );
    }
}

EffectPass.prototype.NewTexture = function( wa, slot, url, buffers, cubeBuffers, keyboard )
{
    var me = this;
    var renderer = this.mRenderer;

    if( renderer===null ) return;

    let texture = null;

    if( url===null || url.mType===null )
    {
        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( this.mTextureCallbackObj, slot, null, true, 0, 0, -1.0, me.mID );
        me.DestroyInput( slot );
        me.mInputs[slot] = null;
        me.MakeHeader();
        return { mFailed:false, mNeedsShaderCompile:false };
    }
    else if( url.mType==="texture" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.image = new Image();
        texture.image.crossOrigin = '';
        texture.image.onload = function()
        {
            let rti = me.Sampler2Renderer(url.mSampler);

            // O.M.G. FIX THIS
            let channels = renderer.TEXFMT.C4I8;
            if (url.mID === "Xdf3zn" || url.mID === "4sf3Rn" || url.mID === "4dXGzn" || url.mID === "4sf3Rr")
                channels = renderer.TEXFMT.C1I8;
            
            texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.image, channels, rti.mFilter, rti.mWrap, rti.mVFlip);

            texture.loaded = true;
            if( me.mTextureCallbackFun!==null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.image, true, 1, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="volume" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mImage = { mData:null, mXres:1, mYres:0, mZres:0 };
        texture.mPreview = new Image();
        texture.mPreview.crossOrigin = '';

	    var xmlHttp = new XMLHttpRequest();
        if( xmlHttp===null ) return { mFailed:true };

        xmlHttp.open('GET', url.mSrc, true);
        xmlHttp.responseType = "arraybuffer";
        xmlHttp.onerror = function()
        {
            console.log( "Error 1 loading Volume" );
        }
        xmlHttp.onload = function()
        {
            let data = xmlHttp.response;
            if (!data ) { console.log( "Error 2 loading Volume" ); return; }

            let file = piFile(data);

            let signature = file.ReadUInt32();
            texture.mImage.mXres = file.ReadUInt32();
            texture.mImage.mYres = file.ReadUInt32();
            texture.mImage.mZres = file.ReadUInt32();
            let binNumChannels = file.ReadUInt8();
            let binLayout = file.ReadUInt8();
            let binFormat = file.ReadUInt16();
            let format = renderer.TEXFMT.C1I8;
                 if( binNumChannels===1 && binFormat===0 )  format = renderer.TEXFMT.C1I8;
            else if( binNumChannels===2 && binFormat===0 )  format = renderer.TEXFMT.C2I8;
            else if( binNumChannels===3 && binFormat===0 )  format = renderer.TEXFMT.C3I8;
            else if( binNumChannels===4 && binFormat===0 )  format = renderer.TEXFMT.C4I8;
            else if( binNumChannels===1 && binFormat===10 ) format = renderer.TEXFMT.C1F32;
            else if( binNumChannels===2 && binFormat===10 ) format = renderer.TEXFMT.C2F32;
            else if( binNumChannels===3 && binFormat===10 ) format = renderer.TEXFMT.C3F32;
            else if( binNumChannels===4 && binFormat===10 ) format = renderer.TEXFMT.C4F32;
            else return;

            let buffer = new Uint8Array(data, 20); // skip 16 bytes (header of .bin)

            let rti = me.Sampler2Renderer(url.mSampler);

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T3D, texture.mImage.mXres, texture.mImage.mYres, format, rti.mFilter, rti.mWrap, buffer);

            if( texture.globject===null )
            {
                console.log( "Error 4: loading Volume" ); 
                return { mFailed:true };
            }

            if (me.mTextureCallbackFun !== null)
            {
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }

            texture.loaded = true;

            // load icon for it
            texture.mPreview.onload = function()
            {
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }
            texture.mPreview.src = url.mPreviewSrc;
        }
        xmlHttp.send("");


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="volume")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="cubemap" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        let rti = me.Sampler2Renderer(url.mSampler);

        if( assetID_to_cubemapBuferID(url.mID)!==-1 )
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 2, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/cubemap00.png";

            this.mEffect.ResizeCubemapBuffer(0, 1024, 1024 );

        }
        else
        {
            texture.image = [ new Image(), new Image(), new Image(), new Image(), new Image(), new Image() ];

            let numLoaded = 0;
            for (var i=0; i<6; i++ )
            {
                texture.image[i].mId = i;
                texture.image[i].crossOrigin = '';
                texture.image[i].onload = function()
                {
                    var id = this.mId;
                    numLoaded++;
                    if( numLoaded===6 )
                    {
                        texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.CUBEMAP, texture.image, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                        texture.loaded = true;
                        if (me.mTextureCallbackFun !== null)
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, texture.image[0], true, 2, 1, -1.0, me.mID);
                    }
                }

                if( i === 0) 
                {
                    texture.image[i].src = url.mSrc;
                } 
                else 
                {
                    let n = url.mSrc.lastIndexOf(".");
                    texture.image[i].src = url.mSrc.substring(0, n) + "_" + i + url.mSrc.substring(n, url.mSrc.length);
                }
            }
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="cubemap")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="webcam" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        texture.video = document.createElement('video');
    	texture.video.width = 320;
    	texture.video.height = 240;
    	texture.video.autoplay = true;
    	texture.video.loop = true;
        texture.mForceMuted = this.mForceMuted;
        texture.mImage = null;

        let rti = me.Sampler2Renderer(url.mSampler);

        var loadImageInsteadOfWebCam = function()
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.mImage, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 7, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/webcam.png";
        }
        
        loadImageInsteadOfWebCam();

        if( typeof navigator.getUserMedia !== "undefined"  && texture.mForceMuted===false )
        {
            texture.video.addEventListener("canplay", function (e)
            {
				try
				{
                    texture.mImage = null;
                    if( texture.globject != null )
                        renderer.DestroyTexture( texture.globject );
					texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
					texture.loaded = true;
                }
                catch(e)
                {
                    loadImageInsteadOfWebCam();
	                alert( 'Your browser can not transfer webcam data to the GPU.');
                }
            } );

            navigator.mediaDevices.getUserMedia( 
                                { "video": { width: 1280, height: 720 }, "audio": false } )
                                .then( function(stream)
                                       {
                                            texture.video.srcObject = stream;
    	                               } )
                                .catch( function(error)
                                        {
                                            loadImageInsteadOfWebCam();
    		                                alert( 'Unable to capture WebCam. Please reload the page.' );
    	                                } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="mic" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mForceMuted = this.mForceMuted;
        texture.mAnalyser = null;
        let num = 512;
        texture.mFreqData = new Uint8Array( num );
        texture.mWaveData = new Uint8Array( num );

        if( wa === null || typeof navigator.getUserMedia === "undefined" )
        {
            if( !texture.mForceMuted ) alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.mForceMuted = true; 
        }

        if( texture.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, num, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)
            texture.loaded = true;
        }
        else
        {
        navigator.getUserMedia( { "audio": true },
                                function(stream)
                                {
                                  texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, null)
                                  texture.mic = wa.createMediaStreamSource(stream);
                                  texture.mAnalyser = wa.createAnalyser();
                                  texture.mic.connect( texture.mAnalyser );
                                  texture.loaded = true;
    	                        },
                                function(error)
                                {
    		                        alert( 'Unable open Mic. Please reload the page.' );
    	                        } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="video" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.video = document.createElement('video');
    	texture.video.loop = true;
        texture.video.preload = "auto";
        texture.video.mPaused = this.mForcePaused;
        texture.video.mMuted = true;//this.mForceMuted;
    	texture.video.muted  = true;//this.mForceMuted;
        if( this.mForceMuted===true )
            texture.video.volume = 0;
    	texture.video.autoplay = false;
        texture.video.hasFalled = false;
        
        let rti = me.Sampler2Renderer(url.mSampler);

        texture.video.addEventListener("canplay", function (e)
        {
            texture.video.play().then( function()
                                       {
                                           texture.video.mPaused = false;

                                           texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                                           texture.loaded = true;
            
                                           if( me.mTextureCallbackFun!=null )
                                               me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.video, true, 3, 1, -1.0, me.mID );
                                        } )
                               .catch( function(error)
                                       {
                                           console.log( error );
                                       }
                                );
        } );

        texture.video.addEventListener( "error", function(e)
        {
               if( texture.video.hasFalled===true ) { alert("Error: cannot load video" ); return; }
               let str = texture.video.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".mp4";
               texture.video.src = str;
               texture.video.hasFalled = true;
        } );

        texture.video.src = url.mSrc;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="music" || url.mType==="musicstream" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.audio = document.createElement('audio');
    	texture.audio.loop = true;
        texture.audio.mMuted = this.mForceMuted;
        texture.audio.mForceMuted = this.mForceMuted;
        texture.audio.muted = this.mForceMuted;
        if( this.mForceMuted===true )
            texture.audio.volume = 0;
        texture.audio.autoplay = false;
        texture.audio.hasFalled = false;
        texture.audio.mPaused = false;
        texture.audio.mSound = {};

        if( this.mForceMuted===false )
        {
            if(url.mType==="musicstream" && SC === null)
            {
                alert( "Shadertoy: Soundcloud could not be reached" );
                texture.audio.mForceMuted = true;
            }
            }

        if( wa === null && this.mForceMuted===false )
        {
            alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.audio.mForceMuted = true;
        }

        if( texture.audio.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null);
            let num = 512;
            texture.audio.mSound.mFreqData = new Uint8Array( num );
            texture.audio.mSound.mWaveData = new Uint8Array( num );
            texture.loaded = true;
        }

        texture.audio.addEventListener( "canplay", function()
        {
            if( texture===null || texture.audio===null ) return;
            if( this.mForceMuted  ) return;
            if( texture.loaded === true ) return;

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)

            texture.audio.mSound.mSource   = wa.createMediaElementSource( texture.audio );
            texture.audio.mSound.mAnalyser = wa.createAnalyser();
            texture.audio.mSound.mGain     = wa.createGain();

            texture.audio.mSound.mSource.connect(   texture.audio.mSound.mAnalyser );
            texture.audio.mSound.mAnalyser.connect( texture.audio.mSound.mGain );
            texture.audio.mSound.mGain.connect(me.mGainNode);

            texture.audio.mSound.mFreqData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );
            texture.audio.mSound.mWaveData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );

            if( texture.audio.mPaused )
            {
                texture.audio.pause();
            }
            else
            {
                texture.audio.play().then( function() {} ).catch( function(e){console.log("error " + e);} );
            }
            texture.loaded = true;
        } );

        texture.audio.addEventListener( "error", function(e)
        {
               if( this.mForceMuted  ) return;

               if( texture.audio.hasFalled===true ) { return; }
               let str = texture.audio.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".ogg";
               texture.audio.src = str;
               texture.audio.hasFalled = true;
        } );

        if( !texture.audio.mForceMuted )
        {
            if(url.mType==="musicstream")
            {
                SC.resolve(url.mSrc, 
                    function(song) 
                    {
                        if( song.streamable===true )
                        {
                            texture.audio.crossOrigin = 'anonymous';
                            texture.audio.src = song.stream_url;
                            texture.audio.soundcloudInfo = song;
                        }
                        else
                        {
                            alert('Shadertoy: Soundcloud 3 - This track cannot be streamed' );
                        }
                    },
                    function(error)
                    {
                        if (me.mTextureCallbackFun!==null)
                        {
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
                        }
                    } );
            } 
            else
            {
                texture.audio.src = url.mSrc;
            }
        }

        if (me.mTextureCallbackFun!==null)
        {
            if (url.mType === "music")            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
            else if (url.mType === "musicstream") me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null, info: texture.audio.soundcloudInfo}, false, 8, 0, -1.0, me.mID);
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="keyboard" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = true;

        texture.keyboard = {};

        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {mImage: keyboard.mIcon, mData: keyboard.mData}, false, 6, 1, -1.0, me.mID );

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="buffer" )
    {
        texture = {};
        texture.mInfo = url;

        texture.image = new Image();
        texture.image.onload = function()
        {
            if( me.mTextureCallbackFun!==null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {texture: texture.image, data:null}, true, 9, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;
        texture.id = assetID_to_bufferID( url.mID );
        texture.loaded = true;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;

        this.mEffect.ResizeBuffer(texture.id, this.mEffect.mXres, this.mEffect.mYres, false );

        this.SetSamplerFilter(slot, url.mSampler.filter, buffers, cubeBuffers, true);
        this.SetSamplerVFlip(slot, url.mSampler.vflip);
        this.SetSamplerWrap(slot, url.mSampler.wrap, buffers);

        this.MakeHeader();
        return returnValue;
    }
    else
    {
        alert( "input type error" );
        return { mFailed: true };
    }

    return { mFailed: true };
}

EffectPass.prototype.Paint_Image = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];

    //------------------------
    
    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];
    let texIsLoaded = [0, 0, 0, 0 ];
    let texID = [ null, null, null, null];

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
            texIsLoaded[i] = 1;
            resos[3*i+0] = 256;
            resos[3*i+1] = 3;
            resos[3*i+2] = 1;
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;

                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                }
            }
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {

                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                texIsLoaded[i] = 0;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    times[i] = 10.0 + time;
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            let id = inp.id;
            if( inp.loaded===true  )
            {
                texID[i] = buffers[id].mTexture[ buffers[id].mLastRenderDone ];
                texIsLoaded[i] = 1;
                resos[3*i+0] = xres;
                resos[3*i+1] = yres;
                resos[3*i+2] = 1;
                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID[i], filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    let prog = this.mProgram;

    //if( vrData!=null && this.mSupportsVR ) prog = this.mProgramVR;

    this.mRenderer.AttachShader(prog);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F("iFrameRate", fps);

    this.mRenderer.SetShaderConstant1F(  "iCh0.time", times[0] );
    this.mRenderer.SetShaderConstant1F(  "iCh1.time", times[1] );
    this.mRenderer.SetShaderConstant1F(  "iCh2.time", times[2] );
    this.mRenderer.SetShaderConstant1F(  "iCh3.time", times[3] );
    this.mRenderer.SetShaderConstant3F(  "iCh0.size", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iCh1.size", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iCh2.size", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iCh3.size", resos[9], resos[10], resos[11] );
    this.mRenderer.SetShaderConstant1I(  "iCh0.loaded", texIsLoaded[0] );
    this.mRenderer.SetShaderConstant1I(  "iCh1.loaded", texIsLoaded[1] );
    this.mRenderer.SetShaderConstant1I(  "iCh2.loaded", texIsLoaded[2] );
    this.mRenderer.SetShaderConstant1I(  "iCh3.loaded", texIsLoaded[3] );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    if( (vrData !== null) && this.mSupportsVR )
    {
        for (let i=0; i<2; i++ )
        {
            let ei = (i===0) ? vrData.mLeftEye : vrData.mRightEye;

            let vp = [i * xres / 2, 0, xres / 2, yres];

            this.mRenderer.SetViewport(vp);

            let fov = ei.mProjection;
            let corA = [ -fov[2], -fov[1], -1.0 ];
            let corB = [  fov[3], -fov[1], -1.0 ];
            let corC = [  fov[3],  fov[0], -1.0 ];
            let corD = [ -fov[2],  fov[0], -1.0 ];
            let apex = [ 0.0, 0.0, 0.0 ];

            let ma = invertFast( ei.mCamera );
            corA = matMulpoint( ma, corA ); 
            corB = matMulpoint( ma, corB ); 
            corC = matMulpoint( ma, corC ); 
            corD = matMulpoint( ma, corD ); 
            apex = matMulpoint( ma, apex ); 

            let corners = [ corA[0], corA[1], corA[2], 
                            corB[0], corB[1], corB[2], 
                            corC[0], corC[1], corC[2], 
                            corD[0], corD[1], corD[2],
                            apex[0], apex[1], apex[2]];

            this.mRenderer.SetShaderConstant3FV("unCorners", corners);
            this.mRenderer.SetShaderConstant4FV("unViewport", vp);

            this.mRenderer.DrawUnitQuad_XY(l1);
        }
    }
    else 
    {
        this.mRenderer.SetViewport([0, 0, xres, yres]);
        this.mRenderer.DrawFullScreenTriangle_XY( l1 );
    }

    this.mRenderer.DettachTextures();
}

EffectPass.prototype.iRenderSound = function(d, callback )
{
    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds() ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    this.mRenderer.SetRenderTarget(this.mRenderFBO);

    this.mRenderer.SetViewport([0, 0, this.mTextureDimensions, this.mTextureDimensions]);
    this.mRenderer.AttachShader(this.mProgram);
    this.mRenderer.SetBlend( false );

    let texID = [null, null, null, null];
    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
    }

    this.mRenderer.AttachTextures(4, texID[0], texID[1], texID[2], texID[3]);

    let l2 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iTimeOffset");
    let l3 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iSampleOffset");
    this.mRenderer.SetShaderConstant4FV("iDate", dates);
    this.mRenderer.SetShaderConstant3FV("iChannelResolution", resos);
    this.mRenderer.SetShaderConstant1F("iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit("iChannel0", 0);
    this.mRenderer.SetShaderTextureUnit("iChannel1", 1);
    this.mRenderer.SetShaderTextureUnit("iChannel2", 2);
    this.mRenderer.SetShaderTextureUnit("iChannel3", 3);

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    //--------------------------------
    let numSamples = this.mTmpBufferSamples;
    let numBlocks = this.mPlaySamples / numSamples;
    for (let j=0; j<numBlocks; j++ )
    {
        let off = j*numSamples;
        
        this.mRenderer.SetShaderConstant1F_Pos(l2, off / this.mSampleRate);
        this.mRenderer.SetShaderConstant1I_Pos(l3, off );
        this.mRenderer.DrawUnitQuad_XY(l1);

        this.mRenderer.GetPixelData(this.mData, 0, this.mTextureDimensions, this.mTextureDimensions);

        callback( off, this.mData, numSamples );
    }

    this.mRenderer.DetachShader();
    this.mRenderer.DettachTextures();
    this.mRenderer.SetRenderTarget(null);
}

EffectPass.prototype.Paint_Sound = function( wa, d )
{
    let bufL = this.mBuffer.getChannelData(0); // Float32Array
    let bufR = this.mBuffer.getChannelData(1); // Float32Array

    this.iRenderSound( d, function(off, data, numSamples)
                         {
                            for( let i=0; i<numSamples; i++ )
                            {
                                bufL[off+i] = -1.0 + 2.0*(data[4*i+0]+256.0*data[4*i+1])/65535.0;
                                bufR[off+i] = -1.0 + 2.0*(data[4*i+2]+256.0*data[4*i+3])/65535.0;
                            }
                         }
                     );
}

EffectPass.prototype.SetUniforms = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    //------------------------
    
    let texID = [ null, null, null, null];

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
        }
        else if( inp.mInfo.mType=="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
    
                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                }
            }

        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
           if( inp.loaded===true )
           { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                times[i] = 10.0 + time;
            }

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = buffers[inp.id].mTexture[ buffers[inp.id].mLastRenderDone ];
                resos[3*i+0] = buffers[inp.id].mResolution[0];
                resos[3*i+1] = buffers[inp.id].mResolution[1];
                resos[3*i+2] = 1;
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    this.mRenderer.AttachShader(this.mProgram);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F(  "iFrameRate", fps );

    this.mRenderer.SetShaderConstant1F(  "iChannel[0].time",       times[0] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[1].time",       times[1] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[2].time",       times[2] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[3].time",       times[3] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[0].resolution", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[1].resolution", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[2].resolution", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[3].resolution", resos[9], resos[10], resos[11] );
}

EffectPass.prototype.ProcessInputs = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
        }
        else if( inp.mInfo.mType==="volume" )
        {
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );
                }
                else if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                if( inp.audio.mForceMuted === true )
                {
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                let id = inp.id;
                let texID = buffers[id].mTexture[ buffers[id].mLastRenderDone ];

                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID, filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
				let id = inp.id;
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }
}

EffectPass.prototype.Paint_Cubemap = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face )
{
    this.ProcessInputs(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
    this.SetUniforms(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    let vp = [0, 0, xres, yres];

    this.mRenderer.SetViewport(vp);

    let corA = [-1.0, -1.0, -1.0];
    let corB = [ 1.0, -1.0, -1.0];
    let corC = [ 1.0,  1.0, -1.0];
    let corD = [-1.0,  1.0, -1.0];
    let apex = [ 0.0,  0.0,  0.0];

         if( face===0 ) { corA=[ 1.0,  1.0,  1.0]; corB=[ 1.0,  1.0, -1.0]; corC=[ 1.0, -1.0, -1.0]; corD=[ 1.0, -1.0,  1.0]; }
    else if( face===1 ) { corA=[-1.0,  1.0, -1.0]; corB=[-1.0,  1.0,  1.0]; corC=[-1.0, -1.0,  1.0]; corD=[-1.0, -1.0, -1.0]; }
    else if( face===2 ) { corA=[-1.0,  1.0, -1.0]; corB=[ 1.0,  1.0, -1.0]; corC=[ 1.0,  1.0,  1.0]; corD=[-1.0,  1.0,  1.0]; }
    else if( face===3 ) { corA=[-1.0, -1.0,  1.0]; corB=[ 1.0, -1.0,  1.0]; corC=[ 1.0, -1.0, -1.0]; corD=[-1.0, -1.0, -1.0]; }
    else if( face===4 ) { corA=[-1.0,  1.0,  1.0]; corB=[ 1.0,  1.0,  1.0]; corC=[ 1.0, -1.0,  1.0]; corD=[-1.0, -1.0,  1.0]; }
    else if( face===5 ) { corA=[ 1.0,  1.0, -1.0]; corB=[-1.0,  1.0, -1.0]; corC=[-1.0, -1.0, -1.0]; corD=[ 1.0, -1.0, -1.0]; }

    let corners = [ corA[0], corA[1], corA[2], 
                    corB[0], corB[1], corB[2], 
                    corC[0], corC[1], corC[2], 
                    corD[0], corD[1], corD[2],
                    apex[0], apex[1], apex[2]];

    this.mRenderer.SetShaderConstant3FV("unCorners", corners);
    this.mRenderer.SetShaderConstant4FV("unViewport", vp);

    this.mRenderer.DrawUnitQuad_XY(l1);

    this.mRenderer.DettachTextures();
}

EffectPass.prototype.Paint = function( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, bufferNeedsMimaps, buffers, cubeBuffers, keyboard, effect )
{
    if( this.mType==="sound" )
    {
        if (this.mSoundShaderCompiled === true)
        {
            // make sure all textures are loaded
            for (let i=0; i<this.mInputs.length; i++ )
            {
                let inp = this.mInputs[i];
                if (inp === null) continue;

                if (inp.mInfo.mType === "texture" && !inp.loaded) return;
                if (inp.mInfo.mType === "cubemap" && !inp.loaded) return;
            }

            this.Paint_Sound(wa, da);
            this.mSoundShaderCompiled = false;
        }
        if (this.mFrame === 0)
        {
            if (this.mPlaying===true)
            {
                this.mPlayNode.disconnect();
                this.mPlayNode.stop();
                this.mPlayNode = null;
            }
            this.mPlaying = true;

            this.mPlayNode = wa.createBufferSource();
            this.mPlayNode.buffer = this.mBuffer;
            this.mPlayNode.connect(this.mGainNode);
            this.mPlayNode.start(0);
        }
        this.mFrame++;
    }
    else if( this.mType==="image" )
    {
        this.mRenderer.SetRenderTarget( null );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );
        this.mFrame++;
    }
    else if( this.mType==="common" )
    {
    }
    else if( this.mType==="buffer" )
    {
        this.mEffect.ResizeBuffer(bufferID, this.mEffect.mXres, this.mEffect.mYres, false );

        let buffer = buffers[bufferID];

        let dstID = 1 - buffer.mLastRenderDone;

        this.mRenderer.SetRenderTarget( buffer.mTarget[dstID] );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }

        // make thumbnail
        //if( this.mTextureCallbackFun != null )
        /*
        {
            this.mRenderer.SetRenderTarget( buffer.mThumbnailRenderTarget );
            let v = [0, 0, buffer.mThumbnailRes[0], buffer.mThumbnailRes[1]];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            this.mRenderer.SetShaderConstant4FV("v", v);
            this.mRenderer.AttachTextures(1, buffer.mTexture[dstID], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);
            this.mRenderer.DettachTextures();
            this.mRenderer.DetachShader();
            this.mRenderer.GetPixelData( new Uint8Array(buffer.mThumbnailBuffer.data.buffer), buffer.mThumbnailRes[0], buffer.mThumbnailRes[1] );
            this.mRenderer.SetRenderTarget(null);
        }
        */
        buffers[bufferID].mLastRenderDone = 1 - buffers[bufferID].mLastRenderDone;
        this.mFrame++;
    }
    else if( this.mType==="cubemap" )
    {
        this.mEffect.ResizeCubemapBuffer(bufferID, 1024, 1024, false );

        let buffer = cubeBuffers[bufferID];

        xres = buffer.mResolution[0];
        yres = buffer.mResolution[1];
        let dstID = 1 - buffer.mLastRenderDone;
        for( let face=0; face<6; face++ )
        {
            this.mRenderer.SetRenderTargetCubeMap( buffer.mTarget[dstID], face );
            this.Paint_Cubemap( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
        }
        this.mRenderer.SetRenderTargetCubeMap( null, 0 );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }
        cubeBuffers[bufferID].mLastRenderDone = 1 - cubeBuffers[bufferID].mLastRenderDone;

        this.mFrame++;
    }
}

EffectPass.prototype.StopOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;
    this.mPlayNode.disconnect();
}

EffectPass.prototype.ResumeOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;

    wa.resume()
    this.mPlayNode.connect( this.mGainNode );
}

EffectPass.prototype.StopOutput_Image = function( wa )
{
}

EffectPass.prototype.ResumeOutput_Image = function( wa )
{
}

EffectPass.prototype.StopOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.StopInput(j);

    if( this.mType==="sound" )
         this.StopOutput_Sound( wa );
    else
         this.StopOutput_Image( wa );
}

EffectPass.prototype.ResumeOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.ResumeInput(j);

    if( this.mType==="sound" )
         this.ResumeOutput_Sound( wa );
    else
         this.ResumeOutput_Image( wa );
}

EffectPass.prototype.GetCompilationTime = function()
{
    return this.mCompilationTime;
}

//============================================================================================================
function Screenshots()
{
    // private
    let mTexture = null;
    let mTarget = null;
    let mXres = 0;
    let mYres = 0;
    let mCubemapToEquirectProgram;
    let mRenderer = null;

    // public
    var me = {};

    me.Initialize = function(renderer)
    {
        mRenderer = renderer;
        let caps = mRenderer.GetCaps();
        let is20 = caps.mIsGL20;

        let vsSourceC, fsSourceC;
        if( is20 )
        {
            vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; out vec4 outColor; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); outColor = texture(t, rd); }";
        }
        else
        {
            vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); gl_FragColor = texture(t, rd); }";
        }

        let compileShader = function (worked, info)
        {
            if (worked === false)
            {
                console.log("Failed to compile cubemap resample shader (" + errorType + "): " + log);
            }
            else
            {
                mCubemapToEquirectProgram = info;
            }
        }
        mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, compileShader);

        return true;
    };

    me.Allocate = function( xres, yres )
    {
        if( xres>mXres || yres>mYres )
        {
            let texture = mRenderer.CreateTexture(mRenderer.TEXTYPE.T2D, xres, yres, mRenderer.TEXFMT.C4F32, mRenderer.FILTER.NONE, mRenderer.TEXWRP.CLAMP, null);
            let target = mRenderer.CreateRenderTarget( texture, null, null, null, null, false);

            if( mXres!==0 )
            {
                mRenderer.DestroyTexture(mTexture);
                mRenderer.DestroyRenderTarget(mTarget);
            }

            mTexture = texture;
            mTarget = target;
            mXres = xres;
            mYres = yres;
        }
    };

    me.GetProgram = function()
    {
        return mCubemapToEquirectProgram;
    };
    me.GetTarget = function()
    {
        return mTarget;
    };

    return me;
};

//============================================================================================================

function Effect(vr, ac, canvas, callback, obj, forceMuted, forcePaused, resizeCallback, crashCallback )
{
    let xres = canvas.width;
    let yres = canvas.height;

    let me = this;
    this.mCanvas = canvas;
    this.mCreated = false;
    this.mRenderer = null;
    this.mAudioContext = ac;
    this.mGLContext = null;
    this.mWebVR = vr;
    this.mRenderingStereo = false;
    this.mXres = xres;
    this.mYres = yres;
    this.mForceMuted = forceMuted;
    if( ac===null ) this.mForceMuted = true;
    this.mForcePaused = forcePaused;
    this.mGainNode = null;
    this.mPasses = [];
    this.mFrame = 0;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mMaxBuffers = 4;
    this.mMaxCubeBuffers = 1;
    this.mMaxPasses = this.mMaxBuffers + 1 + 1 + 1 + 1; // some day decouple passes from buffers (4 buffers + common + Imagen + sound + cubemap)
    this.mBuffers = [];
    this.mCubeBuffers = [];
    this.mScreenshotSytem = null;
    this.mCompilationTime = 0;
    this.mIsLowEnd = piIsMobile();

    this.mGLContext = piCreateGlContext(canvas, false, false, true, false); // need preserve-buffe to true in order to capture screenshots
    if (this.mGLContext === null)
    {
        return;
    }

    canvas.addEventListener("webglcontextlost", function (event)
        {
            event.preventDefault();
            crashCallback();
        }, false);

    this.mRenderer = piRenderer();
    if (!this.mRenderer.Initialize(this.mGLContext))
        return;

    this.mScreenshotSytem = Screenshots();
    if (!this.mScreenshotSytem.Initialize(this.mRenderer))
        return;

    var caps = this.mRenderer.GetCaps();
    this.mIs20 = caps.mIsGL20;
    this.mShaderTextureLOD = caps.mShaderTextureLOD;
    //-------------
    if( ac!==null )
    {   
        this.mGainNode = ac.createGain();
        if( !forceMuted )
        {
            this.mGainNode.connect( ac.destination);
        }
        if (this.mForceMuted )
            this.mGainNode.gain.value = 0.0;
        else
            this.mGainNode.gain.value = 1.0;
    }

    //-------------
    let vsSourceC, fsSourceC;
    if( this.mIs20 )
    {
        vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { outColor = textureLod(t, gl_FragCoord.xy / v.zw, 0.0); }";
    }
    else
    {
        vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; void main() { gl_FragColor = texture2D(t, gl_FragCoord.xy / v.zw, -100.0); }";
    }

    this.mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, function(worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to copy buffers : " + info.mErrorStr);
            else me.mProgramCopy = info;
        });

    let vsSourceD, fsSourceD;
    if( this.mIs20 )
    {
        vsSourceD = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { vec2 uv = gl_FragCoord.xy / v.zw; outColor = texture(t, vec2(uv.x,1.0-uv.y)); }";
    }
    else
    {
        vsSourceD = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; void main() { vec2 uv = gl_FragCoord.xy / v.zw; gl_FragColor = texture2D(t, vec2(uv.x,1.0-uv.y)); }";
    }

    this.mRenderer.CreateShader(vsSourceD, fsSourceD, false, true, function (worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to downscale buffers : " + info.mErrorStr);
            else me.mProgramDownscale = info;
        });


    // set all buffers and cubemaps to null
    for( let i=0; i<this.mMaxBuffers; i++ )
    {
        this.mBuffers[i] = { mTexture: [null, null], 
                             mTarget:  [null, null], 
                             mResolution: [0, 0],
                             mLastRenderDone: 0,
                             mThumbnailRenderTarget: null,
                             mThumbnailTexture: null,
                             mThumbnailBuffer:  null,
                             mThumbnailRes: [0, 0] };
    }

    for( let i=0; i<this.mMaxCubeBuffers; i++ )
    {
        this.mCubeBuffers[i] = { mTexture: [null, null], 
                                mTarget:  [null, null], 
                                mResolution: [0, 0],
                                mLastRenderDone: 0,
                                mThumbnailRenderTarget: null,
                                mThumbnailTexture: null,
                                mThumbnailBuffer:  null,
                                mThumbnailRes: [0, 0] };
    }

    //-------

    let keyboardData = new Uint8Array( 256*3 );
    for (let j=0; j<(256*3); j++ ) { keyboardData[j] = 0; }
    let kayboardTexture = this.mRenderer.CreateTexture( this.mRenderer.TEXTYPE.T2D, 256, 3, this.mRenderer.TEXFMT.C1I8, this.mRenderer.FILTER.NONE, this.mRenderer.TEXWRP.CLAMP, null);
    let keyboardImage = new Image();
    if( callback!==null )
        keyboardImage.src = "/img/keyboard.png"; // don't load PNG if no UI 
    this.mKeyboard = { mData: keyboardData, mTexture: kayboardTexture, mIcon: keyboardImage };

    let iResize = function( xres, yres )
    {
        me.mCanvas.width = xres;
        me.mCanvas.height = yres;
        me.mXres = xres;
        me.mYres = yres;
        me.ResizeBuffers(xres, yres);
        resizeCallback(xres, yres);
    };

    let bestAttemptFallback = function()
    {
        let devicePixelRatio = window.devicePixelRatio || 1;
        let xres = Math.round(me.mCanvas.offsetWidth  * devicePixelRatio) | 0;
        let yres = Math.round(me.mCanvas.offsetHeight * devicePixelRatio) | 0;
        iResize(xres, yres);
    };

    if(!window.ResizeObserver)
    {
        console.log("WARNING: This browser doesn't support ResizeObserver.");
        bestAttemptFallback();
        window.addEventListener("resize", bestAttemptFallback);
    }
    else
    {
        this.mRO = new ResizeObserver( function(entries, observer)
        {
            var entry = entries[0];
            if (!entry['devicePixelContentBoxSize'])
            {
                observer.unobserve(me.mCanvas);
                console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (2)");
                bestAttemptFallback();
                window.addEventListener("resize", bestAttemptFallback);
            }
            else
            {
                let box = entry.devicePixelContentBoxSize[0];
                let xres = box.inlineSize;
                let yres = box.blockSize;
                iResize(xres, yres);
            }
        });
        try
        {
            this.mRO.observe(this.mCanvas, { box: ["device-pixel-content-box"] });
            //this.mRO.observe(this.mCanvas);
        }
        catch (e)
        {
            console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (1)");
            bestAttemptFallback();
            window.addEventListener("resize", bestAttemptFallback);
        }
    }

    this.mCreated = true;
}

Effect.prototype.ResizeCubemapBuffer = function(i, xres, yres )
{
    let oldXres = this.mCubeBuffers[i].mResolution[0];
    let oldYres = this.mCubeBuffers[i].mResolution[1];

    if( this.mCubeBuffers[i].mTexture[0]===null || oldXres !== xres || oldYres !== yres )
    {
        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);
        let target1 = this.mRenderer.CreateRenderTargetCubeMap( texture1, null, false);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target2 = this.mRenderer.CreateRenderTargetCubeMap( texture2, null, false);

        // Store new buffers
        this.mCubeBuffers[i].mTexture = [texture1,texture2], 
        this.mCubeBuffers[i].mTarget =  [target1, target2 ], 
        this.mCubeBuffers[i].mLastRenderDone = 0;
        this.mCubeBuffers[i].mResolution[0] = xres;
        this.mCubeBuffers[i].mResolution[1] = yres;
    }
}

Effect.prototype.ResizeBuffer = function( i, xres, yres, skipIfNotExists )
{
    if( skipIfNotExists && this.mBuffers[i].mTexture[0]===null ) return;

    let oldXres = this.mBuffers[i].mResolution[0];
    let oldYres = this.mBuffers[i].mResolution[1];

    if( oldXres !== xres || oldYres !== yres )
    {
        let needCopy = (this.mBuffers[i].mTexture[0]!==null);

        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[0].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[0].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[1].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[1].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target1 = this.mRenderer.CreateRenderTarget( texture1, null, null, null, null, false);
        let target2 = this.mRenderer.CreateRenderTarget( texture2, null, null, null, null, false);

        if( needCopy )
        {
            let v = [0, 0, Math.min(xres, oldXres), Math.min(yres, oldYres)];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            let vOld = [0, 0, oldXres, oldYres];
            this.mRenderer.SetShaderConstant4FV("v", vOld);

            // Copy old buffers 1 to new buffer
            this.mRenderer.SetRenderTarget(target1);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[0], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Copy old buffers 2 to new buffer
            this.mRenderer.SetRenderTarget(target2);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[1], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Deallocate old memory
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[0]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[0]);
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[1]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[1]);
            //this.mRenderer.DestroyTexture(this.mBuffers[i].thumbnailTexture);
        }

        // Store new buffers
        this.mBuffers[i].mTexture = [texture1,texture2], 
        this.mBuffers[i].mTarget =  [target1, target2 ], 
        this.mBuffers[i].mLastRenderDone = 0;
        this.mBuffers[i].mResolution[0] = xres;
        this.mBuffers[i].mResolution[1] = yres;
    }
}

Effect.prototype.saveScreenshot = function(passid)
{
    let pass = this.mPasses[passid];

    if( pass.mType === "buffer" )
    {
        let bufferID = assetID_to_bufferID( this.mPasses[passid].mOutputs[0] );

        let texture = this.mBuffers[bufferID].mTarget[ this.mBuffers[bufferID].mLastRenderDone ];

        let numComponents = 3;
        let width = texture.mTex0.mXres;
        let height = texture.mTex0.mYres;
        let type = "Float"; // Other options Float, Half, Uint
        let bytes = new Float32Array(width * height * 4 );//numComponents);
        this.mRenderer.GetPixelDataRenderTarget( texture, bytes, width, height );
        let blob = piExportToEXR(width, height, numComponents, type, bytes);

        // Offer download automatically to the user
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "cubemap" )
    {
        let xres = 4096;
        let yres = 2048;
        this.mScreenshotSytem.Allocate( xres, yres );

        let cubeBuffer = this.mCubeBuffers[0];

        let target = this.mScreenshotSytem.GetTarget();
        this.mRenderer.SetRenderTarget( target );

        let program = this.mScreenshotSytem.GetProgram();

        this.mRenderer.AttachShader(program);
        let l1 = this.mRenderer.GetAttribLocation(program, "pos");
        this.mRenderer.SetViewport( [0, 0, xres, yres] );
        this.mRenderer.AttachTextures(1, cubeBuffer.mTexture[ cubeBuffer.mLastRenderDone ], null, null, null);
        this.mRenderer.DrawUnitQuad_XY(l1);
        this.mRenderer.DettachTextures();
        this.mRenderer.SetRenderTarget( null );

        let data = new Float32Array(xres*yres*4);
        this.mRenderer.GetPixelDataRenderTarget( target, data, xres, yres );

        let blob = piExportToEXR(xres, yres, 3, "Float", data );
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "sound" )
    {
        let offset = 0;
        const bits = 16;
        const numChannels = 2;
        let words = new Int16Array(60*pass.mSampleRate*numChannels );

        pass.iRenderSound( new Date(), function(off, data, numSamples)
                                         {
                                            for( let i=0; i<numSamples; i++ )
                                            {
                                                words[offset++] = (data[4*i+0]+256.0*data[4*i+1]) - 32767;
                                                words[offset++] = (data[4*i+2]+256.0*data[4*i+3]) - 32767;
                                            }
                                         }
                                     );

        let blob = piExportToWAV( 60*pass.mSampleRate, pass.mSampleRate, bits, numChannels, words);

        piTriggerDownload("sound.wav", blob);
    }    
}

Effect.prototype.ResizeBuffers = function(xres, yres)
{
    for (let i=0; i<this.mMaxBuffers; i++ )
    {
        this.ResizeBuffer(i, xres, yres, true);
    }
}

Effect.prototype.IsEnabledVR = function ()
{
    if (this.mRenderingStereo) return true;
    return false;
}

Effect.prototype.EnableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( this.mRenderingStereo ) return;

    this.mRenderingStereo = true;
    this.mWebVR.Enable();
}

Effect.prototype.DisableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( !this.mRenderingStereo ) return;

    this.mRenderingStereo = false;
    this.mWebVR.Disable();
}

Effect.prototype.GetTexture = function( passid, slot ) { return this.mPasses[passid].GetTexture( slot ); }
Effect.prototype.NewTexture = function (passid, slot, url) { return this.mPasses[passid].NewTexture( this.mAudioContext, slot, url, this.mBuffers, this.mCubeBuffers, this.mKeyboard ); }
Effect.prototype.SetOutputs = function( passid, slot, url ) { this.mPasses[passid].SetOutputs( slot, url ); }
Effect.prototype.SetOutputsByBufferID = function( passid, slot, id ) { this.mPasses[passid].SetOutputsByBufferID( slot, id ); }
Effect.prototype.GetAcceptsLinear = function (passid, slot) { return this.mPasses[passid].GetAcceptsLinear(slot); }
Effect.prototype.GetAcceptsMipmapping = function (passid, slot) { return this.mPasses[passid].GetAcceptsMipmapping(slot); }
Effect.prototype.GetAcceptsWrapRepeat = function (passid, slot) { return this.mPasses[passid].GetAcceptsWrapRepeat(slot); }
Effect.prototype.GetAcceptsVFlip = function (passid, slot) { return this.mPasses[passid].GetAcceptsVFlip(slot); }
Effect.prototype.SetSamplerFilter = function (passid, slot, str) { this.mPasses[passid].SetSamplerFilter(slot, str, this.mBuffers, this.mCubeBuffers); }
Effect.prototype.GetTranslatedShaderSource = function (passid) { return this.mPasses[passid].GetTranslatedShaderSource(); }
Effect.prototype.GetSamplerFilter = function (passid, slot) { return this.mPasses[passid].GetSamplerFilter(slot); }
Effect.prototype.SetSamplerWrap = function (passid, slot, str) { this.mPasses[passid].SetSamplerWrap(slot, str, this.mBuffers); }
Effect.prototype.GetSamplerWrap = function (passid, slot) { return this.mPasses[passid].GetSamplerWrap(slot); }
Effect.prototype.SetSamplerVFlip = function (passid, slot, str) { this.mPasses[passid].SetSamplerVFlip(slot, str); }
Effect.prototype.GetSamplerVFlip = function (passid, slot) { return this.mPasses[passid].GetSamplerVFlip(slot); }

Effect.prototype.GetHeaderSize = function (passid)
{
    return this.mPasses[passid].mHeaderLength + 
           this.mRenderer.GetShaderHeaderLines(1);
}

Effect.prototype.ToggleVolume = function()
{
    this.mForceMuted = !this.mForceMuted;

    // outp
    if (this.mForceMuted)
        this.mGainNode.gain.value = 0.0;
    else
        this.mGainNode.gain.value = 1.0;

    // inp
    let num = this.mPasses.length;
    for( let j=0; j<num; j++ )
    {
        for( let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            if( this.mForceMuted )
                this.mPasses[j].MuteInput( this.mAudioContext, i );
            else
                this.mPasses[j].UnMuteInput( this.mAudioContext, i );
        }
    }

    return this.mForceMuted;
}

Effect.prototype.SetKeyDown = function( passid, k )
{
    if( this.mKeyboard.mData[ k + 0*256 ] == 255 ) return;

    this.mKeyboard.mData[ k + 0*256 ] = 255;
    this.mKeyboard.mData[ k + 1*256 ] = 255;
    this.mKeyboard.mData[ k + 2*256 ] = 255 - this.mKeyboard.mData[ k + 2*256 ];
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }
}

Effect.prototype.SetKeyUp = function( passid, k )
{
    this.mKeyboard.mData[ k + 0*256 ] = 0;
    this.mKeyboard.mData[ k + 1*256 ] = 0;
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }
}

Effect.prototype.StopOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].StopOutput( wa );
    }
}

Effect.prototype.ResumeOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].ResumeOutput( wa );
    }
}

Effect.prototype.PauseInput = function( passid, id )
{
    return this.mPasses[passid].TooglePauseInput( this.mAudioContext, id );
}

Effect.prototype.ToggleMuteInput = function( passid, id )
{
    return this.mPasses[passid].ToggleMuteInput( this.mAudioContext, id );
}

Effect.prototype.RewindInput = function( passid, id )
{
    this.mPasses[passid].RewindInput( this.mAudioContext, id );
}

Effect.prototype.UpdateInputs = function( passid, forceUpdate )
{
   this.mPasses[passid].UpdateInputs( this.mAudioContext, forceUpdate, this.mKeyboard );
}

Effect.prototype.ResetTime = function()
{
    this.mFrame = 0;
    this.mAudioContext.resume()

    let num = this.mPasses.length;
    for( let i=0; i<num; i++ )
    {
        this.mPasses[i].mFrame = 0;
        for( let j=0; j<this.mPasses[i].mInputs.length; j++ )
            this.mPasses[i].RewindInput(this.mAudioContext, j)
    }
}

Effect.prototype.RequestAnimationFrame = function (id)
{
    if (this.mRenderingStereo && this.mWebVR.IsPresenting())
    {
        this.mWebVR.RequestAnimationFrame(id);
    }
    else
    {
        requestAnimFrame(id);
    }
}

Effect.prototype.Paint = function(time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, isPaused)
{
    let wa = this.mAudioContext;
    let da = new Date();
    let vrData = null; if (this.mRenderingStereo) vrData = this.mWebVR.GetData();
    let xres = this.mXres / 1;
    let yres = this.mYres / 1;

    if( this.mFrame===0 )
    {
        for( let i=0; i<this.mMaxBuffers; i++ )
        {
            if( this.mBuffers[i].mTexture[0]!==null )
            {
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[0] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[1] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
				
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[0] );
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[1] );
            }
        }
        for( let i=0; i<this.mMaxCubeBuffers; i++ )
        {
            if( this.mCubeBuffers[i].mTexture[0]!==null )
            {
                for( let face=0; face<6; face++ )
                {
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[0], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[1], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
					this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[0] );
				    this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[1] );
                }
            }
        }
    }

    let num = this.mPasses.length;

    // render sound first
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "sound" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "buffer" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;
        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="buffer" && inp.id === bufferID && inp.mInfo.mSampler.filter === "mipmap")
                {
                    needMipMaps = true;
                    break;
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render cubemap buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "cubemap" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = 0;//assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;

        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="cubemap" )
                {
                    if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0 && inp.mInfo.mSampler.filter === "mipmap" )
                    {
                        needMipMaps = true;
                        break;
                    }
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render image last
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "image" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }   

    // erase keypresses
    for (let k=0; k<256; k++ )
    {
       this.mKeyboard.mData[ k + 1*256 ] = 0;
    }
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    if( this.mRenderingStereo ) this.mWebVR.Finish();

    this.mFrame++;
}

Effect.prototype.NewShader = function( passid, preventCache, onResolve )
{
    let commonSourceCodes = [];
    for (let i=0; i<this.mPasses.length; i++ )
    {
        if( this.mPasses[i].mType==="common")
        {
            commonSourceCodes.push(this.mPasses[i].mSource);
        }
    }

    this.mPasses[passid].NewShader(commonSourceCodes, preventCache, onResolve );
}

Effect.prototype.GetNumPasses = function()
{
    return this.mPasses.length;
}

Effect.prototype.GetNumOfType = function(passtype)
{
    let id = 0;
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType===passtype )
        {
            id++;
        }
    }
    return id;
}

Effect.prototype.GetPassType = function( id ) { return this.mPasses[id].mType; }
Effect.prototype.GetPassName = function( id ) { return this.mPasses[id].mName; }
Effect.prototype.GetCode = function( id ) { return this.mPasses[id].mSource; }
Effect.prototype.SetCode = function( id, source ) { this.mPasses[id].SetCode(source); }
Effect.prototype.GetError = function (id) { return this.mPasses[id].mError; }
Effect.prototype.GetErrorStr = function (id) { return this.mPasses[id].mErrorStr; }
Effect.prototype.GetErrorGlobal = function()
{
    for (let i = 0; i < this.mPasses.length; i++)
    {
        if (this.mPasses[i].mError)
        {
            return true;
        }
    }
    return false;
}

Effect.prototype.Load = function (jobj )
{
    if (jobj.ver !== "0.1")
    {
        console.log("Wrong Format");
        return false;
    }

    let numPasses = jobj.renderpass.length;

    if( numPasses<1 || numPasses>this.mMaxPasses )
    {
        console.log("Corrupted Shader - " + numPasses);
        return false;
    }

    this.mPasses = [];
    for (let j = 0; j < numPasses; j++)
    {
        let rpass = jobj.renderpass[j];

        // skip sound passes if in thumbnail mode
        if( this.mForceMuted && rpass.type === "sound" ) continue;

        let wpass = new EffectPass(this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                   this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode,
                                   this.mProgramDownscale, j, this);

        wpass.Create(rpass.type, this.mAudioContext);

        let numInputs = rpass.inputs.length;

        for (let i = 0; i < 4; i++)
        {
            wpass.NewTexture(this.mAudioContext, i, null, null, null);
        }
        for (let i = 0; i < numInputs; i++)
        {
            let lid  = rpass.inputs[i].channel;
            let styp = rpass.inputs[i].type;
            let sid  = rpass.inputs[i].id;
            let ssrc = rpass.inputs[i].filepath;
            let psrc = rpass.inputs[i].previewfilepath;
            let samp = rpass.inputs[i].sampler;

            wpass.NewTexture(this.mAudioContext, lid, { mType: styp, mID: sid, mSrc: ssrc, mSampler: samp, mPreviewSrc: psrc }, this.mBuffers, this.mCubeBuffers, this.mKeyboard);
        }

        for (let i = 0; i < 4; i++)
        {
            wpass.SetOutputs(i, null);
        }

        let numOutputs = rpass.outputs.length;
        for (let i = 0; i < numOutputs; i++)
        {
            let outputID = rpass.outputs[i].id;
            let outputCH = rpass.outputs[i].channel;
            wpass.SetOutputs(outputCH, outputID);
        }

        // create some hardcoded names. This should come from the DB
        let rpassName = "";
        if (rpass.type === "common" ) rpassName = "Common";
        if (rpass.type === "sound"  ) rpassName = "Sound";
        if (rpass.type === "image"  ) rpassName = "Image";
        if (rpass.type === "buffer") rpassName = "Buffer " + String.fromCharCode(65 + assetID_to_bufferID(wpass.mOutputs[0]));
        if (rpass.type === "cubemap") rpassName = "Cube A";// " + String.fromCharCode(65 + assetID_to_bufferID(this.mPasses[j].mOutputs[0]));
        wpass.SetName(rpassName);
        wpass.SetCode(rpass.code);

        this.mPasses.push(wpass);
    }
    return true;
}

Effect.prototype.CompileSome = function ( passes, preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    for (let j = 0; j < passes.length; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(passes[j], preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < me.mPasses.length; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.Compile = function (preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(j, preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < numPasses; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.GetCompilationTime = function( id )
{
    return this.mPasses[id].GetCompilationTime()/1000.0;
}
Effect.prototype.GetTotalCompilationTime = function()
{
    return this.mCompilationTime/1000.0;
}

Effect.prototype.DestroyPass = function( id )
{
   this.mPasses[id].Destroy( this.mAudioContext );
   this.mPasses.splice(id, 1);
}

Effect.prototype.AddPass = function( passType, passName, onResolve )
{
    let shaderStr = null;

    if( passType==="sound"   ) shaderStr = "vec2 mainSound( int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n}";
    if( passType==="buffer"  ) shaderStr = "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}";
    if( passType==="common"  ) shaderStr = "vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}";
    if( passType==="cubemap" ) shaderStr = "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rayDir;\n\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}";

    let id = this.GetNumPasses();
    this.mPasses[id] = new EffectPass( this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                       this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode, 
                                       this.mProgramDownscale, id, this );

    this.mPasses[id].Create( passType, this.mAudioContext );
    this.mPasses[id].SetName( passName );
    this.mPasses[id].SetCode( shaderStr );
    this.NewShader(id, false, function ()
    {
        onResolve();
    });

    return { mId : id, mShader : shaderStr };
}

// this should be removed once we have MultiPass 2.0 and passes render to arbitrary buffers
Effect.prototype.IsBufferPassUsed = function( bufferID )
{
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType !== "buffer" ) continue;
        if( this.mPasses[j].mOutputs[0] === bufferID_to_assetID(bufferID) ) return true;
    }
    return false;
}

Effect.prototype.Save = function()
{
    var result = {};

    result.ver = "0.1";

    result.renderpass = [];

    let numPasses = this.mPasses.length;
    for (let j=0; j<numPasses; j++ )
    {
        result.renderpass[j] = {};

        result.renderpass[j].outputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            let outputID = this.mPasses[j].mOutputs[i];
            if( outputID===null ) continue;
            result.renderpass[j].outputs.push( { channel: i, id: outputID } );
        }
        result.renderpass[j].inputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            if( this.mPasses[j].mInputs[i]===null ) continue;
            result.renderpass[j].inputs.push( {channel: i,
                                               type    : this.mPasses[j].mInputs[i].mInfo.mType,
                                               id      : this.mPasses[j].mInputs[i].mInfo.mID,
                                               filepath: this.mPasses[j].mInputs[i].mInfo.mSrc,
                                               sampler : this.mPasses[j].mInputs[i].mInfo.mSampler });
        }

        result.renderpass[j].code = this.mPasses[j].mSource;
        result.renderpass[j].name = this.mPasses[j].mName
        result.renderpass[j].description = "";
        result.renderpass[j].type = this.mPasses[j].mType;
    }

    result.flags = this.calcFlags();

    return result;
}

Effect.prototype.calcFlags = function ()
{
    let flagVR = false;
    let flagWebcam = false;
    let flagSoundInput = false;
    let flagSoundOutput = false;
    let flagKeyboard = false;
    let flagMultipass = false;
    let flagMusicStream = false;

    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        let pass = this.mPasses[j];

        if (pass.mType === "sound") flagSoundOutput = true;
        if (pass.mType === "buffer") flagMultipass = true;

        for (let i = 0; i < 4; i++)
        {
            if (pass.mInputs[i] === null) continue;

            if (pass.mInputs[i].mInfo.mType === "webcam") flagWebcam = true;
            else if (pass.mInputs[i].mInfo.mType === "keyboard") flagKeyboard = true;
            else if (pass.mInputs[i].mInfo.mType === "mic") flagSoundInput = true;
            else if (pass.mInputs[i].mInfo.mType === "musicstream") flagMusicStream = true;
        }

        let n1 = pass.mSource.indexOf("mainVR(");
        let n2 = pass.mSource.indexOf("mainVR (");
        if (n1 > 0 || n2 > 0) flagVR = true;
    }

    return {
        mFlagVR: flagVR,
        mFlagWebcam: flagWebcam,
        mFlagSoundInput: flagSoundInput,
        mFlagSoundOutput: flagSoundOutput,
        mFlagKeyboard: flagKeyboard,
        mFlagMultipass: flagMultipass,
        mFlagMusicStream: flagMusicStream
    };
}</script>
    <script>"use strict"

const kMaxCompileTime = 10.0;

function iReportCrash(shaderID)
{
    let req = new XMLHttpRequest();
    req.onload = function ()
    {
        let jsn = req.response;
        if (jsn === null) return;
        if (jsn.result === 0)
        {
            // yep
        }
    };
    req.open("POST", "/shadertoy", true);
    req.responseType = "json";
    req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    req.send( "s=" + shaderID + "&r=2" );
}
</script>
    <script>"use strict"

var gActive = -1;
var mShaders = [];
var gNumCanvases = 0;

function myrefresh( id, slot, img, forceFrame, gui, guiID, renderID, time )
{
    if( mShaders[id].mReady===false ) return;
    if( forceFrame )
    {
        if (mShaders[id].mScreenshot === false)
        {
            mShaders[id].gEffect.Paint(mShaders[id].mTime / 1000.0, 1.0 / 60.0, 60.0, 0, 0, 0, 0, false);
        }
    }
}

function startRendering()
{
    if( gActive<0 ) return;
    if( mShaders[gActive].mReady===false ) return;
    if( mShaders[gActive].mScreenshot===true ) return;

    let time = getRealTime();

    mShaders[gActive].mFPS.Count( time );
    mShaders[gActive].mTime = mShaders[gActive].mTime0 + (time - mShaders[gActive].mTo);
    let dtime = 1000.0/60.0;
    mShaders[gActive].gEffect.Paint( mShaders[gActive].mTime/1000.0, dtime/1000.0, mShaders[gActive].mFPS.GetFPS(), 0,0,0,0, false);

    requestAnimFrame( startRendering );
}

function iLoadAndCompile(jsn, i )
{
    var shaderObj = jsn[i];
    if (shaderObj === null) return;

    var resizeCB = function (xres, yres) { myrefresh(i, 0, null, true, false, 0, -1.0) };
    var crashCB = function () { alert('crash');/*iReportCrash(gShaderIDs[i])*/ };
    mShaders[i].gEffect = new Effect(null, null, mShaders[i].mPreview.mCanvas, myrefresh, i, true, true, resizeCB, crashCB);

    if (!mShaders[i].gEffect.Load(shaderObj)) return;

    mShaders[i].gEffect.Compile(false, function (worked)
    {
        if (worked === true)
        {
            previewShowRender(mShaders[i].mPreview);

            mShaders[i].mScreenshot = false;
            mShaders[i].mReady = true;
            mShaders[i].mTime = 10.0 * 1000.0;
            mShaders[i].mTime0 = 0.0;
            mShaders[i].mTo = 0.0;
            mShaders[i].mFPS = piCreateFPSCounter();
            mShaders[i].mPreview.mCanvas.addEventListener("mouseout", function (ev) { gActive = -1; }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseover", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.add('isVisible'); }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseout", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.remove('isVisible'); }, true);
            mShaders[i].mPreview.mCanvas.addEventListener("mouseover", function (ev)
            {
                let ele = piGetSourceElement(ev);
                if (ele.mId === undefined) return;

                gActive = ele.mId;
                if (!mShaders[gActive].mReady) return;
                let time = getRealTime();
                mShaders[gActive].mTo = time;
                mShaders[gActive].mTime0 = mShaders[gActive].mTime;
                mShaders[gActive].mFPS.Reset(time);

                startRendering();
            }, true);


            /*
            let compilationTime = mShaders[i].gEffect.GetTotalCompilationTime();
            if (compilationTime > kMaxCompileTime)
            {
                iReportCrash(mShaders[i].mShaderID);
            }*/

            myrefresh(i, null, null, true, false, 0, -1.0);
        }
        else
        {
            mShaders[i].mReady = false;
            previewShowError(mShaders[i].mPreview);
        }
    });
};


function iProcessShader( jsn, i )
{
    var shaderObj = jsn[i];
    if( shaderObj===null ) return;

    if ((shaderObj.info.usePreview === 0 && !gUseScreenshots) || (mShaders[i].mPreviewReady !== 1))
    {
        iLoadAndCompile(jsn, i);
    }
    else
    {
        mShaders[i].mScreenshot = true;
        if( shaderObj.info.usePreview === 1 )
            previewShowScreenshot(mShaders[i].mPreview, 1); // comp
        else if (gUseScreenshots)
            previewShowScreenshot(mShaders[i].mPreview, 2); // sett
    }

    if( i<(jsn.length-1) ) setTimeout( function(){iProcessShader(jsn,i+1);}, 10 );
}

function iInitUI(numCanvases, uiCallback, windowTitle)
{
    gNumCanvases = numCanvases;
    document.getElementById("mySearch").focus();

    //-----------------------------------------------------------------
    // window
    //-----------------------------------------------------------------
    if (windowTitle !== null) {
        document.title = windowTitle;
    }

    //-----------------------------------------------------------------
    // ui
    //-----------------------------------------------------------------
    var num = Math.min(gShaders.length, gNumCanvases);

    //var base = document.getElementsByClassName( "searchResult" );

    for (let i = 0; i < gNumCanvases; i++)
    {
        let pv = createPreview(i);

        if (i >= num) {
            previewHide(pv);
            continue;
        }

        let shaderID = gShaders[i].info.id;
        
        if (pv.mUI !== null && uiCallback !== null) {
            pv.mUI.addEventListener('click', function (ev) {
                uiCallback(shaderID);
                ev.preventDefault();
            }, false);
        }
        
        previewShowLoading(pv);
        
        mShaders[i] = {};
        mShaders[i].mShaderID = shaderID;
        mShaders[i].mPreview = pv;
        mShaders[i].mScreenshot = false;
        mShaders[i].mPreview.mLink.href = "/view/" + shaderID;
        mShaders[i].mPreviewReady = 0;
        mShaders[i].mReady = false;
        mShaders[i].gEffect = null;

        previewLoadScreenshot(mShaders[i].mPreview,
            function () { mShaders[i].mPreviewReady = 1; if (mShaders[i].mReady === false) previewShowScreenshot(mShaders[i].mPreview, 0); },
            function () { mShaders[i].mPreviewReady = 2; },
            shaderID);
    }

    if (num <= 0) {
        return;
    }
}

function iInitShaders(jsn)
{
    for (let i = 0; i < jsn.length; i++)
    {
        let shaderObj = jsn[i];
        if (shaderObj === null) continue;
        let inf = shaderObj.info;
        mShaders[i].mPreview.mTextA.textContent = inf.name;
        mShaders[i].mPreview.mTextB.innerHTML = "<a class='user' href='/user/" + htmlEntities(inf.username) + "'>" + htmlEntities(inf.username) + "</a>";
        mShaders[i].mPreview.mTextC.innerHTML = "<img src='/img/themes/" + gThemeName + "/views.png' class='viewsIcon'></img>" + inf.viewed + "    &nbsp;&nbsp;  <img src='/img/themes/" + gThemeName + "/likes.png' class='likesIcon'></img>" + inf.likes;
    }

    setTimeout(function () { iProcessShader(jsn, 0); }, 10);
}

function resultsInitStatic(numCanvases, uiCallback, windowTitle)
{
    iInitUI(numCanvases, uiCallback, windowTitle);

    iInitShaders(gShaders);
}

function resultsInit(numCanvases, uiCallback, windowTitle)
{	
    iInitUI(numCanvases, uiCallback, windowTitle);

    var num = Math.min(gShaderIDs.length, gNumCanvases);

    var mHttpReq = new XMLHttpRequest();

    mHttpReq.abort();

    var str = "{ \"shaders\" : [";
    for( let i=0; i<num; i++ )
    {
         str += "\"" + gShaderIDs[i] + "\"";
         if( i!==(num-1) ) str += ", ";
    }
    str += "] }";

    str = "s=" + encodeURIComponent( str ) + "&nt=0&nl=0&np=0";

    mHttpReq.open( "POST", "/shadertoy", true );
    mHttpReq.responseType = "json";
    mHttpReq.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    mHttpReq.onload = function ()
    {
        let jsn = this.response;
        if( jsn===null )
        {
            console.log( "Could not load shaders" );
            return;
        }

        iInitShaders(jsn);
    }
    mHttpReq.send( str );
}</script>
    <style>
    .shaderPreview
    {
    display: block;
    background-color: #000000;
    background-image: url("/img/loading.gif");
    background-repeat: no-repeat;
    background-position: center;
    padding: 0px;
    margin: 0px;
    border: 0px solid #000000;
    border-radius: 8px;
    width:100%;
    height:100%;
    position: absolute;
    overflow:hidden;
    }

    .previewInfo
    {
    width: 100%;
    left: 0px;
    top: 2px;
    position: relative;
    visibility: hidden;
    }

    .previewCanvas
    {
    left: 0px;
    top: 0px;
    padding: 0px;
    margin: 0px;
    position: absolute;
    cursor: pointer;
    width:100%;
    height:100%;
    border-radius: 8px;
    border: 0px solid #000000;
    backgroundColor: transparent;
visibility: hidden;
opacity:0;
transition: opacity 1.0s ease;
    }

    .previewText
    {
        text-overflow: ellipsis;
    white-space: nowrap;
    padding-right: 1px;
    }

    .previewTextUser
    {
    text-overflow: ellipsis;
    white-space: nowrap;
    padding-left: 3px;
    }

    .previewStats
    {
    padding-right: 1px;
    right: 0px;
    top: 0px;
    position: absolute;
    }

    .previewErrorContainer
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    visibility:hidden;
    }

    .previewErrorMessage
    {
    top:50%;
    position:absolute;
    width:100%;
    text-align:center;
    padding:0;
    margin:auto;
    color:#ff0000;
    font-size:2em;
    font-style:italic;
    }

    .previewNoGLContainter
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    position:absolute;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    pointer-events:none;
    visibility:hidden;
    font-size:2em;
    }

    .previewNoGLMessage
    {
    width:86%;
    height:90%;
    padding-left:7%;
    padding-right:7%;
    padding-top:10%;
    padding-bottom:0px;
    color:#ff0000;
    position:absolute;
    visibility:hidden;
    }

    .previewThumbnailContainer
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    visibility:hidden;
    border-radius:8px;
    border:0px solid #000000;
    }

    .previewThumbnailImage
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    border-radius:8px;
    border:0px solid #000000;
opacity: 0.0;
transition: opacity 1.0s ease;
    }

    .previewThumbnailIcon
    {
    width:64px;
    height:32px;
    left:0px;
    top:0px;
    padding:0px;
    padding-top:12px;
    margin:0px;
    position:absolute;
    color:#ffffff;
    background-color:#ff8020;
    font-weight:bold;
    border-radius:0px 0px 8px 0px;
    text-align:center;
    //visibility:hidden;
    }


    .previewUIContainter
    {
    display: block;
    right:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    //cursor:pointer;
    //pointer-events:none;
    //visibility:hidden;
    }
</style>

<script>
    function previewHide(me)
    {
    me.mBase.style.visibility = "hidden";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";
    }

    function previewShowRender(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "visible";
me.mCanvas.style.opacity = 1.0;
    me.mCanvas.style.borderRadius ="8px;";
//  me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    }

    function previewShowScreenshot(me, message)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "visible";
me.mThumbnailImg.style.opacity = 1.0;
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    me.mThumbnailWar1.style.visibility = (message===1)?"visible":"hidden";
    me.mThumbnailWar2.style.visibility = (message===2)?"visible":"hidden";
    }

    function previewShowLoading(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";

    me.mLink.style.visibility = "visible";
    me.mBase.style.backgroundColor = "#ff0000;"
    me.mCont.style.visibility = "visible";
    }

    function previewShowNoWebGL(me, shaderID)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "visible";
    me.mError.style.visibility = "visible";
    me.mThumbnailImgNoWebGL.onerror = function(ev) 
                                      { 
                                            me.mThumbnailImgNoWebGL.style.visibility="hidden"; 
                                            me.mMessageNoWebGL.style.visibility="visible"; 
                                      };
    me.mThumbnailImgNoWebGL.src = "/media/shaders/" + shaderID + ".jpg";
    }

    function previewShowError(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "visible";
    me.mCont.style.visibility = "visible";
    }

    function previewLoadScreenshot( me, cbSuccess, cbError, shaderID )
    {
    var url = "/media/shaders/" + shaderID + ".jpg";
    me.mThumbnailImg.onload = cbSuccess;
    me.mThumbnailImg.onerror = function(ev) { cbError(); };
    me.mThumbnailImg.src = url;
    }
        
    function createPreview(id)
    {
        var bar = document.getElementById( "Preview_"+id+"_Canvas" );
        bar.width = bar.offsetWidth;
        bar.height = bar.offsetHeight;
        bar.mId = id;

        return { mBase: document.getElementById( "Preview_"+id+"_Container" ),
        mLink: document.getElementById( "Preview_"+id+"_Link" ),
        mCanvas: bar,
        mCont: document.getElementById( "Preview_"+id+"_Info" ),
        mTextA: document.getElementById( "Preview_"+id+"_Text" ),
        mTextB: document.getElementById( "Preview_"+id+"_TextUser" ),
        mTextC: document.getElementById( "Preview_"+id+"_Stats" ),
        mNoWebGL: document.getElementById( "Preview_"+id+"_NoWebGL" ),
        mError: document.getElementById( "Preview_"+id+"_Error" ),
        mCanvas2D: document.getElementById( "Preview_"+id+"_Thumnail" ),
        mThumbnailImg: document.getElementById( "Preview_"+id+"_ThumnailImage" ),
        mThumbnailWar1: document.getElementById( "Preview_"+id+"_ThumnailWarning1" ),
        mThumbnailWar2: document.getElementById( "Preview_"+id+"_ThumnailWarning2" ),
        mThumbnailImgNoWebGL: document.getElementById( "Preview_"+id+"_ThumnailImageNoWebGL" ),
        mMessageNoWebGL: document.getElementById( "Preview_"+id+"_MessageNoWebGL"),
        mUI: document.getElementById( "Preview_"+id+"_UI" )
        };
    }
</script>

    <style>

    div#shaderGrid
    {
        width:100%;
        padding:0px;
        margin:0px;
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        grid-template-rows: repeat(3, 1fr);
        grid-column-gap: 64px;
        grid-row-gap: 24px;
    }
    .searchResult
    {
        margin: 0px;
        padding: 0px;
        width: 100%;
    }
    .searchResultContainer
    {
        width: 100%;
        padding-bottom:56.25%;
        height: 0;
        position: relative;
    }
    .navigation
    {
        display:flex;
        align-items:center;
    }
    div#navBottom
    {
        display:none;
        justify-content:center;
    }
    a.pageButtons, .pageButtonsCurrent
    {
        border-style: solid;
        border-width: 1px;
        border-color: #808080;
        text-align: center;
        vertical-align: middle;
        margin-left: 12px;
        display: inline-block;
        border-radius: 4px;
		font-weight:bold;
        cursor: pointer;
        padding-bottom:5px;
        padding-top:4px;
        padding-left: 8px;
        padding-right: 8px;
        margin:8px;
    }
    a.pageButtons
    {
        text-decoration: none;
        -moz-transition:    background-color 0.15s linear, color 0.15s linear;
        -webkit-transition: background-color 0.15s linear, color 0.15s linear;
        transition:         background-color 0.15s linear, color 0.15s linear;
    }
    a.pageButtons:hover
    {
      background-color:#808080;
      color : #ff8020;
    }
    .pageButtonsCurrent
    {
        background-color: #808080;
        color:#000000;
    }
    div#controls
    {
        width:100%;
        padding-top:16px;
        padding-bottom:16px;
        display:flex;
        justify-content:space-between; 
        flex-wrap:wrap;
    }
    div#controls > div
    {
        display:inline-flex;
    }
    .controlOptions
    {
        display:inline-block;
    }

    /* ----------------------- media resolutions ------------------------ */

    @media screen and (max-width:799px) 
    {
        div#shaderGrid  { grid-template-columns: 1fr; grid-template-rows: repeat(12, 1fr); grid-column-gap: 0px; grid-row-gap: 16px; }
        div#controls
        {
            width:100%;
            display:flex;
            justify-content:flex-start; 
            flex-wrap:wrap;
        }
        div#controls > div
        {
            display:inline-flex;
            width:100%;
            margin-left: 0px;
            margin-right: 0px;
            padding-bottom:16px;
        }
        div#navBottom
        {
            display: flex;
        }
    }
    
    </style>
    <script>
    var gShaders=[{"ver":"0.1","info":{"id":"ssBGRG","date":"1617556526","viewed":13042,"name":"Red Crash - Procedural GFX","username":"NuSan","description":"Procural image made for Revision 2021 4k Excutable Graphics competition","likes":190,"published":1,"flags":32,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/*\nProcural image made for Revision 2021 4k Excutable Graphics competition\n\nReleased executable can be found here: https:\/\/demozoo.org\/graphics\/292427\/\n*\/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t       \n    vec2 res = iResolution.xy;\n\tvec2 frag = fragCoord.xy;\n\tvec2 uv = frag\/res.xy;\n\t\n\tvec4 value=texture(iChannel0,uv);\n    \n    \n    vec3 col=value.xyz\/value.w;\n    \n    \/\/ basic \"tonemapping\"\n    col = smoothstep(0.,1.,col);\n    col = pow(col, vec3(0.4545));\n    \n\tfragColor = vec4(col, 1);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/*\nProcural image made for Revision 2021 4k Excutable Graphics competition\n\nReleased executable can be found here: https:\/\/demozoo.org\/graphics\/292427\/\n*\/\n\nfloat time;\n\n\/\/DAVE HOSKINS' HASH FUNCTIONS\n\/\/https:\/\/www.shadertoy.com\/view\/4djSRW\nfloat rnd11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    return fract(2.*p*p);\n}\n\nvec3 rnd23(vec2 p)\n{\n\tvec3 p3 = fract(p.xyx * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat rnd31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 rnd33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nfloat rnd21(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\/\/ noise functions\n\nfloat srnd21(vec2 p)\n{\n    vec2 ip=floor(p);\n    p=fract(p);\n    p=smoothstep(0.,1.,p);\n    \n    float p1 = mix(rnd21(ip),rnd21(ip+vec2(1,0)),p.x);\n    float p2 = mix(rnd21(ip+vec2(0,1)),rnd21(ip+vec2(1,1)),p.x);\n    \n    return mix(p1,p2,p.y);\n}\n\nfloat noise21(vec2 p, float pro, float st) {\n    float v=0.0;\n    float s=0.5;\n    for(float i=0.; i<st; ++i) {\n        v+=srnd21(p+i*72.3)*s;\n        p*=pro;\n        s*=0.5;\n    }\n    return v;\n}\n\nfloat srnd31(vec3 p7)\n{\n    vec3 ip=floor(p7);\n\t\n    p7=fract(p7);\n    \/\/p7=smoothstep(0.,1.,p7);\n    \n    float p1 = mix(rnd31(ip),rnd31(ip+vec3(1,0,0)),p7.x);\n    float p2 = mix(rnd31(ip+vec3(0,1,0)),rnd31(ip+vec3(1,1,0)),p7.x);\n    float p3 = mix(rnd31(ip+vec3(0,0,1)),rnd31(ip+vec3(1,0,1)),p7.x);\n    float p4 = mix(rnd31(ip+vec3(0,1,1)),rnd31(ip+vec3(1,1,1)),p7.x);\n    \n    return mix(mix(p1,p2,p7.y),mix(p3,p4,p7.y),p7.z);\n}\n\nfloat noise31(vec3 p8, float pro, float st) {\n    float v=0.0;\n    float s3=0.5;\n    for(float g=min(0.,float(iFrame)); g<st; ++g) {\n        v+=srnd31(p8+g*72.3)*s3;\n        p8*=pro;\n        s3*=0.5;\n    }\n    return v;\n}\n\n\/\/ useful functions\n\nfloat c01(float a) {return clamp(a,0.,1.);}\n\nfloat smin(float a, float b, float h) {\n\tfloat k=c01((a-b)\/h*.5+.5);\n\treturn mix(a,b,k)-k*(1.-k)*h;\n}\n\nfloat pi=acos(-1.);\nmat2 rot(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\n\/\/ sdf functions\n\nfloat box(vec3 p, vec3 s) {\n    p=abs(p)-s;\n    return max(p.x, max(p.y,p.z));\n\t\/\/return length(max(p,vec3(0))) + min(0.,max(p.x,max(p.y,p.z)));\n}\n\n\/\/ hexagonal shape with specified size\nfloat hex(vec3 p, vec3 s) {\n  vec3 ap=abs(p);\n  float prof=max(ap.x-s.x,(ap.x+ap.z)*.7-s.z);\n  return max(ap.y+max(-1.,prof)-s.y,prof);\n}\n\n\/\/ sdf to randomly moved boxes in a grid of size re\nfloat gribble(vec3 p, vec3 re) {\n  vec3 r1=(fract(p\/re+.5)-.5)*re;\n  return box(r1+rnd33(floor(p\/4.+.5))*2.-1.,re*.4)*.7;\n}\n\n\/\/ vessel distance function\nfloat vessel(vec3 p) {\n  \n  p.x=abs(p.x);\n  \/\/ main frame\n  float d = box(p, vec3(8,5,30));\n  \n  \/\/ top 3 layers\n  float u = min(hex(p-vec3(0,0,15),vec3(6,7,20)),min(hex(p-vec3(0,0,24),vec3(4,9,12)),hex(p-vec3(0,0,28),vec3(2,11,8))));\n  u=max(u, (u+p.y+p.z*.3)*.7-5.);\n  d=min(d, u);\n  \n  \/\/ box random details\n  float g1=gribble(p, vec3(4,4,10));\n  float g2=gribble(p+3., vec3(7,3,8));\n  \n  d=min(d,max(d-0.4,g1));\n  d=min(d,max(d-0.3,g2));\n  \n  \/\/ reactors\n  vec3 p2=p-vec3(0,2,0);\n  p2.x=abs(p2.x)-5.;\n  d=min(d, max(abs(p.z-38.)-8.,abs(length(p2.xy)-3.-sin(p.z*.3+.9))-.3)-g1*.2);\n  \n  \/\/ wings\n  vec3 p3=p;\n  p3.xy*=rot(.3);\n  vec3 ap=abs(p3-vec3(0,0,22));\n  float l=max(p3.z-26.,max(abs(p3.y-1.)-.3,(ap.x*.7+ap.z*.3)-14.))-g2*.2;\n  d=min(d, l);\n  \n  return d*.8;\n}\n\n\/\/ all global values I will need later\nfloat vesd=0.; \/\/ distance to vessel\nvec3 vesp=vec3(0); \/\/ local position of pixel in vessel space\nfloat smoke2=1.; \/\/ smoke opacity\nfloat lsmo=0.; \/\/ last smoke distance (to darken vessel around smoke)\nvec3 smp=vec3(0); \/\/ smoke pixel position\nfloat humd=0.; \/\/ distance to the character\nfloat map(vec3 p){\n    float d=10000.0;\n\n\t\/\/ ground distance\n\tvec2 uv1 = p.xz;\n\tfloat lh=noise21(uv1*0.02,2.,5.);\n    \/\/ main ground shape\n\tfloat h=pow(lh,3.) * (25.-60.*c01((length(p)-400.)\/100.));\n    \/\/ turn ground into stratified layers\n\th=(floor(h)+smoothstep(0.,1.,fract(h)))*2.;\n    \/\/ rock detail shapes\n\th+=pow(noise31(p*vec3(1,8,1),lh*5.+1.,3.),2.) * 3.;\n    \/\/ sand part\n\th=smin(h, lh+7.+h*.05,5.);\n\t\n    \/\/ vessel location\n\tvesp=p.zyx+vec3(100,0,100);\n\t\n\t\/\/ foot path\n\tvec2 uv3 = vesp.xz-vec2(10,0);\n\tuv3*=rot(sin(vesp.x*.251)*.1);\n\tfloat mark=smoothstep(0.,1.,sin(uv3.x*4.+sign(uv3.y)*2.));\n\tfloat path=c01(.3-abs(abs(uv3.y)-.4)*2.+mark*.3)*(mark*.3+.5)*smoothstep(12.1,12.,abs(uv3.x-28.));\n\th+=min(.1,path);\n\n    \/\/ final ground sdf\n\tfloat g=-p.y + h;\n\td=min(d, g*.9);\n\t\n\t\/\/ vessel sdf\n\tvesp.yz*=rot(.6);\n\tvesp.xz*=rot(.2);\n\tvesd=vessel(vesp);\n\td=min(d, vesd);\n\n\t\/\/ character sdf\n\tvec3 p4a=(p+vec3(100.1,-6.5,50.3))-vec3(0,2.5-2.5-.1,0);\n\tvec3 p4=p4a;\n\tvec3 p5=p4;\n\tvec3 p6=p4;\n\tp5.z=abs(p5.z)+.1;\n\tp5.x+=sin(p4a.y*3.)*.2+.1;\n\tp5.zy*=rot(-.25);\n    \/\/ head\n\tfloat m=length(p4)-.2;\n    \/\/ body\n\tp4.x+=sin(p4a.y*6.+3.)*.05+.1;\n\tp4.y=abs(p4.y-.75)-.2;\n\tp4.y=abs(p4.y)-.1;\n\tm=smin(m, length(p4)-.25,.18);\n\tm=smin(m, max(1.-p5.y,length(p5.xz)-.1),.1);\n\tm=min(m, .7*max(1.-p5.y,length(p5.xz)-.1+sin(p4a.y*12.)*.05));\n\tp5.z-=.3;\n\tp5.x-=.1;\n\tm=smin(m, max(abs(-p5.y+.9)-.5,length(p5.xz)-.1),.2);\n\tm=smin(m, max(abs(-p4.y+.1)-.1,length(p5.xz)-.13),.1);\n\tp6.x+=.3;\n\tp6.z=abs(p6.z)-.1;\n\tm=min(m, max(abs(-p6.y+.65)-.4,length(p6.xz)-.4+.7*max(.3,abs(-p6.y+.65)))*.7);\n\thumd=m;\n\td=min(d,m);\n\t\n\t\/\/ smoke sdf\n\tvec3 p3 = p+vec3(110,0,94);\n\tp3.x+=p3.y*.3;\n\tp3.xz=abs(p3.xz*rot(p3.y*.07+sin(p3.y*.5)*.3))-5.;\n\tfloat smoke=length(p3.xz)+1.-p3.y*.05;\n\tlsmo=smoke;\n\tsmp=mix(p,smp,c01(smoke-5.));\n\tsmoke2*=c01(.4+(smoke)*.1);\n\t\n\td=min(d, smoke);\n    \n    return d;\n}\n\n\nfloat dither=1.;\n\nfloat shadow(vec3 p, vec3 l) {\n    float shad=1.0;    \n    float dd=0.;\n    for(int i=0;i<50; ++i) {\n        float d=map(p);\n        shad=min(shad,(abs(d)-.01)*100.);\n        if(d<0.01) {\n            shad=0.0;\n            break;\n        }\n        if(dd>20.) break;\n        p+=l*d;\n        dd+=d;\n    }\n    return shad;\n}\n\n\/\/ main lighting direction\nvec3 l = normalize(vec3(7,-2,0));\n\nvec3 sky(vec3 r, float dd, int it) {\n\tvec2 uvs=vec2(atan(r.z,r.x),r.y);\n    \/\/ \"clouds\"\n\tfloat n=noise21(uvs*vec2(7,50),3.7,3.);\n\tfloat n2=noise21(uvs*vec2(7,50)+vec2(.3,-.1),3.7,3.);\n\tfloat push=dd>900.?smoothstep(0.0,0.3,n2-n):0.;\n    \/\/ sky color\n\tvec3 sk=mix(vec3(.7,.5,.3)*(.9+.5*push),vec3(.4,0.3,0.2),dd>900.?c01((n-.3)*5.*(-r.y*10.)+5.*c01((-.1-abs(r.y))*2.)):.5);\n    \/\/ dark to see the sky\n\tsk=mix(sk*pow(vec3(cos(max(-5.5,r.y*9.))*.5+.5),vec3(2.,3.,2.3))*2.,vec3(0),c01(r.y));\n\n\t\/\/ sun halo\n\tvec3 l2 = normalize(vec3(7,-0.9,0)); \/\/ fake sun for composition\n\tsk+=pow(max(0.,dot(r,l2)),60.)*vec3(1,0.5,0.3)*1.2;\n\tsk+=smoothstep(0.9996,0.9998,dot(r,l2))*vec3(1,0.5,0.3);\n\n\t\/\/ far sky details\n\tif(dd>900.) {\n\t\tvec2 suv=uvs*3.;\n\t\tfloat nn = smoothstep(0.2,0.7,noise21(suv*vec2(5,20), 2., 3.));\n        \/\/ star belt\n\t\tnn += .07\/(.01+abs(suv.y+suv.x*.2+1.));\n  \n        \/\/ stars\n\t\tfor(float i=0.;i<3.;++i) {\n\t\t\tsuv*=rot(.7);\n\t\t\tfloat grid=70.+i*10.;\n\t\t\tvec3 starid=rnd23(floor(suv*grid));\n\t\t\tvec2 staruv=fract(suv*grid)-.5;\n\t\t\tfloat stard=length(staruv+(starid.xy-.5)*.5);\n\t\t\tfloat starsmo=i*.07+.01;\n\t\t\tsk += .8*nn*pow(rnd11(starid.z),10.)*(.7+.3*max(sin(vec3(.8,1.7,.9)*3.*starid.z+i*10.),0.)) * smoothstep(.4,0.,stard)*starsmo\/(starsmo+stard);\n\t\t}\n\t\tsk += nn*.01; \/\/ dust\n  \n        \/\/ meteroids\n\t\tvec2 muv=suv+vec2(.2+.2,-.3-.7);\n\t\tmuv*=rot(2.3)*1.3;\n\t\tfor(float i=0.;i<30.;++i) {\n\t\t\tfloat pp=-.1-sin(i*.7)*.3;\n\t\t\tmuv*=rot(sin(pp)*.3);\n\t\t\tfloat pro=cos(pp*7.);\n            \/\/ trail\n\t\t\tsk += vec3(1,.5,.3)*0.002*c01(1.-abs(.5+muv.y+pro*.15)*3.)\/(0.001+abs(muv.x));\n            \/\/ meteroids\n\t\t\tif(length((.007*sin(suv*41.)+muv+vec2(0,0.2*pro+.7))*vec2(2,1))<.015) sk=vec3(0.2+smoothstep(0.,0.3,-muv.x*20.)*.7+sin(muv.y*170.)*sin(muv.x*170.)*.1);\n\t\t}\n\t}\n\t\n\treturn sk;\n}\n\n\/\/ suggested from tdhooper. Thanks!\n\/\/ improve compilation time & overall fps.\nconst int NORMAL_STEPS = 6;\nvec3 getnormal(vec3 pos) {\n\n    vec3 eps = vec3(.001, 0, 0);\n\t\n\tvec3 nor = vec3(0);\n\tfloat invert = 1.;\n\tfor (int i = 0; i < NORMAL_STEPS; i++) {\n\t\tnor += map(pos + eps * invert) * eps * invert;\n\t\teps = eps.zxy;\n\t\tinvert *= -1.;\n\t}\n\treturn normalize(nor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t         \n\n\ttime = float(iFrame);\n    \n    vec2 frag = fragCoord.xy;\n\tvec2 uv = (frag-iResolution.xy*0.5)\/iResolution.y;\n    \n    vec4 finalcolor = vec4(0);\n    if(iFrame>0) {\n        finalcolor += texture(iChannel0, fragCoord\/iResolution.xy);\n    }\n    \n    \/\/ verify if middle mouse clicked or if resolution changed\n    if(iMouse.z > .5 || texelFetch(iChannel0, ivec2(0),0).y != iResolution.y) {\n        finalcolor=vec4(0);\n    }\n\t\n    \/\/ separate rendering by tiles so browser doesn't freeze computer\n    int tilecount = 20;\n    int curtile = int(frag.y*float(tilecount)\/iResolution.y);\n    \n    if(iFrame%tilecount == curtile) {\n        \n        \/\/ random jitter on uv to get antialiasing\n        vec2 uv = (frag-iResolution.xy*0.5+1.5*rnd23(frag+time).xy)\/iResolution.y;\n\n        vec3 finalp=vec3(0);\n        vec3 finals=vec3(0);\n        vec3 finaln=vec3(0,1,0);\n\n        \/\/ raymarching dither to avoid any banding\n        dither = .9+.1*rnd21(frag+time*.7);\n\n        \/\/ camera position\n        vec3 s=5.*vec3(-28.635,-1.601,-4.168);\n        vec2 camr=vec2(8.455,.152);\n\n        vec3 cz=normalize(vec3(sin(camr.x)*cos(camr.y), sin(camr.y), cos(camr.x)*cos(camr.y)));\n        vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n        vec3 cy=cross(cz,cx);\n\n        float fov = 1.0;\n\n        float motime = time;\n\n        vec2 h = rnd23(frag-13.6+motime*37.7).xy * vec2(1.,6.283);\n        vec3 voff = sqrt(h.x)*(cx*sin(h.y)+cy*cos(h.y))*.3\/iResolution.y;\n        \/\/ persp\n        vec3 r=normalize(uv.x*cx+uv.y*cy+fov*cz + voff*fov);\n        finals=s;\n\n        vec3 col=vec3(0);\n        \n        vec3 bs = s;\n        vec3 alpha=vec3(1.0);\n        int bounce=4;\n        int ZERO = min(0,iFrame);\n        for(int j=ZERO; j<bounce; ++j) {\n        \n            smp=vec3(0);\n\n            for(int i=0; i<100; ++i) {\n                float d=map(s);\n                if(d<0.001) break;\n                if(d>1000.0) break;\n                s+=r*d*dither;\n            }\n\n            float vesd2=vesd;\n            vec3 vesp2=vesp;\n            float humd2=humd;\n\n            \/\/ smoke darkening and color\n            float smn=noise31(smp,4.,3.);\n            col += alpha * smoothstep(0.3,0.,smoke2)*(vec3(.3,.2,.1)*smoothstep(.4,.6,smn)+vec3(1,0.2,0.1)*smoothstep(0.3,1.,smn))*4.;\n            alpha*=pow(smoke2,2.);\n            alpha*=smoothstep(0.,1.,lsmo-7.)*.5+.5;\n\n            \/\/ surface normal\n            vec3 n=getnormal(s);\n            \n            \/\/ are we far enough\n            float dd=length(s-finals);\n            if(dd>1000.) {\n                col += sky(r,dd,j)*alpha;\n                \/\/ early out\n                break;\n            } else {\n\n                \/\/ fresnel\n                float fre=pow(max(0.,1.-abs(dot(r,n))),1.0);\n\n                vec3 val=vec3(0);\n\n                \/\/ shadow\n                float shad = shadow(s+n*0.1+l*0.1,l);\n                \/\/ mix ground diffuse colors\n                vec3 sand=mix(vec3(.9,.65,.4),vec3(0.3,.2,.1),c01(s.y-8.));\n                vec3 rock=mix(vec3(.3,0.1,0.1)*0.,vec3(.8,.7,.6),c01((abs(n.x)-.1)*10.));\n                vec3 diff=mix(rock,sand,c01(s.y-7.));\n                if(vesd2<.1) {\n                    \/\/ vessel color\n                    diff=vec3(1);\n                    if(vesp2.z<35. && abs(vesp2.x)<8.6 ) {\n                        if(rnd11(floor(vesp2.y+17.01))<.5) {\n                            \/\/ blue bands\n                            diff=vec3(0.4,.6,1);\n                        }\n                    }\n                    \/\/ darken also the reflection\n                    alpha*= diff;\n                }\n                if(humd2<.01) {\n                    \/\/ character color\n                    diff=vec3(1);\n                    alpha*=pow(fre,.5);\n                }\n\n                \/\/ apply direct lighting\n                val += shad * max(0.,dot(n,l)) * diff;\n\n                val=max(val,0.);\n                \n                \/\/ blend fog color\n                float blend=pow(c01((dd-100.)\/900.),.6);\n                val = mix(val, sky(r,dd,j), blend);\n\n                col += val*alpha;\n\n                float rough = .5;\n                if(vesd2<.1) {\n                    \/\/ vessel roughness\n                    rough=vesp2.z>32.?0.:rnd31(floor(vesp2*vec3(3,.1,.1)-.72)*.3+.7);\n                }\n\n                \/\/ bounce in a random direction around reflection vector, depending on roughness\n                r=normalize(reflect(r,n) + normalize(rnd23(frag+vec2(0,j*375)+time*1.3)-.5)*rough);\n\n                alpha *= 0.7*(1.-blend);\n                s+=n*0.005;\n            }\n            \n            \/\/ tricks by iq to disable unrolling and have faster compilation times\n            if( col.x<-100.0 ) break;\n        }\n\n        finalcolor += vec4(col, 1);\n    }\n    \n    \/\/ store last rendered resolution\n    if(ivec2(fragCoord)==ivec2(0)) {\n        finalcolor=iResolution.xyxy;\n    }\n    \n    fragColor = finalcolor;\n}\n","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"XdBSD3","date":"1416287460","viewed":13017,"name":"Useless Box","username":"movAX13h","description":"Alien examining human technology; Mouse enabled; SFX by srtuss.","likes":38,"published":3,"flags":8,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"\/media\/a\/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"\/media\/ap\/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\/\/ Useless Box, fragment shader by movAX13h, Nov. 2014\n\n#define ALIENHAND\n#define LID\n#define FLOOR\n\/\/#define FLOOR2\n#define SWITCH\n#define THING\n\n#define SHADOW\n#define REFLECTION\n\n\/\/ --\n#define resolution iResolution\n#define mouse iMouse\n\n#define pi2 6.2831853071795\n#define pih 1.5707963267949\n\n\nfloat rand(float x)\n{\n    return fract(sin(x) * 4358.5453123);\n}\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5357);\n}\n\nfloat rand(vec3 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5357 * co.z);\n}\n\nfloat sdBox( vec3 p, vec3 b ) \n{\t\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat udRoundBox(vec3 p, vec3 b, float r)\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdSegment(vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\t\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n\treturn length(p)-r;\n}\n\nfloat sdCappedCylinderZ( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xy),p.z)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCappedCylinderY(vec3 p, vec2 h)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus(vec3 p, vec2 t)\n{\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\n\nvec2 rotate(vec2 p, float a, vec2 offset)\n{\n    p += offset;\n\tvec2 r;\n\tr.x = p.x*cos(a) - p.y*sin(a);\n\tr.y = p.x*sin(a) + p.y*cos(a);\n    r -= offset;\n\treturn r;\n}\n\nfloat opS(float d1, float d2)\n{\n    return max(-d1,d2);\n}\n\nfloat opI(float d1, float d2)\n{\n    return max(d1,d2);\n}\n\n\/\/ polynomial smooth min (k = 0.1); by iq\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5+0.5*(b-a)\/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat time;\nvec3 sunPos;\nvec3 sun;\nfloat focus;\nfloat far;\n\nstruct Hit\n{\n\tfloat d;\n\tvec3 color;\n\tfloat ref;\n\tfloat spec;\n};\n\n#define fingerStart(a,b,c) from=vec3(a, b, c)\n#define seg(t,r) d=smin(d,sdSegment(p, from, t, r), 0.06); from=t\n#define seg2(t,r,s) d=smin(d,sdSegment(p, from, t, r), s); from=t\nfloat alienHand(vec3 p, float cycle)\n{\n    p.x -= 0.2*cycle;\n    p.xy = rotate(p.xy, -0.5+cycle*0.2, vec2(0.0));\n\tp.z *= 0.8;\n    p.y += 0.01*sin(time);\n    \n    float a1 = sin(3.6*time);\n    float a2 = sin(0.7*time+1.333)*a1;\n    \n    float a1s = 0.02*a1;\n    float a2s = 0.05*a2;\n    \n\tvec3 from, to;\n\tfloat d = 1.0e6;\n\t\n\t\/\/ ringfinger\n\tfingerStart(0.4+0.7*a2s, -0.65+a1s, -0.1);\n\tseg(vec3(0.6, -0.35+a1s, -0.1), 0.06);\n\tseg(vec3(1.1, -0.1, -0.1), 0.065);\n\tseg(vec3(2.0, -0.24, -0.07), 0.08);\n\t\n\t\/\/ pinky\n\tfingerStart(0.75+a2s, -0.95+a1s, -0.2);\n\tseg(vec3(0.85, -0.5+a1s, -0.21), 0.05);\n\tseg(vec3(1.18, -0.23, -0.18), 0.06);\n\tseg(vec3(2.0, -0.24, -0.09), 0.07);\n\t\n\t\/\/ thumb\n\tfingerStart(1.0, -0.5, 0.26);\n\tseg(vec3(1.3, -0.2, 0.27), 0.07);\n\tseg(vec3(1.65, -0.2, 0.18), 0.08);\n\tseg(vec3(2.0, -0.2, 0.1), 0.09);\n\t\n\t\/\/ arm\n\tfrom = vec3(1.6, -0.2, 0.0);\n\tseg2(vec3(4.0, -1.2, 0.0), 0.08, 0.3);\n\tseg(vec3(2.0, -0.3, 0.05), 0.14);\n\n\t\/\/ pointer\n\tfingerStart(0.0, 0.5*a1s, 0.0);\n\tseg(vec3(0.5, 0.08+0.3*a1s, 0.02), 0.06);\n\tseg(vec3(1.1, -0.03+abs(0.2*a1s), 0.04), 0.07);\n\tseg(vec3(2.0, -0.2, 0.06), 0.07);\n    \n\treturn d;\n}    \n    \nHit scene(vec3 p)\n{\n    \/\/p.xz = mod(p.xz, 3.0)-1.5;\n    \n\tvec3 q = p;\n    float t = 1.5*time;\n\tfloat cycle = max(0.0, sin(t)-0.3);\n    \n\tHit h = Hit(1.0e6, vec3(0.0,0.1,0.3), 0.1, 0.2);\n\n\t\/\/ box\n\tfloat a = opS(sdBox(p, vec3(0.5, 0.3, 0.14)), sdBox(p, vec3(1.0, 0.5, 0.75)));\n\tfloat b = sdBox(p-vec3(-0.8, 0.54, 0.0), vec3(0.8, 0.4, 0.8));\n\th.d = opS(b, a);\n\n\t\/\/ lid\n\t#ifdef LID\n\tq = p;\n\tq.xy = rotate(q.xy, -max(0.004, 0.2*smoothstep(0.0, 0.3, cycle)), vec2(1.0, -0.11));\n\t\n\ta = sdBox(q-vec3(-0.501, 0.32, 0.0), vec3(0.5, 0.18, 0.75));\n\tb = sdBox(q-vec3(-0.401, 0.26, 0.0), vec3(0.46, 0.2, 0.71));\n\th.d = min(h.d, opS(b, a));\n\t#endif\n\t\n\t\/\/ thing\n    #ifdef THING\n\tq = p;\n\tq.xy = rotate(q.xy, -abs(1.26*smoothstep(0.3, 0.5, 1.0-cycle)), vec2(-0.1, -0.2));\n\t\n\ta = opS(sdCappedCylinderZ(q-vec3(0.1, 0.18, 0.0), vec2(0.4, 0.2)), sdCappedCylinderZ(q-vec3(0.1, 0.18, 0.0), vec2(0.5, 0.08)));\n\tb = sdBox(q-vec3(0.7, 0.36, 0.0), vec3(0.5));\n\th.d = min(h.d, opS(b, a));\n\t#endif\n    \n\t\/\/ switch\n    #ifdef SWITCH\n\tb = sdSegment(p, vec3(0.24, 0.5, 0.0), vec3(0.18+0.14*step(-0.6, sin(t-1.99)), 0.7, 0.0), 0.03);\n\tb = min(b, sdCappedCylinderY(p-vec3(0.24, 0.42, 0.0), vec2(0.1, 0.1)));\n    b = min(b, sdTorus(p-vec3(0.24, 0.525, 0.0), vec2(0.05, 0.018)));\n\t\n\tif (b < h.d) \n\t{\n\t\th.d = b;\n\t\th.color = vec3(0.1);\n\t\th.spec = 0.7;\n\t\th.ref = 0.3;\n\t}\n\t#endif\n    \n    #ifdef ALIENHAND\n    a = alienHand(p-vec3(0.4, 0.71, 0.0), smoothstep(1.0, 0.8, sin(t-4.2)));\n    if (a < h.d)\n    {\n        h.d = a;\n        h.color = vec3(0.4);\n        h.spec = 0.0;\n        h.ref = 0.0;\n    }\n    #endif\n    \n    #ifdef FLOOR\n    \n    #ifdef FLOOR2\n    a = dot(p,vec3(0.0, 1.0, 0.0)) + 0.5;\n    #else\n    a = sdBox(p-vec3(0.0, -0.5, 0.0), vec3(2.0, 0.01, 2.0));\n    #endif\n    if (a < h.d)\n    {\n        h.d = a;\n        #ifdef FLOOR2\n        h.color = vec3(0.5*mod(sin(p.z)-sin(p.x), 0.4)+0.5);\n\t\t\/\/h.color = vec3(0.3+0.5*mod(p.z, 0.4));\n        #else\n        h.color = vec3(0.8);\n\t\t#endif\n        h.spec = 0.2;\n        h.ref = 0.2;\n    }\n    #endif\n    \n\treturn h;\n}\n\nvec3 normal(vec3 p)\n{\n\tfloat c = scene(p).d;\n\tvec2 h = vec2(0.01, 0.0);\n\treturn normalize(vec3(scene(p + h.xyy).d - c, \n\t\t\t\t\t\t  scene(p + h.yxy).d - c, \n\t\t                  scene(p + h.yyx).d - c));\n}\n\n\nvec3 colorize(const vec3 col, const float spec, const vec3 n, const vec3 dir, const in vec3 lightPos)\n{\n\tfloat diffuse = 0.2*max(0.0, dot(n, lightPos));\n\tvec3 ref = normalize(reflect(dir, n));\n\tfloat specular = spec*pow(max(0.0, dot(ref, lightPos)), 3.5);\n\treturn (col + diffuse * vec3(0.9) +\tspecular * vec3(1.0));\n}\n\nvec3 tex3D(vec3 dir)\n{\n    return texture(iChannel0, dir).bgr;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\ttime = iTime + 7.0;\n\tsunPos = vec3(10.0, 15.0, -10.0);\n\tsun = normalize(sunPos);\n\tfocus = 9.0+2.0*cos(0.35*time);\n\tfar = 30.0;    \n    \n    vec2 pos = (fragCoord.xy*2.0 - resolution.xy) \/ resolution.y;\n\t\n\tfloat d = 9.0;\n\tfloat t = 1.2*sin(time*0.1+35.0) ;\n\tvec3 cp = vec3(d*cos(t), 6.0+sin(0.2*time), d*sin(t)); \/\/ circle center\n    \n\tif (mouse.x > 10.0)\n\t{\n\t\tvec2 mrel = 3.0*(mouse.xy\/resolution.xy-0.5);\n\t\td = 10.0;\n        focus = 9.0 + 4.0*mrel.y;\n\t\tcp = vec3(d*cos(-mrel.x*pih), 6.0, d*sin(-mrel.x*pih));\n\t}\n\t\n    vec3 ct = vec3(0.0, 0.1, 0.0);\n   \tvec3 cd = normalize(ct-cp);\n    vec3 cu  = vec3(0.0, 1.0, 0.0);\n    vec3 cs = cross(cd, cu);\n    vec3 dir = normalize(cs*pos.x + cu*pos.y + cd*focus);\t\n\t\n    Hit h;\n\tvec3 col = vec3(0.16);\n\tvec3 ray = cp;\n\tfloat dist = 0.0;\n\t\n\t\/\/ raymarch scene\n    for(int i=0; i < 60; i++) \n\t{\n        h = scene(ray);\n\t\t\n\t\tif(h.d < 0.0001) break;\n\t\t\n\t\tdist += h.d;\n\t\tray += dir * h.d * 0.8;\n\n        if(dist > far) \n\t\t{ \n\t\t\tdist = far; \n\t\t\tbreak; \n\t\t}\n    }\n\n\tfloat m = (1.0 - dist\/far);\n\tvec3 n = normal(ray);\n\tcol = colorize(h.color, h.spec, n, dir, sun)*m;\n\n\tif (dist < far)\n\t{\t\n\t\t\/\/ MIRROR (from obj to reflected normal direction)\n\t\t#ifdef REFLECTION\n\t\tHit h2;\n\t\tdir = reflect(dir, n);\n\t\tvec3 neb = tex3D(dir);\n\t\t\n\t\tvec3 ray2 = ray + dir*0.008;\n\n\t\tdist = 0.0;\n\t\t\n\t\tfor(int i=0; i < 35; i++) \n\t\t{\n\t\t\th2 = scene(ray2 + dir*dist);\n\t\t\tdist += h2.d;\n\t\t\tif (h2.d < 0.001) break;\n\t\t}\n\n\t\tif (dist > far) col += h.ref*neb;\n\t\telse col += h.ref*colorize(h2.color, h2.spec, normal(ray2+dir*dist), dir, sun)*(1.0 - dist\/far);\n\t\t#endif\t\n\t\t\n\t\t\/\/ HARD SHADOW with low number of rm iterations (from obj to sun)\n\t\t#ifdef SHADOW\n\t\tvec3 ray1 = ray;\n\t\tdir = normalize(sunPos - ray1);\n\t\tray1 += n*0.006;\n\t\t\n\t\tfloat sunDist = length(sunPos-ray1);\n\t\tdist = 0.0;\n\t\t\n\t\tfor(int i=0; i < 35; i++) \n\t\t{\n\t\t\th = scene(ray1 + dir*dist);\n\t\t\tdist += h.d;\n\t\t\tif (abs(h.d) < 0.001) break;\n\t\t}\n\n\t\tcol -= 0.2*smoothstep(0.5, -0.3, min(dist, sunDist)\/max(0.0001,sunDist));\n\t\t#endif\n\t}\n\telse col = tex3D(dir);\n    \n\tcol = clamp(col, vec3(0.0), vec3(1.0));\n\tcol = pow(col, vec3(2.2, 2.4, 2.5)) * 3.7; \/\/ farbton & s\u00c3\u00a4ttigung\n\tcol = pow(col, vec3(1.0 \/ 2.2)); \/\/ gamma\t\n\t\n\tfragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\/\/ Sound FX by srtuss\n\nfloat hash(float x)\n{\n    return (fract(cos(x * 115.5782) * 1000.0 + sin(x * 0.5782) * 333.333) - 0.5) * 1.0;\n}\n\nfloat nse(float t)\n{\n    float fl = floor(t);\n    return mix(hash(fl), hash(fl + 1.0), smoothstep(0.0, 1.0, fract(t)));\n}\n\nfloat f1(float t, float ts, float tl, float k)\n{\n\tfloat o1 = clamp(t - ts, 0.0, tl);\n\tfloat o2 = max(t - (ts + tl), 0.0);\n\n\treturn o1 * o1 * k \/ (2.0 * tl) + o2 * k;\n}\n\nfloat phase(float t)\n{\n    float p;\n    \n    float tb = 0.0, td = 1.0;\n    float fl = 4.0, fn = 10.6;\n    \n    p = fl * t;\n    p += f1(t, tb, 0.3, fn - fl); fl = fn; tb += 1.0;\n    fn = (10.0);\n    p += f1(t, tb, 0.5, fn - fl); fl = fn; tb += 0.4;\n    fn = (9.3);\n    p += f1(t, tb, 0.5, fn - fl); fl = fn; tb += 1.0;\n    fn = (0.001);\n    p += f1(t, tb, 0.3, fn - fl); fl = fn; tb += 0.3;\n    \n    \n    return p;\n}\n\n\nfloat wf2(float x)\n{\n    return nse(fract((sin(x * 300.0) * 0.001 + x) * 100.0) * 26.0);\n}\n\nfloat nseh(float x, float h)\n{\n    return nse(x + h) - nse(x - h);\n}\n\nfloat click(float x)\n{\n    x *= 1.5;\n    float v;\n    float y = x;\n    y *= 800.0;\n    y = y * y;\n    v = exp(-y) * 0.0;\n    y = x;\n    y *= 5000.0;\n    y = y * y;\n    v += exp(-y) * 0.2;\n    v += nseh(x * 6000.0, 0.1) * exp(-50.0 * max(x, 0.0)) * step(0.0, x) * 0.3;\n    return v;\n}\n\nfloat motor(float x)\n{\n    x = phase(x);\n    return nseh(mod(x, 0.3333) * 5300.0, 0.06) * 0.9 + wf2(x) * 0.3;\n}\n\nvec2 mainSound( in int samp,float time)\n{\n    float swtime = mod(time - 0.015, 4.1887902047863909846168578443727) - 1.0;\n    float v = click(swtime) + click((swtime - 1.25) * 0.9);\n    \n    v += motor(swtime) * smoothstep(0.6, 1.0, swtime) * smoothstep(0.1 + 2.2, 2.2, swtime) * 0.2;\n    \n    float q = abs(swtime - 0.65);\n    v += nse(swtime * 1000.0) * exp(q * q * -2000.0) * 0.05;\n    q = abs(swtime - 2.2);\n    v += nse(swtime * 1000.0) * exp(q * q * -2000.0) * 0.1;\n    \n    return vec2(v * 1.2);\n}","name":"Sound","description":"","type":"sound"}]},{"ver":"0.1","info":{"id":"lt2fD3","date":"1517442175","viewed":13000,"name":"Kirby Jump","username":"fizzer","description":"Kirby, from the Kirby videogames by Nintendo. Modelled purely with code, from a reference found via Google. Composed and lit for this shot only.","likes":209,"published":1,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ polynomial smooth min (from IQ)\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)\/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat smax(float a,float b, float k)\n{\n    return -smin(-a,-b,k);\n}\n\nmat2 rotmat(float a)\n{\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nfloat shoesDist(vec3 p)\n{\n    vec3 op=p;\n    float d=1e4;\n\n    p.y-=1.5;\n\n    \/\/ right shoe\n    op=p;\n    p-=vec3(-.5,-.6,-.9);\n    p.yz=rotmat(-.7)*p.yz;\n    p.xz=rotmat(0.1)*p.xz;\n    d=min(d,-smin(p.y,-(length(p*vec3(1.6,1,1))-.64),.2));\n    p=op;\n\n    \/\/ left shoe\n    op=p;\n    p-=vec3(.55,-.8,0.4);\n    p.x=-p.x;\n    p.yz=rotmat(1.4)*p.yz;\n    d=min(d,-smin(p.y,-(length(p*vec3(1.6,1,1))-.73),.2));\n    p=op;\n    return d;\n}\n\nfloat sceneDist(vec3 p)\n{\n    vec3 op=p;\n    float d=shoesDist(p);\n\n    d=min(d,p.y);\n    p.y-=1.5;\n\n    \/\/ torso\n    d=min(d,length(p)-1.);\n\n\n    \/\/ left arm\n    op=p;\n    p-=vec3(.66,.7,0);\n    p.xz=rotmat(-0.1)*p.xz;\n    d=smin(d,(length(p*vec3(1.8,1,1))-.58),.07);\n    p=op;\n\n    \/\/ right arm\n    op=p;\n    p-=vec3(-.75,0.2,0);\n    d=smin(d,(length(p*vec3(1,1.5,1))-.54),.03);\n    p=op;\n\n    \/\/ mouth\n    p.y-=.11;\n    float md=smax(p.z+.84,smax(smax(p.x-.2,p.y-.075,.2),dot(p,vec3(.7071,-.7071,0))-.1,.08),.04);\n    p.x=-p.x;\n    md=smax(md,smax(p.z+.84,smax(smax(p.x-.2,p.y-.075,.2),dot(p,vec3(.7071,-.7071,0))-.1,.08),.01),.13);\n    d=smax(d,-md,.012);\n\n    \/\/ tongue\n    p=op;\n    d=smin(d,length((p-vec3(0,.03,-.75))*vec3(1,1,1))-.16,.01);\n\n    return min(d,10.);\n}\n\n\n\nvec3 sceneNorm(vec3 p)\n{\n    vec3 e=vec3(1e-3,0,0);\n    float d = sceneDist(p);\n    return normalize(vec3(sceneDist(p + e.xyy) - sceneDist(p - e.xyy), sceneDist(p + e.yxy) - sceneDist(p - e.yxy),\n                          sceneDist(p + e.yyx) - sceneDist(p - e.yyx)));\n}\n\n\n\/\/ from simon green and others\nfloat ambientOcclusion(vec3 p, vec3 n)\n{\n    const int steps = 4;\n    const float delta = 0.15;\n\n    float a = 0.0;\n    float weight = 4.;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) \/ float(steps)) * delta; \n        a += weight*(d - sceneDist(p + n*d));\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\n\/\/ a re-shaped cosine, to make the peaks more pointy\nfloat cos2(float x){return cos(x-sin(x)\/3.);}\n\nfloat starShape(vec2 p)\n{\n    float a=atan(p.y,p.x)+iTime\/3.;\n    float l=pow(length(p),.8);\n    float star=1.-smoothstep(0.,(3.-cos2(a*5.*2.))*.02,l-.5+cos2(a*5.)*.1);\n    return star;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord\/iResolution.xy;\n\n    float an=cos(iTime)*.1;\n\n    vec2 ot=uv*2.-1.;\n    ot.y*=iResolution.y\/iResolution.x;\n    vec3 ro=vec3(0.,1.4,4.);\n    vec3 rd=normalize(vec3(ot.xy,-1.3));\n\n    rd.xz=mat2(cos(an),sin(an),sin(an),-cos(an))*rd.xz;\n    ro.xz=mat2(cos(an),sin(an),sin(an),-cos(an))*ro.xz;\n\n    float s=20.;\n\n    \/\/ primary ray\n    float t=0.,d=0.;\n    for(int i=0;i<80;++i)\n    {\n        d=sceneDist(ro+rd*t);\n        if(d<1e-4)\n            break;\n        if(t>10.)\n            break;\n        t+=d*.9;\n    }\n\n    t=min(t,10.0);\n\n    \/\/ shadow ray\n    vec3 rp=ro+rd*t;\n    vec3 n=sceneNorm(rp);\n    float st=5e-3;\n    vec3 ld=normalize(vec3(2,4,-4));\n    for(int i=0;i<20;++i)\n    {\n        d=sceneDist(rp+ld*st);\n        if(d<1e-5)\n            break;\n        if(st>5.)\n            break;\n        st+=d*2.;\n    }\n\n    \/\/ ambient occlusion and shadowing\n    vec3 ao=vec3(ambientOcclusion(rp, n));\n    float shad=mix(.85,1.,step(5.,st));\n\n    ao*=mix(.3,1.,.5+.5*n.y);\n\n    \/\/ soft floor shadow\n    if(rp.y<1e-3)\n        ao*=mix(mix(vec3(1,.5,.7),vec3(1),.4)*.6,vec3(1),smoothstep(0.,1.6,length(rp.xz)));\n\n\n\n    vec3 diff=vec3(1);\n    vec3 emit=vec3(0);\n\n    \/\/ skin\n    diff*=vec3(1.15,.3,.41)*1.4;\n    diff+=.4*mix(1.,0.,smoothstep(0.,1.,length(rp.xy-vec2(0.,1.9))));\n    diff+=.5*mix(1.,0.,smoothstep(0.,.5,length(rp.xy-vec2(.7,2.5))));\n    diff+=.36*mix(1.,0.,smoothstep(0.,.5,length(rp.xy-vec2(-1.1,1.8))));\n\n    if(rp.y<1e-3)\n        diff=vec3(.6,1,.6);\n\n    \/\/ mouth\n    diff*=mix(vec3(1,.3,.2),vec3(1),smoothstep(.97,.99,length(rp-vec3(0,1.5,0))));\n\n    \/\/ shoes\n    diff=mix(vec3(1.,.05,.1),diff,smoothstep(0.,0.01,shoesDist(rp)));\n    diff+=.2*mix(1.,0.,smoothstep(0.,.2,length(rp.xy-vec2(-0.5,1.4))));\n    diff+=.12*mix(1.,0.,smoothstep(0.,.25,length(rp.xy-vec2(0.57,.3))));\n\n    \/\/ bounce light from the floor\n    diff+=vec3(.25,1.,.25)*smoothstep(-.3,1.7,-rp.y+1.)*max(0.,-n.y)*.7;\n\n    vec3 orp=rp;\n    rp.y-=1.5;\n    rp.x=abs(rp.x);\n\n    \/\/ blushes\n    diff*=mix(vec3(1,.5,.5),vec3(1),smoothstep(.1,.15,length((rp.xy-vec2(.4,.2))*vec2(1,1.65))));\n\n    rp.xy-=vec2(.16,.45);\n    rp.xy*=.9;\n    orp=rp;\n    rp.y=pow(abs(rp.y),1.4)*sign(rp.y);\n\n    \/\/ eye outline\n    diff*=smoothstep(.058,.067,length((rp.xy)*vec2(.9,.52)));\n\n    rp=orp;\n    rp.y+=.08;\n    rp.y-=pow(abs(rp.x),2.)*16.;\n\n    \/\/ eye reflections\n    emit+=vec3(.1,.5,1.)*(1.-smoothstep(.03,.036,length((rp.xy)*vec2(.7,.3))))*max(0.,-rp.y)*10.;\n\n    rp=orp;\n    rp.y-=.12;\n\n    \/\/ eye highlights\n    emit+=vec3(1)*(1.-smoothstep(.03,.04,length((rp.xy)*vec2(1.,.48))));\n\n    \/\/ fresnel\n    diff+=pow(clamp(1.-dot(-rd,n),0.,.9),4.)*.5;\n\n    \/\/ background and floor fade\n    vec3 backg=vec3(1.15,.3,.41)*.9;\n    ot.x+=.6+iTime\/50.;\n    ot.y+=cos(floor(ot.x*2.)*3.)*.1+.2;\n    ot.x=mod(ot.x,.5)-.25;\n    backg=mix(backg,vec3(1.,1.,.5),.1*starShape((ot-vec2(0.,.6))*8.)*smoothstep(9.,10.,t));\n    diff=mix(diff,backg,smoothstep(.9,10.,t));\n\n    fragColor.rgb=mix(vec3(.15,0,0),vec3(1),ao)*shad*diff*1.1;\n    fragColor.rgb+=emit;\n\n    fragColor.rgb=pow(fragColor.rgb,vec3(1.\/2.4));\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"lltBWB","date":"1540958965","viewed":12950,"name":"Planet Fall","username":"iq","description":"Pretty much a modification to Klems' shader [url]https:\/\/www.shadertoy.com\/view\/XlcfRs[\/url]. Make AA 1 in line 7 if it renders too slow for you","likes":169,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Copyright Inigo Quilez, 2018 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work neither\n\/\/ as it is or altered, here on Shadertoy or anywhere else, in any\n\/\/ form including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it or train a neural\n\/\/ network with it without permission. I share this Work for educational\n\/\/ purposes, and you can link to it, through an URL, proper attribution\n\/\/ and unmodified screenshot, as part of your educational material. If\n\/\/ these conditions are too restrictive please contact me and we'll\n\/\/ definitely work it out.\n\n\/\/ Pretty much a modification to Klems' shader (https:\/\/www.shadertoy.com\/view\/XlcfRs)\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2  \/\/ Change AA to 1 if it renders too slow for you\n#endif\n\n\/\/#define INTERACTIVE\n\nmat3 makeBase( in vec3 w )\n{\n\tfloat k = inversesqrt(1.0-w.y*w.y);\n    return mat3( vec3(-w.z,0.0,w.x)*k, \n                 vec3(-w.x*w.y,1.0-w.y*w.y,-w.y*w.z)*k,\n                 w);\n}\n\n#define ZERO (min(iFrame,0))\n\n\/\/ https:\/\/iquilezles.org\/articles\/intersectors\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in float rad )\n{\n\tfloat b = dot( ro, rd );\n\tfloat c = dot( ro, ro ) - rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n    h = sqrt(h);\n\treturn vec2(-b-h,-b+h);\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat sdCapsule( in vec3 p, in float b, in float r )\n{\n    float h = clamp( p.z\/b, 0.0, 1.0 );\n    return length( p - vec3(0.0,0.0,b)*h ) - r;\/\/*(0.2+1.6*h);\n}\n\n\/\/ modified Keinert et al's inverse Spherical Fibonacci Mapping\nvec4 inverseSF( in vec3 p, const in float n )\n{\n    const float PI = 3.14159265359;\n\tconst float PHI = 1.61803398875;\n\n    float phi = min(atan(p.y,p.x),PI);\n    float k   = max(floor(log(n*PI*sqrt(5.0)*(1.-p.z*p.z))\/log(PHI+1.)),2.0);\n    float Fk  = pow(PHI,k)\/sqrt(5.0);\n    vec2  F   = vec2(round(Fk),round(Fk*PHI));\n    vec2  G   = PI*(fract((F+1.0)*PHI)-(PHI-1.0));    \n    \n    mat2 iB = mat2(F.y,-F.x,G.y,-G.x)\/(F.y*G.x-F.x*G.y);\n    vec2 c = floor(iB*0.5*vec2(phi,n*p.z-n+1.0));\n\n    float ma = 0.0;\n    vec4 res = vec4(0);\n    for( int s=0; s<4; s++ )\n    {\n        vec2 uv = vec2(s&1,s>>1);\n        float i = dot(F,uv+c);\n        float phi = 2.0*PI*fract(i*PHI);\n        float cT = 1.0 - (2.0*i+1.0)\/n;\n        float sT = sqrt(1.0-cT*cT);\n        vec3 q = vec3(cos(phi)*sT, sin(phi)*sT,cT);\n        float a = dot(p,q);\n        if (a > ma)\n        {\n            ma = a;\n            res.xyz = q;\n            res.w = i;\n        }\n    }\n    return res;\n}\n\nfloat map( in vec3 p, out vec4 color, const in bool doColor )\n{\n    float lp = length(p);\n    float dmin = lp-1.0;\n    {\n    vec3 w = p\/lp;\n    vec4 fibo = inverseSF(w, 700.0);\n    float hh = 1.0 - smoothstep(0.05,0.1,length(fibo.xyz-w));\n    dmin -= 0.07*hh;\n    color = vec4(0.05,0.1,0.1,1.0)*hh * (1.0+0.5*sin(fibo.w*111.1));\n    }\n    \n    \n    float s = 1.0;\n    \n    #ifdef INTERACTIVE\n  \/\/float tt = mod(iTime,5.0);\n    float tt = 4.0*iMouse.x\/iResolution.x;\n    vec3  fp = smoothstep(0.0,1.0,tt-vec3(0,1,2));\n    #endif\n    \n    for( int i=0; i<3; i++ )\n    {\n        float h = float(i)\/float(3-1);\n        \n        vec4 f = inverseSF(normalize(p), 65.0 + h*75.0);\n        \n        \/\/ snap\n        p -= f.xyz;\n\n        \/\/ orient to surface\n        p = p*makeBase(f.xyz);\n\n        \/\/ scale\n        float scale = 6.6 + 2.0*sin(111.0*f.w);\n        p *= scale;\n        p.xy *= 1.2;\n        \n        \/\/translate\n        p.z -= 3.0 - length(p.xy)*0.6*sin(f.w*212.1);\n            \n        \/\/ measure distance\n        s *= scale;\n        #ifdef INTERACTIVE\n        float d = sdCapsule( p+vec3(0,0,6), 6.0*fp[i], mix(-40.0,0.42*fp[i],smoothstep(0.0,0.1,fp[i])) );\n        #else\n        float d = sdCapsule( p, -6.0, 0.42 );\n        #endif\n        d \/= s;\n\n        if( d<dmin )\n        {\n            if( doColor )\n            {\n                color.w *= smoothstep(0.0, 5.0\/s, dmin-d);\n\n                if( i==0 ) \n                {\n                    color.xyz = vec3(0.425,0.36,0.1)*1.1;  \/\/ fall\n                  \/\/color.xyz = vec3(0.4,0.8,0.1);         \/\/ summer\n                  \/\/color.xyz = vec3(0.4,0.4,0.8);         \/\/ winter\n                }\n\n                color.zyx += 0.3*(1.0-sqrt(h))*sin(f.w*1111.0+vec3(0.0,1.0,2.0));\n                color.xyz = max(color.xyz,0.0);\n            }\n            dmin = d;\n        }\n        else\n        {\n          color.w *= 0.4*(0.1 + 0.9*smoothstep(0.0, 1.0\/s, d-dmin));\n        }\n    }\n    \n    return dmin;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/normalsSDF\nvec3 calcNormal( in vec3 pos, in float ep )\n{\n    vec4 kk;\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep, kk, false ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep, kk, false ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep, kk, false ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep, kk, false ) );\n#else\n    \/\/ prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+e*ep, kk, false);\n    }\n    return normalize(n);\n#endif    \n    \n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\n{\n    vec2 bound = sphIntersect( ro, rd, 2.1 );\n    tmin = max(tmin,bound.x);\n    tmax = min(tmax,bound.y);\n    \n\tfloat res = 1.0;\n    float t = tmin;\n    for( int i=0; i<50; i++ )\n    {\n    \tvec4 kk;\n\t\tfloat h = map( ro + rd*t, kk, false );\n        res = min( res, k*h\/t );\n        t += clamp( h, 0.02, 0.20 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat raycast(in vec3 ro, in vec3 rd, in float tmin, in float tmax  )\n{\n    vec4 kk;\n    float t = tmin;\n\tfor( int i=0; i<512; i++ )\n    {\n\t\tvec3 p = ro + t*rd;\n        float h = map(p,kk,false);\n\t\tif( abs(h)<(0.15*t\/iResolution.x) ) break;\n\t\tt += h*0.5;\n        if( t>tmax ) return -1.0;;\n\t}\n    \/\/if( t>tmax ) t=-1.0;\n\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float an = (iTime-10.0)*0.05;\n    \n    \/\/ camera\t\n    vec3 ro = vec3( 4.5*sin(an), 0.0, 4.5*cos(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    \/\/ camera-to-world rotation\n    mat3 ca = makeBase( normalize(ta-ro) );\n\n    \/\/ render    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        \/\/ pixel coordinates\n        vec2 o = vec2(float(m),float(n)) \/ float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))\/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)\/iResolution.y;\n        #endif\n        \/\/ ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.2) );\n    \n        \/\/ background\n        vec3 col = vec3(0.1,0.14,0.18) + 0.1*rd.y;\n\n        \/\/ bounding volume\n        vec2 bound = sphIntersect( ro, rd, 2.1 );\n\t\tif( bound.x>0.0 )\n        {\n        \/\/ raycast\n        float t = raycast(ro, rd, bound.x, bound.y );\n        if( t>0.0 )\n        {\n            \/\/ local geometry            \n            vec3 pos = ro + t*rd;\n        \tvec3 nor = calcNormal(pos, 0.01);\n            vec3 upp = normalize(pos);\n            \n            \/\/ color and occlusion\n            vec4 mate; map(pos, mate, true);\n            \n            \/\/ lighting            \n            col = vec3(0.0);\n        \n            \/\/ key ligh\n            {\n                \/\/ dif\n                vec3 lig = normalize(vec3(1.0,0.0,0.7));\n                float dif = clamp(0.5+0.5*dot(nor,lig),0.0,1.0);\n                float sha = calcSoftshadow( pos+0.0001*nor, lig, 0.0001, 2.0, 6.0 );\n                col += mate.xyz*dif*vec3(1.8,0.6,0.5)*1.1*vec3(sha,sha*0.3+0.7*sha*sha,sha*sha);\n\t\t\t\t\/\/ spec\n                vec3 hal = normalize(lig-rd);\n                float spe = clamp( dot(nor,hal), 0.0, 1.0 );\n                float fre = clamp( dot(-rd,lig), 0.0, 1.0 );\n                fre = 0.2 + 0.8*pow(fre,5.0);\n                spe *= spe;\n                spe *= spe;\n                spe *= spe;\n                col += 1.0*(0.25+0.75*mate.x)*spe*dif*sha*fre;\n            }\n\n            \/\/ back light\n           \t{\n                vec3 lig = normalize(vec3(-1.0,0.0,0.0));\n                float dif = clamp(0.5+0.5*dot(nor,lig),0.0,1.0);\n                col += mate.rgb*dif*vec3(1.2,0.9,0.6)*0.2*mate.w;\n            }\n\n            \/\/ dome light\n            {\n                float dif = clamp(0.3+0.7*dot(nor,upp),0.0,1.0);\n                #if 0\n                dif *= 0.05 + 0.95*calcSoftshadow( pos+0.0001*nor, upp, 0.0001, 1.0, 1.0 );\n                col += mate.xyz*dif*5.0*vec3(0.1,0.1,0.3)*mate.w;\n                #else\n                col += mate.xyz*dif*3.0*vec3(0.1,0.1,0.3)*mate.w*(0.2+0.8*mate.w);\n                #endif\n            }\n            \n            \/\/ fake sss\n            {\n                float fre = clamp(1.0+dot(rd,nor),0.0,1.0);\n                col += 0.3*vec3(1.0,0.3,0.2)*mate.xyz*mate.xyz*fre*fre*mate.w;\n            }\n            \n            \/\/ grade\/sss\n            {\n            \tcol = 2.0*pow( col, vec3(0.7,0.85,1.0) );\n            }\n            \n            \/\/ exposure control\n            col *= 0.7 + 0.3*smoothstep(0.0,25.0,abs(iTime-31.0));\n            \n            \/\/ display fake occlusion\n            \/\/col = mate.www;\n        }\n        }\n    \n \n        \/\/ gamma\n        col = pow( col, vec3(0.4545) );\n    \n        tot += col;\n    #if AA>1\n    }\n    tot \/= float(AA*AA);\n    #endif\n\n    \/\/ vignetting\n \tvec2 q = fragCoord\/iResolution.xy;\n    tot *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2 );\n    \n    fragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"XlfXR4","date":"1434657962","viewed":12944,"name":"Curvature - Parametric 3D","username":"iq","description":"Curvature computation for parametric curves (same as [url]https:\/\/www.shadertoy.com\/view\/Mlf3zl[\/url]. but in 3D in this case), and displays it with colors (red is high curvature, yellow is medium, green is low)","likes":101,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ The MIT License\n\/\/ Copyright \u00a9 2015 Inigo Quilez\n\/\/ Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\/\/ https:\/\/www.youtube.com\/c\/InigoQuilez\n\/\/ https:\/\/iquilezles.org\/\n\n\n\/\/\n\/\/ Computes the curvature of a parametric curve f(x) as \n\/\/\n\/\/ k(f) = | f' x f''| \/ |f'|^3\n\/\/\n\/\/ More info here: https:\/\/en.wikipedia.org\/wiki\/Curvature\n\/\/\n\n\n\/\/----------------------------------------\n\nvec3 a, b, c, m, n;\n\n\/\/ curve\nvec3 mapD0(float t)\n{\n    return 0.25 + a*cos(t+m)*(b+c*cos(t*7.0+n));\n}\n\/\/ curve derivative (velocity)\nvec3 mapD1(float t)\n{\n    return -7.0*a*c*cos(t+m)*sin(7.0*t+n) - a*sin(t+m)*(b+c*cos(7.0*t+n));\n}\n\/\/ curve second derivative (acceleration)\nvec3 mapD2(float t)\n{\n    return 14.0*a*c*sin(t+m)*sin(7.0*t+n) - a*cos(t+m)*(b+c*cos(7.0*t+n)) - 49.0*a*c*cos(t+m)*cos(7.0*t+n);\n}\n\n\/\/----------------------------------------\n\nfloat curvature( float t )\n{\n    vec3 r1 = mapD1(t); \/\/ first derivative\n    vec3 r2 = mapD2(t); \/\/ second derivative\n    return length(cross(r1,r2))\/pow(length(r1),3.0);\n}\n\n\/\/-----------------------------------------\n\n\/\/ unsigned squared distance between point and segment\nvec2 usqdPointSegment( in vec3 p, in vec3 a, in vec3 b )\n{\n\tvec3  pa = p - a;\n\tvec3  ba = b - a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\tvec3  q = pa - ba*h;\n\treturn vec2( dot(q,q), h );\n}\n\n\n\/\/ unsigned squared distance between ray and segment\nvec2 usqdLineSegment( vec3 a, vec3 b, vec3 o, vec3 d )\n{\n#if 1\n\tvec3 oa = a-o;\n    vec3 ob = b-o;\n\tvec3 va = oa-d*dot(oa,d);\n    vec3 vb = ob-d*dot(ob,d);\n    \n    vec3 ba = va-vb;\n    float h = clamp( dot(va,ba)\/dot(ba,ba), 0.0, 1.0 );\n    vec3  q = va - ba*h;\n    return vec2( dot(q,q), h );\n#else\n    return usqdPointSegment( vec3(0.0), o+d*dot(a-o,d)-a, o+d*dot(b-o,d)-b );\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    a = vec3(1.85,1.25,1.85) + 0.1*cos(5.0+0.7*iTime + vec3(0.5,1.0,2.0) );\n    b = vec3(0.60,0.60,0.60) + 0.1*cos(4.0+0.5*iTime + vec3(2.5,5.0,3.0) );\n    c = vec3(0.40,0.40,0.40) + 0.1*cos(1.0+0.3*iTime + vec3(6.0,2.0,4.2) );\n    m = cos( 0.11*iTime + vec3(2.0,0.0,5.0) );\n    n = cos( 0.17*iTime + vec3(3.0,1.0,4.0) );\n\n\tvec2 p = (2.0*fragCoord-iResolution.xy)\/iResolution.y;\n \n    vec3 ro = vec3( 0.0, 0.0, 4.0 );\n    vec3 rd = normalize( vec3(p.xy, -2.0) );\n\n    vec3 col = vec3(0.0);\n    \n    vec3  gp = vec3(0.0);\n    float pt = (-1.0-ro.y)\/rd.y;\n    vec3 gc = vec3(0.0);\n    if( pt>0.0 )\n    {\n        gp = ro + pt*rd;\n        gc = vec3(1.0) * (0.2 + 0.1*smoothstep(-0.01,0.01,sin(4.0*gp.x)*sin(4.0*gp.z)));\n        col = 0.3*gc*exp(-0.05*pt);\n    }\n    \n    const int kNum = 150;\n    \n    float dt = 6.2831\/float(kNum);\n\tfloat t = 0.0;\n    vec3  xb = mapD0(t); t += dt;\n    for( int i=0; i<kNum; i++ )\n    {\n        vec3 xc = mapD0(t);\n        xc.y = max(-1.0,xc.y); \/\/ clip to ground\n        vec2 ds = usqdLineSegment( xb, xc, ro, rd );\n\n        \/\/ compute curvature\n        float h = t - dt + dt*ds.y;\n        float c = 1.0\/curvature( h );\n\n        vec3  cc = clamp( 0.25 + 0.75*cos( -clamp(3.0*c,0.0,2.0) + 1.0 + vec3(0.0,1.5,2.0) ), 0.0, 1.0 );\n        \n        col += 1.0*cc*exp2( -800.0*ds.x );\n        col += 0.1*cc*exp2( -40.0*ds.x );\n\n        \/\/ light ground\n        if( pt > 0.0 )\n        {\n            vec2 sd = usqdPointSegment( gp, xb, xc );\n            col += gc*0.8*cc*exp(-2.0*sd.x)*exp( -0.05*pt );\n        }\n        \n        xb = xc; t += dt;\n\t}    \n    \n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"ltj3Wc","date":"1433461436","viewed":12931,"name":"Brush Experiment 3","username":"104","description":"Expanding on experiment 2, but for drawing circles. Mouse X controls falloff. Code is heavily commented showing the concept, not optimized at all.","likes":307,"published":1,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ todo: implement sweep amt\nvec2 mouse;\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ BOILERPLATE UTILITIES...................\nconst float pi = 3.14159;\nconst float pi2 = pi * 2.;\n\nfloat opU( float d1, float d2 ){ return min(d1,d2); }\nfloat opS( float d2, float d1 ){ return max(-d1,d2); }\nfloat opI( float d1, float d2) { return max(d1,d2); }\n\n\n\/\/ from \"Magic Fractal\" by dgreensp\n\/\/ https:\/\/www.shadertoy.com\/view\/4ljGDd\nfloat magicBox(vec3 p) {\n    const int MAGIC_BOX_ITERS = 13;\n    const float MAGIC_BOX_MAGIC = 0.55;\n    \/\/ The fractal lives in a 1x1x1 box with mirrors on all sides.\n    \/\/ Take p anywhere in space and calculate the corresponding position\n    \/\/ inside the box, 0<(x,y,z)<1\n    p = 1.0 - abs(1.0 - mod(p, 2.0));\n    \n    float lastLength = length(p);\n    float tot = 0.0;\n    \/\/ This is the fractal.  More iterations gives a more detailed\n    \/\/ fractal at the expense of more computation.\n    for (int i=0; i < MAGIC_BOX_ITERS; i++) {\n      \/\/ The number subtracted here is a \"magic\" paremeter that\n      \/\/ produces rather different fractals for different values.\n      p = abs(p)\/(lastLength*lastLength) - MAGIC_BOX_MAGIC;\n      float newLength = length(p);\n      tot += abs(newLength-lastLength);\n      lastLength = newLength;\n    }\n\n    return tot;\n}\n\n\nfloat magicBox(vec2 uv){\n    \/\/ A random 3x3 unitary matrix, used to avoid artifacts from slicing the\n    \/\/ volume along the same axes as the fractal's bounding box.\n    const mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\n                        0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\n                        -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\n    vec3 p = 0.5*M*vec3(uv, 0.0);\n    return magicBox(p);\n}\n\n\n\n\nmat2 rot2D(float r)\n{\n    float c = cos(r), s = sin(r);\n    return mat2(c, s, -s, c);\n}\nfloat nsin(float a){return .5+.5*sin(a);}\nfloat ncos(float a){return .5+.5*cos(a);}\nvec3 saturate(vec3 a){return clamp(a,0.,1.);}\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat rand(float n){\n \treturn fract(cos(n*89.42)*343.42);\n}\nfloat dtoa(float d, float amount)\n{\n    return clamp(1.0 \/ (clamp(d, 1.0\/amount, 1.0)*amount), 0.,1.);\n}\nfloat sdAxisAlignedRect(vec2 uv, vec2 tl, vec2 br)\n{\n    vec2 d = max(tl-uv, uv-br);\n    return length(max(vec2(0.0), d)) + min(0.0, max(d.x, d.y));\n}\nfloat sdCircle(vec2 uv, vec2 origin, float radius)\n{\n    return length(uv - origin) - radius;\n}\n\/\/ 0-1 1-0\nfloat smoothstep4(float e1, float e2, float e3, float e4, float val)\n{\n    return min(smoothstep(e1,e2,val), 1.-smoothstep(e3,e4,val));\n}\n\/\/ hash & simplex noise from https:\/\/www.shadertoy.com\/view\/Msf3WH\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\/\/ returns -.5 to 1.5. i think.\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; \/\/ (sqrt(3)-1)\/2;\n    const float K2 = 0.211324865; \/\/ (3-sqrt(3))\/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); \/\/vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\t\n}\nfloat noise01(vec2 p)\n{\n    return clamp((noise(p)+.5)*.5, 0.,1.);\n}\n\/\/ debug function to convert distance to color, revealing sign.\nvec3 dtocolor(vec3 inpColor, float dist)\n{\n    vec3 ret;\n    if(dist > 0.)\n        ret = mix(vec3(0,0,.5), vec3(.5,.5,1), sin(dist * pi2 * 50.));\/\/ red = negative \/ inside geometry.\n    else\n\t    ret = mix(vec3(1.,.5,.5), vec3(.5,0,0), sin(dist * pi2 * 50.));\/\/ blue = positive, of of geometry.\n    ret = mix(ret, vec3(0), clamp(abs(dist),0.,1.));\/\/ falloff\n    return ret;\n}\n\nfloat smoothf(float x)\n{\n    return x*x*x*(x*(x*6. - 15.) + 10.);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ APP CODE ...................\n\n\/\/ this function will produce a line with brush strokes. the inputs are such\n\/\/ that you can apply it to pretty much any line; the geometry is separated from this function.\nvec3 colorBrushStroke(vec2 uvLine, vec2 uvPaper, vec2 lineSize, float sdGeometry, vec3 inpColor, vec4 brushColor)\n{\n    float posInLineY = (uvLine.y \/ lineSize.y);\/\/ position along the line. in the line is 0-1.\n\n    if(iMouse.z > 0.)\n    {\n\/\/    return mix(inpColor, vec3(0), dtoa(sdGeometry, 1000.));\/\/ reveal geometry.\n\/\/    return mix(inpColor, dtocolor(inpColor, uvLine.y), dtoa(sdGeometry, 1000.));\/\/ reveal Y\n\/\/    return mix(inpColor, dtocolor(inpColor, posInLineY), dtoa(sdGeometry, 1000.));\/\/ reveal pos in line.\n\/\/    return mix(inpColor, dtocolor(inpColor, uvLine.x), dtoa(sdGeometry, 1000.));\/\/ reveal X\n    \tfloat okthen = 42.;\/\/ NOP\n    }\n    \n    \/\/ warp the position-in-line, to control the curve of the brush falloff.\n    if(posInLineY > 0.)\n    {\n        float mouseX = iMouse.x == 0. ? 0.2 : (iMouse.x \/ iResolution.x);\n\t    posInLineY = pow(posInLineY, (pow(mouseX,2.) * 15.) + 1.5);\n    }\n\n    \/\/ brush stroke fibers effect.\n    float strokeBoundary = dtoa(sdGeometry, 300.);\/\/ keeps stroke texture inside the geometry.\n    float strokeTexture = 0.\n        + noise01(uvLine * vec2(min(iResolution.y,iResolution.x)*0.2, 1.))\/\/ high freq fibers\n        + noise01(uvLine * vec2(79., 1.))\/\/ smooth brush texture. lots of room for variation here, also layering.\n        + noise01(uvLine * vec2(14., 1.))\/\/ low freq noise, gives more variation\n        ;\n    strokeTexture *= 0.333 * strokeBoundary;\/\/ 0 to 1 (take average of above)\n    strokeTexture = max(0.008, strokeTexture);\/\/ avoid 0; it will be ugly to modulate\n  \t\/\/ fade it from very dark to almost nonexistent by manipulating the curve along Y\n\tfloat strokeAlpha = pow(strokeTexture, max(0.,posInLineY)+0.09);\/\/ add allows bleeding\n    \/\/ fade out the end of the stroke by shifting the noise curve below 0\n    const float strokeAlphaBoost = 1.09;\n    if(posInLineY > 0.)\n        strokeAlpha = strokeAlphaBoost * max(0., strokeAlpha - pow(posInLineY,0.5));\/\/ fade out\n    else\n        strokeAlpha *= strokeAlphaBoost;\n\n    strokeAlpha = smoothf(strokeAlpha);\n    \n    \/\/ paper bleed effect.\n    float paperBleedAmt = 60. + (rand(uvPaper.y) * 30.) + (rand(uvPaper.x) * 30.);\n\/\/    amt = 500.;\/\/ disable paper bleed    \n    \n    \/\/ blotches (per stroke)\n    \/\/float blotchAmt = smoothstep(17.,18.5,magicBox(vec3(uvPaper, uvLine.x)));\n    \/\/blotchAmt *= 0.4;\n    \/\/strokeAlpha += blotchAmt;\n\n    float alpha = strokeAlpha * brushColor.a * dtoa(sdGeometry, paperBleedAmt);\n    alpha = clamp(alpha, 0.,1.);\n    return mix(inpColor, brushColor.rgb, alpha);\n}\n\nvec3 colorBrushStrokeLine(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 p1_, vec2 p2_, float lineWidth)\n{\n    \/\/ flatten the line to be axis-aligned.\n    float lineAngle = pi-atan(p1_.x - p2_.x, p1_.y - p2_.y);\n    mat2 rotMat = rot2D(lineAngle);\n\n    float lineLength = distance(p2_, p1_);\n    \/\/ make an axis-aligned line from this line.\n    vec2 tl = (p1_ * rotMat);\/\/ top left\n    vec2 br = tl + vec2(0,lineLength);\/\/ bottom right\n    vec2 uvLine = uv * rotMat;\n\n    \/\/ make line slightly narrower at end.\n    lineWidth *= mix(1., .9, smoothstep(tl.y,br.y,uvLine.y));\n    \n    \/\/ wobble it around, humanize\n    float res = min(iResolution.y,iResolution.x);\n    uvLine.x += (noise01(uvLine * 1.)-0.5) * 0.02;\n    uvLine.x += cos(uvLine.y * 3.) * 0.009;\/\/ smooth lp wave\n    uvLine.x += (noise01(uvLine * 5.)-0.5) * 0.005;\/\/ a sort of random waviness like individual strands are moving around\n\/\/    uvLine.x += (noise01(uvLine * res * 0.18)-0.5) * 0.0035;\/\/ HP random noise makes it look less scientific\n\n    \/\/ calc distance to geometry. actually just do a straight line, then we will round it out to create the line width.\n    float d = sdAxisAlignedRect(uvLine, tl, br) - lineWidth \/ 2.;\n    uvLine = tl - uvLine;\n    \n    vec2 lineSize = vec2(lineWidth, lineLength);\n    \n    vec3 ret = colorBrushStroke(vec2(uvLine.x, -uvLine.y), uv, lineSize,\n                                d, inpColor, brushColor);\n    return ret;\n}\n\n\/\/ returns:\n\/\/ xy = uvLine\n\/\/ z = radius\nvec3 humanizeBrushStrokeDonut(vec2 uvLine, float radius_, bool clockwise, float lineLength)\n{\n    vec2 humanizedUVLine = uvLine;\n    \n\t\/\/ offsetting the circle along its path creates a twisting effect.\n    float twistAmt = .24;\n    float linePosY = humanizedUVLine.y \/ lineLength;\/\/ 0 to 1 scale\n    humanizedUVLine.x += linePosY * twistAmt;\n    \n    \/\/ perturb radius \/ x\n    float humanizedRadius = radius_;\n    float res = min(iResolution.y,iResolution.x);\n    humanizedRadius += (noise01(uvLine * 1.)-0.5) * 0.04;\n    humanizedRadius += sin(uvLine.y * 3.) * 0.019;\/\/ smooth lp wave\n    humanizedUVLine.x += sin(uvLine.x * 30.) * 0.02;\/\/ more messin\n    humanizedUVLine.x += (noise01(uvLine * 5.)-0.5) * 0.005;\/\/ a sort of random waviness like individual strands are moving around\n\/\/    humanizedUVLine.x += (noise01(uvLine * res * 0.18)-0.5) * 0.0035;\/\/ HP random noise makes it look less scientific\n    \n    return vec3(humanizedUVLine, humanizedRadius);\n}\n\n\/\/ there's something about calling an Enso a \"donut\" that makes me giggle.\n\/\/ TODO: sweepAmt is 0 to 1, the amount of the circle to cover by the brush stroke. 1=whole circle. 0=just a point.\nvec3 colorBrushStrokeDonut(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 o, float radius_, float angleStart, float sweepAmt, float lineWidth, bool clockwise)\n{\n\tvec2 uvLine = uv - o;\n    float angle = atan(uvLine.x, uvLine.y) + pi;\/\/ 0-2pi\n    angle = mod(angle-angleStart+pi, pi2);\n    if(!clockwise)\n        angle = pi2 - angle;\n    float lineLength = radius_ * pi2;\/\/ this is calculated before any humanizing\/perturbance. so it's possible that it's slightly inaccurate, but in ways that will never matter\n    uvLine = vec2(\n        radius_ - length(uvLine),\n        angle \/ pi2 * lineLength\n    );\n    \n    \/\/ make line slightly narrower at end.\n    float lineWidth1 = lineWidth * mix(1., .9, smoothstep(0.,lineLength,uvLine.y));\n    \n    vec3 hu = humanizeBrushStrokeDonut(uvLine, radius_, clockwise, lineLength);\n    vec2 humanizedUVLine = hu.xy;\n    float humanizedRadius = hu.z;\n\n    float d = opS(sdCircle(uv, o, humanizedRadius),\n                  sdCircle(uv, o, humanizedRadius));\n    d -= lineWidth1 * 0.5;\/\/ round off things just like in the line routine.\n\n    vec3 ret = colorBrushStroke(humanizedUVLine, uv, vec2(lineWidth1, lineLength), d, inpColor, brushColor);\n    \n    \/\/ do the same but for before the beginning of the line. distance field is just a single point\n    vec3 ret2 = vec3(1);\n    if(angle > pi)\n    {\n        uvLine.y -= lineLength;\n        hu = humanizeBrushStrokeDonut(uvLine, radius_, clockwise, lineLength);\n        humanizedUVLine = hu.xy;\n        humanizedRadius = hu.z;\n        vec2 strokeStartPos = o + vec2(sin(angleStart), cos(angleStart)) * humanizedRadius;\n        d = distance(uv, strokeStartPos);\n        d -= lineWidth * 0.5 * 1.;\/\/ round off things just like in the line routine.\n        ret2 = colorBrushStroke(humanizedUVLine, uv, vec2(lineWidth, lineLength), d, inpColor, brushColor);\n\t}\n    return min(ret, ret2);\n}\n\n\nvec2 getuv_centerX(vec2 fragCoord, vec2 newTL, vec2 newSize)\n{\n    vec2 ret = vec2(fragCoord.x \/ iResolution.x, (iResolution.y - fragCoord.y) \/ iResolution.y);\/\/ ret is now 0-1 in both dimensions\n    ret *= newSize;\/\/ scale up to new dimensions\n    float aspect = iResolution.x \/ iResolution.y;\n    ret.x *= aspect;\/\/ orig aspect ratio\n    float newWidth = newSize.x * aspect;\n    return ret + vec2(newTL.x - (newWidth - newSize.x) \/ 2.0, newTL.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uvSignature = (fragCoord \/ iResolution.y * 2.0) - 1.;\n    mouse = getuv_centerX(iMouse.xy, vec2(-1,-1), vec2(2,2));\/\/ (iMouse.xy \/ iResolution.y * 2.0) - 1.;\n\tvec2 uv = getuv_centerX(fragCoord, vec2(-1,-1), vec2(2,2));\/\/ 0-1 centered\n    \n    vec3 col = vec3(1.,1.,0.875);\/\/ bg\n    float dist;\n    \n\t\/\/ geometry on display...\n\tfloat yo = sin(-uv.x*pi*0.5)*0.2;\n    col = colorBrushStrokeLine(uv, col, vec4(vec3(.8,.1,0),.9),\/\/ red fixed line\n                           vec2(-1.4, -.4+yo),\n                           vec2(2.6, -.4+yo), 0.3);\n\n    col = colorBrushStrokeLine(uv, col, vec4(vec3(.8,.1,0),0.4),\/\/ red fixed line\n                           vec2(1.3, 0.+yo),\n                           vec2(-2.9, 0.+yo), 0.03);\n\n    col = colorBrushStrokeLine(uv, col, vec4(vec3(.8,.1,0),0.52),\/\/ red fixed line\n                           vec2(1.3, .3+yo + (cos(uv.x * 12.) * 0.025)),\n                           vec2(-2.9, .3+yo), 0.1);\n\n\n    col = colorBrushStrokeDonut(uv, col, vec4(0,0,0,.9),\n                                vec2(0,0),\/\/ origin\n                                0.6,\/\/ radius\n                                0.2,\/\/ angle of brush start\n                                0.5,\/\/ sweep amt 0-1\n                                0.3,\/\/ width\n                                false);\/\/ clockwise\n    \n    \/\/ paint blotches\n    float blotchAmt = smoothstep(20.,50.,magicBox((uv+12.)*2.));\/\/ smoothstep(40.,40.5, magicBox((uv+9.4)*2.));\n    blotchAmt = pow(blotchAmt, 3.);\/\/ attenuate\n    blotchAmt = .7*smoothstep(.2,.4,blotchAmt);\/\/ sharpen\n    col *= 1.-blotchAmt;\n    \n\t\/\/ signature\n    dist = sdAxisAlignedRect(uvSignature, vec2(-0.68), vec2(-0.55));\n    float amt = 90. + (rand(uvSignature.y) * 100.) + (rand(uvSignature.x \/ 4.) * 90.);\n    float vary = sin(uvSignature.x*uvSignature.y*50.)*0.0047;\n    dist = opS(dist-0.028+vary, dist-0.019-vary);\/\/ round edges, and hollow it out\n    col = mix(col, vec3(0.8,.1, 0.0), dtoa(dist, amt) * 0.3);\n    col = mix(col, vec3(0.8,.1, 0.0), dtoa(dist, amt*4.) * 0.95);\n\n    \/\/ grain\n    col.rgb += (rand(uv)-.5)*.08;\n    col.rgb = saturate(col.rgb);\n\n    \/\/ vignette\n    vec2 uvScreen = (fragCoord \/ iResolution.xy * 2.)-1.;\n\tfloat vignetteAmt = 1.-dot(uvScreen*0.5,uvScreen* 0.62);\n    col *= vignetteAmt;\n    \n    fragColor = vec4(col, 1.);\n}\n\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"Mds3zn","date":"1361892210","viewed":12924,"name":"Chromatic Aberration","username":"NickWest","description":"Some kind of camera\/transmission interference","likes":92,"published":1,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"\/media\/a\/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"\/media\/ap\/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\r\n\r\n\tfloat amount = 0.0;\r\n\t\r\n\tamount = (1.0 + sin(iTime*6.0)) * 0.5;\r\n\tamount *= 1.0 + sin(iTime*16.0) * 0.5;\r\n\tamount *= 1.0 + sin(iTime*19.0) * 0.5;\r\n\tamount *= 1.0 + sin(iTime*27.0) * 0.5;\r\n\tamount = pow(amount, 3.0);\r\n\r\n\tamount *= 0.05;\r\n\t\r\n    vec3 col;\r\n    col.r = texture( iChannel0, vec2(uv.x+amount,uv.y) ).r;\r\n    col.g = texture( iChannel0, uv ).g;\r\n    col.b = texture( iChannel0, vec2(uv.x-amount,uv.y) ).b;\r\n\r\n\tcol *= (1.0 - amount * 0.5);\r\n\t\r\n    fragColor = vec4(col,1.0);\r\n}\r\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"XlcSDr","date":"1478909549","viewed":12895,"name":"Clickable Starfield","username":"iapafoto","description":"Click on Galaxies to go close. When close, click on it to enter inside. \nWhen inside, click on stars or clouds to go close or click another galaxy to go close to it.\nIf your computer is good enought you could try WITH_SUPERNOVA_REMNANT (by Duke)","likes":221,"published":1,"flags":48,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Created by sebastien durand - 11\/2016\n\/\/-------------------------------------------------------------------------------------\n\/\/ License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\/\/-------------------------------------------------------------------------------------\n\/\/ Some part of code are extracted, adaptated or inspired by\n\/\/\n\/\/ Planet Shadertoy by Reinder Nijhoff [https:\/\/www.shadertoy.com\/view\/4tjGRh]\n\/\/ Type 2 Supernova by Duke (https:\/\/www.shadertoy.com\/view\/lsyXDK) \n\/\/ Supernova remnant by Duke [https:\/\/www.shadertoy.com\/view\/MdKXzc]\n\/\/ Awesome star by Foxes [https:\/\/www.shadertoy.com\/view\/4lfSzS]\n\/\/ Black Body Spectrum plank by FabriceNeyret2 [https:\/\/www.shadertoy.com\/view\/4tdGWM]\n\/\/ Alien Beacon by otaviogood's [https:\/\/www.shadertoy.com\/view\/ld2SzK]\n\/\/ Hash without Sine by Dave_Hoskins [https:\/\/www.shadertoy.com\/view\/4djSRW]\n\/\/ Noise - value - 3D by iq [https:\/\/www.shadertoy.com\/view\/4sfGzS]\n\/\/ Smooth HSV by iq [https:\/\/www.shadertoy.com\/view\/MsS3Wc]\n\/\/ And many others  :)\n\/\/-------------------------------------------------------------------------------------\n\n\n\/\/ Some stranges behaviours detected under \n\/\/     Ubunto - Firefox and \n\/\/     Manjaro linux - chromium - ati 280\n\/\/  => strange navigation, star disaper when clicked\n \n\n#define WITH_INTERGALACTIC_CLOUDS\n\n\/\/ in progress\n\/\/#define WITH_PLANETS  \n\n\/\/ If fast enougth\n#define WITH_SUPERNOVA_REMNANT\n\/\/#define WITH_DOUBLE_GALAXY;\n\n\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\n\n#define SPIRAL_NOISE_ITER 6\n\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = (PI \/ 180.0);\n\n\/\/ Unit = 10 UA\nconst int   GALAXY_FIELD_VOXEL_STEPS = 16;\nconst int   GALAXY_FIELD_VOXEL_STEPS_HD = 7;\nconst float GALAXY_FIELD_VOXEL_STEP_SIZE = 250000.; \/\/ 2,500,000 AL\nconst float GALAXY_RADIUS = .015;  \/\/ (% of 250000)  50,000 AL\n\nconst int   STAR_FIELD_VOXEL_STEPS = 22;\nconst float STAR_FIELD_VOXEL_STEP_SIZE = .5;  \/\/ 5AL \nconst float STAR_RADIUS = .01; \/\/ 2e-8 in true life !   \/\/ (% of 5)   1e-8\n\nconst float PLANET_FIELD_SCALE = 75.;\nconst int   PLANET_FIELD_VOXEL_STEPS = 10;\nconst float PLANET_FIELD_VOXEL_STEP_SIZE = .5;  \/\/ 5AL \nconst float PLANET_RADIUS = .04;\n\n\nconst float kU2G = GALAXY_FIELD_VOXEL_STEP_SIZE\/STAR_FIELD_VOXEL_STEP_SIZE;\nconst float kG2U = STAR_FIELD_VOXEL_STEP_SIZE\/GALAXY_FIELD_VOXEL_STEP_SIZE;\n\nconst vec3  SUN_COLOR = vec3(.3, .21, .165);\n\nfloat time;\n\n\n\/\/-----------------------------------------------------\n\n\n#define IN_UNIVERSE 1.\n#define IN_GALAXY 2.\n#define IN_SOLAR_SYSTEM 3.\n\n#define MOVING     1.\n#define STATIONARY 2.\n\n#define NONE     0.\n#define GALAXY   1.\n#define STAR     2.\n#define PLANET   3.\n\n\nstruct Config {\n \tfloat movingMode;\n    float targetType;\n    float coordSystem;\n    float time;\n    vec3 ro_cam;\n    vec3 rd_cam;\n    vec3 target_pos;\n    vec3 galaxy_pos;\n};\n    \n\/\/--------------------------------------------------------------------\n\/\/ from iq shader Brick [https:\/\/www.shadertoy.com\/view\/MddGzf]\n\/\/--------------------------------------------------------------------\n\n#define CONF(id)  texture(iChannel0, vec2(id+.5,.5)\/ iChannelResolution[0].xy, -100.0).xyz;\n#define CONF4(id) texture(iChannel0, vec2(id+.5,.5)\/ iChannelResolution[0].xy, -100.0);\n\nConfig getConfig() { \n    vec4 v1 = CONF4(0.);\n    Config cfg;\n    \n    cfg.movingMode = v1.x > 1.5 ? STATIONARY : \n                     MOVING;\n    cfg.targetType = v1.y > 2.5 ? PLANET : \n    \t\t\t\t v1.y > 1.5 ? STAR:\n    \t\t\t\t v1.y > 0.5 ? GALAXY:\n    \t\t\t\t NONE;\n    cfg.coordSystem = v1.z > 2.5 ? IN_SOLAR_SYSTEM :\n    \t\t\t\t  v1.z > 1.5 ? IN_GALAXY :\t\t\t\t\n                      IN_UNIVERSE;\n    cfg.time = v1.w;\n    cfg.ro_cam = CONF(1.);\n    cfg.rd_cam = CONF(2.);\n    cfg.target_pos = CONF(3.);\n    cfg.galaxy_pos = CONF(4.);\n    return cfg;\n}\n\n\/\/-----------------------------------------------------\n\/\/ Paletes functions\n\/\/-----------------------------------------------------\n\n\/\/ from FabriceNeyret2 shader Black Body Spectrum plank [https:\/\/www.shadertoy.com\/view\/4tdGWM]\nvec3 blackBodyColor(float k) {\n    float T = (k*2.)*16000.;\n    vec3 c = vec3(1.,3.375,8.)\/(exp((19e3*vec3(1.,1.5,2.)\/T)) - 1.); \/\/ Planck law\n    return c \/ max(c.r,max(c.g,c.b));  \/\/ chrominance\n}\n\n\/\/-----------------------------------------------------\n\/\/ Noise functions\n\/\/-----------------------------------------------------\n\/\/ Hash without Sine by Dave_Hoskins [https:\/\/www.shadertoy.com\/view\/4djSRW]\n\/\/----------------------------------------------------------------------------------------\n\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n#define HASHSCALE1 .1031\n\nfloat hash(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  1 out, 2 in...\nfloat hash(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  1 out, 3 in...\nfloat hash(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec4 hash4(const in vec4 n) { return fract(sin(n)*1399763.5453123); }\n\n\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nvec4 hash43(vec3 p) {\n\tvec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n\treturn fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));\n}\n\n\/\/----------------------------------------------------------------------------------------\n\n\n\n\/\/ [iq] https:\/\/www.shadertoy.com\/view\/4sfGzS\nfloat noise(const in vec3 x) {\n    vec3 p = floor(x), f = fract(x);\n\tf *= f*(3.-f-f);\n\tvec2 uv = (p.xy+vec2(37.,17.)*p.z) + f.xy,\n\t     rg = textureLod( iChannel1, (uv+.5)\/256., -100.).yx;\n\treturn mix(rg.x, rg.y, f.z);\n}\n\nfloat pn(const in vec3 x) {\n    vec3 p = floor(x), f = fract(x);\n\tf *= f*(3.-f-f);\n\tvec2 uv = (p.xy+vec2(37.,17.)*p.z) + f.xy,\n\t     rg = textureLod( iChannel1, (uv+.5)\/256., -100.).yx;\n\treturn 2.4*mix(rg.x, rg.y, f.z)-1.;\n}\n\nfloat bm(const in vec3 x) {\n    vec3 p = floor(x), f = fract(x);\n\tf *= f*(3.-f-f);\n\tvec2 uv = (p.xy+vec2(37.,17.)*p.z) + f.xy,\n\t     rg = textureLod( iChannel1, (uv+ .5)\/256., -100.).yx;\n\treturn 1.-.82*mix(rg.x, rg.y, f.z);\n}\n\nfloat fpn(const in vec3 p) { \n    return pn(p*.06125)*.5 + \n           pn(p*.125)*.25 + \n           pn(p*.25)*.125;\/\/ + pn(p*.5)*.625;\n}\n\nfloat fbm(const in vec3 p) {\n   return bm(p*.06125)*.5 + \n          bm(p*.125)*.25 + \n          bm(p*.25)*.125 + \n          bm(p*.4)*.2;\n}\n\nconst mat3 msun = mat3(0., .8, .6, -.8, .36, -.48, -.6, -.48, .64);\n\nfloat smoothNoise(in vec3 q){\n\tfloat f  = .5000*noise(q); q=msun*q*2.01;\n          f += .2500*noise(q); q=msun*q*2.02;\n          f += .1250*noise(q); q=msun*q*2.03;\n          f += .0625*noise(q);\n\treturn f;\n}\n\n\/\/-------------------------------------------------------------------------------------\n\/\/ otaviogood's noise from https:\/\/www.shadertoy.com\/view\/ld2SzK\n\/\/--------------------------------------------------------------\n\/\/ This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n\/\/ It should work the same on all computers since it's not based on a hash function like some other noises.\n\/\/ It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 20.;\t\/\/ size of perpendicular vector\nfloat normalizer = 1.0 \/ sqrt(1.0 + nudge*nudge);\t\/\/ pythagorean theorem on that perpendicular to maintain scale\nfloat SpiralNoiseC(vec3 p, vec4 id) {\n    float iter = 2., n = 2.-id.x; \/\/ noise amount\n    for (int i = 0; i < SPIRAL_NOISE_ITER; i++) {\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) \/ iter; \/\/ add sin and cos scaled inverse with the frequency (abs for a ridged look)\n        p.xy += vec2(p.y, -p.x) * nudge; \/\/ rotate by adding perpendicular and scaling down\n        p.xy *= normalizer;\n        p.xz += vec2(p.z, -p.x) * nudge; \/\/ rotate on other axis\n        p.xz *= normalizer;  \n        iter *= id.y + .733733;          \/\/ increase the frequency\n    }\n    return n;\n}\n\nfloat mapIntergalacticCloud(vec3 p, vec4 id) {\n\tfloat k = 2.*id.w +.1;  \/\/ p\/=k;\n    return k*(.5 + SpiralNoiseC(p.zxy*.4132+333., id)*3. + pn(p*8.5)*.12);\n}\n\n#ifdef WITH_SUPERNOVA_REMNANT\n\nbool RaySphereIntersect(vec3 org, vec3 dir, out float near, out float far)\n{\n\tfloat b = dot(dir, org);\n\tfloat c = dot(org, org) - 8.;\n\tfloat delta = b*b - c;\n\tif( delta < 0.0) \n\t\treturn false;\n\tfloat deltasqrt = sqrt(delta);\n\tnear = -b - deltasqrt;\n\tfar = -b + deltasqrt;\n\treturn far > 0.0;\n} \n\nconst float nudge2 = .9;\t\/\/ size of perpendicular vector\nfloat normalizer2 = 1. \/ sqrt(1. + nudge2*nudge2);\t\/\/ pythagorean theorem on that perpendicular to maintain scale\nfloat SpiralNoiseC2(vec3 p) {\n    float n = 0., iter = 2.;\n    for (int i = 0; i < 8; i++) {\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) \/ iter;\t\/\/ abs for a ridged look\n        p.xy += vec2(p.y, -p.x) * nudge2;\n        p.xy *= normalizer2;\n        p.xz += vec2(p.z, -p.x) * nudge2;\n        p.xz *= normalizer2;\n        iter *= 1.733733;\n    }\n    return n;\n}\n\nfloat length2( vec2 p) {\n\treturn sqrt(p.x*p.x + p.y*p.y);\n}\n\nfloat length8(vec2 p) {\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow(p.x + p.y, .125);\n}\n\nfloat Disk(vec3 p, vec3 t) {\n    vec2 q = vec2(length2(p.xy)-t.x,p.z*0.5);\n    return max(length8(q)-t.y, abs(p.z) - t.z);\n}\n\nfloat mapSupernovaRemnant(vec3 p) {\n\tp*=2.;\n    float noi = Disk(p.xzy,vec3(2.0,1.8,1.25))+\n    \t+ fbm(p*90.)\n    \t+ SpiralNoiseC2(p.zxy*0.5123+100.0)*3.0;\n\treturn abs(noi*.5)+0.07;\n}\n\n#endif \/\/ WITH_SUPERNOVA_REMNANT\n\n\n\n\n\/\/-----------------------------------------------------\n\/\/ Intersection functions (mainly adapted from iq ones)\n\/\/-----------------------------------------------------\n\nbool intersectSphere(in vec3 ro, in vec3 rd, in float r, out float dist, out float edge) {\n\tfloat b = dot(rd,-ro), d = b*b - dot(ro,ro) + r*r;\n\tif (d < 0.) return false;\n    edge = sqrt(d);\n\tdist = b - edge;\n\treturn dist > 0.;\n}\n\nbool cylinder(vec3 ro, vec3 rd, float r, float h, out float tn, out float tf) {\n\tfloat a = dot(rd.xy, rd.xy), b = dot(ro.xy, rd.xy),\n\t\t  d = b*b - a*(dot(ro.xy, ro.xy) - r*r);    \n\tif(d < 0.) return false;\n\td = sqrt(d);\n\ttn = (-b - d)\/a; tf = (-b + d)\/a;\n\ta = min(tf, tn); tf = max(tf, tn); tn = a; \/\/ order roots\n\ta = ro.z + tn * rd.z;\n    b = ro.z + tf * rd.z;\n\t\/\/ top, bottom\n\tvec2 zcap = h*vec2(.5, -.5), cap = (zcap - ro.z) \/ rd.z;\n    tn = a < zcap.y ? cap.y : a > zcap.x ? cap.x : tn;\n\ttf = b < zcap.y ? cap.y : b > zcap.x ? cap.x : tf;\n    return tf > 0. && tf > tn;\n}\n\nfloat distanceRayPoint(vec3 ro, vec3 rd, vec3 p, out float h) {\n    h = dot(p-ro,rd);\n    return length(p-ro-rd*h);\n\t\/\/return length(cross(p-ro,rd));\n}\n\n\/\/ +------------------------------------------------------+\n\/\/ |                 Star ray effect                      |\n\/\/ +------------------------------------------------------+\n\n\/\/---------------------------------------------------------\n\/\/ Awesome star by Foxes [https:\/\/www.shadertoy.com\/view\/4lfSzS]\n\/\/---------------------------------------------------------\n \nfloat noise4q(vec4 x) {\n\tvec4 n3 = vec4(0,.25,.5,.75);\n\tvec4 p2 = floor(x.wwww+n3);\n\tvec4 b = floor(x.xxxx+n3) + floor(x.yyyy+n3)*157. + floor(x.zzzz +n3)*113.;\n\tvec4 p1 = b + fract(p2*.00390625)*vec4(164352., -164352., 163840., -163840.);\n\tp2 = b + fract((p2+1.0)*.00390625)*vec4(164352., -164352., 163840., -163840.);\n\tvec4 f1 = fract(x.xxxx+n3),f2 = fract(x.yyyy+n3);\n\tf1 *= f1*(3.0-f1-f1);\n\tf2 *= f2*(3.0-f2-f2);\n\tvec4 n1 = vec4(0,1.,157.,158.), \n         n2 = vec4(113.,114.,270.0,271.);\t\n\tvec4 vs1 = mix(hash4(p1), hash4(n1.yyyy+p1), f1),\n         vs2 = mix(hash4(n1.zzzz+p1), hash4(n1.wwww+p1), f1),\n         vs3 = mix(hash4(p2), hash4(n1.yyyy+p2), f1),\n         vs4 = mix(hash4(n1.zzzz+p2), hash4(n1.wwww+p2), f1);\t\n\tvs1 = mix(vs1, vs2, f2);\n\tvs3 = mix(vs3, vs4, f2);\n\tvs2 = mix(hash4(n2.xxxx+p1), hash4(n2.yyyy+p1), f1);\n\tvs4 = mix(hash4(n2.zzzz+p1), hash4(n2.wwww+p1), f1);\n\tvs2 = mix(vs2, vs4, f2);\n\tvs4 = mix(hash4(n2.xxxx+p2), hash4(n2.yyyy+p2), f1);\n\tvec4 vs5 = mix(hash4(n2.zzzz+p2), hash4(n2.wwww+p2), f1);\n\tvs4 = mix(vs4, vs5, f2);\n\tf1 = fract(x.zzzz+n3);\n\tf2 = fract(x.wwww+n3);\n\tf1 *= f1*(3.-f1-f1);\n\tf2 *= f2*(3.-f2-f2);\n\tvs1 = mix(vs1, vs2, f1);\n\tvs3 = mix(vs3, vs4, f1);\n\tvs1 = mix(vs1, vs3, f2);\n\tfloat r = dot(vs1,vec4(.25));\n\treturn r*r*(3.-r-r);\n}\n\n\/\/ rays of a star\nfloat ringRayNoise(vec3 ray, vec3 pos, float r, float size, float anim) {\n  \tfloat b = dot(ray,pos);\n    vec3 pr = ray*b-pos;\n    float c = length(pr),\n     \t  s = max(0.,(1.-size*abs(r-c)));\n    pr = pr\/c;\n    float n=.4, ns=1., nd = noise4q(vec4(pr*1.0,-anim+c))*2.0;\n    if (c > r) {\n        n  = noise4q(vec4(pr*10.0,-anim+c));\n        ns = noise4q(vec4(pr*50.0,-anim*2.5+ c+c))*2.;\n    }\n    n *= n*nd*nd*ns;\n    return s*s*(s*s+n);\n}\n\n\n\/\/ +------------------------------------------------------+\n\/\/ |                  Sun Lava effect                     |\n\/\/ +------------------------------------------------------+\n\nvec3 getSunColor(in vec3 p, in vec4 id, in float time) {\n    float lava = smoothNoise((p+vec3(time*.03))*50.*(.5+id.z) );\n    return blackBodyColor(.02+3.*clamp(id.x*id.x,.05,1.)*(1. - sqrt(lava)));\n}\n\nvec4 renderSun(in vec3 ro, in vec3 rd, in vec4 id, in float time) {\n\t\/\/ Rotate view to integrate sun rotation \n    \/\/ R(ro.zx, 1.6-time*.5*id.w);\n    \/\/ R(rd.zx, 1.6-time*.5*id.w);\n    vec4 color = vec4(0.);\n    float dist, edge;   \n    if (intersectSphere(ro, rd, 1., dist, edge)) {\n        vec3  pos = ro+rd*dist,\n        \t  nor = normalize(pos);\n    \tcolor = vec4(getSunColor(pos, id, time), smoothstep(0., .2, edge));\n    }\n    \/\/ Rays\n    float s3 = ringRayNoise(rd,ro,1.0,5.-4.*id.y,time);\n\tcolor.a = max(color.a, clamp(s3,0.,.98));\n    color.rgb += blackBodyColor(id.x)*s3;\n    color.rgb *=  1.-.03*cos(5.*time+2.*hash(time));  \/\/ twinkling;\n\treturn clamp(color, vec4(0.),vec4(1.));\n}\n\n\/\/ ---------------------------------------------------\n\/\/ Render Supernova Remnant\n\/\/ ---------------------------------------------------\n\/\/ Supernova remnant by Duke [https:\/\/www.shadertoy.com\/view\/MdKXzc]\n\/\/ ---------------------------------------------------\n\n#ifdef WITH_SUPERNOVA_REMNANT\n\nvec3 computeColorSR(float density, float radius) {\n\treturn mix( vec3(1.,.9,.8), vec3(.4,.15,.1), density)\n\t\t * mix( 7.*vec3(.8,1.,1.), 1.5*vec3(.48,0.53,.5), min( (radius+.5)\/.9, 1.15 ) );\n}\n\nvec4 renderSupernova(vec3 ro, vec3 rd) {\n\tfloat td=0., lDist, d, t;\n    const float h = .1;\n    vec4 sum = vec4(0.);\n    float min_dist=0., max_dist=0.;\n    vec3 pos;\n    \n    if (RaySphereIntersect(ro, rd, min_dist, max_dist)) {       \n        t = max(min_dist,0.) + .01*hash(rd);\n        for (int i=0; i<64; i++) {\n            if (td>.9 || sum.a > .99 || t>max_dist) break;\n            pos = ro + t*rd;\n            d = mapSupernovaRemnant(pos);\n            \/\/d = max(d, 0.);\n            \/\/ point light calculations\n            lDist = max(length(pos), .001);\n            sum+= vec4(.67,.75,1.,1.)\/(lDist*lDist*10.)*.0125; \/\/ star itself\n            sum+= vec4(1.,.5,.25,.6)\/exp(lDist*lDist*lDist*.08)*.033; \/\/ bloom\n            if (d<h) {\n                td += (1. - td) * (h - d) + .005;\n                vec4 col = vec4(computeColorSR(td,lDist), td*.2 );\n                sum.rgb += sum.a * sum.rgb * .2;\t\n                col.rgb *= col.a;\n                sum += col*(1. - sum.a);  \n            }\n            td += .014;\n            \/\/ trying to optimize step size near the camera and near the light source\n            t += max(d * .1 * max(min(lDist,length(ro)),1.0), 0.01);\n        }\n        \/\/ simple scattering\n      \/\/  sum *= 1. \/ exp( ld * 0.2 ) * 0.6;\n        sum = clamp(sum, 0., 1.);\n        sum.xyz *= sum.xyz*(3.-sum.xyz-sum.xyz);\n\t}    \n\treturn sum;\n}\n\n#endif\n\n\/\/ +----------------------------------------+\n\/\/ |               Galaxy                   |\n\/\/ +----------------------------------------+\n\nfloat spiralArm(in vec3 p, in float thickness, in float blurAmout, in float blurStyle) {\n    float dephase = 2., loop = 4.;\n    float a = atan(p.x,p.z),  \/\/ angle     \n\t\t  r = length(p.xz), lr = log(r), \/\/ distance to center\n    \t  th = .1-.25*r, \/\/ thickness according to distance\n    \t  d = fract(.5*(a-lr*loop)\/PI); \/\/apply rotation and scaling.\n    d = (.5\/dephase - abs(d-.5))*2.*PI*r;\n  \td *= (1.-lr)\/thickness;  \/\/ space fct of distance\n    \/\/ Perturb distance fiel1\n    float radialBlur = blurAmout*mix(fpn(8.*vec3(r*43.,40.*d,24.*p.y)),fpn(p*400.0), blurStyle);\n    return sqrt(d*d+10.*p.y*p.y\/thickness)-th*r*.2-radialBlur;\n}\n\nvoid galaxyTransForm(inout vec3 ro, const in vec4 id ) {\n    R(ro.yz, (id.y-.5));\n \/\/ R(ro.xy, .25*id.x*iTime);\n}\n\nfloat mapGalaxy(vec3 p, vec4 id) {  \n\tfloat d1 = spiralArm(p.xzy*.2, 10.*(.5+.5*id.x), .2+.3*id.y, id.z);\n#ifdef WITH_DOUBLE_GALAXY\n    if (id.z<.25) {\n   \t\tfloat d2 = spiralArm(vec3(-p.y,p.z,p.x)*.205, 10.*(.5+.5*id.x), .2+.3*id.y, id.z);        \n   \t\treturn min(d2, d1);\n     } \n#endif    \n     return d1;\n}\n\n\/\/ assign color to the media\nvec3 computeColor( float density, float radius ) {\n\t\/\/ color based on density alone, gives impression of occlusion within the media\n\treturn  mix(vec3(.25,.22,.2), vec3(.1,.0375,.025), density )*\n\t        mix(vec3(4.8,6.,6.),  vec3(.96,1.06,1.), min((radius+.5)*.5, 1.15)); \/\/ color added for disk\n}\n\nvec4 renderGalaxy(in vec3 ro, in vec3 rd, in vec4 id, in bool fast) { \n\tvec4 col, sum = vec4(0);\n    float min_dist=0., max_dist=100.;\n \n    galaxyTransForm(ro,id);\n    galaxyTransForm(rd,id);\n    \n    if (cylinder(ro, rd, 3.,3.5, min_dist, max_dist)) {\n        float ld, td=0., d, t;\n\t\tfloat lDist, lDist2;\n        vec3 pos, ldst, ldst2, lightColor;\n        const float h = .1;\n\n        t = max(min_dist,t) + .2*hash(rd+iTime);;\n\n        \/\/ raymarch loop\n        for (int i=0; i<48; i++)  {\n            \/\/ Loop break conditions.\n            if ((fast&&i>20) || td>.9 ||  sum.a > 0.99 || t>max_dist) break;\n\t\t\n            pos = ro + t*rd;\n            \n            d = mapGalaxy(3.5*pos, id); \/\/ evaluate distance function\n            d = abs(d)+.05;  \/\/ kind of countour drawing\n            d = max(d,.005); \/\/ change this string to control density \n            \n            if (d<h) {\n                \/\/ compute local density \n                ld = h - d;         \n                ld +=  clamp((ld - mapGalaxy(pos*3.5-.2*normalize(pos), id))*2.5, 0., 1. );\n                td += (1. - td) * ld + .005;\n                col = vec4(computeColor(td,length(pos)), td*.25 );\n                col.rgb *= col.a;\n                sum += col*(1. - sum.a);  \n            }\n\n            td += .014;\n            \/\/ point light calculations\n            ldst = pos*.25;\n            ldst2 = pos*.05;\n            ldst2.z *= 2.5;\n            lDist  = max(length(ldst),.0001); \/\/max(length(ldst), 0.001);\n            lDist2 = max(length(ldst2),.0001);\n            \/\/ star in center\n            lightColor = (1.-smoothstep(3.,4.5,lDist*lDist))*\n                mix(.07*vec3(1.,.5,.25)\/(lDist),\n                    .008*vec3(1.,1.7,2.)\/(lDist2), \n                    smoothstep(.2,.7,lDist));\n\n            \/\/ star in center\n            sum.rgb += lightColor\/(lDist*20.); \/\/add a bloom around the light\n            d = max(d, .04); \n            t +=  max(d * .3, .02);\n        }\n   \t\tsum = clamp(sum, 0., 1.);\n      \tsum.xyz *= sum.xyz*(3.-sum.xyz-sum.xyz);\n    }\n    \n    return sum;\n}\n\n\n\/\/--------------------------------------------------------------\n\/\/ Adapted from Planet Shadertoy - Reinder Nijhoff [https:\/\/www.shadertoy.com\/view\/4tjGRh]\n\/\/--------------------------------------------------------------\n\/\/ Toujours en coordonnes Univers\nvec4 renderGalaxyField(in vec3 roU, in vec3 rd, out vec3 out_posU, out vec3 out_id, in bool fast) { \n    out_id = vec3(9);\n      \n    float dint, d=0.;\n    vec3 offset, id, galaxyro,\n         ros = roU + rd*d,\n         pos = floor(ros),\n         ri = 1.\/rd,\n         rs = sign(rd),\n         dis = (pos-ros + .5 + rs*.5) * ri;\n\tvec4 col, sum = vec4(0);\n    \n\tfor( int i=0; i<GALAXY_FIELD_VOXEL_STEPS_HD; i++ ) {\n        \n        if (!fast || i!=0 ) {\/\/galaxyId != id) {\n            id = hash33(pos);\n        \toffset = clamp(id, GALAXY_RADIUS, 1.-GALAXY_RADIUS);\n       \t\td = distanceRayPoint(ros, rd, pos+offset, dint);\n        \tif (dint > 0. && d<GALAXY_RADIUS) {\n                galaxyro = ros-(pos+offset);\n                col = renderGalaxy(galaxyro\/GALAXY_RADIUS*3., rd, vec4(id,.5), fast);\n            \tcol.rgb *= smoothstep(float(GALAXY_FIELD_VOXEL_STEPS),0.,length(roU -pos));\n                out_id = id;\n                sum += (1.-sum.a)*col;\n                if (sum.a>.99)\n                    break;\n            }\n        }\n\t\tvec3 mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n    \n    if (!fast && sum.a<.99) {\n        for( int i=GALAXY_FIELD_VOXEL_STEPS_HD; i<GALAXY_FIELD_VOXEL_STEPS; i++ ) {\n            id = hash33(pos);\n            offset = clamp(id, GALAXY_RADIUS, 1.-GALAXY_RADIUS);\n            d = distanceRayPoint(ros, rd, pos+offset, dint);\n            if (dint > 0.) { \n                col = vec4(.9,.9,.8, 1.)*(1.-smoothstep(GALAXY_RADIUS*.25,GALAXY_RADIUS*.5,d));\n                col.rgb *= smoothstep(float(GALAXY_FIELD_VOXEL_STEPS),0.,length(roU -pos));\n                out_id = id;\n                sum += (1.-sum.a)*col;\n                if (sum.a>.99)\n                    break;\n            }\n\n            vec3 mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n            dis += mm * rs * ri;\n            pos += mm * rs;\n        }\n    }\n\n\treturn sum; \n}\n\n\/\/--------------------------------------------------------------\n\/\/ Adapted from Planet Shadertoy - Reinder Nijhoff [https:\/\/www.shadertoy.com\/view\/4tjGRh]\n\/\/--------------------------------------------------------------\n\/\/ Toujours en coordonnes Galaxy\nvec4 renderStarField(in vec3 roG, in vec3 rd, inout float out_dStar, out vec3 out_id) { \n    out_id = vec3(9);\n    \n    float dint, d = 0.;\n    vec3 offset, id,\n         ros = roG + rd*d,  \n         pos = floor(ros),\n         ri = 1.\/rd,\n         rs = sign(rd),\n         dis = (pos-ros + .5 + rs*.5) * ri;\n    vec4 col, sum = vec4(0);\n    \n    float pitch = 10. \/ iResolution.x;\n    \n\tfor( int i=0; i<STAR_FIELD_VOXEL_STEPS; i++ ) {\n        id = hash33(pos);\n        offset = clamp(id,STAR_RADIUS, 1.-STAR_RADIUS);\n        \n        d = distanceRayPoint(ros, rd, pos+offset, dint);\n        if (dint > 0.) { \n            if (dint < 2. && d<STAR_RADIUS) {\n                col =\n#ifdef WITH_SUPERNOVA_REMNANT\n                \tid.x>.8 ? renderSupernova((ros-(pos+offset))*3.\/STAR_RADIUS, rd) :\n#endif\n                renderSun((ros-(pos+offset))*2.\/STAR_RADIUS, rd, vec4(id,.5), iTime);\n                out_id = id;\n            \tif (col.a>.99) out_dStar = dint;\n            } else {\n                col = (vec4(blackBodyColor(max(id.x-.1, .01)), 1.)*(1.-smoothstep(STAR_RADIUS*.5,STAR_RADIUS,d)));\n            }\n            col.rgb *= smoothstep(float(STAR_FIELD_VOXEL_STEPS), .5, dint);\n            col.rgb *= col.a;\t\t\t\t                                \n            sum += (1.-sum.a)*col;\n            if (sum.a>.99)\n                break;\n        }\n\t\tvec3 mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n\treturn sum;\n}\n\n#ifdef WITH_PLANETS\n\nvec3 getPlanetColor(in vec3 p, vec4 id) {\n    float lava = smoothNoise(p*1.5*(5.*id.z) );\n    return blackBodyColor((.5+id.x)*(1. - pow(lava,2.*id.y))); \/\/ todo: le faire sur une constante\n}\n\nvec4 renderPlanet(in vec3 ro, in vec3 rd, in vec4 id, in vec3 lightDir, float dSun) {\n    vec4 color = vec4(0.);\n  \tfloat r = 1.;\n    float dist, edge;   \n    \n    if (intersectSphere(ro, rd, r, dist, edge)) {\n        if (dist<dSun) {\n\n            vec3  pos = ro+rd*dist,\n                  nor = normalize(pos);\n            float a = smoothstep(0., .8*r, edge); \n            vec3 oCol = getPlanetColor(pos, id);\n\n            vec3 norm = -normalize(pos);\n            float dif = clamp(dot(lightDir, norm), 0.0, 1.0);\n\n            vec3 h = normalize(-rd + lightDir);\n            float spe = pow(clamp(dot(h, norm), 0.0, 1.0), 4.0);\n\n            oCol = dif * oCol ;\n            oCol += dif * spe;\n            color = vec4(oCol, 1.);\n       }\n    }\n\treturn clamp(color, vec4(0.),vec4(1.));\n}\n\n\n\/\/ TODO ue 2D field ex: iq : https:\/\/www.shadertoy.com\/view\/4dSGW1\nvec4 renderPlanetField(in vec3 sunPos, in vec3 roG, in vec3 rd, inout float out_dStar, out vec3 out_id) { \n    out_id = vec3(9);\n\n    roG -= sunPos;\n    roG *= PLANET_FIELD_SCALE;\n    roG.z+=.5;\n    \n    float distSunDrawing = out_dStar*PLANET_FIELD_SCALE;\n    float rayon = 3.;\n    float min_dist=0., max_dist=100.;\n    \n    vec4 col, sum = vec4(0);\n\n  \/\/  if (cylinder(roG, rd, rayon, 1., min_dist, max_dist)) {\n        float dint, d = max(0., (length(roG)-rayon)); \/\/min_dist;\n        vec3 offset, id,\n             ros = roG + rd*d,  \n             pos = floor(ros),\n             ri = 1.\/rd,\n             rs = sign(rd),\n             dis = (pos-ros + .5 + rs*.5) * ri;\n\n        for( int i=0; i<PLANET_FIELD_VOXEL_STEPS; i++ ) {\n            if (length(pos) < rayon && abs(pos.z)<1. && hash(pos+sunPos)>.75) {\n                id = hash33(pos+sunPos);\n                offset = clamp(id,PLANET_RADIUS, 1.-PLANET_RADIUS);\n                offset.z = .5;\n\t\t\t\t\n                col = renderPlanet((ros-(pos+offset))\/PLANET_RADIUS, rd, vec4(id,.5), normalize((pos+offset)-ros), distSunDrawing);\n                out_id = id;\n                if (col.a>.95) out_dStar = dint;\n                col.rgb *= col.a;\t\t\t\t                                \n                sum += (1.-sum.a)*col;\n                if (sum.a>.99)\n                    break;\n            }\n            vec3 mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n            dis += mm * rs * ri;\n            pos += mm * rs;\n            \n        }\n  \/\/  }\n    return sum;\n}\n\n#endif\n\/\/ ---------------------------------------------------\n\/\/ Render intergalactic clouds\n\/\/ ---------------------------------------------------\n\n\n#ifdef WITH_INTERGALACTIC_CLOUDS\n\n\/\/-------------------------------------------------------------------------------------\n\/\/ Adapted from [iq: https:\/\/www.shadertoy.com\/view\/MsS3Wc]\n\/\/-------------------------------------------------------------------------------------\nvec3 hsv2rgb(float x, float y, float z) {\t\n\treturn z+z*y*(clamp(abs(mod(x*6.+vec3(0,4,2),6.)-3.)-1.,0.,1.)-1.);\n}\n\n\/\/-------------------------------------------------------------------------------------\n\/\/ Based on \"Type 2 Supernova\" by Duke (https:\/\/www.shadertoy.com\/view\/lsyXDK) \n\/\/-------------------------------------------------------------------------------------\nvec4 renderIntergalacticClouds(vec3 ro, vec3 rd, float tmax, const vec4 id) {\n    \n    float max_dist= min(tmax, float(STAR_FIELD_VOXEL_STEPS)),\n\t\t  td=0., d, t, noi, lDist, a, sp = 9.,         \n    \t  rRef = 2.*id.x,\n          h = .05+.25*id.z;\n    vec3 pos, lightColor;   \n    vec4 sum = vec4(0);\n   \t\n    t = .1*hash(hash(rd)); \n\n    for (int i=0; i<100; i++)  {\n\t    if(td>.9 ||  sum.a > .99 || t>max_dist) break;\n        a = smoothstep(max_dist,0.,t);\n        pos = ro + t*rd;\n        d = abs(mapIntergalacticCloud(pos, id))+.07;\n\n        \/\/ Light calculations\n        lDist = max(length(mod(pos+sp*.5,sp)-sp*.5), .001); \/\/ TODO add random offset\n        noi = pn(.05*pos);\n        lightColor = mix(hsv2rgb(noi,.5,.6), \n                         hsv2rgb(noi+.3,.5,.6), \n                         smoothstep(rRef*.5,rRef*2.,lDist));\n        sum.rgb += a*lightColor\/exp(lDist*lDist*lDist*.08)\/30.;\n\t\t\/\/ Edges coloring\n        if (d<h) {\n\t\t\ttd += (1.-td)*(h-d)+.005;  \/\/ accumulate density\n            sum.rgb += sum.a * sum.rgb * .25 \/ lDist;  \/\/ emission\t\n\t\t\tsum += (1.-sum.a)*.02*td*a;  \/\/ uniform scale density + alpha blend in contribution \n        } \n        td += .015;\n        t += max(d * .08 * max(min(lDist,d),2.), .01);  \/\/ trying to optimize step size\n    }\n    \n   \tsum = clamp(sum, 0., 1.);   \n    sum.xyz *= sum.xyz*(3.-sum.xyz-sum.xyz);\n\treturn sum;\n}\n\n#endif \n\n\/\/-----------------------------------------------------\n\/\/        Coordinate system conversions\n\/\/-----------------------------------------------------\n\nbool isInGalaxy(in vec3 roU, out vec3 out_GalaxyId, out vec3 out_GalaxyPosU) {\n    vec3 pos = floor(roU);\n    out_GalaxyId = hash33(pos);\n    vec3 offset = clamp(out_GalaxyId, GALAXY_RADIUS, 1.-GALAXY_RADIUS);\n    out_GalaxyPosU = (pos+offset);\n    return length(roU - out_GalaxyPosU) < GALAXY_RADIUS;\n}\n\n\/\/ Echelle 1 pour la grille des galaxies \nvec3 galaxyToUniverse(vec3 galaxyPosU, vec3 coord) {\n    return coord*kG2U + galaxyPosU;\n}\n\n\/\/ Centr\u00e9 sur le centre de la galaxie\n\/\/ Echelle 1 pour la grille des etoiles\nvec3 universeToGalaxy(vec3 galaxyPosU, vec3 coord) {\n    return (coord-galaxyPosU)*kU2G;\n}\n\n\n\n\/*\nfloat DigitBin( const int x )\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue( const vec2 vStringCoords, const float fValue, const float fMaxDigits, const float fDecimalPlaces )\n{\n    if ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.0;\n\tfloat fLog10Value = log2(abs(fValue)) \/ log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((fValue < 0.0) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n                float fReducedRangeValue = fValue;\n                if(fDigitIndex < 0.0) { fReducedRangeValue = fract( fValue ); fDigitIndex += 1.0; }\n\t\t\t\tfloat fDigitValue = (abs(fReducedRangeValue \/ (pow(10.0, fDigitIndex))));\n                fCharBin = DigitBin(int(floor(mod(fDigitValue, 10.0))));\n\t\t\t}\n        }\n\t}\n    return floor(mod((fCharBin \/ pow(2.0, floor(fract(vStringCoords.x) * 4.0) + (floor(vStringCoords.y * 5.0) * 4.0))), 2.0));\n}\n\/\/ Original interface\n\nfloat PrintValue(const in vec2 fragCoord, const in vec2 vPixelCoords, const in vec2 vFontSize, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces)\n{\n    vec2 vStringCharCoords = (fragCoord.xy - vPixelCoords) \/ vFontSize;\n    \n    return PrintValue( vStringCharCoords, fValue, fMaxDigits, fDecimalPlaces );\n}\n*\/\n\n\/\/-----------------------------------------------------\n\/\/ mainImage\n\/\/-----------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    vec2 p = -1. + 2. * uv;\n    p.x *= iResolution.x\/iResolution.y;\n    \n    vec3 col = vec3(0);\n    \n    \n\/\/ Lecture de la configuration -------------------------\n        Config cfg = getConfig();\n\n\t\tbool isU = cfg.coordSystem == IN_UNIVERSE,\n\t\t\t isG = cfg.coordSystem == IN_GALAXY;\n\n\/\/ camera ----------------------------------------------\n\n    vec3 ro, rdcam, ta, up;\n    ro = cfg.ro_cam; \n    rdcam = cfg.rd_cam;\n\n    \/\/ Leger tangage\n    up = normalize(vec3(.1*cos(.1*iTime), .3*cos(.1*iTime), 1.));\n    vec3 ww = normalize( rdcam ),\n         uu = normalize( cross(ww,up) ),\n         vv = normalize( cross(uu,ww)),\n         rd = normalize( -p.x*uu + p.y*vv + 2.*ww );\n\n\/\/ - Est t on dans une galaxie ? --------------------------------     \n    vec3 galaxyId, galaxyPosU;\n    bool inGalaxy = isInGalaxy(isU ? ro : galaxyToUniverse(cfg.galaxy_pos, ro), galaxyId, galaxyPosU);\n       \n\/\/ - rendu des etoiles -----------------------------------\n\n    bool isHitStar = false;\n\tvec3 starPosG, starId = vec3(90);  \n\tvec4 star = vec4(0);\n    if (inGalaxy) {\n        \/\/ Le calcul se fait toujours en coordonnees Galaxie       \n        vec3 roG = isU ? universeToGalaxy(cfg.galaxy_pos, ro) : ro;    \n        float dStar = 9999.;\n        star = renderStarField(roG, rd, dStar, starId ); \n    \n#ifdef WITH_PLANETS    \n        vec3 id0, posSun;\n        if (cfg.targetType == STAR) {\n            posSun = cfg.target_pos;\n        } else if (cfg.targetType == PLANET) {\n\t        id0 = hash33(floor(cfg.target_pos));\n            posSun = floor(cfg.target_pos) + clamp(id0, STAR_RADIUS, 1.-STAR_RADIUS);\n        } else {\n        \tid0 = hash33(floor(roG));\n        \tposSun = floor(roG) + clamp(id0, STAR_RADIUS, 1.-STAR_RADIUS);\n        }\n            \n        float dPlanet = dStar;\n        vec3 planetPosG, planetId = vec3(90);  \n        vec4 planet = renderPlanetField(posSun, roG, rd, dPlanet, planetId);  \n        star = planet + (1.-planet.a) *sqrt(star)*star.a;\n#endif \n        \n#ifdef WITH_INTERGALACTIC_CLOUDS\n        vec4 clouds = renderIntergalacticClouds(roG, rd, dStar, vec4(0.5,0.4,0.16,0.7));\n        star = clouds + (1.-clouds.a) *sqrt(star)*star.a;\n#endif        \n        \n    }\n\n\/\/ - rendu des galaxies ----------------------------------\n\n    vec3 targetPosU, targetId = vec3(90);\n    \/\/ Le calcul se fait toujours en coordonnees univers\n\tvec3 roU = isG ? galaxyToUniverse(cfg.galaxy_pos, ro) : ro;\n\tvec4 colGalaxy = renderGalaxyField(roU, rd, targetPosU, targetId, isG);\n\n    star.rgb += colGalaxy.rgb* (1. - star.a);\n\n    col = star.rgb;\n    \n    \n \/\/   float digit = PrintValue(fragCoord, iResolution.xy*vec2(.0,.7), vec2(20.), cfg.galaxy_pos.x, 8., 10.);\n \/\/   digit += PrintValue(fragCoord, iResolution.xy*vec2(.0,.6), vec2(20.), cfg.galaxy_pos.y, 8., 10.);\n \/\/   digit += PrintValue(fragCoord, iResolution.xy*vec2(.0,.5), vec2(20.), cfg.galaxy_pos.z, 8., 10.);\n \/\/\tcol = mix(col, vec3(1,0,0), digit);\n    \n    fragColor = vec4((isU ? vec3(0.03,0.,.1)+col : col), 1.);\n \n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"\/presets\/tex00.jpg","previewfilepath":"\/presets\/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ in progress\n\/\/#define WITH_PLANETS  \n\n\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = (PI \/ 180.0);\nconst float MAX = 10000.0;\n\n\/\/ Unit = 10 UA\nconst int   GALAXY_FIELD_VOXEL_STEPS = 10;\nconst float GALAXY_FIELD_VOXEL_STEP_SIZE = 250000.; \/\/ 2,500,000 AL\nconst float GALAXY_RADIUS = .015;  \/\/ (% of 250000)  50,000 AL\n\nconst int   STAR_FIELD_VOXEL_STEPS = 13;\nconst float STAR_FIELD_VOXEL_STEP_SIZE = .5;  \/\/ 5AL \nconst float STAR_RADIUS = .01; \/\/ 2e-8 in true life !   \/\/ (% of 5)   1e-8\n\nconst float PLANET_FIELD_SCALE = 75.;\nconst int   PLANET_FIELD_VOXEL_STEPS = 10;\nconst float PLANET_FIELD_VOXEL_STEP_SIZE = .5;  \/\/ 5AL \nconst float PLANET_RADIUS = .04; \n\n\nconst float kU2G = GALAXY_FIELD_VOXEL_STEP_SIZE\/STAR_FIELD_VOXEL_STEP_SIZE;\nconst float kG2U = STAR_FIELD_VOXEL_STEP_SIZE\/GALAXY_FIELD_VOXEL_STEP_SIZE;\n\n\n\n\nfloat time;\n\nfloat keyPress(int ascii) {\n\treturn texture(iChannel2,vec2((.5+float(ascii))\/256.,0.25)).x ;\n}\n\n\n\n\n\n\/\/ Time spend traveling to clicked point\n#define TRAVEL_DELAY 4.\n\n#define IN_UNIVERSE 1.\n#define IN_GALAXY 2.\n#define IN_SOLAR_SYSTEM 3.\n\n#define MOVING     1.\n#define STATIONARY 2.\n\n#define NONE     0.\n#define GALAXY   1.\n#define STAR     2.\n#define PLANET   3.\n\nstruct Config {\n \tfloat movingMode;\n    float targetType;\n    float coordSystem;\n    float time;\n    vec3 ro_cam;\n    vec3 rd_cam;\n    vec3 target_pos;\n    vec3 galaxy_pos;\n    vec3 ro_from;\n    vec3 ro_to;\n    vec3 rd_from;\n    vec3 rd_to;\n};\n    \n    \n#define HASHSCALE1 .1031\nfloat hash(vec3 p3) {\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\/*\nvec3 hash33( const in vec3 p) {\n    return fract(vec3(\n        sin(dot(p,    vec3(127.1,311.7,758.5453123))),\n        sin(dot(p.zyx,vec3(127.1,311.7,758.5453123))),\n        sin(dot(p.yxz,vec3(127.1,311.7,758.5453123))))*43758.5453123);\n}\n*\/\n\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n\/\/#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\nvec3 hash33(vec3 p3){\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nfloat distanceRayPoint(vec3 ro, vec3 rd, vec3 p, out float h) {\n    h = dot(p-ro,rd);\n    return length(p-ro-rd*h);\n}\n\n\/\/ Toujours en coordonnes Univers\nbool renderGalaxyField( in vec3 roU, in vec3 rd, out vec3 out_posU, out vec3 out_id) { \n    float d, dint;\n    vec3 ros = roU + rd*d,   \n\t\tpos = floor(ros),\n\t\tri = 1.\/rd,\n\t\trs = sign(rd),\n\t\tdis = (pos-ros + 0.5 + rs*0.5) * ri,\n\t\toffset, id, galaxyro;\n    \n    float pitch = 10.\/iResolution.x;\n    \n\tfor( int i=0; i<GALAXY_FIELD_VOXEL_STEPS; i++ ) {\n        id = hash33(pos);\n        offset = clamp(id, GALAXY_RADIUS, 1.-GALAXY_RADIUS);\n        \n        \/\/ Si on intersectionne avec la boundingbox (sphere)\n        d = distanceRayPoint(ros, rd, pos+offset, dint);\n        if( dint > 0. && d < GALAXY_RADIUS*.5+dint*pitch ) {\n            galaxyro = pos+offset;\n            out_posU = galaxyro;\n        \tout_id = id;\n        \treturn true;\t    \n        }\n        \n\t\tvec3 mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n    \n\treturn false;\n}\n\n\n\n\/\/ Toujours en coordonnes Galaxy\nbool renderStarField(vec3 galaxyId, in vec3 roG, in vec3 rd, out vec3 out_posG, out vec3 out_id) { \n    out_id = vec3(9);\n\n    float d, dint;\n    vec3 ros = roG + rd*d,\n\t \tpos = floor(ros),\n\t\tri = 1.\/rd,\n\t\trs = sign(rd),\n\t\tdis = (pos-ros + 0.5 + rs*0.5) * ri,\t\n\t\tmm, offset = vec3(0.), id, galaxyro;\n\n    float pitch = 10.\/iResolution.x;\n    \n\tfor( int i=0; i<STAR_FIELD_VOXEL_STEPS; i++ ) {\n        id = hash33(pos);\n        offset = clamp(id, STAR_RADIUS, 1.-STAR_RADIUS);\n        d = distanceRayPoint(ros, rd, pos+offset, dint);\n        if (dint > 0. && d < STAR_RADIUS*.5+dint*pitch) {\n\t        out_posG = pos+offset;\n   \t     \tout_id = id;\n        \treturn true;\n        }\n\t\tmm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n\n\treturn false;\n}\n\n\n#ifdef WITH_PLANETS\n\nbool renderPlanetField(in vec3 sunPos, in vec3 roG, in vec3 rd, out vec3 out_posG, out vec3 out_id) { \n    out_id = vec3(9);\n    float scale = 50.;\n    roG -= sunPos;\n    roG *= PLANET_FIELD_SCALE;\n    roG.z+=.5;\n\n    float rayon = 3.;\n    float min_dist=0., max_dist=100.;\n    \n    vec4 col, sum = vec4(0);\n    float pitch = 10.\/iResolution.x;\n    float dint, d = max(0., (length(roG)-rayon)); \/\/min_dist;\n    vec3 offset, id,\n        ros = roG + rd*d,  \n        pos = floor(ros),\n        ri = 1.\/rd,\n        rs = sign(rd),\n        dis = (pos-ros + .5 + rs*.5) * ri;\n\n    for( int i=0; i<PLANET_FIELD_VOXEL_STEPS; i++ ) {\n        if (length(pos) < rayon && abs(pos.z)<1. && hash(pos+sunPos)>.75) {\n            id = hash33(pos+sunPos);\n            offset = clamp(id,PLANET_RADIUS, 1.-PLANET_RADIUS);\n            offset.z = .5;\n            d = distanceRayPoint(ros, rd, pos+offset, dint);\n            if(dint > 0. && d<PLANET_RADIUS+dint*pitch ) {\n                vec3 pp = pos+offset;\n                pp.z-=.5;\n                out_posG = (pp\/scale)+sunPos;\n                out_id = id;\n                return true;\n            }\n        }\n        vec3 mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n        dis += mm * rs * ri;\n        pos += mm * rs;\n\n    }\n    return false;\n}\n\n#endif\n    \n\/\/--------------------------------------------------------------------\n\/\/ from iq shader Brick [https:\/\/www.shadertoy.com\/view\/MddGzf]\n\/\/--------------------------------------------------------------------   \nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-.5-c) - .5; return -max(d.x,d.y); }\nvoid store( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord) {\n    fragColor = ( isInside(fragCoord,re) > 0. ) ? va : fragColor;\n}\nvoid store( in vec2 re, in vec3 va, inout vec4 fragColor, in vec2 fragCoord) {\n    fragColor = ( isInside(fragCoord,re) > 0. ) ? vec4(va,0.) : fragColor;\n}\n\/\/--------------------------------------------------------------------\n\n\nvoid saveConfig(Config cfg, inout vec4 c, in vec2 f) {\n\tstore(vec2(0.,0.), vec4(cfg.movingMode, cfg.targetType, cfg.coordSystem, cfg.time), c, f);\n\tstore(vec2(1.,0.), cfg.ro_cam,    c, f);\n\tstore(vec2(2.,0.), cfg.rd_cam,    c, f);\n\tstore(vec2(3.,0.), cfg.target_pos,c, f);\n    store(vec2(4.,0.), cfg.galaxy_pos,c, f);\n\tstore(vec2(5.,0.), cfg.ro_from,   c, f);\n    store(vec2(6.,0.), cfg.ro_to,     c, f);\n    store(vec2(7.,0.), cfg.rd_from,   c, f);\n    store(vec2(8.,0.), cfg.rd_to,     c, f);\n}\n\n#define CONF(id)  texture(iChannel0, vec2(id+.5,.5)\/ iChannelResolution[0].xy, -100.0).xyz;\n#define CONF4(id) texture(iChannel0, vec2(id+.5,.5)\/ iChannelResolution[0].xy, -100.0);\nConfig getConfig() { \n    vec4 v1        = CONF4(0.);\n    Config cfg;\n    cfg.movingMode = v1.x > 1.5 ? STATIONARY : \n                     MOVING;\n    cfg.targetType = v1.y > 2.5 ? PLANET : \n    \t\t\t\t v1.y > 1.5 ? STAR:\n    \t\t\t\t v1.y > 0.5 ? GALAXY:\n    \t\t\t\t NONE;\n    cfg.coordSystem =v1.z > 2.5 ? IN_SOLAR_SYSTEM :\n    \t\t\t\t v1.z > 1.5 ? IN_GALAXY :\t\t\t\t\n                     IN_UNIVERSE;\n    cfg.time = v1.w;\n    cfg.ro_cam     = CONF(1.);\n    cfg.rd_cam     = CONF(2.);\n    cfg.target_pos = CONF(3.);\n    cfg.galaxy_pos = CONF(4.);\n    cfg.ro_from    = CONF(5.);\n    cfg.ro_to      = CONF(6.);\n    cfg.rd_from    = CONF(7.);\n    cfg.rd_to      = CONF(8.);\n    return cfg;\n}\n\n\nbool isInGalaxy(in vec3 roU, out vec3 out_GalaxyId, out vec3 out_GalaxyPosU) {\n    vec3 pos = floor(roU);\n    out_GalaxyId = hash33(pos);\n    \n    vec3 offset = clamp(out_GalaxyId, GALAXY_RADIUS, 1.-GALAXY_RADIUS);\n    out_GalaxyPosU = (pos+offset);\n    \n    return length(roU - out_GalaxyPosU) < GALAXY_RADIUS;\n}\n\n\/\/ Echelle 1 pour la grille des galaxies \nvec3 galaxyToUniverse(vec3 galaxyPosU, vec3 coord) {\n    return coord*kG2U + galaxyPosU;\n}\n\n\/\/ Centr\u00e9 sur le centre de la galaxie\n\/\/ Echelle 1 pour la grille des etoiles\nvec3 universeToGalaxy(vec3 galaxyPosU, vec3 coord) {\n    return (coord-galaxyPosU)*kU2G;\n}\n\nConfig galaxyToUniverse(vec3 galaxyPosU, Config cfg) {\n\tcfg.coordSystem = IN_UNIVERSE;\n    cfg.galaxy_pos = galaxyPosU;\n    cfg.ro_cam =  galaxyToUniverse(galaxyPosU, cfg.ro_cam);\n    cfg.ro_from = galaxyToUniverse(galaxyPosU, cfg.ro_from);\n    cfg.ro_to =   galaxyToUniverse(galaxyPosU, cfg.ro_to);\n    cfg.target_pos = galaxyToUniverse(galaxyPosU, cfg.target_pos);\n    return cfg;\n}\n\nConfig universeToGalaxy(vec3 galaxyPosU, Config cfg) {\n\tcfg.coordSystem = IN_GALAXY;\n    cfg.galaxy_pos = galaxyPosU;\n    cfg.ro_cam =  universeToGalaxy(galaxyPosU, cfg.ro_cam);\n    cfg.ro_from = universeToGalaxy(galaxyPosU, cfg.ro_from);\n    cfg.ro_to =   universeToGalaxy(galaxyPosU, cfg.ro_to);\n    cfg.target_pos = universeToGalaxy(galaxyPosU, cfg.target_pos);\n\treturn cfg;\n}\n\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\t\n    if (fragCoord.y > 0.5 || fragCoord.x > 10.) discard;\n            vec2 uv = iMouse.xy \/ iResolution.xy;\n        vec2 p = -1.0 + 2.0 * uv;\n        p.x *= iResolution.x\/iResolution.y;\n\n\/\/ - Initialisation si besoin -------------------------\n    Config cfg;    \n    if(iFrame < 10) { \n        \n        cfg.rd_cam = normalize(vec3(1.,0.,0.));\n \n        vec3 pos = floor(vec3(10.));\n        vec3 id = hash33(pos),\n        offset = clamp(id, GALAXY_RADIUS, 1.-GALAXY_RADIUS);\n        cfg.ro_cam = pos + offset-.03*cfg.rd_cam;\n        vec3 mov = .03*cfg.rd_cam;\n        vec3 center = cfg.ro_cam + mov; \n        R(mov.yz, 1.);\n        R(mov.xy, 1.);\n        cfg.ro_cam = center - mov;\n        cfg.rd_cam = normalize(mov);\n        \n        cfg.movingMode = STATIONARY;\n        cfg.targetType = GALAXY;\n        cfg.coordSystem = IN_UNIVERSE;\n        cfg.time = iTime;\n        cfg.ro_from = cfg.ro_cam;\n        cfg.rd_from = cfg.rd_cam;\n        cfg.ro_to = cfg.ro_cam;\n        cfg.rd_to = cfg.rd_cam;\n        cfg.galaxy_pos = vec3(0);\n        cfg.target_pos = vec3(1);\/\/center;\n\n    } else {\n\n\/\/ - Lecture de la configuration -----------------------\n        cfg = getConfig();\n\n\t\tbool isU = (cfg.coordSystem == IN_UNIVERSE),\n\t\t\t isG = (cfg.coordSystem == IN_GALAXY);\n\n        float time = iTime - cfg.time;\n        \n\/\/ - Camera --------------------------------------------        \n        vec3 ro, ta, rd_cam, up;\n        float smoth = smoothstep(0., TRAVEL_DELAY, time);\n        \n        if (cfg.movingMode == MOVING) { \n            ro =     mix(cfg.ro_from, cfg.ro_to, smoth);\n            rd_cam = mix(cfg.rd_from, cfg.rd_to, smoth);\n        } else {\n            \/\/ rotation autour de la cible\n            if (cfg.targetType != NONE) {                \n                vec3 mov = cfg.rd_to*(cfg.targetType==PLANET?(.03\/PLANET_FIELD_SCALE):.03);\n                vec3 center = cfg.ro_to + mov; \n                R(mov.yz, .05*smoth*time);\n                R(mov.xy, .05*smoth*time);\n                ro = center - mov;\n                rd_cam = normalize(mov);\n            } else {\n                \/\/ ballade\n\t        \tro = cfg.ro_cam+.005*cfg.rd_cam;\n    \t        rd_cam = cfg.rd_cam;\n                R(rd_cam.yz, .002);\n            }\n        }\n        \n        \/\/ leger tangage\n        up = normalize(vec3(.1*cos(.1*iTime), .3*cos(.1*iTime), 1.));\n\n        vec3 ww = normalize(rd_cam),\n        \t uu = normalize(cross(ww,up)),\n        \t vv = normalize(cross(uu,ww)),\n        \t rd = normalize(-p.x*uu + p.y*vv + 2.*ww );\n\n\/\/ - Est t on dans une galaxie ? --------------------------------     \n        vec3 galaxyId, galaxyPosU;\n        bool inGalaxy = isInGalaxy(isU ? ro : galaxyToUniverse(cfg.galaxy_pos, ro), galaxyId, galaxyPosU);\n\n\/\/ - Recherche des clicks sur les objets\n        vec3 targetPosU, targetPosG, targetId;\n     \n        \/\/ - Click Galaxy Field ------------------------------------------\n\n        bool isHitGalaxy = false, isHitStar = false, isHitPlanet = false;\n\n        \/\/ Le calcul se fait toujours en coordonnees univers\n        vec3 roU = isG ? galaxyToUniverse(cfg.galaxy_pos, ro) : ro;\n        isHitGalaxy = renderGalaxyField( roU, rd, targetPosU, targetId);\n        if (isG && length(roU - targetPosU) > 3.) isHitGalaxy = false;\n        if (isHitGalaxy) {\n            targetPosG = universeToGalaxy(cfg.galaxy_pos,targetPosU);    \n        }\n\/\/ - Click Star Field ------------------------------------------\n\n        if (isG && !isHitGalaxy) {\n            \/\/ Le calcul se fait toujours en coordonnees Galaxie       \n            vec3 roG = ro;    \n            isHitStar = renderStarField(galaxyId, roG, rd, targetPosG, targetId );\n\t\t\tif (isHitStar) targetPosU = galaxyToUniverse(cfg.galaxy_pos,targetPosG);                 \n            \n#ifdef WITH_PLANETS\n            vec3 id0 = hash33(floor(roG));\n        \tvec3 posSun = floor(roG) + clamp(id0, STAR_RADIUS, 1.-STAR_RADIUS);            \n            isHitPlanet = renderPlanetField(posSun, roG, rd, targetPosG, targetId);\n            if (isHitPlanet) targetPosU = galaxyToUniverse(cfg.galaxy_pos,targetPosG);                 \n#endif\n        }\n        \n\n\n\/\/ - Generate new Configuration ----------------------------\n\n        cfg.ro_cam = ro;\n        cfg.rd_cam = rd_cam;\n\n        \/\/ On est en mode attente\n        if (cfg.movingMode == STATIONARY) { \/\/ stationary\n            \n            \/\/ click en cours\n            bool isClick = (iMouse.z != 0. && abs(iMouse.z - iMouse.x) < 3. && abs(iMouse.w - iMouse.y) <3.)\n                           || (keyPress(32) >.5);\n\n            if (isClick) {\n                \/\/ On va declancher un mouvement vers le point cliqu\u00e9\n\t\t\t\tcfg.targetType = \n                    \tisHitGalaxy ? GALAXY :\n                \t\tisHitStar ? STAR :\n                \t\tisHitPlanet ? PLANET : NONE;\n                cfg.ro_from = ro;\n                cfg.ro_to = \n                    isHitGalaxy ? (isU ? targetPosU-(cfg.target_pos==vec3(1)||targetPosU==cfg.target_pos?0.:.03)*rd : targetPosG-.03*rd*kU2G) : \/\/ vers la cible\n                    isHitStar ? targetPosG-.03*rd :\n                \tisHitPlanet ? targetPosG-.06*rd\/PLANET_FIELD_SCALE :\n                    ro + 3.*rd; \/\/ 3 unitees dans la direction du click\n\n                cfg.rd_from = rd_cam;\n                cfg.rd_to = rd;\n                cfg.movingMode = MOVING;            \n                cfg.time = iTime;\n                cfg.target_pos = isU ? targetPosU : targetPosG;\n                \/\/((isHitGalaxy && targetId!=cfg.target_id)) ? targetId : isHitStar ? vec3(.5) : isHitPlanet ? vec3(9.) : vec3(0.);\n            }\n            \n        } else { \n          \/\/ En mouvement vers une cible\n            if (isU && inGalaxy) {\n                \/\/ On vient de rentrer dans une galaxie, on change de coordonnes pour garder la precision\n                cfg = universeToGalaxy(galaxyPosU, cfg);\n                \n            } else if (isG && !inGalaxy) {\n                if (length(ro)*kG2U > GALAXY_RADIUS*3.) {\n                \/\/ On vient de sortir de la galaxy, on change de systeme de coordonnes pour garder la precision   \n       \t\t\t\tcfg = galaxyToUniverse(galaxyPosU, cfg);\n                }\n            } \n          \n            if (iTime - cfg.time > TRAVEL_DELAY+1.) {\n                cfg.movingMode = STATIONARY;            \n                cfg.time = iTime;  \n            }\n        }\n\n    }\n    \n    \n\/\/ - Save new Configuration -----------------------------------\n    fragColor = vec4(0.);\n    saveConfig(cfg, fragColor, fragCoord);\n}\n\n\n","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"XsKGRW","date":"1453904549","viewed":12889,"name":"Full Scene Radial Blur","username":"Shane","description":"Applying some God rays, post process, to a simple raymarched scene. Inspired by Passion's \"Blue Dream\" ... and a lot of old demos. :)","likes":172,"published":3,"flags":32,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/*\n\tFull Scene Radial Blur\n\t----------------------\n\n\tRadial blur - as a postprocessing effect - is one of the first things I considered doing \n\twhen the multipass system came out. I've always loved this effect. Reminds me of the early \n\tdemos from Aardbei et al. \n\n\tAnyway, Shadertoy user, Passion, did a really cool radial blur on a field of spheres that\n\tinspired me to do my own. Radial blurs are pretty straight forward, but it was still\n    helpful to have Passion's version as a guide. \n\n    As for the radial blur process, there's not much to it. Start off at the pixel position, \n    then radiate outwards gathering up pixels with decreased weighting. The result is a\n\tblurring of the image in a radial fashion, strangely enough. :)\n\n\tInspired by:\n\n\tBlue Dream - Passion\n\thttps:\/\/www.shadertoy.com\/view\/MdG3RD\n\n\tRadial Blur - IQ\n\thttps:\/\/www.shadertoy.com\/view\/4sfGRn\n\n\tRays of Blinding Light - mu6k\n\thttps:\/\/www.shadertoy.com\/view\/lsf3Dn\n\n*\/\n\n\/\/ The radial blur section. Shadertoy user, Passion, did a good enough job, so I've used a\n\/\/ slightly trimmed down version of that. By the way, there are accumulative weighting \n\/\/ methods that do a slightly better job, but this method is good enough for this example.\n\n\n\/\/ Radial blur samples. More is always better, but there's frame rate to consider.\nconst float SAMPLES = 24.; \n\n\n\/\/ 2x1 hash. Used to jitter the samples.\nfloat hash( vec2 p ){ return fract(sin(dot(p, vec2(41, 289)))*45758.5453); }\n\n\n\/\/ Light offset.\n\/\/\n\/\/ I realized, after a while, that determining the correct light position doesn't help, since \n\/\/ radial blur doesn't really look right unless its focus point is within the screen boundaries, \n\/\/ whereas the light is often out of frame. Therefore, I decided to go for something that at \n\/\/ least gives the feel of following the light. In this case, I normalized the light position \n\/\/ and rotated it in unison with the camera rotation. Hacky, for sure, but who's checking? :)\nvec3 lOff(){    \n    \n    vec2 u = sin(vec2(1.57, 0) - iTime\/2.);\n    mat2 a = mat2(u, -u.y, u.x);\n    \n    vec3 l = normalize(vec3(1.5, 1., -0.5));\n    l.xz = a * l.xz;\n    l.xy = a * l.xy;\n    \n    return l;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \/\/ Screen coordinates.\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n\n    \/\/ Radial blur factors.\n    \/\/\n    \/\/ Falloff, as we radiate outwards.\n    float decay = 0.97; \n    \/\/ Controls the sample density, which in turn, controls the sample spread.\n    float density = 0.5; \n    \/\/ Sample weight. Decays as we radiate outwards.\n    float weight = 0.1; \n    \n    \/\/ Light offset. Kind of fake. See above.\n    vec3 l = lOff();\n    \n    \/\/ Offset texture position (uv - .5), offset again by the fake light movement.\n    \/\/ It's used to set the blur direction (a direction vector of sorts), and is used \n    \/\/ later to center the spotlight.\n    \/\/\n    \/\/ The range is centered on zero, which allows the accumulation to spread out in\n    \/\/ all directions. Ie; It's radial.\n    vec2 tuv =  uv - .5 - l.xy*.45;\n    \n    \/\/ Dividing the direction vector above by the sample number and a density factor\n    \/\/ which controls how far the blur spreads out. Higher density means a greater \n    \/\/ blur radius.\n    vec2 dTuv = tuv*density\/SAMPLES;\n    \n    \/\/ Grabbing a portion of the initial texture sample. Higher numbers will make the\n    \/\/ scene a little clearer, but I'm going for a bit of abstraction.\n    vec4 col = texture(iChannel0, uv.xy)*0.25;\n    \n    \/\/ Jittering, to get rid of banding. Vitally important when accumulating discontinuous \n    \/\/ samples, especially when only a few layers are being used.\n    uv += dTuv*(hash(uv.xy + fract(iTime))*2. - 1.);\n    \n    \/\/ The radial blur loop. Take a texture sample, move a little in the direction of\n    \/\/ the radial direction vector (dTuv) then take another, slightly less weighted,\n    \/\/ sample, add it to the total, then repeat the process until done.\n    for(float i=0.; i < SAMPLES; i++){\n    \n        uv -= dTuv;\n        col += texture(iChannel0, uv) * weight;\n        weight *= decay;\n        \n    }\n    \n    \/\/ Multiplying the final color with a spotlight centered on the focal point of the radial\n    \/\/ blur. It's a nice finishing touch... that Passion came up with. If it's a good idea,\n    \/\/ it didn't come from me. :)\n    col *= (1. - dot(tuv, tuv)*.75);\n    \n    \/\/ Smoothstepping the final color, just to bring it out a bit, then applying some \n    \/\/ loose gamma correction.\n    fragColor = sqrt(smoothstep(0., 1., col));\n    \n    \/\/ Bypassing the radial blur to show the raymarched scene on its own.\n    \/\/fragColor = sqrt(texture(iChannel0, fragCoord.xy \/ iResolution.xy));\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGRn","filepath":"\/media\/a\/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"\/media\/ap\/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ The scene itself. Not much commenting, since this is mainly about the radial blur,\n\/\/ plus a lot of it is rudimentary.\n\n#define FAR 20.\n\n\/\/ Hash.\nfloat hash( float n ){ return fract(cos(n)*45758.5453); }\n\n\n\/\/ Tri-Planar blending function. Based on an old Nvidia writeup:\n\/\/ GPU Gems 3 - Ryan Geiss: http:\/\/http.developer.nvidia.com\/GPUGems3\/gpugems3_ch01.html\nvec3 tpl( sampler2D t, in vec3 p, in vec3 n ){\n   \n    n = max(abs(n), 0.001);\n    n \/= (n.x + n.y + n.z );  \n\tp = (texture(t, p.yz)*n.x + texture(t, p.zx)*n.y + texture(t, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n\/\/ A simple, cheap but visually effective sinusoid based lattice. The downside to building\n\/\/ a scene with transcendentals is the honing difficulty, but the logarithmic based\n\/\/ \"Logarithmmic Bisection\" tracing method counters that.\nfloat map(in vec3 p){\n   \n    \/\/ A few small bumps to put on the surface.\n    float bump = (dot(sin(p*24. - cos(p.yzx*36.)), vec3(.015)));\n    \n    \/\/ Perturbing the surface slightly, prior to construction.\n    p += sin(p*8. + 3.14159)*.1;\n    \n    \/\/ The main surface. A weird, molecular looking lattice.\n    float n = dot(sin(p*2.), cos(p.yzx*2.));\n    \n \t\/\/ Clamping the surface value, and adding the bumps.\n    \/\/return (clamp(0., -1.1, n) + 1.1)\/1.1 + bump;\n    return (min(n, 0.) + 1.1)\/1.1 + bump;\n    \n}\n\n \n\/\/ Ambient occlusion, for that self shadowed look.\n\/\/ XT95 came up with this particular version. Very nice.\n\/\/\n\/\/ Hemispherical SDF AO - https:\/\/www.shadertoy.com\/view\/4sdGWN\n\/\/ Alien Cocoons - https:\/\/www.shadertoy.com\/view\/MsdGz2\nfloat cao( in vec3 p, in vec3 n, float maxDist )\n{\n\tfloat ao = 0.0, l;\n\tconst float nbIte = 6.0;\n\tconst float falloff = 1.5;\n    for( float i=1.; i< nbIte+.5; i++ ){\n    \n        l = (i + hash(i))*.5\/nbIte*maxDist;\n        ao += (l - map( p + n*l ))\/ pow(1. + l, falloff);\n    }\n\t\n    return clamp( 1.-ao\/nbIte, 0., 1.);\n}\n\n\/\/ Tetrahedral normal, courtesy of IQ.\nvec3 nr(in vec3 p)\n{  \n    vec2 e = vec2(-1, 1)*.001;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\n\/\/ A trimmed down version of Nimitz's \"Log Bisecion\" method. Very effective on\n\/\/ difficult to hone in on things like weird, transcendental surfaces.\n\/\/ Worth studying, if you're not familiar with it.\n\/\/\n\/\/ Log-Bisection Tracing - Nimitz\n\/\/ https:\/\/www.shadertoy.com\/view\/4sSXzD\nfloat logBisectTrace( in vec3 ro, in vec3 rd){\n\n\n    float t = 0., told = 0., mid, dn;\n    float d = map(rd*t + ro);\n    float sgn = sign(d);\n\n    for (int i=0; i<64; i++){\n\n        \/\/ If the threshold is crossed with no detection, use the bisection method.\n        \/\/ Also, break for the usual reasons. Note that there's only one \"break\"\n        \/\/ statement in the loop. I heard GPUs like that... but who knows?\n        if (sign(d) != sgn || d < 0.001 || t > FAR) break;\n \n        told = t;\n        \n        \/\/ Branchless version of the following:  \n        \/\/ if(d>1.) t += d*.5; else t += log(abs(d) + 1.1)*.5;\n        t += step(d, 1.)*(log(abs(d) + 1.1)*.5 - d*.5) + d*.5;\n       \n        d = map(rd*t + ro);\n    }\n    \n    \/\/ If a threshold was crossed without a solution, use the bisection method.\n    if (sign(d) != sgn){\n    \n        \/\/ Based on suggestions from CeeJayDK, with some minor changes.\n\n        dn = sign(map(rd*told + ro));\n        \n        vec2 iv = vec2(told, t); \/\/ Near, Far\n\n        \/\/ 6 iterations seems to be more than enough, for most cases...\n        \/\/ but there's an early exit, so I've added a couple more.\n        for (int ii=0; ii<8; ii++){ \n            \/\/Evaluate midpoint\n            mid = dot(iv, vec2(.5));\n            float d = map(rd*mid + ro);\n            if (abs(d) < 0.001)break;\n            \/\/ Suggestion from movAX13h - Shadertoy is one of those rare\n            \/\/ sites with helpful commenters. :)\n            \/\/ Set mid to near or far, depending on which side we're on.\n            iv = mix(vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn));\n        }\n\n        t = mid; \n        \n    }\n\n    return min(t, FAR);\n}\n\n\/\/ Shadows.\nfloat sha(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\n\n    float shade = 1.0;\n    const int maxIterationsShad = 16; \n\n    float dist = start;\n    float stepDist = end\/float(maxIterationsShad);\n\n    for (int i=0; i<maxIterationsShad; i++){\n        float h = map(ro + rd*dist);\n        \/\/shade = min(shade, k*h\/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h\/dist));\n\n        dist += clamp(h, 0.02, 0.16);\n        \n        \/\/ There's some accuracy loss involved, but early exits from accumulative distance function can help.\n        if ((h)<0.001 || dist > end) break; \n    }\n    \n    return min(max(shade, 0.) + 0.1, 1.0); \n}\n\n\/\/ Grey scale.\nfloat gr(vec3 p){ return dot(p, vec3(0.299, 0.587, 0.114)); }\n\n\/\/ Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 db( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \/\/ Gradient vector, constructed with offset greyscale texture values.\n    vec3 g = vec3( gr(tpl(tx, p - e.xyy, n)), gr(tpl(tx, p - e.yxy, n)), gr(tpl(tx, p - e.yyx, n)));\n    \n    g = (g - gr(tpl(tx,  p , n)))\/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); \/\/ Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n\/\/ Camera path. Arranged to coincide with the frequency of the lattice.\nvec3 camPath(float t){\n  \n    return vec3(-sin(t), sin(t) + .75, t*2. + .5);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \n\t\/\/ Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*0.5)\/iResolution.y;\n\t\n\t\/\/ Camera Setup.\n\t\n    vec3 o = camPath(iTime); \/\/ Camera position, doubling as the ray origin.\n    vec3 lk = camPath(iTime + .1);  \/\/ \"Look At\" position.\n    vec3 l = o + vec3(1.5, 1., -0.5); \/\/ Light position, somewhere near the moving camera.\n\n\n    \/\/ Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159\/3.; \/\/ FOV - Field of view.\n    vec3 fwd = normalize(lk-o);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    vec3 up = cross(fwd, rgt);\n\n    \/\/ Unit direction ray.\n    vec3 r = normalize(fwd + FOV*(u.x*rgt + u.y*up));\n    \/\/ Lens distortion.\n    \/\/vec3 r = fwd + FOV*(u.x*rgt + u.y*up);\n    \/\/r = normalize(vec3(r.xy, (r.z - length(r.xy)*.5)));\n    \n    \n    \/\/ Rotate the camera using Fabrice's simplified rotation matrix.\n    u = sin(vec2(1.57, 0) - iTime\/2.); \/\/ Reusing \"u.\"\n    mat2 a = mat2(u, -u.y, u.x);\n    r.xz = a * r.xz;\n    r.xy = a * r.xy;\n\n    \/\/ Nimitz's fancy surface intersection formula.\n    float t = logBisectTrace(o, r);\n\n    \/\/ Initialize the scene color to zero.\n    vec3 col = vec3(0);\n    \n    \/\/ If the surface is hit, light it up.\n    if(t<FAR){\n    \n        \/\/ Position and normal.\n        vec3 p = o + r*t, n = nr(p);\n        \n        \/\/ Texture bump the normal.\n        float sz = 1.\/1.;\n        n = db(iChannel0, p*sz, n, .03\/(1. + t\/FAR));\n\n\n        l -= p; \/\/ Light to surface vector. Ie: Light direction vector.\n        float d = max(length(l), 0.001); \/\/ Light to surface distance.\n        l \/= d; \/\/ Normalizing the light direction vector.\n        \n        \/\/ Ambient occlusion and shadowing.\n        float ao =  cao(p, n, 4.);\n        float sh = sha(p, l, 0.04, d, 4.);\n        \n        \/\/ Diffuse, specular, fresnel. Only the latter is being used here.\n        \/\/float di = max(dot(l, n), 0.);\n        \/\/float sp = pow(max( dot( reflect(r, n), l ), 0.0 ), 8.); \/\/ Specular term.\n        float fr = clamp(1.0 + dot(r, n), 0.0, 1.0); \/\/ Fresnel reflection term.\n        \n        \/\/ Texturing the surface with some tri-planar mapping..\n        vec3 tx = tpl( iChannel0, p*sz, n);\n\n\t\t\/\/ Very simple coloring. Fresnel and texture combination. Radial blurs like simplicity. :)\n        col = tx*fr*4.;\n        col *= 1.\/(1. + d*.125 + d*d*.05)*ao*sh;\n\n        \n    }\n\n    vec3 bg = vec3(1, .56, .3);\n    col = mix(clamp(col, 0., 1.), bg, smoothstep(0., FAR-2., t));\n    fragColor = vec4(col, 1.);\n    \n    \n}","name":"Buf A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"XdXBRH","date":"1494745317","viewed":12817,"name":"Noise - Gradient - 2D - Deriv","username":"iq","description":"Analytic derivatives for 2D Gradient Noise ([url]https:\/\/www.shadertoy.com\/view\/XdXGW8[\/url])","likes":66,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ The MIT License\n\/\/ Copyright \u00a9 2017 Inigo Quilez\n\/\/ Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\/\/ https:\/\/www.youtube.com\/c\/InigoQuilez\n\/\/ https:\/\/iquilezles.org\n\n\n\/\/ Computes the analytic derivatives of a 2D Gradient Noise.\n\/\/\n\/\/ All noise functions here:\n\/\/\n\/\/ https:\/\/www.shadertoy.com\/playlist\/fXlXzf&from=0&num=12\n\n\n\/\/ 0: integer hash\n\/\/ 1: float hash (aliasing based)\n#define METHOD 0\n\n\/\/ 0: cubic\n\/\/ 1: quintic\n#define INTERPOLANT 1\n\n\n#if METHOD==0\nvec2 hash( in ivec2 p )  \/\/ this hash is not production ready, please\n{                        \/\/ replace this by something better\n\n    \/\/ 2D -> 1D\n    ivec2 n = p.x*ivec2(3,37) + p.y*ivec2(311,113);\n\n    \/\/ 1D hash by Hugo Elias\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return -1.0+2.0*vec2( n & ivec2(0x0fffffff))\/float(0x0fffffff);\n}\n#else\nvec2 hash( in vec2 x )   \/\/ this hash is not production ready, please\n{                        \/\/ replace this by something better\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n#endif\n\n\/\/ return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    #if METHOD==0\n    ivec2 i = ivec2(floor( p ));\n    #else\n    vec2 i = floor( p );\n    #endif\n    vec2 f = fract( p );\n\n    #if INTERPOLANT==1\n    \/\/ quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n    #else\n    \/\/ cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n    #endif    \n    \n    #if METHOD==0\n    vec2 ga = hash( i + ivec2(0,0) );\n    vec2 gb = hash( i + ivec2(1,0) );\n    vec2 gc = hash( i + ivec2(0,1) );\n    vec2 gd = hash( i + ivec2(1,1) );\n    #else\n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    #endif\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   \/\/ value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  \/\/ derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\n\/\/ -----------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)\/iResolution.y;\n    \n    vec3 n = noised( 8.0*p + iTime*4.0 );\n\n    vec3 col = 0.5 + 0.5*((p.x>0.0) ? n.yzx : n.xxx);\n    \n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4l2cD3","date":"1510922567","viewed":12806,"name":"Dual 3D Truchet Tiles","username":"Shane","description":"Utilizing two unique Truchet blocks to produce something analogous to a random pipe system.","likes":191,"published":3,"flags":0,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"\/media\/a\/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"\/media\/ap\/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/*\n\n\tDual 3D Truchet Tiles\n\t---------------------\n\n\tThis is yet another 3D Truchet example, but it consists of two unique Truchet blocks, which gives \n\tthe pattern a bit more variation. Truchet patterns usually make use of one block, consisting\n\tof three strategically placed tori designed to intersect the centers of all cube faces.\n\n\tThis particular pattern introduces another variation that consists of two tori intersecting four \n\tfaces and a straight segment that runs through opposing faces. The resultant pattern has more of a \n\trandom pipework look -- as opposed to the standard snake-like one. By the way, you could save a \n    lot of extra decision making and use just the second tile, but I feel the pattern lacks a little\n\tvariance when doing that.\n\t\n\tAnyway, apart from some extra decision making and construction, the code doesn't differ too much \n\tfrom regular examples. By the way, I can thank Mattz for reminding me of a concept that I'd forgotten, \n\twhich helped me speed up the distance field equation. Without it, this example would run much slower.\n\tI've described it briefly somewhere in among the distance field setup.\n\n\tWhilst on the subject of optimization, I should probably mention that I often take shortcuts with\n\tthe distance field equations in order to save the GPU extra calculations. For instance, I'll use a \n\tbound, like \"max(max(x, y), z),\" for a cube instead of the correct - but usually more expensive - \n\tone. For the most part, you can get away with it, but things like shadows, etc, can be affected. \n\tIQ has an example that illustrates the point here:\n\n\tRotational symmetry - iq\n\thttps:\/\/www.shadertoy.com\/view\/XtSczV\n\n\t\n\tBased on:\n\n\t\/\/ Same concept, but with one tile, which makes it easier to comprehend.\n\tCubic Truchet Pattern - Shane\n\thttps:\/\/www.shadertoy.com\/view\/4lfcRl\n\n\tOther Truchet examples:\n\n\t\/\/ 3D Truchet flow. Very cool. If you have easy questions to ask, feel free to send me an email, \n    \/\/ but if you have difficult ones, ask Mattz. :)\n\trandom cubic Truchet flow - mattz\n\thttps:\/\/www.shadertoy.com\/view\/MtSyRz\n\n\t\/\/ Psuedo 3D version, rendered in an oldschool game style.\n\t2D Pipe Pattern - Shane\n\thttps:\/\/www.shadertoy.com\/view\/XlXBzl\n\n\n*\/\n\n\n\/\/ Maximum ray distance.\n#define FAR 80.\n\n\/\/ Cross-sectional shape.\n\/\/ 0, 1, 2, or 3: Round, square, rounded-square or octagonal.\n#define TUBE_SHAPE 3 \n\n\/\/ Cheap, last minute camera weave. Suggested by ExNihilo. To implement this properly, I need\n\/\/ to add a few lines to set up a proper \"too\" and \"from\" camera... add a camera path function...\n\/\/ maybe later. :)\n#define CAMERA_WEAVE\n\n\n\/\/ Global storage vectors for object identification: I'm not fond of using globals inside distance field\n\/\/ functions, but felt it was necessary in this case.\nvec3 vObjID;\n\/\/float gID; \n\n\/\/ Global glow variable. Accumulated in the raymarching function.\nfloat glow;\n\n\n\/\/ Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n\/\/ Smooth maximum, based on IQ's smooth minimum.\nfloat smax(float a, float b, float s){\n    \n    float h = clamp(.5 + .5*(a - b)\/s, 0., 1.);\n    return mix(b, a, h) + h*(1. - h)*s;\n}\n\n\n\/\/ Tri-Planar blending function. Based on an old Nvidia writeup:\n\/\/ GPU Gems 3 - Ryan Geiss: https:\/\/developer.nvidia.com\/gpugems\/GPUGems3\/gpugems3_ch01.html\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n), 0.001);\n    n \/= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    \/\/ Textures are stored in sRGB (I think), so you have to convert them to linear space \n    \/\/ (squaring is a rough approximation) prior to working with them... or something like that. :)\n    \/\/ Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n    \n}\n\n\n\/\/ IQ's correct box formula.\nfloat sdBox( vec2 p, float b ){\n  \/\/vec2 d = abs(p) - b; \/\/ \"p\" is already in absolute form, in this case.\n  vec2 d = p - b;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n\/\/ Tube: Cylindrical tube, square tube, etc. In this case, it's a squarish tube with some\n\/\/ beveled sides.\nfloat tube(vec2 p, float sc, float rad){\n    \n    \/\/ Normally needed, but in this example \"p\" is passed to the function in its absoluted form.\n    \/\/p = abs(p);\n    \n    \n    #if TUBE_SHAPE == 0\n    \n    return length(p) - rad; \/\/ Standard round pipes.\n\n    #elif TUBE_SHAPE == 1\n    \n    \/\/ Box shape: I've left the correct and cheap version for comparison. Uncomment each, then\n    \/\/ pause and check the shadows. The structure remains the same, but the shadows do not.\n    return sdBox(p, rad); \/\/ Correct square distance field equation.\n    \/\/return max(p.x, p.y) - rad; \/\/ Cheaper shortcut. Almost the same, but not quite.\n    \n    #elif TUBE_SHAPE == 2\n    \/\/ Rounded square tube. Two versions.\n    return smax(p.x, p.y, .015) - rad; \/\/ Rounded square. Smooth minimum version.\n    \/\/return pow(dot(pow(p, vec2(8)), vec2(1)), 1.\/8.) - rad; \/\/ Rounded square. Super-elliptical.\n    \n    #else\n    \n    \/\/ Ocatagonal shape.\n    return max(max(p.x, p.y), (p.x + p.y)*sc) - rad; \/\/ .7071 for an octagon.\n    \n    #endif\n    \n}\n\n\n\/\/ The toroidal tube objects. Each consist of a white squarish outer tube, a similar colored \n\/\/ inner one (only visible through the holes) and some colored bands.\nvec4 torTube(vec3 p){\n\n\n    \/\/ Tube width.\n    const float rad2 = .07;\n    \n    \n    \/\/ Main tube. If it were not for the additional tube decorations, the following \n    \/\/ would be all that'd be required.\n    \/\/\n    \/\/ Note that we're converting one of the coordinates to its circular form. That way, \n    \/\/ we're rendering a circular tube, instead of a straight one. It's an oversimplification, \n    \/\/ but that's basically all a torus is. By the way, it doesn't have to be circular, \n    \/\/ converting \"p.xy\" to an octagonal form, etc, would work also.\n    float tb = tube(abs(vec2(length(p.xy) - .5, p.z)), .75, rad2);\n    \n\n    \n    \/\/ Adding some details to the tube. \n    \n    \n    \/\/ Inner tube for colored lights.\n    float innerTb = 1e5; \/\/tb + .0075; \n    \n   \n    \n    \/\/ Tube segments - for the bands and holes.\n    \/\/\n    \/\/ Number of tube segments. Breaking a circle into 8 lots of 3. Other combinations can\n    \/\/ work though.\n    const float aNum = 12.; \n    \n    \/\/ Realigning the segments.\n    p.xy = rot2(3.14159\/4.)*p.xy;\n    \n    \/\/ To place things evenly around the tube, you need to obtain the angle subtended to the center,\n    \/\/ partition it into the required number of cells (aNum), then obtain the angle at the center.\n    float a = atan(p.y, p.x);    \n    float ia = floor(a\/6.283*aNum) + .5; \/\/ .5 to move to the cell center.\n\n    \/\/ Converting to polar coordinates - In effect: Radial position, \"p.x,\" and angular position, \"p.y.\"\n    p.xy = rot2(ia*6.283\/aNum)*p.xy;\n    \/\/ The radial coordinate effective starts off at the center, so to spread the objects out, you have\n    \/\/ to advance them  along the radial coordinate in the radial direction. In this case, we want the \n    \/\/ objects to have the same radius as the torus we're attaching them to, which is \".5.\"\n    p.x -= .5;\n\n    \/\/ Drawing the objects within each of the partitioned cells. In this case, we're rendering some \n    \/\/ colored sleeves (or bands), and boring out some holes.\n    \n    p = abs(p);\n    \n    \/\/ Bands, or sleeves.\n    float band = max(tube(p.xz, .75,  rad2 + .0075), p.y - .06);\n    vec2 peg = vec2(tube(p.xy, .64, .0425), tube(p.yz, .64, .0425)); \n    \n    \n    \/\/ Group the 24 cell partitions into groups of 3 - in order to cover every third cell with the \n    \/\/ band and create a portal in the others... I figured it'd break up the monotony. :)\n    \/\/ On a side note, I try to avoid \"if\" statements inside distance functions when I can, but I \n    \/\/ figured this would be the best way for readability. Although, I might rework it later.\n    if(mod(ia + 1., 3.)>2.){\n        \n        band = min(band, max(tube(p.xz, .6, rad2 + .015), p.y - .04));\n    \t\/\/band = max(band, min(band + .005, -p.y + .015));\n        band = min(band, max(tube(p.xz, .6, rad2 + .025), p.y - .04\/3.));\n    }\n    else {\n        \n        \/\/ Portals on alternate bands.\n        \n        float hole = min(peg.x, peg.y);\n        \n        \/\/ Octagonal portal flush. The rest are raised a little. No reason. Just a design choice.\n        #if TUBE_SHAPE == 3\n        band = min(band, min(max(peg.x, p.z - rad2 - .0075), max(peg.y, p.x - rad2 - .0075)));\n        #else \n        band = min(band, min(max(peg.x, p.z - rad2 - .02), max(peg.y, p.x - rad2 - .02)));\n        #endif\n        band = max(band, -(hole + .015));\n        \n        tb = max(tb, -(hole + .015));\n        \n        \/\/ Inner tube. Actually, just some spheres at the portal positions, but to the observer,\n        \/\/ it gives the impression of an inner tube.\n        innerTb = length(p) - rad2 + .01;\n        \n    }\n    \n\n    \n    \/\/ Return the tube, bands, and inner tube objects.\n    return vec4(tb, band, innerTb, ia);\n}\n\n\n\n\n\/\/ The toroidal tube objects. Each consist of a white squarish outer tube, a similar colored \n\/\/ inner one (only visible through the holes) and some colored bands.\nvec4 straightTube(vec3 p){\n    \n    \n    \/\/ Tube width.\n    const float rad2 = .07;\n    \n    \n    \/\/ Main tube. If it were not for the additional tube decorations, the following \n    \/\/ would be all that'd be required.\n    float tb = tube(abs(p.xy), .75, rad2);\n    \n    \n    \/\/ Inner tube for colored lights.\n    float innerTb = 1e5; \/\/tb + .0075; \n    \n    \n    \/\/ Adding some details to the tube.\n\n    float band = 1e5;\n    const float aNum = 1.;\n\n    \n    float ia = floor(p.z*3.*aNum);\n\n    float opz = mod(p.z + 1.\/aNum\/3., 1.\/aNum);\n    \n    p.z = mod(p.z, 1.\/aNum\/3.) - .5\/aNum\/3.;\n\tp = abs(p);\n    \n    \/\/ Bands, or sleeves.\n    band = max(tb - .0075, p.z - .06);\n    vec2 peg = vec2(tube(p.xz, .64, .0425), tube(p.yz, .64, .0425)); \n\n    \n    if(opz>2.\/aNum\/3.){\n  \n        band = min(band, max(tube(p.xy, .6, rad2 + .015), p.z - .04));\n    \t\/\/band = max(band, min(band + .005, -p.z + .015));\n        band = min(band, max(tube(p.xy, .6, rad2 + .025), p.z - .04\/3.));\n    }\n    else {\n    \n        \/\/ Portals on alternate bands.\n        \n        float hole = min(peg.x, peg.y);\n        \n        \/\/ Octagonal portal flush. The rest are raised a little. No reason. Just a design choice.\n        #if TUBE_SHAPE == 3\n        band = min(band, min(max(peg.x, p.y - rad2 - .0075), max(peg.y, p.x - rad2 - .0075)));\n        #else\n        band = min(band, min(max(peg.x, p.y - rad2 - .02), max(peg.y, p.x - rad2 - .02)));\n        #endif\n        band = max(band, -(hole + .015));\n        \n        tb = max(tb, -(hole + .015));\n        \n                \/\/ Inner tube. Actually, just some spheres at the portal positions, but to the observer,\n        \/\/ it gives the impression of an inner tube.\n        innerTb = length(p) - rad2 + .01;\n        \n    }\n\n    \n    \/\/ Return the tube, bands, and inner tube objects.\n    return vec4(tb, band, innerTb, ia);\n    \n    \n}\n\n\n\n\/\/ I can thank Mattz for reminding me of this. You don't need to call all three decorated tubes,\n\/\/ then determine the minimum. You can determine the minimum main tube, then call the function\n\/\/ for the tube containing the more elaborate detailing that corresponds to it. And by that I\n\/\/ mean return the unique oriented point that corresponds to the nearest tube segment distance.\n\/\/\nvec4 torTubeTest(vec3 p){\n    \n    vec2 v = vec2(length(p.xy) - .5, p.z);\n    \n    \/\/ Main tube distance squared. Note: If a + c < b + c, then a*a<b*b.\n    \/\/ Ie: we don't need to test length(v) - r, just dot(v, v);\n    return vec4(p, dot(v, v));\n}\n\nvec4 straightTubeTest(vec3 p){\n    \n    vec2 v = p.xy;\n    \n    \/\/ Main tube distance squared. Note: If a + c < b + c, then a*a<b*b.\n    \/\/ Ie: we don't need to test length(v) - r, just dot(v, v);\n    return vec4(p, dot(v, v));\n}\n\n\n\/*\n\n\tThe Truchet pattern:\n\n\tA standard 3D Truchet tile consists of three toroids centered on three edges of a cube, \n    positioned to enter and exit six cube faces... Look one up on the internet, and that \n\tdiatribe will make more sense. :) The idea is to connect the tiles in a 3D grid, then \n\trandomly rotate each around one of the axes to produce an interesting spaghetti looking \n\tpattern.\n\n\tConstructing the individual tiles is as simple as breaking space into a cubic grid then\n\tpositioning three tori in each cell. If you can position, rotate and render a torus,\n\tthen it should be rudimentary.\n\n\tThis example uses an additional block consisting of a straight tube connecting two\n\topposite faces and two tori to connect the other four. That should be easy enough to\n\tconstruct too.\n\n*\/\n\nfloat map(vec3 p)\n{\n \n    \/\/ Random ID for each grid cube.\n    float rnd = fract(sin(dot(floor(p + vec3(111, 73, 27)), vec3(7.63, 157.31, 113.97)))*43758.5453);\n    float rnd2 = fract(rnd*41739.7613 + .131);\n\n    \/\/ Partition space into a grid of unit cubes - centered at the origin and ranging from\n    \/\/ vec3(-.5, -.5, -.5) to vec3(-.5, -.5, -.5).\n    p = fract(p) - .5;\n      \n    \/\/ Use each cube's random ID to rotate it in such a way that another one of its faces is \n    \/\/ facing forward. In case you're not aware, the swizzling below is a cheap trick used to\n    \/\/ achieve this. By the way, there may be a faster way to write the conditionals - using \n    \/\/ ternary operators, or something to that effect, but I'm leaving it this way for now... \n    \/\/ However, if a GPU expert feels that it's unnecessarily slow, then feel free to let me \n    \/\/ know, and I'll change it.\n    if(rnd>.833) p = p.xzy;\n    else if(rnd>.666) p = p.yxz;\n    else if(rnd>.5) p = p.yzx;\n    else if(rnd>.333) p = p.zxy;\n    else if(rnd>.166) p = p.zyx;\n        \n    \/\/ I can thank Mattz for reminding me of this step. Each Truchet tile contains three decorated\n    \/\/ tubes. However, you only need to find the closest tube, \"not\" the closest decorated tube, which\n    \/\/ requires a lot more GPU power. Each of these return the closest point and the distance...\n    \/\/ Actually, the squared distance, which for comparisson purposes, is the same thing.\n    vec4 tb1, tb2, tb3;\n    tb1 = torTubeTest(vec3(p.xy + .5, p.z));\n    if(rnd2>.66){\n    \t\n    \ttb2 = torTubeTest(vec3(p.yz - .5, p.x));\n    \ttb3 = torTubeTest(vec3(p.xz - vec2(.5, -.5), p.y));\n    }\n    else {\n    \t\n    \ttb2 = torTubeTest(vec3(p.xy - .5, p.z));\n    \ttb3 = straightTubeTest(p);  \n    }\n     \n    \/\/ Sort the distances, then return the closest point.\n    p = tb1.w<tb2.w && tb1.w<tb3.w ? tb1.xyz : tb2.w<tb3.w ? tb2.xyz : tb3.xyz;\n \n    \/\/ Render the randomly aligned Truchet block. Ie, the three tori - plus bells and whistles.\n    \/\/ Each quarter torus consists of three separate objects: A white tube with some holes in it, \n    \/\/ some bracing (the colored sleeve looking things) and a colored inner tube. That's nine\n    \/\/ objects returned in all. If it were not for the need to sort objects and attain a segment\n    \/\/ identifier (tb.w), only a float would be necessary.\n    vec4 tb;\n    \n    if(rnd2<=.66 && tb3.w<tb1.w && tb3.w<tb2.w) tb = straightTube(p);\n    else tb = torTube(p);\n        \n\n    \/\/\/ A unique angular segment identifier - Not used here.\n    \/\/gID = tb.w;\n    \n     \n    \/\/ Each torus segment contains three individual objects. Here, we're finding the minimum in\n    \/\/ each category. We're keeping a global copy here that will be sorted for object identification\n    \/\/ outside the raymarching loop. The reason this step is necessary is because the line below\n    \/\/ finds the closest object, but doesn't tell us which object that is. That requires sorting,\n    \/\/ which is best done outside the loop, for speed reasons.\n    vObjID = tb.xyz;\n    \n    \/\/ Finding the minimum of the above to determine the overall minimum object in the scene.\n    return min(min(vObjID.x, vObjID.y), vObjID.z);\n    \n    \n}\n\n\n\/*\n\/\/ Recreating part of the distance function to obtain the segment IDs, which in turn is used\n\/\/ to create the blink effect.\nfloat lightBlink(vec3 p, float gID){\n    \n    \/\/ Unique identifier for the cubic grid cell.\n    float rnd = fract(sin(dot(floor(p + vec3(111, 73, 27)), vec3(7.63, 157.31, 113.97)))*43758.5453);\n \n    \/\/ Reusing \"rnd\" to produce a new random number, then using that\n    \/\/ random number to create lights that blink at random intervals.\n    rnd = fract(rnd + gID*43758.54571);\n    \n    \/\/ Blink at random.\n    return smoothstep(0.33, .66, sin(rnd*6.283 + iTime*3.)*.5 + .5);\n\n    \n}\n*\/\n\n\n\/\/ Standard raymarching algorithm.\nfloat trace(vec3 o, vec3 r){\n    \n    glow = 0.;\n    \n    \/\/ Total ray distance travelled, and nearest distance at the current ray position.\n    float t = 0., d, ad;\n    \n    for (int i = 0; i<128; i++) {\n        \n        \/\/ Surface distance.\n        d = map(o + r*t);\n        ad = abs(d);\n        \n        \/\/ Applying some glow. There are better ways to go about it, but this will do.\n        \/\/if(ad<.25) glow += (.25 - ad)\/(1. + d*8.);\n        \/\/if(ad<.25) glow += (.25 - ad)\/(.25 + ad*ad);\n        glow += 1.\/(1. + ad*ad*8.);\n        \/\/if(vObjID.z<vObjID.x && vObjID.z<vObjID.y && ad<.25) glow += (.25 - ad))\/(1. + t);\n        \n        \/\/ If the ray position is within the surface threshold (\"abs\" means either side of the \n        \/\/ surface), or if we've traversed beyond the maximum, exit the loop.\n        if(ad<.001*(t*.125 + 1.) || t>FAR) break;\n        \n        \/\/ Standard jump.\n        t += d; \n        \n        \/\/ Shortening the ray jump right near the camera to alleviated near-camera artifacts.\n        \/\/t += t<.125 ? d*.7 : d; \n    }\n    \n    \/\/ Clamp the total distance to \"FAR.\" It can sometimes get rid of far surface artifacts.\n    return min(t, FAR);\n}\n\n\/\/ Cheap shadows are the bain of my raymarching existence, since trying to alleviate artifacts is an excercise in\n\/\/ futility. In fact, I'd almost say, shadowing - in a setting like this - with limited  iterations is impossible... \n\/\/ However, I'd be very grateful if someone could prove me wrong. :)\nfloat shadow(vec3 ro, vec3 lp, float k, float t){\n\n    \/\/ More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 32; \n    \n    vec3 rd = lp-ro; \/\/ Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = .001*(t*.125 + 1.);  \/\/ Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    \/\/float stepDist = end\/float(maxIterationsShad);\n    rd \/= end;\n\n    \/\/ Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    \/\/ number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        \/\/shade = min(shade, k*h\/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h\/dist)); \/\/ Subtle difference. Thanks to IQ for this tidbit.\n        \/\/ So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        dist += clamp(h, .01, .2); \n        \n        \/\/ Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0.0 || dist > end) break; \n    }\n\n    \/\/ I sometimes add a constant to the final shade value, which lightens the shadow a bit. It's a preference \n    \/\/ thing. Really dark shadows look too brutal to me. Sometimes, I'll also add AO, just for kicks. :)\n    return min(max(shade, 0.) + .0, 1.); \n    \n}\n\n\n\/\/ I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n\/\/ Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 1.25, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = .01 + float(i)*.5\/4.;        \n        float dd = map(p + hr*n);\n        occ += (hr - dd)*sca;\n        sca *= .7;\n    }\n    return clamp(1. - occ, 0., 1.);   \n    \n}\n\n\n\/\/ Normal calculation, with some edging and curvature bundled in.\nvec3 nrm(vec3 p, inout float edge, inout float crv, float t) { \n\t\n    \/\/ It's worth looking into using a fixed epsilon versus using an epsilon value that\n    \/\/ varies with resolution. Each affects the look in different ways. Here, I'm using\n    \/\/ a mixture. I want the lines to be thicker at larger resolutions, but not too thick.\n    \/\/ As for accounting for PPI; There's not a lot I can do about that.\n    vec2 e = vec2(1.\/mix(400., iResolution.y, .5)*(1. + t*.5), 0);\n\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p)*2.;\n\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    \/\/edge = abs(d1 + d2 + d3 + d4 + d5 + d6 - d*3.);\n    edge = smoothstep(0., 1., sqrt(edge\/e.x*2.));\n\/*    \n    \/\/ Wider sample spread for the curvature.\n    e = vec2(12.\/450., 0);\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx);\n    crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .5, 0., 1.);\n*\/\n    \n    e = vec2(.002, 0); \/\/iResolution.y - Depending how you want different resolutions to look.\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    \/\/ Aspect correct screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)\/iResolution.y;\n    \n    \/\/ Ray origin, or camera - Moving along the Z-axis.\n    float tm = iTime;\n    #ifdef CAMERA_WEAVE\n    tm *= .75;\n    #endif\n    \n    vec3 o = vec3(0, 0, tm); \n    \/\/ Light. Situated near the camera whilst moving along with it.\n\t\/\/vec3 lp = vec3(-1, 3, -.25) + o;\n    vec3 lp = o + vec3(-1, 3, -1);\n    \n    \/\/ Cheap, last minute camera weave. Suggested by ExNihilo. To implement this properly, I need to add\n\t\/\/ add a few lines to set up a proper \"too\" and \"from\" camera... add a camera path function...\n    \/\/ maybe later. :)\n    #ifdef CAMERA_WEAVE\n    o.x += sin(tm * 3.14159265\/6. + 1.5707963);\n    #endif\n    \n    \/\/ Unit ray vector.\n    \/\/vec3 r = normalize(vec3(uv, 1));\n    \/\/ Slight bulbous scene warp.\n    vec3 r = normalize(vec3(uv, 1.15));\n    r = normalize(vec3(r.xy, r.z - length(r.xy)*.15));\n    \n    \/\/ Rotating \"r\" back and forth along various axes for some cheap camera movement. \n    #ifdef CAMERA_WEAVE\n    r.xz *= rot2(-sin(tm\/2. - 1.5707963) * 0.6);\n    r.xy *= rot2(-sin(tm\/2. - 1.5707963) * 0.4);\n    \/\/r.yz *= rot2(-sin(tm\/2.) * 0.2);\n    #else\n    r.xz *= rot2(sin(tm\/2.) * 0.4);\n    r.xy *= rot2(cos(tm\/2.) * 0.2);\n    #endif\n    \n    \/\/ Trace out the scene.\n    float t = trace(o, r);\n     \n    \/\/ Determining the object ID. Sorting the three different objects outside the loop\n    \/\/ is a little less readable, but usually faster. See the distance function.\n    \/\/\n    \/\/ Scene object ID: Main tube, colored inner tube or band.\n    float objID = (vObjID.x<vObjID.y && vObjID.x<vObjID.z) ? 0. : (vObjID.y<vObjID.z) ? 1. : 2.;\n\n    \/\/ Segment ID: Sorting the segments to determine the unique ID. This ID is fed\n    \/\/ into a function to give various effects. Not used here.\n    \/\/float svGID = gID;\n \n\t\/\/ Initiate the scene color to zero.\n    vec3 sc = vec3(0);\n    \n    \n    \/\/ An object in the scene has been hit, so light it.\n    if(t<FAR){\n        \n        \/\/ Hit position.\n        vec3 sp = o + r*t;\n        \n        \/\/ Normal, plus edges and curvature. The latter isn't used.\n        float edge = 0., crv = 1.;\n        vec3 sn = nrm(sp, edge, crv, t);\n\n        \n        \/\/ Producing a gradient color based on position. Made up on the spot.\n        vec3 oCol = vec3(1);\n        vec3 bCol = mix(vec3(1, .1, .3).zyx, vec3(1, .5, .1).zyx, dot(sin(sp*8. - cos(sp.yzx*4. + iTime*4.)), vec3(.166)) + .5);\n        \/\/bCol = bCol.zyx; \/\/bCol.yzx; \/\/ Other colors, if you prefer.\n\n\n        \n        \/\/ Color the individual objects, based on object ID.\n        if(objID<.5)oCol = mix(bCol, vec3(1), .97);\n        else if(objID>1.5) oCol = mix(bCol, vec3(1), .05) + bCol*2.;\n        else oCol = oCol = mix(bCol, vec3(1.35), .97)*vec3(1.1, 1, .9);\n\n        \/\/ A bit of subtle texture applied to the object.\n        vec3 tx = tex3D(iChannel0, sp*2., sn);\n        tx = smoothstep(.0, .5, tx)*2.;\n        \/\/\n        if(objID<1.5) oCol *= tx;\n        else oCol *= mix(vec3(1), tx, .5);\n        \n        \n        \/\/ Ambient occlusion and shadows.\n        float ao = cAO(sp, sn);\n        float sh = shadow(sp + sn*.002, lp, 16., t); \n        \n\n        \/\/ Point light direction vector.\n        vec3 ld = lp - sp;\n        float dist = max(length(ld), 0.001); \/\/ Distance.\n        ld \/= dist; \/\/ Using the distance to nomalize the point light direction vector.\n        \n\n        \/\/ Attenuation - based on light to surface distance.\n        float atten = 3.5\/(1. + dist*0.05 + dist*dist*0.05);\n        \n        \/\/ Diffuse light.\n        float diff = max(dot(ld, sn), 0.);\n        if(objID<1.5) diff = pow(diff, 4.)*2.;\n        float spec = pow(max(dot( reflect(ld, sn), r), 0.0 ), 32.0);\n        \/\/float fres = clamp(1. + dot(rd, sn), 0., 1.);\n        \n       \t\n        \n        \/\/ Combining the above terms to produce the final color.\n        sc = oCol*(diff + ao*.2) + mix(bCol.zyx, vec3(1, .7, .3), .5)*spec*4.;\n        \n        \/\/ Fake caustic lighting... Very fake. :)\n        sc += .015\/max(abs(.05 - map(sp*1.5 + sin(iTime\/6.))), .01)*oCol*mix(bCol, vec3(1, .8, .5), .35);\n        \n        \/\/ Adding a bit of glow. It was tempting to get my money's worth, but I kept it subtle. :)\n        if(objID<1.5) sc += bCol*glow*.025;\n        else sc += bCol*glow*1.5;\n        \n        \/\/ Applying the dark edges, attenuation, shadows and ambient occlusion.\n        sc *= (1. - edge*.7);\n        sc *= atten*(sh + ao*.25)*ao;\n        \n    }\n    \n    \n    \n    \/\/ Applying some basic camera distance fog. Not to be confused with the light\n    \/\/ to surface attenuation.\n    float fog = 1.\/(1. + t*.125 + t*t*.05);\n    sc = mix(vec3(0), sc, fog);\/\/\n    \/\/sc = mix(sc, vec3(0), smoothstep(0.0, .2, t\/FAR));\n    \n    \n    \/\/ Subtle vignette.\n    uv = fragCoord\/iResolution.xy;\n    sc *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125);\n    \/\/ Colored variation.\n    \/\/sc = mix(pow(min(vec3(1.5, 1, 1).zyx*sc, 1.), vec3(1, 3, 16).zyx), sc, \n             \/\/pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125)*.75 + .25);\n    \n    \n\tfragColor = vec4(sqrt(max(sc, 0.)), 1);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4t2SzR","date":"1441051744","viewed":12792,"name":"Normal Map Blending","username":"ZigguratVertigo","description":"Reoriented Normal Mapping (vs other techniques). Hopefully another step in convincing people to stop using Overlay to combine normal maps ;) We spend so much math on awesome lighting (ie.: PBR), source content matters. Please tell your artists! <3","likes":103,"published":3,"flags":0,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"\/media\/a\/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"\/media\/ap\/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\/\/\n\/\/ Reoriented Normal Mapping (vs other techniques)\n\/\/\n\/\/ Hopefully another step in convincing people to stop using overlay to combine normal maps ;)\n\/\/ Please tell your artists! We spend so much math on awesome lighting (with PBR), source content matters.\n\/\/\n\/\/ Based on \"Blending in Detail\" by Stephen Hill and myself: \n\/\/ http:\/\/blog.selfshadow.com\/publications\/blending-in-detail\/\n\/\/ http:\/\/blog.selfshadow.com\/sandbox\/normals.html\n\/\/\n\/\/ [References]:\n\/\/ Text rendering: \t\thttps:\/\/www.shadertoy.com\/view\/Mt2GWD\n\/\/ Normal generation: \thttps:\/\/www.shadertoy.com\/view\/llS3WD\n\/\/ \t\t\t\t\t\thttps:\/\/www.shadertoy.com\/view\/MsSXzG\n\/\/\n\/\/ Cycles between the techniques and RNM. If you want to stop on a specific technique, override the following.\n\/\/ Override to force a specific technique (automatic or manual)\n\n#define TECHNIQUE\t\t\t\t\t TECHNIQUE_CycleCompare\n\n\/\/ Automatic\n#define TECHNIQUE_CycleCompare\t\t-1\n\n\/\/ Manual\n#define TECHNIQUE_RNM \t\t\t\t 0\n#define TECHNIQUE_PartialDerivatives 1\n#define TECHNIQUE_Whiteout \t\t\t 3\n#define TECHNIQUE_UDN\t\t\t\t 5\n#define TECHNIQUE_Unity\t\t\t\t 7\n#define TECHNIQUE_Linear\t\t     9\n#define TECHNIQUE_Overlay\t\t     11\n\n\/\/---------------------------------------------------------------------------------------------\n\/\/ Helper Functions\n\/\/---------------------------------------------------------------------------------------------\nfloat saturate(float v)\n{\n    return clamp(v, 0.0, 1.0);\n}\n\nfloat overlay(float x, float y)\n{\n    if (x < 0.5)\n        return 2.0*x*y;\n    else\n        return 1.0 - 2.0*(1.0 - x)*(1.0 - y);\n}\n\n\n\/\/---------------------------------------------------------------------------------------------\n\/\/ Normal Blending Techniques\n\/\/---------------------------------------------------------------------------------------------\n\n\/\/ RNM\nvec3 NormalBlend_RNM(vec3 n1, vec3 n2)\n{\n    \/\/ Unpack (see article on why it's not just n*2-1)\n\tn1 = n1*vec3( 2,  2, 2) + vec3(-1, -1,  0);\n    n2 = n2*vec3(-2, -2, 2) + vec3( 1,  1, -1);\n    \n    \/\/ Blend\n    return n1*dot(n1, n2)\/n1.z - n2;\n}\n\n\/\/ RNM - Already unpacked\nvec3 NormalBlend_UnpackedRNM(vec3 n1, vec3 n2)\n{\n\tn1 += vec3(0, 0, 1);\n\tn2 *= vec3(-1, -1, 1);\n\t\n    return n1*dot(n1, n2)\/n1.z - n2;\n}\n\n\/\/ Partial Derivatives\nvec3 NormalBlend_PartialDerivatives(vec3 n1, vec3 n2)\n{\t\n    \/\/ Unpack\n\tn1 = n1*2.0 - 1.0;\n    n2 = n2*2.0 - 1.0;\n    \n    return normalize(vec3(n1.xy*n2.z + n2.xy*n1.z, n1.z*n2.z));\n}\n\n\/\/ Whiteout\nvec3 NormalBlend_Whiteout(vec3 n1, vec3 n2)\n{\n    \/\/ Unpack\n\tn1 = n1*2.0 - 1.0;\n    n2 = n2*2.0 - 1.0;\n    \n\treturn normalize(vec3(n1.xy + n2.xy, n1.z*n2.z));    \n}\n\n\/\/ UDN\nvec3 NormalBlend_UDN(vec3 n1, vec3 n2)\n{\n    \/\/ Unpack\n\tn1 = n1*2.0 - 1.0;\n    n2 = n2*2.0 - 1.0;    \n    \n\treturn normalize(vec3(n1.xy + n2.xy, n1.z));\n}\n\n\/\/ Unity\nvec3 NormalBlend_Unity(vec3 n1, vec3 n2)\n{\n    \/\/ Unpack\n\tn1 = n1*2.0 - 1.0;\n    n2 = n2*2.0 - 1.0;\n    \n    mat3 nBasis = mat3(vec3(n1.z, n1.y, -n1.x), \/\/ +90 degree rotation around y axis\n        \t\t\t   vec3(n1.x, n1.z, -n1.y), \/\/ -90 degree rotation around x axis\n        \t\t\t   vec3(n1.x, n1.y,  n1.z));\n\t\n    return normalize(n2.x*nBasis[0] + n2.y*nBasis[1] + n2.z*nBasis[2]);\n}\n\n\/\/ Linear Blending\nvec3 NormalBlend_Linear(vec3 n1, vec3 n2)\n{\n    \/\/ Unpack\n\tn1 = n1*2.0 - 1.0;\n    n2 = n2*2.0 - 1.0;\n    \n\treturn normalize(n1 + n2);    \n}\n\n\/\/ Overlay\nvec3 NormalBlend_Overlay(vec3 n1, vec3 n2)\n{\n    vec3 n;\n    n.x = overlay(n1.x, n2.x);\n    n.y = overlay(n1.y, n2.y);\n    n.z = overlay(n1.z, n2.z);\n\n    return normalize(n*2.0 - 1.0);\n}\n\n\/\/ Combine normals\nvec3 CombineNormal(vec3 n1, vec3 n2, int technique)\n{\n \tif (technique == TECHNIQUE_RNM)\n        return NormalBlend_RNM(n1, n2);\n    else if (technique == TECHNIQUE_PartialDerivatives)\n        return NormalBlend_PartialDerivatives(n1, n2);\n    else if (technique == TECHNIQUE_Whiteout)\n        return NormalBlend_Whiteout(n1, n2);\n    else if (technique == TECHNIQUE_UDN)\n        return NormalBlend_UDN(n1, n2);\n    else if (technique == TECHNIQUE_Unity)\n        return NormalBlend_Unity(n1, n2);\n    else if (technique == TECHNIQUE_Linear)\n        return NormalBlend_Linear(n1, n2);\n    else\n        return NormalBlend_Overlay(n1, n2);\n}\n\n\/\/ Compute base normal (since we don't have a texture)\nvec3 ComputeBaseNormal(vec2 uv) \n{\n    uv = fract(uv) * 2.0 - 1.0;    \n        \n    vec3 ret;\n    ret.xy = sqrt(uv * uv) * sign(uv);\n    ret.z = sqrt(abs(1.0 - dot(ret.xy,ret.xy)));\n    \n    ret = ret * 0.5 + 0.5;\n    return mix(vec3(0.5,0.5,1.0), ret, smoothstep(1.0,0.95,dot(uv,uv)));\n}\n\n\/\/ Compute a detail normal (since we don't have a texture)\nvec3 ComputeDetailNormal(vec2 uv)\n{\n    const vec4 avgRGB0 = vec4(1.0\/3.0, 1.0\/3.0, 1.0\/3.0, 0.0);\n    const float scale = 0.02;\n    const vec2 du = vec2(1.0\/512.0, 0.0);\n    const vec2 dv = vec2(0.0, 1.0\/512.0);\n\n    float h0  = dot(avgRGB0, texture(iChannel0, uv)) * scale;\n    float hpx = dot(avgRGB0, texture(iChannel0, uv + du)) * scale;\n    float hmx = dot(avgRGB0, texture(iChannel0, uv - du)) * scale;\n    float hpy = dot(avgRGB0, texture(iChannel0, uv + dv)) * scale;\n    float hmy = dot(avgRGB0, texture(iChannel0, uv - dv)) * scale;\n    \n    float dHdU = (hmx - hpx) \/ (2.0 * du.x);\n    float dHdV = (hmy - hpy) \/ (2.0 * dv.y);\n    \n    return normalize(vec3(dHdU, dHdV, 1.0)) * 0.5 + 0.5;\n}\n\n\/\/---------------------------------------------------------------------------------------------\n\/\/ Text Rendering\n\/\/---------------------------------------------------------------------------------------------\n\/\/ Text from: \n#define DOWN_SCALE 1.0\n#define MAX_INT_DIGITS 4\n#define CHAR_SIZE vec2(8, 12)\n#define CHAR_SPACING vec2(8, 12)\n#define STRWIDTH(c) (c * CHAR_SPACING.x)\n#define STRHEIGHT(c) (c * CHAR_SPACING.y)\n#define NORMAL 0\n#define INVERT 1\n#define UNDERLINE 2\n\nint TEXT_MODE = NORMAL;\n\nvec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000);\nvec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000);\nvec4 ch_quo = vec4(0x006666,0x662400,0x000000,0x000000);\nvec4 ch_hsh = vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000);\nvec4 ch_dol = vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000);\nvec4 ch_pct = vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000);\nvec4 ch_amp = vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000);\nvec4 ch_apo = vec4(0x003030,0x306000,0x000000,0x000000);\nvec4 ch_lbr = vec4(0x000C18,0x306060,0x603018,0x0C0000);\nvec4 ch_rbr = vec4(0x006030,0x180C0C,0x0C1830,0x600000);\nvec4 ch_ast = vec4(0x000000,0x663CFF,0x3C6600,0x000000);\nvec4 ch_crs = vec4(0x000000,0x18187E,0x181800,0x000000);\nvec4 ch_com = vec4(0x000000,0x000000,0x000038,0x386000);\nvec4 ch_dsh = vec4(0x000000,0x0000FE,0x000000,0x000000);\nvec4 ch_per = vec4(0x000000,0x000000,0x000038,0x380000);\nvec4 ch_lsl = vec4(0x000002,0x060C18,0x3060C0,0x800000);\nvec4 ch_0 = vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000);\nvec4 ch_1 = vec4(0x001030,0xF03030,0x303030,0xFC0000);\nvec4 ch_2 = vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000);\nvec4 ch_3 = vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000);\nvec4 ch_4 = vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000);\nvec4 ch_5 = vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000);\nvec4 ch_6 = vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000);\nvec4 ch_7 = vec4(0x00FEC6,0xC6060C,0x183030,0x300000);\nvec4 ch_8 = vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000);\nvec4 ch_9 = vec4(0x0078CC,0xCCCC7C,0x181830,0x700000);\nvec4 ch_col = vec4(0x000000,0x383800,0x003838,0x000000);\nvec4 ch_scl = vec4(0x000000,0x383800,0x003838,0x183000);\nvec4 ch_les = vec4(0x000C18,0x3060C0,0x603018,0x0C0000);\nvec4 ch_equ = vec4(0x000000,0x007E00,0x7E0000,0x000000);\nvec4 ch_grt = vec4(0x006030,0x180C06,0x0C1830,0x600000);\nvec4 ch_que = vec4(0x0078CC,0x0C1830,0x300030,0x300000);\nvec4 ch_ats = vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000);\nvec4 ch_A = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000);\nvec4 ch_B = vec4(0x00FC66,0x66667C,0x666666,0xFC0000);\nvec4 ch_C = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000);\nvec4 ch_D = vec4(0x00F86C,0x666666,0x66666C,0xF80000);\nvec4 ch_E = vec4(0x00FE62,0x60647C,0x646062,0xFE0000);\nvec4 ch_F = vec4(0x00FE66,0x62647C,0x646060,0xF00000);\nvec4 ch_G = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000);\nvec4 ch_H = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000);\nvec4 ch_I = vec4(0x007830,0x303030,0x303030,0x780000);\nvec4 ch_J = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000);\nvec4 ch_K = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000);\nvec4 ch_L = vec4(0x00F060,0x606060,0x626666,0xFE0000);\nvec4 ch_M = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000);\nvec4 ch_N = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000);\nvec4 ch_O = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000);\nvec4 ch_P = vec4(0x00FC66,0x66667C,0x606060,0xF00000);\nvec4 ch_Q = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00);\nvec4 ch_R = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000);\nvec4 ch_S = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000);\nvec4 ch_T = vec4(0x00FCB4,0x303030,0x303030,0x780000);\nvec4 ch_U = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000);\nvec4 ch_V = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000);\nvec4 ch_W = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000);\nvec4 ch_X = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000);\nvec4 ch_Y = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000);\nvec4 ch_Z = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000);\nvec4 ch_lsb = vec4(0x003C30,0x303030,0x303030,0x3C0000);\nvec4 ch_rsl = vec4(0x000080,0xC06030,0x180C06,0x020000);\nvec4 ch_rsb = vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000);\nvec4 ch_pow = vec4(0x10386C,0xC60000,0x000000,0x000000);\nvec4 ch_usc = vec4(0x000000,0x000000,0x000000,0x00FF00);\nvec4 ch_a = vec4(0x000000,0x00780C,0x7CCCCC,0x760000);\nvec4 ch_b = vec4(0x00E060,0x607C66,0x666666,0xDC0000);\nvec4 ch_c = vec4(0x000000,0x0078CC,0xC0C0CC,0x780000);\nvec4 ch_d = vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000);\nvec4 ch_e = vec4(0x000000,0x0078CC,0xFCC0CC,0x780000);\nvec4 ch_f = vec4(0x00386C,0x6060F8,0x606060,0xF00000);\nvec4 ch_g = vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78);\nvec4 ch_h = vec4(0x00E060,0x606C76,0x666666,0xE60000);\nvec4 ch_i = vec4(0x001818,0x007818,0x181818,0x7E0000);\nvec4 ch_j = vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78);\nvec4 ch_k = vec4(0x00E060,0x60666C,0x786C66,0xE60000);\nvec4 ch_l = vec4(0x007818,0x181818,0x181818,0x7E0000);\nvec4 ch_m = vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000);\nvec4 ch_n = vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000);\nvec4 ch_o = vec4(0x000000,0x0078CC,0xCCCCCC,0x780000);\nvec4 ch_p = vec4(0x000000,0x00DC66,0x666666,0x7C60F0);\nvec4 ch_q = vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E);\nvec4 ch_r = vec4(0x000000,0x00EC6E,0x766060,0xF00000);\nvec4 ch_s = vec4(0x000000,0x0078CC,0x6018CC,0x780000);\nvec4 ch_t = vec4(0x000020,0x60FC60,0x60606C,0x380000);\nvec4 ch_u = vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000);\nvec4 ch_v = vec4(0x000000,0x00CCCC,0xCCCC78,0x300000);\nvec4 ch_w = vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000);\nvec4 ch_x = vec4(0x000000,0x00C66C,0x38386C,0xC60000);\nvec4 ch_y = vec4(0x000000,0x006666,0x66663C,0x0C18F0);\nvec4 ch_z = vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000);\nvec4 ch_lpa = vec4(0x001C30,0x3060C0,0x603030,0x1C0000);\nvec4 ch_bar = vec4(0x001818,0x181800,0x181818,0x180000);\nvec4 ch_rpa = vec4(0x00E030,0x30180C,0x183030,0xE00000);\nvec4 ch_tid = vec4(0x0073DA,0xCE0000,0x000000,0x000000);\nvec4 ch_lar = vec4(0x000000,0x10386C,0xC6C6FE,0x000000);\nvec2 print_pos = vec2(0);\n\n\/\/Extracts bit b from the given number.\n\/\/Shifts bits right (num \/ 2^bit) then ANDs the result with 1 (mod(result,2.0)).\nfloat extract_bit(float n, float b)\n{\n    b = clamp(b,-1.0,24.0);\n\treturn floor(mod(floor(n \/ pow(2.0,floor(b))),2.0));   \n}\n\n\/\/Returns the pixel at uv in the given bit-packed sprite.\nfloat sprite(vec4 spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n    \n    \/\/Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    \/\/Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));\n    \n    float pixels = 0.0;\n    pixels += extract_bit(spr.x, bit - 72.0);\n    pixels += extract_bit(spr.y, bit - 48.0);\n    pixels += extract_bit(spr.z, bit - 24.0);\n    pixels += extract_bit(spr.w, bit - 00.0);\n    \n    return bounds ? pixels : 0.0;\n}\n\n\/\/Prints a character and moves the print position forward by 1 character width.\nfloat char(vec4 ch, vec2 uv)\n{\n    if( TEXT_MODE == INVERT )\n    {\n      \/\/Inverts all of the bits in the character.\n      ch = pow(2.0,24.0)-1.0-ch;\n    }\n    if( TEXT_MODE == UNDERLINE )\n    {\n      \/\/Makes the bottom 8 bits all 1.\n      \/\/Shifts the bottom chunk right 8 bits to drop the lowest 8 bits,\n      \/\/then shifts it left 8 bits and adds 255 (binary 11111111).\n      ch.w = floor(ch.w\/256.0)*256.0 + 255.0;  \n    }\n\n    float px = sprite(ch, CHAR_SIZE, uv - print_pos);\n    print_pos.x += CHAR_SPACING.x;\n    return px;\n}\n\nfloat PrintText(vec2 uv, int technique)\n{\n    float col = 0.0;\n    TEXT_MODE = NORMAL;  \n    \n    \/\/ RNM\n    if (technique == TECHNIQUE_RNM)\n    {\n        print_pos = vec2(iResolution.x*0.5 - 0.5*STRHEIGHT(16.0), 2.0 + STRHEIGHT(0.0));\n\n        col += char(ch_R,uv);\n        col += char(ch_e,uv);\n        col += char(ch_o,uv);\n        col += char(ch_r,uv);\n        col += char(ch_i,uv);\n        col += char(ch_e,uv);\n        col += char(ch_n,uv);\n        col += char(ch_t,uv);\n        col += char(ch_e,uv);\n        col += char(ch_d,uv);\n\n        col += char(ch_spc,uv);\n\n        col += char(ch_N,uv);\n        col += char(ch_o,uv);\n        col += char(ch_r,uv);\n        col += char(ch_m,uv);\n        col += char(ch_a,uv);\n        col += char(ch_l,uv);\n\n        col += char(ch_spc,uv);\n\n        col += char(ch_M,uv);\n        col += char(ch_a,uv);\n        col += char(ch_p,uv);\n        col += char(ch_p,uv);\n        col += char(ch_i,uv);\n        col += char(ch_n,uv);\n        col += char(ch_g,uv);\n    }\n    else if (technique == TECHNIQUE_PartialDerivatives)\n    {\n        print_pos = vec2(iResolution.x*0.5 - STRHEIGHT(6.0), 2.0 + STRHEIGHT(0.0));\n\n        col += char(ch_P,uv);\n        col += char(ch_a,uv);\n        col += char(ch_r,uv);\n        col += char(ch_t,uv);\n        col += char(ch_i,uv);\n        col += char(ch_a,uv);\n        col += char(ch_l,uv);\n\n        col += char(ch_spc,uv);\n\n        col += char(ch_D,uv);\n        col += char(ch_e,uv);\n        col += char(ch_r,uv);\n        col += char(ch_i,uv);\n        col += char(ch_v,uv);\n        col += char(ch_a,uv);\n        col += char(ch_t,uv);\n        col += char(ch_i,uv);\n        col += char(ch_v,uv);\n        col += char(ch_e,uv);\n        col += char(ch_s,uv);\n    }\n    else if (technique == TECHNIQUE_Whiteout)\n    {\n        print_pos = vec2(iResolution.x*0.5 - STRHEIGHT(2.0), 2.0 + STRHEIGHT(0.0));\n\n        col += char(ch_W,uv);\n        col += char(ch_h,uv);\n        col += char(ch_i,uv);\n        col += char(ch_t,uv);\n        col += char(ch_e,uv);\n        col += char(ch_o,uv);\n        col += char(ch_u,uv);\n        col += char(ch_t,uv);\n    }    \n    else if (technique == TECHNIQUE_UDN)\n    {\n        print_pos = vec2(iResolution.x*0.5 - STRHEIGHT(1.0), 2.0 + STRHEIGHT(0.0));\n\n        col += char(ch_U,uv);\n        col += char(ch_D,uv);\n        col += char(ch_N,uv);\n    }    \n    else if (technique == TECHNIQUE_Unity)\n    {\n        print_pos = vec2(iResolution.x*0.5 - STRHEIGHT(2.0), 2.0 + STRHEIGHT(0.0));\n\n        col += char(ch_U,uv);\n        col += char(ch_n,uv);\n        col += char(ch_i,uv);\n        col += char(ch_t,uv);\n        col += char(ch_y,uv);\n    } \n    else if (technique == TECHNIQUE_Linear)\n    {\n        print_pos = vec2(iResolution.x*0.5 - STRHEIGHT(2.0), 2.0 + STRHEIGHT(0.0));\n\n        col += char(ch_L,uv);\n        col += char(ch_i,uv);\n        col += char(ch_n,uv);\n        col += char(ch_e,uv);\n        col += char(ch_a,uv);\n        col += char(ch_r,uv);\n    } \n    else\/\/ if (technique == TECHNIQUE_Overlay)\n    {\n        print_pos = vec2(iResolution.x*0.5 - STRHEIGHT(2.0), 2.0 + STRHEIGHT(0.0));\n\n        col += char(ch_O,uv);\n        col += char(ch_v,uv);\n        col += char(ch_e,uv);\n        col += char(ch_r,uv);\n        col += char(ch_l,uv);\n        col += char(ch_a,uv);\n        col += char(ch_y,uv);\n    }    \n    \n    return col;\n}\n\n\n\/\/---------------------------------------------------------------------------------------------\n\/\/ Main\n\/\/---------------------------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n\tint iTechnique = TECHNIQUE;\n    if (iTechnique == TECHNIQUE_CycleCompare)\n    {\n\t\tiTechnique = int(mod(iTime\/4.0, 11.0));    \n    \n        if (int(mod(float(iTechnique), 2.0)) == 0)\n\t\t\tiTechnique = 0;\n    }\n   \n    vec2 uv = fragCoord.xy \/ iResolution.x;\n    \n    \/\/---------------------------------------------------------------------------------------------------------\n    \/\/ [LEFT SIDE] - Combined normal, switches between technique\n    \/\/---------------------------------------------------------------------------------------------------------\n    \/\/ Base Normal (Disk)\n    vec2 uvN = uv;\n    uvN *= (iResolution.x\/iResolution.y);\n    uvN = uvN * 1.2 - vec2(0.12, 0.16);\n\n  \tvec3 BN = vec3(0.5, 0.5, 1.0);\n    if (uvN.x > 0.0 && uvN.x < 0.83 && uvN.y < 0.83 && uvN.y > 0.0)\n    {\n        BN = ComputeBaseNormal(uvN * vec2(1.2,1.2));\n    }\n    \n    \/\/ Detail Normal\n\tvec2 uvDN = uvN;\n    vec3 n1 = ComputeDetailNormal(uvDN);\n \n\t\/\/ Combined Normal\n    vec3 N = CombineNormal(BN, n1, iTechnique);\n\n    \/\/---------------------------------------------------------------------------------------------------------\n    \/\/ [RIGHT SIDE] - Combined normal with lighting, switches between technique\n    \/\/---------------------------------------------------------------------------------------------------------\n    \/\/ Base Normal (Disk)\n    uvN = uv + vec2(0.28, 0.0);\n    uvN *= (iResolution.x\/iResolution.y);\n    uvN = uvN * 1.2 - vec2(0.12, 0.16);\n\n  \tBN = vec3(0.5, 0.5, 1.0);\n    if (uvN.x > 1.66 && uvN.y > 0.0 && uvN.y < 0.83 && uvN.x < 2.50)\n    {\n        BN = ComputeBaseNormal(uvN * vec2(1.2,1.2));\n    }\n    \n    \/\/ Detail Normal\n\tuvDN = uvN+vec2(0.33,0);\n    n1 = ComputeDetailNormal(uvDN);\n \n\t\/\/ Combined Normal\n    vec3 N2 = CombineNormal(BN, n1, iTechnique);\n   \t\n    vec3 color = N; \n    \n\tfloat Time = iTime;\n    vec3 light = normalize(vec3(sin(Time),0,  1));\n\tlight = normalize(vec3(cos(iTime), sin(iTime), 1.0));    \n    vec3 lit = vec3(saturate(dot(light, N2)));\n\n    \/\/---------------------------------------------------------------------------------------------------------\n    \/\/ [BORDERS AND TEXT]\n    \/\/---------------------------------------------------------------------------------------------------------\n    \/\/ Mix normal and lit result\n\tcolor = mix(N*0.5 + 0.5, lit, float(uv.x > 0.5));\n\n    \/\/ Borders\n    color *= float((uv.y > 0.02));\n    color *= float((uv.y < 0.54));\n    color *= float((uv.x < 0.49) || (uv.x > 0.51));\n    color *= float((uv.x > 0.02) && (uv.x < 0.98));\n    \n    \/\/ Text\n    uv = fragCoord.xy \/ DOWN_SCALE;\n    vec3 textColor = vec3((1.-distance(mod(uv,vec2(1.0)),vec2(0.65)))*1.2) * PrintText(floor(uv), iTechnique);\n    \n\tfragColor = vec4(color+textColor, 1.0);\n}","name":"","description":"","type":"image"}]}];    var gUseScreenshots = piIsMobile();
    var gThemeName = "classic";



    </script>
</head>

<!-- <body onload="resultsInit(12,null,null)"> -->
<body onload="resultsInitStatic(12,null,null)">

<!-- header =================================================================================== -->


<div id="header">

    <div id="headerBlock1">
        <a href="/" id="headerTitle">Shadertoy</a>
        <form name="formSearch" action="/results" method="get" style="display:inline-block;">
        <div  id="headerSearch">
            <input type="search" id="mySearch" name="query" placeholder="Search..." value=""/>
        </div>
        </form>
    </div>

    <div id="headerBlock2">
            <a class="headerLinks" href="/browse">Browse</a>
        <a class="headerLinks" href="/new">New</a>
        <a class="headerLinks" href="/signin">Sign In</a>
        </div>
</div>
<!-- content ================================================================================== -->

<div id="content">

  <div id="controls">
    <div>
      <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
      Sort:      </div>
      <div class="controlOptions"><div class="pageButtonsCurrent" href="/results?query=&sort=popular&filter=">Popular</div><a class="pageButtons" href="/results?query=&sort=newest&filter=">Newest</a><a class="pageButtons" href="/results?query=&sort=love&filter=">Love</a><a class="pageButtons" href="/results?query=&sort=hot&filter=">Hot</a></div>
    </div>

    <div id="controlFilter">
      <div style="display:flex;margin-right:8px;align-items:center;">Filter:</div>
      <div class="controlOptions"> <a class="pageButtons" href="/results?query=&sort=popular&filter=multipass">Multipass</a><a class="pageButtons" href="/results?query=&sort=popular&filter=soundoutput">GPU Sound</a><a class="pageButtons" href="/results?query=&sort=popular&filter=vr">VR</a><a class="pageButtons" href="/results?query=&sort=popular&filter=soundinput">Microphone</a><a class="pageButtons" href="/results?query=&sort=popular&filter=musicstream">Soundcloud</a><a class="pageButtons" href="/results?query=&sort=popular&filter=webcam">Webcam</a></div>
    </div>

    <div>
        <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
        View:</div>
        <div><a class="pageButtons" href="/slideshow?query=&sort=popular">Slideshow</a></div>
    </div>

    <div class="navigation" id="navTop" ><span style="padding-right:8px;">Results (74098):</span><div class="controlOptions"><a id="pageButtonFirst" class="pageButtons" href="results?query=&sort=popular&from=0&num=12">1</a><span>...</span><a id="pageButton"0 class="pageButtons" href="results?query=&sort=popular&from=480&num=12">41</a><a id="pageButton"1 class="pageButtons" href="results?query=&sort=popular&from=492&num=12">42</a><div id="pageButton"2 class="pageButtonsCurrent" href="results?query=&sort=popular&from=504&num=12">43</div><a id="pageButton"3 class="pageButtons" href="results?query=&sort=popular&from=516&num=12">44</a><a id="pageButton"4 class="pageButtons" href="results?query=&sort=popular&from=528&num=12">45</a><span>...</span><a id="pageButtonLast" class="pageButtons" href="results?query=&sort=popular&from=74088&num=12">6175</a></div>
</div>
  </div>


  <div id="shaderGrid">
    <div class='searchResult'><div class='searchResultContainer' id='Preview_0_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_0_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_0_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_0_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_0_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_0_Thumnail'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_0_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_0_Info'>  <span class='previewText'  id='Preview_0_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_0_TextUser'></span>  <span class='previewStats' id='Preview_0_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_1_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_1_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_1_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_1_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_1_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_1_Thumnail'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_1_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_1_Info'>  <span class='previewText'  id='Preview_1_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_1_TextUser'></span>  <span class='previewStats' id='Preview_1_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_2_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_2_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_2_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_2_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_2_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_2_Thumnail'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_2_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_2_Info'>  <span class='previewText'  id='Preview_2_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_2_TextUser'></span>  <span class='previewStats' id='Preview_2_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_3_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_3_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_3_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_3_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_3_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_3_Thumnail'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_3_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_3_Info'>  <span class='previewText'  id='Preview_3_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_3_TextUser'></span>  <span class='previewStats' id='Preview_3_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_4_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_4_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_4_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_4_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_4_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_4_Thumnail'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_4_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_4_Info'>  <span class='previewText'  id='Preview_4_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_4_TextUser'></span>  <span class='previewStats' id='Preview_4_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_5_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_5_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_5_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_5_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_5_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_5_Thumnail'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_5_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_5_Info'>  <span class='previewText'  id='Preview_5_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_5_TextUser'></span>  <span class='previewStats' id='Preview_5_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_6_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_6_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_6_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_6_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_6_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_6_Thumnail'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_6_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_6_Info'>  <span class='previewText'  id='Preview_6_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_6_TextUser'></span>  <span class='previewStats' id='Preview_6_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_7_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_7_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_7_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_7_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_7_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_7_Thumnail'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_7_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_7_Info'>  <span class='previewText'  id='Preview_7_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_7_TextUser'></span>  <span class='previewStats' id='Preview_7_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_8_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_8_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_8_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_8_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_8_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_8_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_8_Thumnail'>        <img class='previewThumbnailImage' id='Preview_8_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_8_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_8_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_8_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_8_Info'>  <span class='previewText'  id='Preview_8_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_8_TextUser'></span>  <span class='previewStats' id='Preview_8_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_9_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_9_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_9_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_9_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_9_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_9_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_9_Thumnail'>        <img class='previewThumbnailImage' id='Preview_9_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_9_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_9_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_9_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_9_Info'>  <span class='previewText'  id='Preview_9_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_9_TextUser'></span>  <span class='previewStats' id='Preview_9_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_10_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_10_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_10_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_10_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_10_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_10_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_10_Thumnail'>        <img class='previewThumbnailImage' id='Preview_10_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_10_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_10_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_10_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_10_Info'>  <span class='previewText'  id='Preview_10_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_10_TextUser'></span>  <span class='previewStats' id='Preview_10_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_11_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_11_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_11_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_11_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_11_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_11_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_11_Thumnail'>        <img class='previewThumbnailImage' id='Preview_11_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_11_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_11_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_11_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_11_Info'>  <span class='previewText'  id='Preview_11_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_11_TextUser'></span>  <span class='previewStats' id='Preview_11_Stats'></span></div></div>  </div>
  <br>
  <div class="navigation" id="navBottom" ><span style="padding-right:8px;">Results (74098):</span><div class="controlOptions"><a id="pageButtonFirst" class="pageButtons" href="results?query=&sort=popular&from=0&num=12">1</a><span>...</span><a id="pageButton"0 class="pageButtons" href="results?query=&sort=popular&from=480&num=12">41</a><a id="pageButton"1 class="pageButtons" href="results?query=&sort=popular&from=492&num=12">42</a><div id="pageButton"2 class="pageButtonsCurrent" href="results?query=&sort=popular&from=504&num=12">43</div><a id="pageButton"3 class="pageButtons" href="results?query=&sort=popular&from=516&num=12">44</a><a id="pageButton"4 class="pageButtons" href="results?query=&sort=popular&from=528&num=12">45</a><span>...</span><a id="pageButtonLast" class="pageButtons" href="results?query=&sort=popular&from=74088&num=12">6175</a></div>
</div>  <br>      
</div>

<!-- footer ================================================================================== -->

<div id="footer">
    
    <div><span style="color:#ffffff;">Community Forums</span>
      <ul>
      <li><a class="regular" href="/events">Official Events</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/147749602472741">In Facebook (english)</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/1339783682699494">In Facebook (korean)</a></li>
      <li><a class="regular" href="https://discord.gg/XtmMN6E">In Discord</a> (<a class="regular" href="https://discordapp.com/channels/578696555612209173/579531723348639754">direct link</a>)</li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Feedback and Support</span>
      <ul>
      <li><a class="regular" href="https://www.facebook.com/Shadertoy">Facebook</a></li>
      <li><a class="regular" href="https://twitter.com/shadertoy">Twitter</a></li>
      <li><a class="regular" href="https://www.patreon.com/shadertoy">Patreon</a></li>
      <li><a class="regular" href="https://trello.com/b/5hM0CjId">Roadmap</a></li>

      
      </ul>
    </div>

    <div><span style="color:#ffffff;">Shadertoy</span>
      <ul>
      <li><a class="regular" href="/store">Store</a></li>
      <li><a class="regular" href="/howto">Documentation</a></li>
      <li><a class="regular" href="/terms">Terms & Privacy</a></li>
      <li><a class="regular" href="/about">About</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Apps and Plugins</span>
      <ul>
      <li><a class="regular" href="https://itunes.apple.com/us/app/shadertoy/id717961814">Official iPhone App</a> by <a class="user" href="/user/reinder">Reinder</a></li>
      <li><a class="regular" href="https://steamcommunity.com/sharedfiles/filedetails/?id=1726697188">Screensaver</a> by <a class="user" href="/user/kosro">Kosro</a></li>
      <li><a class="regular" href="https://chrome.google.com/webstore/detail/shadertoy-unofficial-plug/ohicbclhdmkhoabobgppffepcopomhgl">Shadertoy plugin</a> by <a class="user" href="/user/patu">Patu</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Tutorials</span>
      <ul>
      <li><a class="regular" href="https://www.youtube.com/watch?v=0ifChJ0nJfM">Shader coding intro</a> by <a class="user" href="/user/iq">iq</a></li>
      <li><a class="regular" href="https://shadertoyunofficial.wordpress.com/">Shadertoy Unofficial</a> by <a class="user" href="/user/FabriceNeyret2">FabriceNeyret2</a></li>
      </ul>
    </div>

</div>

<div id="compliance" style="padding-bottom:6px;visibility:hidden;left:0;top:0px;width:100%;background-color:rgb(200,120,20,0.93);position:absolute;color:#FFFFFF">
    <div style="text-align: center; margin-top:8px">
        We use cookies to give you the best experience on our website. If you continue using Shadertoy, we'll assume that you are happy to receive all cookies on this website. 
        For more information, please review our <a class="regular" href="/terms">Terms & Privacy</a>.
    </div> 
    <div style="text-align: center;margin-top:6px">
        <button type="button" style="width:100px;font-size:inherit" onclick="acceptCompliance()">Accept</button>
    </div>
</div>

<script>
(function runCompliance() 
{
    let showCompliance = 1;
    let allcookies = document.cookie;
    let cookiearray = allcookies.split(';');
    for (var i=0; i<cookiearray.length; i++)
    {
        let name  = cookiearray[i].split('=')[0];
        let value = cookiearray[i].split('=')[1];
        if (name.trim() == "scmp") 
        {
            showCompliance = value;
            break;
        }
    }

    if (showCompliance === 1) 
    {
        var ve = document.getElementById("compliance");
        ve.style.visibility="visible";
    }
})();

function acceptCompliance()
{
    let now = new Date();
    now.setTime( now.getTime() + (5*365*24*60*60*1000) );
    document.cookie="scmp=0;expires=" + now.toUTCString() + ";";

    var ve = document.getElementById("compliance");
    ve.style.visibility="hidden";
}
</script>

</body>
</html>
