<!DOCTYPE HTML>
<html lang="en">
<head>

    
<script async src="https://www.googletagmanager.com/gtag/js?id=G-7SYLWGZYJ2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-7SYLWGZYJ2');
</script>

<title>Browse (58) - Shadertoy BETA</title>
<meta charset="utf-8" />
<meta name="Keywords" content="shadertoy, shader toy, quilez, inigo, jeremias, pol, fractals, demoscene, computer graphics, mathematics, rendering, demo, 3D, realtime, shader, raytracing, raymarching, webgl, glsl" />
<meta name="Description" content="Build shaders, share them, and learn from the best community." />
<meta name="Author" content="Beautypi" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<link rel="image_src" href="https://www.shadertoy.com/img/logo.png" />
<link rel="apple-touch-icon" href="/img/launch_icon_57.png"/>
<link rel="apple-touch-icon" sizes="72x72" href="/img/launch_icon_72.png"/>
<link rel="apple-touch-icon" sizes="114x114" href="/img/launch_icon_114.png"/>
<link rel="shortcut icon" href="/img/favicon.ico"/>

<style>::-webkit-scrollbar {
    height: 8px;
    width: 8px;
    background: #404040;
}

::-webkit-scrollbar-thumb
{
    background: #909090;
    border-radius: 0ex;
}

::-webkit-scrollbar-corner
{
    background: #000;
}

::-webkit-input-placeholder
{
	font-style:italic;
}
input:-moz-placeholder, textarea:-moz-placeholder
{
	font-style:italic;
}
input.placeholder-text, textarea.placeholder-text
{
	font-style:italic;
}

pre 
{
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
    white-space: -pre-wrap;
    white-space: -o-pre-wrap;
    word-wrap: break-word;
}

@font-face
{
    font-family: Lobster;
    src: url("/img/lobster.otf") format("opentype");
}

div#centerScreen
{
    left: 50%;
    top: 50%;
    position: absolute;
}

a.headerLinks:hover
{
    background-color:#505050;
    color : #ff8020;
}

body
{
    color: #000000;
    font-size:12px;
    font-style:normal;
    font-family:Tahoma,Arial;
    background-repeat: no-repeat;
    //background-attachment: fixed;
    padding:0px;
    margin:0px;
    text-align: left;
    background-color: #d0d0d0;
    background-repeat: repeat;
    user-select: text;
}

a,
a:hover,
a:visited
{
  color : inherit;
}

div#content {
    width: 95%;
    overflow: hidden;
    margin: auto;
    padding: 0px;
    min-height: calc(100vh - 80px);
    //box-sizing: border-box;
}


.notificationCount
{
 background-color:#ff0000;
 padding-left:3px;
 padding-right:1px;
 padding-top:1px;
 padding-bottom:1px;
}

div#header
{
    background-color: #404040;
    top: 0px;
    left: 0px;
    width: 100%;
    padding: 0;
    margin: 0;
    color: #ffffff;
    display: flex;
    flex-direction:row;
}

#headerBlock1
{
    width: 50%;
    display:flex;
    align-items:center;
}

a#headerTitle
{
    font-size: 2.25em;
    font-family: Lobster,Tahoma,Arial;
    text-decoration: none;
    padding-left:32px;
    padding-right:32px;
}

#headerSearch
{
    display: inline-block;
    color: #000000;
    width: 300px;
}

input[type=search]#mySearch
{
    width: 100%;
    border-radius: 6px;
    border: 1px solid black;
    padding:12px;
}

#headerBlock2
{
    width: 50%;
    margin-left: auto;
    display: flex;
    justify-content: flex-end;
}


a#headerTitle:hover
{
    color : #ff8020;
}

a.headerLinks
{
    font-weight: bold;
    padding-top: 14px;
    padding-bottom: 14px;
    padding-left: 14px;
    padding-right: 14px;
    margin:0px;
    text-decoration: none;
    transition: background-color 0.15s linear, color 0.15s linear;
}

#footer
{
    background-color: rgba(64,64,64,0.25);
    color: #000000;
    padding: 0px;
    margin: 0px;
    width: 100%;
    display: flex;
    justify-content: space-between;
    flex-wrap: wrap;
}

#footer div
{
    padding-top:10px;
    padding-bottom:0px;
    padding-left:16px;
    padding-right:16px;
}

#footer div ul
{
    margin-left:0px;
    padding-left:16px;
}

#footer div ul li
{
    padding-top:6px;
}

a.regular
{
    font-weight:bold;
    text-decoration:none
}

a.regular:hover
{
  color : #ff8020;
}

a.user
{
    font-weight:bold;
    text-decoration:none;
}

a.user:hover
{
  color : #ff8020;
  text-decoration: underline;
}

.uiButton
{
    border: none;
    outline: none;
    margin: 0px;
    padding: 0px;
    width: 22px;
    height: 22px;
    position: absolute;
    cursor: pointer;
    border-radius: 4px;
}

.uiButton:hover
{
    box-shadow: inset 0px 0px 1px 1px #808080, 0px 0px 1px 1px #808080;
}

.uiDivBUtton
{
    cursor:pointer;
}

.uiDivBUtton:hover
{
    color: #ffffff;
}


.dialog
{
    display: block;
    background-color: #e0e0e0;
    color: #000000;
    border:1px solid #000;
    padding:0px;
    margin:0px;
    text-align:left;
    border-radius: 4px;
    box-shadow:4px 4px 6px 0px rgba(0,0,0,0.5);
    overflow: hidden;
    z-index:1000;
    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;
}

.dialogHeader
{
    left:0px;
    top: 0px;
    width:100%;
    height:32px;
    position: absolute;
    background-color: #808080;
    cursor:move;
}

.dialogTitle
{
    left: 12px;
    top: 4px;
    position: absolute;
    padding: 0px;
    margin: 0px;
    color:#000000;
    font-size:1.5em;
    text-align: left;
    user-select: none;
    -moz-user-select: -moz-none;
    -webkit-user-select: none;
}

.dialogOverlay
{
    z-index:1000;

    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;

    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    width:100%;
    height:100%;
    position:absolute;

    background-color:rgba(0,0,0,.4);
}

.viewsIcon, .likesIcon
{
    border: none;
    outline: none;
    display:inline-block;
    background-repeat:no-repeat;
    top:0px;
    left:0px;
    padding:0px;
    padding-right: 2px;
    margin:0px;
    position:relative;
}

.userPictureSmall
{
    background-color:#808080;
    border: 1px solid #000000;
    width:32px;
    height:32px;
}

.dialogCloseButton
{
    right:8px;
    top: 4px;
    width:22px;
    height:22px;
    position: absolute;
    background-image: url("/img/close.png");
    cursor: pointer;
    border-radius: 4px;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContentButtons
{
     padding:0;
     border:0;
     text-align: justify;
     left: 24px;
     bottom:40px;
     position:absolute;
}

.dialogButton
{
    text-align: center;
    vertical-align: middle;
    display: inline-block;
    border-radius: 4px;
    font-weight: bold;
    cursor: pointer;
    padding-bottom:5px;
    padding-top:4px;
    padding-left: 8px;
    padding-right: 8px;
    margin-left:4px;
    margin-right:4px;
    text-decoration: none;
    color:#000000;
    width: 80px;
    -moz-transition:    background-color 0.15s linear, color 0.15s linear;
    -webkit-transition: background-color 0.15s linear, color 0.15s linear;
    transition:         background-color 0.15s linear, color 0.15s linear;
}

.dialogButton:hover
{
  background-color:#808080;
  color : #ff8020;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContent
{
    color: inherit;
    overflow: auto;
    width:100%;
    height:100%;
    left: 0px;
    top: 32px;
    position:absolute
}

.dialogContentBody
{
    color: inherit;
    width:100%;
    height:auto;
    padding-top:24px;
    padding-bottom:24px;
    padding-left:24px;
    padding-right:24px;
    text-align: left;
}

.formButton
{
    font-weight:bold;
	color:#ffffff;
	border:none;
    text-align:center;
	background-color:#808080;
    border-radius: 4px;
	padding-left:8px;
	padding-right:8px;
	padding-top:4px;
	padding-bottom:4px;
    cursor:pointer;
    min-width:80px;
    box-sizing: border-box;
}
.formInput {
    border-radius: 6px;
    border: 1px solid black;
    padding: 4px;
    border: none;
}
.formButton:hover {
    background-color: #e0e0e0;
}
.formButton:disabled
{
	color:#b0b0b0;
	background-color:#808080;
}

.formButtonSmall
{
    color:#ffffff;
    border:none;
    text-align:center;
    background-color:#808080;
    border-radius: 4px;
    padding-left:2px;
    padding-right:2px;
    padding-top:2px;
    padding-bottom:2px;
    cursor:pointer;
    min-width:40px;
}

.formButtonSmall:hover
{
    background-color: #e0e0e0;
}

.formButtonSmall:disabled
{
    color:#b0b0b0;
    background-color:#808080;
}

.formButtonSmall.disabled2,
.formButton.disabled2 { color:#b0b0b0; background-color:#808080; pointer-events: none; }

.inputForm
{
    padding-left:2%;
    padding-right:2%;
    resize: none;
    text-align: left;
    background-color:#e0e0e0;
    outline: none;
    border-radius: 4px;
    border: 1px solid #808080;
    color:inherit;
    box-sizing: border-box;
}

.inputForm:focus
{
    border: 1px solid #AFCDD8;
    background-color: #EBF2F4;
}

.transparentPannel
{
    background-color:rgba(64,64,64,0.1);
    padding:16px;
}

.comment, .commentSelf, .commentNew
{
    border-radius: 4px;
    width: 100%;
    margin-left: 0px;
    margin-right: 0px;
    margin-top: 0px;
    margin-bottom: 6px;

    padding: 14px;
    box-sizing: border-box;
    display: grid;
    grid-template-columns: 32px auto 8px;
    grid-template-rows: 1fr;
    grid-gap:8px;
}

.comment:nth-child(even)
{
    background-color: rgba(64,64,64,0.1);
}

.comment:nth-child(odd)
{
    background-color: rgba(128,128,128,0.1);
}

.commentSelf
{
    background-color: rgba(240,160,64,0.1);
}

.commentNew
{
    padding-right: 0px;
    grid-template-columns: 40px auto;
}

.commentContent
{
    vertical-align: top;
    text-align: left;
    word-break: break-all;
    word-break: break-word;
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
}


/* ----------------------- media resolutions ------------------------ */

@media screen and (max-width:799px)
{
    div#header {flex-direction:column; }
    #headerBlock1 { width:100%; }
    #headerBlock2 { width:100%; justify-content: space-around;}
    div#headerSearch {width:200px;}
    input#mySearch { width:200px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:10px; }
}

@media screen and (min-width:800px) and (max-width:1279px)
{
    body { font-size: 9px; }
    div#headerSearch {width: 250px;}
    input#mySearch { width:250px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:11px; }
}

@media screen and (min-width:1280px) and (max-width:1439px)
{
    body { font-size: 10px; }
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1440px) and (max-width:1919px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1920px) and (max-width:2559px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}

@media screen and (min-width:2560px) 
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}
body
{
    background-image: url("/img/themes/classic/background.jpg");
}
</style>

    <script>"use strict"

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piCamera
//
//==============================================================================

function piCamera()
{
    var mMatrix = setIdentity();
    var mMatrixInv = setIdentity();

    var mPosition = [0.0,0.0,0.0];
    var mXRotation = 0.0;
    var mYRotation = 0.0;

    var mPositionTarget = [0.0,0.0,0.0];
    var mXRotationTarget = 0.0;
    var mYRotationTarget = 0.0;

    var me = {};
/*
    me.Set = function( pos, dir, roll) 
             {
                 mMatrix    = setLookat( pos, add(pos,dir), [Math.sin(roll),Math.cos(roll),Math.sin(roll)] );
                 mMatrixInv = invertFast( mMatrix );
             };
*/
    me.SetPos = function(pos)
                {
                    mPosition = pos;
                    //mMatrix[ 3] = -(mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                    //mMatrix[ 7] = -(mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                    //mMatrix[11] = -(mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                };
/*
    me.GlobalMove = function(pos)
                    {
                        mMatrix[ 3] -= (mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                        mMatrix[ 7] -= (mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                        mMatrix[11] -= (mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                        mMatrixInv = invertFast(mMatrix);
                    };
*/
    me.LocalMove = function( dis )
                    {
                        dis = matMulvec( setRotationY(-mYRotation), dis);
                        mPositionTarget = sub(mPositionTarget,dis)
                    };

    me.RotateXY = function( x, y)
                  {
                    mXRotationTarget -= x;
                    mYRotationTarget -= y;
                    mXRotationTarget = Math.min( Math.max( mXRotationTarget, -Math.PI/2), Math.PI/2 );
                  };


    me.CameraExectue = function( dt )
    {
        // smooth position
        mXRotation += (mXRotationTarget-mXRotation) * 12.0*dt;
        mYRotation += (mYRotationTarget-mYRotation) * 12.0*dt;
        mPosition = add(mPosition, mul( sub(mPositionTarget, mPosition), 12.0*dt));

        // Make Camera matrix
        mMatrix = matMul( matMul(setRotationX(mXRotation), 
                                 setRotationY(mYRotation)),  
                                 setTranslation(mPosition));
        mMatrixInv = invertFast(mMatrix);

    }

    me.GetMatrix = function() { return mMatrix; };
    me.GetMatrixInverse = function() { return mMatrixInv; };
    me.SetMatrix = function( mat ) 
                    {
                        mMatrix = mat;
                        mMatrixInv = invertFast(mMatrix);

                        mPosition = getXYZ(matMulpoint(mat, [0.0,0.0,0.0]));
                        mPositionTarget = mPosition;
                    };

    me.GetPos = function() { return getXYZ(matMulpoint(mMatrixInv, [0.0,0.0,0.0])); }
    me.GetDir = function() { return getXYZ(normalize(matMulvec(mMatrixInv, [0.0,0.0,-1.0]))); }

    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piFile
//
//==============================================================================

function piFile( binaryDataArrayBuffer )
{
    // private
    //var mDataView = new DataView( binaryDataArrayBuffer, 0 );
    var mDataView = binaryDataArrayBuffer;
    var mOffset = 0;

    // public members
    var me = {};
    me.mDummy = 0;
/*
    // public functions
    me.Seek = function( off ) { mOffset = off - 3; };
    me.ReadUInt16 = function()  { var res = mDataView.getUint16( mOffset ); mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = mDataView.getUint32( mOffset ); mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = mDataView.getFloat32( mOffset ); mOffset+=4; return res; };
*/

    me.Seek = function( off ) { mOffset = off; };
    me.ReadUInt8  = function()  { var res = (new Uint8Array(mDataView,mOffset))[0]; mOffset+=1; return res; };
    me.ReadUInt16 = function()  { var res = (new Uint16Array(mDataView,mOffset))[0]; mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = (new Uint32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = (new Float32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadFloat32Array = function(n) 
                          { 
                              var src = new Float32Array(mDataView, mOffset);
                              var res = [];  for( var i=0; i<n; i++ ) { res[i] = src[i]; }
                              mOffset += 4*n;
                              return res;
                          };
    me.ReadFloat32ArrayNative = function(n) { var src = new Float32Array(mDataView, mOffset); mOffset += 4*n; return src; };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piMesh
//
//==============================================================================

function piMesh()
{
    this.mChunks = [];
    this.mPrimitiveType = 0;
    this.mVertexFormat = null;
}

/*
piMesh.prototype.normalize = function( ppos, npos )
{
    var numv = this.mVertexData.length;
    var numt = this.mIndices.length;

    for( var i=0; i<numv; i++ )
    {
        //float *v = (float*)piMesh_GetVertexData( me, i, npos );
        //v[0] = 0.0f;
        //v[1] = 0.0f;
        //v[2] = 0.0f;
        this.mVerts[8 * i + 3] = 0.0;
        this.mVerts[8 * i + 4] = 0.0;
        this.mVerts[8 * i + 5] = 0.0;
    }

    for( var i=0; i<numt; i++ )
    {
        piMeshFace *face = me->mFaceData.mIndexArray[0].mBuffer + i;

        const int ft = face->mNum;
        
        vec3 nor = vec3( 0.0f, 0.0f, 0.0f );
        for( int j=0; j<ft; j++ )
        {
            const vec3 va = *((vec3*)piMesh_GetVertexData( me, face->mIndex[ j      ], ppos ));
            const vec3 vb = *((vec3*)piMesh_GetVertexData( me, face->mIndex[(j+1)%ft], ppos ));

            nor += cross( va, vb );
        }

        for( int j=0; j<ft; j++ )
        {
            vec3 *n = (vec3*)piMesh_GetVertexData( me, face->mIndex[j], npos );
            n->x += nor.x;
            n->y += nor.y;
            n->z += nor.z;
        }
    }

    for( var i=0; i<numv; i++ )
    {
        vec3 *v = (vec3*)piMesh_GetVertexData( me, i, npos );
        *v = normalize( *v );
    }
}
*/

piMesh.prototype.createCube = function(renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([ -1.0, -1.0, -1.0,
                                       1.0, -1.0, -1.0,
                                      -1.0,  1.0, -1.0,
                                       1.0,  1.0, -1.0,
                                      -1.0, -1.0,  1.0,
                                       1.0, -1.0,  1.0,
                                      -1.0,  1.0,  1.0,
                                       1.0,  1.0,  1.0 ]),

                        mIndices : new Uint16Array([ 0, 2, 1,   1, 2, 3,   5, 1, 3,   5, 3, 7,   4, 5, 7,   4, 7, 6,   4, 6, 2,   4, 2, 0,   6, 7, 3,   6, 3, 2,   4, 0, 1,   4, 1, 5 ]),
                        mNumVertices : 8,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };

    this.mVertexFormat = { mStride:12, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}

piMesh.prototype.createCubeSharp = function (renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 1.0,
                                    -1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 0.0,

                                     1.0, 1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 0.0,

                                     1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 1.0,
                                    -1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   1.0, 1.0,
                                     1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   1.0, 0.0,

                                    -1.0, 1.0, 1.0,  -1.0, 0.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0,-1.0,  -1.0, 0.0, 0.0,   0.0, 1.0,
                                    -1.0,-1.0,-1.0,  -1.0, 0.0, 0.0,   1.0, 1.0,
                                    -1.0,-1.0, 1.0,  -1.0, 0.0, 0.0,   1.0, 0.0 ]),

                        mIndices : new Uint16Array([0,1,2, 0,2,3,   4,5,6, 4,6,7,    8,9,10,8,10,11,   12,13,14,12,14,15,   16,17,18,16,18,19,   20,21,22,20,22,23]),
                        mNumVertices : 24,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };


    this.mVertexFormat = { mStride:32, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}


piMesh.prototype.createUnitQuad = function (renderer)
{
    this.mPrimitiveType = 0;
    this.mVertexFormat = { mStride:8, mChannels: [ {mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false} ] };

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0,  1.0, 1.0,  1.0]),
                        mIndices : new Uint16Array([0, 2, 1, 1, 2, 3]),
                        mNumVertices : 4,
                        mNumFaces : 2, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };
 
    return true;
}




piMesh.prototype.destroy = function()
{
    //delete this.mVerts;   this.mVerts = null;
    //delete this.mIndices; this.mIndices = null;
}

piMesh.prototype.scale = function (x, y, z)
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] *= x;
            this.mChunks[j].mVerts[stride * i + 1] *= y;
            this.mChunks[j].mVerts[stride * i + 2] *= z;
        }
    }
}

piMesh.prototype.translate = function (x, y, z) 
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] += x;
            this.mChunks[j].mVerts[stride * i + 1] += y;
            this.mChunks[j].mVerts[stride * i + 2] += z;
        }
    }
}

piMesh.prototype.GPULoad = function (renderer)
{
    for( var i=0; i<this.mChunks.length; i++ )
    {
        var vbo = renderer.CreateVertexArray(this.mChunks[i].mVerts, renderer.BUFTYPE.STATIC );
        if (vbo == null)
            return false;

        var ibo = renderer.CreateIndexArray(this.mChunks[i].mIndices, renderer.BUFTYPE.STATIC);
        if (ibo == null)
            return false;

        this.mChunks[i].mVBO = vbo;
        this.mChunks[i].mIBO = ibo;
    }
    return true;
}

piMesh.prototype.GPURender = function (renderer, positions )//, matPrj, matCam )
{
    //renderer.SetShaderConstantMat4F("unMPrj", matPrj, false );

    var num = this.mChunks.length;
    for( var i=0; i<num; i++ )
    {
        //var mat =  matMul( matCam, this.mChunks[i].mTransform );
        //renderer.SetShaderConstantMat4F("unMMod", mat, false);

        renderer.AttachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat, positions );
        renderer.AttachIndexArray(this.mChunks[i].mIBO );
        renderer.DrawPrimitive(renderer.PRIMTYPE.TRIANGLES, this.mChunks[i].mNumFaces * 3, true, 1);
        renderer.DetachIndexArray(this.mChunks[i].mIBO);
        renderer.DetachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat );
    }
}
//==============================================================================
//
// piLibs 2014-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piRenderer
//
//==============================================================================

function piRenderer()
{
    // private members

    var mGL = null;
    var mBindedShader = null;
    var mIs20 = false;
    var mFloat32Textures;
    var mFloat32Filter;
    var mFloat16Textures;
    var mDrawBuffers;
    var mDepthTextures;
    var mDerivatives;
    var mFloat16Filter;
    var mShaderTextureLOD;
    var mAnisotropic;
    var mRenderToFloat32F;
    var mDebugShader;
    var mAsynchCompile;

    var mVBO_Quad = null;
    var mVBO_Tri = null;
    var mVBO_CubePosNor = null;
    var mVBO_CubePos = null;
    var mShaderHeader = ["",""];
    var mShaderHeaderLines = [0,0];

    // public members
    var me = {};

    me.CLEAR      = { Color: 1, Zbuffer : 2, Stencil : 4 };
    me.TEXFMT     = { C4I8 : 0, C1I8 : 1, C1F16 : 2, C4F16 : 3, C1F32 : 4, C4F32 : 5, Z16 : 6, Z24 : 7, Z32 : 8, C3F32:9 };
    me.TEXWRP     = { CLAMP : 0, REPEAT : 1 };
    me.BUFTYPE    = { STATIC : 0, DYNAMIC : 1 };
    me.PRIMTYPE   = { POINTS : 0, LINES : 1, LINE_LOOP : 2, LINE_STRIP : 3, TRIANGLES : 4, TRIANGLE_STRIP : 5 };
    me.RENDSTGATE = { WIREFRAME : 0, FRONT_FACE : 1, CULL_FACE : 2, DEPTH_TEST : 3, ALPHA_TO_COVERAGE : 4 };
    me.TEXTYPE    = { T2D : 0, T3D : 1, CUBEMAP : 2 };
    me.FILTER     = { NONE : 0, LINEAR : 1, MIPMAP : 2, NONE_MIPMAP : 3 };
    me.TYPE       = { UINT8 : 0, UINT16 : 1, UINT32 : 2, FLOAT16: 3, FLOAT32 : 4, FLOAT64: 5 };

    // private functions

    var iFormatPI2GL = function( format )
    {
        if( mIs20 )
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA8,           mGLExternal: mGL.RGBA,             mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.R8,              mGLExternal: mGL.RED,              mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.R16F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA16F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.R32F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA32F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C3F32) return { mGLFormat: mGL.RGB32F,          mGLExternal: mGL.RGB,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT16, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z24)   return { mGLFormat: mGL.DEPTH_COMPONENT24, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z32)   return { mGLFormat: mGL.DEPTH_COMPONENT32F, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        }
        else
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.RED,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT, mGLExternal: mGL.DEPTH_COMPONENT, mGLType: mGL.UNSIGNED_SHORT }
        }

        return null;
     }

    // public functions

    me.Initialize = function( gl )
                    {
                        mGL = gl;

                        mIs20 = !(gl instanceof WebGLRenderingContext);

                        if( mIs20 )
                        {
                            mFloat32Textures  = true;
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = true;
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = true;
                            mDrawBuffers      = true;
                            mDepthTextures    = true;
                            mShaderTextureLOD = true;
                            mAnisotropic = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mGL.getExtension( 'EXT_color_buffer_float');
                            mDebugShader = mGL.getExtension('WEBGL_debug_shaders');
                            mAsynchCompile = mGL.getExtension('KHR_parallel_shader_compile');

							mGL.hint( mGL.FRAGMENT_SHADER_DERIVATIVE_HINT, mGL.NICEST);
                        }
                        else
                        {
                            mFloat32Textures  = mGL.getExtension( 'OES_texture_float' );
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = mGL.getExtension( 'OES_texture_half_float' );
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = mGL.getExtension( 'OES_standard_derivatives' );
                            mDrawBuffers      = mGL.getExtension( 'WEBGL_draw_buffers' );
                            mDepthTextures    = mGL.getExtension( 'WEBGL_depth_texture' );
                            mShaderTextureLOD = mGL.getExtension( 'EXT_shader_texture_lod' );
                            mAnisotropic      = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mFloat32Textures;
                            mDebugShader      = null;
                            mAsynchCompile    = null;
							
							if( mDerivatives !== null) mGL.hint( mDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, mGL.NICEST);
                        }
                        
                        
                        var maxTexSize = mGL.getParameter( mGL.MAX_TEXTURE_SIZE );
                        var maxCubeSize = mGL.getParameter( mGL.MAX_CUBE_MAP_TEXTURE_SIZE );
                        var maxRenderbufferSize = mGL.getParameter( mGL.MAX_RENDERBUFFER_SIZE );
                        var extensions = mGL.getSupportedExtensions();
                        var textureUnits = mGL.getParameter( mGL.MAX_TEXTURE_IMAGE_UNITS );
                        console.log("WebGL (2.0=" + mIs20 + "):" +
                                    " Asynch Compile: "  + ((mAsynchCompile !==null) ? "yes" : "no") +
                                    ", Textures: F32 ["   + ((mFloat32Textures !==null) ? "yes" : "no") +
                                    "], F16 ["   + ((mFloat16Textures !==null) ? "yes" : "no") +
                                    "], Depth [" + ((mDepthTextures   !==null) ? "yes" : "no") +
                                    "], LOD ["    + ((mShaderTextureLOD!==null) ? "yes" : "no") +
                                    "], Aniso ["   + ((mAnisotropic     !==null) ? "yes" : "no") +
                                    "], Units [" + textureUnits +
                                    "], Max Size [" + maxTexSize +
                                    "], Cube Max Size [" + maxCubeSize +
                                    "], Targets: MRT ["            + ((mDrawBuffers     !==null) ? "yes" : "no") +
                                    "], F32 ["     + ((mRenderToFloat32F!==null) ? "yes" : "no") +
                                    "], Max Size [" + maxRenderbufferSize + "]");

                        // create a 2D quad Vertex Buffer
                        var vertices = new Float32Array( [ -1.0, -1.0,   1.0, -1.0,    -1.0,  1.0,     1.0, -1.0,    1.0,  1.0,    -1.0,  1.0] );
                        mVBO_Quad = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                        mGL.bufferData( mGL.ARRAY_BUFFER, vertices, mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 2D triangle Vertex Buffer
                        mVBO_Tri = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0,   3.0, -1.0,    -1.0,  3.0] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePosNor = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0, -1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                               1.0,  1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                               1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                               1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                               1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0,  1.0, -1.0,   0.0,  0.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePos = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0,  1.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        //-------------------------------------------------------------------

                        mShaderHeader[0] = "";
                        mShaderHeaderLines[0] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[0] += "#version 300 es\n" +
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[0] += 6;
                        }
                        else
                        {
                            mShaderHeader[0] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "#endif\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+                                                
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[0] += 26;
                        }

                        //-------------------------------------------------------

                        mShaderHeader[1] = "";
                        mShaderHeaderLines[1] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[1] += "#version 300 es\n"+
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[1] += 6;
                        }
                        else
                        {
                            if( mDerivatives ) { mShaderHeader[1] += "#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n"; mShaderHeaderLines[1]+=3; }
                            if( mShaderTextureLOD  ) { mShaderHeader[1] += "#extension GL_EXT_shader_texture_lod : enable\n"; mShaderHeaderLines[1]++; }
                            mShaderHeader[1] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "#endif\n"+ 
                                                "vec4 texture(     sampler2D   s, vec2 c)                   { return texture2D(s,c); }\n"+
                                                "vec4 texture(     sampler2D   s, vec2 c, float b)          { return texture2D(s,c,b); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c )                  { return textureCube(s,c); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c, float b)          { return textureCube(s,c,b); }\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[1] += 30;
                            if( mShaderTextureLOD )
                            {
                            mShaderHeader[1] += "vec4 textureLod(  sampler2D   s, vec2 c, float b)          { return texture2DLodEXT(s,c,b); }\n";
                            mShaderHeader[1] += "vec4 textureGrad( sampler2D   s, vec2 c, vec2 dx, vec2 dy) { return texture2DGradEXT(s,c,dx,dy); }\n";
                            mShaderHeaderLines[1] += 2;

                            //mShaderHeader[1] += "vec4 texelFetch( sampler2D s, ivec2 c, int l) { return texture2DLodEXT(s,(vec2(c)+0.5)/vec2(800,450),float(l)); }\n";
                            //mShaderHeaderLines[1] += 1;
                            }
                        }

                        return true;
                    };

        me.GetCaps =    function ()
                        {   
                            return { mIsGL20 : mIs20,
                                     mFloat32Textures: mFloat32Textures != null,
                                     mFloat16Textures: mFloat16Textures != null,
                                     mDrawBuffers: mDrawBuffers != null,
                                     mDepthTextures: mDepthTextures != null,
                                     mDerivatives: mDerivatives != null,
                                     mShaderTextureLOD: mShaderTextureLOD != null };
                        };

        me.GetShaderHeaderLines = function (shaderType)
                        {   
                            return mShaderHeaderLines[shaderType];
                        };

        me.CheckErrors = function()
                         {
                                var error = mGL.getError();
                                if( error != mGL.NO_ERROR ) 
                                { 
                                    for( var prop in mGL ) 
                                    {
                                        if( typeof mGL[prop] == 'number' ) 
                                        {
                                            if( mGL[prop] == error )
                                            {
                                                console.log( "GL Error " + error + ": " + prop );
                                                break;
                                            }
                                        }
                                    }
                                }
                         };

        me.Clear =  function( flags, ccolor, cdepth, cstencil )
                    {
                        var mode = 0;
                        if( flags & 1 ) { mode |= mGL.COLOR_BUFFER_BIT;   mGL.clearColor( ccolor[0], ccolor[1], ccolor[2], ccolor[3] ); }
                        if( flags & 2 ) { mode |= mGL.DEPTH_BUFFER_BIT;   mGL.clearDepth( cdepth ); }
                        if( flags & 4 ) { mode |= mGL.STENCIL_BUFFER_BIT; mGL.clearStencil( cstencil ); }
                        mGL.clear( mode );
                    };


        me.CreateTexture = function ( type, xres, yres, format, filter, wrap, buffer)
                           {
                                if( mGL===null ) return null;

                                var id = mGL.createTexture();

                                var glFoTy = iFormatPI2GL( format );
                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                if( type===me.TEXTYPE.T2D )
                                {
                                    mGL.bindTexture( mGL.TEXTURE_2D, id );
//if( buffer==null )
    //mGL.texStorage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres);
//else
                                    mGL.texImage2D( mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap );

                                    if (filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                }
                                else if( type===me.TEXTYPE.T3D )
                                {
                                    if( mIs20 )
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_3D, id );
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_BASE_LEVEL, 0);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAX_LEVEL, Math.log2(xres));
                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_3D);
                                        }
                                        mGL.texImage3D( mGL.TEXTURE_3D, 0, glFoTy.mGLFormat, xres, yres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap );

                                        if (filter === me.FILTER.MIPMAP)
                                            mGL.generateMipmap( mGL.TEXTURE_3D );
                                        mGL.bindTexture( mGL.TEXTURE_3D, null );
                                    }
                                    else 
                                    {
                                        return null;
                                    }
                                }
                                else 
                                {
                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );

                                    // this works great if we know the number of required mipmaps in advance (1, or other)
                                   //mGL.texStorage2D( mGL.TEXTURE_CUBE_MAP, 1, glFoTy.mGLFormat, xres, yres );

                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                    if( filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                    }

                                    if (filter === me.FILTER.MIPMAP)
                                        mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );

                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                }
                        return { mObjectID: id, mXres: xres, mYres: yres, mFormat: format, mType: type, mFilter: filter, mWrap: wrap, mVFlip:false };
                        };

        me.CreateTextureFromImage = function ( type, image, format, filter, wrap, flipY) 
                                {
                                    if( mGL===null ) return null;

                                    var id = mGL.createTexture();

                                    var glFoTy = iFormatPI2GL( format );

                                    var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                    if( type===me.TEXTYPE.T2D )
                                    {
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);

                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.pixelStorei(mGL.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                                        if( mIs20 ) mGL.pixelStorei(mGL.UNPACK_COLORSPACE_CONVERSION_WEBGL, mGL.NONE );

                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);

                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);

                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if( filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                    }
                                    else if( type===me.TEXTYPE.T3D )
                                    {
                                        return null;
                                    }
                                    else 
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );

                                        if( filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                    }
                                    return { mObjectID: id, mXres: image.width, mYres: image.height, mFormat: format, mType: type, mFilter: filter, mWrap:wrap, mVFlip:flipY };
                                };

        me.SetSamplerFilter = function (te, filter, doGenerateMipsIfNeeded) 
                            {
                                if (te.mFilter === filter) return;

                                if (te.mType === me.TEXTYPE.T2D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_3D, null);

                                }
                                else
                                {
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }


                                te.mFilter = filter;
                            };

        me.SetSamplerWrap = function (te, wrap)
                            {
                                if (te.mWrap === wrap) return;

                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, id);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, id);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_3D, null);
                                }

                                te.mWrap = wrap;
                            };

        me.SetSamplerVFlip = function (te, vflip, image)
                            {
                                if (te.mVFlip === vflip) return;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    if( image != null)
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                }
                                else if (te.mType === me.TEXTYPE.CUBEMAP)
                                {
                                    if( image != null)
                                    {
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei( mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
        
                                }

                                te.mVFlip = vflip;
                            };

        me.CreateMipmaps =  function (te)
                            {
                                if( te.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);
                                    mGL.generateMipmap(mGL.TEXTURE_2D);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);
                                }
                                else if( te.mType===me.TEXTYPE.CUBEMAP )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);
                                    mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }
                            };

        me.UpdateTexture =  function( tex, x0, y0, xres, yres, buffer )
                            {
                                var glFoTy = iFormatPI2GL( tex.mFormat );
                                if( tex.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture( mGL.TEXTURE0);
                                    mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                    mGL.texSubImage2D( mGL.TEXTURE_2D, 0, x0, y0, xres, yres, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                }
                            };

        me.UpdateTextureFromImage = function( tex, image )
                                {
                                    var glFoTy = iFormatPI2GL( tex.mFormat );
                                    if( tex.mType===me.TEXTYPE.T2D )
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                        mGL.texImage2D(  mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image );
                                        mGL.bindTexture( mGL.TEXTURE_2D, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                };

        me.DestroyTexture = function( te )
                            {
                                 mGL.deleteTexture( te.mObjectID );
                            };

        me.AttachTextures = function (num, t0, t1, t2, t3) 
                            {
                                if (num > 0 && t0 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                         if (t0.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t0.mObjectID);
                                }

                                if (num > 1 && t1 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE1);
                                         if (t1.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t1.mObjectID);
                                }

                                if (num > 2 && t2 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE2);
                                         if (t2.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t2.mObjectID);
                                }

                                if (num > 3 && t3 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE3);
                                         if (t3.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t3.mObjectID);
                                }
                            };

        me.DettachTextures = function()
                             {
                                mGL.activeTexture(mGL.TEXTURE0);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE1);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE2);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE3);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                             };

        me.CreateRenderTarget = function ( color0, color1, color2, color3, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);

                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_2D, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.DestroyRenderTarget = function ( tex )
                                 {
                                     mGL.deleteFramebuffer(tex.mObjectID);
                                 };

        me.SetRenderTarget = function (tex)
                             {
                                if( tex===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, tex.mObjectID);

                                //mGL.drawBuffers([mGL.COLOR_ATTACHMENT0, mGL.COLOR_ATTACHMENT1]);
                             };

        me.CreateRenderTargetNew = function ( wantColor0, wantZbuffer, xres, yres, samples )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if( wantZbuffer===true )
                                    {
                                        var zb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);

                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.DEPTH_COMPONENT16, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                    }

                                    if( wantColor0 )
                                    {
                                        var cb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, cb);
                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.RGBA8, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.RGBA8, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.RENDERBUFFER, cb);
                                    }

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                    {
                                        return null;
                                    }
                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mXres: xres, mYres:yres, mTex0: color0 };
                                };

        me.CreateRenderTargetCubeMap = function ( color0, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);
                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.SetRenderTargetCubeMap = function (fbo, face)
                             {
                                if( fbo===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                {
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, fbo.mObjectID);
                                    mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X+face, fbo.mTex0.mObjectID, 0);
                                }
                             };


        me.BlitRenderTarget = function( dst, src )
                                {
                                    mGL.bindFramebuffer(mGL.READ_FRAMEBUFFER, src.mObjectID);
                                    mGL.bindFramebuffer(mGL.DRAW_FRAMEBUFFER, dst.mObjectID);
                                    mGL.clearBufferfv(mGL.COLOR, 0, [0.0, 0.0, 0.0, 1.0]);
                                    mGL.blitFramebuffer( 0, 0, src.mXres, src.mYres,
                                                         0, 0, src.mXres, src.mYres,
                                                         mGL.COLOR_BUFFER_BIT, mGL.LINEAR
                                    );
                                };

        me.SetViewport = function( vp )
                         {
                              mGL.viewport( vp[0], vp[1], vp[2], vp[3] );
                         };

        me.SetWriteMask = function( c0, c1, c2, c3, z )
                          {
                              mGL.depthMask(z);
                              mGL.colorMask(c0,c0,c0,c0);
                          };

        me.SetState = function( stateName, stateValue )
                      {
                            if (stateName === me.RENDSTGATE.WIREFRAME)
                            {
                                if( stateValue ) mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.LINE );
                                else             mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.FILL );
                            }
                            else if (stateName === me.RENDSTGATE.FRONT_FACE)
                            {
                                if( stateValue ) mGL.cullFace( mGL.BACK );
                                else             mGL.cullFace( mGL.FRONT );
                            }
                            else if (stateName === me.RENDSTGATE.CULL_FACE)
                            {
                                if( stateValue ) mGL.enable( mGL.CULL_FACE );
                                else             mGL.disable( mGL.CULL_FACE );
                            }
                            else if (stateName === me.RENDSTGATE.DEPTH_TEST)
                            {
                                if( stateValue ) mGL.enable( mGL.DEPTH_TEST );
                                else             mGL.disable( mGL.DEPTH_TEST );
                            }
                            else if (stateName === me.RENDSTGATE.ALPHA_TO_COVERAGE)
                            {
                                if( stateValue ) { mGL.enable(  mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                                else             { mGL.disable( mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                            }
                      };

        me.SetMultisample = function( v)
                    {
                        if( v===true )
                        {
                            mGL.enable(mGL.SAMPLE_COVERAGE);
                            mGL.sampleCoverage(1.0, false);
                        }
                        else
                        {
                            mGL.disable(mGL.SAMPLE_COVERAGE);
                        }
                    };

        me.GetTranslatedShaderSource = function (shader) 
                          {
                            if( mGL===null ) return null;
                            if( mDebugShader===null ) return null;
                            let vfs = mGL.getAttachedShaders(shader.mProgram);
                            let str = mDebugShader.getTranslatedShaderSource(vfs[1]);
                            let parts = str.split("GLSL END"); str = (parts.length<2) ? str : parts[1];
                            return str;
                          };

        me.CreateShader = function (vsSource, fsSource, preventCache, forceSynch, onResolve) 
                          {
                            if( mGL===null ) return;

                            var vs = mGL.createShader( mGL.VERTEX_SHADER   );
                            var fs = mGL.createShader( mGL.FRAGMENT_SHADER );

                            vsSource = mShaderHeader[0] + vsSource;
                            fsSource = mShaderHeader[1] + fsSource;

                            if( preventCache )
                            {
                                let vran = Math.random().toString(36).substring(7);
                                let fran = Math.random().toString(36).substring(7);
                                vsSource += "\n#define K" + vran + "\n";
                                fsSource += "\n#define K" + fran + "\n";
                            }

                            var timeStart = getRealTime();

                            mGL.shaderSource(vs, vsSource);
                            mGL.shaderSource(fs, fsSource);
                            mGL.compileShader(vs);
                            mGL.compileShader(fs);

                            var pr = mGL.createProgram();
                            mGL.attachShader(pr, vs);
                            mGL.attachShader(pr, fs);
                            mGL.linkProgram(pr);

                            //-------------
                            let checkErrors = function()
                            {
                                if (!mGL.getProgramParameter(pr, mGL.LINK_STATUS))
                                {
                                    // vs error
                                    if (!mGL.getShaderParameter(vs, mGL.COMPILE_STATUS))
                                    {
                                        let vsLog = mGL.getShaderInfoLog(vs);
                                        onResolve(false, { mErrorType: 0, mErrorStr: vsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // fs error
                                    else if (!mGL.getShaderParameter(fs, mGL.COMPILE_STATUS))
                                    {
                                        let fsLog = mGL.getShaderInfoLog(fs);
                                        onResolve(false, { mErrorType: 1, mErrorStr: fsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // link error
                                    else
                                    {
                                        let infoLog = mGL.getProgramInfoLog(pr);
                                        onResolve(false, { mErrorType: 2, mErrorStr: infoLog });
                                        mGL.deleteProgram(pr);
                                    }
                                }
                                // no errors
                                else
                                {
                                    let compilationTime = getRealTime() - timeStart;
                                    onResolve(true, { mProgram: pr, mTime: compilationTime });
                                }
                            };

                            // check compilation
                            if (mAsynchCompile === null || forceSynch===true )
                            {
                                checkErrors();
                            }
                            else
                            {
                                let loopCheckCompletion = function ()
                                {
                                    if( mGL.getProgramParameter(pr, mAsynchCompile.COMPLETION_STATUS_KHR) === true )
                                        checkErrors();
                                    else
                                        setTimeout(loopCheckCompletion, 10);
                                };
                                setTimeout(loopCheckCompletion, 10);
                            }
                        };

        me.AttachShader = function( shader )
                          {
                                if( shader===null )
                                {
                                    mBindedShader = null;
                                    mGL.useProgram( null );
                                }
                                else
                                {
                                    mBindedShader = shader;
                                    mGL.useProgram(shader.mProgram);
                                }
                          };

        me.DetachShader = function ()
                        {
                            mGL.useProgram(null);
                        };

        me.DestroyShader = function( tex )
                        {
                            mGL.deleteProgram(tex.mProgram);
                        };

        me.GetAttribLocation = function (shader, name)
                        {
                            return mGL.getAttribLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantLocation = function (shader, name)
                        {
                            return mGL.getUniformLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantMat4F = function( uname, params, istranspose )
                        {
                            var program = mBindedShader;

                            let pos = mGL.getUniformLocation( program.mProgram, uname );
                            if( pos===null )
                                return false;

                            if( istranspose===false )
                            {
                                var tmp = new Float32Array( [ params[0], params[4], params[ 8], params[12],
                                                              params[1], params[5], params[ 9], params[13],
                                                              params[2], params[6], params[10], params[14],
                                                              params[3], params[7], params[11], params[15] ] );
	                            mGL.uniformMatrix4fv(pos,false,tmp);
                            }
                            else
                                mGL.uniformMatrix4fv(pos,false,new Float32Array(params) );
                            return true;
                        };

        me.SetShaderConstant1F_Pos = function(pos, x)
                        {
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1FV_Pos = function(pos, x)
                        {
                            mGL.uniform1fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant1F = function( uname, x )
                        {
                            var pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1I = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1i(pos, x);
                            return true;
                        };
        me.SetShaderConstant1I_Pos = function(pos, x)
                        {
                            mGL.uniform1i(pos, x);
                            return true;
                        };


        me.SetShaderConstant2F = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform2fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant3F = function(uname, x, y, z)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform3f(pos, x, y, z);
                            return true;
                        };

        me.SetShaderConstant1FV = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1fv(pos, new Float32Array(x));
                            return true;
                        };

        me.SetShaderConstant3FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform3fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderConstant4FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform4fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderTextureUnit = function( uname, unit )
                        {
                            var program = mBindedShader;
                            let pos = mGL.getUniformLocation(program.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform1i(pos, unit);
                            return true;
                        };

        me.CreateVertexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, id);
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.CreateIndexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, id );
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.DestroyArray = function( tex )
                        {
                            mGL.destroyBuffer(tex.mObject);
                        };

        me.AttachVertexArray = function( tex, attribs, pos )
                        {
                            let shader = mBindedShader;

                            mGL.bindBuffer( mGL.ARRAY_BUFFER, tex.mObject);

                            var num = attribs.mChannels.length;
                            var stride = attribs.mStride;

                            var offset = 0;
                            for (var i = 0; i < num; i++)
                            {
                                var id = pos[i];
                                mGL.enableVertexAttribArray(id);
                                var dtype = mGL.FLOAT;
                                var dsize = 4;
                                     if( attribs.mChannels[i].mType === me.TYPE.UINT8   ) { dtype = mGL.UNSIGNED_BYTE;  dsize = 1; }
                                else if( attribs.mChannels[i].mType === me.TYPE.UINT16  ) { dtype = mGL.UNSIGNED_SHORT; dsize = 2; }
                                else if( attribs.mChannels[i].mType === me.TYPE.FLOAT32 ) { dtype = mGL.FLOAT;          dsize = 4; }
                                mGL.vertexAttribPointer(id, attribs.mChannels[i].mNumComponents, dtype, attribs.mChannels[i].mNormalize, stride, offset);
                                offset += attribs.mChannels[i].mNumComponents * dsize;
                            }
                        };

        me.AttachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, tex.mObject);
                        };

        me.DetachVertexArray = function (tex, attribs)
                        {
                            let num = attribs.mChannels.length;
                            for (let i = 0; i < num; i++)
                                mGL.disableVertexAttribArray(i);
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, null);
                        };

        me.DetachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, null);
                        };

        me.DrawPrimitive = function( typeOfPrimitive, num, useIndexArray, numInstances )
                        {
                            let glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.POINTS ) glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.LINES ) glType = mGL.LINES;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_LOOP ) glType = mGL.LINE_LOOP;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_STRIP ) glType = mGL.LINE_STRIP;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLES ) glType = mGL.TRIANGLES;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLE_STRIP ) glType = mGL.TRIANGLE_STRIP;

                            if( numInstances<=1 )
                            {
  	                            if( useIndexArray ) mGL.drawElements( glType, num, mGL.UNSIGNED_SHORT, 0 );
	                            else                mGL.drawArrays( glType, 0, num );
                            }
                            else
                            {
                                mGL.drawArraysInstanced(glType, 0, num, numInstances);
                                mGL.drawElementsInstanced( glType, num, mGL.UNSIGNED_SHORT, 0, numInstances);
                            }
                        };


        me.DrawFullScreenTriangle_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 3 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };


        me.DrawUnitQuad_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 6 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };

        me.DrawUnitCube_XYZ_NOR = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                            mGL.vertexAttribPointer( vpos[0], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.vertexAttribPointer( vpos[1], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos[0] );
                            mGL.enableVertexAttribArray( vpos[1] );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos[0] );
                            mGL.disableVertexAttribArray( vpos[1] );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.DrawUnitCube_XYZ = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                            mGL.vertexAttribPointer( vpos, 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.SetBlend = function( enabled )
                    {
                        if( enabled )
                        {
                            mGL.enable( mGL.BLEND );
                            mGL.blendEquationSeparate( mGL.FUNC_ADD, mGL.FUNC_ADD );
                            mGL.blendFuncSeparate( mGL.SRC_ALPHA, mGL.ONE_MINUS_SRC_ALPHA, mGL.ONE, mGL.ONE_MINUS_SRC_ALPHA );
                        }
                        else
                        {
                            mGL.disable( mGL.BLEND );
                        }
                    };

        me.GetPixelData = function( data, offset, xres, yres )
                        {
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.UNSIGNED_BYTE, data, offset);
                        };

        me.GetPixelDataRenderTarget = function( obj, data, xres, yres )
                        {
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, obj.mObjectID);
                            mGL.readBuffer(mGL.COLOR_ATTACHMENT0);
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.FLOAT, data, 0);
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                        };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piShading
//
//==============================================================================

function smoothstep(a, b, x)
{
    x = (x - a) / (b - a);
    if (x < 0) x = 0; else if (x > 1) x = 1;
    return x * x * (3.0 - 2.0 * x);
}

function clamp01(x)
{
    if( x < 0.0 ) x = 0.0;
    if( x > 1.0 ) x = 1.0;
    return x;
}

function clamp(x, a, b)
{
    if( x < a ) x = a;
    if( x > b ) x = b;
    return x;
}

function screen(a, b)
{
    return 1.0 - (1.0 - a) * (1.0 - b);
}

function parabola(x)
{
    return 4.0 * x * (1.0 - x);
}

function min(a, b)
{
    return (a < b) ? a : b;
}

function max(a, b)
{
    return (a > b) ? a : b;
}

function noise( x )
{
    function grad(i, j, x, y)
    {
        var h = 7 * i + 131 * j;
        h = (h << 13) ^ h;
        h = (h * (h * h * 15731 + 789221) + 1376312589);

        var rx = (h & 0x20000000) ? x : -x;
        var ry = (h & 0x10000000) ? y : -y;

        return rx + ry;
    }

    var i = [ Math.floor(x[0]), Math.floor(x[1]) ];
    var f = [ x[0] - i[0], x[1] - i[1] ];
    var w = [ f[0]*f[0]*(3.0-2.0*f[0]), f[1]*f[1]*(3.0-2.0*f[1]) ];

    var a = grad( i[0]+0, i[1]+0, f[0]+0.0, f[1]+0.0 );
    var b = grad( i[0]+1, i[1]+0, f[0]-1.0, f[1]+0.0 );
    var c = grad( i[0]+0, i[1]+1, f[0]+0.0, f[1]-1.0 );
    var d = grad( i[0]+1, i[1]+1, f[0]-1.0, f[1]-1.0 );

    return a + (b-a)*w[0] + (c-a)*w[1] + (a-b-c+d)*w[0]*w[1];
}//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piVecTypes
//
//==============================================================================


function vec3( a, b, c )
{
    return [ a, b, c ];
}

function add( a, b )
{
    return [ a[0]+b[0], a[1]+b[1], a[2]+b[2] ];
}

function sub( a, b )
{
    return [ a[0]-b[0], a[1]-b[1], a[2]-b[2] ];
}

function mul( a, s ) 
{
    return [ a[0]*s, a[1]*s, a[2]*s ];
}

function cross( a, b )
{
    return [ a[1]*b[2] - a[2]*b[1],
             a[2]*b[0] - a[0]*b[2],
             a[0]*b[1] - a[1]*b[0] ];
}

function dot( a, b ) 
{
    return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
}

function normalize( v ) 
{
    var is = 1.0 / Math.sqrt( v[0]*v[0] + v[1]*v[1] + v[2]*v[2] );
    return [ v[0]*is, v[1]*is, v[2]*is ];
}

function createCirclePoint( cen, uuu, vvv, rad, s, t )
{
    return [ cen[0] + rad*(uuu[0]*s + vvv[0]*t),
             cen[1] + rad*(uuu[1]*s + vvv[1]*t),
             cen[2] + rad*(uuu[2]*s + vvv[2]*t) ];
}

function createTangent( a, b, c )
{
    var cb = normalize( [ c[0]-b[0], c[1]-b[1], c[2]-b[2] ] );
    var ba = normalize( [ b[0]-a[0], b[1]-a[1], b[2]-a[2] ] );
    return normalize( [ ba[0]+cb[0], ba[1]+cb[1], ba[2]+cb[2] ] );

}

//===================================

function vec4( a, b, c, d )
{
    return [ a, b, c, d ];
}

function getXYZ( v )
{
    return [ v[0], v[1], v[2] ];
}

//===================================

function setIdentity()
{
    return [ 1.0, 0.0, 0.0, 0.0,
             0.0, 1.0, 0.0, 0.0,
             0.0, 0.0, 1.0, 0.0,
             0.0, 0.0, 0.0, 1.0 ];
}

function setRotationX( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ 1.0,   0.0,   0.0, 0.0,
             0.0,  cost, -sint, 0.0, 
             0.0,  sint,  cost, 0.0,
             0.0,   0.0,   0.0, 1.0 ];
}

function setRotationY( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ cost, 0.0, -sint, 0.0,
              0.0, 1.0,   0.0, 0.0, 
             sint, 0.0,  cost, 0.0,
              0.0, 0.0,   0.0, 1.0 ];
}

function extractRotationEuler( m)
{
    var res = [];
    if (m[0] == 1.0)
    {
        res[0] = Math.atan2(m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;

    }
    else if (m[0] == -1.0)
    {
        res[0] = Math.atan2( m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;
    }
    else
    {
        res[0] = Math.atan2( -m[9], m[10]);
        res[1] = Math.atan2( m[8], Math.sqrt(m[9]*m[9] + m[10]*m[10]));
        res[2] = Math.atan2( m[4], m[0]);
    }
    return res;
}

function setFromQuaternion( q )
{
    var ww = q[3]*q[3];
    var xx = q[0]*q[0];
    var yy = q[1]*q[1];
    var zz = q[2]*q[2];

    return [ ww+xx-yy-zz,                   2.0*(q[0]*q[1] - q[3]*q[2]), 2.0*(q[0]*q[2] + q[3]*q[1]), 0.0,
               2.0*(q[0]*q[1] + q[3]*q[2]),   ww-xx+yy-zz,                 2.0*(q[1]*q[2] - q[3]*q[0]), 0.0,
               2.0*(q[0]*q[2] - q[3]*q[1]),   2.0*(q[1]*q[2] + q[3]*q[0]), ww-xx-yy+zz,                 0.0,
               0.0,                           0.0,                         0.0,                         1.0 ];
}

function setPerspective( fovy, aspect, znear, zfar )
{
    var tan = Math.tan(fovy * Math.PI/180.0);
    var x = 1.0 / (tan*aspect);
    var y = 1.0 / (tan);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0 * zfar * znear) / (zfar - znear);

    return [ x,    0.0,  0.0,  0.0,
             0.0,  y,    0.0,  0.0,
             0.0,  0.0,  c,     d,
             0.0,  0.0, -1.0,  0.0 ];
}

function setLookAt( eye, tar, up )
{
    var dir = [ -tar[0]+eye[0], -tar[1]+eye[1], -tar[2]+eye[2] ];

	var m00 = dir[2]*up[1] - dir[1]*up[2]; 
    var m01 = dir[0]*up[2] - dir[2]*up[0];
    var m02 = dir[1]*up[0] - dir[0]*up[1];
    var im = 1.0/Math.sqrt( m00*m00 + m01*m01 + m02*m02 );
    m00 *= im;
    m01 *= im;
    m02 *= im;

	var m04 = m02*dir[1] - m01*dir[2]; 
    var m05 = m00*dir[2] - m02*dir[0];
    var m06 = m01*dir[0] - m00*dir[1];
    im = 1.0/Math.sqrt( m04*m04 + m05*m05 + m06*m06 );
    m04 *= im;
    m05 *= im;
    m06 *= im;

	var m08 = dir[0];
	var m09 = dir[1];
	var m10 = dir[2];
    im = 1.0/Math.sqrt( m08*m08 + m09*m09 + m10*m10 );
    m08 *= im;
    m09 *= im;
    m10 *= im;

	var m03 = -(m00*eye[0] + m01*eye[1] + m02*eye[2] );
	var m07 = -(m04*eye[0] + m05*eye[1] + m06*eye[2] );
	var m11 = -(m08*eye[0] + m09*eye[1] + m10*eye[2] );

    return [ m00, m01, m02, m03,
             m04, m05, m06, m07,
             m08, m09, m10, m11,
             0.0, 0.0, 0.0, 1.0 ];
}


function setOrtho( left, right, bottom, top, znear, zfar )
{
   var x = 2.0 / (right - left);
   var y = 2.0 / (top - bottom);
   var a = (right + left) / (right - left);
   var b = (top + bottom) / (top - bottom);
   var c = -2.0 / (zfar - znear);
   var d = -(zfar + znear) / ( zfar - znear);

   return [  x, 0.0, 0.0,   a,
           0.0,   y, 0.0,   b,
           0.0, 0.0,   c,   d,
           0.0, 0.0, 0.0, 1.0 ];
}

function setTranslation( p )
{
    return [ 1.0, 0.0, 0.0, p[0],
             0.0, 1.0, 0.0, p[1],
             0.0, 0.0, 1.0, p[2],
             0.0, 0.0, 0.0, 1.0 ];
}

function setScale( s )
{
    return [ s[0], 0.0,  0.0,  0.0,
             0.0,  s[1], 0.0,  0.0,
             0.0,  0.0,  s[2], 0.0,
             0.0,  0.0,  0.0,  1.0];
}

function setProjection( fov, znear, zfar )
{
    var x = 2.0 / (fov[3]+fov[2]);
    var y = 2.0 / (fov[0]+fov[1]);
    var a = (fov[3]-fov[2]) / (fov[3]+fov[2]);
    var b = (fov[0]-fov[1]) / (fov[0]+fov[1]);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0*zfar*znear) / (zfar - znear);
    return [   x, 0.0,    a, 0.0,
             0.0,   y,    b, 0.0,
             0.0, 0.0,    c,   d,
             0.0, 0.0, -1.0, 0.0 ];
   // inverse is:
   //return mat4x4( 1.0/x, 0.0f,  0.0f,   a/x,
   //               0.0f,  1.0/y, 0.0f,   b/x,
   //               0.0f,  0.0f,  0.0f,   -1.0,
   //               0.0f,  0.0f,  1.0f/d, c/d );
}


function invertFast( m )
{
    var inv = [
   
             m[5]  * m[10] * m[15] - 
             m[5]  * m[11] * m[14] - 
             m[9]  * m[6]  * m[15] + 
             m[9]  * m[7]  * m[14] +
             m[13] * m[6]  * m[11] - 
             m[13] * m[7]  * m[10],

             -m[1]  * m[10] * m[15] + 
              m[1]  * m[11] * m[14] + 
              m[9]  * m[2] * m[15] - 
              m[9]  * m[3] * m[14] - 
              m[13] * m[2] * m[11] + 
              m[13] * m[3] * m[10],

             m[1]  * m[6] * m[15] - 
             m[1]  * m[7] * m[14] - 
             m[5]  * m[2] * m[15] + 
             m[5]  * m[3] * m[14] + 
             m[13] * m[2] * m[7] - 
             m[13] * m[3] * m[6],

             -m[1] * m[6] * m[11] + 
              m[1] * m[7] * m[10] + 
              m[5] * m[2] * m[11] - 
              m[5] * m[3] * m[10] - 
              m[9] * m[2] * m[7] + 
              m[9] * m[3] * m[6],

             -m[4]  * m[10] * m[15] + 
              m[4]  * m[11] * m[14] + 
              m[8]  * m[6]  * m[15] - 
              m[8]  * m[7]  * m[14] - 
              m[12] * m[6]  * m[11] + 
              m[12] * m[7]  * m[10],

             m[0]  * m[10] * m[15] - 
             m[0]  * m[11] * m[14] - 
             m[8]  * m[2] * m[15] + 
             m[8]  * m[3] * m[14] + 
             m[12] * m[2] * m[11] - 
             m[12] * m[3] * m[10],

             -m[0]  * m[6] * m[15] + 
              m[0]  * m[7] * m[14] + 
              m[4]  * m[2] * m[15] - 
              m[4]  * m[3] * m[14] - 
              m[12] * m[2] * m[7] + 
              m[12] * m[3] * m[6],


             m[0] * m[6] * m[11] - 
             m[0] * m[7] * m[10] - 
             m[4] * m[2] * m[11] + 
             m[4] * m[3] * m[10] + 
             m[8] * m[2] * m[7] - 
             m[8] * m[3] * m[6],


             m[4]  * m[9] * m[15] - 
             m[4]  * m[11] * m[13] - 
             m[8]  * m[5] * m[15] + 
             m[8]  * m[7] * m[13] + 
             m[12] * m[5] * m[11] - 
             m[12] * m[7] * m[9],



             -m[0]  * m[9] * m[15] + 
              m[0]  * m[11] * m[13] + 
              m[8]  * m[1] * m[15] - 
              m[8]  * m[3] * m[13] - 
              m[12] * m[1] * m[11] + 
              m[12] * m[3] * m[9],

              m[0]  * m[5] * m[15] - 
              m[0]  * m[7] * m[13] - 
              m[4]  * m[1] * m[15] + 
              m[4]  * m[3] * m[13] + 
              m[12] * m[1] * m[7] - 
              m[12] * m[3] * m[5],

              -m[0] * m[5] * m[11] + 
               m[0] * m[7] * m[9] + 
               m[4] * m[1] * m[11] - 
               m[4] * m[3] * m[9] - 
               m[8] * m[1] * m[7] + 
               m[8] * m[3] * m[5],

              -m[4]  * m[9] * m[14] + 
               m[4]  * m[10] * m[13] +
               m[8]  * m[5] * m[14] - 
               m[8]  * m[6] * m[13] - 
               m[12] * m[5] * m[10] + 
               m[12] * m[6] * m[9],

              m[0]  * m[9] * m[14] - 
              m[0]  * m[10] * m[13] - 
              m[8]  * m[1] * m[14] + 
              m[8]  * m[2] * m[13] + 
              m[12] * m[1] * m[10] - 
              m[12] * m[2] * m[9],

              -m[0]  * m[5] * m[14] + 
               m[0]  * m[6] * m[13] + 
               m[4]  * m[1] * m[14] - 
               m[4]  * m[2] * m[13] - 
               m[12] * m[1] * m[6] + 
               m[12] * m[2] * m[5],

              m[0] * m[5] * m[10] - 
              m[0] * m[6] * m[9] - 
              m[4] * m[1] * m[10] + 
              m[4] * m[2] * m[9] + 
              m[8] * m[1] * m[6] - 
              m[8] * m[2] * m[5] ];

    var det = m[0] * inv[0] + m[1] * inv[4] + m[2] * inv[8] + m[3] * inv[12];

    det = 1.0/det;

    for( var i = 0; i<16; i++ ) inv[i] = inv[i] * det;

    return inv;
}

function matMul( a, b )
{
    var res = [];
    for( var i=0; i<4; i++ )
    {
        var x = a[4*i+0];
        var y = a[4*i+1];
        var z = a[4*i+2];
        var w = a[4*i+3];

        res[4*i+0] = x * b[ 0] + y * b[ 4] + z * b[ 8] + w * b[12];
        res[4*i+1] = x * b[ 1] + y * b[ 5] + z * b[ 9] + w * b[13];
        res[4*i+2] = x * b[ 2] + y * b[ 6] + z * b[10] + w * b[14];
        res[4*i+3] = x * b[ 3] + y * b[ 7] + z * b[11] + w * b[15];
    }

    return res;
}

function matMulpoint( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2] + m[ 3],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2] + m[ 7],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] + m[11] ];
}

function matMulvec( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] ];
}


function bound3( infi )
{
    return [ infi, -infi, infi, -infi, infi, -infi ];
}

function bound3_include( a, p )
{
    return [
        (p[0]<a[0]) ? p[0] : a[0],
        (p[0]>a[1]) ? p[0] : a[1],
        (p[1]<a[2]) ? p[1] : a[2],
        (p[1]>a[3]) ? p[1] : a[3],
        (p[2]<a[4]) ? p[2] : a[4],
        (p[2]>a[5]) ? p[2] : a[5] ];
}

function bound3_center( b )
{
    return [ 0.5*(b[0]+b[1]),
             0.5*(b[2]+b[3]),
             0.5*(b[4]+b[5]) ];
}

function bound3_radius( b )
{
    return [ 0.5*(b[1]-b[0]),
             0.5*(b[3]-b[2]),
             0.5*(b[5]-b[4]) ];
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebVR
//
//==============================================================================

function WebVR( isVREnabledCallback, canvasElement )
{
    isVREnabledCallback(false);
    /*


    this.mSupportVR = false;
    this.mHMD = null;

    var me = this;
    var listVRDisplays = function (vrdevs) {
        for (var i = 0; i < vrdevs.length; i++)
        {
            if (vrdevs[i] instanceof VRDisplay)
            {
                me.mHMD = vrdevs[i];
                console.log("WebVR is available.");
                console.log(me.mHMD);
                break;
            }
        }

        isVREnabledCallback(true);
        me.mSupportVR = true;
    }

    if (navigator.getVRDisplays)
    {
        navigator.getVRDisplays().then(listVRDisplays);
    }

    isVREnabledCallback(false);
    this.mCanvas = canvasElement;
    */
}

WebVR.prototype.IsSupported = function()
{
    return false;
    //return this.mSupportVR;
}

WebVR.prototype.GetData = function( id )
{
    return {};
    /*
    var frameData = new VRFrameData();
    var s = this.mHMD.getFrameData(frameData);
    var ss = frameData.pose;
    
    var fovL = this.mHMD.getEyeParameters("left");
    var fovR = this.mHMD.getEyeParameters( "right" );

    // camera info
    var cPos = vec3(0.0, 0.0, 0.0);
    if (ss.position)
        cPos = vec3(-ss.position[0], -ss.position[1], -ss.position[2]);
    var rot = vec4(0.0, 0.0, 0.0, 0.0);
    if (ss.orientation)
        rot = vec4(ss.orientation[0], ss.orientation[1], ss.orientation[2], ss.orientation[3]);
    var cRot = setFromQuaternion(rot);
    var cTra = setTranslation(cPos);
    var cMat = matMul(invertFast(cRot), cTra);
    
    // per eye info
    var lTra = setTranslation( vec3(-fovL.offset[0], -fovL.offset[1], -fovL.offset[2]) );
    var lMat = matMul(lTra, cMat);
    var lPrj = [ Math.tan( fovL.fieldOfView.upDegrees * Math.PI/180.0),
                 Math.tan(fovL.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.rightDegrees * Math.PI / 180.0)];

    var rTra = setTranslation(vec3(-fovR.offset[0], -fovR.offset[1], -fovR.offset[2]));
    var rMat = matMul(rTra, cMat);
    var rPrj = [Math.tan(fovR.fieldOfView.upDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.rightDegrees * Math.PI / 180.0)];

    return {
        mCamera   : { mCamera: cMat },
        mLeftEye  : { mVP:[0,0,fovL.renderWidth,fovL.renderHeight], mProjection:lPrj, mCamera:lMat },
        mRightEye : { mVP:[fovR.renderWidth/2,0,fovR.renderWidth,fovR.renderHeight], mProjection:rPrj, mCamera:rMat }
           };
    */
}

WebVR.prototype.Enable = function( id )
{
    /*
    this.mHMD.requestPresent([{ source: this.mCanvas }]).then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : requestPresent failed.");
        }
    );
    */
}

WebVR.prototype.Disable = function( id )
{
    /*
    if (!this.mHMD.isPresenting)
    {
        return;
    }

    this.mHMD.exitPresent().then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : exitPresent failed.");
        }
    );
    */
}

WebVR.prototype.RequestAnimationFrame = function (id)
{
    //this.mHMD.requestAnimationFrame(id);
}

WebVR.prototype.IsPresenting = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        return true;
    }
    */
    return false;
}

WebVR.prototype.Finish = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        this.mHMD.submitFrame();
    }
    */
}

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebUtils
//
//==============================================================================


// RequestAnimationFrame
window.requestAnimFrame = ( function () { return window.requestAnimationFrame    || window.webkitRequestAnimationFrame ||
                                                 window.mozRequestAnimationFrame || window.oRequestAnimationFrame ||
                                                 window.msRequestAnimationFrame  || function( cb ) { window.setTimeout(cb,1000/60); };
                                        } )();

// performance.now
window.getRealTime = ( function() { if ("performance" in window ) return function() { return window.performance.now(); }
                                                                  return function() { return (new Date()).getTime(); }
                                  } )();

window.URL = window.URL || window.webkitURL;

navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;

function htmlEntities(str) 
{
    return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g,'&apos;');
}

function piDisableTouch()
{
    document.body.addEventListener('touchstart', function(e){ e.preventDefault(); });
}

var piGetTime = function ( timestamp )
{
    if (timestamp == 0)
        return "";
    return new Date(timestamp * 1000).toISOString().substr(0, 10);
}

function piGetCoords( obj )
{
    var x = 0;
    var y = 0; 
    do
    {
         x += obj.offsetLeft;
         y += obj.offsetTop;
    }while( obj = obj.offsetParent );

    return { mX:x, mY:y };
}

function piGetMouseCoords( ev, canvasElement )
{
    var pos = piGetCoords(canvasElement );
    var mcx =                        (ev.pageX - pos.mX) * canvasElement.width / canvasElement.offsetWidth;
    var mcy = canvasElement.height - (ev.pageY - pos.mY) * canvasElement.height / canvasElement.offsetHeight;

    return { mX: mcx, mY: mcy };

}

function piGetSourceElement( e )
{
    var ele = null;
    if( e.target )     ele = e.target;
    if( e.srcElement ) ele = e.srcElement;
    return ele;
}

function piRequestFullScreen( ele )
{
    if( ele==null ) ele =   document.documentElement;
         if( ele.requestFullscreen       ) ele.requestFullscreen();
    else if( ele.msRequestFullscreen     ) ele.msRequestFullscreen();
    else if( ele.mozRequestFullScreen    ) ele.mozRequestFullScreen();
    else if( ele.webkitRequestFullscreen ) ele.webkitRequestFullscreen( Element.ALLOW_KEYBOARD_INPUT );
}

function piIsFullScreen()
{
    return document.fullscreen || document.mozFullScreen || document.webkitIsFullScreen || document.msFullscreenElement || false;
}

function piExitFullScreen()
{
       if( document.exitFullscreen       ) document.exitFullscreen();
  else if( document.msExitFullscreen     ) document.msExitFullscreen();
  else if( document.mozCancelFullScreen  ) document.mozCancelFullScreen();
  else if( document.webkitExitFullscreen ) document.webkitExitFullscreen();
}

function piIsMobile()
{
    return (navigator.userAgent.match(/Android/i) ||
            navigator.userAgent.match(/webOS/i) ||
            navigator.userAgent.match(/iPhone/i) ||
            navigator.userAgent.match(/iPad/i) ||
            navigator.userAgent.match(/iPod/i) ||
            navigator.userAgent.match(/BlackBerry/i) ||
            navigator.userAgent.match(/Windows Phone/i)) ? true : false;
}

function piCreateGlContext( cv, useAlpha, useDepth, usePreserveBuffer, useSupersampling )
{
    var opts = { alpha: useAlpha, 
                 depth: useDepth, 
                 stencil: false, 
                 premultipliedAlpha: false, 
                 antialias: useSupersampling, 
                 preserveDrawingBuffer: usePreserveBuffer, 
                 powerPreference: "high-performance" }; // "low_power", "high_performance", "default"

    var gl = null;
    if( gl === null) gl = cv.getContext( "webgl2", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl2", opts );
    if( gl === null) gl = cv.getContext( "webgl", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl", opts );

    return gl;
}

function piCreateAudioContext()
{
    var res = null;
    try
    {
        if( window.AudioContext ) res = new AudioContext();
        if( res==null && window.webkitAudioContext ) res = new webkitAudioContext();
    }
    catch( e )
    {
        res = null;
    }
    return res;
}

function piHexColorToRGB(str) // "#ff3041"
{
    var rgb = parseInt(str.slice(1), 16);
    var r = (rgb >> 16) & 255;
    var g = (rgb >> 8) & 255;
    var b = (rgb >> 0) & 255;
    return [r, g, b];
}

function piCreateFPSCounter()
{
    var mFrame;
    var mTo;
    var mFPS;

    var iReset = function( time )
    {
        mFrame = 0;
        mTo = time;
        mFPS = 60.0;
    }

    var iCount = function( time )
    {
        mFrame++;

        if( (time-mTo)>500.0 )
        {
            mFPS = 1000.0*mFrame/(time-mTo);
            mFrame = 0;
            mTo = time;
            return true;
        }
        return false;
    }

    var iGetFPS = function()
    {
        return mFPS;
    }
    
    return { Reset : iReset, Count : iCount, GetFPS : iGetFPS };
}

function piCanMediaRecorded(canvas)
{
    if (typeof window.MediaRecorder !== 'function' || typeof canvas.captureStream !== 'function') {
        return false;
    }
    return true;
}

function piCreateMediaRecorder(isRecordingCallback, canvas) 
{
    if (piCanMediaRecorded(canvas) == false)
    {
        return null;
    }
    
    var options = { audioBitsPerSecond : 0, videoBitsPerSecond : 8000000 }; 
	     if (MediaRecorder.isTypeSupported('video/webm;codecs=h264')) options.mimeType = 'video/webm;codecs=h264';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9' )) options.mimeType = 'video/webm;codecs=vp9';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8' )) options.mimeType = 'video/webm;codecs=vp8';
    else                                                              options.mimeType = 'video/webm;';

    var mediaRecorder = new MediaRecorder(canvas.captureStream(), options);
    var chunks = [];
    
    mediaRecorder.ondataavailable = function(e) 
    {
        if (e.data.size > 0) 
        {
            chunks.push(e.data);
        }
    };
 
    mediaRecorder.onstart = function(){ 
        isRecordingCallback( true );
    };
    
    mediaRecorder.onstop = function()
    {
         isRecordingCallback( false );
         let blob     = new Blob(chunks, {type: "video/webm"});
         chunks       = [];
         let videoURL = window.URL.createObjectURL(blob);
         let url      = window.URL.createObjectURL(blob);
         let a        = document.createElement("a");
         document.body.appendChild(a);
         a.style      = "display: none";
         a.href       = url;
         a.download   = "capture.webm";
         a.click();
         window.URL.revokeObjectURL(url);
     };
    
    return mediaRecorder;
}

function piExportToEXR(width, height, numComponents, type, bytes)
{
    var bytesPerComponent = 0;
    if      (type=="Uint")   bytesPerComponent = 4; 
    else if (type=="Half")   bytesPerComponent = 2;
    else if (type=="Float")  bytesPerComponent = 4;

    var tHeader = 258 + (18 * numComponents + 1);
    var tTable = 8 * height;
    var tScanlines = height * (4 + 4 + (numComponents * bytesPerComponent * width));
    var tTotal = tHeader + tTable + tScanlines;

    //console.log("    header size = " + tHeader);
    //console.log("    table size = " + tTable);
    //console.log("    scanlines size = " + tScanlines);
    //console.log("    total = " + tTotal);

    var buffer = new ArrayBuffer(tTotal); 
    var data = new DataView(buffer);

    // Header
    {
        // Header : 4 bytes -> 0x76, 0x2f, 0x31, 0x01
        var c = 0;
        data.setUint8 (c++, 0x76);
        data.setUint8 (c++, 0x2f);
        data.setUint8 (c++, 0x31);
        data.setUint8 (c++, 0x01);

        // Version : 4 bytes -> 2, 0, 0, 0
        data.setUint8 (c++, 0x02);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        
        // Write channel info
        // Write attribute name : "channels"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x73);
            data.setUint8 (c++, 0x0);

            // Write attribute type : "chlist"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : 18 x 3 + 1 = 55
            var attribSize = 18 * numComponents + 1;
            data.setUint8 (c++, attribSize); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            var i;
            for (i = 0; i < numComponents; i++)
            {
                // Attribute : "B" (42) "G" (47) "R" (52)
                if (i==0)       data.setUint8 (c++, 0x42);
                else if (i==1)  data.setUint8 (c++, 0x47);
                else if (i==2)  data.setUint8 (c++, 0x52);
                data.setUint8 (c++, 0x00);
                
                // Value : Float (2), Half (1), Uint (0)
                if      (type=="Uint")   data.setUint8 (c++, 0x00); 
                else if (type=="Half")   data.setUint8 (c++, 0x01);
                else if (type=="Float")  data.setUint8 (c++, 0x02);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);

                // Plinear
                data.setUint8 (c++, 0x01);

                // Reserved
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 

                // X sampling
                data.setUint8 (c++, 0x01); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                
                // Y sampling
                data.setUint8 (c++, 0x01);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
            }
            // End attribute
            data.setUint8 (c++, 0x00);
    
        // Write attribute name : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute type : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : "1"
            data.setUint8 (c++, 0x01); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // Write attribute value : "0" (None)
            data.setUint8 (c++, 0x00);

        // datawindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00); 

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00);

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 

            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // displayWindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x79); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00);

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00); 

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // size
            data.setUint8 (c++, 0x01);
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);
            
            // value 
            data.setUint8 (c++, 0x00);

        // PixelAspectRatio
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x41); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x52); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x00); 

            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);
        
            // size 4
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 1.0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);
        
        // screenWindowCenter
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63);
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x43); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e);
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00);

            // v2f
            data.setUint8 (c++, 0x76); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x00);

            // size 8
            data.setUint8 (c++, 0x08); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

        // screenWindowWidth
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x00); 
            
            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00); 

            // size
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);

            // value
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);

        // End of header
        data.setUint8 (c++, 0x00);
    }
    //console.log("header size = " + c);

    // Scanline table
    var initc = c + height * 8;
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        var jump = initc + scanline * (8 + width * bytesPerComponent * numComponents); 
        data.setUint32 (c, jump, true);
        c += 4; 

        data.setUint32 (c, 0x00, true);
        c += 4;
    }
    //console.log("header + scanlines table size = " + c);

    // Scanlines
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        // Scanline
        data.setUint32(c, scanline, true);
        c += 4;

        // size 24
        var size = width * numComponents * bytesPerComponent; 
        data.setUint32(c, size, true);
        c += 4;

        var numComponentsSource = 4; // number of components in the SOURCE image
        for (var component = 0; component < numComponents ; component ++) 
        {
            for (var pixel = 0 ; pixel < width ; pixel ++) 
            {
                // flip vertical, so we read OpenGL buffers without JS image flipping
                var v = bytes[(height-1-scanline) * width *numComponentsSource + pixel * numComponentsSource + (2-component)];
                if      (type=="Float") data.setFloat32(c, v, true);
                else if (type=="Half")  data.setUint16(c, v, true);

                c += bytesPerComponent;
            }
        }
    }
    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}


function piExportToWAV(numSamples, rate, bits, numChannels, words)
{
    let numBytes = numSamples * numChannels * bits/8;

    let buffer = new ArrayBuffer(44 + numBytes); 
    let data = new DataView(buffer);

    {
        data.setUint32( 0, 0x46464952, true );  // RIFF
        data.setUint32( 4, numBytes + 36, true);
        {
            data.setUint32( 8, 0x45564157, true );  // WAV_WAVE
            data.setUint32( 12, 0x20746D66, true );  // WAV_FMT
            {
                data.setUint32( 16, 16, true);
                data.setUint16( 20, 1, true ); // WAV_FORMAT_PCM
                data.setUint16( 22, numChannels, true);
                data.setUint32( 24, rate, true);
                data.setUint32( 28, rate*numChannels*bits / 8, true);
                data.setUint16( 32, numChannels*bits / 8, true);
                data.setUint16( 34, bits, true);
            }

            data.setUint32( 36, 0x61746164, true);  // WAV_DATA
            {
                data.setUint32( 40, numBytes, true);
                let numWords = numSamples * numChannels;
                for(let i=0; i<numWords; i++ )
                {
                    data.setInt16( 44 + i*2, words[i], true );
                }
            }
        }
    }


    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}

function piTriggerDownload(name, blob)
{
    let url = URL.createObjectURL(blob);
    let aElement = document.createElement("a");
    aElement.href     = url;
    aElement.target   = "_self";
    aElement.download = name;
    document.body.appendChild(aElement);
    aElement.click();
    document.body.removeChild(aElement);
}</script>
    <script>"use strict"

function bufferID_to_assetID( id )
{
    if( id===0 ) return '4dXGR8';
    if( id===1 ) return 'XsXGR8';
    if( id===2 ) return '4sXGR8';
    if( id===3 ) return 'XdfGR8';
    return 'none';
}
function assetID_to_bufferID( id )
{
    if( id==='4dXGR8' ) return 0;
    if( id==='XsXGR8' ) return 1;
    if( id==='4sXGR8' ) return 2;
    if( id==='XdfGR8' ) return 3;
    return -1;
}

function assetID_to_cubemapBuferID( id )
{
    if( id==='4dX3Rr' ) return 0;
    return -1;
}
function cubamepBufferID_to_assetID( id )
{
    if( id===0 ) return '4dX3Rr';
    return 'none';
}

function EffectPass( renderer, is20, isLowEnd, hasShaderTextureLOD, callback, obj, forceMuted, forcePaused, outputGainNode, copyProgram, id, effect  )
{
    this.mID = id;
    this.mInputs  = [null, null, null, null ];
    this.mOutputs = [null, null, null, null ];
    this.mSource = null;

    this.mGainNode = outputGainNode;
    this.mSoundShaderCompiled = false;

    this.mEffect = effect;
    this.mRenderer = renderer;
    this.mProgramCopy = copyProgram; 
    this.mCompilationTime = 0;

    this.mType = "none";
    this.mName = "none";
    this.mFrame = 0;

    this.mShaderTextureLOD = hasShaderTextureLOD;
    this.mIs20 = is20;
    this.mIsLowEnd = isLowEnd;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mForceMuted = forceMuted;
    this.mForcePaused = forcePaused;
}

EffectPass.prototype.MakeHeader_Image = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        // old API
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                   header += "uniform sampler2D iChannel" + i + ";\n";

        // new API (see shadertoy.com/view/wtdGW8)
        header += "uniform struct {\n";
             if( inp===null )                  header += "  sampler2D";
        else if( inp.mInfo.mType==="cubemap" ) header += "  samplerCube";
        else if( inp.mInfo.mType==="volume"  ) header += "  sampler3D";
        else                                  header += "  sampler2D";
        header +=        " sampler;\n";
        header += "  vec3  size;\n";
        header += "  float time;\n";
        header += "  int   loaded;\n";
        header += "}iCh" + i + ";\n";
    }
	header += "void mainImage( out vec4 c, in vec2 f );\n";
    header += "void st_assert( bool cond );\n";
    header += "void st_assert( bool cond, int v );\n";

    if( this.mIs20 ) 
    {
        header += "\nout vec4 shadertoy_out_color;\n" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)shadertoy_out_color.x=-1.0;else if(v==1)shadertoy_out_color.y=-1.0;else if(v==2)shadertoy_out_color.z=-1.0;else shadertoy_out_color.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)shadertoy_out_color.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "shadertoy_out_color = vec4(1.0,1.0,1.0,1.0);" + 
            "vec4 color = vec4(1e20);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "if(shadertoy_out_color.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(shadertoy_out_color.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(shadertoy_out_color.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(shadertoy_out_color.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "shadertoy_out_color = vec4(color.xyz,1.0);" +
        "}";
    }
    else
    {
        header += "" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)gl_FragColor.x=-1.0;else if(v==1)gl_FragColor.y=-1.0;else if(v==2)gl_FragColor.z=-1.0;else gl_FragColor.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)gl_FragColor.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "gl_FragColor = vec4(0.0,0.0,0.0,1.0);" + 
            "vec4 color = vec4(1e20);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "color.w = 1.0;" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(gl_FragColor.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "gl_FragColor = vec4(color.xyz,1.0);"+
        "}";
    }
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 ) 
        this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "void main( void )" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );" +
        "color.w = 1.0;"
    if( this.mIs20 ) 
        this.mImagePassFooterVR +=  "outColor = color;}";
    else
        this.mImagePassFooterVR +=  "gl_FragColor = color;}";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Buffer = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                  header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainImage( out vec4 c,  in vec2 f );\n"

    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +
        "mainImage( color, gl_FragCoord.xy );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
    this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        this.mImagePassFooterVR +="outColor = color; }";
    else
        this.mImagePassFooterVR +="gl_FragColor = color; }";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Cubemap = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                   header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainCubemap( out vec4 c, in vec2 f, in vec3 ro, in vec3 rd );\n"

    header += "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainCubemap( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Sound = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform float     iChannelTime[4];\n" +
              "uniform float     iTimeOffset;\n" +
              "uniform int       iSampleOffset;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n";

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp!==null && inp.mInfo.mType==="cubemap" )
            header += "uniform samplerCube iChannel" + i + ";\n";
        else
            header += "uniform sampler2D iChannel" + i + ";\n";
    }
    header += "\n";
    header += "vec2 mainSound( in int samp, float time );\n";

    if( this.mIs20 )
    {
        header += "out vec4 outColor; void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "int   s = iSampleOffset + int(gl_FragCoord.y-0.2)*512 + int(gl_FragCoord.x-0.2);" +
            "vec2 y = mainSound( s, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "outColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    else
    {
        header += "void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "vec2 y = mainSound( 0, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "gl_FragColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    header += "\n";
    this.mHeader = header;
    this.mHeaderLength = 0;
}


EffectPass.prototype.MakeHeader_Common = function ()
{
    let header = "";
    let headerlength = 0;

    header += "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n";
    headerlength += 2;

    if (this.mIs20)
    {
        header += "out vec4 outColor;\n";
        headerlength += 1;
    }
    header += "void main( void )\n";
    headerlength += 1;

    if (this.mIs20)
        header += "{ outColor = vec4(0.0); }";
    else
        header += "{ gl_FragColor = vec4(0.0); }";
    headerlength += 1;
    header += "\n";
    headerlength += 1;

    this.mHeader = header;
    this.mHeaderLength = headerlength;
}

EffectPass.prototype.MakeHeader = function()
{
         if( this.mType==="image" ) this.MakeHeader_Image();
    else if( this.mType==="sound" ) this.MakeHeader_Sound();
    else if( this.mType==="buffer") this.MakeHeader_Buffer();
    else if( this.mType==="common") this.MakeHeader_Common();
    else if( this.mType==="cubemap") this.MakeHeader_Cubemap();
    else console.log("ERROR 4");
}

EffectPass.prototype.Create_Image = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}
EffectPass.prototype.Destroy_Image = function( wa )
{
}

EffectPass.prototype.Create_Buffer = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}

EffectPass.prototype.Destroy_Buffer = function( wa )
{
}

EffectPass.prototype.Create_Cubemap = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
}

EffectPass.prototype.Destroy_Cubemap = function( wa )
{
}

EffectPass.prototype.Create_Common = function( wa )
{
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.MakeHeader();
}
EffectPass.prototype.Destroy_Common = function( wa )
{
}

EffectPass.prototype.Create_Sound = function (wa)
{
    this.MakeHeader();

    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    this.mSampleRate = 44100;
    this.mPlayTime = 60*3;
    this.mPlaySamples = this.mPlayTime*this.mSampleRate;
    this.mBuffer = wa.createBuffer( 2, this.mPlaySamples, this.mSampleRate );

    //-------------------
    this.mTextureDimensions = 512;
    this.mRenderTexture = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D, 
                                                       this.mTextureDimensions, this.mTextureDimensions,
                                                       this.mRenderer.TEXFMT.C4I8,
                                                       this.mRenderer.FILTER.NONE,
                                                       this.mRenderer.TEXWRP.CLAMP, null);
    this.mRenderFBO = this.mRenderer.CreateRenderTarget(this.mRenderTexture, null, null, null, null, false);

    //-----------------------------

    // ArrayBufferView pixels;
    this.mTmpBufferSamples = this.mTextureDimensions*this.mTextureDimensions;
    this.mData = new Uint8Array( this.mTmpBufferSamples*4 );

    this.mPlaying = false;
}

EffectPass.prototype.Destroy_Sound = function( wa )
{
    if( this.mPlayNode!==null ) this.mPlayNode.stop();
    this.mPlayNode = null;
    this.mBuffer = null;
    this.mData = null;

    this.mRenderer.DestroyRenderTarget(this.mRenderFBO);
    this.mRenderer.DestroyTexture(this.mRenderTexture);
}

EffectPass.prototype.Create = function( passType, wa )
{
    this.mType = passType;
    this.mSource = null;

         if( passType==="image" ) this.Create_Image( wa );
    else if( passType==="sound" ) this.Create_Sound( wa );
    else if( passType==="buffer") this.Create_Buffer( wa );
    else if( passType==="common") this.Create_Common( wa );
    else if( passType==="cubemap") this.Create_Cubemap( wa );
    else alert("ERROR 1");
}

EffectPass.prototype.SetName = function (passName)
{
    this.mName = passName;
}

EffectPass.prototype.SetCode = function (src)
{
    this.mSource = src;
}

EffectPass.prototype.Destroy = function( wa )
{
    this.mSource = null;
         if( this.mType==="image" ) this.Destroy_Image( wa );
    else if( this.mType==="sound" ) this.Destroy_Sound( wa );
    else if( this.mType==="buffer") this.Destroy_Buffer( wa );
    else if( this.mType==="common") this.Destroy_Common( wa );
    else if( this.mType==="cubemap") this.Destroy_Cubemap( wa );
    else alert("ERROR 2");
}

EffectPass.prototype.NewShader_Sound = function( shaderCode, commonShaderCodes)
{
    let vsSource = null;

    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for( let i=0; i<commonShaderCodes.length; i++ )
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    this.mSoundShaderCompiled = false;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader_Image = function ( shaderCode, commonShaderCodes )
{
    this.mSupportsVR = false;

    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    return [vsSource, fsSource];


    /*
    let n1 = shaderCode.indexOf("mainVR(");
    let n2 = shaderCode.indexOf("mainVR (");
    let n3 = shaderCode.indexOf("mainVR  (");
    if( n1>0 || n2>0 || n3>0 )
    {
        let vsSourceVR;
        if( this.mIs20 )
            vsSourceVR = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        else
            vsSourceVR = "attribute in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

        let fsSourceVR = this.mHeader;
        for (let i = 0; i < commonShaderCodes.length; i++) {
            fsSourceVR += commonShaderCodes[i];
        }
        fsSourceVR += shaderCode;
        fsSourceVR += this.mImagePassFooterVR;

        let res = this.mRenderer.CreateShader(vsSource, fsSourceVR, preventCache);
        if( res.mResult == false )
        {
            return res.mInfo;
        }
        if( this.mProgramVR != null )
            this.mRenderer.DestroyShader( this.mProgramVR );

        this.mSupportsVR = true;
        this.mProgramVR = res;
    }
    */
}

EffectPass.prototype.NewShader_Cubemap = function( shaderCode, commonShaderCodes )
{
    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }

    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;

    fsSource += shaderCode;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader_Common = function (shaderCode )
{
    let vsSource = null;
    if (this.mIs20)
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader + shaderCode;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader = function ( commonSourceCodes, preventCache, onResolve)
{
    if( this.mRenderer===null ) return;

    let vs_fs = null;

         if( this.mType==="sound"  ) vs_fs = this.NewShader_Sound(   this.mSource, commonSourceCodes );
    else if( this.mType==="image"  ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="buffer" ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="common" ) vs_fs = this.NewShader_Common(  this.mSource,                   );
    else if( this.mType==="cubemap") vs_fs = this.NewShader_Cubemap( this.mSource, commonSourceCodes );
    else { console.log("ERROR 3: \"" + this.mType + "\""); return; }

    let me = this;
    this.mRenderer.CreateShader(vs_fs[0], vs_fs[1], preventCache, false,
        function (worked, info)
        {
            if (worked === true)
            {
                if (me.mType === "sound")
                {
                    me.mSoundShaderCompiled = true;
                }

                me.mCompilationTime = info.mTime;
                me.mError = false;
                me.mErrorStr = "No Errors";
                if (me.mProgram !== null)
                    me.mRenderer.DestroyShader(me.mProgram);
                me.mTranslatedSource = me.mRenderer.GetTranslatedShaderSource(info);
                me.mProgram = info;
            }
            else
            {
                me.mError = true;
                me.mErrorStr = info.mErrorStr;
            }
            onResolve();
        });
}

EffectPass.prototype.DestroyInput = function( id )
{
    if( this.mInputs[id]===null ) return;

    if( this.mInputs[id].mInfo.mType==="texture" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    if( this.mInputs[id].mInfo.mType==="volume" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="webcam" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video.src = "";

        if( this.mInputs[id].video.srcObject!==null )
        {
        let tracks = this.mInputs[id].video.srcObject.getVideoTracks();
        if( tracks ) tracks[0].stop();
        }
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="video" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="music" || this.mInputs[id].mInfo.mType==="musicstream")
    {
        this.mInputs[id].audio.pause();
        this.mInputs[id].audio.mSound.mFreqData = null;
        this.mInputs[id].audio.mSound.mWaveData = null;
        this.mInputs[id].audio = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="cubemap" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="keyboard" )
    {
        //if( this.mInputs[id].globject != null )
          //  this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="mic" )
    {
        this.mInputs[id].mic = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }

    this.mInputs[id] = null;
}

EffectPass.prototype.TooglePauseInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        else
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.audio.mPaused )
        {
            if( inp.loaded )
            {
                inp.audio.play();
            }
            inp.audio.mPaused = false;
        }
        else
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }

    return null;
}

EffectPass.prototype.StopInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused === false )
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused === false )
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.ResumeInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused )
        {
            inp.audio.play();
            inp.audio.mPaused = false;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.RewindInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp==null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.loaded )
        {
            inp.video.currentTime = 0;
        }
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.loaded )
        {
            inp.audio.currentTime = 0;
        }
    }
}

EffectPass.prototype.MuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = true;
        inp.video.mMuted = true;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 0.0;
        inp.audio.mMuted = true;
    }
}

EffectPass.prototype.UnMuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = false;
        inp.video.mMuted = false;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 1.0;
        inp.audio.mMuted = false;
    }
}

EffectPass.prototype.ToggleMuteInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];
    if( inp===null ) return null;

    if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.video.mMuted;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if( inp.audio.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.audio.mMuted;
    }

    return null;
}

EffectPass.prototype.UpdateInputs = function( wa, forceUpdate, keyboard )
{
   for (let i=0; i<this.mInputs.length; i++ )
   {
        let inp = this.mInputs[i];

        if( inp===null )
        {
            if( forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, null, false, 0, 0, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.image, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mPreview, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if( inp.loaded && forceUpdate )
            {
                if( this.mTextureCallbackFun!==null )
                {
                    let img = (assetID_to_cubemapBuferID(inp.mInfo.mID)===-1) ? inp.image[0] : inp.mImage;
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, img, true, 2, 1, -1.0, this.mID );
                }
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:keyboard.mIcon,mData:keyboard.mData}, false, 6, 0, -1.0, this.mID );
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, -1, this.mID );
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
              if( inp.loaded && inp.audio.mPaused === false && inp.audio.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                      inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                  }

                  if (this.mTextureCallbackFun!==null)
                  {
                           if (inp.mInfo.mType === "music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData}, false, 4, 1, inp.audio.currentTime, this.mID);
                      else if (inp.mInfo.mType === "musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData, info: inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                  }
              }
              else if( inp.loaded===false )
              {
                  if (this.mTextureCallbackFun!==null)
                      this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:null}, false, 4, 0, -1.0, this.mID);
              }
        }
        else if( inp.mInfo.mType==="mic" )
        {
              if( inp.loaded && inp.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                      inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
                  }
                  if( this.mTextureCallbackFun!==null )
                      this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave: ((wa==null)?null:inp.mFreqData) }, false, 5, 1, 0, this.mID );
              }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:null}, true, 9, 1, -1.0, this.mID );
            }
        }
    }
}

EffectPass.prototype.Sampler2Renderer = function (sampler)
{
    let filter = this.mRenderer.FILTER.NONE;
    if (sampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
    if (sampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
    let wrap = this.mRenderer.TEXWRP.REPEAT;
    if (sampler.wrap === "clamp") wrap = this.mRenderer.TEXWRP.CLAMP;
    let vflip = false;
    if (sampler.vflip === "true") vflip = true;

    return { mFilter: filter, mWrap: wrap, mVFlip: vflip };
}

EffectPass.prototype.GetSamplerVFlip = function (id)
{
    let inp = this.mInputs[id];
    return inp.mInfo.mSampler.vflip;
}

EffectPass.prototype.GetTranslatedShaderSource = function ()
{
    return this.mTranslatedSource;
}

EffectPass.prototype.SetSamplerVFlip = function (id, str) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = false;
    if (str === "true") filter = true;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, null);
            inp.mInfo.mSampler.vflip = str;
        }
    }
}

EffectPass.prototype.GetAcceptsVFlip = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return false;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return false;
    return true;
}

EffectPass.prototype.GetSamplerFilter = function (id)
{
    let inp = this.mInputs[id];
    if( inp===null) return;
    return inp.mInfo.mSampler.filter;
}

EffectPass.prototype.SetSamplerFilter = function (id, str, buffers, cubeBuffers) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = renderer.FILTER.NONE;
    if (str === "linear") filter = renderer.FILTER.LINEAR;
    if (str === "mipmap") filter = renderer.FILTER.MIPMAP;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0)
            {
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[0], filter, true);
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[1], filter, true);
                inp.mInfo.mSampler.filter = str;
            }
            else
            {
                renderer.SetSamplerFilter(inp.globject, filter, true);
                inp.mInfo.mSampler.filter = str;
            }
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[0], filter, true);
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[1], filter, true);
        inp.mInfo.mSampler.filter = str;
    }
    else if (inp.mInfo.mType === "keyboard")
    {
        inp.mInfo.mSampler.filter = str;
    }
}

EffectPass.prototype.GetAcceptsMipmapping = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetAcceptsLinear = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return true;
    if (inp.mInfo.mType === "musicstream") return true;
    if (inp.mInfo.mType === "mic")  return true;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return true;
    return false;
}

EffectPass.prototype.GetAcceptsWrapRepeat = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return false;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetSamplerWrap = function (id)
{
    return this.mInputs[id].mInfo.mSampler.wrap;
}

EffectPass.prototype.SetSamplerWrap = function (id, str, buffers)
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let restr = renderer.TEXWRP.REPEAT;
    if (str === "clamp") restr = renderer.TEXWRP.CLAMP;

    if (inp === null) 
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "video") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap") 
    {
        if (inp.loaded)
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "webcam") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[0], restr);
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[1], restr);
        inp.mInfo.mSampler.wrap = str;
    }
}


EffectPass.prototype.GetTexture = function( slot )
{
    let inp = this.mInputs[slot];
    if( inp===null ) return null;
    return inp.mInfo;
}

EffectPass.prototype.SetOutputs = function( slot, id )
{
    this.mOutputs[slot] = id;
}

EffectPass.prototype.SetOutputsByBufferID = function( slot, id )
{
    if( this.mType==="buffer" )
    {
        this.mOutputs[slot] = bufferID_to_assetID( id );

        this.mEffect.ResizeBuffer( id, this.mEffect.mXres, this.mEffect.mYres, false );
    }
    else if( this.mType==="cubemap" )
    {
        this.mOutputs[slot] = cubamepBufferID_to_assetID( id );
        this.mEffect.ResizeCubemapBuffer(id, 1024, 1024 );
    }
}

EffectPass.prototype.NewTexture = function( wa, slot, url, buffers, cubeBuffers, keyboard )
{
    var me = this;
    var renderer = this.mRenderer;

    if( renderer===null ) return;

    let texture = null;

    if( url===null || url.mType===null )
    {
        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( this.mTextureCallbackObj, slot, null, true, 0, 0, -1.0, me.mID );
        me.DestroyInput( slot );
        me.mInputs[slot] = null;
        me.MakeHeader();
        return { mFailed:false, mNeedsShaderCompile:false };
    }
    else if( url.mType==="texture" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.image = new Image();
        texture.image.crossOrigin = '';
        texture.image.onload = function()
        {
            let rti = me.Sampler2Renderer(url.mSampler);

            // O.M.G. FIX THIS
            let channels = renderer.TEXFMT.C4I8;
            if (url.mID === "Xdf3zn" || url.mID === "4sf3Rn" || url.mID === "4dXGzn" || url.mID === "4sf3Rr")
                channels = renderer.TEXFMT.C1I8;
            
            texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.image, channels, rti.mFilter, rti.mWrap, rti.mVFlip);

            texture.loaded = true;
            if( me.mTextureCallbackFun!==null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.image, true, 1, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="volume" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mImage = { mData:null, mXres:1, mYres:0, mZres:0 };
        texture.mPreview = new Image();
        texture.mPreview.crossOrigin = '';

	    var xmlHttp = new XMLHttpRequest();
        if( xmlHttp===null ) return { mFailed:true };

        xmlHttp.open('GET', url.mSrc, true);
        xmlHttp.responseType = "arraybuffer";
        xmlHttp.onerror = function()
        {
            console.log( "Error 1 loading Volume" );
        }
        xmlHttp.onload = function()
        {
            let data = xmlHttp.response;
            if (!data ) { console.log( "Error 2 loading Volume" ); return; }

            let file = piFile(data);

            let signature = file.ReadUInt32();
            texture.mImage.mXres = file.ReadUInt32();
            texture.mImage.mYres = file.ReadUInt32();
            texture.mImage.mZres = file.ReadUInt32();
            let binNumChannels = file.ReadUInt8();
            let binLayout = file.ReadUInt8();
            let binFormat = file.ReadUInt16();
            let format = renderer.TEXFMT.C1I8;
                 if( binNumChannels===1 && binFormat===0 )  format = renderer.TEXFMT.C1I8;
            else if( binNumChannels===2 && binFormat===0 )  format = renderer.TEXFMT.C2I8;
            else if( binNumChannels===3 && binFormat===0 )  format = renderer.TEXFMT.C3I8;
            else if( binNumChannels===4 && binFormat===0 )  format = renderer.TEXFMT.C4I8;
            else if( binNumChannels===1 && binFormat===10 ) format = renderer.TEXFMT.C1F32;
            else if( binNumChannels===2 && binFormat===10 ) format = renderer.TEXFMT.C2F32;
            else if( binNumChannels===3 && binFormat===10 ) format = renderer.TEXFMT.C3F32;
            else if( binNumChannels===4 && binFormat===10 ) format = renderer.TEXFMT.C4F32;
            else return;

            let buffer = new Uint8Array(data, 20); // skip 16 bytes (header of .bin)

            let rti = me.Sampler2Renderer(url.mSampler);

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T3D, texture.mImage.mXres, texture.mImage.mYres, format, rti.mFilter, rti.mWrap, buffer);

            if( texture.globject===null )
            {
                console.log( "Error 4: loading Volume" ); 
                return { mFailed:true };
            }

            if (me.mTextureCallbackFun !== null)
            {
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }

            texture.loaded = true;

            // load icon for it
            texture.mPreview.onload = function()
            {
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }
            texture.mPreview.src = url.mPreviewSrc;
        }
        xmlHttp.send("");


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="volume")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="cubemap" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        let rti = me.Sampler2Renderer(url.mSampler);

        if( assetID_to_cubemapBuferID(url.mID)!==-1 )
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 2, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/cubemap00.png";

            this.mEffect.ResizeCubemapBuffer(0, 1024, 1024 );

        }
        else
        {
            texture.image = [ new Image(), new Image(), new Image(), new Image(), new Image(), new Image() ];

            let numLoaded = 0;
            for (var i=0; i<6; i++ )
            {
                texture.image[i].mId = i;
                texture.image[i].crossOrigin = '';
                texture.image[i].onload = function()
                {
                    var id = this.mId;
                    numLoaded++;
                    if( numLoaded===6 )
                    {
                        texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.CUBEMAP, texture.image, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                        texture.loaded = true;
                        if (me.mTextureCallbackFun !== null)
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, texture.image[0], true, 2, 1, -1.0, me.mID);
                    }
                }

                if( i === 0) 
                {
                    texture.image[i].src = url.mSrc;
                } 
                else 
                {
                    let n = url.mSrc.lastIndexOf(".");
                    texture.image[i].src = url.mSrc.substring(0, n) + "_" + i + url.mSrc.substring(n, url.mSrc.length);
                }
            }
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="cubemap")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="webcam" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        texture.video = document.createElement('video');
    	texture.video.width = 320;
    	texture.video.height = 240;
    	texture.video.autoplay = true;
    	texture.video.loop = true;
        texture.mForceMuted = this.mForceMuted;
        texture.mImage = null;

        let rti = me.Sampler2Renderer(url.mSampler);

        var loadImageInsteadOfWebCam = function()
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.mImage, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 7, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/webcam.png";
        }
        
        loadImageInsteadOfWebCam();

        if( typeof navigator.getUserMedia !== "undefined"  && texture.mForceMuted===false )
        {
            texture.video.addEventListener("canplay", function (e)
            {
				try
				{
                    texture.mImage = null;
                    if( texture.globject != null )
                        renderer.DestroyTexture( texture.globject );
					texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
					texture.loaded = true;
                }
                catch(e)
                {
                    loadImageInsteadOfWebCam();
	                alert( 'Your browser can not transfer webcam data to the GPU.');
                }
            } );

            navigator.mediaDevices.getUserMedia( 
                                { "video": { width: 1280, height: 720 }, "audio": false } )
                                .then( function(stream)
                                       {
                                            texture.video.srcObject = stream;
    	                               } )
                                .catch( function(error)
                                        {
                                            loadImageInsteadOfWebCam();
    		                                alert( 'Unable to capture WebCam. Please reload the page.' );
    	                                } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="mic" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mForceMuted = this.mForceMuted;
        texture.mAnalyser = null;
        let num = 512;
        texture.mFreqData = new Uint8Array( num );
        texture.mWaveData = new Uint8Array( num );

        if( wa === null || typeof navigator.getUserMedia === "undefined" )
        {
            if( !texture.mForceMuted ) alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.mForceMuted = true; 
        }

        if( texture.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, num, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)
            texture.loaded = true;
        }
        else
        {
        navigator.getUserMedia( { "audio": true },
                                function(stream)
                                {
                                  texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, null)
                                  texture.mic = wa.createMediaStreamSource(stream);
                                  texture.mAnalyser = wa.createAnalyser();
                                  texture.mic.connect( texture.mAnalyser );
                                  texture.loaded = true;
    	                        },
                                function(error)
                                {
    		                        alert( 'Unable open Mic. Please reload the page.' );
    	                        } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="video" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.video = document.createElement('video');
    	texture.video.loop = true;
        texture.video.preload = "auto";
        texture.video.mPaused = this.mForcePaused;
        texture.video.mMuted = true;//this.mForceMuted;
    	texture.video.muted  = true;//this.mForceMuted;
        if( this.mForceMuted===true )
            texture.video.volume = 0;
    	texture.video.autoplay = false;
        texture.video.hasFalled = false;
        
        let rti = me.Sampler2Renderer(url.mSampler);

        texture.video.addEventListener("canplay", function (e)
        {
            texture.video.play().then( function()
                                       {
                                           texture.video.mPaused = false;

                                           texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                                           texture.loaded = true;
            
                                           if( me.mTextureCallbackFun!=null )
                                               me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.video, true, 3, 1, -1.0, me.mID );
                                        } )
                               .catch( function(error)
                                       {
                                           console.log( error );
                                       }
                                );
        } );

        texture.video.addEventListener( "error", function(e)
        {
               if( texture.video.hasFalled===true ) { alert("Error: cannot load video" ); return; }
               let str = texture.video.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".mp4";
               texture.video.src = str;
               texture.video.hasFalled = true;
        } );

        texture.video.src = url.mSrc;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="music" || url.mType==="musicstream" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.audio = document.createElement('audio');
    	texture.audio.loop = true;
        texture.audio.mMuted = this.mForceMuted;
        texture.audio.mForceMuted = this.mForceMuted;
        texture.audio.muted = this.mForceMuted;
        if( this.mForceMuted===true )
            texture.audio.volume = 0;
        texture.audio.autoplay = false;
        texture.audio.hasFalled = false;
        texture.audio.mPaused = false;
        texture.audio.mSound = {};

        if( this.mForceMuted===false )
        {
            if(url.mType==="musicstream" && SC === null)
            {
                alert( "Shadertoy: Soundcloud could not be reached" );
                texture.audio.mForceMuted = true;
            }
            }

        if( wa === null && this.mForceMuted===false )
        {
            alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.audio.mForceMuted = true;
        }

        if( texture.audio.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null);
            let num = 512;
            texture.audio.mSound.mFreqData = new Uint8Array( num );
            texture.audio.mSound.mWaveData = new Uint8Array( num );
            texture.loaded = true;
        }

        texture.audio.addEventListener( "canplay", function()
        {
            if( texture===null || texture.audio===null ) return;
            if( this.mForceMuted  ) return;
            if( texture.loaded === true ) return;

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)

            texture.audio.mSound.mSource   = wa.createMediaElementSource( texture.audio );
            texture.audio.mSound.mAnalyser = wa.createAnalyser();
            texture.audio.mSound.mGain     = wa.createGain();

            texture.audio.mSound.mSource.connect(   texture.audio.mSound.mAnalyser );
            texture.audio.mSound.mAnalyser.connect( texture.audio.mSound.mGain );
            texture.audio.mSound.mGain.connect(me.mGainNode);

            texture.audio.mSound.mFreqData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );
            texture.audio.mSound.mWaveData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );

            if( texture.audio.mPaused )
            {
                texture.audio.pause();
            }
            else
            {
                texture.audio.play().then( function() {} ).catch( function(e){console.log("error " + e);} );
            }
            texture.loaded = true;
        } );

        texture.audio.addEventListener( "error", function(e)
        {
               if( this.mForceMuted  ) return;

               if( texture.audio.hasFalled===true ) { return; }
               let str = texture.audio.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".ogg";
               texture.audio.src = str;
               texture.audio.hasFalled = true;
        } );

        if( !texture.audio.mForceMuted )
        {
            if(url.mType==="musicstream")
            {
                SC.resolve(url.mSrc, 
                    function(song) 
                    {
                        if( song.streamable===true )
                        {
                            texture.audio.crossOrigin = 'anonymous';
                            texture.audio.src = song.stream_url;
                            texture.audio.soundcloudInfo = song;
                        }
                        else
                        {
                            alert('Shadertoy: Soundcloud 3 - This track cannot be streamed' );
                        }
                    },
                    function(error)
                    {
                        if (me.mTextureCallbackFun!==null)
                        {
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
                        }
                    } );
            } 
            else
            {
                texture.audio.src = url.mSrc;
            }
        }

        if (me.mTextureCallbackFun!==null)
        {
            if (url.mType === "music")            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
            else if (url.mType === "musicstream") me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null, info: texture.audio.soundcloudInfo}, false, 8, 0, -1.0, me.mID);
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="keyboard" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = true;

        texture.keyboard = {};

        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {mImage: keyboard.mIcon, mData: keyboard.mData}, false, 6, 1, -1.0, me.mID );

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="buffer" )
    {
        texture = {};
        texture.mInfo = url;

        texture.image = new Image();
        texture.image.onload = function()
        {
            if( me.mTextureCallbackFun!==null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {texture: texture.image, data:null}, true, 9, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;
        texture.id = assetID_to_bufferID( url.mID );
        texture.loaded = true;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;

        this.mEffect.ResizeBuffer(texture.id, this.mEffect.mXres, this.mEffect.mYres, false );

        this.SetSamplerFilter(slot, url.mSampler.filter, buffers, cubeBuffers, true);
        this.SetSamplerVFlip(slot, url.mSampler.vflip);
        this.SetSamplerWrap(slot, url.mSampler.wrap, buffers);

        this.MakeHeader();
        return returnValue;
    }
    else
    {
        alert( "input type error" );
        return { mFailed: true };
    }

    return { mFailed: true };
}

EffectPass.prototype.Paint_Image = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];

    //------------------------
    
    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];
    let texIsLoaded = [0, 0, 0, 0 ];
    let texID = [ null, null, null, null];

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
            texIsLoaded[i] = 1;
            resos[3*i+0] = 256;
            resos[3*i+1] = 3;
            resos[3*i+2] = 1;
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;

                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                }
            }
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {

                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                texIsLoaded[i] = 0;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    times[i] = 10.0 + time;
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            let id = inp.id;
            if( inp.loaded===true  )
            {
                texID[i] = buffers[id].mTexture[ buffers[id].mLastRenderDone ];
                texIsLoaded[i] = 1;
                resos[3*i+0] = xres;
                resos[3*i+1] = yres;
                resos[3*i+2] = 1;
                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID[i], filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    let prog = this.mProgram;

    //if( vrData!=null && this.mSupportsVR ) prog = this.mProgramVR;

    this.mRenderer.AttachShader(prog);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F("iFrameRate", fps);

    this.mRenderer.SetShaderConstant1F(  "iCh0.time", times[0] );
    this.mRenderer.SetShaderConstant1F(  "iCh1.time", times[1] );
    this.mRenderer.SetShaderConstant1F(  "iCh2.time", times[2] );
    this.mRenderer.SetShaderConstant1F(  "iCh3.time", times[3] );
    this.mRenderer.SetShaderConstant3F(  "iCh0.size", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iCh1.size", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iCh2.size", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iCh3.size", resos[9], resos[10], resos[11] );
    this.mRenderer.SetShaderConstant1I(  "iCh0.loaded", texIsLoaded[0] );
    this.mRenderer.SetShaderConstant1I(  "iCh1.loaded", texIsLoaded[1] );
    this.mRenderer.SetShaderConstant1I(  "iCh2.loaded", texIsLoaded[2] );
    this.mRenderer.SetShaderConstant1I(  "iCh3.loaded", texIsLoaded[3] );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    if( (vrData !== null) && this.mSupportsVR )
    {
        for (let i=0; i<2; i++ )
        {
            let ei = (i===0) ? vrData.mLeftEye : vrData.mRightEye;

            let vp = [i * xres / 2, 0, xres / 2, yres];

            this.mRenderer.SetViewport(vp);

            let fov = ei.mProjection;
            let corA = [ -fov[2], -fov[1], -1.0 ];
            let corB = [  fov[3], -fov[1], -1.0 ];
            let corC = [  fov[3],  fov[0], -1.0 ];
            let corD = [ -fov[2],  fov[0], -1.0 ];
            let apex = [ 0.0, 0.0, 0.0 ];

            let ma = invertFast( ei.mCamera );
            corA = matMulpoint( ma, corA ); 
            corB = matMulpoint( ma, corB ); 
            corC = matMulpoint( ma, corC ); 
            corD = matMulpoint( ma, corD ); 
            apex = matMulpoint( ma, apex ); 

            let corners = [ corA[0], corA[1], corA[2], 
                            corB[0], corB[1], corB[2], 
                            corC[0], corC[1], corC[2], 
                            corD[0], corD[1], corD[2],
                            apex[0], apex[1], apex[2]];

            this.mRenderer.SetShaderConstant3FV("unCorners", corners);
            this.mRenderer.SetShaderConstant4FV("unViewport", vp);

            this.mRenderer.DrawUnitQuad_XY(l1);
        }
    }
    else 
    {
        this.mRenderer.SetViewport([0, 0, xres, yres]);
        this.mRenderer.DrawFullScreenTriangle_XY( l1 );
    }

    this.mRenderer.DettachTextures();
}

EffectPass.prototype.iRenderSound = function(d, callback )
{
    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds() ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    this.mRenderer.SetRenderTarget(this.mRenderFBO);

    this.mRenderer.SetViewport([0, 0, this.mTextureDimensions, this.mTextureDimensions]);
    this.mRenderer.AttachShader(this.mProgram);
    this.mRenderer.SetBlend( false );

    let texID = [null, null, null, null];
    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
    }

    this.mRenderer.AttachTextures(4, texID[0], texID[1], texID[2], texID[3]);

    let l2 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iTimeOffset");
    let l3 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iSampleOffset");
    this.mRenderer.SetShaderConstant4FV("iDate", dates);
    this.mRenderer.SetShaderConstant3FV("iChannelResolution", resos);
    this.mRenderer.SetShaderConstant1F("iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit("iChannel0", 0);
    this.mRenderer.SetShaderTextureUnit("iChannel1", 1);
    this.mRenderer.SetShaderTextureUnit("iChannel2", 2);
    this.mRenderer.SetShaderTextureUnit("iChannel3", 3);

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    //--------------------------------
    let numSamples = this.mTmpBufferSamples;
    let numBlocks = this.mPlaySamples / numSamples;
    for (let j=0; j<numBlocks; j++ )
    {
        let off = j*numSamples;
        
        this.mRenderer.SetShaderConstant1F_Pos(l2, off / this.mSampleRate);
        this.mRenderer.SetShaderConstant1I_Pos(l3, off );
        this.mRenderer.DrawUnitQuad_XY(l1);

        this.mRenderer.GetPixelData(this.mData, 0, this.mTextureDimensions, this.mTextureDimensions);

        callback( off, this.mData, numSamples );
    }

    this.mRenderer.DetachShader();
    this.mRenderer.DettachTextures();
    this.mRenderer.SetRenderTarget(null);
}

EffectPass.prototype.Paint_Sound = function( wa, d )
{
    let bufL = this.mBuffer.getChannelData(0); // Float32Array
    let bufR = this.mBuffer.getChannelData(1); // Float32Array

    this.iRenderSound( d, function(off, data, numSamples)
                         {
                            for( let i=0; i<numSamples; i++ )
                            {
                                bufL[off+i] = -1.0 + 2.0*(data[4*i+0]+256.0*data[4*i+1])/65535.0;
                                bufR[off+i] = -1.0 + 2.0*(data[4*i+2]+256.0*data[4*i+3])/65535.0;
                            }
                         }
                     );
}

EffectPass.prototype.SetUniforms = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    //------------------------
    
    let texID = [ null, null, null, null];

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
        }
        else if( inp.mInfo.mType=="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
    
                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                }
            }

        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
           if( inp.loaded===true )
           { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                times[i] = 10.0 + time;
            }

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = buffers[inp.id].mTexture[ buffers[inp.id].mLastRenderDone ];
                resos[3*i+0] = buffers[inp.id].mResolution[0];
                resos[3*i+1] = buffers[inp.id].mResolution[1];
                resos[3*i+2] = 1;
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    this.mRenderer.AttachShader(this.mProgram);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F(  "iFrameRate", fps );

    this.mRenderer.SetShaderConstant1F(  "iChannel[0].time",       times[0] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[1].time",       times[1] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[2].time",       times[2] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[3].time",       times[3] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[0].resolution", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[1].resolution", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[2].resolution", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[3].resolution", resos[9], resos[10], resos[11] );
}

EffectPass.prototype.ProcessInputs = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
        }
        else if( inp.mInfo.mType==="volume" )
        {
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );
                }
                else if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                if( inp.audio.mForceMuted === true )
                {
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                let id = inp.id;
                let texID = buffers[id].mTexture[ buffers[id].mLastRenderDone ];

                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID, filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
				let id = inp.id;
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }
}

EffectPass.prototype.Paint_Cubemap = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face )
{
    this.ProcessInputs(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
    this.SetUniforms(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    let vp = [0, 0, xres, yres];

    this.mRenderer.SetViewport(vp);

    let corA = [-1.0, -1.0, -1.0];
    let corB = [ 1.0, -1.0, -1.0];
    let corC = [ 1.0,  1.0, -1.0];
    let corD = [-1.0,  1.0, -1.0];
    let apex = [ 0.0,  0.0,  0.0];

         if( face===0 ) { corA=[ 1.0,  1.0,  1.0]; corB=[ 1.0,  1.0, -1.0]; corC=[ 1.0, -1.0, -1.0]; corD=[ 1.0, -1.0,  1.0]; }
    else if( face===1 ) { corA=[-1.0,  1.0, -1.0]; corB=[-1.0,  1.0,  1.0]; corC=[-1.0, -1.0,  1.0]; corD=[-1.0, -1.0, -1.0]; }
    else if( face===2 ) { corA=[-1.0,  1.0, -1.0]; corB=[ 1.0,  1.0, -1.0]; corC=[ 1.0,  1.0,  1.0]; corD=[-1.0,  1.0,  1.0]; }
    else if( face===3 ) { corA=[-1.0, -1.0,  1.0]; corB=[ 1.0, -1.0,  1.0]; corC=[ 1.0, -1.0, -1.0]; corD=[-1.0, -1.0, -1.0]; }
    else if( face===4 ) { corA=[-1.0,  1.0,  1.0]; corB=[ 1.0,  1.0,  1.0]; corC=[ 1.0, -1.0,  1.0]; corD=[-1.0, -1.0,  1.0]; }
    else if( face===5 ) { corA=[ 1.0,  1.0, -1.0]; corB=[-1.0,  1.0, -1.0]; corC=[-1.0, -1.0, -1.0]; corD=[ 1.0, -1.0, -1.0]; }

    let corners = [ corA[0], corA[1], corA[2], 
                    corB[0], corB[1], corB[2], 
                    corC[0], corC[1], corC[2], 
                    corD[0], corD[1], corD[2],
                    apex[0], apex[1], apex[2]];

    this.mRenderer.SetShaderConstant3FV("unCorners", corners);
    this.mRenderer.SetShaderConstant4FV("unViewport", vp);

    this.mRenderer.DrawUnitQuad_XY(l1);

    this.mRenderer.DettachTextures();
}

EffectPass.prototype.Paint = function( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, bufferNeedsMimaps, buffers, cubeBuffers, keyboard, effect )
{
    if( this.mType==="sound" )
    {
        if (this.mSoundShaderCompiled === true)
        {
            // make sure all textures are loaded
            for (let i=0; i<this.mInputs.length; i++ )
            {
                let inp = this.mInputs[i];
                if (inp === null) continue;

                if (inp.mInfo.mType === "texture" && !inp.loaded) return;
                if (inp.mInfo.mType === "cubemap" && !inp.loaded) return;
            }

            this.Paint_Sound(wa, da);
            this.mSoundShaderCompiled = false;
        }
        if (this.mFrame === 0)
        {
            if (this.mPlaying===true)
            {
                this.mPlayNode.disconnect();
                this.mPlayNode.stop();
                this.mPlayNode = null;
            }
            this.mPlaying = true;

            this.mPlayNode = wa.createBufferSource();
            this.mPlayNode.buffer = this.mBuffer;
            this.mPlayNode.connect(this.mGainNode);
            this.mPlayNode.start(0);
        }
        this.mFrame++;
    }
    else if( this.mType==="image" )
    {
        this.mRenderer.SetRenderTarget( null );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );
        this.mFrame++;
    }
    else if( this.mType==="common" )
    {
    }
    else if( this.mType==="buffer" )
    {
        this.mEffect.ResizeBuffer(bufferID, this.mEffect.mXres, this.mEffect.mYres, false );

        let buffer = buffers[bufferID];

        let dstID = 1 - buffer.mLastRenderDone;

        this.mRenderer.SetRenderTarget( buffer.mTarget[dstID] );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }

        // make thumbnail
        //if( this.mTextureCallbackFun != null )
        /*
        {
            this.mRenderer.SetRenderTarget( buffer.mThumbnailRenderTarget );
            let v = [0, 0, buffer.mThumbnailRes[0], buffer.mThumbnailRes[1]];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            this.mRenderer.SetShaderConstant4FV("v", v);
            this.mRenderer.AttachTextures(1, buffer.mTexture[dstID], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);
            this.mRenderer.DettachTextures();
            this.mRenderer.DetachShader();
            this.mRenderer.GetPixelData( new Uint8Array(buffer.mThumbnailBuffer.data.buffer), buffer.mThumbnailRes[0], buffer.mThumbnailRes[1] );
            this.mRenderer.SetRenderTarget(null);
        }
        */
        buffers[bufferID].mLastRenderDone = 1 - buffers[bufferID].mLastRenderDone;
        this.mFrame++;
    }
    else if( this.mType==="cubemap" )
    {
        this.mEffect.ResizeCubemapBuffer(bufferID, 1024, 1024, false );

        let buffer = cubeBuffers[bufferID];

        xres = buffer.mResolution[0];
        yres = buffer.mResolution[1];
        let dstID = 1 - buffer.mLastRenderDone;
        for( let face=0; face<6; face++ )
        {
            this.mRenderer.SetRenderTargetCubeMap( buffer.mTarget[dstID], face );
            this.Paint_Cubemap( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
        }
        this.mRenderer.SetRenderTargetCubeMap( null, 0 );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }
        cubeBuffers[bufferID].mLastRenderDone = 1 - cubeBuffers[bufferID].mLastRenderDone;

        this.mFrame++;
    }
}

EffectPass.prototype.StopOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;
    this.mPlayNode.disconnect();
}

EffectPass.prototype.ResumeOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;

    wa.resume()
    this.mPlayNode.connect( this.mGainNode );
}

EffectPass.prototype.StopOutput_Image = function( wa )
{
}

EffectPass.prototype.ResumeOutput_Image = function( wa )
{
}

EffectPass.prototype.StopOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.StopInput(j);

    if( this.mType==="sound" )
         this.StopOutput_Sound( wa );
    else
         this.StopOutput_Image( wa );
}

EffectPass.prototype.ResumeOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.ResumeInput(j);

    if( this.mType==="sound" )
         this.ResumeOutput_Sound( wa );
    else
         this.ResumeOutput_Image( wa );
}

EffectPass.prototype.GetCompilationTime = function()
{
    return this.mCompilationTime;
}

//============================================================================================================
function Screenshots()
{
    // private
    let mTexture = null;
    let mTarget = null;
    let mXres = 0;
    let mYres = 0;
    let mCubemapToEquirectProgram;
    let mRenderer = null;

    // public
    var me = {};

    me.Initialize = function(renderer)
    {
        mRenderer = renderer;
        let caps = mRenderer.GetCaps();
        let is20 = caps.mIsGL20;

        let vsSourceC, fsSourceC;
        if( is20 )
        {
            vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; out vec4 outColor; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); outColor = texture(t, rd); }";
        }
        else
        {
            vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); gl_FragColor = texture(t, rd); }";
        }

        let compileShader = function (worked, info)
        {
            if (worked === false)
            {
                console.log("Failed to compile cubemap resample shader (" + errorType + "): " + log);
            }
            else
            {
                mCubemapToEquirectProgram = info;
            }
        }
        mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, compileShader);

        return true;
    };

    me.Allocate = function( xres, yres )
    {
        if( xres>mXres || yres>mYres )
        {
            let texture = mRenderer.CreateTexture(mRenderer.TEXTYPE.T2D, xres, yres, mRenderer.TEXFMT.C4F32, mRenderer.FILTER.NONE, mRenderer.TEXWRP.CLAMP, null);
            let target = mRenderer.CreateRenderTarget( texture, null, null, null, null, false);

            if( mXres!==0 )
            {
                mRenderer.DestroyTexture(mTexture);
                mRenderer.DestroyRenderTarget(mTarget);
            }

            mTexture = texture;
            mTarget = target;
            mXres = xres;
            mYres = yres;
        }
    };

    me.GetProgram = function()
    {
        return mCubemapToEquirectProgram;
    };
    me.GetTarget = function()
    {
        return mTarget;
    };

    return me;
};

//============================================================================================================

function Effect(vr, ac, canvas, callback, obj, forceMuted, forcePaused, resizeCallback, crashCallback )
{
    let xres = canvas.width;
    let yres = canvas.height;

    let me = this;
    this.mCanvas = canvas;
    this.mCreated = false;
    this.mRenderer = null;
    this.mAudioContext = ac;
    this.mGLContext = null;
    this.mWebVR = vr;
    this.mRenderingStereo = false;
    this.mXres = xres;
    this.mYres = yres;
    this.mForceMuted = forceMuted;
    if( ac===null ) this.mForceMuted = true;
    this.mForcePaused = forcePaused;
    this.mGainNode = null;
    this.mPasses = [];
    this.mFrame = 0;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mMaxBuffers = 4;
    this.mMaxCubeBuffers = 1;
    this.mMaxPasses = this.mMaxBuffers + 1 + 1 + 1 + 1; // some day decouple passes from buffers (4 buffers + common + Imagen + sound + cubemap)
    this.mBuffers = [];
    this.mCubeBuffers = [];
    this.mScreenshotSytem = null;
    this.mCompilationTime = 0;
    this.mIsLowEnd = piIsMobile();

    this.mGLContext = piCreateGlContext(canvas, false, false, true, false); // need preserve-buffe to true in order to capture screenshots
    if (this.mGLContext === null)
    {
        return;
    }

    canvas.addEventListener("webglcontextlost", function (event)
        {
            event.preventDefault();
            crashCallback();
        }, false);

    this.mRenderer = piRenderer();
    if (!this.mRenderer.Initialize(this.mGLContext))
        return;

    this.mScreenshotSytem = Screenshots();
    if (!this.mScreenshotSytem.Initialize(this.mRenderer))
        return;

    var caps = this.mRenderer.GetCaps();
    this.mIs20 = caps.mIsGL20;
    this.mShaderTextureLOD = caps.mShaderTextureLOD;
    //-------------
    if( ac!==null )
    {   
        this.mGainNode = ac.createGain();
        if( !forceMuted )
        {
            this.mGainNode.connect( ac.destination);
        }
        if (this.mForceMuted )
            this.mGainNode.gain.value = 0.0;
        else
            this.mGainNode.gain.value = 1.0;
    }

    //-------------
    let vsSourceC, fsSourceC;
    if( this.mIs20 )
    {
        vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { outColor = textureLod(t, gl_FragCoord.xy / v.zw, 0.0); }";
    }
    else
    {
        vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; void main() { gl_FragColor = texture2D(t, gl_FragCoord.xy / v.zw, -100.0); }";
    }

    this.mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, function(worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to copy buffers : " + info.mErrorStr);
            else me.mProgramCopy = info;
        });

    let vsSourceD, fsSourceD;
    if( this.mIs20 )
    {
        vsSourceD = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { vec2 uv = gl_FragCoord.xy / v.zw; outColor = texture(t, vec2(uv.x,1.0-uv.y)); }";
    }
    else
    {
        vsSourceD = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; void main() { vec2 uv = gl_FragCoord.xy / v.zw; gl_FragColor = texture2D(t, vec2(uv.x,1.0-uv.y)); }";
    }

    this.mRenderer.CreateShader(vsSourceD, fsSourceD, false, true, function (worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to downscale buffers : " + info.mErrorStr);
            else me.mProgramDownscale = info;
        });


    // set all buffers and cubemaps to null
    for( let i=0; i<this.mMaxBuffers; i++ )
    {
        this.mBuffers[i] = { mTexture: [null, null], 
                             mTarget:  [null, null], 
                             mResolution: [0, 0],
                             mLastRenderDone: 0,
                             mThumbnailRenderTarget: null,
                             mThumbnailTexture: null,
                             mThumbnailBuffer:  null,
                             mThumbnailRes: [0, 0] };
    }

    for( let i=0; i<this.mMaxCubeBuffers; i++ )
    {
        this.mCubeBuffers[i] = { mTexture: [null, null], 
                                mTarget:  [null, null], 
                                mResolution: [0, 0],
                                mLastRenderDone: 0,
                                mThumbnailRenderTarget: null,
                                mThumbnailTexture: null,
                                mThumbnailBuffer:  null,
                                mThumbnailRes: [0, 0] };
    }

    //-------

    let keyboardData = new Uint8Array( 256*3 );
    for (let j=0; j<(256*3); j++ ) { keyboardData[j] = 0; }
    let kayboardTexture = this.mRenderer.CreateTexture( this.mRenderer.TEXTYPE.T2D, 256, 3, this.mRenderer.TEXFMT.C1I8, this.mRenderer.FILTER.NONE, this.mRenderer.TEXWRP.CLAMP, null);
    let keyboardImage = new Image();
    if( callback!==null )
        keyboardImage.src = "/img/keyboard.png"; // don't load PNG if no UI 
    this.mKeyboard = { mData: keyboardData, mTexture: kayboardTexture, mIcon: keyboardImage };

    let iResize = function( xres, yres )
    {
        me.mCanvas.width = xres;
        me.mCanvas.height = yres;
        me.mXres = xres;
        me.mYres = yres;
        me.ResizeBuffers(xres, yres);
        resizeCallback(xres, yres);
    };

    let bestAttemptFallback = function()
    {
        let devicePixelRatio = window.devicePixelRatio || 1;
        let xres = Math.round(me.mCanvas.offsetWidth  * devicePixelRatio) | 0;
        let yres = Math.round(me.mCanvas.offsetHeight * devicePixelRatio) | 0;
        iResize(xres, yres);
    };

    if(!window.ResizeObserver)
    {
        console.log("WARNING: This browser doesn't support ResizeObserver.");
        bestAttemptFallback();
        window.addEventListener("resize", bestAttemptFallback);
    }
    else
    {
        this.mRO = new ResizeObserver( function(entries, observer)
        {
            var entry = entries[0];
            if (!entry['devicePixelContentBoxSize'])
            {
                observer.unobserve(me.mCanvas);
                console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (2)");
                bestAttemptFallback();
                window.addEventListener("resize", bestAttemptFallback);
            }
            else
            {
                let box = entry.devicePixelContentBoxSize[0];
                let xres = box.inlineSize;
                let yres = box.blockSize;
                iResize(xres, yres);
            }
        });
        try
        {
            this.mRO.observe(this.mCanvas, { box: ["device-pixel-content-box"] });
            //this.mRO.observe(this.mCanvas);
        }
        catch (e)
        {
            console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (1)");
            bestAttemptFallback();
            window.addEventListener("resize", bestAttemptFallback);
        }
    }

    this.mCreated = true;
}

Effect.prototype.ResizeCubemapBuffer = function(i, xres, yres )
{
    let oldXres = this.mCubeBuffers[i].mResolution[0];
    let oldYres = this.mCubeBuffers[i].mResolution[1];

    if( this.mCubeBuffers[i].mTexture[0]===null || oldXres !== xres || oldYres !== yres )
    {
        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);
        let target1 = this.mRenderer.CreateRenderTargetCubeMap( texture1, null, false);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target2 = this.mRenderer.CreateRenderTargetCubeMap( texture2, null, false);

        // Store new buffers
        this.mCubeBuffers[i].mTexture = [texture1,texture2], 
        this.mCubeBuffers[i].mTarget =  [target1, target2 ], 
        this.mCubeBuffers[i].mLastRenderDone = 0;
        this.mCubeBuffers[i].mResolution[0] = xres;
        this.mCubeBuffers[i].mResolution[1] = yres;
    }
}

Effect.prototype.ResizeBuffer = function( i, xres, yres, skipIfNotExists )
{
    if( skipIfNotExists && this.mBuffers[i].mTexture[0]===null ) return;

    let oldXres = this.mBuffers[i].mResolution[0];
    let oldYres = this.mBuffers[i].mResolution[1];

    if( oldXres !== xres || oldYres !== yres )
    {
        let needCopy = (this.mBuffers[i].mTexture[0]!==null);

        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[0].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[0].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[1].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[1].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target1 = this.mRenderer.CreateRenderTarget( texture1, null, null, null, null, false);
        let target2 = this.mRenderer.CreateRenderTarget( texture2, null, null, null, null, false);

        if( needCopy )
        {
            let v = [0, 0, Math.min(xres, oldXres), Math.min(yres, oldYres)];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            let vOld = [0, 0, oldXres, oldYres];
            this.mRenderer.SetShaderConstant4FV("v", vOld);

            // Copy old buffers 1 to new buffer
            this.mRenderer.SetRenderTarget(target1);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[0], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Copy old buffers 2 to new buffer
            this.mRenderer.SetRenderTarget(target2);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[1], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Deallocate old memory
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[0]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[0]);
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[1]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[1]);
            //this.mRenderer.DestroyTexture(this.mBuffers[i].thumbnailTexture);
        }

        // Store new buffers
        this.mBuffers[i].mTexture = [texture1,texture2], 
        this.mBuffers[i].mTarget =  [target1, target2 ], 
        this.mBuffers[i].mLastRenderDone = 0;
        this.mBuffers[i].mResolution[0] = xres;
        this.mBuffers[i].mResolution[1] = yres;
    }
}

Effect.prototype.saveScreenshot = function(passid)
{
    let pass = this.mPasses[passid];

    if( pass.mType === "buffer" )
    {
        let bufferID = assetID_to_bufferID( this.mPasses[passid].mOutputs[0] );

        let texture = this.mBuffers[bufferID].mTarget[ this.mBuffers[bufferID].mLastRenderDone ];

        let numComponents = 3;
        let width = texture.mTex0.mXres;
        let height = texture.mTex0.mYres;
        let type = "Float"; // Other options Float, Half, Uint
        let bytes = new Float32Array(width * height * 4 );//numComponents);
        this.mRenderer.GetPixelDataRenderTarget( texture, bytes, width, height );
        let blob = piExportToEXR(width, height, numComponents, type, bytes);

        // Offer download automatically to the user
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "cubemap" )
    {
        let xres = 4096;
        let yres = 2048;
        this.mScreenshotSytem.Allocate( xres, yres );

        let cubeBuffer = this.mCubeBuffers[0];

        let target = this.mScreenshotSytem.GetTarget();
        this.mRenderer.SetRenderTarget( target );

        let program = this.mScreenshotSytem.GetProgram();

        this.mRenderer.AttachShader(program);
        let l1 = this.mRenderer.GetAttribLocation(program, "pos");
        this.mRenderer.SetViewport( [0, 0, xres, yres] );
        this.mRenderer.AttachTextures(1, cubeBuffer.mTexture[ cubeBuffer.mLastRenderDone ], null, null, null);
        this.mRenderer.DrawUnitQuad_XY(l1);
        this.mRenderer.DettachTextures();
        this.mRenderer.SetRenderTarget( null );

        let data = new Float32Array(xres*yres*4);
        this.mRenderer.GetPixelDataRenderTarget( target, data, xres, yres );

        let blob = piExportToEXR(xres, yres, 3, "Float", data );
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "sound" )
    {
        let offset = 0;
        const bits = 16;
        const numChannels = 2;
        let words = new Int16Array(60*pass.mSampleRate*numChannels );

        pass.iRenderSound( new Date(), function(off, data, numSamples)
                                         {
                                            for( let i=0; i<numSamples; i++ )
                                            {
                                                words[offset++] = (data[4*i+0]+256.0*data[4*i+1]) - 32767;
                                                words[offset++] = (data[4*i+2]+256.0*data[4*i+3]) - 32767;
                                            }
                                         }
                                     );

        let blob = piExportToWAV( 60*pass.mSampleRate, pass.mSampleRate, bits, numChannels, words);

        piTriggerDownload("sound.wav", blob);
    }    
}

Effect.prototype.ResizeBuffers = function(xres, yres)
{
    for (let i=0; i<this.mMaxBuffers; i++ )
    {
        this.ResizeBuffer(i, xres, yres, true);
    }
}

Effect.prototype.IsEnabledVR = function ()
{
    if (this.mRenderingStereo) return true;
    return false;
}

Effect.prototype.EnableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( this.mRenderingStereo ) return;

    this.mRenderingStereo = true;
    this.mWebVR.Enable();
}

Effect.prototype.DisableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( !this.mRenderingStereo ) return;

    this.mRenderingStereo = false;
    this.mWebVR.Disable();
}

Effect.prototype.GetTexture = function( passid, slot ) { return this.mPasses[passid].GetTexture( slot ); }
Effect.prototype.NewTexture = function (passid, slot, url) { return this.mPasses[passid].NewTexture( this.mAudioContext, slot, url, this.mBuffers, this.mCubeBuffers, this.mKeyboard ); }
Effect.prototype.SetOutputs = function( passid, slot, url ) { this.mPasses[passid].SetOutputs( slot, url ); }
Effect.prototype.SetOutputsByBufferID = function( passid, slot, id ) { this.mPasses[passid].SetOutputsByBufferID( slot, id ); }
Effect.prototype.GetAcceptsLinear = function (passid, slot) { return this.mPasses[passid].GetAcceptsLinear(slot); }
Effect.prototype.GetAcceptsMipmapping = function (passid, slot) { return this.mPasses[passid].GetAcceptsMipmapping(slot); }
Effect.prototype.GetAcceptsWrapRepeat = function (passid, slot) { return this.mPasses[passid].GetAcceptsWrapRepeat(slot); }
Effect.prototype.GetAcceptsVFlip = function (passid, slot) { return this.mPasses[passid].GetAcceptsVFlip(slot); }
Effect.prototype.SetSamplerFilter = function (passid, slot, str) { this.mPasses[passid].SetSamplerFilter(slot, str, this.mBuffers, this.mCubeBuffers); }
Effect.prototype.GetTranslatedShaderSource = function (passid) { return this.mPasses[passid].GetTranslatedShaderSource(); }
Effect.prototype.GetSamplerFilter = function (passid, slot) { return this.mPasses[passid].GetSamplerFilter(slot); }
Effect.prototype.SetSamplerWrap = function (passid, slot, str) { this.mPasses[passid].SetSamplerWrap(slot, str, this.mBuffers); }
Effect.prototype.GetSamplerWrap = function (passid, slot) { return this.mPasses[passid].GetSamplerWrap(slot); }
Effect.prototype.SetSamplerVFlip = function (passid, slot, str) { this.mPasses[passid].SetSamplerVFlip(slot, str); }
Effect.prototype.GetSamplerVFlip = function (passid, slot) { return this.mPasses[passid].GetSamplerVFlip(slot); }

Effect.prototype.GetHeaderSize = function (passid)
{
    return this.mPasses[passid].mHeaderLength + 
           this.mRenderer.GetShaderHeaderLines(1);
}

Effect.prototype.ToggleVolume = function()
{
    this.mForceMuted = !this.mForceMuted;

    // outp
    if (this.mForceMuted)
        this.mGainNode.gain.value = 0.0;
    else
        this.mGainNode.gain.value = 1.0;

    // inp
    let num = this.mPasses.length;
    for( let j=0; j<num; j++ )
    {
        for( let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            if( this.mForceMuted )
                this.mPasses[j].MuteInput( this.mAudioContext, i );
            else
                this.mPasses[j].UnMuteInput( this.mAudioContext, i );
        }
    }

    return this.mForceMuted;
}

Effect.prototype.SetKeyDown = function( passid, k )
{
    if( this.mKeyboard.mData[ k + 0*256 ] == 255 ) return;

    this.mKeyboard.mData[ k + 0*256 ] = 255;
    this.mKeyboard.mData[ k + 1*256 ] = 255;
    this.mKeyboard.mData[ k + 2*256 ] = 255 - this.mKeyboard.mData[ k + 2*256 ];
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }
}

Effect.prototype.SetKeyUp = function( passid, k )
{
    this.mKeyboard.mData[ k + 0*256 ] = 0;
    this.mKeyboard.mData[ k + 1*256 ] = 0;
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }
}

Effect.prototype.StopOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].StopOutput( wa );
    }
}

Effect.prototype.ResumeOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].ResumeOutput( wa );
    }
}

Effect.prototype.PauseInput = function( passid, id )
{
    return this.mPasses[passid].TooglePauseInput( this.mAudioContext, id );
}

Effect.prototype.ToggleMuteInput = function( passid, id )
{
    return this.mPasses[passid].ToggleMuteInput( this.mAudioContext, id );
}

Effect.prototype.RewindInput = function( passid, id )
{
    this.mPasses[passid].RewindInput( this.mAudioContext, id );
}

Effect.prototype.UpdateInputs = function( passid, forceUpdate )
{
   this.mPasses[passid].UpdateInputs( this.mAudioContext, forceUpdate, this.mKeyboard );
}

Effect.prototype.ResetTime = function()
{
    this.mFrame = 0;
    this.mAudioContext.resume()

    let num = this.mPasses.length;
    for( let i=0; i<num; i++ )
    {
        this.mPasses[i].mFrame = 0;
        for( let j=0; j<this.mPasses[i].mInputs.length; j++ )
            this.mPasses[i].RewindInput(this.mAudioContext, j)
    }
}

Effect.prototype.RequestAnimationFrame = function (id)
{
    if (this.mRenderingStereo && this.mWebVR.IsPresenting())
    {
        this.mWebVR.RequestAnimationFrame(id);
    }
    else
    {
        requestAnimFrame(id);
    }
}

Effect.prototype.Paint = function(time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, isPaused)
{
    let wa = this.mAudioContext;
    let da = new Date();
    let vrData = null; if (this.mRenderingStereo) vrData = this.mWebVR.GetData();
    let xres = this.mXres / 1;
    let yres = this.mYres / 1;

    if( this.mFrame===0 )
    {
        for( let i=0; i<this.mMaxBuffers; i++ )
        {
            if( this.mBuffers[i].mTexture[0]!==null )
            {
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[0] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[1] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
				
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[0] );
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[1] );
            }
        }
        for( let i=0; i<this.mMaxCubeBuffers; i++ )
        {
            if( this.mCubeBuffers[i].mTexture[0]!==null )
            {
                for( let face=0; face<6; face++ )
                {
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[0], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[1], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
					this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[0] );
				    this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[1] );
                }
            }
        }
    }

    let num = this.mPasses.length;

    // render sound first
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "sound" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "buffer" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;
        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="buffer" && inp.id === bufferID && inp.mInfo.mSampler.filter === "mipmap")
                {
                    needMipMaps = true;
                    break;
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render cubemap buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "cubemap" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = 0;//assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;

        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="cubemap" )
                {
                    if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0 && inp.mInfo.mSampler.filter === "mipmap" )
                    {
                        needMipMaps = true;
                        break;
                    }
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render image last
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "image" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }   

    // erase keypresses
    for (let k=0; k<256; k++ )
    {
       this.mKeyboard.mData[ k + 1*256 ] = 0;
    }
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    if( this.mRenderingStereo ) this.mWebVR.Finish();

    this.mFrame++;
}

Effect.prototype.NewShader = function( passid, preventCache, onResolve )
{
    let commonSourceCodes = [];
    for (let i=0; i<this.mPasses.length; i++ )
    {
        if( this.mPasses[i].mType==="common")
        {
            commonSourceCodes.push(this.mPasses[i].mSource);
        }
    }

    this.mPasses[passid].NewShader(commonSourceCodes, preventCache, onResolve );
}

Effect.prototype.GetNumPasses = function()
{
    return this.mPasses.length;
}

Effect.prototype.GetNumOfType = function(passtype)
{
    let id = 0;
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType===passtype )
        {
            id++;
        }
    }
    return id;
}

Effect.prototype.GetPassType = function( id ) { return this.mPasses[id].mType; }
Effect.prototype.GetPassName = function( id ) { return this.mPasses[id].mName; }
Effect.prototype.GetCode = function( id ) { return this.mPasses[id].mSource; }
Effect.prototype.SetCode = function( id, source ) { this.mPasses[id].SetCode(source); }
Effect.prototype.GetError = function (id) { return this.mPasses[id].mError; }
Effect.prototype.GetErrorStr = function (id) { return this.mPasses[id].mErrorStr; }
Effect.prototype.GetErrorGlobal = function()
{
    for (let i = 0; i < this.mPasses.length; i++)
    {
        if (this.mPasses[i].mError)
        {
            return true;
        }
    }
    return false;
}

Effect.prototype.Load = function (jobj )
{
    if (jobj.ver !== "0.1")
    {
        console.log("Wrong Format");
        return false;
    }

    let numPasses = jobj.renderpass.length;

    if( numPasses<1 || numPasses>this.mMaxPasses )
    {
        console.log("Corrupted Shader - " + numPasses);
        return false;
    }

    this.mPasses = [];
    for (let j = 0; j < numPasses; j++)
    {
        let rpass = jobj.renderpass[j];

        // skip sound passes if in thumbnail mode
        if( this.mForceMuted && rpass.type === "sound" ) continue;

        let wpass = new EffectPass(this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                   this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode,
                                   this.mProgramDownscale, j, this);

        wpass.Create(rpass.type, this.mAudioContext);

        let numInputs = rpass.inputs.length;

        for (let i = 0; i < 4; i++)
        {
            wpass.NewTexture(this.mAudioContext, i, null, null, null);
        }
        for (let i = 0; i < numInputs; i++)
        {
            let lid  = rpass.inputs[i].channel;
            let styp = rpass.inputs[i].type;
            let sid  = rpass.inputs[i].id;
            let ssrc = rpass.inputs[i].filepath;
            let psrc = rpass.inputs[i].previewfilepath;
            let samp = rpass.inputs[i].sampler;

            wpass.NewTexture(this.mAudioContext, lid, { mType: styp, mID: sid, mSrc: ssrc, mSampler: samp, mPreviewSrc: psrc }, this.mBuffers, this.mCubeBuffers, this.mKeyboard);
        }

        for (let i = 0; i < 4; i++)
        {
            wpass.SetOutputs(i, null);
        }

        let numOutputs = rpass.outputs.length;
        for (let i = 0; i < numOutputs; i++)
        {
            let outputID = rpass.outputs[i].id;
            let outputCH = rpass.outputs[i].channel;
            wpass.SetOutputs(outputCH, outputID);
        }

        // create some hardcoded names. This should come from the DB
        let rpassName = "";
        if (rpass.type === "common" ) rpassName = "Common";
        if (rpass.type === "sound"  ) rpassName = "Sound";
        if (rpass.type === "image"  ) rpassName = "Image";
        if (rpass.type === "buffer") rpassName = "Buffer " + String.fromCharCode(65 + assetID_to_bufferID(wpass.mOutputs[0]));
        if (rpass.type === "cubemap") rpassName = "Cube A";// " + String.fromCharCode(65 + assetID_to_bufferID(this.mPasses[j].mOutputs[0]));
        wpass.SetName(rpassName);
        wpass.SetCode(rpass.code);

        this.mPasses.push(wpass);
    }
    return true;
}

Effect.prototype.CompileSome = function ( passes, preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    for (let j = 0; j < passes.length; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(passes[j], preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < me.mPasses.length; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.Compile = function (preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(j, preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < numPasses; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.GetCompilationTime = function( id )
{
    return this.mPasses[id].GetCompilationTime()/1000.0;
}
Effect.prototype.GetTotalCompilationTime = function()
{
    return this.mCompilationTime/1000.0;
}

Effect.prototype.DestroyPass = function( id )
{
   this.mPasses[id].Destroy( this.mAudioContext );
   this.mPasses.splice(id, 1);
}

Effect.prototype.AddPass = function( passType, passName, onResolve )
{
    let shaderStr = null;

    if( passType==="sound"   ) shaderStr = "vec2 mainSound( int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n}";
    if( passType==="buffer"  ) shaderStr = "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}";
    if( passType==="common"  ) shaderStr = "vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}";
    if( passType==="cubemap" ) shaderStr = "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rayDir;\n\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}";

    let id = this.GetNumPasses();
    this.mPasses[id] = new EffectPass( this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                       this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode, 
                                       this.mProgramDownscale, id, this );

    this.mPasses[id].Create( passType, this.mAudioContext );
    this.mPasses[id].SetName( passName );
    this.mPasses[id].SetCode( shaderStr );
    this.NewShader(id, false, function ()
    {
        onResolve();
    });

    return { mId : id, mShader : shaderStr };
}

// this should be removed once we have MultiPass 2.0 and passes render to arbitrary buffers
Effect.prototype.IsBufferPassUsed = function( bufferID )
{
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType !== "buffer" ) continue;
        if( this.mPasses[j].mOutputs[0] === bufferID_to_assetID(bufferID) ) return true;
    }
    return false;
}

Effect.prototype.Save = function()
{
    var result = {};

    result.ver = "0.1";

    result.renderpass = [];

    let numPasses = this.mPasses.length;
    for (let j=0; j<numPasses; j++ )
    {
        result.renderpass[j] = {};

        result.renderpass[j].outputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            let outputID = this.mPasses[j].mOutputs[i];
            if( outputID===null ) continue;
            result.renderpass[j].outputs.push( { channel: i, id: outputID } );
        }
        result.renderpass[j].inputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            if( this.mPasses[j].mInputs[i]===null ) continue;
            result.renderpass[j].inputs.push( {channel: i,
                                               type    : this.mPasses[j].mInputs[i].mInfo.mType,
                                               id      : this.mPasses[j].mInputs[i].mInfo.mID,
                                               filepath: this.mPasses[j].mInputs[i].mInfo.mSrc,
                                               sampler : this.mPasses[j].mInputs[i].mInfo.mSampler });
        }

        result.renderpass[j].code = this.mPasses[j].mSource;
        result.renderpass[j].name = this.mPasses[j].mName
        result.renderpass[j].description = "";
        result.renderpass[j].type = this.mPasses[j].mType;
    }

    result.flags = this.calcFlags();

    return result;
}

Effect.prototype.calcFlags = function ()
{
    let flagVR = false;
    let flagWebcam = false;
    let flagSoundInput = false;
    let flagSoundOutput = false;
    let flagKeyboard = false;
    let flagMultipass = false;
    let flagMusicStream = false;

    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        let pass = this.mPasses[j];

        if (pass.mType === "sound") flagSoundOutput = true;
        if (pass.mType === "buffer") flagMultipass = true;

        for (let i = 0; i < 4; i++)
        {
            if (pass.mInputs[i] === null) continue;

            if (pass.mInputs[i].mInfo.mType === "webcam") flagWebcam = true;
            else if (pass.mInputs[i].mInfo.mType === "keyboard") flagKeyboard = true;
            else if (pass.mInputs[i].mInfo.mType === "mic") flagSoundInput = true;
            else if (pass.mInputs[i].mInfo.mType === "musicstream") flagMusicStream = true;
        }

        let n1 = pass.mSource.indexOf("mainVR(");
        let n2 = pass.mSource.indexOf("mainVR (");
        if (n1 > 0 || n2 > 0) flagVR = true;
    }

    return {
        mFlagVR: flagVR,
        mFlagWebcam: flagWebcam,
        mFlagSoundInput: flagSoundInput,
        mFlagSoundOutput: flagSoundOutput,
        mFlagKeyboard: flagKeyboard,
        mFlagMultipass: flagMultipass,
        mFlagMusicStream: flagMusicStream
    };
}</script>
    <script>"use strict"

const kMaxCompileTime = 10.0;

function iReportCrash(shaderID)
{
    let req = new XMLHttpRequest();
    req.onload = function ()
    {
        let jsn = req.response;
        if (jsn === null) return;
        if (jsn.result === 0)
        {
            // yep
        }
    };
    req.open("POST", "/shadertoy", true);
    req.responseType = "json";
    req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    req.send( "s=" + shaderID + "&r=2" );
}
</script>
    <script>"use strict"

var gActive = -1;
var mShaders = [];
var gNumCanvases = 0;

function myrefresh( id, slot, img, forceFrame, gui, guiID, renderID, time )
{
    if( mShaders[id].mReady===false ) return;
    if( forceFrame )
    {
        if (mShaders[id].mScreenshot === false)
        {
            mShaders[id].gEffect.Paint(mShaders[id].mTime / 1000.0, 1.0 / 60.0, 60.0, 0, 0, 0, 0, false);
        }
    }
}

function startRendering()
{
    if( gActive<0 ) return;
    if( mShaders[gActive].mReady===false ) return;
    if( mShaders[gActive].mScreenshot===true ) return;

    let time = getRealTime();

    mShaders[gActive].mFPS.Count( time );
    mShaders[gActive].mTime = mShaders[gActive].mTime0 + (time - mShaders[gActive].mTo);
    let dtime = 1000.0/60.0;
    mShaders[gActive].gEffect.Paint( mShaders[gActive].mTime/1000.0, dtime/1000.0, mShaders[gActive].mFPS.GetFPS(), 0,0,0,0, false);

    requestAnimFrame( startRendering );
}

function iLoadAndCompile(jsn, i )
{
    var shaderObj = jsn[i];
    if (shaderObj === null) return;

    var resizeCB = function (xres, yres) { myrefresh(i, 0, null, true, false, 0, -1.0) };
    var crashCB = function () { alert('crash');/*iReportCrash(gShaderIDs[i])*/ };
    mShaders[i].gEffect = new Effect(null, null, mShaders[i].mPreview.mCanvas, myrefresh, i, true, true, resizeCB, crashCB);

    if (!mShaders[i].gEffect.Load(shaderObj)) return;

    mShaders[i].gEffect.Compile(false, function (worked)
    {
        if (worked === true)
        {
            previewShowRender(mShaders[i].mPreview);

            mShaders[i].mScreenshot = false;
            mShaders[i].mReady = true;
            mShaders[i].mTime = 10.0 * 1000.0;
            mShaders[i].mTime0 = 0.0;
            mShaders[i].mTo = 0.0;
            mShaders[i].mFPS = piCreateFPSCounter();
            mShaders[i].mPreview.mCanvas.addEventListener("mouseout", function (ev) { gActive = -1; }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseover", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.add('isVisible'); }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseout", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.remove('isVisible'); }, true);
            mShaders[i].mPreview.mCanvas.addEventListener("mouseover", function (ev)
            {
                let ele = piGetSourceElement(ev);
                if (ele.mId === undefined) return;

                gActive = ele.mId;
                if (!mShaders[gActive].mReady) return;
                let time = getRealTime();
                mShaders[gActive].mTo = time;
                mShaders[gActive].mTime0 = mShaders[gActive].mTime;
                mShaders[gActive].mFPS.Reset(time);

                startRendering();
            }, true);


            /*
            let compilationTime = mShaders[i].gEffect.GetTotalCompilationTime();
            if (compilationTime > kMaxCompileTime)
            {
                iReportCrash(mShaders[i].mShaderID);
            }*/

            myrefresh(i, null, null, true, false, 0, -1.0);
        }
        else
        {
            mShaders[i].mReady = false;
            previewShowError(mShaders[i].mPreview);
        }
    });
};


function iProcessShader( jsn, i )
{
    var shaderObj = jsn[i];
    if( shaderObj===null ) return;

    if ((shaderObj.info.usePreview === 0 && !gUseScreenshots) || (mShaders[i].mPreviewReady !== 1))
    {
        iLoadAndCompile(jsn, i);
    }
    else
    {
        mShaders[i].mScreenshot = true;
        if( shaderObj.info.usePreview === 1 )
            previewShowScreenshot(mShaders[i].mPreview, 1); // comp
        else if (gUseScreenshots)
            previewShowScreenshot(mShaders[i].mPreview, 2); // sett
    }

    if( i<(jsn.length-1) ) setTimeout( function(){iProcessShader(jsn,i+1);}, 10 );
}

function iInitUI(numCanvases, uiCallback, windowTitle)
{
    gNumCanvases = numCanvases;
    document.getElementById("mySearch").focus();

    //-----------------------------------------------------------------
    // window
    //-----------------------------------------------------------------
    if (windowTitle !== null) {
        document.title = windowTitle;
    }

    //-----------------------------------------------------------------
    // ui
    //-----------------------------------------------------------------
    var num = Math.min(gShaders.length, gNumCanvases);

    //var base = document.getElementsByClassName( "searchResult" );

    for (let i = 0; i < gNumCanvases; i++)
    {
        let pv = createPreview(i);

        if (i >= num) {
            previewHide(pv);
            continue;
        }

        let shaderID = gShaders[i].info.id;
        
        if (pv.mUI !== null && uiCallback !== null) {
            pv.mUI.addEventListener('click', function (ev) {
                uiCallback(shaderID);
                ev.preventDefault();
            }, false);
        }
        
        previewShowLoading(pv);
        
        mShaders[i] = {};
        mShaders[i].mShaderID = shaderID;
        mShaders[i].mPreview = pv;
        mShaders[i].mScreenshot = false;
        mShaders[i].mPreview.mLink.href = "/view/" + shaderID;
        mShaders[i].mPreviewReady = 0;
        mShaders[i].mReady = false;
        mShaders[i].gEffect = null;

        previewLoadScreenshot(mShaders[i].mPreview,
            function () { mShaders[i].mPreviewReady = 1; if (mShaders[i].mReady === false) previewShowScreenshot(mShaders[i].mPreview, 0); },
            function () { mShaders[i].mPreviewReady = 2; },
            shaderID);
    }

    if (num <= 0) {
        return;
    }
}

function iInitShaders(jsn)
{
    for (let i = 0; i < jsn.length; i++)
    {
        let shaderObj = jsn[i];
        if (shaderObj === null) continue;
        let inf = shaderObj.info;
        mShaders[i].mPreview.mTextA.textContent = inf.name;
        mShaders[i].mPreview.mTextB.innerHTML = "<a class='user' href='/user/" + htmlEntities(inf.username) + "'>" + htmlEntities(inf.username) + "</a>";
        mShaders[i].mPreview.mTextC.innerHTML = "<img src='/img/themes/" + gThemeName + "/views.png' class='viewsIcon'></img>" + inf.viewed + "    &nbsp;&nbsp;  <img src='/img/themes/" + gThemeName + "/likes.png' class='likesIcon'></img>" + inf.likes;
    }

    setTimeout(function () { iProcessShader(jsn, 0); }, 10);
}

function resultsInitStatic(numCanvases, uiCallback, windowTitle)
{
    iInitUI(numCanvases, uiCallback, windowTitle);

    iInitShaders(gShaders);
}

function resultsInit(numCanvases, uiCallback, windowTitle)
{	
    iInitUI(numCanvases, uiCallback, windowTitle);

    var num = Math.min(gShaderIDs.length, gNumCanvases);

    var mHttpReq = new XMLHttpRequest();

    mHttpReq.abort();

    var str = "{ \"shaders\" : [";
    for( let i=0; i<num; i++ )
    {
         str += "\"" + gShaderIDs[i] + "\"";
         if( i!==(num-1) ) str += ", ";
    }
    str += "] }";

    str = "s=" + encodeURIComponent( str ) + "&nt=0&nl=0&np=0";

    mHttpReq.open( "POST", "/shadertoy", true );
    mHttpReq.responseType = "json";
    mHttpReq.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    mHttpReq.onload = function ()
    {
        let jsn = this.response;
        if( jsn===null )
        {
            console.log( "Could not load shaders" );
            return;
        }

        iInitShaders(jsn);
    }
    mHttpReq.send( str );
}</script>
    <style>
    .shaderPreview
    {
    display: block;
    background-color: #000000;
    background-image: url("/img/loading.gif");
    background-repeat: no-repeat;
    background-position: center;
    padding: 0px;
    margin: 0px;
    border: 0px solid #000000;
    border-radius: 8px;
    width:100%;
    height:100%;
    position: absolute;
    overflow:hidden;
    }

    .previewInfo
    {
    width: 100%;
    left: 0px;
    top: 2px;
    position: relative;
    visibility: hidden;
    }

    .previewCanvas
    {
    left: 0px;
    top: 0px;
    padding: 0px;
    margin: 0px;
    position: absolute;
    cursor: pointer;
    width:100%;
    height:100%;
    border-radius: 8px;
    border: 0px solid #000000;
    backgroundColor: transparent;
visibility: hidden;
opacity:0;
transition: opacity 1.0s ease;
    }

    .previewText
    {
        text-overflow: ellipsis;
    white-space: nowrap;
    padding-right: 1px;
    }

    .previewTextUser
    {
    text-overflow: ellipsis;
    white-space: nowrap;
    padding-left: 3px;
    }

    .previewStats
    {
    padding-right: 1px;
    right: 0px;
    top: 0px;
    position: absolute;
    }

    .previewErrorContainer
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    visibility:hidden;
    }

    .previewErrorMessage
    {
    top:50%;
    position:absolute;
    width:100%;
    text-align:center;
    padding:0;
    margin:auto;
    color:#ff0000;
    font-size:2em;
    font-style:italic;
    }

    .previewNoGLContainter
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    position:absolute;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    pointer-events:none;
    visibility:hidden;
    font-size:2em;
    }

    .previewNoGLMessage
    {
    width:86%;
    height:90%;
    padding-left:7%;
    padding-right:7%;
    padding-top:10%;
    padding-bottom:0px;
    color:#ff0000;
    position:absolute;
    visibility:hidden;
    }

    .previewThumbnailContainer
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    visibility:hidden;
    border-radius:8px;
    border:0px solid #000000;
    }

    .previewThumbnailImage
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    border-radius:8px;
    border:0px solid #000000;
opacity: 0.0;
transition: opacity 1.0s ease;
    }

    .previewThumbnailIcon
    {
    width:64px;
    height:32px;
    left:0px;
    top:0px;
    padding:0px;
    padding-top:12px;
    margin:0px;
    position:absolute;
    color:#ffffff;
    background-color:#ff8020;
    font-weight:bold;
    border-radius:0px 0px 8px 0px;
    text-align:center;
    //visibility:hidden;
    }


    .previewUIContainter
    {
    display: block;
    right:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    //cursor:pointer;
    //pointer-events:none;
    //visibility:hidden;
    }
</style>

<script>
    function previewHide(me)
    {
    me.mBase.style.visibility = "hidden";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";
    }

    function previewShowRender(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "visible";
me.mCanvas.style.opacity = 1.0;
    me.mCanvas.style.borderRadius ="8px;";
//  me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    }

    function previewShowScreenshot(me, message)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "visible";
me.mThumbnailImg.style.opacity = 1.0;
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    me.mThumbnailWar1.style.visibility = (message===1)?"visible":"hidden";
    me.mThumbnailWar2.style.visibility = (message===2)?"visible":"hidden";
    }

    function previewShowLoading(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";

    me.mLink.style.visibility = "visible";
    me.mBase.style.backgroundColor = "#ff0000;"
    me.mCont.style.visibility = "visible";
    }

    function previewShowNoWebGL(me, shaderID)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "visible";
    me.mError.style.visibility = "visible";
    me.mThumbnailImgNoWebGL.onerror = function(ev) 
                                      { 
                                            me.mThumbnailImgNoWebGL.style.visibility="hidden"; 
                                            me.mMessageNoWebGL.style.visibility="visible"; 
                                      };
    me.mThumbnailImgNoWebGL.src = "/media/shaders/" + shaderID + ".jpg";
    }

    function previewShowError(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "visible";
    me.mCont.style.visibility = "visible";
    }

    function previewLoadScreenshot( me, cbSuccess, cbError, shaderID )
    {
    var url = "/media/shaders/" + shaderID + ".jpg";
    me.mThumbnailImg.onload = cbSuccess;
    me.mThumbnailImg.onerror = function(ev) { cbError(); };
    me.mThumbnailImg.src = url;
    }
        
    function createPreview(id)
    {
        var bar = document.getElementById( "Preview_"+id+"_Canvas" );
        bar.width = bar.offsetWidth;
        bar.height = bar.offsetHeight;
        bar.mId = id;

        return { mBase: document.getElementById( "Preview_"+id+"_Container" ),
        mLink: document.getElementById( "Preview_"+id+"_Link" ),
        mCanvas: bar,
        mCont: document.getElementById( "Preview_"+id+"_Info" ),
        mTextA: document.getElementById( "Preview_"+id+"_Text" ),
        mTextB: document.getElementById( "Preview_"+id+"_TextUser" ),
        mTextC: document.getElementById( "Preview_"+id+"_Stats" ),
        mNoWebGL: document.getElementById( "Preview_"+id+"_NoWebGL" ),
        mError: document.getElementById( "Preview_"+id+"_Error" ),
        mCanvas2D: document.getElementById( "Preview_"+id+"_Thumnail" ),
        mThumbnailImg: document.getElementById( "Preview_"+id+"_ThumnailImage" ),
        mThumbnailWar1: document.getElementById( "Preview_"+id+"_ThumnailWarning1" ),
        mThumbnailWar2: document.getElementById( "Preview_"+id+"_ThumnailWarning2" ),
        mThumbnailImgNoWebGL: document.getElementById( "Preview_"+id+"_ThumnailImageNoWebGL" ),
        mMessageNoWebGL: document.getElementById( "Preview_"+id+"_MessageNoWebGL"),
        mUI: document.getElementById( "Preview_"+id+"_UI" )
        };
    }
</script>

    <style>

    div#shaderGrid
    {
        width:100%;
        padding:0px;
        margin:0px;
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        grid-template-rows: repeat(3, 1fr);
        grid-column-gap: 64px;
        grid-row-gap: 24px;
    }
    .searchResult
    {
        margin: 0px;
        padding: 0px;
        width: 100%;
    }
    .searchResultContainer
    {
        width: 100%;
        padding-bottom:56.25%;
        height: 0;
        position: relative;
    }
    .navigation
    {
        display:flex;
        align-items:center;
    }
    div#navBottom
    {
        display:none;
        justify-content:center;
    }
    a.pageButtons, .pageButtonsCurrent
    {
        border-style: solid;
        border-width: 1px;
        border-color: #808080;
        text-align: center;
        vertical-align: middle;
        margin-left: 12px;
        display: inline-block;
        border-radius: 4px;
		font-weight:bold;
        cursor: pointer;
        padding-bottom:5px;
        padding-top:4px;
        padding-left: 8px;
        padding-right: 8px;
        margin:8px;
    }
    a.pageButtons
    {
        text-decoration: none;
        -moz-transition:    background-color 0.15s linear, color 0.15s linear;
        -webkit-transition: background-color 0.15s linear, color 0.15s linear;
        transition:         background-color 0.15s linear, color 0.15s linear;
    }
    a.pageButtons:hover
    {
      background-color:#808080;
      color : #ff8020;
    }
    .pageButtonsCurrent
    {
        background-color: #808080;
        color:#000000;
    }
    div#controls
    {
        width:100%;
        padding-top:16px;
        padding-bottom:16px;
        display:flex;
        justify-content:space-between; 
        flex-wrap:wrap;
    }
    div#controls > div
    {
        display:inline-flex;
    }
    .controlOptions
    {
        display:inline-block;
    }

    /* ----------------------- media resolutions ------------------------ */

    @media screen and (max-width:799px) 
    {
        div#shaderGrid  { grid-template-columns: 1fr; grid-template-rows: repeat(12, 1fr); grid-column-gap: 0px; grid-row-gap: 16px; }
        div#controls
        {
            width:100%;
            display:flex;
            justify-content:flex-start; 
            flex-wrap:wrap;
        }
        div#controls > div
        {
            display:inline-flex;
            width:100%;
            margin-left: 0px;
            margin-right: 0px;
            padding-bottom:16px;
        }
        div#navBottom
        {
            display: flex;
        }
    }
    
    </style>
    <script>
    var gShaders=[{"ver":"0.1","info":{"id":"3s3GDn","date":"1568150258","viewed":9905,"name":"GLOW TUTORIAL","username":"alro","description":"A simple glow effect and how to control it.\n\nSee [url]https:\/\/www.desmos.com\/calculator\/eecd6kmwy9[\/url] for an illustration as mentioned in the code\n\nSee also P_Malin's comment below and [url]https:\/\/www.desmos.com\/calculator\/f14x5a9lsb[\/url]","likes":81,"published":1,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ How to achieve and control a simple distance glow effect based on several Shadertoy examples\n\/\/ For 3D see https:\/\/www.shadertoy.com\/view\/7stGWj\n\/\/ Things to try:\n\/\/  * Make the radius and intensity pulse in time or to input\n\/\/\t* Time varying colour\n\/\/  * Animate several points and add the glow values for each to create metaballs\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \/\/***********    Basic setup    **********\n    \n    \/\/ Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord\/iResolution.xy;\n\t\/\/ Position of fragment relative to centre of screen\n    vec2 pos = 0.5 - uv;\n    \/\/ Adjust y by aspect for uniform transforms\n    pos.y \/= iResolution.x\/iResolution.y;\n    \n    \/\/**********         Glow        **********\n    \n    \/\/ Equation 1\/x gives a hyperbola which is a nice shape to use for drawing glow as \n    \/\/ it is intense near 0 followed by a rapid fall off and an eventual slow fade\n    float dist = 1.0\/length(pos);\n    \n    \/\/**********        Radius       **********\n    \n    \/\/ Dampen the glow to control the radius\n    dist *= 0.1;\n    \n    \/\/**********       Intensity     **********\n    \n    \/\/ Raising the result to a power allows us to change the glow fade behaviour\n    \/\/ See https:\/\/www.desmos.com\/calculator\/eecd6kmwy9 for an illustration\n    \/\/ (Move the slider of m to see different fade rates)\n    dist = pow(dist, 0.8);\n    \n    \/\/ Knowing the distance from a fragment to the source of the glow, the above can be \n    \/\/ written compactly as: \n    \/\/\tfloat getGlow(float dist, float radius, float intensity){\n    \/\/\t\treturn pow(radius\/dist, intensity);\n\t\/\/\t}\n    \/\/ The returned value can then be multiplied with a colour to get the final result\n       \n    \/\/ Add colour\n    vec3 col = dist * vec3(1.0, 0.5, 0.25);\n\t\n    \/\/ Tonemapping. See comment by P_Malin\n    col = 1.0 - exp( -col );\n    \n    \/\/ Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\/*\n    Copyright (c) 2019 al-ro\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.\n*\/","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"MlscDj","date":"1507894704","viewed":9880,"name":"Neon World","username":"zguerrero","description":"experimenting witch ray marching and distance field","likes":219,"published":1,"flags":32,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy\/iResolution.xy;\n        \n    float b = step(fract(uv.y * 50.0 + iTime), 0.5);\n\tvec4 tex = texture(iChannel0, uv);\n    vec4 tex2 = texture(iChannel0, uv + vec2((b - 0.5)*0.005, 0.0));\n    \n    vec2 vign = smoothstep(vec2(0.5, 1.5), vec2(1.0, 0.98 + b*0.02), vec2(length(uv - 0.5) * 2.0)); \n       \n    vec4 grain = texture(iChannel1, fragCoord.xy\/256.0 + vec2(0.0, iTime*10.0));\n    vec4 res = mix(tex, vec4(tex.x, tex.y, tex2.z, tex.w), vign.x);\n    vec4 col = res * vign.y * (0.85 + grain*0.15);\n\tfragColor = pow(col*1.75, vec4(1.25));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float epsilon = 0.02;\nconst float pi = 3.14159265359;\nconst float speed = 3.0;\nconst vec3 wallsColor = vec3(0.05, 0.025, 0.025);\nconst vec3 lightColor = vec3(0.3, 0.6, 1.0);\nconst vec3 lightColor2 = vec3(0.5, 0.35, 0.35);\nconst vec3 fogColor = vec3(0.05, 0.05, 0.2);\nconst float curvAmout = 0.075;\nconst float reflAmout = 0.8;\n\n\/\/Distance Field functions by iq :\n\/\/https:\/\/iquilezles.org\/articles\/distfunctions\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(c.xy - p.xz) - c.z;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec2 linearStep2(vec2 mi, vec2 ma, vec2 v)\n{\n    return clamp((v - mi) \/ (ma - mi), 0.0 ,1.0);\n}\n\nfloat tunnel( vec3 p, vec3 c )\n{\n  return -length(c.xy - p.xz) + c.z;\n}\n\nvec4 distfunc(vec3 pos)\n{\n    vec3 repPos = opRep(pos, vec3(4.0, 1.0, 4.0));\n    vec2 sinPos = sin((pos.z * pi \/ 8.0) + vec2(0.0, pi)) * 1.75;\n    vec3 repPosSin = opRep(pos.xxz + vec3(sinPos.x, sinPos.y, 0.0), vec3(4.0, 4.0, 0.0));\n    \n    float cylinders = sdCylinder(vec3(repPos.x, pos.y, repPos.z), vec3(0.0, 0.0, 0.5));\n    float s = sin(iTime*3.0 + floor(pos.z*0.25));\n    float cutCylinders1 = sdBox(vec3(pos.x, pos.y, repPos.z), vec3(100.0, clamp(s, 0.025, 0.75), 1.0));\n    float cutCylinders2 = sdBox(vec3(repPos.x, pos.y, repPos.z), vec3(0.035, 100.0, 10.0));\n    float cuttedCylinders = max(-cutCylinders2, max(-cutCylinders1, cylinders));\n    \n    float innerCylinders = sdCylinder(vec3(repPos.x, pos.y, repPos.z), vec3(0.0, 0.0, 0.15));\n    float tubes1 = sdCylinder(vec3(repPosSin.x, 0.0, pos.y - 0.85), vec3(0.0, 0.0, 0.025));\n    float tubes2 = sdCylinder(vec3(repPosSin.y, 0.0, pos.y + 0.85), vec3(0.0, 0.0, 0.025));\n    float tubes = min(tubes1, tubes2);  \n    float lightsGeom = min(tubes, innerCylinders);\n    \n    float resultCylinders = min(cuttedCylinders, lightsGeom);\n    \n    float spheres = sdSphere(vec3(repPos.x, pos.y, repPos.z), (s*0.5+0.5)*1.5);\n    float light = min(tubes, spheres);\n    \n    vec2 planeMod = abs(fract(pos.xx * vec2(0.25, 4.0) + 0.5) * 4.0 - 2.0) - 1.0;\n    float planeMod2 = clamp(planeMod.y, -0.02, 0.02) * min(0.0, planeMod.x);\n    float cylindersCutPlane = sdCylinder(vec3(repPos.x, pos.y, repPos.z), vec3(0.0, 0.0, 0.6));\n    float spheresCutPlane = sdSphere(vec3(repPos.x, pos.y, repPos.z), 1.3);\n    \n    float plane = 1.0 - abs(pos.y + clamp(planeMod.x, -0.04, 0.04) + planeMod2);\n    float t = tunnel(pos.xzy * vec3(1.0, 1.0, 3.0), vec3(0.0, 0.0, 8.5));\n    float cutTunnel = sdBox(vec3(pos.x, pos.y, repPos.z), vec3(100.0, 100.0, 0.1));\n    plane = min(max(-cutTunnel, t), max(-spheresCutPlane, max(-cylindersCutPlane, plane)));\n    \n    float dist = min(resultCylinders, plane);\n    float occ = min(cuttedCylinders, plane);\n    \n    float id = 0.0;\n    \n    if(lightsGeom < epsilon)\n    {\n       id = 1.0; \n    }\n    \n\treturn vec4(dist, id, light, occ);\n}\n\nvec3 rayMarch(vec3 rayDir, vec3 cameraOrigin)\n{\n    const int maxItter = 100;\n\tconst float maxDist = 30.0;\n    \n    float totalDist = 0.0;\n\tvec3 pos = cameraOrigin;\n\tvec4 dist = vec4(epsilon);\n    \n    for(int i = 0; i < maxItter; i++)\n\t{\n\t\tdist = distfunc(pos);\n\t\ttotalDist += dist.x;\n\t\tpos += dist.x * rayDir;\n        \n        if(dist.x < epsilon || totalDist > maxDist)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n    \n    return vec3(dist.x, totalDist, dist.y);\n}\n\nvec3 rayMarchReflection(vec3 rayDir, vec3 cameraOrigin)\n{\n    const int maxItter = 30;\n\tconst float maxDist = 20.0;\n    \n    float totalDist = 0.0;\n\tvec3 pos = cameraOrigin;\n\tvec4 dist = vec4(epsilon);\n\n    for(int i = 0; i < maxItter; i++)\n\t{\n\t\tdist = distfunc(pos);\n\t\ttotalDist += dist.x;\n\t\tpos += dist.x * rayDir;\n        \n        if(dist.x < epsilon || totalDist > maxDist)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n    \n    return vec3(dist.x, totalDist, dist.y);\n}\n\n\/\/Inpired From iq's ao :\n\/\/https:\/\/www.shadertoy.com\/view\/Xds3zN\nvec2 AOandFakeAreaLights(vec3 pos, vec3 n)\n{\n\tvec4 res = vec4(0.0);\n    \n\tfor( int i=0; i<3; i++ )\n\t{\n\t\tvec3 aopos = pos + n*0.3*float(i);\n\t\tvec4 d = distfunc(aopos);\n\t\tres += d;\n\t}\n    \n    float ao = clamp(res.w, 0.0, 1.0);\n    float light = 1.0 - clamp(res.z*0.3, 0.0, 1.0);\n    \n\treturn vec2(ao, light * ao);   \n}\n\n\/\/Camera Function by iq :\n\/\/https:\/\/www.shadertoy.com\/view\/Xds3zN\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\/\/Normal and Curvature Function by Nimitz;\n\/\/https:\/\/www.shadertoy.com\/view\/Xts3WM\nvec4 norcurv(in vec3 p)\n{\n    vec2 e = vec2(-epsilon, epsilon);   \n    float t1 = distfunc(p + e.yxx).x, t2 = distfunc(p + e.xxy).x;\n    float t3 = distfunc(p + e.xyx).x, t4 = distfunc(p + e.yyy).x;\n\n    float curv = .25\/e.y*(t1 + t2 + t3 + t4 - 4.0 * distfunc(p).x);\n    return vec4(normalize(e.yxx*t1 + e.xxy*t2 + e.xyx*t3 + e.yyy*t4), curv);\n}\n\nvec4 lighting(vec3 n, vec3 rayDir, vec3 reflectDir, vec3 pos)\n{\n    vec3 light = vec3(0.0, 0.0, 2.0 + iTime * speed);\n    vec3 lightVec = light - pos;\n\tvec3 lightDir = normalize(lightVec);\n    float atten = clamp(1.0 - length(lightVec)*0.1, 0.0, 1.0);\n    float spec = pow(max(0.0, dot(reflectDir, lightDir)), 10.0);\n    float rim = (1.0 - max(0.0, dot(-n, rayDir)));\n\n    return vec4(spec*atten*lightColor2 + rim*0.2, rim); \n}\n\nvec3 color(float id, vec3 pos)\n{\n    vec2 fp = vec2(1.0) - linearStep2(vec2(0.0), vec2(0.01), abs(fract(pos.xz * vec2(0.25, 1.0) + vec2(0.0, 0.5)) - 0.5));\n    float s = fp.y + fp.x;\n    return mix(wallsColor + s*lightColor*0.5, lightColor, id);\n}\n\nvec4 finalColor(vec3 rayDir, vec3 reflectDir, vec3 pos, vec3 normal, float ao, float id)\n{\n\tvec4 l = lighting(normal, rayDir, reflectDir, pos);\n\tvec3 col = color(id, pos);\n    float ao1 = 0.5 * ao + 0.5;\n    float ao2 = 0.25 * ao + 0.75;\n    vec3 res = (mix(col * ao1, col, id) + l.xyz) * ao2;\n\treturn vec4(res, l.w); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy\/iResolution.xy;\n    \n    float move = iTime * speed;\n    vec2 sinMove = sin((move * pi) \/ 16.0 + vec2(1.0, -1.0)) * vec2(5.0, 0.35);\n    float camX = sinMove.x;\n    float camY = 0.0;\n    float camZ = -5.0 + move;                 \n    vec3 cameraOrigin = vec3(camX, camY, camZ);\n    \n\tvec3 cameraTarget = vec3(0.0, 0.0, cameraOrigin.z + 10.0);\n    \n\tvec2 screenPos = uv * 2.0 - 1.0;\n    \n\tscreenPos.x *= iResolution.x\/iResolution.y;\n    \n    mat3 cam = setCamera(cameraOrigin, cameraTarget, sinMove.y);\n    \n    vec3 rayDir = cam*normalize(vec3(screenPos.xy,1.0));\n    vec3 dist = rayMarch(rayDir, cameraOrigin);\n    \n    vec3 res;\n    vec2 fog;\n\n\tif(dist.x < epsilon)\n    {\n        vec3 pos = cameraOrigin + dist.y*rayDir;\n        vec4 n = norcurv(pos);\n        vec2 ao = AOandFakeAreaLights(pos, n.xyz);\n        vec3 r = reflect(rayDir, n.xyz);\n        vec3 rpos = pos + n.xyz*0.02;\n        vec3 reflectDist = rayMarchReflection(r, rpos);\n        fog = clamp(1.0 \/ exp(vec2(dist.y, reflectDist.y)*vec2(0.15, 0.2)), 0.0, 1.0);\n        vec4 direct = finalColor(rayDir, r, pos, n.xyz, ao.x, dist.z) + n.w*curvAmout;\n        \n        vec4 reflN;\n        vec2 reflAO;\n        vec3 reflFinal;\n        \n        if(reflectDist.x < epsilon)\n    \t{\n        \tvec3 reflPos = rpos + reflectDist.y*r;\n        \treflN = norcurv(reflPos);\n            reflAO = AOandFakeAreaLights(reflPos, reflN.xyz);\n            vec3 rr = reflect(r, reflN.xyz);\n            vec4 refl = finalColor(r, rr, reflPos, reflN.xyz, reflAO.x, reflectDist.z);\n            vec3 reflAreaLights = reflAO.y * lightColor * 0.5;\n            reflFinal = (refl.xyz + reflN.w*curvAmout + reflAreaLights) * fog.y * reflAmout * direct.w;\n        }\n        else   \n        {\n            reflFinal = vec3(0.0, 0.0, 0.0);\n        }\n        \n        vec3 areaLightsColor = ao.y * lightColor * 0.5;\n        \n        res = mix(fogColor, direct.xyz + reflFinal + areaLightsColor, fog.x);\n    }\n    else\n    {\n        res = fogColor; \n        fog = vec2(0.0);\n    }\n    \n\tfragColor = vec4(res, (dist.z) * fog);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const float radialBlurInstensity = 0.01;\nconst float speed = 3.0;\nconst float pi = 3.14159265359;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float s = sin(iTime*speed * pi \/ 16.0 - 1.0);\n    vec2 radialBlurCenter = vec2((s * 0.5 + 0.5) * 0.5 + 0.25, abs(s)* 0.2 + 0.35);\n    \n\tvec2 uv = fragCoord.xy\/iResolution.xy;\n    vec2 uvCenter = uv - radialBlurCenter;\n    float c = length(uv - radialBlurCenter);\n    vec4 texBlurred = texture(iChannel0, uv);\n    \n    float itter = 0.0;\n    \n\tfor(float itter1 = 0.0; itter1 < 5.0; itter1++)\n    {\n        itter = itter1;\n        texBlurred += texture(iChannel0, uvCenter * (1.0 - radialBlurInstensity * \n        itter1 * c) + radialBlurCenter);\n    }\n    \n    vec4 res = texBlurred \/ itter;\n        \n    vec4 prev = texture(iChannel1, uv);\n\n    float motionBlur = mix(res.w, prev.w, 0.75);\n    vec3 light = motionBlur * vec3(0.25, 0.5, 0.75);\n\tfragColor = vec4(res.xyz + light*2.0, motionBlur);\n}","name":"Buf B","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"4sSXWt","date":"1417027955","viewed":9872,"name":"Direct Light using MIS","username":"koiava","description":"Left - BSDF sampling\nRight - Light sampling\nCenter - Combination those strategies using [b][url=https:\/\/graphics.stanford.edu\/courses\/cs348b-03\/papers\/veach-chapter9.pdf]MIS[\/url][\/b](E. Veach, and L. Guibas)\n","likes":115,"published":3,"flags":0,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/Implementation of Multiple Importance Sampling technique(E.Veach 1995)\n\/\/example shows MIS for direct light calculation\n\/\/Idea behind technique is that every monte-carlo sampling technique has \n\/\/variance and this variance comes from low probability of success.\n\/\/So if you have 2 or more unbiased monte-carlo sampling techniques \n\/\/which gives you different response on same situation you can predict \n\/\/which of those responses contains more variance and weight them\n\/\/correspondingly to decrease overal variance and stay unbiased.\n#define PIXEL_SAMPLES 2\n#define LIGHT_SAMPLES 2\n#define BSDF_SAMPLES 2\n#define FRAME_TIME 0.05\t\/\/for motion blur\n#define IMPORTANCE_SAMPLE_LIGHTS\n#define SHADOWS\n\n\/\/light sampling technique *******************\n#define IMPORTANCE_SAMPLE_LIGHT_SOURCE\n\/\/#define SAMPLE_LIGHT_AREA\n#define SAMPLE_LIGHT_SOLIDANGLE\n\/\/********************************************\n\n#define SHOW_PLANES\n#define SHOW_TEXT\n\n#define GAMMA 2.2\nconst vec3 backgroundColor = vec3( 0.2 );\n\n\/\/used macros and constants\n#define HALF_PI \t\t\t1.5707963\n#define PI \t\t\t\t\t3.1415926\n#define TWO_PI \t\t\t\t6.2831852\n#define FOUR_PI \t\t\t12.566370\n#define INV_PI \t\t\t\t0.3183099\n#define INV_TWO_PI \t\t\t0.1591549\n#define INV_FOUR_PI \t\t0.0795775\n#define EPSILON \t\t\t0.0001\n#define IN_RANGE(x,a,b)\t\t(((x) > (a)) && ((x) < (b)))\n#define EQUAL_FLT(a,b,eps)\t(abs(a-(b))<eps)\n#define IS_ZERO(a) \t\t\tEQUAL_FLT(a,0.0,EPSILON)\n\/\/********************************************\n\n#ifdef SHOW_TEXT\nstruct Disk {\n    vec2 position_;\n    float radius_innder_;\n    float radius_outter_;\n    float angle_begin_;\n    float angle_end_;\n};\n    \nstruct Box {\n    vec2 position_;\n    vec2 dimensions_;\t\/\/positive\n};\n\nbool pointInBox( vec2 p, Box box ) {\n    if( IN_RANGE( p.x, box.position_.x, box.position_.x + box.dimensions_.x ) &&\n      \tIN_RANGE( p.y, box.position_.y, box.position_.y + box.dimensions_.y ) )\n        return true;\n    \n    return false;\n}\n\nbool pointInDisk( vec2 p, Disk disk ) {\n    Box bbox = Box(disk.position_ - vec2(disk.radius_outter_)*1.01, vec2(disk.radius_outter_)*2.01 );\n    \n    \/\/primitive level culling\n    if( !pointInBox( p, bbox ) )\n        return false;\n    \n    vec2 v = p - disk.position_;\n    \n    float rho;\n    rho = sqrt( v.x*v.x + v.y*v.y );\n    \n    if( !IN_RANGE( rho, disk.radius_innder_, disk.radius_outter_ ) )\n        return false;\n    \n\tfloat theta = atan( v.y, v.x );\n    theta += PI;\n    \n    if( !IN_RANGE( theta, disk.angle_begin_, disk.angle_end_ ) )\n        return false;\n    \n    return true;\n}\n\nvec2 fontDim = vec2(5.0,5.0);\n\nbool is_point_on_B( vec2 p ) {\n    if( pointInBox( p, Box( vec2( 0.0, 0.0 ), vec2( 1.0, 5.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 1.0, 0.0 ), vec2( 0.5, 1.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 1.0, 2.0 ), vec2( 0.5, 1.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 1.0, 4.0 ), vec2( 0.5, 1.0 ) ) ) \t\t\t\t\t||\n       \tpointInDisk( p, Disk( vec2( 1.5, 1.5 ), 0.5, 1.5, HALF_PI, PI+HALF_PI ) ) \t||\n      \tpointInDisk( p, Disk( vec2( 1.5, 3.5 ), 0.5, 1.5, HALF_PI, PI+HALF_PI ) ) )\n        return true;\n    return false;\n}\n\nbool is_point_on_R( vec2 p ) {\n    if( pointInBox( p, Box( vec2( 0.0, 0.0 ), vec2( 1.0, 5.0 ) ) ) \t\t\t\t||\n       \tpointInBox( p, Box( vec2( 1.0, 2.0 ), vec2( 0.5, 1.0 ) ) ) \t\t\t\t||\n       \tpointInBox( p, Box( vec2( 1.0, 4.0 ), vec2( 0.5, 1.0 ) ) ) \t\t\t\t||\n       \tpointInBox( p, Box( vec2( 2.0, 0.0 ), vec2( 1.0, 1.5 ) ) ) \t\t\t\t||\n       \tpointInDisk( p, Disk( vec2( 1.5, 1.5 ), 0.5, 1.5, PI, PI+HALF_PI ) ) \t||\n      \tpointInDisk( p, Disk( vec2( 1.5, 3.5 ), 0.5, 1.5, HALF_PI, PI+HALF_PI ) ) )\n        return true;\n    return false;\n}\n\nbool is_point_on_D( vec2 p ) {\n    if( pointInBox( p, Box( vec2( 0.0, 0.0 ), vec2( 1.0, 5.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 1.0, 0.0 ), vec2( 0.5, 1.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 2.0, 1.5 ), vec2( 1.0, 2.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 1.0, 4.0 ), vec2( 0.5, 1.0 ) ) ) \t\t\t\t\t||\n       \tpointInDisk( p, Disk( vec2( 1.5, 1.5 ), 0.5, 1.5, HALF_PI, PI ) ) \t||\n      \tpointInDisk( p, Disk( vec2( 1.5, 3.5 ), 0.5, 1.5, PI, PI+HALF_PI ) ) )\n        return true;\n    return false;\n}\n\nbool is_point_on_F( vec2 p ) {\n    if( pointInBox( p, Box( vec2( 0.0, 0.0 ), vec2( 1.0, 5.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 1.0, 2.0 ), vec2( 1.5, 1.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 1.0, 4.0 ), vec2( 2.0, 1.0 ) ) ) )\n        return true;\n    return false;\n}\n\nbool is_point_on_I( vec2 p ) {\n    if( pointInBox( p, Box( vec2( 0.0, 0.0 ), vec2( 1.0, 5.0 ) ) ) )\n        return true;\n    return false;\n}\n\nbool is_point_on_M( vec2 p ) {\n    if( pointInBox( p, Box( vec2( 0.0, 0.0 ), vec2( 1.0, 5.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 4.0, 0.0 ), vec2( 1.0, 5.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 2.0, 2.0 ), vec2( 1.0, 3.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 1.0, 4.0 ), vec2( 3.0, 1.0 ) ) ) )\n        return true;\n    return false;\n}\n\nbool is_point_on_S( vec2 p ) {\n    if( pointInBox( p, Box( vec2( 0.0, 0.0 ), vec2( 1.5, 1.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 1.5, 4.0 ), vec2( 1.5, 1.0 ) ) ) \t\t\t\t\t||\n       \tpointInDisk( p, Disk( vec2( 1.5, 1.5 ), 0.5, 1.5, HALF_PI, HALF_PI+PI ) ) \t||\n       \tpointInDisk( p, Disk( vec2( 1.5, 3.5 ), 0.5, 1.5, HALF_PI+PI, TWO_PI ) ) \t||\n      \tpointInDisk( p, Disk( vec2( 1.5, 3.5 ), 0.5, 1.5, 0.0, HALF_PI ) ) )\n        return true;\n    return false;\n}\n\nbool is_point_on_L( vec2 p ) {\n    if( pointInBox( p, Box( vec2( 0.0, 0.0 ), vec2( 1.0, 5.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 0.0, 0.0 ), vec2( 3.0, 1.0 ) ) ) )\n        return true;\n    return false;\n}\n\nbool is_point_on_G( vec2 p ) {\n    if( pointInBox( p, Box( vec2( 0.0, 1.5 ), vec2( 1.0, 2.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 2.0, 3.0 ), vec2( 1.0, 0.5 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 1.5, 0.0 ), vec2( 1.5, 2.0 ) ) ) \t\t\t\t\t||\n       \tpointInDisk( p, Disk( vec2( 1.5, 1.5 ), 0.5, 1.5, 0.0, HALF_PI ) ) \t||\n      \tpointInDisk( p, Disk( vec2( 1.5, 3.5 ), 0.5, 1.5, PI, TWO_PI ) ) )\n        return true;\n    return false;\n}\n\nbool is_point_on_H( vec2 p ) {\n    if( pointInBox( p, Box( vec2( 0.0, 0.0 ), vec2( 1.0, 5.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 2.0, 0.0 ), vec2( 1.0, 5.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 1.0, 2.0 ), vec2( 1.0, 1.0 ) ) ) )\n        return true;\n    return false;\n}\n\nbool is_point_on_T( vec2 p ) {\n    if( pointInBox( p, Box( vec2( 1.0, 0.0 ), vec2( 1.0, 5.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 0.0, 4.0 ), vec2( 3.0, 1.0 ) ) ) )\n        return true;\n    return false;\n}\n\nbool is_point_on_BRDF( vec2 p ) {\n    \/\/Object level culling\n    Box bbox = Box( vec2(0.0), vec2(16.0,5.0) );\n    if( !pointInBox( p, bbox ) )\n        return false;\n    \n    vec2 offsetVec = vec2( 0.0 );\n    \n    if( is_point_on_B( p ) ||\n      \tis_point_on_R( p - (offsetVec += vec2(4.0,0.0)) ) ||\n      \tis_point_on_D( p - (offsetVec += vec2(4.0,0.0)) ) ||\n      \tis_point_on_F( p - (offsetVec += vec2(4.0,0.0)) ) ) {\n        return true;\n    }\n    \n    return false;\n}\n\nbool is_point_on_MIS( vec2 p ) {\n    \/\/Object level culling\n    Box bbox = Box( vec2(0.0), vec2(12.0,5.0) );\n    if( !pointInBox( p, bbox ) )\n        return false;\n    \n    vec2 v = vec2(fontDim.x + 1.0,0.0);\n    vec2 offsetVec = vec2( 0.0 );\n    \n    if( is_point_on_M( p ) ||\n      \tis_point_on_I( p - (offsetVec += vec2(6.0,0.0)) ) ||\n      \tis_point_on_S( p - (offsetVec += vec2(2.0,0.0)) )) {\n        return true;\n    }\n    \n    return false;\n}\n\nbool is_point_on_LIGHT( vec2 p ) {\n    \/\/Object level culling\n    Box bbox = Box( vec2(0.0), vec2(20.0,5.0) );\n    if( !pointInBox( p, bbox ) )\n        return false;\n    \n    vec2 offsetVec = vec2( 0.0 );\n    \n    if( is_point_on_L( p ) ||\n      \tis_point_on_I( p - (offsetVec += vec2(4.0,0.0)) ) ||\n      \tis_point_on_G( p - (offsetVec += vec2(2.0,0.0)) ) ||\n      \tis_point_on_H( p - (offsetVec += vec2(4.0,0.0)) ) ||\n      \tis_point_on_T( p - (offsetVec += vec2(4.0,0.0)) )) {\n        return true;\n    }\n    \n    return false;\n}\n\n#endif\n\n\n#define MATERIAL_COUNT \t\t8\n#define BSDF_COUNT \t\t\t3\n#define BSDF_R_DIFFUSE \t\t0\n#define BSDF_R_GLOSSY \t\t1\n#define BSDF_R_LIGHT \t\t2\n\n\/\/***********************************\n\/\/sampling types\n#define SAMPLING_LIGHT\t\t\t\t0\n#define SAMPLING_BSDF\t\t\t\t1\n#define SAMPLING_LIGHT_AND_BSDF_MIS\t2\n#define SAMPLING_NONE\t\t\t\t3\nint samplingTechnique;\nfloat split1;\nfloat split2;\n\nvoid initSamplingTechnique(float p) {\n    float k = iMouse.x\/iResolution.x;\n    if(iMouse.z<0.0 || iMouse.x==0.0) {\n      \tsplit1 = 0.0;\n        split2 = iResolution.x;  \n    } else {\n        split1 = iMouse.x*k;\n        split2 = iMouse.x + (iResolution.x-iMouse.x)*k;\n    }\n    \n    if(p < split1-1.0) {\n        samplingTechnique = SAMPLING_BSDF;\n    } else if((p > split1+1.0) && (p < split2-1.0)) {\n        samplingTechnique = SAMPLING_LIGHT_AND_BSDF_MIS;\n    } else if(p > split2+1.0){\n        samplingTechnique = SAMPLING_LIGHT;\n    } else {\n        samplingTechnique = SAMPLING_NONE;\n    }\n}\n\/\/***********************************\n\n#define LIGHT_COUNT (4)\n#define LIGHT_COUNT_INV (0.25)\n#define WALL_COUNT \t(2)\n\n\/\/MIS heuristics *****************************\n#define MIS_HEURISTIC_BALANCE\n\/\/#define MIS_HEURISTIC_POWER\n\nfloat misWeightPower( in float a, in float b ) {\n    float a2 = a*a;\n    float b2 = b*b;\n    float a2b2 = a2 + b2;\n    return a2 \/ a2b2;\n}\nfloat misWeightBalance( in float a, in float b ) {\n    float ab = a + b;\n    \n    return a \/ ab;\n}\nfloat misWeight( in float pdfA, in float pdfB ) {\n#ifdef MIS_HEURISTIC_POWER\n    return misWeightPower(pdfA,pdfB);\n#else\n    return misWeightBalance(pdfA,pdfB);\n#endif\n}\n\/\/********************************************\n            \n\/\/ random number generator **********\n\/\/ taken from iq :)\nfloat seed;\t\/\/seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n\/\/***********************************\n\n\/\/ Color corversion code from: http:\/\/lolengine.net\/blog\/2013\/07\/27\/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 \/ 3.0, 1.0 \/ 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\/\/************************************************************************************\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Converting PDF from Solid angle to Area\nfloat PdfWtoA( float aPdfW, float aDist2, float aCosThere ){\n    if( aDist2 < EPSILON )\n        return 0.0;\n    return aPdfW * abs(aCosThere) \/ aDist2;\n}\n\n\/\/ Converting PDF between from Area to Solid angle\nfloat PdfAtoW( float aPdfA, float aDist2, float aCosThere ){\n    float absCosTheta = abs(aCosThere);\n    if( absCosTheta < EPSILON )\n        return 0.0;\n    \n    return aPdfA * aDist2 \/ absCosTheta;\n}\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ Data structures ****************** \nstruct Sphere { vec3 pos; float radius; float radiusSq; float area; };\nstruct LightSamplingRecord { vec3 w; float d; float pdf; };\nstruct Plane { vec4 abcd; };\nstruct Range { float min_; float max_; };\nstruct Material { vec3 color; float roughness_; int bsdf_; };\nstruct RaySurfaceHit { vec3 N; vec3 E; int mtl_id; int obj_id; float dist; };\nstruct Ray { vec3 origin; vec3 dir; };\nstruct Camera { mat3 rotate; vec3 pos; float fovV; };\n\/\/***********************************\n    \n\/\/ ************ SCENE ***************\nPlane walls[WALL_COUNT];\nSphere lights[LIGHT_COUNT];\n\n#ifdef SHOW_PLANES\n#define PLANE_COUNT (3)\nPlane planes[PLANE_COUNT];\nRange planeZRanges[PLANE_COUNT];\nfloat planeHalfWidth = 2.3;\n#endif\n\/\/***********************************\n\n\/\/ ************************  INTERSECTION FUNCTIONS **************************\nbool raySphereIntersection( Ray ray, in Sphere sph, out float t ) {\n    t = -1.0;\n\tvec3  ce = ray.origin - sph.pos;\n\tfloat b = dot( ray.dir, ce );\n\tfloat c = dot( ce, ce ) - sph.radiusSq;\n\tfloat h = b*b - c;\n    if( h > 0.0 ) {\n\t\tt = -b - sqrt(h);\n\t}\n\t\n\treturn ( t > 0.0 );\n}\n\nbool rayPlaneIntersection( Ray ray, Plane plane, out float t ){\n    float dotVN = dot( ray.dir, plane.abcd.xyz );\n   \n    if ( abs( dotVN ) < EPSILON ) {\n        return false;\n    }\n    \n\tt = -(dot( ray.origin, plane.abcd.xyz ) + plane.abcd.w)\/dotVN;\n    \n    return ( t > 0.0 );\n}\n\/\/ ***************************************************************************\n\nvoid updateScene(float t) {\n    \/\/init lights\n    t *= 4.0;\n\n    float moveSize = 0.7;\n    float a = 0.0;\n    float speed = 2.0;\n    float val;\n    \n    \/\/1\n    val = a+t*speed;    \n    lights[0].pos = vec3( -2.0, 1.4, -5.0 ) + vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(0)*LIGHT_COUNT_INV);\n    a += 0.4;\n    \n    \/\/2\n    val = a+t*speed;    \n    lights[1].pos = vec3( -1.1, 1.4, -5.0 ) + vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(1)*LIGHT_COUNT_INV);\n    a += 0.4;\n    \n    \/\/3\n    val = a+t*speed;    \n    lights[2].pos = vec3( 0.0, 1.4, -5.0 ) + vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(2)*LIGHT_COUNT_INV);\n    a += 0.4;\n    \n    \/\/4\n    val = a+t*speed;    \n    lights[3].pos = vec3( 1.6, 1.4, -5.0 ) + vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(3)*LIGHT_COUNT_INV);\n    a += 0.4;\n}\n\nvoid initScene() {\n    \/\/init lights\n    lights[0] = Sphere( vec3( -2.0, 1.4, -5.0 ), 0.05, 0.0025, 0.0314159 );\n\tlights[1] = Sphere( vec3( -1.1, 1.4, -5.0 ), 0.2, 0.04, 0.5026548 );\n\tlights[2] = Sphere( vec3( 0.0, 1.4, -5.0 ), 0.4, 0.16, 2.0106193 );\n\tlights[3] = Sphere( vec3( 1.6, 1.4, -5.0 ), 0.8, 0.64, 8.0424770 );\n    \n    float moveSize = 0.7;\n    float a = 0.0;\n    float speed = 2.0;\n    float val;\n    \n    \/\/1\n    val = a+iTime*speed;    \n    lights[0].pos += vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(0)*LIGHT_COUNT_INV);\n    a += 0.4;\n    \n    \/\/2\n    val = a+iTime*speed;    \n    lights[1].pos += vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(1)*LIGHT_COUNT_INV);\n    a += 0.4;\n    \n    \/\/3\n    val = a+iTime*speed;    \n    lights[2].pos += vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(2)*LIGHT_COUNT_INV);\n    a += 0.4;\n    \n    \/\/4\n    val = a+iTime*speed;    \n    lights[3].pos += vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(3)*LIGHT_COUNT_INV);\n    a += 0.4;\n    \n    \/\/init walls\n    walls[0].abcd = vec4( normalize(vec3(0.0, 1.0, -EPSILON)), 1.0 );\n    \/\/walls[0].abcd = vec4( 0.0, 1.0, 0.0, 1.0 );\n    walls[1].abcd = vec4( 0.0, 0.0, 1.0, 6.2 );\n    \n#ifdef SHOW_PLANES\n    \/\/init planes\n    vec3 planeNormal = normalize( vec3( 0.0, 1.0, 1.2 ) );\n    planes[0].abcd = vec4( planeNormal, 3.8 );\n    planeZRanges[0].min_ = -5.8;\n    planeZRanges[0].max_ = -5.0;\n    \n    planeNormal = normalize( vec3( 0.0, 1.0, 0.7 ) );\n    planes[1].abcd = vec4( planeNormal, 2.8 );\n    planeZRanges[1].min_ = -4.8;\n    planeZRanges[1].max_ = -4.0;\n    \n    planeNormal = normalize( vec3( 0.0, 1.0, 0.3 ) );\n    planes[2].abcd = vec4( planeNormal, 1.8 );\n    planeZRanges[2].min_ = -3.8;\n    planeZRanges[2].max_ = -3.0;\n#endif\n}\n\n#define GET_LIGHT_SPHERE_CONST(i) lights[i]\n\n\nMaterial materialLibrary[MATERIAL_COUNT];\n\n#define INIT_MTL(i,bsdf,phongExp,colorVal) materialLibrary[i].bsdf_=bsdf; materialLibrary[i].roughness_=phongExp; materialLibrary[i].color=colorVal;\nvoid initMaterialLibrary()\n{\n    vec3 white = vec3( 1.0, 1.0, 1.0 );\n    vec3 gray = vec3( 0.8, 0.8, 0.8 );\n    \n    \/\/walls\n    INIT_MTL( 0, BSDF_R_DIFFUSE, 0.0, white );\n\t\n    \/\/planes\n    INIT_MTL( 1, BSDF_R_GLOSSY, 4096.0, gray );\n    INIT_MTL( 2, BSDF_R_GLOSSY, 128.0, gray );\n    INIT_MTL( 3, BSDF_R_GLOSSY, 32.0, gray );\n    \n    \/\/lights\n    float totalIntencity = 6.0;\n    float min_x = lights[0].pos.x;\n    float max_x = lights[3].pos.x;\n    float x_range = max_x - min_x;\n    float h1 = ((lights[0].pos.x-min_x)\/x_range)*0.6;\n    float h2 = ((lights[1].pos.x-min_x)\/x_range)*0.6;\n    float h3 = ((lights[2].pos.x-min_x)\/x_range)*0.6;\n    float h4 = ((lights[3].pos.x-min_x)\/x_range)*0.6;\n    float s = 0.7;\n    float v1 = 1.0\/(FOUR_PI*lights[0].radiusSq);\n    float v2 = 1.0\/(FOUR_PI*lights[1].radiusSq);\n    float v3 = 1.0\/(FOUR_PI*lights[2].radiusSq);\n    float v4 = 1.0\/(FOUR_PI*lights[3].radiusSq);\n    \n    INIT_MTL( 4, BSDF_R_LIGHT, 0.0, hsv2rgb( vec3( h1, s, v1 ) )*totalIntencity );\n    INIT_MTL( 5, BSDF_R_LIGHT, 0.0, hsv2rgb( vec3( h2, s, v2 ) )*totalIntencity );\n    INIT_MTL( 6, BSDF_R_LIGHT, 0.0, hsv2rgb( vec3( h3, s, v3 ) )*totalIntencity );\n    INIT_MTL( 7, BSDF_R_LIGHT, 0.0, hsv2rgb( vec3( h4, s, v4 ) )*totalIntencity );\n}\n\nMaterial getMaterialFromLibrary( int index ){\n#if __VERSION__ >= 300\n    return materialLibrary[index];\n#else\n    if(index == 0) return materialLibrary[0];\n    if(index == 1) return materialLibrary[1];\n    if(index == 2) return materialLibrary[2];\n    if(index == 3) return materialLibrary[3];\n    if(index == 4) return materialLibrary[4];\n    if(index == 5) return materialLibrary[5];\n    if(index == 6) return materialLibrary[6];\n    return materialLibrary[7];\n#endif\n}\n\nvoid getLightInfo( in int index, out Sphere sphere, out vec3 intensity ) {\n#if __VERSION__ >= 300\n    sphere = lights[index];\n#else\n    if(index == 0) { sphere = lights[0]; } else\n    if(index == 1) { sphere = lights[1]; } else\n    if(index == 2) { sphere = lights[2]; } else\n    \t\t\t   { sphere = lights[3]; }\n#endif\n    intensity = getMaterialFromLibrary(4+index).color;\n}\n\n\/\/ Geometry functions ***********************************************************\nvec2 uniformPointWithinCircle( in float radius, in float Xi1, in float Xi2 ) {\n    float r = radius*sqrt(Xi1);\n    float theta = Xi2*TWO_PI;\n\treturn vec2( r*cos(theta), r*sin(theta) );\n}\n\nvec3 uniformDirectionWithinCone( in vec3 d, in float phi, in float sina, in float cosa ) {    \n\tvec3 w = normalize(d);\n    vec3 u = normalize(cross(w.yzx, w));\n    vec3 v = cross(w, u);\n\treturn (u*cos(phi) + v*sin(phi)) * sina + w * cosa;\n}\n\nvoid basis(in vec3 n, out vec3 b1, out vec3 b2) {\n    float sign_ = sign(n.z);\n\tfloat a = -1.0 \/ (sign_ + n.z);\n\tfloat b = n.x * n.y * a;\n\tb1 = vec3(1.0 + sign_ * n.x * n.x * a, sign_ * b, -sign_ * n.x);\n\tb2 = vec3(b, sign_ + n.y * n.y * a, -n.y);\n}\n\nvec3 localToWorld( in vec3 localDir, in vec3 normal ) {\n    vec3 a,b;\n    basis( normal, a, b );\n\treturn localDir.x*a + localDir.y*b + localDir.z*normal;\n}\n\nvec3 sphericalToCartesian( in float rho, in float phi, in float theta ) {\n    float sinTheta = sin(theta);\n    return vec3( sinTheta*cos(phi), sinTheta*sin(phi), cos(theta) )*rho;\n}\n\nvec3 sampleHemisphereCosWeighted( in vec3 n, in float Xi1, in float Xi2 ) {\n    float theta = acos(sqrt(1.0-Xi1));\n    float phi = TWO_PI * Xi2;\n\n    return localToWorld( sphericalToCartesian( 1.0, phi, theta ), n );\n}\n\nvec3 randomDirection( in float Xi1, in float Xi2 ) {\n    float theta = acos(1.0 - 2.0*Xi1);\n    float phi = TWO_PI * Xi2;\n    \n    return sphericalToCartesian( 1.0, phi, theta );\n}\n\/\/*****************************************************************************\n\n\n\/\/ BSDF functions *************************************************************\nfloat evaluateBlinn( in  vec3 N, in vec3 E, in vec3 L, in float roughness ) {\n    vec3 H = normalize(E + L);\n    float cosTheta = dot(N,H);\n    return (roughness + 2.0) \/ (8.0 * PI) * pow(cosTheta, roughness);\n}\n\nfloat pdfBlinn(in vec3 N, in vec3 E, in vec3 L, in float roughness ) {\n    vec3 H = normalize(E + L);\n    float cosTheta = dot(N,H);\n\tfloat normalizationFactor = (roughness + 1.0) \/ TWO_PI;\n    return pow( cosTheta, roughness ) * normalizationFactor \/ (4.0 * dot(E, H));\n}\n\nvec3 sampleBlinn( in vec3 N, in vec3 E, in float roughness, in float r1, in float r2, out float pdf ) {\n    float cosTheta = pow( r1, 1.0\/( roughness ) );\n    float phi = r2*TWO_PI;\n    float theta = acos( cosTheta );\n    vec3 H = localToWorld( sphericalToCartesian( 1.0, phi, theta ), N );\n    float dotNH = dot(H,N);\n    vec3 L = reflect( E*(-1.0), H );\n    \n    pdf = pdfBlinn(N, E, L, roughness );\n    \n    return L;\n}\n\nfloat evaluateLambertian( in vec3 N, in vec3 L ) {\n    return INV_PI;\n}\n\nfloat pdfLambertian( in vec3 N, in vec3 L ) {\n    return max(.0, dot( N, L )) * INV_PI;\n}\n\nvec3 sampleLambertian( in vec3 N, in float r1, in float r2, out float pdf ){\n    vec3 L = sampleHemisphereCosWeighted( N, r1, r2 );\n    pdf = pdfLambertian(N, L);\n    return L;\n}\n\/\/*****************************************************************************\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nvoid initCamera( in vec3 pos, in vec3 frontDir, in vec3 upDir, in float fovV, out Camera dst ) {\n\tvec3 back = normalize( -frontDir );\n\tvec3 right = normalize( cross( upDir, back ) );\n\tvec3 up = cross( back, right );\n    dst.rotate[0] = right;\n    dst.rotate[1] = up;\n    dst.rotate[2] = back;\n    dst.fovV = fovV;\n    dst.pos = pos;\n}\n\nRay genRay( in Camera camera, in vec2 pixel ) {\n\tvec2 iPlaneSize=2.*tan(0.5*camera.fovV)*vec2(iResolution.x\/iResolution.y,1.);\n\tvec2 ixy=(pixel\/iResolution.xy - 0.5)*iPlaneSize;\n    \n    Ray ray;\n    ray.origin = camera.pos;\n\tray.dir = camera.rotate*normalize(vec3(ixy.x,ixy.y,-1.0));\n\n\treturn ray;\n}\n\n\nbool raySceneIntersection( \tin Ray ray,\n                          \tin float distMin,\n                          \tout RaySurfaceHit hit ) {\n    hit.obj_id = -1;\n    hit.dist = 1000.0;\n    hit.E = ray.dir*(-1.0);\n    \n    \/\/check lights\n    for( int i1=0; i1<LIGHT_COUNT; i1++ ){\n        float dist;\n        if( raySphereIntersection( ray, lights[i1], dist ) && (dist>distMin) && ( dist < hit.dist ) ) {\n            hit.dist = dist;\n          \tvec3 hitpos = ray.origin + ray.dir*hit.dist;\n    \t\thit.N = (hitpos - lights[i1].pos)*(1.0\/lights[i1].radius);\n    \t\thit.mtl_id = 4 + i1;\n            hit.obj_id = i1;\n        }\n    }\n    \n    \/\/check walls\n    for( int i=0; i<WALL_COUNT; i++ ){\n        float dist;\n        if( rayPlaneIntersection( ray, walls[i], dist ) && (dist>distMin) && (dist < hit.dist ) ){\n            hit.dist = dist;\n\/\/            hit.pos = ray.origin + ray.dir*hit.dist;\n    \t\thit.N = walls[i].abcd.xyz;\n    \t\thit.mtl_id = 0;\n            hit.obj_id = LIGHT_COUNT + i;\n        }\n    }\n    \n#ifdef SHOW_PLANES\n    \/\/check planes\n    for( int i=0; i<PLANE_COUNT; i++ ){\n        float dist;\n        if( rayPlaneIntersection( ray, planes[i], dist ) && (dist>distMin) && (dist < hit.dist ) ){\n            vec3 hitPos = ray.origin + ray.dir*dist;\n            if( (hitPos.z < planeZRanges[i].max_ ) && (hitPos.z > planeZRanges[i].min_) && (hitPos.x < planeHalfWidth ) && (hitPos.x > -planeHalfWidth ) ) {\n                hit.dist = dist;\n\/\/                hit.pos = hitPos;\n                hit.N = planes[i].abcd.xyz;\n                hit.mtl_id = 1+i;\n                hit.obj_id = LIGHT_COUNT + WALL_COUNT + i;\n            }        \n        }\n    }\n#endif\n    \n    return ( hit.obj_id != -1 );\n}\n\nvoid sampleSphericalLight( in vec3 x, in Sphere sphere, float Xi1, float Xi2, out LightSamplingRecord sampleRec ) {\n#ifdef SAMPLE_LIGHT_AREA\n    vec3 n = randomDirection( Xi1, Xi2 );\n    vec3 p = sphere.pos + n*sphere.radius;\n    float pdfA = 1.0\/sphere.area;\n    \n    vec3 Wi = p - x;\n    \n    float d2 = dot(Wi,Wi);\n    sampleRec.d = sqrt(d2);\n    sampleRec.w = Wi\/sampleRec.d; \n    float cosTheta = max( 0.0, dot(n, -sampleRec.w) );\n    sampleRec.pdf = PdfAtoW( pdfA, d2, cosTheta );\n#else\n    vec3 w = sphere.pos - x;\t\/\/direction to light center\n\tfloat dc_2 = dot(w, w);\t\t\/\/squared distance to light center\n    float dc = sqrt(dc_2);\t\t\/\/distance to light center\n    \n    if( dc_2 > sphere.radiusSq ) {\n    \tfloat sin_theta_max_2 = sphere.radiusSq \/ dc_2;\n\t\tfloat cos_theta_max = sqrt( 1.0 - clamp( sin_theta_max_2, 0.0, 1.0 ) );\n    \tfloat cos_theta = mix( cos_theta_max, 1.0, Xi1 );\n        float sin_theta_2 = 1.0 - cos_theta*cos_theta;\n    \tfloat sin_theta = sqrt(sin_theta_2);\n        sampleRec.w = uniformDirectionWithinCone( w, TWO_PI*Xi2, sin_theta, cos_theta );\n    \tsampleRec.pdf = 1.0\/( TWO_PI * (1.0 - cos_theta_max) );\n        \n        \/\/Calculate intersection distance\n\t\t\/\/http:\/\/ompf2.com\/viewtopic.php?f=3&t=1914\n        sampleRec.d = dc*cos_theta - sqrt(sphere.radiusSq - dc_2*sin_theta_2);\n    } else {\n        sampleRec.w = randomDirection( Xi1, Xi2 );\n        sampleRec.pdf = 1.0\/FOUR_PI;\n    \traySphereIntersection( Ray(x,sampleRec.w), sphere, sampleRec.d );\n    }\n#endif\n}\n\nfloat sphericalLightSamplingPdf( in vec3 x, in vec3 wi, float d, in vec3 n1, in Sphere sphere ) {\n#ifdef SAMPLE_LIGHT_SOLIDANGLE\n    float solidangle;\n    vec3 w = sphere.pos - x;\t\/\/direction to light center\n\tfloat dc_2 = dot(w, w);\t\t\/\/squared distance to light center\n    float dc = sqrt(dc_2);\t\t\/\/distance to light center\n    \n    if( dc_2 > sphere.radiusSq ) {\n    \tfloat sin_theta_max_2 = clamp( sphere.radiusSq \/ dc_2, 0.0, 1.0);\n\t\tfloat cos_theta_max = sqrt( 1.0 - sin_theta_max_2 );\n    \tsolidangle = TWO_PI * (1.0 - cos_theta_max);\n    } else { \n    \tsolidangle = FOUR_PI;\n    }\n    \n    return 1.0\/solidangle;\n#else\n    float lightPdfA = 1.0\/sphere.area;\n    float cosTheta1 = max( 0.0, dot( n1, -wi ) );\n    return PdfAtoW( lightPdfA, d*d, cosTheta1 );\n#endif\n}\n\nfloat lightChoosingPdf(in vec3 x, in int lightId) {\n#ifdef IMPORTANCE_SAMPLE_LIGHT_SOURCE\n    float cdf[LIGHT_COUNT];\n    \n    for(int i=0; i<LIGHT_COUNT; i++) {\n        float len = length(lights[i].pos - x);\n        cdf[i] = 1.0 \/ (len * len);\n    }\n    \n    for(int i=1; i<LIGHT_COUNT; i++) {\n        cdf[i] += cdf[i - 1];\n    }\n    \n    for(int i=0; i<LIGHT_COUNT; i++) {\n        cdf[i] \/= cdf[LIGHT_COUNT-1];\n    }\n    \n    return cdf[lightId] - (lightId==0? 0.0 : cdf[lightId-1]);\n#else\n   \treturn 1.0\/float(LIGHT_COUNT);\n#endif\n}  \t\n\nint chooseOneLight(in vec3 x, in float Xi, out float pdf) {\n#ifdef IMPORTANCE_SAMPLE_LIGHT_SOURCE\n    float cdf[LIGHT_COUNT];\n    \n    for(int i=0; i<LIGHT_COUNT; i++) {\n        float len = length(lights[i].pos - x);\n        cdf[i] = 1.0 \/ (len * len);\n    }\n    \n    for(int i=1; i<LIGHT_COUNT; i++) {\n        cdf[i] += cdf[i - 1];\n    }\n    \n    for(int i=0; i<LIGHT_COUNT; i++) {\n        cdf[i] \/= cdf[LIGHT_COUNT-1];\n    }\n    \n    int id = 0;\n    for(int i=0; i<LIGHT_COUNT; i++) {\n        if(Xi < cdf[i]) {\n        \tid = i;\n            pdf = cdf[i] - (i==0? 0.0 : cdf[i-1]);\n            break;\n        }\n    }\n    \n    return id;\n#else\n   \tpdf = 1.0\/float(LIGHT_COUNT);\n    return int(Xi*float(LIGHT_COUNT));\n#endif\n}\n\nvec3 sampleBSDF( in vec3 x, in RaySurfaceHit hit, in Material mtl, in bool useMIS ) {\n    vec3 Lo = vec3( 0.0 );\n    float bsdfSamplingPdf = 1.0\/float(BSDF_SAMPLES);\n    vec3 n = hit.N * vec3((dot(hit.E, hit.N) < 0.0) ? -1.0 : 1.0);\n    \n    for( int i=0; i<BSDF_SAMPLES; i++ ) {\n        \/\/Generate direction proportional to bsdf\n        vec3 bsdfDir;\n        float bsdfPdfW;\n        float Xi1 = rnd();\n        float Xi2 = rnd();\n        float strataSize = 1.0 \/ float(BSDF_SAMPLES);\n        Xi2 = strataSize * (float(i) + Xi2);\n        float brdf;\n        \n        if( mtl.bsdf_ == BSDF_R_GLOSSY ) {\n            bsdfDir = sampleBlinn( n, hit.E, mtl.roughness_, Xi1, Xi2, bsdfPdfW );\n            brdf = evaluateBlinn( n, hit.E, bsdfDir, mtl.roughness_ );\n        } else {\n            bsdfDir = sampleLambertian( n, Xi1, Xi2, bsdfPdfW );\n            brdf = evaluateLambertian( n, bsdfDir );\n        }\n        \n        float dotNWi = dot( bsdfDir, n );\n\n        \/\/Continue if sampled direction is under surface\n        if( (dotNWi > 0.0) && (bsdfPdfW > EPSILON) ){\n            \/\/calculate light visibility\n            RaySurfaceHit newHit;\n            if( raySceneIntersection( Ray( x, bsdfDir ), EPSILON, newHit ) && (newHit.obj_id < LIGHT_COUNT) ) {\n                \/\/Get hit light Info\n                vec3 Li;\n                Sphere lightSphere;\n                getLightInfo( newHit.obj_id, lightSphere, Li );\n\n                \/\/Read light info\n                float weight = 1.0;\n\t\t\t\tfloat lightPdfW;\n                if ( useMIS ) {\n                    lightPdfW = sphericalLightSamplingPdf( x, bsdfDir, newHit.dist, newHit.N, lightSphere );\n                    lightPdfW *= lightChoosingPdf(x, newHit.obj_id);\n                    weight = misWeight( bsdfPdfW, lightPdfW );\n                }\n\n                Lo += brdf*dotNWi*(Li\/bsdfPdfW)*weight;\n            }\n        }\n    }\n\n    return Lo*bsdfSamplingPdf;\n}     \n\nvec3 sampleLight( \tin vec3 x, in RaySurfaceHit hit, in Material mtl, in bool useMIS ) {\n    vec3 Lo = vec3( 0.0 );\t\/\/outgoing radiance\n    float lightSamplingPdf = 1.0\/float(LIGHT_SAMPLES);\n   \n    for( int i=0; i<LIGHT_SAMPLES; i++ ) {\n        \/\/select light uniformly\n        float Xi = rnd();\n        float strataSize = 1.0 \/ float(LIGHT_SAMPLES);\n        Xi = strataSize * (float(i) + Xi);\n        float lightPickPdf;\n        int lightId = chooseOneLight(x, Xi, lightPickPdf);\n\n        \/\/Read light info\n        vec3 Li;\t\t\t\t\/\/incomming radiance\n        Sphere lightSphere;\n        getLightInfo( lightId, lightSphere, Li );\n        \n        float Xi1 = rnd();\n        float Xi2 = rnd();\n        LightSamplingRecord sampleRec;\n        sampleSphericalLight( x, lightSphere, Xi1, Xi2, sampleRec );\n        \n        float lightPdfW = lightPickPdf*sampleRec.pdf;\n        vec3 Wi = sampleRec.w;\n        \n        float dotNWi = dot(Wi,hit.N);\n\n        if ( (dotNWi > 0.0) && (lightPdfW > EPSILON) ) {\n            Ray shadowRay = Ray( x, Wi );\n            RaySurfaceHit newHit;\n            bool visible = true;\n#ifdef SHADOWS\n            visible = ( raySceneIntersection( shadowRay, EPSILON, newHit ) && EQUAL_FLT(newHit.dist,sampleRec.d,EPSILON) );\n#endif\n            if(visible) {\n                float brdf;\n    \t\t\tfloat brdfPdfW;\t\t\t\/\/pdf of choosing Wi with 'bsdf sampling' technique\n                \n                if( mtl.bsdf_ == BSDF_R_GLOSSY ) {\n                    brdf = evaluateBlinn( hit.N, hit.E, Wi, mtl.roughness_ );\n                    brdfPdfW = pdfBlinn(hit.N, hit.E, Wi, mtl.roughness_ );\t\/\/sampling Pdf matches brdf\n                } else {\n                    brdf = evaluateLambertian( hit.N, Wi );\n                    brdfPdfW = pdfLambertian( hit.N, Wi );\t\/\/sampling Pdf matches brdf\n                }\n\n                float weight = 1.0;\n                if( useMIS ) {\n                    weight = misWeight( lightPdfW, brdfPdfW );\n                }\n                \n                Lo += ( Li * brdf * weight * dotNWi ) \/ lightPdfW;\n            }\n        }\n    }\n    \n    return Lo*lightSamplingPdf;\n}\n\nvec3 Radiance( in Ray ray ) {\n    RaySurfaceHit hit;\n    if( raySceneIntersection( ray, 0.0, hit ) ) {\n    \tMaterial mtl = getMaterialFromLibrary( hit.mtl_id );\n\n        vec3 f, Le;\n\n        if( mtl.bsdf_ == BSDF_R_LIGHT ) {\n            Le = mtl.color;\n            f = vec3( 1.0, 1.0, 1.0 );\n        } else {\n            Le = vec3( 0.0 );\n            f = mtl.color;\n        }\n        \n        vec3 hitPos = ray.origin + ray.dir*hit.dist;\n            \n        vec3 directLight = vec3(0.0);\n        if( samplingTechnique == SAMPLING_LIGHT ) {\n            directLight += sampleLight( hitPos, hit, mtl, false );\n        } else if( samplingTechnique == SAMPLING_BSDF ) {\n            directLight += sampleBSDF( hitPos, hit, mtl, false );\n        } else {\n            directLight += sampleBSDF( hitPos, hit, mtl, true );\n            directLight += sampleLight( hitPos, hit, mtl, true );\n        }\n\n        return Le + f * directLight;\n    }\n\n    return backgroundColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = \/*iTime +*\/ iResolution.y * fragCoord.x \/ iResolution.x + fragCoord.y \/ iResolution.y;\n    \n\tfloat sinTime = sin(iTime*0.2);\n    \n    Camera camera;\n    initScene();\n    initMaterialLibrary();\n    \n    vec2 splitterPos = iMouse.xy;\n    if ( splitterPos.x == 0.0 && splitterPos.y == 0.0 ) {\n        splitterPos = iResolution.xy*0.5;\n    }\n    initSamplingTechnique((iMouse.x==0.0)?iResolution.x*0.5:fragCoord.x);\n    \n    if(samplingTechnique == SAMPLING_NONE) {\n        fragColor = vec4( 1.0 );\n        return;\n    }\n\t\n    Ray ray;\n\tvec3 accumulatedColor = vec3( 0.0 );\n\tfor(int si=0; si<PIXEL_SAMPLES; ++si ){\n        \/\/stratified sampling for t\n        float tprev = iTime;\n        float tnext = iTime+FRAME_TIME;\n        float tStrata = 1.0\/float(PIXEL_SAMPLES);\n        float tnorm = tStrata*(float(si)+rnd());\n        float t = mix(tprev,tnext,tnorm);\n        \n        \/\/for object motion blur\n        updateScene(t);\n        \n        \/\/update camera for camera motion blur\n        vec3 cameraPos = vec3( 0.0, 1.0 + sin(t*0.45), 3.0 + sin(t*0.4)*3.0 );\n    \tvec3 cameraTarget = vec3( sin(t*0.4)*0.3, 0.0, -5.0 );\n    \tinitCamera( cameraPos, cameraTarget - cameraPos, vec3( 0.0, 1.0, 0.0 ), radians(45.0), camera );\n        \n        vec2 subPixelCoord = vec2(rnd(), rnd());\n        vec2 screenCoord = fragCoord.xy + subPixelCoord;\n        ray = genRay( camera, screenCoord );\n        \n        accumulatedColor += Radiance( ray );\n        \n#ifdef SHOW_TEXT\n        float fontScale = 3.2;\n        vec2 offset_brdf = vec2( 2.0*fontScale, 0.0 )*fontScale;\n        vec2 offset_mis = vec2( 1.5*fontScale, 0.0 )*fontScale;\n        vec2 offset_light = vec2( 2.0*fontScale, 0.0 )*fontScale;\n\n        if( is_point_on_BRDF( (screenCoord.xy - vec2(split1*0.5,iResolution.y*0.03) + offset_brdf )*(1.0\/fontScale) ) ) {\n            float val = clamp(split1\/iResolution.x, 0.0, 0.9 );\n            accumulatedColor += vec3( val ); \n        }\n        \n        if( is_point_on_MIS( (screenCoord.xy - vec2((split1+split2)*0.5,iResolution.y*0.03) + offset_mis )*(1.0\/fontScale) ) ) {\n            float val = clamp((split2-split1)\/(0.6*iResolution.x), 0.0, 0.9 );\n            accumulatedColor += vec3( val );\n        }\n        \n        if( is_point_on_LIGHT( (screenCoord.xy - vec2((split2+iResolution.x)*0.5,iResolution.y*0.03) + offset_light )*(1.0\/fontScale) )) {\n            float val = clamp((iResolution.x-split2)\/iResolution.x, 0.0, 0.9 );\n            accumulatedColor += vec3( val );\n        }\n#endif\n\t}\n\t\n\t\/\/devide to sample count\n\taccumulatedColor = accumulatedColor*(1.0\/float(PIXEL_SAMPLES));\n\t\n\t\/\/gamma correction\n    accumulatedColor = pow( accumulatedColor, vec3( 1.0 \/ GAMMA ) );\n    \n\tfragColor = vec4( accumulatedColor,1.0 );\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"Msf3zX","date":"1376174419","viewed":9852,"name":"Foggy Mountains 2","username":"ztri","description":"Moutains with timelapse style clouds and fog. Use mouse to control the clouds & camera.","likes":137,"published":1,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"\/media\/a\/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"\/media\/ap\/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\/\/ Use mouse to control the camera & time.\n\n\nfloat time = 0.0;\n\t \nvec3 rotate(vec3 r, float v){ return vec3(r.x*cos(v)+r.z*sin(v),r.y,r.z*cos(v)-r.x*sin(v));}\n\nfloat noise( in vec3 x )\n{\n\tfloat  z = x.z*64.0;\n\tvec2 offz = vec2(0.317,0.123);\n\tvec2 uv1 = x.xy + offz*floor(z); \n\tvec2 uv2 = uv1  + offz;\n\treturn mix(textureLod( iChannel0, uv1 ,0.0).x,textureLod( iChannel0, uv2 ,0.0).x,fract(z))-0.5;\n}\n\nfloat noises( in vec3 p){\n\tfloat a = 0.0;\n\tfor(float i=1.0;i<6.0;i++){\n\t\ta += noise(p)\/i;\n\t\tp = p*2.0 + vec3(0.0,a*0.001\/i,a*0.0001\/i);\n\t}\n\treturn a;\n}\n\nfloat base( in vec3 p){\n\treturn noise(p*0.00002)*1200.0;\n}\n\nfloat ground( in vec3 p){\n\treturn base(p)+noises(p.zxy*0.00005+10.0)*40.0*(0.0-p.y*0.01)+p.y;\n}\n\nfloat clouds( in vec3 p){\n\tfloat b = base(p);\n\tp.y += b*0.5\/abs(p.y) + 100.0;\n\treturn noises(vec3(p.x*0.3+((time+iMouse.y)*30.0),p.y,p.z)*0.00002)-max(p.y,0.0)*0.00009;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    time        = iTime*5.0+floor(iTime*0.1)*150.0;\n    vec2 uv     = fragCoord.xy\/(iResolution.xx*0.5)-vec2(1.0,iResolution.y\/iResolution.x);\n    vec3 campos   = vec3(30.0,500.0,time*8.0);\n\t\t campos.y = 500.0-base(campos);\n    vec3 ray   = rotate(normalize(vec3(uv.x,uv.y-sin(time*0.05)*0.2-0.1,1.0).xyz),time*0.01+iMouse.x*0.009);\n    vec3 pos    = campos+ray;\n    vec3 sun    = vec3(0.0,0.6,-0.4);    \t\n\t\n    \/\/ raymarch\n    float test  = 0.0;\n    float fog   = 0.0;\n\tfloat dist  = 0.0;\n\n\tvec3  p1 = pos;\t\n\tfor(float i=1.0;i<50.0;i++){\n        test  = ground(p1); \n\t\tfog  += max(test*clouds(p1),fog*0.02);\n\t\tp1   += ray*min(test,i*i*0.5);\n\t\tdist += test;\n\t\tif(abs(test)<10.0||dist>40000.0) break;\n\t}\n\n\tfloat l     = sin(dot(ray,sun));\n\tvec3  light = vec3(l,0.0,-l)+ray.y*0.2;\n    \n\tfloat amb = smoothstep(-100.0,100.0,ground(p1+vec3(0.0,30.0,0.0)+sun*10.0))-smoothstep(1000.0,-0.0,p1.y)*0.7;\n\tvec3  ground = vec3(0.30,0.30,0.25)+sin(p1*0.001)*0.01+noise(vec3(p1*0.002))*0.1+amb*0.7+light*0.01;\n\t\t\n\tfloat f = smoothstep(0.0,800.0,fog);\n\tvec3  cloud = vec3(0.70,0.72,0.70)+light*0.05+sin(fog*0.0002)*0.2+noise(p1)*0.05;\n\n\tfloat h = smoothstep(10000.,40000.0,dist);\n\tvec3  sky = cloud+ray.y*0.1-0.02;\t\n\t\n\tfragColor = vec4(sqrt(smoothstep(0.2,1.0,mix(mix(ground,sky,h),cloud,f)-dot(uv,uv)*0.1)),1.0);\n\t\n\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4dKXDy","date":"1466577438","viewed":9850,"name":"Quake Logo","username":"knarkowicz","description":"Quake logo made for 20th Quake anniversary","likes":69,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"\/media\/a\/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"\/media\/ap\/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float MATH_PI = float( 3.14159265359 );\n\nfloat VisibilityTerm( float roughness, float ndotv, float ndotl )\n{\n\tfloat m2\t= roughness * roughness;\n\tfloat visV\t= ndotl * sqrt( ndotv * ( ndotv - ndotv * m2 ) + m2 );\n\tfloat visL\t= ndotv * sqrt( ndotl * ( ndotl - ndotl * m2 ) + m2 );\n\treturn 0.5 \/ max( visV + visL, 0.00001 );\n}\n\nfloat DistributionTerm( float roughness, float ndoth )\n{\n\tfloat m2\t= roughness * roughness;\n\tfloat d\t\t= ( ndoth * m2 - ndoth ) * ndoth + 1.0;\n\treturn m2 \/ ( d * d * MATH_PI );\n}\n\nvec3 FresnelTerm( vec3 specularColor, float vdoth )\n{\n\tvec3 fresnel = clamp( 50.0 * specularColor.y, 0.0, 1.0 ) * specularColor + ( 1.0 - specularColor ) * pow( ( 1.0 - vdoth ), 5.0 );\n\treturn fresnel;\n}\n\nvec3 LightSpecular( vec3 normal, vec3 viewDir, vec3 lightDir, vec3 lightColor, float roughness, vec3 specularColor )\n{\n\tvec3 halfVec = normalize( viewDir + lightDir );\n\n\tfloat vdoth = clamp( dot( viewDir,\thalfVec\t ), 0.0, 1.0 );\n\tfloat ndoth\t= clamp( dot( normal,\thalfVec\t ), 0.0, 1.0 );\n\tfloat ndotv = clamp( dot( normal,\tviewDir  ), 0.0, 1.0 );\n\tfloat ndotl = clamp( dot( normal,\tlightDir ), 0.0, 1.0 );\n    \n   \tvec3\tf = FresnelTerm( specularColor, vdoth );\n\tfloat\td = DistributionTerm( roughness, ndoth );\n\tfloat\tv = VisibilityTerm( roughness, ndotv, ndotl );\n    \n    vec3 specular;\n\tspecular = lightColor * f * ( d * v * MATH_PI * ndotl );\n\treturn specular;\n}\n\nfloat Cylinder( vec3 p, float r, float height ) \n{\n\tfloat d = length( p.xz ) - r;\n\td = max( d, abs( p.y ) - height );\n\treturn d;\n}\n\nfloat Sphere( vec3 p, float s )\n{\n\treturn length( p ) - s;\n}\n\nfloat Box( vec3 p, vec3 b )\n{\n\tvec3 d = abs( p ) - b;\n\treturn min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\nfloat Substract( float a, float b )\n{\n    return max( a, -b );\n}\n\nfloat SubstractRound( float a, float b, float r ) \n{\n\tvec2 u = max( vec2( r + a, r - b ), vec2( 0.0, 0.0 ) );\n\treturn min( -r, max( a, -b ) ) + length( u );\n}\n\nfloat Union( float a, float b )\n{\n    return min( a, b );\n}\n\nfloat UnionRound( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5 * ( b - a ) \/ k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * ( 1.0 - h );\n}\n\nfloat TriPrism( vec3 p, vec3 h )\n{        \n    vec3 q = abs( p );\n    return max( q.y - h.y, max( q.z * 0.866025 + p.x * h.z, -p.x ) - h.x * 0.5 );\n}\n\nfloat Scene( vec3 p, mat3 localToWorld )\n{\n    p = p * localToWorld;\n    \n    \/\/ ring\n    float a = Cylinder( p, 1.0, 0.1 );\n    float b = Cylinder( p + vec3( 0.12, 0.0, 0.0 ), 0.9, 0.2 ); \n    float ring = Substract( a, b );\n    \n    \/\/ nail\n    float c = Box( p + vec3( -0.8, 0.0, 0.0 ), vec3( 0.4, 0.1, 0.1 ) );\n    float d = Box( p + vec3( -0.4, 0.0, 0.0 ), vec3( 0.02, 0.1, 0.25 ) );\n    float e = TriPrism( p + vec3( -1.274, 0.0, 0.0 ), vec3( 0.149, 0.1, 0.16 ) );\n    float nail = Union( UnionRound( c, d, 0.1 ), e );\n    \n    \/\/ dents\n    float f = TriPrism( p + vec3( +0.08, 0.0, -0.85 ), vec3( 0.1, 0.2, 0.5 ) );\n    float g = TriPrism( p + vec3( -0.45, 0.0, -0.4 ), vec3( 0.1, 0.2, 0.16 ) );\n    float h = TriPrism( p + vec3( -0.8, 0.0, -0.65 ), vec3( 0.08, 0.2, 0.16 ) );\n    float i = TriPrism( p + vec3( -0.9, 0.0, 0.3 ), vec3( 0.04, 0.2, 0.16 ) );\n    float j = TriPrism( p + vec3( +0.3, 0.0, 0.68 ), vec3( 0.28, 0.2, 0.16 ) );\n    float k = TriPrism( p + vec3( -0.45, 0.0, -0.94 ), vec3( 0.07, 0.2, 0.5 ) );\n    float l = TriPrism( p + vec3( 0.0, 0.0, 1.06 ), vec3( 0.1, 0.2, 0.5 ) );\n\n    float dents = Union( Union( Union( Union( Union( Union( f, g ), h ), i ), j ), k ), l );\n    ring = SubstractRound( ring, dents, 0.03 );\n    \n    float ret = Union( ring, nail );\n\treturn ret;\n}\n\nfloat CastRay( in vec3 ro, in vec3 rd, mat3 localToWorld )\n{\n    const float maxd = 5.0;\n    \n\tfloat h = 0.5;\n    float t = 0.0;\n   \n    for ( int i = 0; i < 50; ++i )\n    {\n        if ( h < 0.001 || t > maxd ) \n        {\n            break;\n        }\n        \n\t    h = Scene( ro + rd * t, localToWorld );\n        t += h;\n    }\n\n    if ( t > maxd )\n    {\n        t = -1.0;\n    }\n\t\n    return t;\n}\n\nvec3 SceneNormal( in vec3 pos, mat3 localToWorld )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    Scene( pos + eps.xyy, localToWorld ) - Scene( pos - eps.xyy, localToWorld ),\n\t    Scene( pos + eps.yxy, localToWorld ) - Scene( pos - eps.yxy, localToWorld ),\n\t    Scene( pos + eps.yyx, localToWorld ) - Scene( pos - eps.yyx, localToWorld ) );\n\treturn normalize( -nor );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy \/ iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n\tp.x *= iResolution.x \/ iResolution.y;\n\n\tvec3 rayOrigin \t= vec3( 0.0, -0.28, -3.5 );\n    vec3 rayDir \t= normalize( vec3( p.x, p.y, 2.0 ) );\n    \n    float theta = -0.5 * MATH_PI;\n    mat3 rotX = mat3(\n        vec3( cos( theta ), sin( theta ), 0.0 ),\n        vec3( -sin( theta ), cos( theta ), 0.0 ),\n\t\tvec3( 0.0, 0.0, 1.0 )\n        );    \n    \n    vec2 mo = iMouse.xy \/ iResolution.xy;    \n    float phi = 0.25 * MATH_PI + 2.0 * iTime + 10.0 * mo.x;    \n    mat3 rotY = mat3(\n        vec3( 1.0, 0.0, 0.0 ),\n        vec3( 0.0, cos( phi ), sin( phi ) ),\n        vec3( 0.0, -sin( phi ), cos( phi ) )\n        );\n    \n    mat3 localToWorld = rotX * rotY;    \n\n\n\tvec3 color = texture( iChannel0, q ).yyy * 0.3;\n    \n\tfloat t = CastRay( rayOrigin, rayDir, localToWorld );\n    if ( t > 0.0 )\n    {\n        vec3 pos = rayOrigin + t * rayDir;\n        vec3 normal = SceneNormal( pos, localToWorld );\n        vec3 lightDir = normalize( vec3( 0.5, 0.3, 1.0 ) );\n        vec3 lightColor = vec3( 1.6 );\n        \n        vec3 posLS = pos * localToWorld;\n        vec3 nrmLS = normal * localToWorld;\n        vec2 uvX = posLS.yz;\n        vec2 uvY = posLS.xz;\n        vec2 uvZ = posLS.xy;\n        \n        vec3 textureX = texture( iChannel0, uvX ).xyz;\n        vec3 textureY = texture( iChannel0, uvY ).xyz;\n        vec3 textureZ = texture( iChannel0, uvZ ).xyz;\n        \n        vec3 weights = max( abs( nrmLS ), 0.00001 );\n\t\tweights \/= weights.x + weights.y + weights.z;\n        \n        vec3 texture = textureX * weights.x + textureY * weights.y + textureZ * weights.z;\n        \n        float rustMask = clamp( texture.x * 3.0 - 0.5, 0.0, 1.0 );\n                \n        vec3 diffuseColor = mix( vec3( 0.0 ), texture, rustMask );\n        diffuseColor *= diffuseColor * vec3( 0.94, 0.72, 0.47 ) * 1.5;\n        vec3 specularColor = mix( texture, vec3( 0.04 ), rustMask );\n        float roughness = mix( 0.2, 0.6, rustMask );\n        \n        vec3 diffuse = lightColor * clamp( dot( normal, lightDir ), 0.0, 1.0 );\n        color = diffuseColor * ( diffuse + 0.2 );\n        color += LightSpecular( normal, rayDir, lightDir, lightColor, roughness, specularColor );\n    }\n    \n    fragColor = vec4( color, 1.0 );\n}\n\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"MscSDB","date":"1463060978","viewed":9843,"name":"Cellular Tiled Tunnel","username":"Shane","description":"Using a cheaply constructed 3D cellular tile to emulate a 2nd order Voronoi surface in realtime.","likes":188,"published":3,"flags":0,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"\/media\/a\/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"\/media\/ap\/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/*\n\n    Cellular Tiled Tunnel\n    ---------------------\n    \n    I've always liked the look of a 2nd order Voronoi surface. IQ's Leizex demo is a great\n\tprerendered example, and for anyone who can remember, Tomasz Dobrowolski's Suboceanic\n\twas cutting edge back in the day.\n\n\tAnyway, I've always wanted to get a proper example working in a shader... Yeah, I need\n\tbigger dreams. :) Unfortunately, I kind of realized that it wasn't going to be possible \n\tuntil GPUs become even faster than they already are, so I figured I'd try the next best \n\tthing and come up with a way to emulate the look with something cheap. This is the \n\tresult. It's not perfect, but it looks surprisingly similar.\n\n\tThe regular 2nd order Voronoi algorithm involves a \"lot\" of operations. In general,\n\t27 cell checks - all involving a bunch of vector arithmetic, fract, sin, floor, \n\tcomparisons, etc... It's possible to cut down on cell checks, perform a bunch of\n\toptimizations, etc, but it's still too much work for a raymarcher.\n\n\tThe surface here is produced via a repeat 3D tile approach. The look is achieved by \n\tperforming 2nd order distance checks on the tiles. I used a highly scientific approach\n\twhich involved crossing my fingers, doing the distance checks and hoping for the best. :)\n\tAmazingly, it produced the result I was looking for.\n\n\tI covered the tile construction in other \"cell tile\" examples, so I'll spare you the \n\tdetails, but it's pretty simple. The only additions here are the second order distance\n\tchecks.\n\n\tIn order to show the surface itself, I've made the example geometric looking - I hope\n\tyou like brown, or whatever color that is. :) Note that individual cell regions are \n\tcolored\tdifferently. I did that to show that it could be done, but I'm not convinced \n\tthat it adds to the aesthetics in any meaningful way.\n\n\tAnyway, I have a few more interesting examples that I'll put up pretty soon.\n\t\n    Related examples: \n\n    Cellular Tiling - Shane\n    https:\/\/www.shadertoy.com\/view\/4scXz2\n\n\t\/\/ For comparison, this example uses the standard 2nd order Voronoi algorithm. For fun,\n\t\/\/ I dropped the cell tile routine into it and it ran a lot faster.\n\tVoronoi - rocks - iq\n\thttps:\/\/www.shadertoy.com\/view\/MsXGzM\n\n\trgba leizex - Inigo Quilez\n\thttp:\/\/www.pouet.net\/prod.php?which=51829\n\thttps:\/\/www.youtube.com\/watch?v=eJBGj8ggCXU\n\thttps:\/\/iquilezles.org\/prods\/index.htm\n\n\tTomasz Dobrowolski - Suboceanic\n\thttp:\/\/www.pouet.net\/prod.php?which=18343\n\n*\/\n\n#define PI 3.14159265358979\n#define FAR 50. \/\/ Maximum allowable ray distance.\n\n\/\/ Grey scale.\nfloat getGrey(vec3 p){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\n\n\/\/ Non-standard vec3-to-vec3 hash function.\nvec3 hash33(vec3 p){ \n    \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\n\/\/ 2x2 matrix rotation.\nmat2 rot2(float a){\n    \n    float c = cos(a); float s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\n\/\/ Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); \/\/ max(abs(n), 0.001), etc.\n    n \/= (n.x + n.y + n.z );  \n    \n\tvec3 tx = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    \n    return tx*tx;\n}\n\n\n\/\/ The cellular tile routine. Draw a few objects (four spheres, in this case) using a minumum\n\/\/ blend at various 3D locations on a cubic tile. Make the tile wrappable by ensuring the \n\/\/ objects wrap around the edges. That's it.\n\/\/\n\/\/ Believe it or not, you can get away with as few as three spheres. If you sum the total \n\/\/ instruction count here, you'll see that it's way, way lower than 2nd order 3D Voronoi.\n\/\/ Not requiring a hash function provides the biggest benefit, but there is also less setup.\n\/\/ \n\/\/ The result isn't perfect, but 3D cellular tiles can enable you to put a Voronoi looking \n\/\/ surface layer on a lot of 3D objects for little cost.\n\/\/\nfloat drawSphere(in vec3 p){\n    \n    \/\/ Anything that wraps the domain will suffice, so any of the following will work.\n    \/\/p = cos(p*3.14159)*0.5; \n    \/\/p = abs(cos(p*3.14159)*0.5);    \n    p = fract(p)-.5;    \n    \n    return dot(p, p);\n    \n    \/\/ Other metrics to try.\n    \n    \/\/p = abs(fract(p)-.5);\n    \/\/return dot(p, vec3(.5));\n    \n    \/\/p = abs(fract(p)-.5);\n    \/\/return max(max(p.x, p.y), p.z);\n    \n    \/\/p = cos(p*3.14159)*0.5; \n    \/\/p = abs(cos(p*3.14159)*0.5);\n    \/\/p = abs(fract(p)-.5);\n    \/\/return max(max(p.x - p.y, p.y - p.z), p.z - p.x);\n    \/\/return min(min(p.x - p.y, p.y - p.z), p.z - p.x);\n    \n}\n\n\/\/ Faster (I'm assuming), more streamlined version. See the comments below for an expanded explanation.\n\/\/ The function below is pretty quick also, and can be expanded to include more spheres. This one\n\/\/ takes advantage of the fact that only four object need sorting. With three spheres, it'd be even\n\/\/ better.\nfloat cellTile(in vec3 p){\n    \n    \/\/ Draw four overlapping objects (spheres, in this case) at various positions throughout the tile.\n    vec4 v, d; \n    d.x = drawSphere(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.y = drawSphere(p - vec3(.39, .2, .11));\n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawSphere(p - vec3(.62, .24, .06));\n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071;\n    d.w = drawSphere(p - vec3(.2, .82, .64));\n\n    v.xy = min(d.xz, d.yw), v.z = min(max(d.x, d.y), max(d.z, d.w)), v.w = max(v.x, v.y); \n   \n    d.x =  min(v.z, v.w) - min(v.x, v.y); \/\/ Maximum minus second order, for that beveled Voronoi look. Range [0, 1].\n    \/\/d.x =  min(v.x, v.y);\n        \n    return (d.x*2.66); \/\/ Normalize... roughly.\n    \n}\n\n\/*\n\/\/ Draw some spheres throughout a repeatable cubic tile. The offsets were partly based on \n\/\/ science, but for the most part, you could choose any combinations you want. Note the \n\/\/ normalized planar positional roation between sphere rendering to really mix things up. This \n\/\/ particular function is used by the raymarcher, so involves fewer spheres.\n\/\/\nfloat cellTile(in vec3 p){\n\n    \/\/ Storage for the closest distance metric, second closest and the current\n    \/\/ distance for comparisson testing.\n    \/\/\n    \/\/ Set the maximum possible value - dot(vec3(.5), vec3(.5)). I think my reasoning is\n    \/\/ correct, but I have lousy deductive reasoning, so you may want to double check. :)\n    vec3 d = (vec3(.75)); \n   \n    \n    \/\/ Draw some overlapping objects (spheres, in this case) at various positions on the tile.\n    \/\/ Then do the fist and second order distance checks. Very simple.\n    d.z = drawSphere(p - vec3(.81, .62, .53));\n    d.x = min(d.x, d.z); \/\/d.y = max(d.x, min(d.y, d.z)); \/\/ Not needed on the first iteration.\n    \n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.z = drawSphere(p - vec3(.39, .2, .11));\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    \n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawSphere(p - vec3(.62, .24, .06));\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    \n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071; \n    d.z = drawSphere(p - vec3(.2, .82, .64));\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n\n     \n\t\/\/ More spheres means better patterns, but slows things down.\n    \/\/p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    \/\/d.z = drawSphere(p - vec3(.48, .29, .2));\n    \/\/d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    \n    \/\/p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    \/\/d.z = drawSphere(p - vec3(.06, .87, .78));\n    \/\/d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z); \n\t\n\n    \n    \/\/ Returning what I'm hoping is a normalized result. Not that it\n    \/\/ matters too much, but I'd like it normalized.\n    \/\/ 2.66 seems to work, but I'll double check at some stage.\n    \/\/ d.x: Minimum distance. Regular round Voronoi looking.\n    \/\/ d.y - d.x - Maximum minus minimum, for that beveled Voronoi look.\n    \/\/\n    return (d.y - d.x)*2.66; \n    \/\/return 1. - d.x*2.66;\n    \/\/return 1. - sqrt(d.x)*1.63299; \/\/ etc.\n\n    \n}\n*\/\n\n\/\/ Just like the function above, but used to return the regional cell ID...\n\/\/ kind of. Either way, it's used to color individual raised sections in\n\/\/ the same way that a regular Voronoi function can. It's only called once,\n\/\/ so doesn't have to be particularly fast. It's kept separate to the\n\/\/ raymarched version, because you don't want to be performing ID checks\n\/\/ several times a frame when you don't have to. By the way, that applies\n\/\/ to identifying any object in any scene.\n\/\/\n\/\/ By the way, it's customary to bundle the respective distance and cell\n\/\/ ID into a vector (vec3(d.x, d.y, cellID)) and return that, but I'm \n\/\/ keeping it simple here.\n\/\/\nint cellTileID(in vec3 p){\n    \n    int cellID = 0;\n    \n    \/\/ Storage for the closest distance metric, second closest and the current\n    \/\/ distance for comparisson testing.\n    vec3 d = (vec3(.75)); \/\/ Set the maximum.\n    \n    \/\/ Draw some overlapping objects (spheres, in this case) at various positions on the tile.\n    \/\/ Then do the fist and second order distance checks. Very simple.\n    d.z = drawSphere(p - vec3(.81, .62, .53)); if(d.z<d.x) cellID = 1;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    \n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.z = drawSphere(p - vec3(.39, .2, .11)); if(d.z<d.x) cellID = 2;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    \n    \n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawSphere(p - vec3(.62, .24, .06)); if(d.z<d.x) cellID = 3;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n   \n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071; \n    d.z = drawSphere(p - vec3(.2, .82, .64)); if(d.z<d.x) cellID = 4;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n\n\/* \n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.z = drawSphere2(p - vec3(.48, .29, .2)); if(d.z<d.x) cellID = 5;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    \n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawSphere2(p - vec3(.06, .87, .78)); if(d.z<d.x) cellID = 6;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z); \n*\/ \n    \n    return cellID;\n    \n}\n\n\n\/\/ The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ float s = sin(z\/24.)*cos(z\/16.); return vec2(s*9., 0); }\n\n\/\/ Standard tunnel distance function with some perturbation thrown into the mix. A tunnel is just a tube \n\/\/ with a smoothly shifting center as you traverse lengthwise. The walls of the tube are perturbed by the\n\/\/ cheap 3D surface function I described above.\nfloat map(vec3 p){\n\n    \n    float sf = cellTile(p\/2.5);\n    \n    \/\/ Tunnel bend correction, of sorts. Looks nice, but slays framerate, which is disappointing. I'm\n    \/\/ assuming that \"tan\" function is the bottleneck, but I can't be sure.\n    \/\/vec2 g = (path(p.z + 0.1) - path(p.z - 0.1))\/0.2;\n    \/\/g = cos(atan(g));\n    p.xy -= path(p.z);\n    \/\/p.xy *= g;\n  \n    \/\/ Round tunnel.\n    \/\/ For a round tunnel, use the Euclidean distance: length(p.xy).\n    return 1.- length(p.xy*vec2(0.5, 0.7071)) + (0.5-sf)*.35;\n\n    \n\/*\n    \/\/ Rounded square tunnel using Minkowski distance: pow(pow(abs(tun.x), n), pow(abs(tun.y), n), 1\/n)\n    vec2 tun = abs(p.xy)*vec2(0.5, 0.7071);\n    tun = pow(tun, vec2(8.));\n    float n =1.-pow(tun.x + tun.y, 1.0\/8.) + (0.5-sf)*.35;\n    return n;\/\/min(n, p.y + FH);\n*\/\n    \n\/*\n    \/\/ Square tunnel.\n    \/\/ For a square tunnel, use the Chebyshev(?) distance: max(abs(tun.x), abs(tun.y))\n    vec2 tun = abs(p.xy - path(p.z))*vec2(0.5, 0.7071);\n    float n = 1.- max(tun.x, tun.y) + (0.5-sf)*.5;\n    return n;\n*\/\n \n}\n\n\n\/\/ Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    float t = 0.0, h;\n    for(int i = 0; i < 96; i++){\n    \n        h = map(ro+rd*t);\n        \/\/ Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        \/\/ \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<0.002*(t*.125 + 1.) || t>FAR) break; \/\/ Alternative: 0.001*max(t*.25, 1.)\n        t += h*.8;\n        \n    }\n\n    return min(t, FAR);\n    \n}\n\n\/\/ Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n\/\/ make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    \/\/ Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; \/\/ Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )\/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); \/\/ Bumped normal. \"bf\" - bump factor.\n    \n}\n\n\n\/\/ Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ. By the way, there is an \n\/\/ aesthetic difference between this and the regular six tap version. Sometimes, it's noticeable,\n\/\/ and other times, like this example, it's not.\nvec3 calcNormal(in vec3 p){\n\n    \/\/ Note the slightly increased sampling distance, to alleviate artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.0025, -0.0025); \n    return normalize(e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n\n\/*\n\/\/ Standard normal function. 6 taps.\nvec3 calcNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.005, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n*\/\n\n\/\/ Ambient occlusion, for that self shadowed look. Based on the original by XT95. I love this \n\/\/ function, and in many cases, it gives really, really nice results. For a better version, and \n\/\/ usage, refer to XT95's examples below:\n\/\/\n\/\/ Hemispherical SDF AO - https:\/\/www.shadertoy.com\/view\/4sdGWN\n\/\/ Alien Cocoons - https:\/\/www.shadertoy.com\/view\/MsdGz2\nfloat calculateAO( in vec3 p, in vec3 n )\n{\n\tfloat ao = 0.0, l;\n    const float maxDist = 2.;\n\tconst float nbIte = 6.0;\n\t\/\/const float falloff = 0.9;\n    for( float i=1.; i< nbIte+.5; i++ ){\n    \n        l = (i*.75 + fract(cos(i)*45758.5453)*.25)\/nbIte*maxDist;\n        \n        ao += (l - map( p + n*l ))\/(1.+ l);\/\/ \/ pow(1.+l, falloff);\n    }\n\t\n    return clamp(1.- ao\/nbIte, 0., 1.);\n}\n\n\/\/ Cool curve function, by Shadertoy user, Nimitz.\n\/\/\n\/\/ From an intuitive sense, the function returns a weighted difference between a surface \n\/\/ value and some surrounding values. Almost common sense... almost. :)\n\/\/\n\/\/ Original usage (I think?) - Cheap curvature: https:\/\/www.shadertoy.com\/view\/Xts3WM\n\/\/ Other usage: Xyptonjtroz: https:\/\/www.shadertoy.com\/view\/4ts3z2\nfloat curve(in vec3 p, in float w){\n\n    vec2 e = vec2(-1., 1.)*w;\n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return 0.125\/(w*w) *(t1 + t2 + t3 + t4 - 4.*map(p));\n}\n\n\/*\n\/\/ Oldschool hatching effect. Interesting under the right circumstances.\nvec3 ch(in vec3 col, in vec2 fragCoord){\n    \n    vec3 fColor = col;\n    \n    float lum = dot(col, vec3(.299, .587, .114));\/\/ length(col);\n\tfloat mx = 1.\/7.; \/\/ 1.732\/7.;\n    \n    float rgt = fragCoord.x + fragCoord.y;\n    float lft = fragCoord.x - fragCoord.y;\n    \n    fColor = col*4.; col *= .6;\n    \n    if (lum < mx*6. && mod(rgt, 8.) == 0.) fColor = col;\n    if (lum < mx*5. && mod(lft, 8.) == 0.) fColor = col;\n    if (lum < mx*4. && mod(rgt, 4.) == 0.) fColor = col;\n    if (lum < mx*3. && mod(lft, 4.) == 0.) fColor = col;\n    if (lum < mx*2. && mod(rgt, 2.) == 0.) fColor = col;\n    if (lum < mx*1. && mod(lft, 2.) == 0.) fColor = col;\n    \n    return min(fColor, 1.);\n}\n*\/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n\n\t\/\/ Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*0.5)\/iResolution.y;\n\t\n\t\/\/ Camera Setup.\n\tvec3 lookAt = vec3(0.0, 0.0, iTime*6.);  \/\/ \"Look At\" position.\n\tvec3 camPos = lookAt + vec3(0.0, 0.1, -0.5); \/\/ Camera position, doubling as the ray origin.\n \n    \/\/ Light positioning. One is a little behind the camera, and the other is further down the tunnel.\n \tvec3 light_pos = camPos + vec3(0.0, 0.125, 4.125);\/\/ Put it a bit in front of the camera.\n\tvec3 light_pos2 = camPos + vec3(0.0, 0.0, 8.0);\/\/ Put it a bit in front of the camera.\n\n\t\/\/ Using the Z-value to perturb the XY-plane.\n\t\/\/ Sending the camera, \"look at,\" and two light vectors down the tunnel. The \"path\" function is \n\t\/\/ synchronized with the distance function. Change to \"path2\" to traverse the other tunnel.\n\tlookAt.xy += path(lookAt.z);\n\tcamPos.xy += path(camPos.z);\n\tlight_pos.xy += path(light_pos.z);\n\tlight_pos2.xy += path(light_pos2.z);\n\n    \/\/ Using the above to produce the unit ray-direction vector.\n    float FOV = PI\/3.; \/\/ FOV - Field of view.\n    vec3 forward = normalize(lookAt-camPos);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    \/\/ rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    \n    \/\/ Swiveling the camera from left to right when turning corners.\n    rd.xy = rot2( path(lookAt.z).x\/32. )*rd.xy;\n\t\t\n    \/\/ Standard ray marching routine.\n    float t = trace(camPos, rd);\n\t\n    \/\/ The final scene color. Initated to black.\n\tvec3 sceneCol = vec3(0.);\n\t\n\t\/\/ The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n\t\n    \t\n    \t\/\/ Surface position and surface normal.\n\t    vec3 sp = t * rd+camPos;\n\t    vec3 sn = calcNormal(sp);\n        \n        \/\/ Texture scale factor.\n        const float tSize0 = 1.\/1.; \n        const float tSize1 = 1.\/1.;\n    \t\n    \t\/\/ Texture-based bump mapping.\n\t    \/\/if (sp.y<-(FH-0.005)) sn = doBumpMap(iChannel1, sp*tSize1, sn, 0.025); \/\/ Floor.\n\t    \/\/else sn = doBumpMap(iChannel0, sp*tSize0, sn, 0.025); \/\/ Walls.\n        \n        sn = doBumpMap(iChannel0, sp*tSize0, sn, 0.02);\n        \/\/sn = doBumpMap(sp, sn, 0.01);\n\t    \n\t    \/\/ Ambient occlusion.\n\t    float ao = calculateAO(sp, sn);\n    \t\n    \t\/\/ Light direction vectors.\n\t    vec3 ld = light_pos-sp;\n\t    vec3 ld2 = light_pos2-sp;\n\n        \/\/ Distance from respective lights to the surface point.\n\t    float lDdist = max(length(ld), 0.001);\n\t    float lDdist2 = max(length(ld2), 0.001);\n    \t\n    \t\/\/ Normalize the light direction vectors.\n\t    ld \/= lDdist;\n\t    ld2 \/= lDdist2;\n\t    \n\t    \/\/ Light attenuation, based on the distances above. In case it isn't obvious, this\n        \/\/ is a cheap fudge to save a few extra lines. Normally, the individual light\n        \/\/ attenuations would be handled separately... No one will notice, or care. :)\n\t    float atten = 1.\/(1. + lDdist*.125 + lDdist*lDdist*.05);\n        float atten2 =  1.\/(1. + lDdist2*.125 + lDdist2*lDdist2*.05);\n    \t\n    \t\/\/ Ambient light.\n\t    float ambience = 0.75;\n    \t\n    \t\/\/ Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.0);\n\t    float diff2 = max( dot(sn, ld2), 0.0);\n    \t\n    \t\/\/ Specular lighting.\n\t    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.);\n\t    float spec2 = pow(max( dot( reflect(-ld2, sn), -rd ), 0.0 ), 32.);\n    \t\n    \t\/\/ Curvature.\n\t    float crv = clamp(curve(sp, 0.125)*0.5+0.5, .0, 1.);\n\t    \n\t    \/\/ Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow( clamp(dot(sn, rd) + 1., .0, 1.), 1.);\n \n        \n        vec3 texCol = tex3D(iChannel0, sp*tSize0, sn);\n        texCol = min(texCol*1.5, 1.);\n        \/\/texCol = vec3(1)*dot(texCol, vec3(0.299, 0.587, 0.114));\n        \/\/texCol = smoothstep(-.0, .6, texCol); \/\/ etc.\n        \n        \/\/texCol = texCol*vec3(1., .5, .2); \n        int id = cellTileID(sp\/2.5);\n        if(id == 4) texCol = texCol*vec3(1., .5, .3); \n        if(id == 3) texCol = texCol*.5 + texCol*vec3(.5, .25, .15); \n        \n    \t\n    \t\/\/ Darkening the crevices. Otherwise known as cheap, scientifically-incorrect shadowing.\t\n\t    float shading =  crv*0.75+0.25; \n    \t\n    \t\/\/ Combining the above terms to produce the final color. It was based more on acheiving a\n        \/\/ certain aesthetic than science.\n        \/\/\n        \/\/ Shiny.\n        sceneCol = (texCol*(diff + ambience + spec) + spec*vec3(.7, .9, 1))*atten;\n        sceneCol += (texCol*(diff2 + ambience + spec2) + spec2*vec3(.7, .9, 1))*atten2;\n        \/\/\n        \/\/ Other combinations:\n        \/\/\n        \/\/ Glow.\n        \/\/float gr = dot(texCol, vec3(0.299, 0.587, 0.114));\n        \/\/sceneCol = (gr*(diff + ambience*0.25) + spec*texCol*2. + fre*crv*texCol.zyx*2.)*atten;\n        \/\/sceneCol += (gr*(diff2 + ambience*0.25) + spec2*texCol*2. + fre*crv*texCol.zyx*2.)*atten2;\n        \n        \/\/ Shading.\n        sceneCol *= shading*ao;\n        \n        \/\/ Drawing the lines on the surface.      \n        sceneCol *= clamp(abs(curve(sp, 0.035)), .0, 1.)*.5 + 1.;  \/\/ Glow lines.\n        sceneCol *= 1. - smoothstep(0., 4., abs(curve(sp, 0.0125)))*vec3(.82, .85, .88); \/\/ Darker.\n\t   \n\t\n\t}\n    \n    \/\/ Some simple post processing effects.\n    \/\/float a = dot(sceneCol, vec3(0.299, 0.587, 0.114));\n    \/\/sceneCol = min(vec3(a*3., pow(a, 2.5)*2., pow(a, 6.)), 1.); \/\/ Fire palette.\n    \/\/sceneCol = floor(sceneCol*15.999)\/15.; \/\/ Oldschool effect.  \n    \/\/ Oldschool hatching effect. Uncomment the \"ch\" function to use this one.\n    \/\/sceneCol = ch(clamp(sceneCol, 0., 1.), fragCoord); \n\t\n\tfragColor = vec4(sqrt(clamp(sceneCol, 0., 1.)), 1.0);\n    \n\t\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4dG3RW","date":"1453367766","viewed":9843,"name":"Molecular Dynamics","username":"dr2","description":"Molecular dynamics simulation of soft disks","likes":80,"published":3,"flags":32,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\/\/ \"Molecular Dynamics\" by dr2 - 2016\n\/\/ License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n\/*\nSimple but inefficient MD program for 2D soft disks. The algorithm\nparallelizes but is useless for large systems.\n\nStoring non-pixel data in textures follows iq's approach.\n\nSince the refresh rate is limited to 60 fps, doing multiple compute steps \nbetween display updates improves performance. Pixel-based rendering of \nlarge numbers of disks is also time consuming. \n\nMouse click restarts run.\n*\/\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 32.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi \/ txRow)) + 0.5) \/\n     txSize);\n}\n\nconst int nMolEdge = 20;\nconst int nMol = nMolEdge * nMolEdge;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec3 col;\n  vec2 uv, ut, q;\n  float bFac, dMin, b;\n  uv = 2. * fragCoord \/ iResolution.xy - 1.;\n  uv.x *= iResolution.x \/ iResolution.y;\n  ut = abs (uv) - vec2 (1.);\n  b = max (ut.x, ut.y);\n  ut = abs (ut);\n  if (b > 0.003) col = vec3 (0.82);\n  else if (b < 0. && min (ut.x, ut.y) < 0.01) col = vec3 (0.3, 0.3, 1.);\n  else {\n    bFac = Loadv4 (nMol).y;\n    q = 0.5 * (bFac * float (nMolEdge) + 0.5) * uv;\n    dMin = 1000.;\n    for (int n = 0; n < nMol; n ++)\n       dMin = min (dMin, length (q - Loadv4 (n).xy));\n    col = mix (vec3 (0.2),  vec3 (0., 1., 0.), 1. - smoothstep (0.4, 0.5, dMin));\n  }\n  fragColor = vec4 (col, 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ \"Molecular Dynamics\" by dr2 - 2016\n\/\/ License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n#define mPtr iMouse\n\nfloat Hashff (float p)\n{\n  const float cHashM = 43758.54;\n  return fract (sin (p) * cHashM);\n}\n\nconst float txRow = 32.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi \/ txRow)) + 0.5) \/\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  float fi = float (idVar);\n  vec2 d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi \/ txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n\nconst int nMolEdge = 20;\nconst int nMol = nMolEdge * nMolEdge;\nfloat bFac;\n\nvec4 Step (int mId)\n{\n  vec4 p, pp;\n  vec2 dr, f;\n  float rr, rri, rri3, rCut, rrCut, bLen, dt;\n  f = vec2 (0.);\n  p = Loadv4 (mId);\n  rCut = pow (2., 1.\/6.);\n  rrCut = rCut * rCut;\n  for (int n = 0; n < nMol; n ++) {\n    pp = Loadv4 (n);\n    dr = p.xy - pp.xy;\n    rr = dot (dr, dr);\n    if (n != mId && rr < rrCut) {\n      rri = 1. \/ rr;\n      rri3 = rri * rri * rri;\n      f += 48. * rri3 * (rri3 - 0.5) * rri * dr;\n    }\n  }\n  bLen = bFac * float (nMolEdge);\n  dr = 0.5 * (bLen + rCut) - abs (p.xy);\n  if (dr.x < rCut) {\n    if (p.x > 0.) dr.x = - dr.x;\n    rri = 1. \/ (dr.x * dr.x);\n    rri3 = rri * rri * rri;\n    f.x += 48. * rri3 * (rri3 - 0.5) * rri * dr.x;\n  }\n  if (dr.y < rCut) {\n    if (p.y > 0.) dr.y = - dr.y;\n    rri = 1. \/ (dr.y * dr.y);\n    rri3 = rri * rri * rri;\n    f.y += 48. * rri3 * (rri3 - 0.5) * rri * dr.y;\n  }\n  dt = 0.005;\n  p.zw += dt * f;\n  p.xy += dt * p.zw;\n  return p;\n}\n\nvec4 Init (int mId)\n{\n  vec4 p;\n  float x, y, t, vel;\n  const float pi = 3.14159;\n  y = float (mId \/ nMolEdge);\n  x = float (mId) - float (nMolEdge) * y;\n  t = 0.25 * (2. * mod (y, 2.) - 1.);\n  p.xy = (vec2 (x + t, y) - 0.5 * float (nMolEdge - 1));\n  t = 2. * pi * Hashff (float (mId));\n  vel = 3.;\n  p.zw = vel * vec2 (cos (t), sin (t));\n  return p;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat, p;\n  int mId;\n  vec2 kv = floor (fragCoord);\n  mId = int (kv.x + txRow * kv.y);\n  if (kv.x >= txRow || mId > nMol) discard;\n  if (iFrame <= 5) {\n    bFac = 1.1;\n    stDat = vec4 (0., bFac, 0., 0.);\n    if (mId < nMol) p = Init (mId);\n  } else {\n    stDat = Loadv4 (nMol);\n    ++ stDat.x;\n    bFac = stDat.y;\n    if (mId < nMol) p = Step (mId);\n    if (mPtr.z > 0. && stDat.x > 50.) {\n      stDat.x = 0.;\n      p = Init (mId);\n    }\n  }\n  Savev4 (mId, ((mId < nMol) ? p : stDat), fragColor, fragCoord);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/\/ \"Molecular Dynamics\" by dr2 - 2016\n\/\/ License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n#define mPtr iMouse\n\nfloat Hashff (float p)\n{\n  const float cHashM = 43758.54;\n  return fract (sin (p) * cHashM);\n}\n\nconst float txRow = 32.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi \/ txRow)) + 0.5) \/\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  float fi = float (idVar);\n  vec2 d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi \/ txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n\nconst int nMolEdge = 20;\nconst int nMol = nMolEdge * nMolEdge;\nfloat bFac;\n\nvec4 Step (int mId)\n{\n  vec4 p, pp;\n  vec2 dr, f;\n  float rr, rri, rri3, rCut, rrCut, bLen, dt;\n  f = vec2 (0.);\n  p = Loadv4 (mId);\n  rCut = pow (2., 1.\/6.);\n  rrCut = rCut * rCut;\n  for (int n = 0; n < nMol; n ++) {\n    pp = Loadv4 (n);\n    dr = p.xy - pp.xy;\n    rr = dot (dr, dr);\n    if (n != mId && rr < rrCut) {\n      rri = 1. \/ rr;\n      rri3 = rri * rri * rri;\n      f += 48. * rri3 * (rri3 - 0.5) * rri * dr;\n    }\n  }\n  bLen = bFac * float (nMolEdge);\n  dr = 0.5 * (bLen + rCut) - abs (p.xy);\n  if (dr.x < rCut) {\n    if (p.x > 0.) dr.x = - dr.x;\n    rri = 1. \/ (dr.x * dr.x);\n    rri3 = rri * rri * rri;\n    f.x += 48. * rri3 * (rri3 - 0.5) * rri * dr.x;\n  }\n  if (dr.y < rCut) {\n    if (p.y > 0.) dr.y = - dr.y;\n    rri = 1. \/ (dr.y * dr.y);\n    rri3 = rri * rri * rri;\n    f.y += 48. * rri3 * (rri3 - 0.5) * rri * dr.y;\n  }\n  dt = 0.005;\n  p.zw += dt * f;\n  p.xy += dt * p.zw;\n  return p;\n}\n\nvec4 Init (int mId)\n{\n  vec4 p;\n  float x, y, t, vel;\n  const float pi = 3.14159;\n  y = float (mId \/ nMolEdge);\n  x = float (mId) - float (nMolEdge) * y;\n  t = 0.25 * (2. * mod (y, 2.) - 1.);\n  p.xy = (vec2 (x + t, y) - 0.5 * float (nMolEdge - 1));\n  t = 2. * pi * Hashff (float (mId));\n  vel = 3.;\n  p.zw = vel * vec2 (cos (t), sin (t));\n  return p;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat, p;\n  int mId;\n  vec2 kv = floor (fragCoord);\n  mId = int (kv.x + txRow * kv.y);\n  if (kv.x >= txRow || mId > nMol) discard;\n  if (iFrame <= 5) {\n    bFac = 1.1;\n    stDat = vec4 (0., bFac, 0., 0.);\n    if (mId < nMol) p = Init (mId);\n  } else {\n    stDat = Loadv4 (nMol);\n    ++ stDat.x;\n    bFac = stDat.y;\n    if (mId < nMol) p = Step (mId);\n    if (mPtr.z > 0. && stDat.x > 50.) {\n      stDat.x = 0.;\n      p = Init (mId);\n    }\n  }\n  Savev4 (mId, ((mId < nMol) ? p : stDat), fragColor, fragCoord);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\/\/ \"Molecular Dynamics\" by dr2 - 2016\n\/\/ License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n#define mPtr iMouse\n\nfloat Hashff (float p)\n{\n  const float cHashM = 43758.54;\n  return fract (sin (p) * cHashM);\n}\n\nconst float txRow = 32.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi \/ txRow)) + 0.5) \/\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  float fi = float (idVar);\n  vec2 d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi \/ txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n\nconst int nMolEdge = 20;\nconst int nMol = nMolEdge * nMolEdge;\nfloat bFac;\n\nvec4 Step (int mId)\n{\n  vec4 p, pp;\n  vec2 dr, f;\n  float rr, rri, rri3, rCut, rrCut, bLen, dt;\n  f = vec2 (0.);\n  p = Loadv4 (mId);\n  rCut = pow (2., 1.\/6.);\n  rrCut = rCut * rCut;\n  for (int n = 0; n < nMol; n ++) {\n    pp = Loadv4 (n);\n    dr = p.xy - pp.xy;\n    rr = dot (dr, dr);\n    if (n != mId && rr < rrCut) {\n      rri = 1. \/ rr;\n      rri3 = rri * rri * rri;\n      f += 48. * rri3 * (rri3 - 0.5) * rri * dr;\n    }\n  }\n  bLen = bFac * float (nMolEdge);\n  dr = 0.5 * (bLen + rCut) - abs (p.xy);\n  if (dr.x < rCut) {\n    if (p.x > 0.) dr.x = - dr.x;\n    rri = 1. \/ (dr.x * dr.x);\n    rri3 = rri * rri * rri;\n    f.x += 48. * rri3 * (rri3 - 0.5) * rri * dr.x;\n  }\n  if (dr.y < rCut) {\n    if (p.y > 0.) dr.y = - dr.y;\n    rri = 1. \/ (dr.y * dr.y);\n    rri3 = rri * rri * rri;\n    f.y += 48. * rri3 * (rri3 - 0.5) * rri * dr.y;\n  }\n  dt = 0.005;\n  p.zw += dt * f;\n  p.xy += dt * p.zw;\n  return p;\n}\n\nvec4 Init (int mId)\n{\n  vec4 p;\n  float x, y, t, vel;\n  const float pi = 3.14159;\n  y = float (mId \/ nMolEdge);\n  x = float (mId) - float (nMolEdge) * y;\n  t = 0.25 * (2. * mod (y, 2.) - 1.);\n  p.xy = (vec2 (x + t, y) - 0.5 * float (nMolEdge - 1));\n  t = 2. * pi * Hashff (float (mId));\n  vel = 3.;\n  p.zw = vel * vec2 (cos (t), sin (t));\n  return p;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat, p;\n  int mId;\n  vec2 kv = floor (fragCoord);\n  mId = int (kv.x + txRow * kv.y);\n  if (kv.x >= txRow || mId > nMol) discard;\n  if (iFrame <= 5) {\n    bFac = 1.1;\n    stDat = vec4 (0., bFac, 0., 0.);\n    if (mId < nMol) p = Init (mId);\n  } else {\n    stDat = Loadv4 (nMol);\n    ++ stDat.x;\n    bFac = stDat.y;\n    if (mId < nMol) p = Step (mId);\n    if (mPtr.z > 0. && stDat.x > 50.) {\n      stDat.x = 0.;\n      p = Init (mId);\n    }\n  }\n  Savev4 (mId, ((mId < nMol) ? p : stDat), fragColor, fragCoord);\n}\n","name":"Buffer C","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"XtSGDK","date":"1433417027","viewed":9820,"name":"Rotating Structure","username":"iq","description":"Another space flipping experiment, similar to [url]https:\/\/www.shadertoy.com\/view\/Xdf3Rn[\/url], [url]https:\/\/www.shadertoy.com\/view\/MsXGRf[\/url] and [url]https:\/\/www.shadertoy.com\/view\/4dsGD7[\/url]. I used an infinite grid like Kali's Inversion Machine.","likes":124,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"\/media\/a\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"\/media\/ap\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"\/media\/a\/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"\/media\/ap\/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\/\/ Copyright Inigo Quilez, 2015 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work neither\n\/\/ as it is or altered, here on Shadertoy or anywhere else, in any\n\/\/ form including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it or train a neural\n\/\/ network with it without permission. I share this Work for educational\n\/\/ purposes, and you can link to it, through an URL, proper attribution\n\/\/ and unmodified screenshot, as part of your educational material. If\n\/\/ these conditions are too restrictive please contact me and we'll\n\/\/ definitely work it out.\n\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2    \/\/ set AA to 1 if you have a slow machine  \n#endif\n\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nvec3 deform( in vec3 p, in float time, out float sca )\n{\n    float s = 0.34*sqrt(dot(p*p,p*p));\n    \/\/float s = 1.0;\n\n    p = p\/s;\n\n    p.xyz += 4.0*sin(0.5*vec3(1.0,1.1,1.3)*time+vec3(0.0,2.0,4.0));\n    \n    sca = s;\n    \n\treturn p;\n}\n\nfloat shape( vec3 p )\n{\n    vec3 q = mod( p+1.0, 2.0 ) -1.0;\n\n    float d1 = udRoundBox(q,vec3(0.10,0.02,1.00),0.02);\n    float d2 = udRoundBox(q,vec3(0.02,1.00,0.10),0.02);\n    float d3 = udRoundBox(q,vec3(1.00,0.10,0.02),0.02);\n    float d4 = udRoundBox(q,vec3(0.30,0.30,0.30),0.02);\n\n    return min( min(d1,d2), min(d3,d4) );\n}\n\nfloat map( vec3 p, float t )\n{\n    float s = 1.0;\n    p = deform( p, t, s );\n    return shape( p ) * s;\n}\n\nvec3 calcNormal( in vec3 pos, in float eps, in float t )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*map( pos + e.xyy, t ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, t ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, t ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, t ) );\n}\n\nvec3 calcNormal2( in vec3 pos, in float eps )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*shape( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*shape( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*shape( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*shape( pos + e.xxx ) );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        float h = 0.01 + 0.5*float(i)\/7.0;\n        occ += (h-shape( pos + h*nor ));\n    }\n    return clamp( 1.0 - 4.0*occ\/8.0, 0.0, 1.0 );    \n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float k, in float time )\n{\n    float res = 1.0;\n    float t = 0.01;\n    for( int i=0; i<32; i++ )\n    {\n        float h = map(ro + rd*t, time);\n        res = min( res, smoothstep(0.0,1.0,k*h\/t) );\n        t += clamp( h, 0.04, 0.1 );\n\t\tif( res<0.01 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n, in float k )\n{\n    vec3 m = pow( abs( n ), vec3(k) );\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n\treturn (x*m.x + y*m.y + z*m.z) \/ (m.x + m.y + m.z);\n}\n\nvec3 shade( in vec3 ro, in vec3 rd, in float t, float time )\n{\n    float eps = 0.001;\n    \n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormal( pos, eps, time );\n    float kk;\n    vec3 qos = deform( pos, time, kk );\n    vec3 qor = calcNormal2( qos, eps );\n\n    vec3 tex = texcube( iChannel0, qos*0.5, qor, 1.0 ).xyz;\n\n    vec3 lig = normalize( vec3(2.0,1.0,0.2) );\n\n    float fre = pow( clamp(1.0+dot(nor,rd), 0.0, 1.0 ), 2.0 );\n    float occ = calcAO( qos, qor );\n\n    float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n    float sha = softshadow( pos, lig, 64.0, time ); \n    dif *= sha;\n        \n    vec3 col = 2.0*vec3(1.1,0.8,0.6)*dif*(0.5+0.5*occ) + 0.6*vec3(0.1,0.27,0.4)*occ;\n    col += 1.0*fre*(0.5+0.5*dif)*occ;\n    float sh = 4.0 + tex.x*64.0;\n    col += 0.1*sh*pow(clamp(-dot(rd,nor),0.0,1.0),sh)*occ*sha;\n    col *= clamp(2.0*dot(pos,pos),0.0,1.0);\n\n    col *= 6.0*tex;\n    \n    col *= exp( -1.5*t );\n\n    return col;        \n}\n\nfloat intersect( in vec3 ro, in vec3 rd, const float maxdist, float time )\n{\n    float res = -1.0;\n    vec3 resP = vec3(0.0);\n    float t = 0.1;\n    for( int i=0; i<100; i++ )\n    {\n        vec3 p = ro + t*rd;\n        float h = map( p, time );\n        res = t;\n\n        if( h<(0.001*t) || t>maxdist ) break;\n        \n        t += h*0.5;\n    }\n\treturn res;\n}\n\nvec3 render( in vec3 ro, in vec3 rd, float time )\n{\n    vec3 col = vec3(0.0);\n    \n    const float maxdist = 32.0;\n    float t = intersect( ro, rd, maxdist, time );\n    if( t < maxdist )\n    {\n        col = shade( ro, rd, t, time );\n    }\n\n    return pow( col, vec3(0.55) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\nfloat hash1( uint n ) \n{\n    \/\/ integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))\/float(0x7fffffff);\n}\n\n\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n#if AA>1\n    vec3 col = vec3(0.0);\n    \n    float r = texture( iChannel1, fragCoord\/iChannelResolution[1].xy ).x;\n    for( int j=0; j<AA; j++ )\n    for( int i=0; i<AA; i++ )\n    {\n        vec2 p = (2.0*(fragCoord+vec2(i,j)\/float(AA))-iResolution.xy)\/iResolution.y;\n\n        float time = iTime + (r+float(AA*j + i))\/float(AA*AA) * (0.4\/30.0);\n        \n        time = 41.73 + time;\n        \n        float an = 6.0 + 0.1*time;\n\n        vec3 ro = vec3(0.0,1.0,0.5) + 2.0*vec3(cos(an),0.0,sin(an));\n        vec3 ta = vec3(0.0,0.0,0.0);\n        mat3 ca = setCamera( ro, ta, 0.3 );\n        vec3 rd = normalize( ca * vec3(p,-1.5) );\n        \n        col += render( ro, rd, time );\n    }\n    col \/= float(AA*AA);\n#else\n    vec2 p = (2.0*fragCoord-iResolution.xy)\/iResolution.y;\n    \n    float time = iTime;\/\/ + (hash1(iRands.x+px.x+px.y*31U))*0.1*(1.0\/24.0);\n    time = 41.73 + time;\n    float an = 6.0 + 0.1*time;\n\n    vec3 ro = vec3(0.0,1.0,0.5) + 2.0*vec3(cos(an),0.0,sin(an));\n    vec3 ta = vec3(0.0,0.0,0.0);\n    mat3 ca = setCamera( ro, ta, 0.3 );\n    vec3 rd = normalize( ca * vec3(p,-1.5) );\n\n    vec3 col = render( ro, rd, time );\n#endif    \n\tfragColor = vec4( col, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"ldc3RB","date":"1450413944","viewed":9811,"name":"Noise Lab (2D)","username":"candycat","description":"try to fake http:\/\/www.noisemachine.com\/talk1\/19.html in 2D.","likes":38,"published":1,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[],"code":"#define Use_Perlin\n\/\/#define Use_Value\n\/\/#define Use_Simplex\n\n\/\/ ========= Noise ===========\nvec2 hash22(vec2 p)\n{\n    p = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)));\n    \n    \/\/return normalize(-1.0 + 2.0 * fract(sin(p)*43758.5453123));\n    return -1.0 + 2.0 * fract(sin(p)*43758.5453123);\n}\n\nfloat hash21(vec2 p)\n{\n\tfloat h = dot(p,vec2(127.1,311.7));\n\t\n    return -1.0 + 2.0 * fract(sin(h)*43758.5453123);\n}\n\nfloat perlin_noise(vec2 p)\n{\n    vec2 pi = floor(p);\n    vec2 pf = p - pi;\n    \n    vec2 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return mix(mix(dot(hash22(pi + vec2(0.0, 0.0)), pf - vec2(0.0, 0.0)), \n                   dot(hash22(pi + vec2(1.0, 0.0)), pf - vec2(1.0, 0.0)), w.x), \n               mix(dot(hash22(pi + vec2(0.0, 1.0)), pf - vec2(0.0, 1.0)), \n                   dot(hash22(pi + vec2(1.0, 1.0)), pf - vec2(1.0, 1.0)), w.x),\n               w.y);\n}\n\nfloat value_noise(vec2 p)\n{\n    vec2 pi = floor(p);\n    vec2 pf = p - pi;\n    \n    vec2 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return mix(mix(hash21(pi + vec2(0.0, 0.0)), hash21(pi + vec2(1.0, 0.0)), w.x),\n               mix(hash21(pi + vec2(0.0, 1.0)), hash21(pi + vec2(1.0, 1.0)), w.x),\n               w.y);\n}\n\nfloat simplex_noise(vec2 p)\n{\n    const float K1 = 0.366025404; \/\/ (sqrt(3)-1)\/2;\n    const float K2 = 0.211324865; \/\/ (3-sqrt(3))\/6;\n    \n    vec2 i = floor(p + (p.x + p.y) * K1);\n    \n    vec2 a = p - (i - (i.x + i.y) * K2);\n    vec2 o = (a.x < a.y) ? vec2(0.0, 1.0) : vec2(1.0, 0.0);\n    vec2 b = a - (o - K2);\n    vec2 c = a - (1.0 - 2.0 * K2);\n    \n    vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n    vec3 n = h * h * h * h * vec3(dot(a, hash22(i)), dot(b, hash22(i + o)), dot(c, hash22(i + 1.0)));\n    \n    return dot(vec3(70.0, 70.0, 70.0), n);\n}\n\nfloat noise(vec2 p) {\n#ifdef Use_Perlin\n    return perlin_noise(p);\n#elif defined Use_Value\n    return value_noise(p);\n#elif defined Use_Simplex\n    return simplex_noise(p);\n#endif\n    \n    return 0.0;\n}\n\n\/\/ ========== Different function ==========\nfloat noise_itself(vec2 p)\n{\n    return noise(p * 8.0);\n}\n\nfloat noise_sum(vec2 p)\n{\n    float f = 0.0;\n    p = p * 4.0;\n    f += 1.0000 * noise(p); p = 2.0 * p;\n    f += 0.5000 * noise(p); p = 2.0 * p;\n\tf += 0.2500 * noise(p); p = 2.0 * p;\n\tf += 0.1250 * noise(p); p = 2.0 * p;\n\tf += 0.0625 * noise(p); p = 2.0 * p;\n    \n    return f;\n}\n\nfloat noise_sum_abs(vec2 p)\n{\n    float f = 0.0;\n    p = p * 7.0;\n    f += 1.0000 * abs(noise(p)); p = 2.0 * p;\n    f += 0.5000 * abs(noise(p)); p = 2.0 * p;\n\tf += 0.2500 * abs(noise(p)); p = 2.0 * p;\n\tf += 0.1250 * abs(noise(p)); p = 2.0 * p;\n\tf += 0.0625 * abs(noise(p)); p = 2.0 * p;\n    \n    return f;\n}\n\nfloat noise_sum_abs_sin(vec2 p)\n{\n    float f = noise_sum_abs(p);\n    f = sin(f * 1.5 + p.x * 7.0);\n    \n    return f * f;\n}\n\n\/\/ ========== Draw ==========\nvec3 draw_simple(float f)\n{\n    f = f * 0.5 + 0.5;\n    return f * vec3(25.0\/255.0, 161.0\/255.0, 245.0\/255.0);\n}\n\nvec3 draw_cloud(float f)\n{\n    f = f * 0.5 + 0.5;\n    return mix(\tvec3(8.0\/255.0, 65.0\/255.0, 82.0\/255.0),\n              \tvec3(178.0\/255.0, 161.0\/255.0, 205.0\/255.0),\n               \tf*f);\n}\n\nvec3 draw_fire(float f)\n{\n    f = f * 0.5 + 0.5;\n    return mix(\tvec3(131.0\/255.0, 8.0\/255.0, 0.0\/255.0),\n              \tvec3(204.0\/255.0, 194.0\/255.0, 56.0\/255.0),\n               \tpow(f, 3.));\n}\n\nvec3 draw_marble(float f)\n{\n    f = f * 0.5 + 0.5;\n    return mix(\tvec3(31.0\/255.0, 14.0\/255.0, 4.0\/255.0),\n              \tvec3(172.0\/255.0, 153.0\/255.0, 138.0\/255.0),\n               \t1.0 - pow(f, 5.));\n}\n\nvec3 draw_circle(vec2 p, float radius, vec3 col, vec3 back)\n{\n    p = 2.0 * p - vec2(iResolution.x\/iResolution.y, 1.0);\n    return \tmix(col, back, smoothstep(0.0, 0.01, length(p) - radius)) *\n        \tsmoothstep(0.0, 0.02, abs(length(p) - radius));\n        \t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy \/ iResolution.xy;\n    vec2 uv = p * vec2(iResolution.x\/iResolution.y, 1.0);\n    vec2 split = vec2(0.5, 0.5);\n    if (iMouse.z > 0.0) {\n        split += 2.0 * iMouse.xy\/iResolution.xy - 1.0;\n    }\n    \n    float f = 0.0;\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    \n    if (p.x < split.x && p.y > split.y) {\n        f = noise_itself(uv);\n        col = draw_simple(f);\n    } else if (p.x < split.x && p.y <= split.y) {\n        f = noise_sum(uv);\n        col = draw_cloud(f);\n    } else if (p.x >= split.x && p.y < split.y) {\n        f = noise_sum_abs(uv);\n        col = draw_fire(f);\n    } else {\n        f = noise_sum_abs_sin(uv);\n        col = draw_marble(f);\n    }\n    \n    f = f * 0.5 + 0.5;\n    col = draw_circle(uv, 0.9, col, vec3(f));\n    col = mix(vec3(0.3, 0.0, 0.0), col, smoothstep(0.0, 0.005, abs(p.x - split.x)));\n    col = mix(vec3(0.3, 0.0, 0.0), col, smoothstep(0.0, 0.005*iResolution.x\/iResolution.y, abs(p.y - split.y)));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"ltyGRV","date":"1475512936","viewed":9810,"name":"watercolor","username":"flockaroo","description":"watercolor effect.\nbasic principle: blurring strokes perpendicular to gradient, colors parallel.\n","likes":121,"published":3,"flags":0,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"\/media\/a\/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"\/media\/ap\/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRr","filepath":"\/media\/a\/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"\/media\/ap\/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ created by florian berger (flockaroo) - 2016\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ trying to resemble watercolors\n\n#define Res  iResolution.xy\n#define Res0 iChannelResolution[0].xy\n#define Res1 iChannelResolution[1].xy\n\n#define PI 3.14159265358979\n\nvec4 getCol(vec2 pos)\n{\n    vec2 uv=pos\/Res0;\n    vec4 c1 = texture(iChannel0,uv);\n    vec4 c2 = vec4(.4); \/\/ gray on greenscreen\n    float d = clamp(dot(c1.xyz,vec3(-0.5,1.0,-0.5)),0.0,1.0);\n    return mix(c1,c2,1.8*d);\n}\n\nvec4 getCol2(vec2 pos)\n{\n    vec2 uv=pos\/Res0;\n    vec4 c1 = texture(iChannel0,uv);\n    vec4 c2 = vec4(1.5); \/\/ bright white on greenscreen\n    float d = clamp(dot(c1.xyz,vec3(-0.5,1.0,-0.5)),0.0,1.0);\n    return mix(c1,c2,1.8*d);\n}\n\nvec2 getGrad(vec2 pos,float delta)\n{\n    vec2 d=vec2(delta,0);\n    return vec2(\n        dot((getCol(pos+d.xy)-getCol(pos-d.xy)).xyz,vec3(.333)),\n        dot((getCol(pos+d.yx)-getCol(pos-d.yx)).xyz,vec3(.333))\n    )\/delta;\n}\n\nvec2 getGrad2(vec2 pos,float delta)\n{\n    vec2 d=vec2(delta,0);\n    return vec2(\n        dot((getCol2(pos+d.xy)-getCol2(pos-d.xy)).xyz,vec3(.333)),\n        dot((getCol2(pos+d.yx)-getCol2(pos-d.yx)).xyz,vec3(.333))\n    )\/delta;\n}\n\nvec4 getRand(vec2 pos) \n{\n    vec2 uv=pos\/Res1;\n    return texture(iChannel1,uv);\n}\n\nfloat htPattern(vec2 pos)\n{\n    float p;\n    float r=getRand(pos*.4\/.7*1.).x;\n  \tp=clamp((pow(r+.3,2.)-.45),0.,1.);\n    return p;\n}\n\nfloat getVal(vec2 pos, float level)\n{\n    return length(getCol(pos).xyz)+0.0001*length(pos-0.5*Res0);\n    return dot(getCol(pos).xyz,vec3(.333));\n}\n    \nvec4 getBWDist(vec2 pos)\n{\n    return vec4(smoothstep(.9,1.1,getVal(pos,0.)*.9+htPattern(pos*.7)));\n}\n\n#define SampNum 24\n\n#define N(a) (a.yx*vec2(1,-1))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos=((fragCoord-Res.xy*.5)\/Res.y*Res0.y)+Res0.xy*.5;\n    vec2 pos2=pos;\n    vec2 pos3=pos;\n    vec2 pos4=pos;\n    vec2 pos0=pos;\n    vec3 col=vec3(0);\n    vec3 col2=vec3(0);\n    float cnt=0.0;\n    float cnt2=0.;\n    for(int i=0;i<1*SampNum;i++)\n    {   \n        \/\/ gradient for outlines (gray on green screen)\n        vec2 gr =getGrad(pos, 2.0)+.0001*(getRand(pos ).xy-.5);\n        vec2 gr2=getGrad(pos2,2.0)+.0001*(getRand(pos2).xy-.5);\n        \n        \/\/ gradient for wash effect (white on green screen)\n        vec2 gr3=getGrad2(pos3,2.0)+.0001*(getRand(pos3).xy-.5);\n        vec2 gr4=getGrad2(pos4,2.0)+.0001*(getRand(pos4).xy-.5);\n        \n        float grl=clamp(10.*length(gr),0.,1.);\n        float gr2l=clamp(10.*length(gr2),0.,1.);\n\n        \/\/ outlines:\n        \/\/ stroke perpendicular to gradient\n        pos +=.8 *normalize(N(gr));\n        pos2-=.8 *normalize(N(gr2));\n        float fact=1.-float(i)\/float(SampNum);\n        col+=fact*mix(vec3(1.2),getBWDist(pos).xyz*2.,grl);\n        col+=fact*mix(vec3(1.2),getBWDist(pos2).xyz*2.,gr2l);\n        \n        \/\/ colors + wash effect on gradients:\n        \/\/ color gets lost from dark areas\n        pos3+=.25*normalize(gr3)+.5*(getRand(pos0*.07).xy-.5);\n        \/\/ to bright areas\n        pos4-=.5 *normalize(gr4)+.5*(getRand(pos0*.07).xy-.5);\n        \n        float f1=3.*fact;\n        float f2=4.*(.7-fact); \n        col2+=f1*(getCol2(pos3).xyz+.25+.4*getRand(pos3*1.).xyz);\n        col2+=f2*(getCol2(pos4).xyz+.25+.4*getRand(pos4*1.).xyz);\n        \n        cnt2+=f1+f2;\n        cnt+=fact;\n    }\n    \/\/ normalize\n    col\/=cnt*2.5;\n    col2\/=cnt2*1.65;\n    \n    \/\/ outline + color\n    col = clamp(clamp(col*.9+.1,0.,1.)*col2,0.,1.);\n    \/\/ paper color and grain\n    col = col*vec3(.93,0.93,0.85)\n        *mix(texture(iChannel2,fragCoord.xy\/iResolution.xy).xyz,vec3(1.2),.7)\n        +.15*getRand(pos0*2.5).x;\n    \/\/ vignetting\n    float r = length((fragCoord-iResolution.xy*.5)\/iResolution.x);\n    float vign = 1.-r*r*r*r;\n    \n\tfragColor = vec4(col*vign,1.0);\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4dl3R4","date":"1363960434","viewed":9801,"name":"Snowy","username":"HeGu","description":"To celebrate that winter is soon over....\n\nThis shader uses various noises (uses stegu simplex noise and worley) and ramps to make a 2D snow landscape scene with an out of focus moon and a snowy slope below it.","likes":141,"published":1,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[],"code":"    \/\/ This shader useds noise shaders by stegu -- http:\/\/webstaff.itn.liu.se\/~stegu\/\n    \/\/ This is supposed to look like snow falling, for example like http:\/\/24.media.tumblr.com\/tumblr_mdhvqrK2EJ1rcru73o1_500.gif\n\n\t\tvec2 mod289(vec2 x) {\n\t\t  return x - floor(x * (1.0 \/ 289.0)) * 289.0;\n\t\t}\n\n\t\tvec3 mod289(vec3 x) {\n\t\t  \treturn x - floor(x * (1.0 \/ 289.0)) * 289.0;\n\t\t}\n\t\t\n\t\tvec4 mod289(vec4 x) {\n\t\t  \treturn x - floor(x * (1.0 \/ 289.0)) * 289.0;\n\t\t}\n\t\t\n\t\tvec3 permute(vec3 x) {\n\t\t  return mod289(((x*34.0)+1.0)*x);\n\t\t}\n\n\t\tvec4 permute(vec4 x) {\n\t\t  return mod((34.0 * x + 1.0) * x, 289.0);\n\t\t}\n\n\t\tvec4 taylorInvSqrt(vec4 r)\n\t\t{\n\t\t  \treturn 1.79284291400159 - 0.85373472095314 * r;\n\t\t}\n\t\t\n\t\tfloat snoise(vec2 v)\n\t\t{\n\t\t\t\tconst vec4 C = vec4(0.211324865405187,0.366025403784439,-0.577350269189626,0.024390243902439);\n\t\t\t\tvec2 i  = floor(v + dot(v, C.yy) );\n\t\t\t\tvec2 x0 = v -   i + dot(i, C.xx);\n\t\t\t\t\n\t\t\t\tvec2 i1;\n\t\t\t\ti1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\t\t\t\tvec4 x12 = x0.xyxy + C.xxzz;\n\t\t\t\tx12.xy -= i1;\n\t\t\t\t\n\t\t\t\ti = mod289(i); \/\/ Avoid truncation effects in permutation\n\t\t\t\tvec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t\t\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\t\t\t\t\n\t\t\t\tvec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n\t\t\t\tm = m*m ;\n\t\t\t\tm = m*m ;\n\t\t\t\t\n\t\t\t\tvec3 x = 2.0 * fract(p * C.www) - 1.0;\n\t\t\t\tvec3 h = abs(x) - 0.5;\n\t\t\t\tvec3 ox = floor(x + 0.5);\n\t\t\t\tvec3 a0 = x - ox;\n\t\t\t\t\n\t\t\t\tm *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\t\t\t\t\n\t\t\t\tvec3 g;\n\t\t\t\tg.x  = a0.x  * x0.x  + h.x  * x0.y;\n\t\t\t\tg.yz = a0.yz * x12.xz + h.yz * x12.yw;\n\n\t\t\t\treturn 130.0 * dot(m, g);\t\t\n\t\t}\n\t\t\n\t\tfloat cellular2x2(vec2 P)\n\t\t{\n\t\t\t\t#define K 0.142857142857 \/\/ 1\/7\n\t\t\t\t#define K2 0.0714285714285 \/\/ K\/2\n\t\t\t\t#define jitter 0.8 \/\/ jitter 1.0 makes F1 wrong more often\n\t\t\t\t\n\t\t\t\tvec2 Pi = mod(floor(P), 289.0);\n\t\t\t\tvec2 Pf = fract(P);\n\t\t\t\tvec4 Pfx = Pf.x + vec4(-0.5, -1.5, -0.5, -1.5);\n\t\t\t\tvec4 Pfy = Pf.y + vec4(-0.5, -0.5, -1.5, -1.5);\n\t\t\t\tvec4 p = permute(Pi.x + vec4(0.0, 1.0, 0.0, 1.0));\n\t\t\t\tp = permute(p + Pi.y + vec4(0.0, 0.0, 1.0, 1.0));\n\t\t\t\tvec4 ox = mod(p, 7.0)*K+K2;\n\t\t\t\tvec4 oy = mod(floor(p*K),7.0)*K+K2;\n\t\t\t\tvec4 dx = Pfx + jitter*ox;\n\t\t\t\tvec4 dy = Pfy + jitter*oy;\n\t\t\t\tvec4 d = dx * dx + dy * dy; \/\/ d11, d12, d21 and d22, squared\n\t\t\t\t\/\/ Sort out the two smallest distances\n\t\t\t\t\n\t\t\t\t\/\/ Cheat and pick only F1\n\t\t\t\td.xy = min(d.xy, d.zw);\n\t\t\t\td.x = min(d.x, d.y);\n\t\t\t\treturn d.x; \/\/ F1 duplicated, F2 not computed\n\t\t}\n\n\t\tfloat fbm(vec2 p) {\n \t\t   float f = 0.0;\n    \t\tfloat w = 0.5;\n    \t\tfor (int i = 0; i < 5; i ++) {\n\t\t\t\t\t\tf += w * snoise(p);\n\t\t\t\t\t\tp *= 2.;\n\t\t\t\t\t\tw *= 0.5;\n    \t\t}\n    \t\treturn f;\n\t\t}\n\n\t\tvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n\t\t{\n\t\t\t\tfloat speed=2.0;\n\t\t\t\t\n\t\t\t\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n\t\t\t\t\n\t\t\t\tuv.x*=(iResolution.x\/iResolution.y);\n\t\t\t\t\n\t\t\t\tvec2 suncent=vec2(0.3,0.9);\n\t\t\t\t\n\t\t\t\tfloat suns=(1.0-distance(uv,suncent));\n\t\t\t\tsuns=clamp(0.2+suns,0.0,1.0);\n\t\t\t\tfloat sunsh=smoothstep(0.85,0.95,suns);\n\n\t\t\t\tfloat slope;\n\t\t\t\tslope=0.8+uv.x-(uv.y*2.3);\n\t\t\t\tslope=1.0-smoothstep(0.55,0.0,slope);\t\t\t\t\t\t\t\t\n\t\t\t\t\n\t\t\t\tfloat noise=abs(fbm(uv*1.5));\n\t\t\t\tslope=(noise*0.2)+(slope-((1.0-noise)*slope*0.1))*0.6;\n\t\t\t\tslope=clamp(slope,0.0,1.0);\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\tvec2 GA;\n\t\t\t\tGA.x-=iTime*1.8;\n\t\t\t\tGA.y+=iTime*0.9;\n\t\t\t\tGA*=speed;\n\t\t\t\n\t\t\t\tfloat F1=0.0,F2=0.0,F3=0.0,F4=0.0,F5=0.0,N1=0.0,N2=0.0,N3=0.0,N4=0.0,N5=0.0;\n\t\t\t\tfloat A=0.0,A1=0.0,A2=0.0,A3=0.0,A4=0.0,A5=0.0;\n\n\n\t\t\t\t\/\/ Attentuation\n\t\t\t\tA = (uv.x-(uv.y*0.3));\n\t\t\t\tA = clamp(A,0.0,1.0);\n\n\t\t\t\t\/\/ Snow layers, somewhat like an fbm with worley layers.\n\t\t\t\tF1 = 1.0-cellular2x2((uv+(GA*0.1))*8.0);\t\n\t\t\t\tA1 = 1.0-(A*1.0);\n\t\t\t\tN1 = smoothstep(0.998,1.0,F1)*1.0*A1;\t\n\n\t\t\t\tF2 = 1.0-cellular2x2((uv+(GA*0.2))*6.0);\t\n\t\t\t\tA2 = 1.0-(A*0.8);\n\t\t\t\tN2 = smoothstep(0.995,1.0,F2)*0.85*A2;\t\t\t\t\n\n\t\t\t\tF3 = 1.0-cellular2x2((uv+(GA*0.4))*4.0);\t\n\t\t\t\tA3 = 1.0-(A*0.6);\n\t\t\t\tN3 = smoothstep(0.99,1.0,F3)*0.65*A3;\t\t\t\t\n\n\t\t\t\tF4 = 1.0-cellular2x2((uv+(GA*0.6))*3.0);\t\n\t\t\t\tA4 = 1.0-(A*1.0);\n\t\t\t\tN4 = smoothstep(0.98,1.0,F4)*0.4*A4;\t\t\t\t\n\n\t\t\t\tF5 = 1.0-cellular2x2((uv+(GA))*1.2);\t\n\t\t\t\tA5 = 1.0-(A*1.0);\n\t\t\t\tN5 = smoothstep(0.98,1.0,F5)*0.25*A5;\t\t\t\t\n\t\t\t\t\t\t\t\t\n\t\t\t\tfloat Snowout=N5+N4+N3+N2+N1;\n\t\t\t\t\t\t\t\t\n\t\t\t\tSnowout = 0.35+(slope*(suns+0.3))+(sunsh*0.6)+N1+N2+N3+N4+N5;\n\t\t\t\t\n\t\t\t\tfragColor = vec4(Snowout*0.9, Snowout, Snowout*1.1, 1.0);\n\n\t\t}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"tstczS","date":"1639409611","viewed":9782,"name":"Paper Plane","username":"zduny","description":"Prototype of my mobile game:\n[url]https:\/\/play.google.com\/store\/apps\/details?id=com.zduny.paperplane[\/url]\n\nControls: \nSPACE to start\nLEFT ARROW and RIGHT ARROW - control the plane","likes":97,"published":3,"flags":48,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"\/media\/a\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"\/media\/ap\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"INCLUDE_TEXTURE_GRID_WIDTH\nINCLUDE_GAME_CONSTANTS\nINCLUDE_STATE_STRUCT\nINCLUDE_STATE_LOAD_FUNCTION\n\nconst bool showTexture = false;\n\nconst vec3 background = vec3(0.454, 0.672, 0.984);\n\nconst float aspectRatio = 8.0 \/ 16.0;\nconst float top = 1.0 \/ aspectRatio;\n\nState state;\nvec3 letterColor;\n\nvec4 blend(in vec4 under, in vec4 over) {\n  vec4 result = mix(under, over, over.a);\n  result.a = over.a + under.a * (1.0 - over.a);\n    \n  return result;\n}\n\nvec2 fixUv(in vec2 uv) {\n  uv = clamp(uv, 0.0, 1.0);\n  uv.x *= iResolution.y \/ iResolution.x;\n  return uv;\n}\n\nvec4 getPipeTexture(in vec2 uv) {\n  return texture(iChannel1, fixUv(uv) \/ float(textureGridWidth));\n}\n\nvec4 getPlaneTexture(in float angle, in vec2 uv) {\n  float total = float(textureGridWidth * textureGridWidth - 2);  \n  float i = round((angle + 0.5) * total + 1.0);\n  \n  uv = fixUv(uv);\n  uv.x += iResolution.y \/ iResolution.x * mod(i, float(textureGridWidth));\n  uv.y += floor(i \/ float(textureGridWidth));\n  \n  return texture(iChannel1, uv \/ float(textureGridWidth));\n}\n\nvoid drawLetter(inout vec4 fragColor, in vec2 fragCoord, \n                in vec2 position, in vec2 size, in int code) {\n  vec2 uv = fragCoord - position;\n  uv += size * 0.5;\n  uv \/= size;\n  \n  if (uv.x > 0.0 && uv.x < 1.0 && uv.y > 0.0 && uv.y < 1.0) {\n    uv.x += float(code % 16);\n    uv.y += float(15 - code \/ 16);\n    \n    uv *= 0.0625;\n    \n    float sd = abs(texture(iChannel2, uv).a);\n    fragColor = blend(fragColor, \n      vec4(vec3(0.0), smoothstep(0.0, 1.0, (0.55 - sd) * 50.0)));\n    fragColor = blend(fragColor, \n      vec4(letterColor, smoothstep(0.0, 1.0, (0.51 - sd) * 50.0)));\n  }\n}\n\nfloat elasticOut(float t) {\n  return sin(-13.0 * (t + 1.0) * 3.1416 * 0.5) * pow(2.0, -10.0 * t) + 1.0;\n}\n\nfloat cubicIn(float t) {\n  return t * t * t;\n}\n\nfloat cubicOut(float t) {\n  float f = t - 1.0;\n  return f * f * f + 1.0;\n}\n\nconst float HALF_PI = 3.1416 * 0.5;\nfloat elasticInOut(float t) {\n  return t < 0.5\n    ? 0.5 * sin(+13.0 * HALF_PI * 2.0 * t) * pow(2.0, 10.0 * (2.0 * t - 1.0))\n    : 0.5 * sin(-13.0 * HALF_PI * ((2.0 * t - 1.0) + 1.0)) * pow(2.0, -10.0 * (2.0 * t - 1.0)) + 1.0;\n}\n\nvoid drawPipes(inout vec4 fragColor, in vec2 fragCoord, \n               in vec2 position, in float gap) {   \n  float size = pipeSize;\n\n  vec2 uv = fragCoord - position;\n  if (uv.x > 0.0) {\n    uv.x *= -1.0;\n  }\n  uv += size * 0.5;\n  uv.x += size * 0.21 + gap;\n  uv \/= size;\n  \n  fragColor = blend(fragColor, getPipeTexture(uv));\n}\n\nvoid drawAllPipes(inout vec4 fragColor, in vec2 fragCoord) {\n  vec4 outColor = fragColor;\n\n  for (int i = 0; i < pipesCount; i++) {\n    Gap gap = state.gaps[i];\n    vec2 position = vec2(gap.position, \n      pipesStart + state.pipesOffset + float(i) * pipesGap);\n    drawPipes(outColor, fragCoord, position, gap.size);\n  }\n  \n  float time = clamp(max(iTime, state.animationTime) * 1.5, 0.0, 1.0);\n  fragColor = mix(fragColor, outColor, cubicIn(time));\n}\n\n#define INCLUDE_DRAW_STRING_FUNCTION(name, arrayName, arrayLength)         \\\n  void name(inout vec4 fragColor, in vec2 fragCoord, float offset) {       \\\n    float size = 1.0 \/ float(arrayLength);                                 \\\n                                                                           \\\n    fragCoord.y -= top - size * (1.0 + offset) - 0.2;                      \\\n    fragCoord *= 1.08;                                                     \\\n    fragCoord.x = clamp(fragCoord.x, -1.0, 1.0);                           \\\n    fragCoord.x += 1.0;                                                    \\\n    fragCoord *= 0.5;                                                      \\\n                                                                           \\\n    int code = arrayName[int(fragCoord.x \/ size - 0.01)];                  \\\n    fragCoord.x = mod(fragCoord.x, size) - size * 0.5;                     \\\n                                                                           \\\n    drawLetter(fragColor, fragCoord, vec2(0.0), vec2(size * 1.4), code);   \\\n  }\n\nconst int paperLength = 5;\nconst int[] paperLetters = int[](80, 65, 80, 69, 82);\n\nconst int planeLength = 5;\nconst int[] planeLetters = int[](80, 76, 65, 78, 69);\n\nINCLUDE_DRAW_STRING_FUNCTION(drawPaper, paperLetters, paperLength)\nINCLUDE_DRAW_STRING_FUNCTION(drawPlane, planeLetters, planeLength)\n\nvoid drawLogo(inout vec4 fragColor, in vec2 fragCoord) {\n  if (state.animationState >= STATE_IN_GAME) {\n    return;\n  }\n\n  bool inAnimation = state.animationState <= STATE_MENU;\n  float animationTime = state.animationTime;\n  \n  float time = clamp(animationTime * 1.1, 0.0, 1.0);\n  float position = inAnimation \n    ? mix(-8.0, 0.0, elasticOut(time))\n    : mix(0.0, -8.0, cubicIn(time));\n    \n  letterColor = vec3(1.0);\n  drawPaper(fragColor, fragCoord, position - 0.5);\n  drawPlane(fragColor, fragCoord, position + 2.0);\n}\n\nvoid drawScore(inout vec4 fragColor, in vec2 fragCoord) {\n  if (state.animationState < STATE_IN_GAME && state.highScore == 0) {\n    return;\n  }\n\n  bool inAnimation = state.animationState <= STATE_MENU;\n  float animationTime = state.animationTime;\n  \n  float time = state.animationState == STATE_GAME_OVER \n    ? 1.0\n    : clamp(animationTime * (inAnimation ? 1.2 : 0.5) - 0.1, 0.0, 1.0);\n  float y = inAnimation\n    ? mix(2.0, 0.0, elasticOut(time))\n    : mix(0.0, 1.55, elasticInOut(time));\n  \n  float size = 0.27;\n  \n  int[] scoreString = int[](0, 0, 0, 0, 0, 0, 0);\n  int scoreLength = 0;\n  int score;\n  if (state.animationState <= STATE_MENU) {\n    score = state.highScore;\n  } else if (state.animationState == STATE_OUTRO && time < 0.7) {\n    score = int(mix(float(state.highScore), 0.0, clamp((time - 0.5) * 4.0, 0.0, 1.0)));\n  } else if (state.animationState == STATE_OUTRO) {\n    score = 0;\n  }else if (state.animationState >= STATE_IN_GAME) {\n    score = state.score;\n  }\n  for (int i = 0; i < 6; i++) {\n    scoreString[i] = 48 + score % 10;\n    scoreLength++;\n    score = score \/ 10;\n    if (score == 0) {\n      break;\n    }\n  }\n  \n  letterColor = \n    (state.animationState >= STATE_IN_GAME && state.score <= state.highScore) ||\n    (state.animationState == STATE_OUTRO && time > 0.5)\n    ? vec3(1.0)\n    : vec3(1.0, 1.0, 0.7);\n    \n  vec4 outColor = vec4(0.0);\n  float letterWidth = size * 0.8;\n  for (int i = 0; i < scoreLength; i++) {\n    vec2 position = vec2(0.0 + float(scoreLength - i - 1) * letterWidth, y + 0.21);\n    position.x -= float(scoreLength) * 0.5 * letterWidth - letterWidth * 0.48;\n    drawLetter(outColor, fragCoord, position, vec2(size * 1.4), scoreString[i]);\n  }\n  \n  if (state.animationState == STATE_IN_GAME && state.highScore == 0) {\n    outColor.a *= cubicIn(clamp((state.animationTime - 4.0) * 3.0, 0.0, 1.0));\n  }\n  if (state.animationState == STATE_GAME_OVER && \n      state.score < 2 && \n      state.highScore == 0) {\n    outColor.a = 0.0;\n  }\n  fragColor = blend(fragColor, outColor);\n}\n\nvoid drawPaperPlaneButton(inout vec4 fragColor, in vec2 fragCoord, \n                          in vec2 position, bool shadow) {\n  vec2 size = vec2(shadow ? 0.71 : 0.68);\n  \n  position -= fragCoord;\n  position += size * 0.5;\n  \n  position \/= size;\n  float tmp = position.x;\n  position.x = 1.0 - position.y;\n  position.y = tmp;\n  \n  vec4 color = getPlaneTexture(0.0, position);\n  \n  fragColor = blend(fragColor, shadow ? vec4(vec3(0.2), color.a * 0.5) : color);\n}\n\nvoid drawPlayButton(inout vec4 fragColor, in vec2 fragCoord) {\n  if (state.animationState >= STATE_IN_GAME) {\n    return;\n  }\n\n  vec2 position = vec2(0.0, -1.0);\n  \n  bool inAnimation = state.animationState <= STATE_MENU;\n  float animationTime = state.animationTime;\n  float time = clamp(animationTime * 1.2, 0.0, 1.0);\n  \n  vec2 circlePosition = inAnimation\n    ? mix(position - vec2(0.0, 3.0), position, elasticOut(animationTime))\n    : mix(position, position - vec2(0.0, 3.0), cubicIn(animationTime));\n  \n  const float radius = 0.45;\n  float sd = distance(circlePosition, fragCoord);\n  \n  fragColor = blend(fragColor, \n    vec4(vec3(0.0), smoothstep(1.0, 0.0, (sd - radius - 0.02) * 100.0)));\n  fragColor = blend(fragColor, \n    vec4(vec3(0.0, 0.0, 0.85), smoothstep(1.0, 0.0, (sd - radius) * 100.0)));\n\n  position += vec2(0.01, 0.02);\n  \n  time = clamp(animationTime * (inAnimation ? 3.0 : 2.0), 0.0, 1.0);\n  \n  vec2 shadowPosition = inAnimation\n    ? mix(position - vec2(2.7, 0.0), position, cubicOut(time))\n    : mix(position, position + vec2(2.7, 0.0), cubicIn(time));\n  \n  if (state.isPlayPressed) {\n    position.y -= 0.025;\n  }\n  vec2 planePosition = inAnimation\n    ? mix(position - vec2(3.0, 0.0), position, cubicOut(time))\n    : mix(position, position + vec2(3.0, 0.0), cubicIn(time));\n    \n  vec4 shadow = vec4(0.0);\n  drawPaperPlaneButton(shadow, fragCoord, shadowPosition + vec2(0.0, -0.03), true);\n  shadow.a *= smoothstep(1.0, 0.0, (sd - radius - 0.02) * 100.0);\n  fragColor = blend(fragColor, shadow);\n  \n  drawPaperPlaneButton(fragColor, fragCoord, planePosition, false);\n}\n\nvoid drawPlane(inout vec4 fragColor, in vec2 fragCoord) {\n  if (state.animationState < STATE_OUTRO) {\n    return;\n  }\n  \n  vec2 size = vec2(planeSize);\n  vec2 position = state.plane.position;\n  \n  position -= fragCoord;\n  position += size * 0.5;\n  \n  position \/= size;\n  position.y = 1.0 - position.y;\n  \n  vec4 color = getPlaneTexture(state.plane.angle, position);\n  \n  fragColor = blend(fragColor, color);\n}\n\nvoid normalizeFragCoord(inout vec2 fragCoord) {\n  fragCoord -= iResolution.xy * 0.5;\n  fragCoord \/= iResolution.y * 0.5;\n  fragCoord \/= aspectRatio;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {  \n  fragColor = vec4(vec3(0.0), 1.0);\n  \n  if (showTexture) {\n    vec2 uv = fragCoord \/ iResolution.xy;\n    fragColor = vec4(background, 1.0);\n    fragColor = blend(fragColor, texture(iChannel1, uv));\n    return;\n  }\n  \n  normalizeFragCoord(fragCoord);\n  bool inFrame = abs(fragCoord.x) < 1.0;\n  if (inFrame) {\n    state = loadState(); \n    fragColor = vec4(background, 1.0);\n    drawAllPipes(fragColor, fragCoord);\n    drawLogo(fragColor, fragCoord);\n    drawPlayButton(fragColor, fragCoord);\n    drawPlane(fragColor, fragCoord);\n    drawScore(fragColor, fragCoord);\n  }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec3 toLinear(in vec3 color) { return pow(color, vec3(2.2)); }\nvec3 toSRGB(in vec3 color) { return pow(color, vec3(1.0 \/ 2.2)); }\n\n#define INCLUDE_TEXTURE_GRID_WIDTH                                       \\\n  const int textureGridWidth = 6;\n\n#define loadVariable(location)                                           \\\n  texelFetch(iChannel0, ivec2(location, 0), 0)\n\n#define isKeyDown(keyCode)                                               \\\n  (texelFetch(iChannel1, ivec2(keyCode, 0), 0).x > 0.0)\n \nconst int resolutionLocation = 0; \n#define INCLUDE_GAME_CONSTANTS                                           \\\n  const int pipesCount = 6;                                              \\\n  const float pipeSize = 0.5;                                            \\\n  const float pipesStart = -2.5;                                         \\\n  const float pipesGap = 1.05;                                           \\\n  const float planeMinPosition = 1.0;                                    \\\n  const float planeSize = 0.5;                                           \\\n  const float turningSpeed = 2.0;                                        \\\n  const vec2 startingPosition = vec2(-3.0, 4.0);                         \\\n  const float startingAngle = 0.5;                                       \\\n  const float startingOffset = -3.2;                                     \\\n                                                                         \\\n  const int variousLocation = 1;                                         \\\n  const int planeDataLocation = 2;                                       \\\n  const int keysLocation = 3;                                            \\\n  const int pipesLocation = 4;                                           \\\n  const int endOfData = pipesLocation + pipesCount;\n  \n#define STATE_INTRO 0\n#define STATE_MENU 1\n#define STATE_OUTRO 2\n#define STATE_IN_GAME 3\n#define STATE_GAME_OVER 4\n  \n#define INCLUDE_STATE_STRUCT                                             \\\n  struct Gap {                                                           \\\n    float position;                                                      \\\n    float size;                                                          \\\n  };                                                                     \\\n                                                                         \\\n  struct Plane {                                                         \\\n    vec2 position;                                                       \\\n    float angle;                                                         \\\n  };                                                                     \\\n                                                                         \\\n  struct State {                                                         \\\n    vec2 oldResolution;                                                  \\\n    vec2 newResolution;                                                  \\\n    Plane plane;                                                         \\\n    int animationState;                                                  \\\n    float animationTime;                                                 \\\n    float pipesOffset;                                                   \\\n    int score;                                                           \\\n    int highScore;                                                       \\\n    float traveledDistance;                                              \\\n    bool isPlayPressed;                                                  \\\n    Gap[pipesCount] gaps;                                                \\\n  };\n  \n#define INCLUDE_STATE_LOAD_FUNCTION                                      \\\n  State loadState() {                                                    \\\n    State state;                                                         \\\n                                                                         \\\n    vec4 resolutionData = loadVariable(resolutionLocation);              \\\n    state.oldResolution = resolutionData.zw;                             \\\n    state.newResolution = resolutionData.xy;                             \\\n                                                                         \\\n    vec4 planeData = loadVariable(planeDataLocation);                    \\\n                                                                         \\\n    Plane plane;                                                         \\\n    plane.position = planeData.xy;                                       \\\n    plane.angle = planeData.z;                                           \\\n                                                                         \\\n    state.plane = plane;                                                 \\\n                                                                         \\\n    vec4 variousData = loadVariable(variousLocation);                    \\\n    state.animationState = int(variousData.x);                           \\\n    state.animationTime = variousData.y;                                 \\\n    state.pipesOffset = variousData.z;                                   \\\n    state.score = int(variousData.w);                                    \\\n                                                                         \\\n    vec4 keysData = loadVariable(keysLocation);                          \\\n    state.isPlayPressed = keysData.x > 0.0;                              \\\n    state.highScore = int(keysData.y);                                   \\\n    state.traveledDistance = keysData.z;                                 \\\n                                                                         \\\n    for (int i = 0; i < pipesCount; i++) {                               \\\n      vec2 pipesData = loadVariable(pipesLocation + i).xy;               \\\n                                                                         \\\n      Gap gap;                                                           \\\n      gap.position = pipesData.x;                                        \\\n      gap.size = pipesData.y;                                            \\\n                                                                         \\\n      state.gaps[i] = gap;                                               \\\n    }                                                                    \\\n                                                                         \\\n    return state;                                                        \\\n  }\n  \n#define INCLUDE_STATE_SAVE_FUNCTION                                      \\\n  int fragmentCoordinates = 0;                                           \\\n  vec4 outputColor = vec4(0.0);                                          \\\n                                                                         \\\n  void saveState(in State state) {                                       \\\n    switch (fragmentCoordinates) {                                       \\\n      case resolutionLocation:                                           \\\n        outputColor.xy = state.newResolution;                            \\\n        outputColor.zw = state.oldResolution;                            \\\n        return;                                                          \\\n      case planeDataLocation:                                            \\\n        outputColor.xy = state.plane.position;                           \\\n        outputColor.z = state.plane.angle;                               \\\n        return;                                                          \\\n      case variousLocation:                                              \\\n        outputColor.x = float(state.animationState);                     \\\n        outputColor.y = state.animationTime;                             \\\n        outputColor.z = state.pipesOffset;                               \\\n        outputColor.w = float(state.score);                              \\\n        return;                                                          \\\n      case keysLocation:                                                 \\\n        outputColor.x = state.isPlayPressed ? 1.0 : 0.0;                 \\\n        outputColor.y = float(state.highScore);                          \\\n        outputColor.z = state.traveledDistance;                          \\\n        return;                                                          \\\n    }                                                                    \\\n                                                                         \\\n    if (fragmentCoordinates >= pipesLocation &&                          \\\n        fragmentCoordinates < endOfData) {                               \\\n      int i = fragmentCoordinates - pipesLocation;                       \\\n                                                                         \\\n      Gap gap = state.gaps[i];                                           \\\n                                                                         \\\n      outputColor.x = gap.position;                                      \\\n      outputColor.y = gap.size;                                          \\\n    }                                                                    \\\n  }     \n\n\n#define MS_STANDARD_1  vec2[](vec2(0.0))\n#define MS_STANDARD_2  vec2[](vec2(-0.25), vec2(0.25))\n#define MS_STANDARD_4  vec2[](                                           \\\n                         vec2(-0.125, -0.375), vec2(0.375, -0.125),      \\\n                         vec2(-0.375,  0.125), vec2(0.125,  0.375)       \\\n                       )\n#define MS_STANDARD_8  vec2[](                                           \\\n                         vec2( 0.0625, -0.1875), vec2(-0.0625,  0.1875), \\\n                         vec2( 0.3125,  0.0625), vec2(-0.1875, -0.3125), \\\n                         vec2(-0.3125,  0.3125), vec2(-0.4375, -0.0625), \\\n                         vec2( 0.1875,  0.4375), vec2( 0.4375, -0.4375)  \\\n                       )\n                            \n#define MS_STANDARD_16 vec2[](                                           \\\n                         vec2( 0.0625,  0.0625), vec2(-0.0625, -0.1875), \\\n                         vec2(-0.1875,  0.125 ), vec2( 0.25  , -0.0625), \\\n                         vec2(-0.3125, -0.125 ), vec2( 0.125 ,  0.3125), \\\n                         vec2( 0.3125,  0.1875), vec2( 0.1875, -0.3125), \\\n                         vec2(-0.125 ,  0.375 ), vec2( 0.0   , -0.4375), \\\n                         vec2(-0.25  , -0.375 ), vec2(-0.375 ,  0.25  ), \\\n                         vec2(-0.5   ,  0.0   ), vec2( 0.4375, -0.25  ), \\\n                         vec2( 0.375 ,  0.4375), vec2(-0.4375, -0.5   )  \\\n                       )\n                             \n#define AA_1                                                             \\\n  const int sampleCount = 1;                                             \\\n  const vec2[] samplePositions = MS_STANDARD_1;\n\n#define AA_2                                                             \\\n  const int sampleCount = 2;                                             \\\n  const vec2[] samplePositions = MS_STANDARD_2;\n\n#define AA_4                                                             \\\n  const int sampleCount = 4;                                             \\\n  const vec2[] samplePositions = MS_STANDARD_4;\n\n#define AA_8                                                             \\\n  const int sampleCount = 8;                                             \\\n  const vec2[] samplePositions = MS_STANDARD_8;\n\n#define AA_16                                                            \\\n  const int sampleCount = 16;                                            \\\n  const vec2[] samplePositions = MS_STANDARD_16;\n\n#define INCLUDE_SUPER_SAMPLE_FUNCTION(name, quality, takeSample)         \\\n  vec4 name(in vec2 fragCoord) {                                         \\\n    quality                                                              \\\n    vec4 result = vec4(0.0);                                             \\\n    for (int i = 0; i < sampleCount; i++) {                              \\\n      result += takeSample(fragCoord + samplePositions[i]);              \\\n    }                                                                    \\\n                                                                         \\\n    return result \/ float(sampleCount);                                  \\\n  }\n\n#define INCLUDE_GRID_SUPER_SAMPLE_FUNCTION(name, takeSample)             \\\n  vec4 name(in vec2 fragCoord, in int samplesSqrt) {                     \\\n    vec4 outColor = vec4(0.0);                                           \\\n    for (int x = 0; x < samplesSqrt; x++) {                              \\\n      for (int y = 0; y < samplesSqrt; y++) {                            \\\n        vec2 offset =                                                    \\\n          vec2((float(x) + 0.5) * (1.0 \/ float(samplesSqrt)) - 0.5,      \\\n               (float(y) + 0.5) * (1.0 \/ float(samplesSqrt)) - 0.5);     \\\n        vec2 samplePosition = fragCoord + offset;                        \\\n        outColor += takeSample(samplePosition);                          \\\n      }                                                                  \\\n    }                                                                    \\\n                                                                         \\\n    return outColor \/ float(samplesSqrt * samplesSqrt);                  \\\n  }","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"\/presets\/tex00.jpg","previewfilepath":"\/presets\/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"INCLUDE_GAME_CONSTANTS  \nINCLUDE_STATE_STRUCT\nINCLUDE_STATE_LOAD_FUNCTION\nINCLUDE_STATE_SAVE_FUNCTION\n\n#define KEY_SPACE 32\n#define KEY_LEFT 37\n#define KEY_RIGHT 39\n\nfloat timeDelta() {\n  return iTimeDelta * 1.0;\n}\n\nfloat random(float seed) {\n  return fract(sin(seed) * 43758.5453123);\n}\n\nGap randomGap(float seed) {\n  Gap gap;\n  \n  gap.position = (random(seed) - 0.5) * 1.3;\n  gap.size = 0.2 + random(seed * 0.37) * 0.3;\n  \n  return gap;\n}\n\nvoid initPlane(inout State state) {\n  float side = random(iDate.w) < 0.5 ? -1.0 : 1.0;\n\n  Plane plane;\n  plane.position = startingPosition;\n  plane.position.x *= side;\n  plane.angle = startingAngle * side;\n  state.plane = plane;\n}\n\nState initialState() {\n  State state;\n  \n  state.oldResolution = iResolution.xy;\n  state.newResolution = iResolution.xy;\n  \n  initPlane(state);\n  \n  state.animationState = STATE_INTRO;\n  state.animationTime = 0.0;\n  state.pipesOffset = 0.0;\n  state.score = 0;\n  state.highScore = 0;\n  state.traveledDistance = 0.0;\n  \n  state.isPlayPressed = false;\n  \n  for (int i = 0; i < pipesCount; i++) {\n    state.gaps[i] = randomGap(float(i));\n  }\n  \n  return state;\n}\n\nvoid handlePlayButton(inout State state) {\n  if (state.isPlayPressed && !isKeyDown(KEY_SPACE)) {\n    state.animationState = STATE_OUTRO;\n    state.animationTime = 0.0;\n  }\n  state.isPlayPressed = isKeyDown(KEY_SPACE);\n}\n\nfloat planeFall(in Plane plane) {\n  float speed = timeDelta() * 2.0;\n  return (0.9 - pow(abs(plane.angle), 1.4)) * speed;\n}\n\nvoid movePlane(inout Plane plane) {\n  float speed = timeDelta() * 2.0;\n  plane.position.x += plane.angle * speed;\n  plane.position.y -= planeFall(plane);\n}\n\nvec2 planeHitbox(in Plane plane) {\n  float angle = plane.angle * 2.1 + 3.1416 * 0.5;\n  vec2 hitbox = plane.position - vec2(cos(angle), sin(angle)) * planeSize * 0.39;\n  hitbox.y += planeSize * 0.05;\n  return hitbox;\n}\n\nbool outOfBounds(in vec2 hitbox) {\n  return hitbox.x < -1.0 || hitbox.x > 1.0; \n}\n\nbool intersectsPipes(in vec2 hitbox, in State state) {\n  for (int i = 0; i < pipesCount; i++) {\n    Gap gap = state.gaps[i];\n    vec2 position = vec2(gap.position, \n      pipesStart + state.pipesOffset + float(i) * pipesGap);\n    float deltaY = abs(hitbox.y - position.y);\n    if (deltaY < pipeSize * 0.25) {\n      float deltaX = abs(hitbox.x - position.x);\n      if (deltaX > gap.size) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nState updateState(in State state) {\n  state.oldResolution = state.newResolution;\n  state.newResolution = iResolution.xy;\n  \n  switch (state.animationState) {\n    case STATE_INTRO:\n      if (state.score > state.highScore) {\n        state.highScore = state.score;\n      }\n      state.pipesOffset += timeDelta();\n      state.animationTime += timeDelta();\n      if (state.animationTime > 0.5) {\n        handlePlayButton(state);\n      }\n      if (state.animationTime >= 1.0) {\n        state.animationState = STATE_MENU;\n      }\n      break;\n    case STATE_MENU:\n      state.pipesOffset += timeDelta();\n      handlePlayButton(state);\n      break;\n    case STATE_OUTRO:\n      movePlane(state.plane);\n      if (state.animationTime > 0.6) {\n        if (state.animationTime < 2.5) {\n          state.pipesOffset = mix(state.pipesOffset, startingOffset, 0.05);\n        } else {\n          state.animationState = STATE_IN_GAME;\n          state.traveledDistance = 0.0;\n          state.score = 0;\n        }\n      } else {\n        state.pipesOffset += timeDelta();\n      }\n      state.animationTime += timeDelta();\n      break;\n    case STATE_IN_GAME:\n      if (isKeyDown(KEY_LEFT)) {\n        state.plane.angle -= turningSpeed * timeDelta();\n      }\n      if (isKeyDown(KEY_RIGHT)) {\n        state.plane.angle += turningSpeed * timeDelta();\n      }\n      state.plane.angle = clamp(state.plane.angle, -0.5, 0.5);\n    \n      movePlane(state.plane);\n    \n      if (state.plane.position.y < planeMinPosition) {\n        float delta = abs(state.plane.position.y - planeMinPosition);\n        state.pipesOffset += delta;\n        state.traveledDistance += delta;\n        state.plane.position.y = planeMinPosition;\n      }\n     \n      state.score = int((state.traveledDistance - 0.45) \/ pipesGap);\n      \n      vec2 hitbox = planeHitbox(state.plane); \n      if (outOfBounds(hitbox) || intersectsPipes(planeHitbox(state.plane), state)) {\n        state.animationState = STATE_GAME_OVER;\n        state.animationTime = 0.0;\n      }\n      state.animationTime += timeDelta();\n      break;\n      \n    case STATE_GAME_OVER:\n      state.animationTime += timeDelta();\n      float delta = planeFall(state.plane);\n      state.pipesOffset += delta;\n      state.plane.position.y += delta;\n      \n      if (state.animationTime > 1.0) {\n        state.animationState = STATE_INTRO;\n        state.animationTime = 0.0;\n        initPlane(state);\n      }\n      break;\n  }\n  \n  if (state.pipesOffset > pipesGap) {\n    state.pipesOffset = mod(state.pipesOffset, pipesGap);\n    for (int i = pipesCount - 1; i > 0; i--) {\n      state.gaps[i] = state.gaps[i - 1];\n    }\n    state.gaps[0] = randomGap(iTime);\n  }\n  \n  return state;\n}\n  \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  fragColor = vec4(0.0);\n  fragmentCoordinates = ivec2(fragCoord).x;\n  if (fragmentCoordinates < endOfData) {\n    if (iFrame == 0) {\n      saveState(initialState());\n    } else {\n      saveState(updateState(loadState()));\n    }\n    fragColor = outputColor;\n  }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"INCLUDE_TEXTURE_GRID_WIDTH\n\nconst float pi = 3.1416;\nconst float epsilon = 0.00001;\nconst vec3 right = vec3(1.0, 0.0, 0.0);\nconst vec3 up = vec3(0.0, 1.0, 0.0);\nconst vec3 forward = vec3(0.0, 0.0, -1.0);\n\nconst vec3[] points =\n    vec3[](vec3(0.0, -1.3, 0.0), vec3(-1.0, 1.0, 0.0), vec3(-0.21, 1.0, 0.0),\n           vec3(0.0, 0.92, -0.4), vec3(0.21, 1.0, 0.0), vec3(0.9, 1.0, 0.0));\nconst ivec3[] triangles =\n    ivec3[](ivec3(0, 1, 2), ivec3(2, 3, 0), ivec3(3, 4, 0), ivec3(4, 5, 0));\nconst ivec2[] lines =\n    ivec2[](ivec2(0, 1), ivec2(0, 2), ivec2(0, 3), ivec2(0, 4), ivec2(0, 5),\n            ivec2(1, 2), ivec2(2, 3), ivec2(3, 4), ivec2(4, 5));\nconst int lengthTriangles = 4;\nconst int lengthLines = 9;\n\nstruct Ray {\n  vec3 origin;\n  vec3 direction;\n};\n    \nstruct Sphere {\n  vec3 origin;\n  float radius;\n};\n    \nmat4 rotationMatrix(in vec3 axis, in float angle) {\n  axis = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n\n  return mat4(\n      oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,\n      oc * axis.z * axis.x + axis.y * s, 0.0, oc * axis.x * axis.y + axis.z * s,\n      oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, 0.0,\n      oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s,\n      oc * axis.z * axis.z + c, 0.0, 0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 translationMatrix(in vec3 translation) {\n  return mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0,\n              translation.x, translation.y, translation.z, 1.0);\n}\n\nRay createRayOrthographic(in vec2 screenPosition) {\n  return Ray(vec3(screenPosition, 0.0), vec3(0.0, 0.0, -1.0));\n}\n\nvec3 positionOnRay(in Ray ray, in float t) {\n  return ray.origin + ray.direction * t;\n}\n\nvoid transformRay(inout Ray ray, mat4 matrix) {\n  ray.origin = (matrix * vec4(ray.origin, 1.0)).xyz;\n  ray.direction = normalize(matrix * vec4(ray.direction, 0.0)).xyz;\n}\n\nbool rayIntersectsSphere(in Ray ray, in Sphere sphere, out float t0,\n                         out float t1) {\n  float a = dot(ray.direction, ray.direction);\n  vec3 s0_r0 = ray.origin - sphere.origin;\n  float b = 2.0 * dot(ray.direction, s0_r0);\n  float c = dot(s0_r0, s0_r0) - (sphere.radius * sphere.radius);\n  float delta = b * b - 4.0 * a * c;\n  float a_2 = 2.0 * a;\n\n  if (delta < 0.0) {\n    return false;\n  }\n\n  float delta_sqrt = sqrt(delta);\n\n  t0 = (-b - delta_sqrt) \/ a_2;\n  t1 = (-b + delta_sqrt) \/ a_2;\n\n  return true;\n}\n\nbool rayIntersectsTriangle(in Ray ray, in vec3 v0, in vec3 v1, in vec3 v2,\n                           out float t) {\n  vec3 edge1, edge2, h, s, q;\n  float a, f, u, v;\n\n  edge1 = v1 - v0;\n  edge2 = v2 - v0;\n\n  h = cross(ray.direction, edge2);\n  a = dot(edge1, h);\n\n  if (a > -epsilon && a < epsilon)\n    return false;\n\n  f = 1.0 \/ a;\n  s = ray.origin - v0;\n  u = f * dot(s, h);\n\n  if (u < 0.0 || u > 1.0)\n    return false;\n\n  q = cross(s, edge1);\n  v = f * dot(ray.direction, q);\n\n  if (v < 0.0 || u + v > 1.0)\n    return false;\n\n  \/\/ At this stage we can compute t to find out where the intersection point is\n  \/\/ on the line.\n  t = f * dot(edge2, q);\n  if (t > epsilon) \/\/ ray intersection\n  {\n    return true;\n  }\n\n  \/\/ This means that there is a line intersection but not a ray intersection.\n  return false;\n}\n\nbool rayIntersectsCylinder(in Ray ray, in vec3 pa, in vec3 pb, in float radius, \n                           out float t0, out float t1) {\n  vec3 ro = ray.origin;\n  vec3 rd = ray.direction;\n\n  vec3 cc = 0.5 * (pa + pb);\n  float ch = length(pb - pa);\n  vec3 ca = (pb - pa) \/ ch;\n  ch *= 0.5;\n\n  vec3 oc = ro - cc;\n\n  float card = dot(ca, rd);\n  float caoc = dot(ca, oc);\n\n  float a = 1.0 - card * card;\n  float b = dot(oc, rd) - caoc * card;\n  float c = dot(oc, oc) - caoc * caoc - radius * radius;\n  float h = b * b - a * c;\n  if (h < 0.0)\n    return false;\n  h = sqrt(h);\n  t0 = (-b - h) \/ a;\n  t1 = (-b + h) \/ a; \/\/ exit point\n\n  float y = caoc + t0 * card;\n\n  \/\/ body\n  if (abs(y) < ch) {\n    return true;\n  }\n\n  return false;\n}\n\nbool rayIntersectsLine(in Ray ray, in vec3 pa, in vec3 pb, in float radius, out float t) {\n  float t0, trash;\n\n  t = 100000.0;\n\n  bool i = false;\n  if (rayIntersectsSphere(ray, Sphere(pa, radius), t0, trash)) {\n    t = t0;\n    i = true;\n  }\n\n  if (rayIntersectsSphere(ray, Sphere(pb, radius), t0, trash) && t0 < t) {\n    t = t0;\n    i = true;\n  }\n\n  if (rayIntersectsCylinder(ray, pa, pb, radius, t0, trash) && t0 < t) {\n    t = t0;\n    i = true;\n  }\n\n  return i;\n}\n\n\nvec4 trace(in Ray ray, int i) {\n  vec4 color = vec4(0.0);  \n    \n  float total = float(textureGridWidth * textureGridWidth - 2);\n  float angle = float(i - 1) \/ total - 0.5;  \n    \n  mat4 transform = rotationMatrix(up, 0.0) *\n                   rotationMatrix(forward, angle * 2.2) *\n                   rotationMatrix(right, -0.6) *\n                   translationMatrix(vec3(0.0, 0.0, 12.0));\n  transformRay(ray, transform);  \n    \n  float t0 = 100000.0;\n  for (int i = 0; i < lengthTriangles; i++) {\n    ivec3 triangle = triangles[i];\n    vec3 a = points[triangle[0]];\n    vec3 b = points[triangle[1]];\n    vec3 c = points[triangle[2]];\n\n    float t;\n    if (rayIntersectsTriangle(ray, a, b, c, t) && t < t0) {\n      t0 = t - 0.0;\n      color = vec4(1.0);\n    }\n  }\n\n  for (int i = 0; i < lengthLines; i++) {\n    ivec2 line = lines[i];\n    vec3 a = points[line[0]];\n    vec3 b = points[line[1]];\n\n    float t;\n    vec3 normal;\n    if (rayIntersectsLine(ray, a, b, 0.04, t) && t < t0) {\n      t0 = t;\n      color = vec4(vec3(0.0), 1.0);\n    }\n  } \n    \n  return color;\n}\n\nvec4 drawPipe(in vec2 position) {\n  float offset = position.x < 0.0 ? 0.17 : 0.0;\n \n  if (position.x > 0.8) {\n    return vec4(0.0);\n  }\n \n  if (abs(position.y) < 0.9 - offset) {\n    if ((abs(position.y) < 0.8 - offset) && \n        !(position.x > 0.0 && position.x < 0.1) && \n        (position.x < 0.7)) {\n      float y = position.y + offset * 0.97;\n      vec3 color = vec3(0.458, 0.835, 0.184);\n      color = y > 0.57 && y < 0.73 ? vec3(0.803, 0.964, 0.505) : color;\n      color = y > 0.45 && y < 0.53 ? vec3(0.740, 0.940, 0.442) : color;\n      color = y > 0.37 && y < 0.4 ? vec3(0.658, 0.935, 0.284) : color;\n      y = position.y - offset * 0.9;\n      color = y < -0.55 && y > -0.8 ? vec3(0.380, 0.734, 0.145) : color;\n      color = y < -0.7 && y > -0.8 ? vec3(0.280, 0.634, 0.145) : color;\n      \n      return vec4(toLinear(color), 1.0);\n    }\n    \n    return vec4(toLinear(vec3(0.233, 0.227, 0.247)), 1.0);\n  }\n  \n  return vec4(0.0);\n}\n\nvec4 takeSample(in vec2 position) {\n  float size = iResolution.y \/ float(textureGridWidth);\n  ivec2 xy = ivec2(position \/ size);\n  position = mod(position, size); \n  position -= vec2(0.5 * size);\n  position \/= size * 0.33;\n    \n  int i = xy.x + xy.y * textureGridWidth;\n  if (i == 0) {\n    position *= 1.2;\n    return drawPipe(position);\n  } else {\n    Ray ray = createRayOrthographic(position);\n    return trace(ray, i);\n  }\n}\n\nbool resolutionChanged() {\n  vec4 resolutionData = loadVariable(resolutionLocation);\n  return resolutionData.xy != resolutionData.zw;\n}\n\n\nINCLUDE_SUPER_SAMPLE_FUNCTION(superSample, AA_16, takeSample)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  if (iFrame > 0 && !resolutionChanged()) {\n    vec2 uv = fragCoord \/ iResolution.xy;\n    fragColor = texture(iChannel1, uv);\n    return;\n  }   \n    \n  if (fragCoord.x > iResolution.y) {\n    fragColor = vec4(0.0);\n    return;\n  }\n    \n  fragColor = superSample(fragCoord);\n}","name":"Buffer B","description":"","type":"buffer"}]}];    var gUseScreenshots = piIsMobile();
    var gThemeName = "classic";



    </script>
</head>

<!-- <body onload="resultsInit(12,null,null)"> -->
<body onload="resultsInitStatic(12,null,null)">

<!-- header =================================================================================== -->


<div id="header">

    <div id="headerBlock1">
        <a href="/" id="headerTitle">Shadertoy</a>
        <form name="formSearch" action="/results" method="get" style="display:inline-block;">
        <div  id="headerSearch">
            <input type="search" id="mySearch" name="query" placeholder="Search..." value=""/>
        </div>
        </form>
    </div>

    <div id="headerBlock2">
            <a class="headerLinks" href="/browse">Browse</a>
        <a class="headerLinks" href="/new">New</a>
        <a class="headerLinks" href="/signin">Sign In</a>
        </div>
</div>
<!-- content ================================================================================== -->

<div id="content">

  <div id="controls">
    <div>
      <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
      Sort:      </div>
      <div class="controlOptions"><div class="pageButtonsCurrent" href="/results?query=&sort=popular&filter=">Popular</div><a class="pageButtons" href="/results?query=&sort=newest&filter=">Newest</a><a class="pageButtons" href="/results?query=&sort=love&filter=">Love</a><a class="pageButtons" href="/results?query=&sort=hot&filter=">Hot</a></div>
    </div>

    <div id="controlFilter">
      <div style="display:flex;margin-right:8px;align-items:center;">Filter:</div>
      <div class="controlOptions"> <a class="pageButtons" href="/results?query=&sort=popular&filter=multipass">Multipass</a><a class="pageButtons" href="/results?query=&sort=popular&filter=soundoutput">GPU Sound</a><a class="pageButtons" href="/results?query=&sort=popular&filter=vr">VR</a><a class="pageButtons" href="/results?query=&sort=popular&filter=soundinput">Microphone</a><a class="pageButtons" href="/results?query=&sort=popular&filter=musicstream">Soundcloud</a><a class="pageButtons" href="/results?query=&sort=popular&filter=webcam">Webcam</a></div>
    </div>

    <div>
        <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
        View:</div>
        <div><a class="pageButtons" href="/slideshow?query=&sort=popular">Slideshow</a></div>
    </div>

    <div class="navigation" id="navTop" ><span style="padding-right:8px;">Results (74098):</span><div class="controlOptions"><a id="pageButtonFirst" class="pageButtons" href="results?query=&sort=popular&from=0&num=12">1</a><span>...</span><a id="pageButton"0 class="pageButtons" href="results?query=&sort=popular&from=660&num=12">56</a><a id="pageButton"1 class="pageButtons" href="results?query=&sort=popular&from=672&num=12">57</a><div id="pageButton"2 class="pageButtonsCurrent" href="results?query=&sort=popular&from=684&num=12">58</div><a id="pageButton"3 class="pageButtons" href="results?query=&sort=popular&from=696&num=12">59</a><a id="pageButton"4 class="pageButtons" href="results?query=&sort=popular&from=708&num=12">60</a><span>...</span><a id="pageButtonLast" class="pageButtons" href="results?query=&sort=popular&from=74088&num=12">6175</a></div>
</div>
  </div>


  <div id="shaderGrid">
    <div class='searchResult'><div class='searchResultContainer' id='Preview_0_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_0_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_0_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_0_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_0_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_0_Thumnail'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_0_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_0_Info'>  <span class='previewText'  id='Preview_0_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_0_TextUser'></span>  <span class='previewStats' id='Preview_0_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_1_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_1_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_1_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_1_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_1_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_1_Thumnail'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_1_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_1_Info'>  <span class='previewText'  id='Preview_1_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_1_TextUser'></span>  <span class='previewStats' id='Preview_1_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_2_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_2_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_2_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_2_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_2_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_2_Thumnail'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_2_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_2_Info'>  <span class='previewText'  id='Preview_2_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_2_TextUser'></span>  <span class='previewStats' id='Preview_2_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_3_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_3_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_3_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_3_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_3_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_3_Thumnail'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_3_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_3_Info'>  <span class='previewText'  id='Preview_3_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_3_TextUser'></span>  <span class='previewStats' id='Preview_3_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_4_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_4_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_4_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_4_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_4_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_4_Thumnail'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_4_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_4_Info'>  <span class='previewText'  id='Preview_4_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_4_TextUser'></span>  <span class='previewStats' id='Preview_4_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_5_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_5_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_5_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_5_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_5_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_5_Thumnail'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_5_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_5_Info'>  <span class='previewText'  id='Preview_5_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_5_TextUser'></span>  <span class='previewStats' id='Preview_5_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_6_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_6_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_6_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_6_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_6_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_6_Thumnail'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_6_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_6_Info'>  <span class='previewText'  id='Preview_6_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_6_TextUser'></span>  <span class='previewStats' id='Preview_6_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_7_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_7_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_7_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_7_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_7_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_7_Thumnail'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_7_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_7_Info'>  <span class='previewText'  id='Preview_7_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_7_TextUser'></span>  <span class='previewStats' id='Preview_7_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_8_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_8_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_8_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_8_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_8_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_8_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_8_Thumnail'>        <img class='previewThumbnailImage' id='Preview_8_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_8_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_8_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_8_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_8_Info'>  <span class='previewText'  id='Preview_8_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_8_TextUser'></span>  <span class='previewStats' id='Preview_8_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_9_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_9_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_9_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_9_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_9_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_9_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_9_Thumnail'>        <img class='previewThumbnailImage' id='Preview_9_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_9_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_9_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_9_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_9_Info'>  <span class='previewText'  id='Preview_9_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_9_TextUser'></span>  <span class='previewStats' id='Preview_9_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_10_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_10_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_10_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_10_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_10_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_10_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_10_Thumnail'>        <img class='previewThumbnailImage' id='Preview_10_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_10_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_10_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_10_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_10_Info'>  <span class='previewText'  id='Preview_10_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_10_TextUser'></span>  <span class='previewStats' id='Preview_10_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_11_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_11_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_11_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_11_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_11_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_11_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_11_Thumnail'>        <img class='previewThumbnailImage' id='Preview_11_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_11_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_11_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_11_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_11_Info'>  <span class='previewText'  id='Preview_11_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_11_TextUser'></span>  <span class='previewStats' id='Preview_11_Stats'></span></div></div>  </div>
  <br>
  <div class="navigation" id="navBottom" ><span style="padding-right:8px;">Results (74098):</span><div class="controlOptions"><a id="pageButtonFirst" class="pageButtons" href="results?query=&sort=popular&from=0&num=12">1</a><span>...</span><a id="pageButton"0 class="pageButtons" href="results?query=&sort=popular&from=660&num=12">56</a><a id="pageButton"1 class="pageButtons" href="results?query=&sort=popular&from=672&num=12">57</a><div id="pageButton"2 class="pageButtonsCurrent" href="results?query=&sort=popular&from=684&num=12">58</div><a id="pageButton"3 class="pageButtons" href="results?query=&sort=popular&from=696&num=12">59</a><a id="pageButton"4 class="pageButtons" href="results?query=&sort=popular&from=708&num=12">60</a><span>...</span><a id="pageButtonLast" class="pageButtons" href="results?query=&sort=popular&from=74088&num=12">6175</a></div>
</div>  <br>      
</div>

<!-- footer ================================================================================== -->

<div id="footer">
    
    <div><span style="color:#ffffff;">Community Forums</span>
      <ul>
      <li><a class="regular" href="/events">Official Events</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/147749602472741">In Facebook (english)</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/1339783682699494">In Facebook (korean)</a></li>
      <li><a class="regular" href="https://discord.gg/XtmMN6E">In Discord</a> (<a class="regular" href="https://discordapp.com/channels/578696555612209173/579531723348639754">direct link</a>)</li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Feedback and Support</span>
      <ul>
      <li><a class="regular" href="https://www.facebook.com/Shadertoy">Facebook</a></li>
      <li><a class="regular" href="https://twitter.com/shadertoy">Twitter</a></li>
      <li><a class="regular" href="https://www.patreon.com/shadertoy">Patreon</a></li>
      <li><a class="regular" href="https://trello.com/b/5hM0CjId">Roadmap</a></li>

      
      </ul>
    </div>

    <div><span style="color:#ffffff;">Shadertoy</span>
      <ul>
      <li><a class="regular" href="/store">Store</a></li>
      <li><a class="regular" href="/howto">Documentation</a></li>
      <li><a class="regular" href="/terms">Terms & Privacy</a></li>
      <li><a class="regular" href="/about">About</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Apps and Plugins</span>
      <ul>
      <li><a class="regular" href="https://itunes.apple.com/us/app/shadertoy/id717961814">Official iPhone App</a> by <a class="user" href="/user/reinder">Reinder</a></li>
      <li><a class="regular" href="https://steamcommunity.com/sharedfiles/filedetails/?id=1726697188">Screensaver</a> by <a class="user" href="/user/kosro">Kosro</a></li>
      <li><a class="regular" href="https://chrome.google.com/webstore/detail/shadertoy-unofficial-plug/ohicbclhdmkhoabobgppffepcopomhgl">Shadertoy plugin</a> by <a class="user" href="/user/patu">Patu</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Tutorials</span>
      <ul>
      <li><a class="regular" href="https://www.youtube.com/watch?v=0ifChJ0nJfM">Shader coding intro</a> by <a class="user" href="/user/iq">iq</a></li>
      <li><a class="regular" href="https://shadertoyunofficial.wordpress.com/">Shadertoy Unofficial</a> by <a class="user" href="/user/FabriceNeyret2">FabriceNeyret2</a></li>
      </ul>
    </div>

</div>

<div id="compliance" style="padding-bottom:6px;visibility:hidden;left:0;top:0px;width:100%;background-color:rgb(200,120,20,0.93);position:absolute;color:#FFFFFF">
    <div style="text-align: center; margin-top:8px">
        We use cookies to give you the best experience on our website. If you continue using Shadertoy, we'll assume that you are happy to receive all cookies on this website. 
        For more information, please review our <a class="regular" href="/terms">Terms & Privacy</a>.
    </div> 
    <div style="text-align: center;margin-top:6px">
        <button type="button" style="width:100px;font-size:inherit" onclick="acceptCompliance()">Accept</button>
    </div>
</div>

<script>
(function runCompliance() 
{
    let showCompliance = 1;
    let allcookies = document.cookie;
    let cookiearray = allcookies.split(';');
    for (var i=0; i<cookiearray.length; i++)
    {
        let name  = cookiearray[i].split('=')[0];
        let value = cookiearray[i].split('=')[1];
        if (name.trim() == "scmp") 
        {
            showCompliance = value;
            break;
        }
    }

    if (showCompliance === 1) 
    {
        var ve = document.getElementById("compliance");
        ve.style.visibility="visible";
    }
})();

function acceptCompliance()
{
    let now = new Date();
    now.setTime( now.getTime() + (5*365*24*60*60*1000) );
    document.cookie="scmp=0;expires=" + now.toUTCString() + ";";

    var ve = document.getElementById("compliance");
    ve.style.visibility="hidden";
}
</script>

</body>
</html>
