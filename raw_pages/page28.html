<!DOCTYPE HTML>
<html lang="en">
<head>

    
<script async src="https://www.googletagmanager.com/gtag/js?id=G-7SYLWGZYJ2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-7SYLWGZYJ2');
</script>

<title>Browse (29) - Shadertoy BETA</title>
<meta charset="utf-8" />
<meta name="Keywords" content="shadertoy, shader toy, quilez, inigo, jeremias, pol, fractals, demoscene, computer graphics, mathematics, rendering, demo, 3D, realtime, shader, raytracing, raymarching, webgl, glsl" />
<meta name="Description" content="Build shaders, share them, and learn from the best community." />
<meta name="Author" content="Beautypi" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<link rel="image_src" href="https://www.shadertoy.com/img/logo.png" />
<link rel="apple-touch-icon" href="/img/launch_icon_57.png"/>
<link rel="apple-touch-icon" sizes="72x72" href="/img/launch_icon_72.png"/>
<link rel="apple-touch-icon" sizes="114x114" href="/img/launch_icon_114.png"/>
<link rel="shortcut icon" href="/img/favicon.ico"/>

<style>::-webkit-scrollbar {
    height: 8px;
    width: 8px;
    background: #404040;
}

::-webkit-scrollbar-thumb
{
    background: #909090;
    border-radius: 0ex;
}

::-webkit-scrollbar-corner
{
    background: #000;
}

::-webkit-input-placeholder
{
	font-style:italic;
}
input:-moz-placeholder, textarea:-moz-placeholder
{
	font-style:italic;
}
input.placeholder-text, textarea.placeholder-text
{
	font-style:italic;
}

pre 
{
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
    white-space: -pre-wrap;
    white-space: -o-pre-wrap;
    word-wrap: break-word;
}

@font-face
{
    font-family: Lobster;
    src: url("/img/lobster.otf") format("opentype");
}

div#centerScreen
{
    left: 50%;
    top: 50%;
    position: absolute;
}

a.headerLinks:hover
{
    background-color:#505050;
    color : #ff8020;
}

body
{
    color: #000000;
    font-size:12px;
    font-style:normal;
    font-family:Tahoma,Arial;
    background-repeat: no-repeat;
    //background-attachment: fixed;
    padding:0px;
    margin:0px;
    text-align: left;
    background-color: #d0d0d0;
    background-repeat: repeat;
    user-select: text;
}

a,
a:hover,
a:visited
{
  color : inherit;
}

div#content {
    width: 95%;
    overflow: hidden;
    margin: auto;
    padding: 0px;
    min-height: calc(100vh - 80px);
    //box-sizing: border-box;
}


.notificationCount
{
 background-color:#ff0000;
 padding-left:3px;
 padding-right:1px;
 padding-top:1px;
 padding-bottom:1px;
}

div#header
{
    background-color: #404040;
    top: 0px;
    left: 0px;
    width: 100%;
    padding: 0;
    margin: 0;
    color: #ffffff;
    display: flex;
    flex-direction:row;
}

#headerBlock1
{
    width: 50%;
    display:flex;
    align-items:center;
}

a#headerTitle
{
    font-size: 2.25em;
    font-family: Lobster,Tahoma,Arial;
    text-decoration: none;
    padding-left:32px;
    padding-right:32px;
}

#headerSearch
{
    display: inline-block;
    color: #000000;
    width: 300px;
}

input[type=search]#mySearch
{
    width: 100%;
    border-radius: 6px;
    border: 1px solid black;
    padding:12px;
}

#headerBlock2
{
    width: 50%;
    margin-left: auto;
    display: flex;
    justify-content: flex-end;
}


a#headerTitle:hover
{
    color : #ff8020;
}

a.headerLinks
{
    font-weight: bold;
    padding-top: 14px;
    padding-bottom: 14px;
    padding-left: 14px;
    padding-right: 14px;
    margin:0px;
    text-decoration: none;
    transition: background-color 0.15s linear, color 0.15s linear;
}

#footer
{
    background-color: rgba(64,64,64,0.25);
    color: #000000;
    padding: 0px;
    margin: 0px;
    width: 100%;
    display: flex;
    justify-content: space-between;
    flex-wrap: wrap;
}

#footer div
{
    padding-top:10px;
    padding-bottom:0px;
    padding-left:16px;
    padding-right:16px;
}

#footer div ul
{
    margin-left:0px;
    padding-left:16px;
}

#footer div ul li
{
    padding-top:6px;
}

a.regular
{
    font-weight:bold;
    text-decoration:none
}

a.regular:hover
{
  color : #ff8020;
}

a.user
{
    font-weight:bold;
    text-decoration:none;
}

a.user:hover
{
  color : #ff8020;
  text-decoration: underline;
}

.uiButton
{
    border: none;
    outline: none;
    margin: 0px;
    padding: 0px;
    width: 22px;
    height: 22px;
    position: absolute;
    cursor: pointer;
    border-radius: 4px;
}

.uiButton:hover
{
    box-shadow: inset 0px 0px 1px 1px #808080, 0px 0px 1px 1px #808080;
}

.uiDivBUtton
{
    cursor:pointer;
}

.uiDivBUtton:hover
{
    color: #ffffff;
}


.dialog
{
    display: block;
    background-color: #e0e0e0;
    color: #000000;
    border:1px solid #000;
    padding:0px;
    margin:0px;
    text-align:left;
    border-radius: 4px;
    box-shadow:4px 4px 6px 0px rgba(0,0,0,0.5);
    overflow: hidden;
    z-index:1000;
    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;
}

.dialogHeader
{
    left:0px;
    top: 0px;
    width:100%;
    height:32px;
    position: absolute;
    background-color: #808080;
    cursor:move;
}

.dialogTitle
{
    left: 12px;
    top: 4px;
    position: absolute;
    padding: 0px;
    margin: 0px;
    color:#000000;
    font-size:1.5em;
    text-align: left;
    user-select: none;
    -moz-user-select: -moz-none;
    -webkit-user-select: none;
}

.dialogOverlay
{
    z-index:1000;

    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;

    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    width:100%;
    height:100%;
    position:absolute;

    background-color:rgba(0,0,0,.4);
}

.viewsIcon, .likesIcon
{
    border: none;
    outline: none;
    display:inline-block;
    background-repeat:no-repeat;
    top:0px;
    left:0px;
    padding:0px;
    padding-right: 2px;
    margin:0px;
    position:relative;
}

.userPictureSmall
{
    background-color:#808080;
    border: 1px solid #000000;
    width:32px;
    height:32px;
}

.dialogCloseButton
{
    right:8px;
    top: 4px;
    width:22px;
    height:22px;
    position: absolute;
    background-image: url("/img/close.png");
    cursor: pointer;
    border-radius: 4px;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContentButtons
{
     padding:0;
     border:0;
     text-align: justify;
     left: 24px;
     bottom:40px;
     position:absolute;
}

.dialogButton
{
    text-align: center;
    vertical-align: middle;
    display: inline-block;
    border-radius: 4px;
    font-weight: bold;
    cursor: pointer;
    padding-bottom:5px;
    padding-top:4px;
    padding-left: 8px;
    padding-right: 8px;
    margin-left:4px;
    margin-right:4px;
    text-decoration: none;
    color:#000000;
    width: 80px;
    -moz-transition:    background-color 0.15s linear, color 0.15s linear;
    -webkit-transition: background-color 0.15s linear, color 0.15s linear;
    transition:         background-color 0.15s linear, color 0.15s linear;
}

.dialogButton:hover
{
  background-color:#808080;
  color : #ff8020;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContent
{
    color: inherit;
    overflow: auto;
    width:100%;
    height:100%;
    left: 0px;
    top: 32px;
    position:absolute
}

.dialogContentBody
{
    color: inherit;
    width:100%;
    height:auto;
    padding-top:24px;
    padding-bottom:24px;
    padding-left:24px;
    padding-right:24px;
    text-align: left;
}

.formButton
{
    font-weight:bold;
	color:#ffffff;
	border:none;
    text-align:center;
	background-color:#808080;
    border-radius: 4px;
	padding-left:8px;
	padding-right:8px;
	padding-top:4px;
	padding-bottom:4px;
    cursor:pointer;
    min-width:80px;
    box-sizing: border-box;
}
.formInput {
    border-radius: 6px;
    border: 1px solid black;
    padding: 4px;
    border: none;
}
.formButton:hover {
    background-color: #e0e0e0;
}
.formButton:disabled
{
	color:#b0b0b0;
	background-color:#808080;
}

.formButtonSmall
{
    color:#ffffff;
    border:none;
    text-align:center;
    background-color:#808080;
    border-radius: 4px;
    padding-left:2px;
    padding-right:2px;
    padding-top:2px;
    padding-bottom:2px;
    cursor:pointer;
    min-width:40px;
}

.formButtonSmall:hover
{
    background-color: #e0e0e0;
}

.formButtonSmall:disabled
{
    color:#b0b0b0;
    background-color:#808080;
}

.formButtonSmall.disabled2,
.formButton.disabled2 { color:#b0b0b0; background-color:#808080; pointer-events: none; }

.inputForm
{
    padding-left:2%;
    padding-right:2%;
    resize: none;
    text-align: left;
    background-color:#e0e0e0;
    outline: none;
    border-radius: 4px;
    border: 1px solid #808080;
    color:inherit;
    box-sizing: border-box;
}

.inputForm:focus
{
    border: 1px solid #AFCDD8;
    background-color: #EBF2F4;
}

.transparentPannel
{
    background-color:rgba(64,64,64,0.1);
    padding:16px;
}

.comment, .commentSelf, .commentNew
{
    border-radius: 4px;
    width: 100%;
    margin-left: 0px;
    margin-right: 0px;
    margin-top: 0px;
    margin-bottom: 6px;

    padding: 14px;
    box-sizing: border-box;
    display: grid;
    grid-template-columns: 32px auto 8px;
    grid-template-rows: 1fr;
    grid-gap:8px;
}

.comment:nth-child(even)
{
    background-color: rgba(64,64,64,0.1);
}

.comment:nth-child(odd)
{
    background-color: rgba(128,128,128,0.1);
}

.commentSelf
{
    background-color: rgba(240,160,64,0.1);
}

.commentNew
{
    padding-right: 0px;
    grid-template-columns: 40px auto;
}

.commentContent
{
    vertical-align: top;
    text-align: left;
    word-break: break-all;
    word-break: break-word;
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
}


/* ----------------------- media resolutions ------------------------ */

@media screen and (max-width:799px)
{
    div#header {flex-direction:column; }
    #headerBlock1 { width:100%; }
    #headerBlock2 { width:100%; justify-content: space-around;}
    div#headerSearch {width:200px;}
    input#mySearch { width:200px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:10px; }
}

@media screen and (min-width:800px) and (max-width:1279px)
{
    body { font-size: 9px; }
    div#headerSearch {width: 250px;}
    input#mySearch { width:250px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:11px; }
}

@media screen and (min-width:1280px) and (max-width:1439px)
{
    body { font-size: 10px; }
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1440px) and (max-width:1919px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1920px) and (max-width:2559px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}

@media screen and (min-width:2560px) 
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}
body
{
    background-image: url("/img/themes/classic/background.jpg");
}
</style>

    <script>"use strict"

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piCamera
//
//==============================================================================

function piCamera()
{
    var mMatrix = setIdentity();
    var mMatrixInv = setIdentity();

    var mPosition = [0.0,0.0,0.0];
    var mXRotation = 0.0;
    var mYRotation = 0.0;

    var mPositionTarget = [0.0,0.0,0.0];
    var mXRotationTarget = 0.0;
    var mYRotationTarget = 0.0;

    var me = {};
/*
    me.Set = function( pos, dir, roll) 
             {
                 mMatrix    = setLookat( pos, add(pos,dir), [Math.sin(roll),Math.cos(roll),Math.sin(roll)] );
                 mMatrixInv = invertFast( mMatrix );
             };
*/
    me.SetPos = function(pos)
                {
                    mPosition = pos;
                    //mMatrix[ 3] = -(mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                    //mMatrix[ 7] = -(mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                    //mMatrix[11] = -(mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                };
/*
    me.GlobalMove = function(pos)
                    {
                        mMatrix[ 3] -= (mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                        mMatrix[ 7] -= (mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                        mMatrix[11] -= (mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                        mMatrixInv = invertFast(mMatrix);
                    };
*/
    me.LocalMove = function( dis )
                    {
                        dis = matMulvec( setRotationY(-mYRotation), dis);
                        mPositionTarget = sub(mPositionTarget,dis)
                    };

    me.RotateXY = function( x, y)
                  {
                    mXRotationTarget -= x;
                    mYRotationTarget -= y;
                    mXRotationTarget = Math.min( Math.max( mXRotationTarget, -Math.PI/2), Math.PI/2 );
                  };


    me.CameraExectue = function( dt )
    {
        // smooth position
        mXRotation += (mXRotationTarget-mXRotation) * 12.0*dt;
        mYRotation += (mYRotationTarget-mYRotation) * 12.0*dt;
        mPosition = add(mPosition, mul( sub(mPositionTarget, mPosition), 12.0*dt));

        // Make Camera matrix
        mMatrix = matMul( matMul(setRotationX(mXRotation), 
                                 setRotationY(mYRotation)),  
                                 setTranslation(mPosition));
        mMatrixInv = invertFast(mMatrix);

    }

    me.GetMatrix = function() { return mMatrix; };
    me.GetMatrixInverse = function() { return mMatrixInv; };
    me.SetMatrix = function( mat ) 
                    {
                        mMatrix = mat;
                        mMatrixInv = invertFast(mMatrix);

                        mPosition = getXYZ(matMulpoint(mat, [0.0,0.0,0.0]));
                        mPositionTarget = mPosition;
                    };

    me.GetPos = function() { return getXYZ(matMulpoint(mMatrixInv, [0.0,0.0,0.0])); }
    me.GetDir = function() { return getXYZ(normalize(matMulvec(mMatrixInv, [0.0,0.0,-1.0]))); }

    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piFile
//
//==============================================================================

function piFile( binaryDataArrayBuffer )
{
    // private
    //var mDataView = new DataView( binaryDataArrayBuffer, 0 );
    var mDataView = binaryDataArrayBuffer;
    var mOffset = 0;

    // public members
    var me = {};
    me.mDummy = 0;
/*
    // public functions
    me.Seek = function( off ) { mOffset = off - 3; };
    me.ReadUInt16 = function()  { var res = mDataView.getUint16( mOffset ); mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = mDataView.getUint32( mOffset ); mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = mDataView.getFloat32( mOffset ); mOffset+=4; return res; };
*/

    me.Seek = function( off ) { mOffset = off; };
    me.ReadUInt8  = function()  { var res = (new Uint8Array(mDataView,mOffset))[0]; mOffset+=1; return res; };
    me.ReadUInt16 = function()  { var res = (new Uint16Array(mDataView,mOffset))[0]; mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = (new Uint32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = (new Float32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadFloat32Array = function(n) 
                          { 
                              var src = new Float32Array(mDataView, mOffset);
                              var res = [];  for( var i=0; i<n; i++ ) { res[i] = src[i]; }
                              mOffset += 4*n;
                              return res;
                          };
    me.ReadFloat32ArrayNative = function(n) { var src = new Float32Array(mDataView, mOffset); mOffset += 4*n; return src; };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piMesh
//
//==============================================================================

function piMesh()
{
    this.mChunks = [];
    this.mPrimitiveType = 0;
    this.mVertexFormat = null;
}

/*
piMesh.prototype.normalize = function( ppos, npos )
{
    var numv = this.mVertexData.length;
    var numt = this.mIndices.length;

    for( var i=0; i<numv; i++ )
    {
        //float *v = (float*)piMesh_GetVertexData( me, i, npos );
        //v[0] = 0.0f;
        //v[1] = 0.0f;
        //v[2] = 0.0f;
        this.mVerts[8 * i + 3] = 0.0;
        this.mVerts[8 * i + 4] = 0.0;
        this.mVerts[8 * i + 5] = 0.0;
    }

    for( var i=0; i<numt; i++ )
    {
        piMeshFace *face = me->mFaceData.mIndexArray[0].mBuffer + i;

        const int ft = face->mNum;
        
        vec3 nor = vec3( 0.0f, 0.0f, 0.0f );
        for( int j=0; j<ft; j++ )
        {
            const vec3 va = *((vec3*)piMesh_GetVertexData( me, face->mIndex[ j      ], ppos ));
            const vec3 vb = *((vec3*)piMesh_GetVertexData( me, face->mIndex[(j+1)%ft], ppos ));

            nor += cross( va, vb );
        }

        for( int j=0; j<ft; j++ )
        {
            vec3 *n = (vec3*)piMesh_GetVertexData( me, face->mIndex[j], npos );
            n->x += nor.x;
            n->y += nor.y;
            n->z += nor.z;
        }
    }

    for( var i=0; i<numv; i++ )
    {
        vec3 *v = (vec3*)piMesh_GetVertexData( me, i, npos );
        *v = normalize( *v );
    }
}
*/

piMesh.prototype.createCube = function(renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([ -1.0, -1.0, -1.0,
                                       1.0, -1.0, -1.0,
                                      -1.0,  1.0, -1.0,
                                       1.0,  1.0, -1.0,
                                      -1.0, -1.0,  1.0,
                                       1.0, -1.0,  1.0,
                                      -1.0,  1.0,  1.0,
                                       1.0,  1.0,  1.0 ]),

                        mIndices : new Uint16Array([ 0, 2, 1,   1, 2, 3,   5, 1, 3,   5, 3, 7,   4, 5, 7,   4, 7, 6,   4, 6, 2,   4, 2, 0,   6, 7, 3,   6, 3, 2,   4, 0, 1,   4, 1, 5 ]),
                        mNumVertices : 8,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };

    this.mVertexFormat = { mStride:12, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}

piMesh.prototype.createCubeSharp = function (renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 1.0,
                                    -1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 0.0,

                                     1.0, 1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 0.0,

                                     1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 1.0,
                                    -1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   1.0, 1.0,
                                     1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   1.0, 0.0,

                                    -1.0, 1.0, 1.0,  -1.0, 0.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0,-1.0,  -1.0, 0.0, 0.0,   0.0, 1.0,
                                    -1.0,-1.0,-1.0,  -1.0, 0.0, 0.0,   1.0, 1.0,
                                    -1.0,-1.0, 1.0,  -1.0, 0.0, 0.0,   1.0, 0.0 ]),

                        mIndices : new Uint16Array([0,1,2, 0,2,3,   4,5,6, 4,6,7,    8,9,10,8,10,11,   12,13,14,12,14,15,   16,17,18,16,18,19,   20,21,22,20,22,23]),
                        mNumVertices : 24,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };


    this.mVertexFormat = { mStride:32, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}


piMesh.prototype.createUnitQuad = function (renderer)
{
    this.mPrimitiveType = 0;
    this.mVertexFormat = { mStride:8, mChannels: [ {mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false} ] };

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0,  1.0, 1.0,  1.0]),
                        mIndices : new Uint16Array([0, 2, 1, 1, 2, 3]),
                        mNumVertices : 4,
                        mNumFaces : 2, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };
 
    return true;
}




piMesh.prototype.destroy = function()
{
    //delete this.mVerts;   this.mVerts = null;
    //delete this.mIndices; this.mIndices = null;
}

piMesh.prototype.scale = function (x, y, z)
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] *= x;
            this.mChunks[j].mVerts[stride * i + 1] *= y;
            this.mChunks[j].mVerts[stride * i + 2] *= z;
        }
    }
}

piMesh.prototype.translate = function (x, y, z) 
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] += x;
            this.mChunks[j].mVerts[stride * i + 1] += y;
            this.mChunks[j].mVerts[stride * i + 2] += z;
        }
    }
}

piMesh.prototype.GPULoad = function (renderer)
{
    for( var i=0; i<this.mChunks.length; i++ )
    {
        var vbo = renderer.CreateVertexArray(this.mChunks[i].mVerts, renderer.BUFTYPE.STATIC );
        if (vbo == null)
            return false;

        var ibo = renderer.CreateIndexArray(this.mChunks[i].mIndices, renderer.BUFTYPE.STATIC);
        if (ibo == null)
            return false;

        this.mChunks[i].mVBO = vbo;
        this.mChunks[i].mIBO = ibo;
    }
    return true;
}

piMesh.prototype.GPURender = function (renderer, positions )//, matPrj, matCam )
{
    //renderer.SetShaderConstantMat4F("unMPrj", matPrj, false );

    var num = this.mChunks.length;
    for( var i=0; i<num; i++ )
    {
        //var mat =  matMul( matCam, this.mChunks[i].mTransform );
        //renderer.SetShaderConstantMat4F("unMMod", mat, false);

        renderer.AttachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat, positions );
        renderer.AttachIndexArray(this.mChunks[i].mIBO );
        renderer.DrawPrimitive(renderer.PRIMTYPE.TRIANGLES, this.mChunks[i].mNumFaces * 3, true, 1);
        renderer.DetachIndexArray(this.mChunks[i].mIBO);
        renderer.DetachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat );
    }
}
//==============================================================================
//
// piLibs 2014-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piRenderer
//
//==============================================================================

function piRenderer()
{
    // private members

    var mGL = null;
    var mBindedShader = null;
    var mIs20 = false;
    var mFloat32Textures;
    var mFloat32Filter;
    var mFloat16Textures;
    var mDrawBuffers;
    var mDepthTextures;
    var mDerivatives;
    var mFloat16Filter;
    var mShaderTextureLOD;
    var mAnisotropic;
    var mRenderToFloat32F;
    var mDebugShader;
    var mAsynchCompile;

    var mVBO_Quad = null;
    var mVBO_Tri = null;
    var mVBO_CubePosNor = null;
    var mVBO_CubePos = null;
    var mShaderHeader = ["",""];
    var mShaderHeaderLines = [0,0];

    // public members
    var me = {};

    me.CLEAR      = { Color: 1, Zbuffer : 2, Stencil : 4 };
    me.TEXFMT     = { C4I8 : 0, C1I8 : 1, C1F16 : 2, C4F16 : 3, C1F32 : 4, C4F32 : 5, Z16 : 6, Z24 : 7, Z32 : 8, C3F32:9 };
    me.TEXWRP     = { CLAMP : 0, REPEAT : 1 };
    me.BUFTYPE    = { STATIC : 0, DYNAMIC : 1 };
    me.PRIMTYPE   = { POINTS : 0, LINES : 1, LINE_LOOP : 2, LINE_STRIP : 3, TRIANGLES : 4, TRIANGLE_STRIP : 5 };
    me.RENDSTGATE = { WIREFRAME : 0, FRONT_FACE : 1, CULL_FACE : 2, DEPTH_TEST : 3, ALPHA_TO_COVERAGE : 4 };
    me.TEXTYPE    = { T2D : 0, T3D : 1, CUBEMAP : 2 };
    me.FILTER     = { NONE : 0, LINEAR : 1, MIPMAP : 2, NONE_MIPMAP : 3 };
    me.TYPE       = { UINT8 : 0, UINT16 : 1, UINT32 : 2, FLOAT16: 3, FLOAT32 : 4, FLOAT64: 5 };

    // private functions

    var iFormatPI2GL = function( format )
    {
        if( mIs20 )
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA8,           mGLExternal: mGL.RGBA,             mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.R8,              mGLExternal: mGL.RED,              mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.R16F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA16F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.R32F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA32F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C3F32) return { mGLFormat: mGL.RGB32F,          mGLExternal: mGL.RGB,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT16, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z24)   return { mGLFormat: mGL.DEPTH_COMPONENT24, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z32)   return { mGLFormat: mGL.DEPTH_COMPONENT32F, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        }
        else
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.RED,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT, mGLExternal: mGL.DEPTH_COMPONENT, mGLType: mGL.UNSIGNED_SHORT }
        }

        return null;
     }

    // public functions

    me.Initialize = function( gl )
                    {
                        mGL = gl;

                        mIs20 = !(gl instanceof WebGLRenderingContext);

                        if( mIs20 )
                        {
                            mFloat32Textures  = true;
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = true;
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = true;
                            mDrawBuffers      = true;
                            mDepthTextures    = true;
                            mShaderTextureLOD = true;
                            mAnisotropic = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mGL.getExtension( 'EXT_color_buffer_float');
                            mDebugShader = mGL.getExtension('WEBGL_debug_shaders');
                            mAsynchCompile = mGL.getExtension('KHR_parallel_shader_compile');

							mGL.hint( mGL.FRAGMENT_SHADER_DERIVATIVE_HINT, mGL.NICEST);
                        }
                        else
                        {
                            mFloat32Textures  = mGL.getExtension( 'OES_texture_float' );
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = mGL.getExtension( 'OES_texture_half_float' );
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = mGL.getExtension( 'OES_standard_derivatives' );
                            mDrawBuffers      = mGL.getExtension( 'WEBGL_draw_buffers' );
                            mDepthTextures    = mGL.getExtension( 'WEBGL_depth_texture' );
                            mShaderTextureLOD = mGL.getExtension( 'EXT_shader_texture_lod' );
                            mAnisotropic      = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mFloat32Textures;
                            mDebugShader      = null;
                            mAsynchCompile    = null;
							
							if( mDerivatives !== null) mGL.hint( mDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, mGL.NICEST);
                        }
                        
                        
                        var maxTexSize = mGL.getParameter( mGL.MAX_TEXTURE_SIZE );
                        var maxCubeSize = mGL.getParameter( mGL.MAX_CUBE_MAP_TEXTURE_SIZE );
                        var maxRenderbufferSize = mGL.getParameter( mGL.MAX_RENDERBUFFER_SIZE );
                        var extensions = mGL.getSupportedExtensions();
                        var textureUnits = mGL.getParameter( mGL.MAX_TEXTURE_IMAGE_UNITS );
                        console.log("WebGL (2.0=" + mIs20 + "):" +
                                    " Asynch Compile: "  + ((mAsynchCompile !==null) ? "yes" : "no") +
                                    ", Textures: F32 ["   + ((mFloat32Textures !==null) ? "yes" : "no") +
                                    "], F16 ["   + ((mFloat16Textures !==null) ? "yes" : "no") +
                                    "], Depth [" + ((mDepthTextures   !==null) ? "yes" : "no") +
                                    "], LOD ["    + ((mShaderTextureLOD!==null) ? "yes" : "no") +
                                    "], Aniso ["   + ((mAnisotropic     !==null) ? "yes" : "no") +
                                    "], Units [" + textureUnits +
                                    "], Max Size [" + maxTexSize +
                                    "], Cube Max Size [" + maxCubeSize +
                                    "], Targets: MRT ["            + ((mDrawBuffers     !==null) ? "yes" : "no") +
                                    "], F32 ["     + ((mRenderToFloat32F!==null) ? "yes" : "no") +
                                    "], Max Size [" + maxRenderbufferSize + "]");

                        // create a 2D quad Vertex Buffer
                        var vertices = new Float32Array( [ -1.0, -1.0,   1.0, -1.0,    -1.0,  1.0,     1.0, -1.0,    1.0,  1.0,    -1.0,  1.0] );
                        mVBO_Quad = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                        mGL.bufferData( mGL.ARRAY_BUFFER, vertices, mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 2D triangle Vertex Buffer
                        mVBO_Tri = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0,   3.0, -1.0,    -1.0,  3.0] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePosNor = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0, -1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                               1.0,  1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                               1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                               1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                               1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0,  1.0, -1.0,   0.0,  0.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePos = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0,  1.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        //-------------------------------------------------------------------

                        mShaderHeader[0] = "";
                        mShaderHeaderLines[0] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[0] += "#version 300 es\n" +
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[0] += 6;
                        }
                        else
                        {
                            mShaderHeader[0] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "#endif\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+                                                
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[0] += 26;
                        }

                        //-------------------------------------------------------

                        mShaderHeader[1] = "";
                        mShaderHeaderLines[1] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[1] += "#version 300 es\n"+
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[1] += 6;
                        }
                        else
                        {
                            if( mDerivatives ) { mShaderHeader[1] += "#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n"; mShaderHeaderLines[1]+=3; }
                            if( mShaderTextureLOD  ) { mShaderHeader[1] += "#extension GL_EXT_shader_texture_lod : enable\n"; mShaderHeaderLines[1]++; }
                            mShaderHeader[1] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "#endif\n"+ 
                                                "vec4 texture(     sampler2D   s, vec2 c)                   { return texture2D(s,c); }\n"+
                                                "vec4 texture(     sampler2D   s, vec2 c, float b)          { return texture2D(s,c,b); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c )                  { return textureCube(s,c); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c, float b)          { return textureCube(s,c,b); }\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[1] += 30;
                            if( mShaderTextureLOD )
                            {
                            mShaderHeader[1] += "vec4 textureLod(  sampler2D   s, vec2 c, float b)          { return texture2DLodEXT(s,c,b); }\n";
                            mShaderHeader[1] += "vec4 textureGrad( sampler2D   s, vec2 c, vec2 dx, vec2 dy) { return texture2DGradEXT(s,c,dx,dy); }\n";
                            mShaderHeaderLines[1] += 2;

                            //mShaderHeader[1] += "vec4 texelFetch( sampler2D s, ivec2 c, int l) { return texture2DLodEXT(s,(vec2(c)+0.5)/vec2(800,450),float(l)); }\n";
                            //mShaderHeaderLines[1] += 1;
                            }
                        }

                        return true;
                    };

        me.GetCaps =    function ()
                        {   
                            return { mIsGL20 : mIs20,
                                     mFloat32Textures: mFloat32Textures != null,
                                     mFloat16Textures: mFloat16Textures != null,
                                     mDrawBuffers: mDrawBuffers != null,
                                     mDepthTextures: mDepthTextures != null,
                                     mDerivatives: mDerivatives != null,
                                     mShaderTextureLOD: mShaderTextureLOD != null };
                        };

        me.GetShaderHeaderLines = function (shaderType)
                        {   
                            return mShaderHeaderLines[shaderType];
                        };

        me.CheckErrors = function()
                         {
                                var error = mGL.getError();
                                if( error != mGL.NO_ERROR ) 
                                { 
                                    for( var prop in mGL ) 
                                    {
                                        if( typeof mGL[prop] == 'number' ) 
                                        {
                                            if( mGL[prop] == error )
                                            {
                                                console.log( "GL Error " + error + ": " + prop );
                                                break;
                                            }
                                        }
                                    }
                                }
                         };

        me.Clear =  function( flags, ccolor, cdepth, cstencil )
                    {
                        var mode = 0;
                        if( flags & 1 ) { mode |= mGL.COLOR_BUFFER_BIT;   mGL.clearColor( ccolor[0], ccolor[1], ccolor[2], ccolor[3] ); }
                        if( flags & 2 ) { mode |= mGL.DEPTH_BUFFER_BIT;   mGL.clearDepth( cdepth ); }
                        if( flags & 4 ) { mode |= mGL.STENCIL_BUFFER_BIT; mGL.clearStencil( cstencil ); }
                        mGL.clear( mode );
                    };


        me.CreateTexture = function ( type, xres, yres, format, filter, wrap, buffer)
                           {
                                if( mGL===null ) return null;

                                var id = mGL.createTexture();

                                var glFoTy = iFormatPI2GL( format );
                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                if( type===me.TEXTYPE.T2D )
                                {
                                    mGL.bindTexture( mGL.TEXTURE_2D, id );
//if( buffer==null )
    //mGL.texStorage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres);
//else
                                    mGL.texImage2D( mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap );

                                    if (filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                }
                                else if( type===me.TEXTYPE.T3D )
                                {
                                    if( mIs20 )
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_3D, id );
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_BASE_LEVEL, 0);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAX_LEVEL, Math.log2(xres));
                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_3D);
                                        }
                                        mGL.texImage3D( mGL.TEXTURE_3D, 0, glFoTy.mGLFormat, xres, yres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap );

                                        if (filter === me.FILTER.MIPMAP)
                                            mGL.generateMipmap( mGL.TEXTURE_3D );
                                        mGL.bindTexture( mGL.TEXTURE_3D, null );
                                    }
                                    else 
                                    {
                                        return null;
                                    }
                                }
                                else 
                                {
                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );

                                    // this works great if we know the number of required mipmaps in advance (1, or other)
                                   //mGL.texStorage2D( mGL.TEXTURE_CUBE_MAP, 1, glFoTy.mGLFormat, xres, yres );

                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                    if( filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                    }

                                    if (filter === me.FILTER.MIPMAP)
                                        mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );

                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                }
                        return { mObjectID: id, mXres: xres, mYres: yres, mFormat: format, mType: type, mFilter: filter, mWrap: wrap, mVFlip:false };
                        };

        me.CreateTextureFromImage = function ( type, image, format, filter, wrap, flipY) 
                                {
                                    if( mGL===null ) return null;

                                    var id = mGL.createTexture();

                                    var glFoTy = iFormatPI2GL( format );

                                    var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                    if( type===me.TEXTYPE.T2D )
                                    {
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);

                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.pixelStorei(mGL.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                                        if( mIs20 ) mGL.pixelStorei(mGL.UNPACK_COLORSPACE_CONVERSION_WEBGL, mGL.NONE );

                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);

                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);

                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if( filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                    }
                                    else if( type===me.TEXTYPE.T3D )
                                    {
                                        return null;
                                    }
                                    else 
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );

                                        if( filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                    }
                                    return { mObjectID: id, mXres: image.width, mYres: image.height, mFormat: format, mType: type, mFilter: filter, mWrap:wrap, mVFlip:flipY };
                                };

        me.SetSamplerFilter = function (te, filter, doGenerateMipsIfNeeded) 
                            {
                                if (te.mFilter === filter) return;

                                if (te.mType === me.TEXTYPE.T2D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_3D, null);

                                }
                                else
                                {
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }


                                te.mFilter = filter;
                            };

        me.SetSamplerWrap = function (te, wrap)
                            {
                                if (te.mWrap === wrap) return;

                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, id);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, id);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_3D, null);
                                }

                                te.mWrap = wrap;
                            };

        me.SetSamplerVFlip = function (te, vflip, image)
                            {
                                if (te.mVFlip === vflip) return;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    if( image != null)
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                }
                                else if (te.mType === me.TEXTYPE.CUBEMAP)
                                {
                                    if( image != null)
                                    {
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei( mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
        
                                }

                                te.mVFlip = vflip;
                            };

        me.CreateMipmaps =  function (te)
                            {
                                if( te.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);
                                    mGL.generateMipmap(mGL.TEXTURE_2D);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);
                                }
                                else if( te.mType===me.TEXTYPE.CUBEMAP )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);
                                    mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }
                            };

        me.UpdateTexture =  function( tex, x0, y0, xres, yres, buffer )
                            {
                                var glFoTy = iFormatPI2GL( tex.mFormat );
                                if( tex.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture( mGL.TEXTURE0);
                                    mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                    mGL.texSubImage2D( mGL.TEXTURE_2D, 0, x0, y0, xres, yres, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                }
                            };

        me.UpdateTextureFromImage = function( tex, image )
                                {
                                    var glFoTy = iFormatPI2GL( tex.mFormat );
                                    if( tex.mType===me.TEXTYPE.T2D )
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                        mGL.texImage2D(  mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image );
                                        mGL.bindTexture( mGL.TEXTURE_2D, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                };

        me.DestroyTexture = function( te )
                            {
                                 mGL.deleteTexture( te.mObjectID );
                            };

        me.AttachTextures = function (num, t0, t1, t2, t3) 
                            {
                                if (num > 0 && t0 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                         if (t0.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t0.mObjectID);
                                }

                                if (num > 1 && t1 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE1);
                                         if (t1.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t1.mObjectID);
                                }

                                if (num > 2 && t2 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE2);
                                         if (t2.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t2.mObjectID);
                                }

                                if (num > 3 && t3 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE3);
                                         if (t3.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t3.mObjectID);
                                }
                            };

        me.DettachTextures = function()
                             {
                                mGL.activeTexture(mGL.TEXTURE0);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE1);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE2);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE3);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                             };

        me.CreateRenderTarget = function ( color0, color1, color2, color3, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);

                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_2D, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.DestroyRenderTarget = function ( tex )
                                 {
                                     mGL.deleteFramebuffer(tex.mObjectID);
                                 };

        me.SetRenderTarget = function (tex)
                             {
                                if( tex===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, tex.mObjectID);

                                //mGL.drawBuffers([mGL.COLOR_ATTACHMENT0, mGL.COLOR_ATTACHMENT1]);
                             };

        me.CreateRenderTargetNew = function ( wantColor0, wantZbuffer, xres, yres, samples )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if( wantZbuffer===true )
                                    {
                                        var zb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);

                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.DEPTH_COMPONENT16, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                    }

                                    if( wantColor0 )
                                    {
                                        var cb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, cb);
                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.RGBA8, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.RGBA8, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.RENDERBUFFER, cb);
                                    }

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                    {
                                        return null;
                                    }
                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mXres: xres, mYres:yres, mTex0: color0 };
                                };

        me.CreateRenderTargetCubeMap = function ( color0, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);
                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.SetRenderTargetCubeMap = function (fbo, face)
                             {
                                if( fbo===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                {
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, fbo.mObjectID);
                                    mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X+face, fbo.mTex0.mObjectID, 0);
                                }
                             };


        me.BlitRenderTarget = function( dst, src )
                                {
                                    mGL.bindFramebuffer(mGL.READ_FRAMEBUFFER, src.mObjectID);
                                    mGL.bindFramebuffer(mGL.DRAW_FRAMEBUFFER, dst.mObjectID);
                                    mGL.clearBufferfv(mGL.COLOR, 0, [0.0, 0.0, 0.0, 1.0]);
                                    mGL.blitFramebuffer( 0, 0, src.mXres, src.mYres,
                                                         0, 0, src.mXres, src.mYres,
                                                         mGL.COLOR_BUFFER_BIT, mGL.LINEAR
                                    );
                                };

        me.SetViewport = function( vp )
                         {
                              mGL.viewport( vp[0], vp[1], vp[2], vp[3] );
                         };

        me.SetWriteMask = function( c0, c1, c2, c3, z )
                          {
                              mGL.depthMask(z);
                              mGL.colorMask(c0,c0,c0,c0);
                          };

        me.SetState = function( stateName, stateValue )
                      {
                            if (stateName === me.RENDSTGATE.WIREFRAME)
                            {
                                if( stateValue ) mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.LINE );
                                else             mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.FILL );
                            }
                            else if (stateName === me.RENDSTGATE.FRONT_FACE)
                            {
                                if( stateValue ) mGL.cullFace( mGL.BACK );
                                else             mGL.cullFace( mGL.FRONT );
                            }
                            else if (stateName === me.RENDSTGATE.CULL_FACE)
                            {
                                if( stateValue ) mGL.enable( mGL.CULL_FACE );
                                else             mGL.disable( mGL.CULL_FACE );
                            }
                            else if (stateName === me.RENDSTGATE.DEPTH_TEST)
                            {
                                if( stateValue ) mGL.enable( mGL.DEPTH_TEST );
                                else             mGL.disable( mGL.DEPTH_TEST );
                            }
                            else if (stateName === me.RENDSTGATE.ALPHA_TO_COVERAGE)
                            {
                                if( stateValue ) { mGL.enable(  mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                                else             { mGL.disable( mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                            }
                      };

        me.SetMultisample = function( v)
                    {
                        if( v===true )
                        {
                            mGL.enable(mGL.SAMPLE_COVERAGE);
                            mGL.sampleCoverage(1.0, false);
                        }
                        else
                        {
                            mGL.disable(mGL.SAMPLE_COVERAGE);
                        }
                    };

        me.GetTranslatedShaderSource = function (shader) 
                          {
                            if( mGL===null ) return null;
                            if( mDebugShader===null ) return null;
                            let vfs = mGL.getAttachedShaders(shader.mProgram);
                            let str = mDebugShader.getTranslatedShaderSource(vfs[1]);
                            let parts = str.split("GLSL END"); str = (parts.length<2) ? str : parts[1];
                            return str;
                          };

        me.CreateShader = function (vsSource, fsSource, preventCache, forceSynch, onResolve) 
                          {
                            if( mGL===null ) return;

                            var vs = mGL.createShader( mGL.VERTEX_SHADER   );
                            var fs = mGL.createShader( mGL.FRAGMENT_SHADER );

                            vsSource = mShaderHeader[0] + vsSource;
                            fsSource = mShaderHeader[1] + fsSource;

                            if( preventCache )
                            {
                                let vran = Math.random().toString(36).substring(7);
                                let fran = Math.random().toString(36).substring(7);
                                vsSource += "\n#define K" + vran + "\n";
                                fsSource += "\n#define K" + fran + "\n";
                            }

                            var timeStart = getRealTime();

                            mGL.shaderSource(vs, vsSource);
                            mGL.shaderSource(fs, fsSource);
                            mGL.compileShader(vs);
                            mGL.compileShader(fs);

                            var pr = mGL.createProgram();
                            mGL.attachShader(pr, vs);
                            mGL.attachShader(pr, fs);
                            mGL.linkProgram(pr);

                            //-------------
                            let checkErrors = function()
                            {
                                if (!mGL.getProgramParameter(pr, mGL.LINK_STATUS))
                                {
                                    // vs error
                                    if (!mGL.getShaderParameter(vs, mGL.COMPILE_STATUS))
                                    {
                                        let vsLog = mGL.getShaderInfoLog(vs);
                                        onResolve(false, { mErrorType: 0, mErrorStr: vsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // fs error
                                    else if (!mGL.getShaderParameter(fs, mGL.COMPILE_STATUS))
                                    {
                                        let fsLog = mGL.getShaderInfoLog(fs);
                                        onResolve(false, { mErrorType: 1, mErrorStr: fsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // link error
                                    else
                                    {
                                        let infoLog = mGL.getProgramInfoLog(pr);
                                        onResolve(false, { mErrorType: 2, mErrorStr: infoLog });
                                        mGL.deleteProgram(pr);
                                    }
                                }
                                // no errors
                                else
                                {
                                    let compilationTime = getRealTime() - timeStart;
                                    onResolve(true, { mProgram: pr, mTime: compilationTime });
                                }
                            };

                            // check compilation
                            if (mAsynchCompile === null || forceSynch===true )
                            {
                                checkErrors();
                            }
                            else
                            {
                                let loopCheckCompletion = function ()
                                {
                                    if( mGL.getProgramParameter(pr, mAsynchCompile.COMPLETION_STATUS_KHR) === true )
                                        checkErrors();
                                    else
                                        setTimeout(loopCheckCompletion, 10);
                                };
                                setTimeout(loopCheckCompletion, 10);
                            }
                        };

        me.AttachShader = function( shader )
                          {
                                if( shader===null )
                                {
                                    mBindedShader = null;
                                    mGL.useProgram( null );
                                }
                                else
                                {
                                    mBindedShader = shader;
                                    mGL.useProgram(shader.mProgram);
                                }
                          };

        me.DetachShader = function ()
                        {
                            mGL.useProgram(null);
                        };

        me.DestroyShader = function( tex )
                        {
                            mGL.deleteProgram(tex.mProgram);
                        };

        me.GetAttribLocation = function (shader, name)
                        {
                            return mGL.getAttribLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantLocation = function (shader, name)
                        {
                            return mGL.getUniformLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantMat4F = function( uname, params, istranspose )
                        {
                            var program = mBindedShader;

                            let pos = mGL.getUniformLocation( program.mProgram, uname );
                            if( pos===null )
                                return false;

                            if( istranspose===false )
                            {
                                var tmp = new Float32Array( [ params[0], params[4], params[ 8], params[12],
                                                              params[1], params[5], params[ 9], params[13],
                                                              params[2], params[6], params[10], params[14],
                                                              params[3], params[7], params[11], params[15] ] );
	                            mGL.uniformMatrix4fv(pos,false,tmp);
                            }
                            else
                                mGL.uniformMatrix4fv(pos,false,new Float32Array(params) );
                            return true;
                        };

        me.SetShaderConstant1F_Pos = function(pos, x)
                        {
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1FV_Pos = function(pos, x)
                        {
                            mGL.uniform1fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant1F = function( uname, x )
                        {
                            var pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1I = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1i(pos, x);
                            return true;
                        };
        me.SetShaderConstant1I_Pos = function(pos, x)
                        {
                            mGL.uniform1i(pos, x);
                            return true;
                        };


        me.SetShaderConstant2F = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform2fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant3F = function(uname, x, y, z)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform3f(pos, x, y, z);
                            return true;
                        };

        me.SetShaderConstant1FV = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1fv(pos, new Float32Array(x));
                            return true;
                        };

        me.SetShaderConstant3FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform3fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderConstant4FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform4fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderTextureUnit = function( uname, unit )
                        {
                            var program = mBindedShader;
                            let pos = mGL.getUniformLocation(program.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform1i(pos, unit);
                            return true;
                        };

        me.CreateVertexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, id);
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.CreateIndexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, id );
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.DestroyArray = function( tex )
                        {
                            mGL.destroyBuffer(tex.mObject);
                        };

        me.AttachVertexArray = function( tex, attribs, pos )
                        {
                            let shader = mBindedShader;

                            mGL.bindBuffer( mGL.ARRAY_BUFFER, tex.mObject);

                            var num = attribs.mChannels.length;
                            var stride = attribs.mStride;

                            var offset = 0;
                            for (var i = 0; i < num; i++)
                            {
                                var id = pos[i];
                                mGL.enableVertexAttribArray(id);
                                var dtype = mGL.FLOAT;
                                var dsize = 4;
                                     if( attribs.mChannels[i].mType === me.TYPE.UINT8   ) { dtype = mGL.UNSIGNED_BYTE;  dsize = 1; }
                                else if( attribs.mChannels[i].mType === me.TYPE.UINT16  ) { dtype = mGL.UNSIGNED_SHORT; dsize = 2; }
                                else if( attribs.mChannels[i].mType === me.TYPE.FLOAT32 ) { dtype = mGL.FLOAT;          dsize = 4; }
                                mGL.vertexAttribPointer(id, attribs.mChannels[i].mNumComponents, dtype, attribs.mChannels[i].mNormalize, stride, offset);
                                offset += attribs.mChannels[i].mNumComponents * dsize;
                            }
                        };

        me.AttachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, tex.mObject);
                        };

        me.DetachVertexArray = function (tex, attribs)
                        {
                            let num = attribs.mChannels.length;
                            for (let i = 0; i < num; i++)
                                mGL.disableVertexAttribArray(i);
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, null);
                        };

        me.DetachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, null);
                        };

        me.DrawPrimitive = function( typeOfPrimitive, num, useIndexArray, numInstances )
                        {
                            let glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.POINTS ) glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.LINES ) glType = mGL.LINES;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_LOOP ) glType = mGL.LINE_LOOP;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_STRIP ) glType = mGL.LINE_STRIP;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLES ) glType = mGL.TRIANGLES;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLE_STRIP ) glType = mGL.TRIANGLE_STRIP;

                            if( numInstances<=1 )
                            {
  	                            if( useIndexArray ) mGL.drawElements( glType, num, mGL.UNSIGNED_SHORT, 0 );
	                            else                mGL.drawArrays( glType, 0, num );
                            }
                            else
                            {
                                mGL.drawArraysInstanced(glType, 0, num, numInstances);
                                mGL.drawElementsInstanced( glType, num, mGL.UNSIGNED_SHORT, 0, numInstances);
                            }
                        };


        me.DrawFullScreenTriangle_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 3 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };


        me.DrawUnitQuad_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 6 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };

        me.DrawUnitCube_XYZ_NOR = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                            mGL.vertexAttribPointer( vpos[0], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.vertexAttribPointer( vpos[1], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos[0] );
                            mGL.enableVertexAttribArray( vpos[1] );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos[0] );
                            mGL.disableVertexAttribArray( vpos[1] );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.DrawUnitCube_XYZ = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                            mGL.vertexAttribPointer( vpos, 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.SetBlend = function( enabled )
                    {
                        if( enabled )
                        {
                            mGL.enable( mGL.BLEND );
                            mGL.blendEquationSeparate( mGL.FUNC_ADD, mGL.FUNC_ADD );
                            mGL.blendFuncSeparate( mGL.SRC_ALPHA, mGL.ONE_MINUS_SRC_ALPHA, mGL.ONE, mGL.ONE_MINUS_SRC_ALPHA );
                        }
                        else
                        {
                            mGL.disable( mGL.BLEND );
                        }
                    };

        me.GetPixelData = function( data, offset, xres, yres )
                        {
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.UNSIGNED_BYTE, data, offset);
                        };

        me.GetPixelDataRenderTarget = function( obj, data, xres, yres )
                        {
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, obj.mObjectID);
                            mGL.readBuffer(mGL.COLOR_ATTACHMENT0);
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.FLOAT, data, 0);
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                        };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piShading
//
//==============================================================================

function smoothstep(a, b, x)
{
    x = (x - a) / (b - a);
    if (x < 0) x = 0; else if (x > 1) x = 1;
    return x * x * (3.0 - 2.0 * x);
}

function clamp01(x)
{
    if( x < 0.0 ) x = 0.0;
    if( x > 1.0 ) x = 1.0;
    return x;
}

function clamp(x, a, b)
{
    if( x < a ) x = a;
    if( x > b ) x = b;
    return x;
}

function screen(a, b)
{
    return 1.0 - (1.0 - a) * (1.0 - b);
}

function parabola(x)
{
    return 4.0 * x * (1.0 - x);
}

function min(a, b)
{
    return (a < b) ? a : b;
}

function max(a, b)
{
    return (a > b) ? a : b;
}

function noise( x )
{
    function grad(i, j, x, y)
    {
        var h = 7 * i + 131 * j;
        h = (h << 13) ^ h;
        h = (h * (h * h * 15731 + 789221) + 1376312589);

        var rx = (h & 0x20000000) ? x : -x;
        var ry = (h & 0x10000000) ? y : -y;

        return rx + ry;
    }

    var i = [ Math.floor(x[0]), Math.floor(x[1]) ];
    var f = [ x[0] - i[0], x[1] - i[1] ];
    var w = [ f[0]*f[0]*(3.0-2.0*f[0]), f[1]*f[1]*(3.0-2.0*f[1]) ];

    var a = grad( i[0]+0, i[1]+0, f[0]+0.0, f[1]+0.0 );
    var b = grad( i[0]+1, i[1]+0, f[0]-1.0, f[1]+0.0 );
    var c = grad( i[0]+0, i[1]+1, f[0]+0.0, f[1]-1.0 );
    var d = grad( i[0]+1, i[1]+1, f[0]-1.0, f[1]-1.0 );

    return a + (b-a)*w[0] + (c-a)*w[1] + (a-b-c+d)*w[0]*w[1];
}//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piVecTypes
//
//==============================================================================


function vec3( a, b, c )
{
    return [ a, b, c ];
}

function add( a, b )
{
    return [ a[0]+b[0], a[1]+b[1], a[2]+b[2] ];
}

function sub( a, b )
{
    return [ a[0]-b[0], a[1]-b[1], a[2]-b[2] ];
}

function mul( a, s ) 
{
    return [ a[0]*s, a[1]*s, a[2]*s ];
}

function cross( a, b )
{
    return [ a[1]*b[2] - a[2]*b[1],
             a[2]*b[0] - a[0]*b[2],
             a[0]*b[1] - a[1]*b[0] ];
}

function dot( a, b ) 
{
    return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
}

function normalize( v ) 
{
    var is = 1.0 / Math.sqrt( v[0]*v[0] + v[1]*v[1] + v[2]*v[2] );
    return [ v[0]*is, v[1]*is, v[2]*is ];
}

function createCirclePoint( cen, uuu, vvv, rad, s, t )
{
    return [ cen[0] + rad*(uuu[0]*s + vvv[0]*t),
             cen[1] + rad*(uuu[1]*s + vvv[1]*t),
             cen[2] + rad*(uuu[2]*s + vvv[2]*t) ];
}

function createTangent( a, b, c )
{
    var cb = normalize( [ c[0]-b[0], c[1]-b[1], c[2]-b[2] ] );
    var ba = normalize( [ b[0]-a[0], b[1]-a[1], b[2]-a[2] ] );
    return normalize( [ ba[0]+cb[0], ba[1]+cb[1], ba[2]+cb[2] ] );

}

//===================================

function vec4( a, b, c, d )
{
    return [ a, b, c, d ];
}

function getXYZ( v )
{
    return [ v[0], v[1], v[2] ];
}

//===================================

function setIdentity()
{
    return [ 1.0, 0.0, 0.0, 0.0,
             0.0, 1.0, 0.0, 0.0,
             0.0, 0.0, 1.0, 0.0,
             0.0, 0.0, 0.0, 1.0 ];
}

function setRotationX( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ 1.0,   0.0,   0.0, 0.0,
             0.0,  cost, -sint, 0.0, 
             0.0,  sint,  cost, 0.0,
             0.0,   0.0,   0.0, 1.0 ];
}

function setRotationY( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ cost, 0.0, -sint, 0.0,
              0.0, 1.0,   0.0, 0.0, 
             sint, 0.0,  cost, 0.0,
              0.0, 0.0,   0.0, 1.0 ];
}

function extractRotationEuler( m)
{
    var res = [];
    if (m[0] == 1.0)
    {
        res[0] = Math.atan2(m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;

    }
    else if (m[0] == -1.0)
    {
        res[0] = Math.atan2( m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;
    }
    else
    {
        res[0] = Math.atan2( -m[9], m[10]);
        res[1] = Math.atan2( m[8], Math.sqrt(m[9]*m[9] + m[10]*m[10]));
        res[2] = Math.atan2( m[4], m[0]);
    }
    return res;
}

function setFromQuaternion( q )
{
    var ww = q[3]*q[3];
    var xx = q[0]*q[0];
    var yy = q[1]*q[1];
    var zz = q[2]*q[2];

    return [ ww+xx-yy-zz,                   2.0*(q[0]*q[1] - q[3]*q[2]), 2.0*(q[0]*q[2] + q[3]*q[1]), 0.0,
               2.0*(q[0]*q[1] + q[3]*q[2]),   ww-xx+yy-zz,                 2.0*(q[1]*q[2] - q[3]*q[0]), 0.0,
               2.0*(q[0]*q[2] - q[3]*q[1]),   2.0*(q[1]*q[2] + q[3]*q[0]), ww-xx-yy+zz,                 0.0,
               0.0,                           0.0,                         0.0,                         1.0 ];
}

function setPerspective( fovy, aspect, znear, zfar )
{
    var tan = Math.tan(fovy * Math.PI/180.0);
    var x = 1.0 / (tan*aspect);
    var y = 1.0 / (tan);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0 * zfar * znear) / (zfar - znear);

    return [ x,    0.0,  0.0,  0.0,
             0.0,  y,    0.0,  0.0,
             0.0,  0.0,  c,     d,
             0.0,  0.0, -1.0,  0.0 ];
}

function setLookAt( eye, tar, up )
{
    var dir = [ -tar[0]+eye[0], -tar[1]+eye[1], -tar[2]+eye[2] ];

	var m00 = dir[2]*up[1] - dir[1]*up[2]; 
    var m01 = dir[0]*up[2] - dir[2]*up[0];
    var m02 = dir[1]*up[0] - dir[0]*up[1];
    var im = 1.0/Math.sqrt( m00*m00 + m01*m01 + m02*m02 );
    m00 *= im;
    m01 *= im;
    m02 *= im;

	var m04 = m02*dir[1] - m01*dir[2]; 
    var m05 = m00*dir[2] - m02*dir[0];
    var m06 = m01*dir[0] - m00*dir[1];
    im = 1.0/Math.sqrt( m04*m04 + m05*m05 + m06*m06 );
    m04 *= im;
    m05 *= im;
    m06 *= im;

	var m08 = dir[0];
	var m09 = dir[1];
	var m10 = dir[2];
    im = 1.0/Math.sqrt( m08*m08 + m09*m09 + m10*m10 );
    m08 *= im;
    m09 *= im;
    m10 *= im;

	var m03 = -(m00*eye[0] + m01*eye[1] + m02*eye[2] );
	var m07 = -(m04*eye[0] + m05*eye[1] + m06*eye[2] );
	var m11 = -(m08*eye[0] + m09*eye[1] + m10*eye[2] );

    return [ m00, m01, m02, m03,
             m04, m05, m06, m07,
             m08, m09, m10, m11,
             0.0, 0.0, 0.0, 1.0 ];
}


function setOrtho( left, right, bottom, top, znear, zfar )
{
   var x = 2.0 / (right - left);
   var y = 2.0 / (top - bottom);
   var a = (right + left) / (right - left);
   var b = (top + bottom) / (top - bottom);
   var c = -2.0 / (zfar - znear);
   var d = -(zfar + znear) / ( zfar - znear);

   return [  x, 0.0, 0.0,   a,
           0.0,   y, 0.0,   b,
           0.0, 0.0,   c,   d,
           0.0, 0.0, 0.0, 1.0 ];
}

function setTranslation( p )
{
    return [ 1.0, 0.0, 0.0, p[0],
             0.0, 1.0, 0.0, p[1],
             0.0, 0.0, 1.0, p[2],
             0.0, 0.0, 0.0, 1.0 ];
}

function setScale( s )
{
    return [ s[0], 0.0,  0.0,  0.0,
             0.0,  s[1], 0.0,  0.0,
             0.0,  0.0,  s[2], 0.0,
             0.0,  0.0,  0.0,  1.0];
}

function setProjection( fov, znear, zfar )
{
    var x = 2.0 / (fov[3]+fov[2]);
    var y = 2.0 / (fov[0]+fov[1]);
    var a = (fov[3]-fov[2]) / (fov[3]+fov[2]);
    var b = (fov[0]-fov[1]) / (fov[0]+fov[1]);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0*zfar*znear) / (zfar - znear);
    return [   x, 0.0,    a, 0.0,
             0.0,   y,    b, 0.0,
             0.0, 0.0,    c,   d,
             0.0, 0.0, -1.0, 0.0 ];
   // inverse is:
   //return mat4x4( 1.0/x, 0.0f,  0.0f,   a/x,
   //               0.0f,  1.0/y, 0.0f,   b/x,
   //               0.0f,  0.0f,  0.0f,   -1.0,
   //               0.0f,  0.0f,  1.0f/d, c/d );
}


function invertFast( m )
{
    var inv = [
   
             m[5]  * m[10] * m[15] - 
             m[5]  * m[11] * m[14] - 
             m[9]  * m[6]  * m[15] + 
             m[9]  * m[7]  * m[14] +
             m[13] * m[6]  * m[11] - 
             m[13] * m[7]  * m[10],

             -m[1]  * m[10] * m[15] + 
              m[1]  * m[11] * m[14] + 
              m[9]  * m[2] * m[15] - 
              m[9]  * m[3] * m[14] - 
              m[13] * m[2] * m[11] + 
              m[13] * m[3] * m[10],

             m[1]  * m[6] * m[15] - 
             m[1]  * m[7] * m[14] - 
             m[5]  * m[2] * m[15] + 
             m[5]  * m[3] * m[14] + 
             m[13] * m[2] * m[7] - 
             m[13] * m[3] * m[6],

             -m[1] * m[6] * m[11] + 
              m[1] * m[7] * m[10] + 
              m[5] * m[2] * m[11] - 
              m[5] * m[3] * m[10] - 
              m[9] * m[2] * m[7] + 
              m[9] * m[3] * m[6],

             -m[4]  * m[10] * m[15] + 
              m[4]  * m[11] * m[14] + 
              m[8]  * m[6]  * m[15] - 
              m[8]  * m[7]  * m[14] - 
              m[12] * m[6]  * m[11] + 
              m[12] * m[7]  * m[10],

             m[0]  * m[10] * m[15] - 
             m[0]  * m[11] * m[14] - 
             m[8]  * m[2] * m[15] + 
             m[8]  * m[3] * m[14] + 
             m[12] * m[2] * m[11] - 
             m[12] * m[3] * m[10],

             -m[0]  * m[6] * m[15] + 
              m[0]  * m[7] * m[14] + 
              m[4]  * m[2] * m[15] - 
              m[4]  * m[3] * m[14] - 
              m[12] * m[2] * m[7] + 
              m[12] * m[3] * m[6],


             m[0] * m[6] * m[11] - 
             m[0] * m[7] * m[10] - 
             m[4] * m[2] * m[11] + 
             m[4] * m[3] * m[10] + 
             m[8] * m[2] * m[7] - 
             m[8] * m[3] * m[6],


             m[4]  * m[9] * m[15] - 
             m[4]  * m[11] * m[13] - 
             m[8]  * m[5] * m[15] + 
             m[8]  * m[7] * m[13] + 
             m[12] * m[5] * m[11] - 
             m[12] * m[7] * m[9],



             -m[0]  * m[9] * m[15] + 
              m[0]  * m[11] * m[13] + 
              m[8]  * m[1] * m[15] - 
              m[8]  * m[3] * m[13] - 
              m[12] * m[1] * m[11] + 
              m[12] * m[3] * m[9],

              m[0]  * m[5] * m[15] - 
              m[0]  * m[7] * m[13] - 
              m[4]  * m[1] * m[15] + 
              m[4]  * m[3] * m[13] + 
              m[12] * m[1] * m[7] - 
              m[12] * m[3] * m[5],

              -m[0] * m[5] * m[11] + 
               m[0] * m[7] * m[9] + 
               m[4] * m[1] * m[11] - 
               m[4] * m[3] * m[9] - 
               m[8] * m[1] * m[7] + 
               m[8] * m[3] * m[5],

              -m[4]  * m[9] * m[14] + 
               m[4]  * m[10] * m[13] +
               m[8]  * m[5] * m[14] - 
               m[8]  * m[6] * m[13] - 
               m[12] * m[5] * m[10] + 
               m[12] * m[6] * m[9],

              m[0]  * m[9] * m[14] - 
              m[0]  * m[10] * m[13] - 
              m[8]  * m[1] * m[14] + 
              m[8]  * m[2] * m[13] + 
              m[12] * m[1] * m[10] - 
              m[12] * m[2] * m[9],

              -m[0]  * m[5] * m[14] + 
               m[0]  * m[6] * m[13] + 
               m[4]  * m[1] * m[14] - 
               m[4]  * m[2] * m[13] - 
               m[12] * m[1] * m[6] + 
               m[12] * m[2] * m[5],

              m[0] * m[5] * m[10] - 
              m[0] * m[6] * m[9] - 
              m[4] * m[1] * m[10] + 
              m[4] * m[2] * m[9] + 
              m[8] * m[1] * m[6] - 
              m[8] * m[2] * m[5] ];

    var det = m[0] * inv[0] + m[1] * inv[4] + m[2] * inv[8] + m[3] * inv[12];

    det = 1.0/det;

    for( var i = 0; i<16; i++ ) inv[i] = inv[i] * det;

    return inv;
}

function matMul( a, b )
{
    var res = [];
    for( var i=0; i<4; i++ )
    {
        var x = a[4*i+0];
        var y = a[4*i+1];
        var z = a[4*i+2];
        var w = a[4*i+3];

        res[4*i+0] = x * b[ 0] + y * b[ 4] + z * b[ 8] + w * b[12];
        res[4*i+1] = x * b[ 1] + y * b[ 5] + z * b[ 9] + w * b[13];
        res[4*i+2] = x * b[ 2] + y * b[ 6] + z * b[10] + w * b[14];
        res[4*i+3] = x * b[ 3] + y * b[ 7] + z * b[11] + w * b[15];
    }

    return res;
}

function matMulpoint( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2] + m[ 3],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2] + m[ 7],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] + m[11] ];
}

function matMulvec( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] ];
}


function bound3( infi )
{
    return [ infi, -infi, infi, -infi, infi, -infi ];
}

function bound3_include( a, p )
{
    return [
        (p[0]<a[0]) ? p[0] : a[0],
        (p[0]>a[1]) ? p[0] : a[1],
        (p[1]<a[2]) ? p[1] : a[2],
        (p[1]>a[3]) ? p[1] : a[3],
        (p[2]<a[4]) ? p[2] : a[4],
        (p[2]>a[5]) ? p[2] : a[5] ];
}

function bound3_center( b )
{
    return [ 0.5*(b[0]+b[1]),
             0.5*(b[2]+b[3]),
             0.5*(b[4]+b[5]) ];
}

function bound3_radius( b )
{
    return [ 0.5*(b[1]-b[0]),
             0.5*(b[3]-b[2]),
             0.5*(b[5]-b[4]) ];
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebVR
//
//==============================================================================

function WebVR( isVREnabledCallback, canvasElement )
{
    isVREnabledCallback(false);
    /*


    this.mSupportVR = false;
    this.mHMD = null;

    var me = this;
    var listVRDisplays = function (vrdevs) {
        for (var i = 0; i < vrdevs.length; i++)
        {
            if (vrdevs[i] instanceof VRDisplay)
            {
                me.mHMD = vrdevs[i];
                console.log("WebVR is available.");
                console.log(me.mHMD);
                break;
            }
        }

        isVREnabledCallback(true);
        me.mSupportVR = true;
    }

    if (navigator.getVRDisplays)
    {
        navigator.getVRDisplays().then(listVRDisplays);
    }

    isVREnabledCallback(false);
    this.mCanvas = canvasElement;
    */
}

WebVR.prototype.IsSupported = function()
{
    return false;
    //return this.mSupportVR;
}

WebVR.prototype.GetData = function( id )
{
    return {};
    /*
    var frameData = new VRFrameData();
    var s = this.mHMD.getFrameData(frameData);
    var ss = frameData.pose;
    
    var fovL = this.mHMD.getEyeParameters("left");
    var fovR = this.mHMD.getEyeParameters( "right" );

    // camera info
    var cPos = vec3(0.0, 0.0, 0.0);
    if (ss.position)
        cPos = vec3(-ss.position[0], -ss.position[1], -ss.position[2]);
    var rot = vec4(0.0, 0.0, 0.0, 0.0);
    if (ss.orientation)
        rot = vec4(ss.orientation[0], ss.orientation[1], ss.orientation[2], ss.orientation[3]);
    var cRot = setFromQuaternion(rot);
    var cTra = setTranslation(cPos);
    var cMat = matMul(invertFast(cRot), cTra);
    
    // per eye info
    var lTra = setTranslation( vec3(-fovL.offset[0], -fovL.offset[1], -fovL.offset[2]) );
    var lMat = matMul(lTra, cMat);
    var lPrj = [ Math.tan( fovL.fieldOfView.upDegrees * Math.PI/180.0),
                 Math.tan(fovL.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.rightDegrees * Math.PI / 180.0)];

    var rTra = setTranslation(vec3(-fovR.offset[0], -fovR.offset[1], -fovR.offset[2]));
    var rMat = matMul(rTra, cMat);
    var rPrj = [Math.tan(fovR.fieldOfView.upDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.rightDegrees * Math.PI / 180.0)];

    return {
        mCamera   : { mCamera: cMat },
        mLeftEye  : { mVP:[0,0,fovL.renderWidth,fovL.renderHeight], mProjection:lPrj, mCamera:lMat },
        mRightEye : { mVP:[fovR.renderWidth/2,0,fovR.renderWidth,fovR.renderHeight], mProjection:rPrj, mCamera:rMat }
           };
    */
}

WebVR.prototype.Enable = function( id )
{
    /*
    this.mHMD.requestPresent([{ source: this.mCanvas }]).then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : requestPresent failed.");
        }
    );
    */
}

WebVR.prototype.Disable = function( id )
{
    /*
    if (!this.mHMD.isPresenting)
    {
        return;
    }

    this.mHMD.exitPresent().then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : exitPresent failed.");
        }
    );
    */
}

WebVR.prototype.RequestAnimationFrame = function (id)
{
    //this.mHMD.requestAnimationFrame(id);
}

WebVR.prototype.IsPresenting = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        return true;
    }
    */
    return false;
}

WebVR.prototype.Finish = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        this.mHMD.submitFrame();
    }
    */
}

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebUtils
//
//==============================================================================


// RequestAnimationFrame
window.requestAnimFrame = ( function () { return window.requestAnimationFrame    || window.webkitRequestAnimationFrame ||
                                                 window.mozRequestAnimationFrame || window.oRequestAnimationFrame ||
                                                 window.msRequestAnimationFrame  || function( cb ) { window.setTimeout(cb,1000/60); };
                                        } )();

// performance.now
window.getRealTime = ( function() { if ("performance" in window ) return function() { return window.performance.now(); }
                                                                  return function() { return (new Date()).getTime(); }
                                  } )();

window.URL = window.URL || window.webkitURL;

navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;

function htmlEntities(str) 
{
    return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g,'&apos;');
}

function piDisableTouch()
{
    document.body.addEventListener('touchstart', function(e){ e.preventDefault(); });
}

var piGetTime = function ( timestamp )
{
    if (timestamp == 0)
        return "";
    return new Date(timestamp * 1000).toISOString().substr(0, 10);
}

function piGetCoords( obj )
{
    var x = 0;
    var y = 0; 
    do
    {
         x += obj.offsetLeft;
         y += obj.offsetTop;
    }while( obj = obj.offsetParent );

    return { mX:x, mY:y };
}

function piGetMouseCoords( ev, canvasElement )
{
    var pos = piGetCoords(canvasElement );
    var mcx =                        (ev.pageX - pos.mX) * canvasElement.width / canvasElement.offsetWidth;
    var mcy = canvasElement.height - (ev.pageY - pos.mY) * canvasElement.height / canvasElement.offsetHeight;

    return { mX: mcx, mY: mcy };

}

function piGetSourceElement( e )
{
    var ele = null;
    if( e.target )     ele = e.target;
    if( e.srcElement ) ele = e.srcElement;
    return ele;
}

function piRequestFullScreen( ele )
{
    if( ele==null ) ele =   document.documentElement;
         if( ele.requestFullscreen       ) ele.requestFullscreen();
    else if( ele.msRequestFullscreen     ) ele.msRequestFullscreen();
    else if( ele.mozRequestFullScreen    ) ele.mozRequestFullScreen();
    else if( ele.webkitRequestFullscreen ) ele.webkitRequestFullscreen( Element.ALLOW_KEYBOARD_INPUT );
}

function piIsFullScreen()
{
    return document.fullscreen || document.mozFullScreen || document.webkitIsFullScreen || document.msFullscreenElement || false;
}

function piExitFullScreen()
{
       if( document.exitFullscreen       ) document.exitFullscreen();
  else if( document.msExitFullscreen     ) document.msExitFullscreen();
  else if( document.mozCancelFullScreen  ) document.mozCancelFullScreen();
  else if( document.webkitExitFullscreen ) document.webkitExitFullscreen();
}

function piIsMobile()
{
    return (navigator.userAgent.match(/Android/i) ||
            navigator.userAgent.match(/webOS/i) ||
            navigator.userAgent.match(/iPhone/i) ||
            navigator.userAgent.match(/iPad/i) ||
            navigator.userAgent.match(/iPod/i) ||
            navigator.userAgent.match(/BlackBerry/i) ||
            navigator.userAgent.match(/Windows Phone/i)) ? true : false;
}

function piCreateGlContext( cv, useAlpha, useDepth, usePreserveBuffer, useSupersampling )
{
    var opts = { alpha: useAlpha, 
                 depth: useDepth, 
                 stencil: false, 
                 premultipliedAlpha: false, 
                 antialias: useSupersampling, 
                 preserveDrawingBuffer: usePreserveBuffer, 
                 powerPreference: "high-performance" }; // "low_power", "high_performance", "default"

    var gl = null;
    if( gl === null) gl = cv.getContext( "webgl2", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl2", opts );
    if( gl === null) gl = cv.getContext( "webgl", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl", opts );

    return gl;
}

function piCreateAudioContext()
{
    var res = null;
    try
    {
        if( window.AudioContext ) res = new AudioContext();
        if( res==null && window.webkitAudioContext ) res = new webkitAudioContext();
    }
    catch( e )
    {
        res = null;
    }
    return res;
}

function piHexColorToRGB(str) // "#ff3041"
{
    var rgb = parseInt(str.slice(1), 16);
    var r = (rgb >> 16) & 255;
    var g = (rgb >> 8) & 255;
    var b = (rgb >> 0) & 255;
    return [r, g, b];
}

function piCreateFPSCounter()
{
    var mFrame;
    var mTo;
    var mFPS;

    var iReset = function( time )
    {
        mFrame = 0;
        mTo = time;
        mFPS = 60.0;
    }

    var iCount = function( time )
    {
        mFrame++;

        if( (time-mTo)>500.0 )
        {
            mFPS = 1000.0*mFrame/(time-mTo);
            mFrame = 0;
            mTo = time;
            return true;
        }
        return false;
    }

    var iGetFPS = function()
    {
        return mFPS;
    }
    
    return { Reset : iReset, Count : iCount, GetFPS : iGetFPS };
}

function piCanMediaRecorded(canvas)
{
    if (typeof window.MediaRecorder !== 'function' || typeof canvas.captureStream !== 'function') {
        return false;
    }
    return true;
}

function piCreateMediaRecorder(isRecordingCallback, canvas) 
{
    if (piCanMediaRecorded(canvas) == false)
    {
        return null;
    }
    
    var options = { audioBitsPerSecond : 0, videoBitsPerSecond : 8000000 }; 
	     if (MediaRecorder.isTypeSupported('video/webm;codecs=h264')) options.mimeType = 'video/webm;codecs=h264';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9' )) options.mimeType = 'video/webm;codecs=vp9';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8' )) options.mimeType = 'video/webm;codecs=vp8';
    else                                                              options.mimeType = 'video/webm;';

    var mediaRecorder = new MediaRecorder(canvas.captureStream(), options);
    var chunks = [];
    
    mediaRecorder.ondataavailable = function(e) 
    {
        if (e.data.size > 0) 
        {
            chunks.push(e.data);
        }
    };
 
    mediaRecorder.onstart = function(){ 
        isRecordingCallback( true );
    };
    
    mediaRecorder.onstop = function()
    {
         isRecordingCallback( false );
         let blob     = new Blob(chunks, {type: "video/webm"});
         chunks       = [];
         let videoURL = window.URL.createObjectURL(blob);
         let url      = window.URL.createObjectURL(blob);
         let a        = document.createElement("a");
         document.body.appendChild(a);
         a.style      = "display: none";
         a.href       = url;
         a.download   = "capture.webm";
         a.click();
         window.URL.revokeObjectURL(url);
     };
    
    return mediaRecorder;
}

function piExportToEXR(width, height, numComponents, type, bytes)
{
    var bytesPerComponent = 0;
    if      (type=="Uint")   bytesPerComponent = 4; 
    else if (type=="Half")   bytesPerComponent = 2;
    else if (type=="Float")  bytesPerComponent = 4;

    var tHeader = 258 + (18 * numComponents + 1);
    var tTable = 8 * height;
    var tScanlines = height * (4 + 4 + (numComponents * bytesPerComponent * width));
    var tTotal = tHeader + tTable + tScanlines;

    //console.log("    header size = " + tHeader);
    //console.log("    table size = " + tTable);
    //console.log("    scanlines size = " + tScanlines);
    //console.log("    total = " + tTotal);

    var buffer = new ArrayBuffer(tTotal); 
    var data = new DataView(buffer);

    // Header
    {
        // Header : 4 bytes -> 0x76, 0x2f, 0x31, 0x01
        var c = 0;
        data.setUint8 (c++, 0x76);
        data.setUint8 (c++, 0x2f);
        data.setUint8 (c++, 0x31);
        data.setUint8 (c++, 0x01);

        // Version : 4 bytes -> 2, 0, 0, 0
        data.setUint8 (c++, 0x02);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        
        // Write channel info
        // Write attribute name : "channels"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x73);
            data.setUint8 (c++, 0x0);

            // Write attribute type : "chlist"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : 18 x 3 + 1 = 55
            var attribSize = 18 * numComponents + 1;
            data.setUint8 (c++, attribSize); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            var i;
            for (i = 0; i < numComponents; i++)
            {
                // Attribute : "B" (42) "G" (47) "R" (52)
                if (i==0)       data.setUint8 (c++, 0x42);
                else if (i==1)  data.setUint8 (c++, 0x47);
                else if (i==2)  data.setUint8 (c++, 0x52);
                data.setUint8 (c++, 0x00);
                
                // Value : Float (2), Half (1), Uint (0)
                if      (type=="Uint")   data.setUint8 (c++, 0x00); 
                else if (type=="Half")   data.setUint8 (c++, 0x01);
                else if (type=="Float")  data.setUint8 (c++, 0x02);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);

                // Plinear
                data.setUint8 (c++, 0x01);

                // Reserved
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 

                // X sampling
                data.setUint8 (c++, 0x01); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                
                // Y sampling
                data.setUint8 (c++, 0x01);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
            }
            // End attribute
            data.setUint8 (c++, 0x00);
    
        // Write attribute name : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute type : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : "1"
            data.setUint8 (c++, 0x01); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // Write attribute value : "0" (None)
            data.setUint8 (c++, 0x00);

        // datawindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00); 

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00);

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 

            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // displayWindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x79); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00);

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00); 

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // size
            data.setUint8 (c++, 0x01);
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);
            
            // value 
            data.setUint8 (c++, 0x00);

        // PixelAspectRatio
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x41); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x52); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x00); 

            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);
        
            // size 4
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 1.0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);
        
        // screenWindowCenter
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63);
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x43); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e);
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00);

            // v2f
            data.setUint8 (c++, 0x76); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x00);

            // size 8
            data.setUint8 (c++, 0x08); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

        // screenWindowWidth
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x00); 
            
            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00); 

            // size
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);

            // value
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);

        // End of header
        data.setUint8 (c++, 0x00);
    }
    //console.log("header size = " + c);

    // Scanline table
    var initc = c + height * 8;
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        var jump = initc + scanline * (8 + width * bytesPerComponent * numComponents); 
        data.setUint32 (c, jump, true);
        c += 4; 

        data.setUint32 (c, 0x00, true);
        c += 4;
    }
    //console.log("header + scanlines table size = " + c);

    // Scanlines
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        // Scanline
        data.setUint32(c, scanline, true);
        c += 4;

        // size 24
        var size = width * numComponents * bytesPerComponent; 
        data.setUint32(c, size, true);
        c += 4;

        var numComponentsSource = 4; // number of components in the SOURCE image
        for (var component = 0; component < numComponents ; component ++) 
        {
            for (var pixel = 0 ; pixel < width ; pixel ++) 
            {
                // flip vertical, so we read OpenGL buffers without JS image flipping
                var v = bytes[(height-1-scanline) * width *numComponentsSource + pixel * numComponentsSource + (2-component)];
                if      (type=="Float") data.setFloat32(c, v, true);
                else if (type=="Half")  data.setUint16(c, v, true);

                c += bytesPerComponent;
            }
        }
    }
    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}


function piExportToWAV(numSamples, rate, bits, numChannels, words)
{
    let numBytes = numSamples * numChannels * bits/8;

    let buffer = new ArrayBuffer(44 + numBytes); 
    let data = new DataView(buffer);

    {
        data.setUint32( 0, 0x46464952, true );  // RIFF
        data.setUint32( 4, numBytes + 36, true);
        {
            data.setUint32( 8, 0x45564157, true );  // WAV_WAVE
            data.setUint32( 12, 0x20746D66, true );  // WAV_FMT
            {
                data.setUint32( 16, 16, true);
                data.setUint16( 20, 1, true ); // WAV_FORMAT_PCM
                data.setUint16( 22, numChannels, true);
                data.setUint32( 24, rate, true);
                data.setUint32( 28, rate*numChannels*bits / 8, true);
                data.setUint16( 32, numChannels*bits / 8, true);
                data.setUint16( 34, bits, true);
            }

            data.setUint32( 36, 0x61746164, true);  // WAV_DATA
            {
                data.setUint32( 40, numBytes, true);
                let numWords = numSamples * numChannels;
                for(let i=0; i<numWords; i++ )
                {
                    data.setInt16( 44 + i*2, words[i], true );
                }
            }
        }
    }


    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}

function piTriggerDownload(name, blob)
{
    let url = URL.createObjectURL(blob);
    let aElement = document.createElement("a");
    aElement.href     = url;
    aElement.target   = "_self";
    aElement.download = name;
    document.body.appendChild(aElement);
    aElement.click();
    document.body.removeChild(aElement);
}</script>
    <script>"use strict"

function bufferID_to_assetID( id )
{
    if( id===0 ) return '4dXGR8';
    if( id===1 ) return 'XsXGR8';
    if( id===2 ) return '4sXGR8';
    if( id===3 ) return 'XdfGR8';
    return 'none';
}
function assetID_to_bufferID( id )
{
    if( id==='4dXGR8' ) return 0;
    if( id==='XsXGR8' ) return 1;
    if( id==='4sXGR8' ) return 2;
    if( id==='XdfGR8' ) return 3;
    return -1;
}

function assetID_to_cubemapBuferID( id )
{
    if( id==='4dX3Rr' ) return 0;
    return -1;
}
function cubamepBufferID_to_assetID( id )
{
    if( id===0 ) return '4dX3Rr';
    return 'none';
}

function EffectPass( renderer, is20, isLowEnd, hasShaderTextureLOD, callback, obj, forceMuted, forcePaused, outputGainNode, copyProgram, id, effect  )
{
    this.mID = id;
    this.mInputs  = [null, null, null, null ];
    this.mOutputs = [null, null, null, null ];
    this.mSource = null;

    this.mGainNode = outputGainNode;
    this.mSoundShaderCompiled = false;

    this.mEffect = effect;
    this.mRenderer = renderer;
    this.mProgramCopy = copyProgram; 
    this.mCompilationTime = 0;

    this.mType = "none";
    this.mName = "none";
    this.mFrame = 0;

    this.mShaderTextureLOD = hasShaderTextureLOD;
    this.mIs20 = is20;
    this.mIsLowEnd = isLowEnd;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mForceMuted = forceMuted;
    this.mForcePaused = forcePaused;
}

EffectPass.prototype.MakeHeader_Image = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        // old API
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                   header += "uniform sampler2D iChannel" + i + ";\n";

        // new API (see shadertoy.com/view/wtdGW8)
        header += "uniform struct {\n";
             if( inp===null )                  header += "  sampler2D";
        else if( inp.mInfo.mType==="cubemap" ) header += "  samplerCube";
        else if( inp.mInfo.mType==="volume"  ) header += "  sampler3D";
        else                                  header += "  sampler2D";
        header +=        " sampler;\n";
        header += "  vec3  size;\n";
        header += "  float time;\n";
        header += "  int   loaded;\n";
        header += "}iCh" + i + ";\n";
    }
	header += "void mainImage( out vec4 c, in vec2 f );\n";
    header += "void st_assert( bool cond );\n";
    header += "void st_assert( bool cond, int v );\n";

    if( this.mIs20 ) 
    {
        header += "\nout vec4 shadertoy_out_color;\n" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)shadertoy_out_color.x=-1.0;else if(v==1)shadertoy_out_color.y=-1.0;else if(v==2)shadertoy_out_color.z=-1.0;else shadertoy_out_color.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)shadertoy_out_color.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "shadertoy_out_color = vec4(1.0,1.0,1.0,1.0);" + 
            "vec4 color = vec4(1e20);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "if(shadertoy_out_color.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(shadertoy_out_color.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(shadertoy_out_color.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(shadertoy_out_color.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "shadertoy_out_color = vec4(color.xyz,1.0);" +
        "}";
    }
    else
    {
        header += "" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)gl_FragColor.x=-1.0;else if(v==1)gl_FragColor.y=-1.0;else if(v==2)gl_FragColor.z=-1.0;else gl_FragColor.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)gl_FragColor.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "gl_FragColor = vec4(0.0,0.0,0.0,1.0);" + 
            "vec4 color = vec4(1e20);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "color.w = 1.0;" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(gl_FragColor.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "gl_FragColor = vec4(color.xyz,1.0);"+
        "}";
    }
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 ) 
        this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "void main( void )" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );" +
        "color.w = 1.0;"
    if( this.mIs20 ) 
        this.mImagePassFooterVR +=  "outColor = color;}";
    else
        this.mImagePassFooterVR +=  "gl_FragColor = color;}";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Buffer = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                  header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainImage( out vec4 c,  in vec2 f );\n"

    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +
        "mainImage( color, gl_FragCoord.xy );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
    this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        this.mImagePassFooterVR +="outColor = color; }";
    else
        this.mImagePassFooterVR +="gl_FragColor = color; }";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Cubemap = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                   header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainCubemap( out vec4 c, in vec2 f, in vec3 ro, in vec3 rd );\n"

    header += "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(1e20);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainCubemap( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Sound = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform float     iChannelTime[4];\n" +
              "uniform float     iTimeOffset;\n" +
              "uniform int       iSampleOffset;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n";

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp!==null && inp.mInfo.mType==="cubemap" )
            header += "uniform samplerCube iChannel" + i + ";\n";
        else
            header += "uniform sampler2D iChannel" + i + ";\n";
    }
    header += "\n";
    header += "vec2 mainSound( in int samp, float time );\n";

    if( this.mIs20 )
    {
        header += "out vec4 outColor; void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "int   s = iSampleOffset + int(gl_FragCoord.y-0.2)*512 + int(gl_FragCoord.x-0.2);" +
            "vec2 y = mainSound( s, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "outColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    else
    {
        header += "void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "vec2 y = mainSound( 0, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "gl_FragColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    header += "\n";
    this.mHeader = header;
    this.mHeaderLength = 0;
}


EffectPass.prototype.MakeHeader_Common = function ()
{
    let header = "";
    let headerlength = 0;

    header += "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n";
    headerlength += 2;

    if (this.mIs20)
    {
        header += "out vec4 outColor;\n";
        headerlength += 1;
    }
    header += "void main( void )\n";
    headerlength += 1;

    if (this.mIs20)
        header += "{ outColor = vec4(0.0); }";
    else
        header += "{ gl_FragColor = vec4(0.0); }";
    headerlength += 1;
    header += "\n";
    headerlength += 1;

    this.mHeader = header;
    this.mHeaderLength = headerlength;
}

EffectPass.prototype.MakeHeader = function()
{
         if( this.mType==="image" ) this.MakeHeader_Image();
    else if( this.mType==="sound" ) this.MakeHeader_Sound();
    else if( this.mType==="buffer") this.MakeHeader_Buffer();
    else if( this.mType==="common") this.MakeHeader_Common();
    else if( this.mType==="cubemap") this.MakeHeader_Cubemap();
    else console.log("ERROR 4");
}

EffectPass.prototype.Create_Image = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}
EffectPass.prototype.Destroy_Image = function( wa )
{
}

EffectPass.prototype.Create_Buffer = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}

EffectPass.prototype.Destroy_Buffer = function( wa )
{
}

EffectPass.prototype.Create_Cubemap = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
}

EffectPass.prototype.Destroy_Cubemap = function( wa )
{
}

EffectPass.prototype.Create_Common = function( wa )
{
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.MakeHeader();
}
EffectPass.prototype.Destroy_Common = function( wa )
{
}

EffectPass.prototype.Create_Sound = function (wa)
{
    this.MakeHeader();

    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    this.mSampleRate = 44100;
    this.mPlayTime = 60*3;
    this.mPlaySamples = this.mPlayTime*this.mSampleRate;
    this.mBuffer = wa.createBuffer( 2, this.mPlaySamples, this.mSampleRate );

    //-------------------
    this.mTextureDimensions = 512;
    this.mRenderTexture = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D, 
                                                       this.mTextureDimensions, this.mTextureDimensions,
                                                       this.mRenderer.TEXFMT.C4I8,
                                                       this.mRenderer.FILTER.NONE,
                                                       this.mRenderer.TEXWRP.CLAMP, null);
    this.mRenderFBO = this.mRenderer.CreateRenderTarget(this.mRenderTexture, null, null, null, null, false);

    //-----------------------------

    // ArrayBufferView pixels;
    this.mTmpBufferSamples = this.mTextureDimensions*this.mTextureDimensions;
    this.mData = new Uint8Array( this.mTmpBufferSamples*4 );

    this.mPlaying = false;
}

EffectPass.prototype.Destroy_Sound = function( wa )
{
    if( this.mPlayNode!==null ) this.mPlayNode.stop();
    this.mPlayNode = null;
    this.mBuffer = null;
    this.mData = null;

    this.mRenderer.DestroyRenderTarget(this.mRenderFBO);
    this.mRenderer.DestroyTexture(this.mRenderTexture);
}

EffectPass.prototype.Create = function( passType, wa )
{
    this.mType = passType;
    this.mSource = null;

         if( passType==="image" ) this.Create_Image( wa );
    else if( passType==="sound" ) this.Create_Sound( wa );
    else if( passType==="buffer") this.Create_Buffer( wa );
    else if( passType==="common") this.Create_Common( wa );
    else if( passType==="cubemap") this.Create_Cubemap( wa );
    else alert("ERROR 1");
}

EffectPass.prototype.SetName = function (passName)
{
    this.mName = passName;
}

EffectPass.prototype.SetCode = function (src)
{
    this.mSource = src;
}

EffectPass.prototype.Destroy = function( wa )
{
    this.mSource = null;
         if( this.mType==="image" ) this.Destroy_Image( wa );
    else if( this.mType==="sound" ) this.Destroy_Sound( wa );
    else if( this.mType==="buffer") this.Destroy_Buffer( wa );
    else if( this.mType==="common") this.Destroy_Common( wa );
    else if( this.mType==="cubemap") this.Destroy_Cubemap( wa );
    else alert("ERROR 2");
}

EffectPass.prototype.NewShader_Sound = function( shaderCode, commonShaderCodes)
{
    let vsSource = null;

    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for( let i=0; i<commonShaderCodes.length; i++ )
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    this.mSoundShaderCompiled = false;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader_Image = function ( shaderCode, commonShaderCodes )
{
    this.mSupportsVR = false;

    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    return [vsSource, fsSource];


    /*
    let n1 = shaderCode.indexOf("mainVR(");
    let n2 = shaderCode.indexOf("mainVR (");
    let n3 = shaderCode.indexOf("mainVR  (");
    if( n1>0 || n2>0 || n3>0 )
    {
        let vsSourceVR;
        if( this.mIs20 )
            vsSourceVR = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        else
            vsSourceVR = "attribute in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

        let fsSourceVR = this.mHeader;
        for (let i = 0; i < commonShaderCodes.length; i++) {
            fsSourceVR += commonShaderCodes[i];
        }
        fsSourceVR += shaderCode;
        fsSourceVR += this.mImagePassFooterVR;

        let res = this.mRenderer.CreateShader(vsSource, fsSourceVR, preventCache);
        if( res.mResult == false )
        {
            return res.mInfo;
        }
        if( this.mProgramVR != null )
            this.mRenderer.DestroyShader( this.mProgramVR );

        this.mSupportsVR = true;
        this.mProgramVR = res;
    }
    */
}

EffectPass.prototype.NewShader_Cubemap = function( shaderCode, commonShaderCodes )
{
    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }

    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;

    fsSource += shaderCode;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader_Common = function (shaderCode )
{
    let vsSource = null;
    if (this.mIs20)
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader + shaderCode;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader = function ( commonSourceCodes, preventCache, onResolve)
{
    if( this.mRenderer===null ) return;

    let vs_fs = null;

         if( this.mType==="sound"  ) vs_fs = this.NewShader_Sound(   this.mSource, commonSourceCodes );
    else if( this.mType==="image"  ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="buffer" ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="common" ) vs_fs = this.NewShader_Common(  this.mSource,                   );
    else if( this.mType==="cubemap") vs_fs = this.NewShader_Cubemap( this.mSource, commonSourceCodes );
    else { console.log("ERROR 3: \"" + this.mType + "\""); return; }

    let me = this;
    this.mRenderer.CreateShader(vs_fs[0], vs_fs[1], preventCache, false,
        function (worked, info)
        {
            if (worked === true)
            {
                if (me.mType === "sound")
                {
                    me.mSoundShaderCompiled = true;
                }

                me.mCompilationTime = info.mTime;
                me.mError = false;
                me.mErrorStr = "No Errors";
                if (me.mProgram !== null)
                    me.mRenderer.DestroyShader(me.mProgram);
                me.mTranslatedSource = me.mRenderer.GetTranslatedShaderSource(info);
                me.mProgram = info;
            }
            else
            {
                me.mError = true;
                me.mErrorStr = info.mErrorStr;
            }
            onResolve();
        });
}

EffectPass.prototype.DestroyInput = function( id )
{
    if( this.mInputs[id]===null ) return;

    if( this.mInputs[id].mInfo.mType==="texture" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    if( this.mInputs[id].mInfo.mType==="volume" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="webcam" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video.src = "";

        if( this.mInputs[id].video.srcObject!==null )
        {
        let tracks = this.mInputs[id].video.srcObject.getVideoTracks();
        if( tracks ) tracks[0].stop();
        }
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="video" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="music" || this.mInputs[id].mInfo.mType==="musicstream")
    {
        this.mInputs[id].audio.pause();
        this.mInputs[id].audio.mSound.mFreqData = null;
        this.mInputs[id].audio.mSound.mWaveData = null;
        this.mInputs[id].audio = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="cubemap" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="keyboard" )
    {
        //if( this.mInputs[id].globject != null )
          //  this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="mic" )
    {
        this.mInputs[id].mic = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }

    this.mInputs[id] = null;
}

EffectPass.prototype.TooglePauseInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        else
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.audio.mPaused )
        {
            if( inp.loaded )
            {
                inp.audio.play();
            }
            inp.audio.mPaused = false;
        }
        else
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }

    return null;
}

EffectPass.prototype.StopInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused === false )
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused === false )
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.ResumeInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused )
        {
            inp.audio.play();
            inp.audio.mPaused = false;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.RewindInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp==null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.loaded )
        {
            inp.video.currentTime = 0;
        }
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.loaded )
        {
            inp.audio.currentTime = 0;
        }
    }
}

EffectPass.prototype.MuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = true;
        inp.video.mMuted = true;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 0.0;
        inp.audio.mMuted = true;
    }
}

EffectPass.prototype.UnMuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = false;
        inp.video.mMuted = false;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 1.0;
        inp.audio.mMuted = false;
    }
}

EffectPass.prototype.ToggleMuteInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];
    if( inp===null ) return null;

    if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.video.mMuted;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if( inp.audio.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.audio.mMuted;
    }

    return null;
}

EffectPass.prototype.UpdateInputs = function( wa, forceUpdate, keyboard )
{
   for (let i=0; i<this.mInputs.length; i++ )
   {
        let inp = this.mInputs[i];

        if( inp===null )
        {
            if( forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, null, false, 0, 0, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.image, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mPreview, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if( inp.loaded && forceUpdate )
            {
                if( this.mTextureCallbackFun!==null )
                {
                    let img = (assetID_to_cubemapBuferID(inp.mInfo.mID)===-1) ? inp.image[0] : inp.mImage;
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, img, true, 2, 1, -1.0, this.mID );
                }
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:keyboard.mIcon,mData:keyboard.mData}, false, 6, 0, -1.0, this.mID );
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, -1, this.mID );
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
              if( inp.loaded && inp.audio.mPaused === false && inp.audio.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                      inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                  }

                  if (this.mTextureCallbackFun!==null)
                  {
                           if (inp.mInfo.mType === "music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData}, false, 4, 1, inp.audio.currentTime, this.mID);
                      else if (inp.mInfo.mType === "musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData, info: inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                  }
              }
              else if( inp.loaded===false )
              {
                  if (this.mTextureCallbackFun!==null)
                      this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:null}, false, 4, 0, -1.0, this.mID);
              }
        }
        else if( inp.mInfo.mType==="mic" )
        {
              if( inp.loaded && inp.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                      inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
                  }
                  if( this.mTextureCallbackFun!==null )
                      this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave: ((wa==null)?null:inp.mFreqData) }, false, 5, 1, 0, this.mID );
              }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:null}, true, 9, 1, -1.0, this.mID );
            }
        }
    }
}

EffectPass.prototype.Sampler2Renderer = function (sampler)
{
    let filter = this.mRenderer.FILTER.NONE;
    if (sampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
    if (sampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
    let wrap = this.mRenderer.TEXWRP.REPEAT;
    if (sampler.wrap === "clamp") wrap = this.mRenderer.TEXWRP.CLAMP;
    let vflip = false;
    if (sampler.vflip === "true") vflip = true;

    return { mFilter: filter, mWrap: wrap, mVFlip: vflip };
}

EffectPass.prototype.GetSamplerVFlip = function (id)
{
    let inp = this.mInputs[id];
    return inp.mInfo.mSampler.vflip;
}

EffectPass.prototype.GetTranslatedShaderSource = function ()
{
    return this.mTranslatedSource;
}

EffectPass.prototype.SetSamplerVFlip = function (id, str) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = false;
    if (str === "true") filter = true;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, null);
            inp.mInfo.mSampler.vflip = str;
        }
    }
}

EffectPass.prototype.GetAcceptsVFlip = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return false;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return false;
    return true;
}

EffectPass.prototype.GetSamplerFilter = function (id)
{
    let inp = this.mInputs[id];
    if( inp===null) return;
    return inp.mInfo.mSampler.filter;
}

EffectPass.prototype.SetSamplerFilter = function (id, str, buffers, cubeBuffers) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = renderer.FILTER.NONE;
    if (str === "linear") filter = renderer.FILTER.LINEAR;
    if (str === "mipmap") filter = renderer.FILTER.MIPMAP;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0)
            {
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[0], filter, true);
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[1], filter, true);
                inp.mInfo.mSampler.filter = str;
            }
            else
            {
                renderer.SetSamplerFilter(inp.globject, filter, true);
                inp.mInfo.mSampler.filter = str;
            }
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[0], filter, true);
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[1], filter, true);
        inp.mInfo.mSampler.filter = str;
    }
    else if (inp.mInfo.mType === "keyboard")
    {
        inp.mInfo.mSampler.filter = str;
    }
}

EffectPass.prototype.GetAcceptsMipmapping = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetAcceptsLinear = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return true;
    if (inp.mInfo.mType === "musicstream") return true;
    if (inp.mInfo.mType === "mic")  return true;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return true;
    return false;
}

EffectPass.prototype.GetAcceptsWrapRepeat = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return false;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetSamplerWrap = function (id)
{
    return this.mInputs[id].mInfo.mSampler.wrap;
}

EffectPass.prototype.SetSamplerWrap = function (id, str, buffers)
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let restr = renderer.TEXWRP.REPEAT;
    if (str === "clamp") restr = renderer.TEXWRP.CLAMP;

    if (inp === null) 
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "video") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap") 
    {
        if (inp.loaded)
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "webcam") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[0], restr);
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[1], restr);
        inp.mInfo.mSampler.wrap = str;
    }
}


EffectPass.prototype.GetTexture = function( slot )
{
    let inp = this.mInputs[slot];
    if( inp===null ) return null;
    return inp.mInfo;
}

EffectPass.prototype.SetOutputs = function( slot, id )
{
    this.mOutputs[slot] = id;
}

EffectPass.prototype.SetOutputsByBufferID = function( slot, id )
{
    if( this.mType==="buffer" )
    {
        this.mOutputs[slot] = bufferID_to_assetID( id );

        this.mEffect.ResizeBuffer( id, this.mEffect.mXres, this.mEffect.mYres, false );
    }
    else if( this.mType==="cubemap" )
    {
        this.mOutputs[slot] = cubamepBufferID_to_assetID( id );
        this.mEffect.ResizeCubemapBuffer(id, 1024, 1024 );
    }
}

EffectPass.prototype.NewTexture = function( wa, slot, url, buffers, cubeBuffers, keyboard )
{
    var me = this;
    var renderer = this.mRenderer;

    if( renderer===null ) return;

    let texture = null;

    if( url===null || url.mType===null )
    {
        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( this.mTextureCallbackObj, slot, null, true, 0, 0, -1.0, me.mID );
        me.DestroyInput( slot );
        me.mInputs[slot] = null;
        me.MakeHeader();
        return { mFailed:false, mNeedsShaderCompile:false };
    }
    else if( url.mType==="texture" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.image = new Image();
        texture.image.crossOrigin = '';
        texture.image.onload = function()
        {
            let rti = me.Sampler2Renderer(url.mSampler);

            // O.M.G. FIX THIS
            let channels = renderer.TEXFMT.C4I8;
            if (url.mID === "Xdf3zn" || url.mID === "4sf3Rn" || url.mID === "4dXGzn" || url.mID === "4sf3Rr")
                channels = renderer.TEXFMT.C1I8;
            
            texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.image, channels, rti.mFilter, rti.mWrap, rti.mVFlip);

            texture.loaded = true;
            if( me.mTextureCallbackFun!==null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.image, true, 1, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="volume" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mImage = { mData:null, mXres:1, mYres:0, mZres:0 };
        texture.mPreview = new Image();
        texture.mPreview.crossOrigin = '';

	    var xmlHttp = new XMLHttpRequest();
        if( xmlHttp===null ) return { mFailed:true };

        xmlHttp.open('GET', url.mSrc, true);
        xmlHttp.responseType = "arraybuffer";
        xmlHttp.onerror = function()
        {
            console.log( "Error 1 loading Volume" );
        }
        xmlHttp.onload = function()
        {
            let data = xmlHttp.response;
            if (!data ) { console.log( "Error 2 loading Volume" ); return; }

            let file = piFile(data);

            let signature = file.ReadUInt32();
            texture.mImage.mXres = file.ReadUInt32();
            texture.mImage.mYres = file.ReadUInt32();
            texture.mImage.mZres = file.ReadUInt32();
            let binNumChannels = file.ReadUInt8();
            let binLayout = file.ReadUInt8();
            let binFormat = file.ReadUInt16();
            let format = renderer.TEXFMT.C1I8;
                 if( binNumChannels===1 && binFormat===0 )  format = renderer.TEXFMT.C1I8;
            else if( binNumChannels===2 && binFormat===0 )  format = renderer.TEXFMT.C2I8;
            else if( binNumChannels===3 && binFormat===0 )  format = renderer.TEXFMT.C3I8;
            else if( binNumChannels===4 && binFormat===0 )  format = renderer.TEXFMT.C4I8;
            else if( binNumChannels===1 && binFormat===10 ) format = renderer.TEXFMT.C1F32;
            else if( binNumChannels===2 && binFormat===10 ) format = renderer.TEXFMT.C2F32;
            else if( binNumChannels===3 && binFormat===10 ) format = renderer.TEXFMT.C3F32;
            else if( binNumChannels===4 && binFormat===10 ) format = renderer.TEXFMT.C4F32;
            else return;

            let buffer = new Uint8Array(data, 20); // skip 16 bytes (header of .bin)

            let rti = me.Sampler2Renderer(url.mSampler);

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T3D, texture.mImage.mXres, texture.mImage.mYres, format, rti.mFilter, rti.mWrap, buffer);

            if( texture.globject===null )
            {
                console.log( "Error 4: loading Volume" ); 
                return { mFailed:true };
            }

            if (me.mTextureCallbackFun !== null)
            {
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }

            texture.loaded = true;

            // load icon for it
            texture.mPreview.onload = function()
            {
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }
            texture.mPreview.src = url.mPreviewSrc;
        }
        xmlHttp.send("");


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="volume")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="cubemap" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        let rti = me.Sampler2Renderer(url.mSampler);

        if( assetID_to_cubemapBuferID(url.mID)!==-1 )
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 2, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/cubemap00.png";

            this.mEffect.ResizeCubemapBuffer(0, 1024, 1024 );

        }
        else
        {
            texture.image = [ new Image(), new Image(), new Image(), new Image(), new Image(), new Image() ];

            let numLoaded = 0;
            for (var i=0; i<6; i++ )
            {
                texture.image[i].mId = i;
                texture.image[i].crossOrigin = '';
                texture.image[i].onload = function()
                {
                    var id = this.mId;
                    numLoaded++;
                    if( numLoaded===6 )
                    {
                        texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.CUBEMAP, texture.image, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                        texture.loaded = true;
                        if (me.mTextureCallbackFun !== null)
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, texture.image[0], true, 2, 1, -1.0, me.mID);
                    }
                }

                if( i === 0) 
                {
                    texture.image[i].src = url.mSrc;
                } 
                else 
                {
                    let n = url.mSrc.lastIndexOf(".");
                    texture.image[i].src = url.mSrc.substring(0, n) + "_" + i + url.mSrc.substring(n, url.mSrc.length);
                }
            }
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="cubemap")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="webcam" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        texture.video = document.createElement('video');
    	texture.video.width = 320;
    	texture.video.height = 240;
    	texture.video.autoplay = true;
    	texture.video.loop = true;
        texture.mForceMuted = this.mForceMuted;
        texture.mImage = null;

        let rti = me.Sampler2Renderer(url.mSampler);

        var loadImageInsteadOfWebCam = function()
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.mImage, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 7, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/webcam.png";
        }
        
        loadImageInsteadOfWebCam();

        if( typeof navigator.getUserMedia !== "undefined"  && texture.mForceMuted===false )
        {
            texture.video.addEventListener("canplay", function (e)
            {
				try
				{
                    texture.mImage = null;
                    if( texture.globject != null )
                        renderer.DestroyTexture( texture.globject );
					texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
					texture.loaded = true;
                }
                catch(e)
                {
                    loadImageInsteadOfWebCam();
	                alert( 'Your browser can not transfer webcam data to the GPU.');
                }
            } );

            navigator.mediaDevices.getUserMedia( 
                                { "video": { width: 1280, height: 720 }, "audio": false } )
                                .then( function(stream)
                                       {
                                            texture.video.srcObject = stream;
    	                               } )
                                .catch( function(error)
                                        {
                                            loadImageInsteadOfWebCam();
    		                                alert( 'Unable to capture WebCam. Please reload the page.' );
    	                                } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="mic" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mForceMuted = this.mForceMuted;
        texture.mAnalyser = null;
        let num = 512;
        texture.mFreqData = new Uint8Array( num );
        texture.mWaveData = new Uint8Array( num );

        if( wa === null || typeof navigator.getUserMedia === "undefined" )
        {
            if( !texture.mForceMuted ) alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.mForceMuted = true; 
        }

        if( texture.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, num, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)
            texture.loaded = true;
        }
        else
        {
        navigator.getUserMedia( { "audio": true },
                                function(stream)
                                {
                                  texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, null)
                                  texture.mic = wa.createMediaStreamSource(stream);
                                  texture.mAnalyser = wa.createAnalyser();
                                  texture.mic.connect( texture.mAnalyser );
                                  texture.loaded = true;
    	                        },
                                function(error)
                                {
    		                        alert( 'Unable open Mic. Please reload the page.' );
    	                        } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="video" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.video = document.createElement('video');
    	texture.video.loop = true;
        texture.video.preload = "auto";
        texture.video.mPaused = this.mForcePaused;
        texture.video.mMuted = true;//this.mForceMuted;
    	texture.video.muted  = true;//this.mForceMuted;
        if( this.mForceMuted===true )
            texture.video.volume = 0;
    	texture.video.autoplay = false;
        texture.video.hasFalled = false;
        
        let rti = me.Sampler2Renderer(url.mSampler);

        texture.video.addEventListener("canplay", function (e)
        {
            texture.video.play().then( function()
                                       {
                                           texture.video.mPaused = false;

                                           texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                                           texture.loaded = true;
            
                                           if( me.mTextureCallbackFun!=null )
                                               me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.video, true, 3, 1, -1.0, me.mID );
                                        } )
                               .catch( function(error)
                                       {
                                           console.log( error );
                                       }
                                );
        } );

        texture.video.addEventListener( "error", function(e)
        {
               if( texture.video.hasFalled===true ) { alert("Error: cannot load video" ); return; }
               let str = texture.video.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".mp4";
               texture.video.src = str;
               texture.video.hasFalled = true;
        } );

        texture.video.src = url.mSrc;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="music" || url.mType==="musicstream" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.audio = document.createElement('audio');
    	texture.audio.loop = true;
        texture.audio.mMuted = this.mForceMuted;
        texture.audio.mForceMuted = this.mForceMuted;
        texture.audio.muted = this.mForceMuted;
        if( this.mForceMuted===true )
            texture.audio.volume = 0;
        texture.audio.autoplay = false;
        texture.audio.hasFalled = false;
        texture.audio.mPaused = false;
        texture.audio.mSound = {};

        if( this.mForceMuted===false )
        {
            if(url.mType==="musicstream" && SC === null)
            {
                alert( "Shadertoy: Soundcloud could not be reached" );
                texture.audio.mForceMuted = true;
            }
            }

        if( wa === null && this.mForceMuted===false )
        {
            alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.audio.mForceMuted = true;
        }

        if( texture.audio.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null);
            let num = 512;
            texture.audio.mSound.mFreqData = new Uint8Array( num );
            texture.audio.mSound.mWaveData = new Uint8Array( num );
            texture.loaded = true;
        }

        texture.audio.addEventListener( "canplay", function()
        {
            if( texture===null || texture.audio===null ) return;
            if( this.mForceMuted  ) return;
            if( texture.loaded === true ) return;

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)

            texture.audio.mSound.mSource   = wa.createMediaElementSource( texture.audio );
            texture.audio.mSound.mAnalyser = wa.createAnalyser();
            texture.audio.mSound.mGain     = wa.createGain();

            texture.audio.mSound.mSource.connect(   texture.audio.mSound.mAnalyser );
            texture.audio.mSound.mAnalyser.connect( texture.audio.mSound.mGain );
            texture.audio.mSound.mGain.connect(me.mGainNode);

            texture.audio.mSound.mFreqData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );
            texture.audio.mSound.mWaveData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );

            if( texture.audio.mPaused )
            {
                texture.audio.pause();
            }
            else
            {
                texture.audio.play().then( function() {} ).catch( function(e){console.log("error " + e);} );
            }
            texture.loaded = true;
        } );

        texture.audio.addEventListener( "error", function(e)
        {
               if( this.mForceMuted  ) return;

               if( texture.audio.hasFalled===true ) { return; }
               let str = texture.audio.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".ogg";
               texture.audio.src = str;
               texture.audio.hasFalled = true;
        } );

        if( !texture.audio.mForceMuted )
        {
            if(url.mType==="musicstream")
            {
                SC.resolve(url.mSrc, 
                    function(song) 
                    {
                        if( song.streamable===true )
                        {
                            texture.audio.crossOrigin = 'anonymous';
                            texture.audio.src = song.stream_url;
                            texture.audio.soundcloudInfo = song;
                        }
                        else
                        {
                            alert('Shadertoy: Soundcloud 3 - This track cannot be streamed' );
                        }
                    },
                    function(error)
                    {
                        if (me.mTextureCallbackFun!==null)
                        {
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
                        }
                    } );
            } 
            else
            {
                texture.audio.src = url.mSrc;
            }
        }

        if (me.mTextureCallbackFun!==null)
        {
            if (url.mType === "music")            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
            else if (url.mType === "musicstream") me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null, info: texture.audio.soundcloudInfo}, false, 8, 0, -1.0, me.mID);
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="keyboard" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = true;

        texture.keyboard = {};

        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {mImage: keyboard.mIcon, mData: keyboard.mData}, false, 6, 1, -1.0, me.mID );

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="buffer" )
    {
        texture = {};
        texture.mInfo = url;

        texture.image = new Image();
        texture.image.onload = function()
        {
            if( me.mTextureCallbackFun!==null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {texture: texture.image, data:null}, true, 9, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;
        texture.id = assetID_to_bufferID( url.mID );
        texture.loaded = true;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;

        this.mEffect.ResizeBuffer(texture.id, this.mEffect.mXres, this.mEffect.mYres, false );

        this.SetSamplerFilter(slot, url.mSampler.filter, buffers, cubeBuffers, true);
        this.SetSamplerVFlip(slot, url.mSampler.vflip);
        this.SetSamplerWrap(slot, url.mSampler.wrap, buffers);

        this.MakeHeader();
        return returnValue;
    }
    else
    {
        alert( "input type error" );
        return { mFailed: true };
    }

    return { mFailed: true };
}

EffectPass.prototype.Paint_Image = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];

    //------------------------
    
    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];
    let texIsLoaded = [0, 0, 0, 0 ];
    let texID = [ null, null, null, null];

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
            texIsLoaded[i] = 1;
            resos[3*i+0] = 256;
            resos[3*i+1] = 3;
            resos[3*i+2] = 1;
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;

                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                }
            }
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {

                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                texIsLoaded[i] = 0;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    times[i] = 10.0 + time;
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            let id = inp.id;
            if( inp.loaded===true  )
            {
                texID[i] = buffers[id].mTexture[ buffers[id].mLastRenderDone ];
                texIsLoaded[i] = 1;
                resos[3*i+0] = xres;
                resos[3*i+1] = yres;
                resos[3*i+2] = 1;
                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID[i], filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    let prog = this.mProgram;

    //if( vrData!=null && this.mSupportsVR ) prog = this.mProgramVR;

    this.mRenderer.AttachShader(prog);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F("iFrameRate", fps);

    this.mRenderer.SetShaderConstant1F(  "iCh0.time", times[0] );
    this.mRenderer.SetShaderConstant1F(  "iCh1.time", times[1] );
    this.mRenderer.SetShaderConstant1F(  "iCh2.time", times[2] );
    this.mRenderer.SetShaderConstant1F(  "iCh3.time", times[3] );
    this.mRenderer.SetShaderConstant3F(  "iCh0.size", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iCh1.size", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iCh2.size", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iCh3.size", resos[9], resos[10], resos[11] );
    this.mRenderer.SetShaderConstant1I(  "iCh0.loaded", texIsLoaded[0] );
    this.mRenderer.SetShaderConstant1I(  "iCh1.loaded", texIsLoaded[1] );
    this.mRenderer.SetShaderConstant1I(  "iCh2.loaded", texIsLoaded[2] );
    this.mRenderer.SetShaderConstant1I(  "iCh3.loaded", texIsLoaded[3] );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    if( (vrData !== null) && this.mSupportsVR )
    {
        for (let i=0; i<2; i++ )
        {
            let ei = (i===0) ? vrData.mLeftEye : vrData.mRightEye;

            let vp = [i * xres / 2, 0, xres / 2, yres];

            this.mRenderer.SetViewport(vp);

            let fov = ei.mProjection;
            let corA = [ -fov[2], -fov[1], -1.0 ];
            let corB = [  fov[3], -fov[1], -1.0 ];
            let corC = [  fov[3],  fov[0], -1.0 ];
            let corD = [ -fov[2],  fov[0], -1.0 ];
            let apex = [ 0.0, 0.0, 0.0 ];

            let ma = invertFast( ei.mCamera );
            corA = matMulpoint( ma, corA ); 
            corB = matMulpoint( ma, corB ); 
            corC = matMulpoint( ma, corC ); 
            corD = matMulpoint( ma, corD ); 
            apex = matMulpoint( ma, apex ); 

            let corners = [ corA[0], corA[1], corA[2], 
                            corB[0], corB[1], corB[2], 
                            corC[0], corC[1], corC[2], 
                            corD[0], corD[1], corD[2],
                            apex[0], apex[1], apex[2]];

            this.mRenderer.SetShaderConstant3FV("unCorners", corners);
            this.mRenderer.SetShaderConstant4FV("unViewport", vp);

            this.mRenderer.DrawUnitQuad_XY(l1);
        }
    }
    else 
    {
        this.mRenderer.SetViewport([0, 0, xres, yres]);
        this.mRenderer.DrawFullScreenTriangle_XY( l1 );
    }

    this.mRenderer.DettachTextures();
}

EffectPass.prototype.iRenderSound = function(d, callback )
{
    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds() ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    this.mRenderer.SetRenderTarget(this.mRenderFBO);

    this.mRenderer.SetViewport([0, 0, this.mTextureDimensions, this.mTextureDimensions]);
    this.mRenderer.AttachShader(this.mProgram);
    this.mRenderer.SetBlend( false );

    let texID = [null, null, null, null];
    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
    }

    this.mRenderer.AttachTextures(4, texID[0], texID[1], texID[2], texID[3]);

    let l2 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iTimeOffset");
    let l3 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iSampleOffset");
    this.mRenderer.SetShaderConstant4FV("iDate", dates);
    this.mRenderer.SetShaderConstant3FV("iChannelResolution", resos);
    this.mRenderer.SetShaderConstant1F("iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit("iChannel0", 0);
    this.mRenderer.SetShaderTextureUnit("iChannel1", 1);
    this.mRenderer.SetShaderTextureUnit("iChannel2", 2);
    this.mRenderer.SetShaderTextureUnit("iChannel3", 3);

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    //--------------------------------
    let numSamples = this.mTmpBufferSamples;
    let numBlocks = this.mPlaySamples / numSamples;
    for (let j=0; j<numBlocks; j++ )
    {
        let off = j*numSamples;
        
        this.mRenderer.SetShaderConstant1F_Pos(l2, off / this.mSampleRate);
        this.mRenderer.SetShaderConstant1I_Pos(l3, off );
        this.mRenderer.DrawUnitQuad_XY(l1);

        this.mRenderer.GetPixelData(this.mData, 0, this.mTextureDimensions, this.mTextureDimensions);

        callback( off, this.mData, numSamples );
    }

    this.mRenderer.DetachShader();
    this.mRenderer.DettachTextures();
    this.mRenderer.SetRenderTarget(null);
}

EffectPass.prototype.Paint_Sound = function( wa, d )
{
    let bufL = this.mBuffer.getChannelData(0); // Float32Array
    let bufR = this.mBuffer.getChannelData(1); // Float32Array

    this.iRenderSound( d, function(off, data, numSamples)
                         {
                            for( let i=0; i<numSamples; i++ )
                            {
                                bufL[off+i] = -1.0 + 2.0*(data[4*i+0]+256.0*data[4*i+1])/65535.0;
                                bufR[off+i] = -1.0 + 2.0*(data[4*i+2]+256.0*data[4*i+3])/65535.0;
                            }
                         }
                     );
}

EffectPass.prototype.SetUniforms = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    //------------------------
    
    let texID = [ null, null, null, null];

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
        }
        else if( inp.mInfo.mType=="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
    
                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                }
            }

        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
           if( inp.loaded===true )
           { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                times[i] = 10.0 + time;
            }

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = buffers[inp.id].mTexture[ buffers[inp.id].mLastRenderDone ];
                resos[3*i+0] = buffers[inp.id].mResolution[0];
                resos[3*i+1] = buffers[inp.id].mResolution[1];
                resos[3*i+2] = 1;
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    this.mRenderer.AttachShader(this.mProgram);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F(  "iFrameRate", fps );

    this.mRenderer.SetShaderConstant1F(  "iChannel[0].time",       times[0] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[1].time",       times[1] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[2].time",       times[2] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[3].time",       times[3] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[0].resolution", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[1].resolution", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[2].resolution", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[3].resolution", resos[9], resos[10], resos[11] );
}

EffectPass.prototype.ProcessInputs = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
        }
        else if( inp.mInfo.mType==="volume" )
        {
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );
                }
                else if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                if( inp.audio.mForceMuted === true )
                {
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                let id = inp.id;
                let texID = buffers[id].mTexture[ buffers[id].mLastRenderDone ];

                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID, filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
				let id = inp.id;
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }
}

EffectPass.prototype.Paint_Cubemap = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face )
{
    this.ProcessInputs(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
    this.SetUniforms(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    let vp = [0, 0, xres, yres];

    this.mRenderer.SetViewport(vp);

    let corA = [-1.0, -1.0, -1.0];
    let corB = [ 1.0, -1.0, -1.0];
    let corC = [ 1.0,  1.0, -1.0];
    let corD = [-1.0,  1.0, -1.0];
    let apex = [ 0.0,  0.0,  0.0];

         if( face===0 ) { corA=[ 1.0,  1.0,  1.0]; corB=[ 1.0,  1.0, -1.0]; corC=[ 1.0, -1.0, -1.0]; corD=[ 1.0, -1.0,  1.0]; }
    else if( face===1 ) { corA=[-1.0,  1.0, -1.0]; corB=[-1.0,  1.0,  1.0]; corC=[-1.0, -1.0,  1.0]; corD=[-1.0, -1.0, -1.0]; }
    else if( face===2 ) { corA=[-1.0,  1.0, -1.0]; corB=[ 1.0,  1.0, -1.0]; corC=[ 1.0,  1.0,  1.0]; corD=[-1.0,  1.0,  1.0]; }
    else if( face===3 ) { corA=[-1.0, -1.0,  1.0]; corB=[ 1.0, -1.0,  1.0]; corC=[ 1.0, -1.0, -1.0]; corD=[-1.0, -1.0, -1.0]; }
    else if( face===4 ) { corA=[-1.0,  1.0,  1.0]; corB=[ 1.0,  1.0,  1.0]; corC=[ 1.0, -1.0,  1.0]; corD=[-1.0, -1.0,  1.0]; }
    else if( face===5 ) { corA=[ 1.0,  1.0, -1.0]; corB=[-1.0,  1.0, -1.0]; corC=[-1.0, -1.0, -1.0]; corD=[ 1.0, -1.0, -1.0]; }

    let corners = [ corA[0], corA[1], corA[2], 
                    corB[0], corB[1], corB[2], 
                    corC[0], corC[1], corC[2], 
                    corD[0], corD[1], corD[2],
                    apex[0], apex[1], apex[2]];

    this.mRenderer.SetShaderConstant3FV("unCorners", corners);
    this.mRenderer.SetShaderConstant4FV("unViewport", vp);

    this.mRenderer.DrawUnitQuad_XY(l1);

    this.mRenderer.DettachTextures();
}

EffectPass.prototype.Paint = function( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, bufferNeedsMimaps, buffers, cubeBuffers, keyboard, effect )
{
    if( this.mType==="sound" )
    {
        if (this.mSoundShaderCompiled === true)
        {
            // make sure all textures are loaded
            for (let i=0; i<this.mInputs.length; i++ )
            {
                let inp = this.mInputs[i];
                if (inp === null) continue;

                if (inp.mInfo.mType === "texture" && !inp.loaded) return;
                if (inp.mInfo.mType === "cubemap" && !inp.loaded) return;
            }

            this.Paint_Sound(wa, da);
            this.mSoundShaderCompiled = false;
        }
        if (this.mFrame === 0)
        {
            if (this.mPlaying===true)
            {
                this.mPlayNode.disconnect();
                this.mPlayNode.stop();
                this.mPlayNode = null;
            }
            this.mPlaying = true;

            this.mPlayNode = wa.createBufferSource();
            this.mPlayNode.buffer = this.mBuffer;
            this.mPlayNode.connect(this.mGainNode);
            this.mPlayNode.start(0);
        }
        this.mFrame++;
    }
    else if( this.mType==="image" )
    {
        this.mRenderer.SetRenderTarget( null );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );
        this.mFrame++;
    }
    else if( this.mType==="common" )
    {
    }
    else if( this.mType==="buffer" )
    {
        this.mEffect.ResizeBuffer(bufferID, this.mEffect.mXres, this.mEffect.mYres, false );

        let buffer = buffers[bufferID];

        let dstID = 1 - buffer.mLastRenderDone;

        this.mRenderer.SetRenderTarget( buffer.mTarget[dstID] );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }

        // make thumbnail
        //if( this.mTextureCallbackFun != null )
        /*
        {
            this.mRenderer.SetRenderTarget( buffer.mThumbnailRenderTarget );
            let v = [0, 0, buffer.mThumbnailRes[0], buffer.mThumbnailRes[1]];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            this.mRenderer.SetShaderConstant4FV("v", v);
            this.mRenderer.AttachTextures(1, buffer.mTexture[dstID], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);
            this.mRenderer.DettachTextures();
            this.mRenderer.DetachShader();
            this.mRenderer.GetPixelData( new Uint8Array(buffer.mThumbnailBuffer.data.buffer), buffer.mThumbnailRes[0], buffer.mThumbnailRes[1] );
            this.mRenderer.SetRenderTarget(null);
        }
        */
        buffers[bufferID].mLastRenderDone = 1 - buffers[bufferID].mLastRenderDone;
        this.mFrame++;
    }
    else if( this.mType==="cubemap" )
    {
        this.mEffect.ResizeCubemapBuffer(bufferID, 1024, 1024, false );

        let buffer = cubeBuffers[bufferID];

        xres = buffer.mResolution[0];
        yres = buffer.mResolution[1];
        let dstID = 1 - buffer.mLastRenderDone;
        for( let face=0; face<6; face++ )
        {
            this.mRenderer.SetRenderTargetCubeMap( buffer.mTarget[dstID], face );
            this.Paint_Cubemap( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
        }
        this.mRenderer.SetRenderTargetCubeMap( null, 0 );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }
        cubeBuffers[bufferID].mLastRenderDone = 1 - cubeBuffers[bufferID].mLastRenderDone;

        this.mFrame++;
    }
}

EffectPass.prototype.StopOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;
    this.mPlayNode.disconnect();
}

EffectPass.prototype.ResumeOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;

    wa.resume()
    this.mPlayNode.connect( this.mGainNode );
}

EffectPass.prototype.StopOutput_Image = function( wa )
{
}

EffectPass.prototype.ResumeOutput_Image = function( wa )
{
}

EffectPass.prototype.StopOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.StopInput(j);

    if( this.mType==="sound" )
         this.StopOutput_Sound( wa );
    else
         this.StopOutput_Image( wa );
}

EffectPass.prototype.ResumeOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.ResumeInput(j);

    if( this.mType==="sound" )
         this.ResumeOutput_Sound( wa );
    else
         this.ResumeOutput_Image( wa );
}

EffectPass.prototype.GetCompilationTime = function()
{
    return this.mCompilationTime;
}

//============================================================================================================
function Screenshots()
{
    // private
    let mTexture = null;
    let mTarget = null;
    let mXres = 0;
    let mYres = 0;
    let mCubemapToEquirectProgram;
    let mRenderer = null;

    // public
    var me = {};

    me.Initialize = function(renderer)
    {
        mRenderer = renderer;
        let caps = mRenderer.GetCaps();
        let is20 = caps.mIsGL20;

        let vsSourceC, fsSourceC;
        if( is20 )
        {
            vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; out vec4 outColor; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); outColor = texture(t, rd); }";
        }
        else
        {
            vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); gl_FragColor = texture(t, rd); }";
        }

        let compileShader = function (worked, info)
        {
            if (worked === false)
            {
                console.log("Failed to compile cubemap resample shader (" + errorType + "): " + log);
            }
            else
            {
                mCubemapToEquirectProgram = info;
            }
        }
        mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, compileShader);

        return true;
    };

    me.Allocate = function( xres, yres )
    {
        if( xres>mXres || yres>mYres )
        {
            let texture = mRenderer.CreateTexture(mRenderer.TEXTYPE.T2D, xres, yres, mRenderer.TEXFMT.C4F32, mRenderer.FILTER.NONE, mRenderer.TEXWRP.CLAMP, null);
            let target = mRenderer.CreateRenderTarget( texture, null, null, null, null, false);

            if( mXres!==0 )
            {
                mRenderer.DestroyTexture(mTexture);
                mRenderer.DestroyRenderTarget(mTarget);
            }

            mTexture = texture;
            mTarget = target;
            mXres = xres;
            mYres = yres;
        }
    };

    me.GetProgram = function()
    {
        return mCubemapToEquirectProgram;
    };
    me.GetTarget = function()
    {
        return mTarget;
    };

    return me;
};

//============================================================================================================

function Effect(vr, ac, canvas, callback, obj, forceMuted, forcePaused, resizeCallback, crashCallback )
{
    let xres = canvas.width;
    let yres = canvas.height;

    let me = this;
    this.mCanvas = canvas;
    this.mCreated = false;
    this.mRenderer = null;
    this.mAudioContext = ac;
    this.mGLContext = null;
    this.mWebVR = vr;
    this.mRenderingStereo = false;
    this.mXres = xres;
    this.mYres = yres;
    this.mForceMuted = forceMuted;
    if( ac===null ) this.mForceMuted = true;
    this.mForcePaused = forcePaused;
    this.mGainNode = null;
    this.mPasses = [];
    this.mFrame = 0;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mMaxBuffers = 4;
    this.mMaxCubeBuffers = 1;
    this.mMaxPasses = this.mMaxBuffers + 1 + 1 + 1 + 1; // some day decouple passes from buffers (4 buffers + common + Imagen + sound + cubemap)
    this.mBuffers = [];
    this.mCubeBuffers = [];
    this.mScreenshotSytem = null;
    this.mCompilationTime = 0;
    this.mIsLowEnd = piIsMobile();

    this.mGLContext = piCreateGlContext(canvas, false, false, true, false); // need preserve-buffe to true in order to capture screenshots
    if (this.mGLContext === null)
    {
        return;
    }

    canvas.addEventListener("webglcontextlost", function (event)
        {
            event.preventDefault();
            crashCallback();
        }, false);

    this.mRenderer = piRenderer();
    if (!this.mRenderer.Initialize(this.mGLContext))
        return;

    this.mScreenshotSytem = Screenshots();
    if (!this.mScreenshotSytem.Initialize(this.mRenderer))
        return;

    var caps = this.mRenderer.GetCaps();
    this.mIs20 = caps.mIsGL20;
    this.mShaderTextureLOD = caps.mShaderTextureLOD;
    //-------------
    if( ac!==null )
    {   
        this.mGainNode = ac.createGain();
        if( !forceMuted )
        {
            this.mGainNode.connect( ac.destination);
        }
        if (this.mForceMuted )
            this.mGainNode.gain.value = 0.0;
        else
            this.mGainNode.gain.value = 1.0;
    }

    //-------------
    let vsSourceC, fsSourceC;
    if( this.mIs20 )
    {
        vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { outColor = textureLod(t, gl_FragCoord.xy / v.zw, 0.0); }";
    }
    else
    {
        vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; void main() { gl_FragColor = texture2D(t, gl_FragCoord.xy / v.zw, -100.0); }";
    }

    this.mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, function(worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to copy buffers : " + info.mErrorStr);
            else me.mProgramCopy = info;
        });

    let vsSourceD, fsSourceD;
    if( this.mIs20 )
    {
        vsSourceD = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { vec2 uv = gl_FragCoord.xy / v.zw; outColor = texture(t, vec2(uv.x,1.0-uv.y)); }";
    }
    else
    {
        vsSourceD = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; void main() { vec2 uv = gl_FragCoord.xy / v.zw; gl_FragColor = texture2D(t, vec2(uv.x,1.0-uv.y)); }";
    }

    this.mRenderer.CreateShader(vsSourceD, fsSourceD, false, true, function (worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to downscale buffers : " + info.mErrorStr);
            else me.mProgramDownscale = info;
        });


    // set all buffers and cubemaps to null
    for( let i=0; i<this.mMaxBuffers; i++ )
    {
        this.mBuffers[i] = { mTexture: [null, null], 
                             mTarget:  [null, null], 
                             mResolution: [0, 0],
                             mLastRenderDone: 0,
                             mThumbnailRenderTarget: null,
                             mThumbnailTexture: null,
                             mThumbnailBuffer:  null,
                             mThumbnailRes: [0, 0] };
    }

    for( let i=0; i<this.mMaxCubeBuffers; i++ )
    {
        this.mCubeBuffers[i] = { mTexture: [null, null], 
                                mTarget:  [null, null], 
                                mResolution: [0, 0],
                                mLastRenderDone: 0,
                                mThumbnailRenderTarget: null,
                                mThumbnailTexture: null,
                                mThumbnailBuffer:  null,
                                mThumbnailRes: [0, 0] };
    }

    //-------

    let keyboardData = new Uint8Array( 256*3 );
    for (let j=0; j<(256*3); j++ ) { keyboardData[j] = 0; }
    let kayboardTexture = this.mRenderer.CreateTexture( this.mRenderer.TEXTYPE.T2D, 256, 3, this.mRenderer.TEXFMT.C1I8, this.mRenderer.FILTER.NONE, this.mRenderer.TEXWRP.CLAMP, null);
    let keyboardImage = new Image();
    if( callback!==null )
        keyboardImage.src = "/img/keyboard.png"; // don't load PNG if no UI 
    this.mKeyboard = { mData: keyboardData, mTexture: kayboardTexture, mIcon: keyboardImage };

    let iResize = function( xres, yres )
    {
        me.mCanvas.width = xres;
        me.mCanvas.height = yres;
        me.mXres = xres;
        me.mYres = yres;
        me.ResizeBuffers(xres, yres);
        resizeCallback(xres, yres);
    };

    let bestAttemptFallback = function()
    {
        let devicePixelRatio = window.devicePixelRatio || 1;
        let xres = Math.round(me.mCanvas.offsetWidth  * devicePixelRatio) | 0;
        let yres = Math.round(me.mCanvas.offsetHeight * devicePixelRatio) | 0;
        iResize(xres, yres);
    };

    if(!window.ResizeObserver)
    {
        console.log("WARNING: This browser doesn't support ResizeObserver.");
        bestAttemptFallback();
        window.addEventListener("resize", bestAttemptFallback);
    }
    else
    {
        this.mRO = new ResizeObserver( function(entries, observer)
        {
            var entry = entries[0];
            if (!entry['devicePixelContentBoxSize'])
            {
                observer.unobserve(me.mCanvas);
                console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (2)");
                bestAttemptFallback();
                window.addEventListener("resize", bestAttemptFallback);
            }
            else
            {
                let box = entry.devicePixelContentBoxSize[0];
                let xres = box.inlineSize;
                let yres = box.blockSize;
                iResize(xres, yres);
            }
        });
        try
        {
            this.mRO.observe(this.mCanvas, { box: ["device-pixel-content-box"] });
            //this.mRO.observe(this.mCanvas);
        }
        catch (e)
        {
            console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (1)");
            bestAttemptFallback();
            window.addEventListener("resize", bestAttemptFallback);
        }
    }

    this.mCreated = true;
}

Effect.prototype.ResizeCubemapBuffer = function(i, xres, yres )
{
    let oldXres = this.mCubeBuffers[i].mResolution[0];
    let oldYres = this.mCubeBuffers[i].mResolution[1];

    if( this.mCubeBuffers[i].mTexture[0]===null || oldXres !== xres || oldYres !== yres )
    {
        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);
        let target1 = this.mRenderer.CreateRenderTargetCubeMap( texture1, null, false);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target2 = this.mRenderer.CreateRenderTargetCubeMap( texture2, null, false);

        // Store new buffers
        this.mCubeBuffers[i].mTexture = [texture1,texture2], 
        this.mCubeBuffers[i].mTarget =  [target1, target2 ], 
        this.mCubeBuffers[i].mLastRenderDone = 0;
        this.mCubeBuffers[i].mResolution[0] = xres;
        this.mCubeBuffers[i].mResolution[1] = yres;
    }
}

Effect.prototype.ResizeBuffer = function( i, xres, yres, skipIfNotExists )
{
    if( skipIfNotExists && this.mBuffers[i].mTexture[0]===null ) return;

    let oldXres = this.mBuffers[i].mResolution[0];
    let oldYres = this.mBuffers[i].mResolution[1];

    if( oldXres !== xres || oldYres !== yres )
    {
        let needCopy = (this.mBuffers[i].mTexture[0]!==null);

        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[0].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[0].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[1].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[1].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target1 = this.mRenderer.CreateRenderTarget( texture1, null, null, null, null, false);
        let target2 = this.mRenderer.CreateRenderTarget( texture2, null, null, null, null, false);

        if( needCopy )
        {
            let v = [0, 0, Math.min(xres, oldXres), Math.min(yres, oldYres)];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            let vOld = [0, 0, oldXres, oldYres];
            this.mRenderer.SetShaderConstant4FV("v", vOld);

            // Copy old buffers 1 to new buffer
            this.mRenderer.SetRenderTarget(target1);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[0], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Copy old buffers 2 to new buffer
            this.mRenderer.SetRenderTarget(target2);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[1], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Deallocate old memory
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[0]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[0]);
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[1]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[1]);
            //this.mRenderer.DestroyTexture(this.mBuffers[i].thumbnailTexture);
        }

        // Store new buffers
        this.mBuffers[i].mTexture = [texture1,texture2], 
        this.mBuffers[i].mTarget =  [target1, target2 ], 
        this.mBuffers[i].mLastRenderDone = 0;
        this.mBuffers[i].mResolution[0] = xres;
        this.mBuffers[i].mResolution[1] = yres;
    }
}

Effect.prototype.saveScreenshot = function(passid)
{
    let pass = this.mPasses[passid];

    if( pass.mType === "buffer" )
    {
        let bufferID = assetID_to_bufferID( this.mPasses[passid].mOutputs[0] );

        let texture = this.mBuffers[bufferID].mTarget[ this.mBuffers[bufferID].mLastRenderDone ];

        let numComponents = 3;
        let width = texture.mTex0.mXres;
        let height = texture.mTex0.mYres;
        let type = "Float"; // Other options Float, Half, Uint
        let bytes = new Float32Array(width * height * 4 );//numComponents);
        this.mRenderer.GetPixelDataRenderTarget( texture, bytes, width, height );
        let blob = piExportToEXR(width, height, numComponents, type, bytes);

        // Offer download automatically to the user
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "cubemap" )
    {
        let xres = 4096;
        let yres = 2048;
        this.mScreenshotSytem.Allocate( xres, yres );

        let cubeBuffer = this.mCubeBuffers[0];

        let target = this.mScreenshotSytem.GetTarget();
        this.mRenderer.SetRenderTarget( target );

        let program = this.mScreenshotSytem.GetProgram();

        this.mRenderer.AttachShader(program);
        let l1 = this.mRenderer.GetAttribLocation(program, "pos");
        this.mRenderer.SetViewport( [0, 0, xres, yres] );
        this.mRenderer.AttachTextures(1, cubeBuffer.mTexture[ cubeBuffer.mLastRenderDone ], null, null, null);
        this.mRenderer.DrawUnitQuad_XY(l1);
        this.mRenderer.DettachTextures();
        this.mRenderer.SetRenderTarget( null );

        let data = new Float32Array(xres*yres*4);
        this.mRenderer.GetPixelDataRenderTarget( target, data, xres, yres );

        let blob = piExportToEXR(xres, yres, 3, "Float", data );
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "sound" )
    {
        let offset = 0;
        const bits = 16;
        const numChannels = 2;
        let words = new Int16Array(60*pass.mSampleRate*numChannels );

        pass.iRenderSound( new Date(), function(off, data, numSamples)
                                         {
                                            for( let i=0; i<numSamples; i++ )
                                            {
                                                words[offset++] = (data[4*i+0]+256.0*data[4*i+1]) - 32767;
                                                words[offset++] = (data[4*i+2]+256.0*data[4*i+3]) - 32767;
                                            }
                                         }
                                     );

        let blob = piExportToWAV( 60*pass.mSampleRate, pass.mSampleRate, bits, numChannels, words);

        piTriggerDownload("sound.wav", blob);
    }    
}

Effect.prototype.ResizeBuffers = function(xres, yres)
{
    for (let i=0; i<this.mMaxBuffers; i++ )
    {
        this.ResizeBuffer(i, xres, yres, true);
    }
}

Effect.prototype.IsEnabledVR = function ()
{
    if (this.mRenderingStereo) return true;
    return false;
}

Effect.prototype.EnableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( this.mRenderingStereo ) return;

    this.mRenderingStereo = true;
    this.mWebVR.Enable();
}

Effect.prototype.DisableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( !this.mRenderingStereo ) return;

    this.mRenderingStereo = false;
    this.mWebVR.Disable();
}

Effect.prototype.GetTexture = function( passid, slot ) { return this.mPasses[passid].GetTexture( slot ); }
Effect.prototype.NewTexture = function (passid, slot, url) { return this.mPasses[passid].NewTexture( this.mAudioContext, slot, url, this.mBuffers, this.mCubeBuffers, this.mKeyboard ); }
Effect.prototype.SetOutputs = function( passid, slot, url ) { this.mPasses[passid].SetOutputs( slot, url ); }
Effect.prototype.SetOutputsByBufferID = function( passid, slot, id ) { this.mPasses[passid].SetOutputsByBufferID( slot, id ); }
Effect.prototype.GetAcceptsLinear = function (passid, slot) { return this.mPasses[passid].GetAcceptsLinear(slot); }
Effect.prototype.GetAcceptsMipmapping = function (passid, slot) { return this.mPasses[passid].GetAcceptsMipmapping(slot); }
Effect.prototype.GetAcceptsWrapRepeat = function (passid, slot) { return this.mPasses[passid].GetAcceptsWrapRepeat(slot); }
Effect.prototype.GetAcceptsVFlip = function (passid, slot) { return this.mPasses[passid].GetAcceptsVFlip(slot); }
Effect.prototype.SetSamplerFilter = function (passid, slot, str) { this.mPasses[passid].SetSamplerFilter(slot, str, this.mBuffers, this.mCubeBuffers); }
Effect.prototype.GetTranslatedShaderSource = function (passid) { return this.mPasses[passid].GetTranslatedShaderSource(); }
Effect.prototype.GetSamplerFilter = function (passid, slot) { return this.mPasses[passid].GetSamplerFilter(slot); }
Effect.prototype.SetSamplerWrap = function (passid, slot, str) { this.mPasses[passid].SetSamplerWrap(slot, str, this.mBuffers); }
Effect.prototype.GetSamplerWrap = function (passid, slot) { return this.mPasses[passid].GetSamplerWrap(slot); }
Effect.prototype.SetSamplerVFlip = function (passid, slot, str) { this.mPasses[passid].SetSamplerVFlip(slot, str); }
Effect.prototype.GetSamplerVFlip = function (passid, slot) { return this.mPasses[passid].GetSamplerVFlip(slot); }

Effect.prototype.GetHeaderSize = function (passid)
{
    return this.mPasses[passid].mHeaderLength + 
           this.mRenderer.GetShaderHeaderLines(1);
}

Effect.prototype.ToggleVolume = function()
{
    this.mForceMuted = !this.mForceMuted;

    // outp
    if (this.mForceMuted)
        this.mGainNode.gain.value = 0.0;
    else
        this.mGainNode.gain.value = 1.0;

    // inp
    let num = this.mPasses.length;
    for( let j=0; j<num; j++ )
    {
        for( let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            if( this.mForceMuted )
                this.mPasses[j].MuteInput( this.mAudioContext, i );
            else
                this.mPasses[j].UnMuteInput( this.mAudioContext, i );
        }
    }

    return this.mForceMuted;
}

Effect.prototype.SetKeyDown = function( passid, k )
{
    if( this.mKeyboard.mData[ k + 0*256 ] == 255 ) return;

    this.mKeyboard.mData[ k + 0*256 ] = 255;
    this.mKeyboard.mData[ k + 1*256 ] = 255;
    this.mKeyboard.mData[ k + 2*256 ] = 255 - this.mKeyboard.mData[ k + 2*256 ];
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }
}

Effect.prototype.SetKeyUp = function( passid, k )
{
    this.mKeyboard.mData[ k + 0*256 ] = 0;
    this.mKeyboard.mData[ k + 1*256 ] = 0;
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }
}

Effect.prototype.StopOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].StopOutput( wa );
    }
}

Effect.prototype.ResumeOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].ResumeOutput( wa );
    }
}

Effect.prototype.PauseInput = function( passid, id )
{
    return this.mPasses[passid].TooglePauseInput( this.mAudioContext, id );
}

Effect.prototype.ToggleMuteInput = function( passid, id )
{
    return this.mPasses[passid].ToggleMuteInput( this.mAudioContext, id );
}

Effect.prototype.RewindInput = function( passid, id )
{
    this.mPasses[passid].RewindInput( this.mAudioContext, id );
}

Effect.prototype.UpdateInputs = function( passid, forceUpdate )
{
   this.mPasses[passid].UpdateInputs( this.mAudioContext, forceUpdate, this.mKeyboard );
}

Effect.prototype.ResetTime = function()
{
    this.mFrame = 0;
    this.mAudioContext.resume()

    let num = this.mPasses.length;
    for( let i=0; i<num; i++ )
    {
        this.mPasses[i].mFrame = 0;
        for( let j=0; j<this.mPasses[i].mInputs.length; j++ )
            this.mPasses[i].RewindInput(this.mAudioContext, j)
    }
}

Effect.prototype.RequestAnimationFrame = function (id)
{
    if (this.mRenderingStereo && this.mWebVR.IsPresenting())
    {
        this.mWebVR.RequestAnimationFrame(id);
    }
    else
    {
        requestAnimFrame(id);
    }
}

Effect.prototype.Paint = function(time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, isPaused)
{
    let wa = this.mAudioContext;
    let da = new Date();
    let vrData = null; if (this.mRenderingStereo) vrData = this.mWebVR.GetData();
    let xres = this.mXres / 1;
    let yres = this.mYres / 1;

    if( this.mFrame===0 )
    {
        for( let i=0; i<this.mMaxBuffers; i++ )
        {
            if( this.mBuffers[i].mTexture[0]!==null )
            {
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[0] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[1] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
				
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[0] );
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[1] );
            }
        }
        for( let i=0; i<this.mMaxCubeBuffers; i++ )
        {
            if( this.mCubeBuffers[i].mTexture[0]!==null )
            {
                for( let face=0; face<6; face++ )
                {
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[0], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[1], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
					this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[0] );
				    this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[1] );
                }
            }
        }
    }

    let num = this.mPasses.length;

    // render sound first
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "sound" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "buffer" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;
        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="buffer" && inp.id === bufferID && inp.mInfo.mSampler.filter === "mipmap")
                {
                    needMipMaps = true;
                    break;
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render cubemap buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "cubemap" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = 0;//assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;

        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="cubemap" )
                {
                    if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0 && inp.mInfo.mSampler.filter === "mipmap" )
                    {
                        needMipMaps = true;
                        break;
                    }
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render image last
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "image" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }   

    // erase keypresses
    for (let k=0; k<256; k++ )
    {
       this.mKeyboard.mData[ k + 1*256 ] = 0;
    }
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    if( this.mRenderingStereo ) this.mWebVR.Finish();

    this.mFrame++;
}

Effect.prototype.NewShader = function( passid, preventCache, onResolve )
{
    let commonSourceCodes = [];
    for (let i=0; i<this.mPasses.length; i++ )
    {
        if( this.mPasses[i].mType==="common")
        {
            commonSourceCodes.push(this.mPasses[i].mSource);
        }
    }

    this.mPasses[passid].NewShader(commonSourceCodes, preventCache, onResolve );
}

Effect.prototype.GetNumPasses = function()
{
    return this.mPasses.length;
}

Effect.prototype.GetNumOfType = function(passtype)
{
    let id = 0;
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType===passtype )
        {
            id++;
        }
    }
    return id;
}

Effect.prototype.GetPassType = function( id ) { return this.mPasses[id].mType; }
Effect.prototype.GetPassName = function( id ) { return this.mPasses[id].mName; }
Effect.prototype.GetCode = function( id ) { return this.mPasses[id].mSource; }
Effect.prototype.SetCode = function( id, source ) { this.mPasses[id].SetCode(source); }
Effect.prototype.GetError = function (id) { return this.mPasses[id].mError; }
Effect.prototype.GetErrorStr = function (id) { return this.mPasses[id].mErrorStr; }
Effect.prototype.GetErrorGlobal = function()
{
    for (let i = 0; i < this.mPasses.length; i++)
    {
        if (this.mPasses[i].mError)
        {
            return true;
        }
    }
    return false;
}

Effect.prototype.Load = function (jobj )
{
    if (jobj.ver !== "0.1")
    {
        console.log("Wrong Format");
        return false;
    }

    let numPasses = jobj.renderpass.length;

    if( numPasses<1 || numPasses>this.mMaxPasses )
    {
        console.log("Corrupted Shader - " + numPasses);
        return false;
    }

    this.mPasses = [];
    for (let j = 0; j < numPasses; j++)
    {
        let rpass = jobj.renderpass[j];

        // skip sound passes if in thumbnail mode
        if( this.mForceMuted && rpass.type === "sound" ) continue;

        let wpass = new EffectPass(this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                   this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode,
                                   this.mProgramDownscale, j, this);

        wpass.Create(rpass.type, this.mAudioContext);

        let numInputs = rpass.inputs.length;

        for (let i = 0; i < 4; i++)
        {
            wpass.NewTexture(this.mAudioContext, i, null, null, null);
        }
        for (let i = 0; i < numInputs; i++)
        {
            let lid  = rpass.inputs[i].channel;
            let styp = rpass.inputs[i].type;
            let sid  = rpass.inputs[i].id;
            let ssrc = rpass.inputs[i].filepath;
            let psrc = rpass.inputs[i].previewfilepath;
            let samp = rpass.inputs[i].sampler;

            wpass.NewTexture(this.mAudioContext, lid, { mType: styp, mID: sid, mSrc: ssrc, mSampler: samp, mPreviewSrc: psrc }, this.mBuffers, this.mCubeBuffers, this.mKeyboard);
        }

        for (let i = 0; i < 4; i++)
        {
            wpass.SetOutputs(i, null);
        }

        let numOutputs = rpass.outputs.length;
        for (let i = 0; i < numOutputs; i++)
        {
            let outputID = rpass.outputs[i].id;
            let outputCH = rpass.outputs[i].channel;
            wpass.SetOutputs(outputCH, outputID);
        }

        // create some hardcoded names. This should come from the DB
        let rpassName = "";
        if (rpass.type === "common" ) rpassName = "Common";
        if (rpass.type === "sound"  ) rpassName = "Sound";
        if (rpass.type === "image"  ) rpassName = "Image";
        if (rpass.type === "buffer") rpassName = "Buffer " + String.fromCharCode(65 + assetID_to_bufferID(wpass.mOutputs[0]));
        if (rpass.type === "cubemap") rpassName = "Cube A";// " + String.fromCharCode(65 + assetID_to_bufferID(this.mPasses[j].mOutputs[0]));
        wpass.SetName(rpassName);
        wpass.SetCode(rpass.code);

        this.mPasses.push(wpass);
    }
    return true;
}

Effect.prototype.CompileSome = function ( passes, preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    for (let j = 0; j < passes.length; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(passes[j], preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < me.mPasses.length; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.Compile = function (preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(j, preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < numPasses; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.GetCompilationTime = function( id )
{
    return this.mPasses[id].GetCompilationTime()/1000.0;
}
Effect.prototype.GetTotalCompilationTime = function()
{
    return this.mCompilationTime/1000.0;
}

Effect.prototype.DestroyPass = function( id )
{
   this.mPasses[id].Destroy( this.mAudioContext );
   this.mPasses.splice(id, 1);
}

Effect.prototype.AddPass = function( passType, passName, onResolve )
{
    let shaderStr = null;

    if( passType==="sound"   ) shaderStr = "vec2 mainSound( int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n}";
    if( passType==="buffer"  ) shaderStr = "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}";
    if( passType==="common"  ) shaderStr = "vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}";
    if( passType==="cubemap" ) shaderStr = "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rayDir;\n\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}";

    let id = this.GetNumPasses();
    this.mPasses[id] = new EffectPass( this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                       this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode, 
                                       this.mProgramDownscale, id, this );

    this.mPasses[id].Create( passType, this.mAudioContext );
    this.mPasses[id].SetName( passName );
    this.mPasses[id].SetCode( shaderStr );
    this.NewShader(id, false, function ()
    {
        onResolve();
    });

    return { mId : id, mShader : shaderStr };
}

// this should be removed once we have MultiPass 2.0 and passes render to arbitrary buffers
Effect.prototype.IsBufferPassUsed = function( bufferID )
{
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType !== "buffer" ) continue;
        if( this.mPasses[j].mOutputs[0] === bufferID_to_assetID(bufferID) ) return true;
    }
    return false;
}

Effect.prototype.Save = function()
{
    var result = {};

    result.ver = "0.1";

    result.renderpass = [];

    let numPasses = this.mPasses.length;
    for (let j=0; j<numPasses; j++ )
    {
        result.renderpass[j] = {};

        result.renderpass[j].outputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            let outputID = this.mPasses[j].mOutputs[i];
            if( outputID===null ) continue;
            result.renderpass[j].outputs.push( { channel: i, id: outputID } );
        }
        result.renderpass[j].inputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            if( this.mPasses[j].mInputs[i]===null ) continue;
            result.renderpass[j].inputs.push( {channel: i,
                                               type    : this.mPasses[j].mInputs[i].mInfo.mType,
                                               id      : this.mPasses[j].mInputs[i].mInfo.mID,
                                               filepath: this.mPasses[j].mInputs[i].mInfo.mSrc,
                                               sampler : this.mPasses[j].mInputs[i].mInfo.mSampler });
        }

        result.renderpass[j].code = this.mPasses[j].mSource;
        result.renderpass[j].name = this.mPasses[j].mName
        result.renderpass[j].description = "";
        result.renderpass[j].type = this.mPasses[j].mType;
    }

    result.flags = this.calcFlags();

    return result;
}

Effect.prototype.calcFlags = function ()
{
    let flagVR = false;
    let flagWebcam = false;
    let flagSoundInput = false;
    let flagSoundOutput = false;
    let flagKeyboard = false;
    let flagMultipass = false;
    let flagMusicStream = false;

    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        let pass = this.mPasses[j];

        if (pass.mType === "sound") flagSoundOutput = true;
        if (pass.mType === "buffer") flagMultipass = true;

        for (let i = 0; i < 4; i++)
        {
            if (pass.mInputs[i] === null) continue;

            if (pass.mInputs[i].mInfo.mType === "webcam") flagWebcam = true;
            else if (pass.mInputs[i].mInfo.mType === "keyboard") flagKeyboard = true;
            else if (pass.mInputs[i].mInfo.mType === "mic") flagSoundInput = true;
            else if (pass.mInputs[i].mInfo.mType === "musicstream") flagMusicStream = true;
        }

        let n1 = pass.mSource.indexOf("mainVR(");
        let n2 = pass.mSource.indexOf("mainVR (");
        if (n1 > 0 || n2 > 0) flagVR = true;
    }

    return {
        mFlagVR: flagVR,
        mFlagWebcam: flagWebcam,
        mFlagSoundInput: flagSoundInput,
        mFlagSoundOutput: flagSoundOutput,
        mFlagKeyboard: flagKeyboard,
        mFlagMultipass: flagMultipass,
        mFlagMusicStream: flagMusicStream
    };
}</script>
    <script>"use strict"

const kMaxCompileTime = 10.0;

function iReportCrash(shaderID)
{
    let req = new XMLHttpRequest();
    req.onload = function ()
    {
        let jsn = req.response;
        if (jsn === null) return;
        if (jsn.result === 0)
        {
            // yep
        }
    };
    req.open("POST", "/shadertoy", true);
    req.responseType = "json";
    req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    req.send( "s=" + shaderID + "&r=2" );
}
</script>
    <script>"use strict"

var gActive = -1;
var mShaders = [];
var gNumCanvases = 0;

function myrefresh( id, slot, img, forceFrame, gui, guiID, renderID, time )
{
    if( mShaders[id].mReady===false ) return;
    if( forceFrame )
    {
        if (mShaders[id].mScreenshot === false)
        {
            mShaders[id].gEffect.Paint(mShaders[id].mTime / 1000.0, 1.0 / 60.0, 60.0, 0, 0, 0, 0, false);
        }
    }
}

function startRendering()
{
    if( gActive<0 ) return;
    if( mShaders[gActive].mReady===false ) return;
    if( mShaders[gActive].mScreenshot===true ) return;

    let time = getRealTime();

    mShaders[gActive].mFPS.Count( time );
    mShaders[gActive].mTime = mShaders[gActive].mTime0 + (time - mShaders[gActive].mTo);
    let dtime = 1000.0/60.0;
    mShaders[gActive].gEffect.Paint( mShaders[gActive].mTime/1000.0, dtime/1000.0, mShaders[gActive].mFPS.GetFPS(), 0,0,0,0, false);

    requestAnimFrame( startRendering );
}

function iLoadAndCompile(jsn, i )
{
    var shaderObj = jsn[i];
    if (shaderObj === null) return;

    var resizeCB = function (xres, yres) { myrefresh(i, 0, null, true, false, 0, -1.0) };
    var crashCB = function () { alert('crash');/*iReportCrash(gShaderIDs[i])*/ };
    mShaders[i].gEffect = new Effect(null, null, mShaders[i].mPreview.mCanvas, myrefresh, i, true, true, resizeCB, crashCB);

    if (!mShaders[i].gEffect.Load(shaderObj)) return;

    mShaders[i].gEffect.Compile(false, function (worked)
    {
        if (worked === true)
        {
            previewShowRender(mShaders[i].mPreview);

            mShaders[i].mScreenshot = false;
            mShaders[i].mReady = true;
            mShaders[i].mTime = 10.0 * 1000.0;
            mShaders[i].mTime0 = 0.0;
            mShaders[i].mTo = 0.0;
            mShaders[i].mFPS = piCreateFPSCounter();
            mShaders[i].mPreview.mCanvas.addEventListener("mouseout", function (ev) { gActive = -1; }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseover", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.add('isVisible'); }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseout", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.remove('isVisible'); }, true);
            mShaders[i].mPreview.mCanvas.addEventListener("mouseover", function (ev)
            {
                let ele = piGetSourceElement(ev);
                if (ele.mId === undefined) return;

                gActive = ele.mId;
                if (!mShaders[gActive].mReady) return;
                let time = getRealTime();
                mShaders[gActive].mTo = time;
                mShaders[gActive].mTime0 = mShaders[gActive].mTime;
                mShaders[gActive].mFPS.Reset(time);

                startRendering();
            }, true);


            /*
            let compilationTime = mShaders[i].gEffect.GetTotalCompilationTime();
            if (compilationTime > kMaxCompileTime)
            {
                iReportCrash(mShaders[i].mShaderID);
            }*/

            myrefresh(i, null, null, true, false, 0, -1.0);
        }
        else
        {
            mShaders[i].mReady = false;
            previewShowError(mShaders[i].mPreview);
        }
    });
};


function iProcessShader( jsn, i )
{
    var shaderObj = jsn[i];
    if( shaderObj===null ) return;

    if ((shaderObj.info.usePreview === 0 && !gUseScreenshots) || (mShaders[i].mPreviewReady !== 1))
    {
        iLoadAndCompile(jsn, i);
    }
    else
    {
        mShaders[i].mScreenshot = true;
        if( shaderObj.info.usePreview === 1 )
            previewShowScreenshot(mShaders[i].mPreview, 1); // comp
        else if (gUseScreenshots)
            previewShowScreenshot(mShaders[i].mPreview, 2); // sett
    }

    if( i<(jsn.length-1) ) setTimeout( function(){iProcessShader(jsn,i+1);}, 10 );
}

function iInitUI(numCanvases, uiCallback, windowTitle)
{
    gNumCanvases = numCanvases;
    document.getElementById("mySearch").focus();

    //-----------------------------------------------------------------
    // window
    //-----------------------------------------------------------------
    if (windowTitle !== null) {
        document.title = windowTitle;
    }

    //-----------------------------------------------------------------
    // ui
    //-----------------------------------------------------------------
    var num = Math.min(gShaders.length, gNumCanvases);

    //var base = document.getElementsByClassName( "searchResult" );

    for (let i = 0; i < gNumCanvases; i++)
    {
        let pv = createPreview(i);

        if (i >= num) {
            previewHide(pv);
            continue;
        }

        let shaderID = gShaders[i].info.id;
        
        if (pv.mUI !== null && uiCallback !== null) {
            pv.mUI.addEventListener('click', function (ev) {
                uiCallback(shaderID);
                ev.preventDefault();
            }, false);
        }
        
        previewShowLoading(pv);
        
        mShaders[i] = {};
        mShaders[i].mShaderID = shaderID;
        mShaders[i].mPreview = pv;
        mShaders[i].mScreenshot = false;
        mShaders[i].mPreview.mLink.href = "/view/" + shaderID;
        mShaders[i].mPreviewReady = 0;
        mShaders[i].mReady = false;
        mShaders[i].gEffect = null;

        previewLoadScreenshot(mShaders[i].mPreview,
            function () { mShaders[i].mPreviewReady = 1; if (mShaders[i].mReady === false) previewShowScreenshot(mShaders[i].mPreview, 0); },
            function () { mShaders[i].mPreviewReady = 2; },
            shaderID);
    }

    if (num <= 0) {
        return;
    }
}

function iInitShaders(jsn)
{
    for (let i = 0; i < jsn.length; i++)
    {
        let shaderObj = jsn[i];
        if (shaderObj === null) continue;
        let inf = shaderObj.info;
        mShaders[i].mPreview.mTextA.textContent = inf.name;
        mShaders[i].mPreview.mTextB.innerHTML = "<a class='user' href='/user/" + htmlEntities(inf.username) + "'>" + htmlEntities(inf.username) + "</a>";
        mShaders[i].mPreview.mTextC.innerHTML = "<img src='/img/themes/" + gThemeName + "/views.png' class='viewsIcon'></img>" + inf.viewed + "    &nbsp;&nbsp;  <img src='/img/themes/" + gThemeName + "/likes.png' class='likesIcon'></img>" + inf.likes;
    }

    setTimeout(function () { iProcessShader(jsn, 0); }, 10);
}

function resultsInitStatic(numCanvases, uiCallback, windowTitle)
{
    iInitUI(numCanvases, uiCallback, windowTitle);

    iInitShaders(gShaders);
}

function resultsInit(numCanvases, uiCallback, windowTitle)
{	
    iInitUI(numCanvases, uiCallback, windowTitle);

    var num = Math.min(gShaderIDs.length, gNumCanvases);

    var mHttpReq = new XMLHttpRequest();

    mHttpReq.abort();

    var str = "{ \"shaders\" : [";
    for( let i=0; i<num; i++ )
    {
         str += "\"" + gShaderIDs[i] + "\"";
         if( i!==(num-1) ) str += ", ";
    }
    str += "] }";

    str = "s=" + encodeURIComponent( str ) + "&nt=0&nl=0&np=0";

    mHttpReq.open( "POST", "/shadertoy", true );
    mHttpReq.responseType = "json";
    mHttpReq.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    mHttpReq.onload = function ()
    {
        let jsn = this.response;
        if( jsn===null )
        {
            console.log( "Could not load shaders" );
            return;
        }

        iInitShaders(jsn);
    }
    mHttpReq.send( str );
}</script>
    <style>
    .shaderPreview
    {
    display: block;
    background-color: #000000;
    background-image: url("/img/loading.gif");
    background-repeat: no-repeat;
    background-position: center;
    padding: 0px;
    margin: 0px;
    border: 0px solid #000000;
    border-radius: 8px;
    width:100%;
    height:100%;
    position: absolute;
    overflow:hidden;
    }

    .previewInfo
    {
    width: 100%;
    left: 0px;
    top: 2px;
    position: relative;
    visibility: hidden;
    }

    .previewCanvas
    {
    left: 0px;
    top: 0px;
    padding: 0px;
    margin: 0px;
    position: absolute;
    cursor: pointer;
    width:100%;
    height:100%;
    border-radius: 8px;
    border: 0px solid #000000;
    backgroundColor: transparent;
visibility: hidden;
opacity:0;
transition: opacity 1.0s ease;
    }

    .previewText
    {
        text-overflow: ellipsis;
    white-space: nowrap;
    padding-right: 1px;
    }

    .previewTextUser
    {
    text-overflow: ellipsis;
    white-space: nowrap;
    padding-left: 3px;
    }

    .previewStats
    {
    padding-right: 1px;
    right: 0px;
    top: 0px;
    position: absolute;
    }

    .previewErrorContainer
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    visibility:hidden;
    }

    .previewErrorMessage
    {
    top:50%;
    position:absolute;
    width:100%;
    text-align:center;
    padding:0;
    margin:auto;
    color:#ff0000;
    font-size:2em;
    font-style:italic;
    }

    .previewNoGLContainter
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    position:absolute;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    pointer-events:none;
    visibility:hidden;
    font-size:2em;
    }

    .previewNoGLMessage
    {
    width:86%;
    height:90%;
    padding-left:7%;
    padding-right:7%;
    padding-top:10%;
    padding-bottom:0px;
    color:#ff0000;
    position:absolute;
    visibility:hidden;
    }

    .previewThumbnailContainer
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    visibility:hidden;
    border-radius:8px;
    border:0px solid #000000;
    }

    .previewThumbnailImage
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    border-radius:8px;
    border:0px solid #000000;
opacity: 0.0;
transition: opacity 1.0s ease;
    }

    .previewThumbnailIcon
    {
    width:64px;
    height:32px;
    left:0px;
    top:0px;
    padding:0px;
    padding-top:12px;
    margin:0px;
    position:absolute;
    color:#ffffff;
    background-color:#ff8020;
    font-weight:bold;
    border-radius:0px 0px 8px 0px;
    text-align:center;
    //visibility:hidden;
    }


    .previewUIContainter
    {
    display: block;
    right:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    //cursor:pointer;
    //pointer-events:none;
    //visibility:hidden;
    }
</style>

<script>
    function previewHide(me)
    {
    me.mBase.style.visibility = "hidden";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";
    }

    function previewShowRender(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "visible";
me.mCanvas.style.opacity = 1.0;
    me.mCanvas.style.borderRadius ="8px;";
//  me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    }

    function previewShowScreenshot(me, message)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "visible";
me.mThumbnailImg.style.opacity = 1.0;
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    me.mThumbnailWar1.style.visibility = (message===1)?"visible":"hidden";
    me.mThumbnailWar2.style.visibility = (message===2)?"visible":"hidden";
    }

    function previewShowLoading(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";

    me.mLink.style.visibility = "visible";
    me.mBase.style.backgroundColor = "#ff0000;"
    me.mCont.style.visibility = "visible";
    }

    function previewShowNoWebGL(me, shaderID)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "visible";
    me.mError.style.visibility = "visible";
    me.mThumbnailImgNoWebGL.onerror = function(ev) 
                                      { 
                                            me.mThumbnailImgNoWebGL.style.visibility="hidden"; 
                                            me.mMessageNoWebGL.style.visibility="visible"; 
                                      };
    me.mThumbnailImgNoWebGL.src = "/media/shaders/" + shaderID + ".jpg";
    }

    function previewShowError(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "visible";
    me.mCont.style.visibility = "visible";
    }

    function previewLoadScreenshot( me, cbSuccess, cbError, shaderID )
    {
    var url = "/media/shaders/" + shaderID + ".jpg";
    me.mThumbnailImg.onload = cbSuccess;
    me.mThumbnailImg.onerror = function(ev) { cbError(); };
    me.mThumbnailImg.src = url;
    }
        
    function createPreview(id)
    {
        var bar = document.getElementById( "Preview_"+id+"_Canvas" );
        bar.width = bar.offsetWidth;
        bar.height = bar.offsetHeight;
        bar.mId = id;

        return { mBase: document.getElementById( "Preview_"+id+"_Container" ),
        mLink: document.getElementById( "Preview_"+id+"_Link" ),
        mCanvas: bar,
        mCont: document.getElementById( "Preview_"+id+"_Info" ),
        mTextA: document.getElementById( "Preview_"+id+"_Text" ),
        mTextB: document.getElementById( "Preview_"+id+"_TextUser" ),
        mTextC: document.getElementById( "Preview_"+id+"_Stats" ),
        mNoWebGL: document.getElementById( "Preview_"+id+"_NoWebGL" ),
        mError: document.getElementById( "Preview_"+id+"_Error" ),
        mCanvas2D: document.getElementById( "Preview_"+id+"_Thumnail" ),
        mThumbnailImg: document.getElementById( "Preview_"+id+"_ThumnailImage" ),
        mThumbnailWar1: document.getElementById( "Preview_"+id+"_ThumnailWarning1" ),
        mThumbnailWar2: document.getElementById( "Preview_"+id+"_ThumnailWarning2" ),
        mThumbnailImgNoWebGL: document.getElementById( "Preview_"+id+"_ThumnailImageNoWebGL" ),
        mMessageNoWebGL: document.getElementById( "Preview_"+id+"_MessageNoWebGL"),
        mUI: document.getElementById( "Preview_"+id+"_UI" )
        };
    }
</script>

    <style>

    div#shaderGrid
    {
        width:100%;
        padding:0px;
        margin:0px;
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        grid-template-rows: repeat(3, 1fr);
        grid-column-gap: 64px;
        grid-row-gap: 24px;
    }
    .searchResult
    {
        margin: 0px;
        padding: 0px;
        width: 100%;
    }
    .searchResultContainer
    {
        width: 100%;
        padding-bottom:56.25%;
        height: 0;
        position: relative;
    }
    .navigation
    {
        display:flex;
        align-items:center;
    }
    div#navBottom
    {
        display:none;
        justify-content:center;
    }
    a.pageButtons, .pageButtonsCurrent
    {
        border-style: solid;
        border-width: 1px;
        border-color: #808080;
        text-align: center;
        vertical-align: middle;
        margin-left: 12px;
        display: inline-block;
        border-radius: 4px;
		font-weight:bold;
        cursor: pointer;
        padding-bottom:5px;
        padding-top:4px;
        padding-left: 8px;
        padding-right: 8px;
        margin:8px;
    }
    a.pageButtons
    {
        text-decoration: none;
        -moz-transition:    background-color 0.15s linear, color 0.15s linear;
        -webkit-transition: background-color 0.15s linear, color 0.15s linear;
        transition:         background-color 0.15s linear, color 0.15s linear;
    }
    a.pageButtons:hover
    {
      background-color:#808080;
      color : #ff8020;
    }
    .pageButtonsCurrent
    {
        background-color: #808080;
        color:#000000;
    }
    div#controls
    {
        width:100%;
        padding-top:16px;
        padding-bottom:16px;
        display:flex;
        justify-content:space-between; 
        flex-wrap:wrap;
    }
    div#controls > div
    {
        display:inline-flex;
    }
    .controlOptions
    {
        display:inline-block;
    }

    /* ----------------------- media resolutions ------------------------ */

    @media screen and (max-width:799px) 
    {
        div#shaderGrid  { grid-template-columns: 1fr; grid-template-rows: repeat(12, 1fr); grid-column-gap: 0px; grid-row-gap: 16px; }
        div#controls
        {
            width:100%;
            display:flex;
            justify-content:flex-start; 
            flex-wrap:wrap;
        }
        div#controls > div
        {
            display:inline-flex;
            width:100%;
            margin-left: 0px;
            margin-right: 0px;
            padding-bottom:16px;
        }
        div#navBottom
        {
            display: flex;
        }
    }
    
    </style>
    <script>
    var gShaders=[{"ver":"0.1","info":{"id":"XlcXDX","date":"1481796789","viewed":18154,"name":"Vinyl Visualizer","username":"s23b","description":"inspired by the logo of [url=https:\/\/www.facebook.com\/thehostelSG\/]a bar[\/url]\n\nmusic by [url=https:\/\/www.youtube.com\/channel\/UC_hXu1_lUOqWZUzk2Ps2Y1w]Fleece[\/url]","likes":57,"published":3,"flags":64,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4s23DD","filepath":"https:\/\/soundcloud.com\/fleecemusic\/rise","previewfilepath":"https:\/\/soundcloud.com\/fleecemusic\/rise","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BARS 12.\n\n#define PI 3.14159265359\n\n\/\/ rotation transform\nvoid tRotate(inout vec2 p, float angel) {\n    float s = sin(angel), c = cos(angel);\n\tp *= mat2(c, -s, s, c);\n}\n\n\/\/ circle distance\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\n\/\/ union\nfloat opU(float a, float b) {\n    return min(a, b);\n}\n\n\/\/ substraction\nfloat opS(float a, float b) {\n    return max(a, -b);\n}\n\n\/\/ distance function of half of an ark\n\/\/ parameters: inner radius, outer radius, angle\nfloat sdArk(vec2 p, float ir, float or, float a) {\n    \n    \/\/ add outer circle\n    float d = sdCircle(p, or);\n        \n    \/\/ substract inner circle\n    d = opS(d, sdCircle(p, ir));\n    \n    \/\/ rotate with angle\n    tRotate(p, -a * PI \/ 2.);\n    \n    \/\/ clip the top\n    d = opS(d, -p.y);\n    \n    \/\/ add circle to the top\n    d = opU(d, sdCircle(p - vec2((or + ir) \/ 2., 0.), (or - ir) \/ 2.));\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy * 2. - 1.;\n    \n    \/\/ I wanted it to look good on my phone vertically :P\n    if (iResolution.x > iResolution.y) uv.x *= iResolution.x \/ iResolution.y; else uv.y *= iResolution.y \/ iResolution.x;\n    \n    \/\/ little white padding\n    uv *= 1.05;\n    \n    \/\/ add circles\n    float d = sdCircle(uv, 1.);\n    d = opS(d, sdCircle(uv, .34));\n    d = opU(d, sdCircle(uv, .04));\n    \n    \/\/ calculate position of the bars\n    float barsStart = .37;\n    float barsEnd = .94;\n    float barId = floor((length(uv) -barsStart) \/ (barsEnd - barsStart) * BARS);\n    \n    \/\/ only go forward if we're in a bar\n    if (barId >= 0. && barId < BARS) {\n        \n        float barWidth = (barsEnd - barsStart) \/ BARS;\n        float barStart = barsStart + barWidth * (barId + .25);\n        float barAngel = texture(iChannel0, vec2(1. - barId \/ BARS, .25)).x * .5;\n\n        \/\/ add a little rotation to completely ruin the beautiful symmetry\n        tRotate(uv, -barAngel * .2 * sin(barId + iTime));\n        \n        \/\/ mirror everything\n    \tuv = abs(uv);\n        \n        \/\/ add the bars\n        d = opS(d, sdArk(uv, barStart, barStart + barWidth \/ 2., barAngel));\n    }\n    \n    \/\/ use the slope to render the distance with antialiasing\n    float w = min(fwidth(d), .01);\n\tfragColor = vec4(vec3(smoothstep(-w, w, d)),1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4dsGD7","date":"1372228953","viewed":18133,"name":"The Inversion Machine","username":"Kali","description":"My \"Inversion Machine\" shader now with synthesized sound","likes":235,"published":1,"flags":8,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[],"code":"\/\/ \"The Inversion Machine\" by Kali\r\n\r\nconst float width=.22;\r\nconst float scale=4.;\r\nconst float detail=.002;\r\n\r\nvec3 lightdir=-vec3(.2,.5,1.);\r\n\r\nmat2 rot;\r\n\r\nfloat rand(vec2 co){\r\n\treturn fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\r\n}\r\n\r\nfloat de(vec3 p) {\r\n\tfloat t=iTime;\r\n\tfloat dotp=dot(p,p);\r\n\tp.x+=sin(t*40.)*.007;\r\n\tp=p\/dotp*scale;\r\n\tp=sin(p+vec3(sin(1.+t)*2.,-t,-t*2.));\r\n\tfloat d=length(p.yz)-width;\r\n\td=min(d,length(p.xz)-width);\r\n\td=min(d,length(p.xy)-width);\r\n\td=min(d,length(p*p*p)-width*.3);\r\n\treturn d*dotp\/scale;\r\n}\r\n\r\nvec3 normal(vec3 p) {\r\n\tvec3 e = vec3(0.0,detail,0.0);\r\n\t\r\n\treturn normalize(vec3(\r\n\t\t\tde(p+e.yxx)-de(p-e.yxx),\r\n\t\t\tde(p+e.xyx)-de(p-e.xyx),\r\n\t\t\tde(p+e.xxy)-de(p-e.xxy)\r\n\t\t\t)\r\n\t\t);\t\r\n}\r\n\r\nfloat light(in vec3 p, in vec3 dir) {\r\n\tvec3 ldir=normalize(lightdir);\r\n\tvec3 n=normal(p);\r\n\tfloat sh=1.;\r\n\tfloat diff=max(0.,dot(ldir,-n))+.1*max(0.,dot(normalize(dir),-n));\r\n\tvec3 r = reflect(ldir,n);\r\n\tfloat spec=max(0.,dot(dir,-r))*sh;\r\n\treturn diff+pow(spec,20.)*.7;\t\r\n\t\t}\r\n\r\nfloat raymarch(in vec3 from, in vec3 dir, in vec2 fragCoord) \r\n{\r\n\tvec2 uv = fragCoord.xy \/ iResolution.xy*2.-1.;\r\n\tuv.y*=iResolution.y\/iResolution.x;\r\n\tfloat st,d,col,totdist=st=0.;\r\n\tvec3 p;\r\n\tfloat ra=rand(uv.xy*iTime)-.5;\r\n\tfloat ras=max(0.,sign(-.5+rand(vec2(1.3456,.3573)*floor(30.+iTime*20.))));\r\n\tfloat rab=rand(vec2(1.2439,2.3453)*floor(10.+iTime*40.))*ras;\r\n\tfloat rac=rand(vec2(1.1347,1.0331)*floor(40.+iTime));\r\n\tfloat ral=rand(1.+floor(uv.yy*300.)*iTime)-.5;\r\n\tfor (int i=0; i<60; i++) {\r\n\t\tp=from+totdist*dir;\r\n\t\td=de(p);\r\n\t\tif (d<detail || totdist>2.) break;\r\n\t\ttotdist+=d; \r\n\t\tst+=max(0.,.04-d);\r\n\t}\r\n\tvec2 li=uv*rot;\r\n\tfloat backg=.45*pow(1.5-min(1.,length(li+vec2(0.,-.6))),1.5);\r\n\tif (d<detail) {\r\n\t\tcol=light(p-detail*dir, dir); \r\n\t} else { \r\n\t\tcol=backg;\r\n\t}\r\n\tcol+=smoothstep(0.,1.,st)*.8*(.1+rab);\r\n\tcol+=pow(max(0.,1.-length(p)),8.)*(.5+10.*rab);\r\n\tcol+=pow(max(0.,1.-length(p)),30.)*50.;\r\n\tcol = mix(col, backg, 1.0-exp(-.25*pow(totdist,3.)));\r\n\tif (rac>.7) col=col*.7+(.3+ra+ral*.5)*mod(uv.y+iTime*2.,.25);\r\n\tcol = mix(col, .5+ra+ral*.5, max(0.,3.-iTime)\/3.);\r\n\treturn col+ra*.03+(ral*.1+ra*.1)*rab;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfloat t=iTime*.2;\r\n\tvec2 uv = fragCoord.xy \/ iResolution.xy*2.-1.;\r\n\tuv.y*=iResolution.y\/iResolution.x;\r\n\tvec3 from=vec3(0.,0.1,-1.2);\r\n\tvec3 dir=normalize(vec3(uv,1.));\r\n\trot=mat2(cos(t),sin(t),-sin(t),cos(t));\r\n\tdir.xy=dir.xy*rot;\r\n\tfloat col=raymarch(from,dir,fragCoord); \r\n\tcol=pow(col,1.25)*clamp(60.-iTime,0.,1.);\r\n\tfragColor = vec4(col);\r\n}\r\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float rand(vec2 co){\n\treturn fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvec2 mainSound( in int samp,float time)\n{\n\tfloat ti=time;\n    vec2 s=vec2(0.);\n    float t=mod(time,10.)-5.;\n    float tb=mod(time,.3);\n\tfloat x=t*.1;\n\t\/\/fractal sound\n    for (int i=0;i<23;i++) {\n    \tx=1.3\/abs(x)-1.; \t   \n    }\n    s+=x*2.;\n\t\/\/noise\n\tti*=5.;\n    s+=vec2(rand(vec2(ti,1234.258-ti*2.568))*sin(time*100.),0.)*4.;\n\tti*=2.;\n    s+=vec2(0.,rand(vec2(ti,1234.258-time*2.568))*sin(time*100.))*4.;\n\tti*=.02;\n    \/\/pulse\n\ts*=.2;\n\ttb-=x*.0003;\n    s+=vec2(sin(time),cos(time))*sin(tb*tb*4000.)*exp(-15.*tb)*20.;\n\ts+=(1.-mod(time*(2000.+sin(t*t)*100.)+x*.2,2.))*.7;\n    \/\/starting noise\n\ts*=clamp(time*.2,0.,1.);\n    s=mix(s,vec2(rand(vec2(ti*1.5,1234.258-ti*2.568))-.3)*10.,clamp(1.-time*.5,0.,1.));\n    return vec2(s)*.5*clamp(60.-time,0.,1.);\n}","name":"Sound","description":"","type":"sound"}]},{"ver":"0.1","info":{"id":"lty3Rt","date":"1476125205","viewed":18130,"name":"Pegasus Galaxy","username":"frankenburgh","description":"Galaxy shader from Pegasus 4k Intro\n4kb executable: http:\/\/www.pouet.net\/prod.php?which=65859\nhttps:\/\/www.youtube.com\/watch?v=3pXhImWoNsw","likes":230,"published":1,"flags":64,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"ldB3Rm","filepath":"https:\/\/soundcloud.com\/virgill\/4k-galaxy-pegasus-soundtrack","previewfilepath":"https:\/\/soundcloud.com\/virgill\/4k-galaxy-pegasus-soundtrack","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Galaxy shader\n\/\/\n\/\/ Created by Frank Hugenroth  \/frankenburgh\/   07\/2015\n\/\/ Released at nordlicht\/bremen 2015\n\n#define SCREEN_EFFECT 0\n\n\/\/ random\/hash function              \nfloat hash( float n )\n{\n  return fract(cos(n)*41415.92653);\n}\n\n\/\/ 2d noise function\nfloat noise( in vec2 x )\n{\n  vec2 p  = floor(x);\n  vec2 f  = smoothstep(0.0, 1.0, fract(x));\n  float n = p.x + p.y*57.0;\n\n  return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n}\n\nfloat noise( in vec3 x )\n{\n  vec3 p  = floor(x);\n  vec3 f  = smoothstep(0.0, 1.0, fract(x));\n  float n = p.x + p.y*57.0 + 113.0*p.z;\n\n  return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n    mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\nmat3 m = mat3( 0.00,  1.60,  1.20, -1.60,  0.72, -0.96, -1.20, -0.96,  1.28 );\n\n\/\/ Fractional Brownian motion\nfloat fbmslow( vec3 p )\n{\n  float f = 0.5000*noise( p ); p = m*p*1.2;\n  f += 0.2500*noise( p ); p = m*p*1.3;\n  f += 0.1666*noise( p ); p = m*p*1.4;\n  f += 0.0834*noise( p ); p = m*p*1.84;\n  return f;\n}\n\nfloat fbm( vec3 p )\n{\n  float f = 0., a = 1., s=0.;\n  f += a*noise( p ); p = m*p*1.149; s += a; a *= .75;\n  f += a*noise( p ); p = m*p*1.41; s += a; a *= .75;\n  f += a*noise( p ); p = m*p*1.51; s += a; a *= .65;\n  f += a*noise( p ); p = m*p*1.21; s += a; a *= .35;\n  f += a*noise( p ); p = m*p*1.41; s += a; a *= .75;\n  f += a*noise( p ); \n  return f\/s;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime * 0.1;\n\n\tvec2 xy = -1.0 + 2.0*fragCoord.xy \/ iResolution.xy;\n\n\t\/\/ fade in (1=10sec), out after 8=80sec;\n\tfloat fade = min(1., time*1.)*min(1.,max(0., 15.-time));\n\t\/\/ start glow after 5=50sec\n\tfloat fade2= max(0., time-10.)*0.37;\n\tfloat glow = max(-.25,1.+pow(fade2, 10.) - 0.001*pow(fade2, 25.));\n\t\n\t\n\t\/\/ get camera position and view direction\n\tvec3 campos = vec3(500.0, 850., -.0-cos((time-1.4)\/2.)*2000.); \/\/ moving\n\tvec3 camtar = vec3(0., 0., 0.);\n\t\n\tfloat roll = 0.34;\n\tvec3 cw = normalize(camtar-campos);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n\tvec3 rd = normalize( xy.x*cu + xy.y*cv + 1.6*cw );\n\n\tvec3 light   = normalize( vec3(  0., 0.,  0. )-campos );\n\tfloat sundot = clamp(dot(light,rd),0.0,1.0);\n\n\t\/\/ render sky\n\n    \/\/ galaxy center glow\n    vec3 col = glow*1.2*min(vec3(1.0, 1.0, 1.0), vec3(2.0,1.0,0.5)*pow( sundot, 100.0 ));\n    \/\/ moon haze\n    col += 0.3*vec3(0.8,0.9,1.2)*pow( sundot, 8.0 );\n\n\t\/\/ stars\n\tvec3 stars = 85.5*vec3(pow(fbmslow(rd.xyz*312.0), 7.0))*vec3(pow(fbmslow(rd.zxy*440.3), 8.0));\n\t\n\t\/\/ moving background fog\n    vec3 cpos = 1500.*rd + vec3(831.0-time*30., 321.0, 1000.0);\n    col += vec3(0.4, 0.5, 1.0) * ((fbmslow( cpos*0.0035 ) - .5));\n\n\tcpos += vec3(831.0-time*33., 321.0, 999.);\n    col += vec3(0.6, 0.3, 0.6) * 10.0*pow((fbmslow( cpos*0.0045 )), 10.0);\n\n\tcpos += vec3(3831.0-time*39., 221.0, 999.0);\n    col += 0.03*vec3(0.6, 0.0, 0.0) * 10.0*pow((fbmslow( cpos*0.0145 )), 2.0);\n\n\t\/\/ stars\n\tcpos = 1500.*rd + vec3(831.0, 321.0, 999.);\n\tcol += stars*fbm(cpos*0.0021);\n\t\n\t\n\t\/\/ Clouds\n    vec2 shift = vec2( time*100.0, time*180.0 );\n    vec4 sum = vec4(0,0,0,0); \n    float c = campos.y \/ rd.y; \/\/ cloud height\n    vec3 cpos2 = campos - c*rd;\n    float radius = length(cpos2.xz)\/1000.0;\n\n    if (radius<1.8)\n    {\n  \t  for (int q=10; q>-10; q--) \/\/ layers\n      {\n\t\tif (sum.w>0.999) continue;\n        float c = (float(q)*8.-campos.y) \/ rd.y; \/\/ cloud height\n        vec3 cpos = campos + c*rd;\n\n   \t\tfloat see = dot(normalize(cpos), normalize(campos));\n\t\tvec3 lightUnvis = vec3(.0,.0,.0 );\n\t\tvec3 lightVis   = vec3(1.3,1.2,1.2 );\n\t\tvec3 shine = mix(lightVis, lightUnvis, smoothstep(0.0, 1.0, see));\n\n\t\t\/\/ border\n \t    float radius = length(cpos.xz)\/999.;\n\t    if (radius>1.0)\n\t      continue;\n\n\t\tfloat rot = 3.00*(radius)-time;\n      \tcpos.xz = cpos.xz*mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n \t\n\t\tcpos += vec3(831.0+shift.x, 321.0+float(q)*mix(250.0, 50.0, radius)-shift.x*0.2, 1330.0+shift.y); \/\/ cloud position\n\t\tcpos *= mix(0.0025, 0.0028, radius); \/\/ zoom\n      \tfloat alpha = smoothstep(0.50, 1.0, fbm( cpos )); \/\/ fractal cloud density\n\t  \talpha *= 1.3*pow(smoothstep(1.0, 0.0, radius), 0.3); \/\/ fade out disc at edges\n\t  \tvec3 dustcolor = mix(vec3( 2.0, 1.3, 1.0 ), vec3( 0.1,0.2,0.3 ), pow(radius, .5));\n      \tvec3 localcolor = mix(dustcolor, shine, alpha); \/\/ density color white->gray\n\t\t  \n\t\tfloat gstar = 2.*pow(noise( cpos*21.40 ), 22.0);\n\t\tfloat gstar2= 3.*pow(noise( cpos*26.55 ), 34.0);\n\t\tfloat gholes= 1.*pow(noise( cpos*11.55 ), 14.0);\n\t\tlocalcolor += vec3(1.0, 0.6, 0.3)*gstar;\n\t\tlocalcolor += vec3(1.0, 1.0, 0.7)*gstar2;\n\t\tlocalcolor -= gholes;\n\t\t  \n        alpha = (1.0-sum.w)*alpha; \/\/ alpha\/density saturation (the more a cloud layer\\\\\\'s density, the more the higher layers will be hidden)\n        sum += vec4(localcolor*alpha, alpha); \/\/ sum up weightened color\n\t  }\n\t\t\n  \t  for (int q=0; q<20; q++) \/\/ 120 layers\n      {\n\t\tif (sum.w>0.999) continue;\n        float c = (float(q)*4.-campos.y) \/ rd.y; \/\/ cloud height\n        vec3 cpos = campos + c*rd;\n\n   \t\tfloat see = dot(normalize(cpos), normalize(campos));\n\t\tvec3 lightUnvis = vec3(.0,.0,.0 );\n\t\tvec3 lightVis   = vec3(1.3,1.2,1.2 );\n\t\tvec3 shine = mix(lightVis, lightUnvis, smoothstep(0.0, 1.0, see));\n\n\t\t\/\/ border\n \t    float radius = length(cpos.xz)\/200.0;\n\t    if (radius>1.0)\n\t      continue;\n\n\t\tfloat rot = 3.2*(radius)-time*1.1;\n      \tcpos.xz = cpos.xz*mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n \t\n\t\tcpos += vec3(831.0+shift.x, 321.0+float(q)*mix(250.0, 50.0, radius)-shift.x*0.2, 1330.0+shift.y); \/\/ cloud position\n      \tfloat alpha = 0.1+smoothstep(0.6, 1.0, fbm( cpos )); \/\/ fractal cloud density\n\t  \talpha *= 1.2*(pow(smoothstep(1.0, 0.0, radius), 0.72) - pow(smoothstep(1.0, 0.0, radius*1.875), 0.2)); \/\/ fade out disc at edges\n      \tvec3 localcolor = vec3(0.0, 0.0, 0.0); \/\/ density color white->gray\n  \n        alpha = (1.0-sum.w)*alpha; \/\/ alpha\/density saturation (the more a cloud layer\\\\\\'s density, the more the higher layers will be hidden)\n        sum += vec4(localcolor*alpha, alpha); \/\/ sum up weightened color\n\t  }\n    }\n\tfloat alpha = smoothstep(1.-radius*.5, 1.0, sum.w);\n    sum.rgb \/= sum.w+0.0001;\n    sum.rgb -= 0.2*vec3(0.8, 0.75, 0.7) * pow(sundot,10.0)*alpha;\n    sum.rgb += min(glow, 10.0)*0.2*vec3(1.2, 1.2, 1.2) * pow(sundot,5.0)*(1.0-alpha);\n\n   \tcol = mix( col, sum.rgb , sum.w);\/\/*pow(sundot,10.0) );\n\n    \/\/ haze\n\tcol = fade*mix(col, vec3(0.3,0.5,.9), 29.0*(pow( sundot, 50.0 )-pow( sundot, 60.0 ))\/(2.+9.*abs(rd.y)));\n\n#if SCREEN_EFFECT == 1\n    if (time<2.5)\n    {\n    \t\/\/ screen effect\n    \tfloat c = (col.r+col.g+col.b)* .3 * (.6+.3*cos(gl_FragCoord.y*1.2543)) + .1*(noise((xy+time*2.)*294.)*noise((xy-time*3.)*321.));\n   \t    c += max(0.,.08*sin(10.*time+xy.y*7.2543));\n        \/\/ flicker\n\t\tcol = vec3(c, c, c) * (1.-0.5*pow(noise(vec2(time*99., 0.)), 9.));\n    }\n    else\n    {\n        \/\/ bam\n        float c = clamp(1.-(time-2.5)*6., 0., 1. );\n        col = mix(col, vec3(1.,1.,1.),c);\n    }\n#endif\n    \n    \/\/ Vignetting\n\tvec2 xy2 = gl_FragCoord.xy \/ iResolution.xy;\n\tcol *= vec3(.5, .5, .5) + 0.25*pow(100.0*xy2.x*xy2.y*(1.0-xy2.x)*(1.0-xy2.y), .5 );\t\n\n\tfragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"XsBSRV","date":"1413586923","viewed":18063,"name":"On\/Off Spikes","username":"movAX13h","description":"My first rm shader with shadow pass. No AA. Mouse enabled. \nThank you srtuss for support. Thank you morgan3d for the nebula function.","likes":110,"published":3,"flags":0,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ On\/Off Spikes, fragment shader by movAX13h, oct 2014\n\n#define HARD_SHADOW\n#define GLOW\n#define EDGES\n#define NUM_TENTACLES 6\n#define BUMPS\n#define NUM_BUMPS 8\n#define BACKGROUND\n#define SUN_POS vec3(15.0, 15.0, -15.0)\n\/\/#define SUN_SPHERE\n\n#define SPHERE_COL vec3(0.6, 0.3, 0.1)\n#define MOUTH_COL vec3(0.9, 0.6, 0.1)\n#define TENTACLE_COL vec3(0.06)\n\n#define GAMMA 2.2\n\n\/\/---\n#define resolution iResolution\n#define mouse iMouse\n#define pi2 6.283185307179586476925286766559\n#define pih 1.5707963267949\n\n\/\/ Using the nebula function of the \"Star map shader\" by morgan3d \n\/\/ as environment map and light sphere texture (https:\/\/www.shadertoy.com\/view\/4sBXzG)\nconst float pi= 3.1415927;const int NUM_OCTAVES = 4;float hash(float n) { return fract(sin(n) * 1e4); } float hash(vec2 p){return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 +p.x))));}float noise(float x) { float i = floor(x);float f = fract(x); float u = f * f * (3.0 - 2.0 * f);return mix(hash(i),hash(i+1.0),u);}float noise(vec2 x){vec2 i=floor(x);vec2 f=fract(x);\tfloat a = hash(i); float b=hash(i + vec2(1.0,0.0));float c=hash(i+vec2(0.0, 1.0)); float d = hash(i + vec2(1.0, 1.0)); vec2 u = f * f * (3.0 - 2.0 * f); return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y; }float NOISE(vec2 x){ float v = 0.0; float a = 0.5; vec2 shift=vec2(100);mat2 rot=mat2(cos(0.5),sin(0.5), -sin(0.5), cos(0.50)); for (int i = 0; i < NUM_OCTAVES;++i) {v+=a*noise(x);x = rot* x * 2.0 + shift; a *= 0.5; } return v; }float square(float x) { return x * x;}mat3 rotation(float yaw, float pitch){return mat3(cos(yaw),0,-sin(yaw), 0, 1, 0, sin(yaw), 0, cos(yaw)) * mat3(1, 0, 0, 0, cos(pitch), sin(pitch), 0, -sin(pitch), cos(pitch)); }vec3 nebula(vec3 dir) { float purple = abs(dir.x); float yellow = noise(dir.y);vec3 streakyHue = vec3(purple + yellow, yellow * 0.7, purple);vec3 puffyHue = vec3(0.8, 0.1, 1.0);float streaky = min(1.0, 8.0 * pow(NOISE(dir.yz*square(dir.x) * 13.0+ dir.xy * square(dir.z) * 7.0 + vec2(150.0, 2.0)),10.0));float puffy=square(NOISE(dir.xz * 4.0 + vec2(30, 10)) * dir.y);\nreturn pow(clamp(puffyHue * puffy * (1.0 - streaky) + streaky * streakyHue, 0.0, 1.0), vec3(1.0\/2.2));}\n\/\/ ---\n\nfloat sdBox( vec3 p, vec3 b ) \n{\t\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n\treturn length(p)-r;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xy),p.z)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec2 rotate(vec2 p, float a)\n{\n\tvec2 r;\n\tr.x = p.x*cos(a) - p.y*sin(a);\n\tr.y = p.x*sin(a) + p.y*cos(a);\n\treturn r;\n}\n\n\/\/ polynomial smooth min (k = 0.1); by iq\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5+0.5*(b-a)\/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\n\/\/ globals\nfloat glow, bite;\nvec3 sphere_col;\nvec3 sun = normalize(SUN_POS);\nfloat focus = 5.0;\nfloat far = 23.0;\n\nstruct Hit\n{\n\tfloat d;\n\tvec3 color;\n\tfloat edge;\n};\n\nHit scene(vec3 p)\n{\n\tfloat d, d1, d2, d3, f, e = 0.15;\n\t\n\tvec3 q = p;\n\tq.xy = rotate(q.xy, 1.5);\n\t\n\t\/\/ center sphere\n\td1 = sdSphere(q, 0.3);\n\td = d1; \n    vec3 col = sphere_col; \n    \n\t\/\/ tentacles\n\tfloat r = length(q);\n\tfloat a = atan(q.z, q.x);\n\ta += 0.4*sin(r-iTime);\n\t\n\tq = vec3(a*float(NUM_TENTACLES)\/pi2,q.y,length(q.xz)); \/\/ circular domain\n\tq = vec3(mod(q.x,1.0)-0.5*1.0,q.y,q.z); \/\/ repetition\n\t\n\td3 = sdCappedCylinder(q-vec3(0.0,0.0,0.9+bite), vec2(0.1-(r-bite)\/18.0,0.8));\n\td2 = min(d3, sdBox(q-vec3(0.0, 0.0, 0.1+bite), vec3(0.2, 0.2, 0.2))); \/\/ close box\n\td2 = smin(d2, sdBox(q-vec3(0.0, 0.0, 0.4+bite), vec3(0.2, 0.05, 0.4)), 0.1); \/\/ wide box\n\t\n    f = smoothstep(0.11, 0.28, d2-d1);\n\tcol = mix(MOUTH_COL, col, f);\n\te = mix(e, 0.0, f);\n\td = smin(d1, d2, 0.24);\n    \n\tcol = mix(TENTACLE_COL, col, smoothstep(0., 0.48, d3-d));\n\t\n    #ifdef SUN_SPHERE\n\td = min(d, sdSphere(p-sun, 0.1));\n    #endif\n    \n\t#ifdef BUMPS\n\tfor(int i = 0; i < NUM_BUMPS; i++)\n\t{\n        d2 = float(i);\n        d1 = sdSphere(p-0.18*smoothstep(0.1, 1.0, glow)*\n                      vec3(sin(4.0*iTime+d2*0.6), sin(5.3*iTime+d2*1.4), cos(5.8*iTime+d2*0.6)),\n                      0.03);\n\t\t\n\t\td = smin(d1, d, 0.2);\n\t\t\/\/d = min(d1, d);\n\t}\n\t#endif\n\t\n\t#ifdef BACKGROUND\n\tq = p;\n\tq.yz = mod(q.yz, 1.0);\n\tq -= vec3(-.6, 0.5, 0.5);\n\td1 = sdBox(q, vec3(0.1, 0.48, 0.48));\n\tif (d1 < d) { d = d1; col = vec3(0.1); }\n\t#endif\n\t\n\treturn Hit(d, col, e);\n}\n\nvec3 normal(vec3 p)\n{\n\tfloat c = scene(p).d;\n\tvec2 h = vec2(0.01, 0.0);\n\treturn normalize(vec3(scene(p + h.xyy).d - c, \n\t\t\t\t\t\t  scene(p + h.yxy).d - c, \n\t\t                  scene(p + h.yyx).d - c));\n}\n\nfloat edges(vec3 p) \/\/ by srtuss\n{\n\tfloat acc = 0.0;\n\tfloat h = 0.01;\n\tacc += scene(p + vec3(-h, -h, -h)).d;\n\tacc += scene(p + vec3(-h, -h, +h)).d;\n\tacc += scene(p + vec3(-h, +h, -h)).d;\n\tacc += scene(p + vec3(-h, +h, +h)).d;\n\tacc += scene(p + vec3(+h, -h, -h)).d;\n\tacc += scene(p + vec3(+h, -h, +h)).d;\n\tacc += scene(p + vec3(+h, +h, -h)).d;\n\tacc += scene(p + vec3(+h, +h, +h)).d;\n\treturn acc \/ h;\n}\n\nvec3 colorize(Hit hit, vec3 n, vec3 dir, const in vec3 lightPos)\n{\n\tfloat diffuse = 0.3*max(0.0, dot(n, lightPos));\n\t\n\tvec3 ref = normalize(reflect(dir, n));\n\tfloat specular = 0.4*pow(max(0.0, dot(ref, lightPos)), 6.5);\n\n\treturn (hit.color.rgb + \n\t\t\tdiffuse * vec3(0.9) +\n\t\t\tspecular * vec3(1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    \/\/time = iTime;\n    glow = max(0.0, min(1.0, 2.0*sin(iTime*0.7-5.0)));\n    bite = smoothstep(0.0, 1.0, 1.6*sin(iTime*0.7));\n    sphere_col = SPHERE_COL*glow;\n\n    \n    vec2 pos = (fragCoord.xy*2.0 - resolution.xy) \/ resolution.y;\n\t\n\tfloat d = clamp(1.5*sin(0.3*iTime), 0.5, 1.0);\n\tvec3 cp = vec3(10.0*d, -2.3*d, -6.2*d+4.0*clamp(2.0*sin(iTime*0.5), 0.0, 1.0)); \/\/ anim curious spectator\n\t\n\tif (mouse.z > 0.5)\n\t{\n\t\tvec2 mrel = mouse.xy\/resolution.xy-0.5;\n\t\tfloat mdis = (8.0+6.0*mrel.y);\n\t\tcp = vec3(mdis*cos(-mrel.x*pih), 4.0*mrel.y, mdis*sin(-mrel.x*pih));\n\t}\n\t\n    vec3 ct = vec3(0.0, 0.0, 0.0);\n   \tvec3 cd = normalize(ct-cp);\n    vec3 cu  = vec3(0.0, 1.0, 0.0);\n    vec3 cs = cross(cd, cu);\n    vec3 dir = normalize(cs*pos.x + cu*pos.y + cd*focus);\t\n\t\n    Hit h;\n\tvec3 col = vec3(0.16);\n\tvec3 ray = cp;\n\tfloat dist = 0.0;\n\t\n\t\/\/ raymarch scene\n    for(int i=0; i < 60; i++) \n\t{\n        h = scene(ray);\n\t\t\n\t\tif(h.d < 0.0001) break;\n\t\t\n\t\tdist += h.d;\n\t\tray += dir * h.d * 0.9;\n\n        if(dist > far) \n\t\t{ \n\t\t\tdist = far; \n\t\t\tbreak; \n\t\t}\n    }\n\n\tfloat m = (1.0 - dist\/far);\n\tvec3 n = normal(ray);\n\tcol = colorize(h, n, dir, sun)*m;\n\n    #ifdef EDGES\n\tfloat edge = edges(ray);\n\tcol = mix(col, vec3(0.0), h.edge*edge*smoothstep(0.3, 0.35, length(ray)));\n    #endif\n    \n\tvec3 neb = nebula(n);\n\tcol += min(glow, 0.1)*neb.brg;\n\t\n\t\/\/ HARD SHADOW with low number of rm iterations (from obj to sun)\n\t#ifdef HARD_SHADOW\n\tvec3 ray1 = ray;\n\tdir = normalize(SUN_POS - ray1);\n\tray1 += n*0.002;\n\t\n\tfloat sunDist = length(SUN_POS-ray1);\n\tdist = 0.0;\n\t\n\tfor(int i=0; i < 35; i++) \n\t{\n\t\th = scene(ray1 + dir*dist);\n\t\tdist += h.d;\n\t\tif (abs(h.d) < 0.001) break;\n\t}\n\n\tcol -= 0.24*smoothstep(0.5, -0.3, min(dist, sunDist)\/max(0.0001,sunDist));\n\t#endif\n\t\n\t\/\/ ILLUMINATION & free shadow with low number of rm iterations (from obj to sphere)\n\t#ifdef GLOW\n\tdir = normalize(-ray);\n\tray += n*0.002;\n\t\n\tfloat sphereDist = max(0.0001, length(ray)-0.3);\n\tdist = 0.0;\n\t\n\tfor(int i=0; i < 35; i++) \n\t{\n\t\th = scene(ray + dir*dist);\n\t\tdist += h.d;\n\t\tif (abs(h.d) < 0.001) break;\n\t}\n\t\n\tvec3 neb1 = nebula(dir*rotation(0.0, iTime*0.4)).brg;\n    \n\tcol += (0.7*sphere_col+glow*neb1)*(0.6*(smoothstep(3.0, 0.0, sphereDist))*min(dist, sphereDist)\/sphereDist + \n\t\t   0.6*smoothstep(0.1, 0.0, sphereDist));\n\t#endif\n    \n\tcol -= 0.2*smoothstep(0.6,3.7,length(pos));\n\tcol = clamp(col, vec3(0.0), vec3(1.0));\n\tcol = pow(col, vec3(2.2, 2.4, 2.5)) * 3.9;\n\tcol = pow(col, vec3(1.0 \/ GAMMA));\n    \n\tfragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4sjXzG","date":"1413297020","viewed":18024,"name":"Terrain Tubes","username":"iq","description":"Testing some super cheap cosine-based noise, and some random ideas on tubes.","likes":153,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"\/media\/a\/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"\/media\/ap\/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"\/media\/a\/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"\/media\/ap\/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Copyright Inigo Quilez, 2014 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work neither\n\/\/ as it is or altered, here on Shadertoy or anywhere else, in any\n\/\/ form including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it or train a neural\n\/\/ network with it without permission. I share this Work for educational\n\/\/ purposes, and you can link to it, through an URL, proper attribution\n\/\/ and unmodified screenshot, as part of your educational material. If\n\/\/ these conditions are too restrictive please contact me and we'll\n\/\/ definitely work it out.\n\n#define USE_BOUND_PLANE\n\n\nconst mat2 m2 = mat2(1.6,-1.2,1.2,1.6);\n\nfloat noi( in vec2 p )\n{\n    return 0.5*(cos(6.2831*p.x) + cos(6.2831*p.y));\n}\n\nfloat terrainLow( vec2 p )\n{\n    p *= 0.0013;\n\n    float s = 1.0;\n\tfloat t = 0.0;\n\tfor( int i=0; i<2; i++ )\n\t{\n        t += s*noi( p );\n\t\ts *= 0.5 + 0.1*t;\n        p = 0.97*m2*p + (t-0.5)*0.2;\n\t}\n\treturn t*55.0;\n}\n\nfloat terrainMed( vec2 p )\n{\n    p *= 0.0013;\n\n    float s = 1.0;\n\tfloat t = 0.0;\n\tfor( int i=0; i<6; i++ )\n\t{\n        t += s*noi( p );\n\t\ts *= 0.5 + 0.1*t;\n        p = 0.97*m2*p + (t-0.5)*0.2;\n\t}\n            \n    return t*55.0;\n}\n\nfloat terrainHigh( vec2 p )\n{\n    vec2 q = p;\n    p *= 0.0013;\n\n    float s = 1.0;\n\tfloat t = 0.0;\n\tfor( int i=0; i<7; i++ )\n\t{\n        t += s*noi( p );\n\t\ts *= 0.5 + 0.1*t;\n        p = 0.97*m2*p + (t-0.5)*0.2;\n\t}\n    \n    t +=   0.05*textureLod( iChannel0, 0.001*q, 0.0 ).x;\n    t +=   0.03*textureLod( iChannel0, 0.005*q, 0.0 ).x;\n    t += t*0.03*textureLod( iChannel0, 0.020*q, 0.0 ).x;\n\n\treturn t*55.0;\n}\n\nfloat tubes( vec3 pos, float time )\n{\n    float sep = 400.0;\n\n    pos.z -= sep*0.025*noi( 0.005*pos.xz*vec2(0.5,1.5) );\n    pos.x -= sep*0.050*noi( 0.005*pos.zy*vec2(0.5,1.5) );\n    \n    vec3 qos = mod( pos + sep*0.5, sep ) - sep*0.5; \n    qos.y = pos.y - 70.0;\n    qos.x += sep*0.3*cos( 0.01*pos.z);\n    qos.y += sep*0.1*cos( 0.01*pos.x );\n\n    float sph = length( qos.xy ) - sep*0.012;\n\n    sph -= (1.0-0.8*smoothstep(-10.0,0.0,qos.y))*sep*0.003*noi( 0.15*pos.xy*vec2(0.2,1.0) );\n\n    return sph;\n}\n\n\nfloat tubesH( vec3 pos, float time )\n{\n    float t = tubes( pos, time );\n\n    t += 1.0*texture( iChannel3, 0.01*pos.yz ).x;\n    t += 2.0*texture( iChannel0, 0.005*pos.xy ).x;\n\n    return t;\n}\n\nvec2 map( in vec3 pos, float time )\n{\n    float m = 0.0;\n\tfloat h = pos.y - terrainMed(pos.xz);\n\n    float sph = tubes( pos, time );\n    float k = 60.0;\n    float w = clamp( 0.5 + 0.5*(h-sph)\/k, 0.0, 1.0 );\n    h = mix( h, sph, w ) - k*w*(1.0-w);\n    m = mix( m, 1.0, w ) - 1.0*w*(1.0-w);\n    m = clamp(m,0.0,1.0);\n\n    return vec2( h, m );\n}\n\nfloat mapH( in vec3 pos, in float time )\n{\n    float y = terrainHigh(pos.xz);\n        \n    float h = pos.y - y;\n    \n    float sph = tubesH( pos, time );\n    float k = 60.0;\n    float w = clamp( 0.5 + 0.5*(h-sph)\/k, 0.0, 1.0 );\n    h = mix( h, sph, w ) - k*w*(1.0-w);\n\n    return h;\n}\n\nvec2 interesct( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float time )\n{\n    float t = tmin;\n    float  m = 0.0;\n\tfor( int i=0; i<160; i++ )\n\t{\n        vec3 pos = ro + t*rd;\n        vec2 res = map( pos, time );\n        m = res.y;\n        if( res.x<(0.001*t) || t>tmax  ) break;\n        t += res.x * 0.5;\n\t}\n\n\treturn vec2( t, m );\n}\n\nfloat calcShadow(in vec3 ro, in vec3 rd )\n{\n\tvec2  eps = vec2(150.0,0.0);\n    float h1 = terrainMed( ro.xz );\n    float h2 = terrainLow( ro.xz );\n    \n    float d1 = 10.0;\n    float d2 = 80.0;\n    float d3 = 200.0;\n    float s1 = clamp( 1.0*(h1 + rd.y*d1 - terrainMed(ro.xz + d1*rd.xz)), 0.0, 1.0 );\n    float s2 = clamp( 0.5*(h1 + rd.y*d2 - terrainMed(ro.xz + d2*rd.xz)), 0.0, 1.0 );\n    float s3 = clamp( 0.2*(h2 + rd.y*d3 - terrainLow(ro.xz + d3*rd.xz)), 0.0, 1.0 );\n\n    return min(min(s1,s2),s3);\n}\n\nvec3 calcNormalHigh( in vec3 pos, float t, in float time )\n{\n    vec2 e = vec2(1.0,-1.0)*0.001*t;\n\n    return normalize( e.xyy*mapH( pos + e.xyy, time ) + \n\t\t\t\t\t  e.yyx*mapH( pos + e.yyx, time ) + \n\t\t\t\t\t  e.yxy*mapH( pos + e.yxy, time ) + \n\t\t\t\t\t  e.xxx*mapH( pos + e.xxx, time ) );\n}\n\n\nvec3 calcNormalMed( in vec3 pos, float t )\n{\n\tfloat e = 0.005*t;\n    vec2  eps = vec2(e,0.0);\n    float h = terrainMed( pos.xz );\n    return normalize(vec3( terrainMed(pos.xz-eps.xy)-h, e, terrainMed(pos.xz-eps.yx)-h ));\n}\n\nvec3 camPath( float time )\n{\n    vec2 p = 1100.0*vec2( cos(0.0+0.23*time), cos(1.5+0.205*time) );\n\treturn vec3( p.x, 0.0, p.y );\n}\n\nvec3 dome( in vec3 rd, in vec3 light1 )\n{\n\tfloat sda = clamp(0.5 + 0.5*dot(rd,light1),0.0,1.0);\n    float cho = max(rd.y,0.0);\n    \n    vec3 bgcol = mix( mix(vec3(0.00,0.40,0.60)*0.7, \n                          vec3(0.80,0.70,0.20),                        pow(1.0-cho,3.0 + 4.0-4.0*sda)), \n                          vec3(0.43+0.2*sda,0.4-0.1*sda,0.4-0.25*sda), pow(1.0-cho,10.0+ 8.0-8.0*sda) );\n    bgcol *= 0.8 + 0.2*sda;\n    return bgcol*0.75;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3  cw = normalize(ta-ro);\n\tvec3  cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3  cu = normalize( cross(cw,cp) );\n\tvec3  cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = -1.0 + 2.0*fragCoord.xy\/iResolution.xy;\n    vec2 sp = xy*vec2(iResolution.x\/iResolution.y,1.0);\n\n    \/\/--------------------------\n\n    \/\/ animate    \n    float camid = floor((0.0+iTime-0.0)\/9.0);\n    float time = 16.5 + (0.0+iTime-0.0)*0.1 + 20.0*iMouse.x\/iResolution.x + 72.1*camid + 19.0*max(0.0,camid-1.0);\n\n    \/\/ camera    \n\tfloat cr = 0.18*sin(-0.1*time);\n\tvec3  ro = camPath( time + 0.0 );\n\tvec3  ta = camPath( time + 3.0 );\n    ro.y = terrainLow( ro.xz ) + 60.0 + 30.0*sin(1.0*(time-14.4));\n\tta.y = ro.y - 200.0;\n    \/\/ camera to world transformation\n    mat3 cam = setCamera( ro, ta, cr );\n    \n    \/\/ light      \n    vec3 light1 = normalize( vec3(-0.8,0.2,0.5) );\n    \n    \/\/--------------------------\n    \n    \/\/ generate ray\n    vec3 rd = cam * normalize(vec3(sp.xy,1.5));\n        \n    \/\/ background    \n    vec3 bgcol = dome( rd, light1 );\n    \n    \/\/ raymarch\n    float tmin = 10.0;\n    float tmax = 4500.0;\n    \n#ifdef USE_BOUND_PLANE\n    \/\/ intersect boundg plane\n    float maxh = 130.0;\n    float tp = (maxh-ro.y)\/rd.y;\n    if( tp>0.0 )\n    {\n        if( ro.y>maxh ) tmin = max( tmin, tp );\n        else            tmax = min( tmax, tp );\n    }\n#endif\n    \n\tfloat sundotc = clamp( dot(rd,light1), 0.0, 1.0 );\n    vec3  col = bgcol;\n    \n    vec2 res = interesct( ro, rd, tmin, tmax, time );\n    if( res.x>tmax )\n    {\n        \/\/ sky\t\t\n\t\tcol += 0.2*0.12*vec3(1.0,0.5,0.1)*pow( sundotc,5.0 );\n\t\tcol += 0.2*0.12*vec3(1.0,0.6,0.1)*pow( sundotc,64.0 );\n\t\tcol += 0.2*0.12*vec3(2.0,0.4,0.1)*pow( sundotc,512.0 );\n\n        \/\/ clouds\n  \t\tvec2 sc = ro.xz + rd.xz*(1000.0-ro.y)\/rd.y;\n\t\tcol = mix( col, 0.25*vec3(0.5,0.9,1.0), 0.4*smoothstep(0.0,1.0,texture(iChannel0,0.000005*sc).x) );\n\n        \/\/ sun scatter\n        col += 0.2*0.2*vec3(1.5,0.7,0.4)*pow( sundotc, 4.0 );\n    }\n\telse\n\t{\n        \/\/ mountains\t\t\n        float t = res.x;\n\t\tvec3 pos = ro + t*rd;\n        vec3 nor = calcNormalHigh( pos, t, time );\n        vec3 sor = calcNormalMed( pos, t );\n        vec3 ref = reflect( rd, nor );\n\n        \/\/ rock\n        col = vec3(0.07,0.06,0.05);\n        col *= 0.2 + sqrt( texture( iChannel0, 0.01*pos.xy*vec2(0.5,1.0) ).x *\n                           texture( iChannel0, 0.01*pos.zy*vec2(0.5,1.0) ).x );\n        vec3 col2 = vec3(1.0,0.2,0.1)*0.01;\n        col = mix( col, col2, 0.5*res.y );\n        \n        \/\/ grass\n        float s = smoothstep(0.6,0.7,nor.y - 0.01*(pos.y-20.0));        \n        s *= smoothstep( 0.15,0.2,0.01*nor.x+texture(iChannel0, 0.001*pos.zx).x);\n        vec3 gcol = 0.13*vec3(0.22,0.23,0.04);\n        gcol *= 0.3+texture( iChannel1, 0.03*pos.xz ).x*1.4;\n        col = mix( col, gcol, s );\n        \/\/col *= texture( iChannel0, 0.3*pos.xz ).x*3.2;\n        nor = mix( nor, sor, 0.3*s );\n        vec3 ptnor = nor;\n\n        \/\/ trees\n        s = smoothstep(0.9,0.95,nor.y - 0.01*(pos.y-20.0));        \n        s *= smoothstep( 0.1,0.13,-0.17+texture(iChannel0, 0.001*pos.zx).x);\n        vec3 tor = -1.0 + 2.0*texture( iChannel1, 0.015*pos.xz ).xyz;\n        tor.y = 1.5;\n        tor = normalize(tor);\n        col = mix( col, 0.11*vec3(0.22,0.25,0.02)*1.0, s );\n        nor = mix( nor, tor, 0.7*s );\n        \n\t\t\/\/ snow\n        s = ptnor.y + 0.008*pos.y - 0.2 + 0.2*(texture(iChannel1,0.00015*pos.xz+0.0*sor.y).x-0.5);\n        float sf = fwidth(s) * 1.5;\n        s = smoothstep(0.84-sf, 0.84+sf, s );\n        col = mix( col, 0.15*vec3(0.42,0.6,0.8), s);\n        nor = mix( nor, sor, 0.5*smoothstep(0.9, 0.95, s ) );\n\n        \/\/ lighting\t\t\n        float amb = clamp( nor.y,0.0,1.0);\n\t\tfloat dif = clamp( dot( light1, nor ), 0.0, 1.0 );\n\t\tfloat bac = clamp( dot( normalize( vec3(-light1.x, 0.0, light1.z ) ), nor ), 0.0, 1.0 );\n\t\tfloat sha = mix( calcShadow( pos, light1 ), 1.0, res.y );\n        float spe = pow( clamp( dot(ref,light1), 0.0, 1.0 ), 4.0 ) * dif;\n\t\t\n\t\tvec3 lin  = vec3(0.0);\n        lin += dif*vec3(11.0,6.00,3.00)*vec3( sha, sha*sha*0.5+0.5*sha, sha*sha*0.8+0.2*sha );\n\t\tlin += amb*vec3(0.25,0.30,0.40);\n        lin += bac*vec3(0.35,0.40,0.50);\n        lin += spe*vec3(4.00,4.00,4.00)*res.y;\n        \n        col *= lin;\n\n        \/\/ fog\n        col = mix( col, 0.25*mix(vec3(0.4,0.75,1.0),vec3(0.3,0.3,0.3), sundotc*sundotc), 1.0-exp(-0.0000008*t*t) );\n\n        \/\/ sun scatter\n        col += 0.15*vec3(1.0,0.8,0.3)*pow( sundotc, 8.0 )*(1.0-exp(-0.003*t));\n\n        \/\/ background\n        col = mix( col, bgcol, 1.0-exp(-0.00000004*t*t) );\n    }\n    \n    \/\/ gamma\n\tcol = pow( col, vec3(0.45) );\n \n    \/\/ color grading    \n    col = col*1.4*vec3(1.0,1.0,1.02) + vec3(0.0,0.0,0.11);\n    col = clamp(col,0.0,1.0);\n    col = col*col*(3.0-2.0*col);\n    col = mix( col, vec3(dot(col,vec3(0.333))), 0.25 );\n    \n    \/\/ vignetting\t\n \tcol *= 0.5 + 0.5*pow( (xy.x+1.0)*(xy.y+1.0)*(xy.x-1.0)*(xy.y-1.0), 0.1 );\n \n    \/\/ camera fade\n    col *= smoothstep( 0.0, 0.1, 2.0*abs(fract(0.5+iTime\/9.0)-0.5) );\n   \n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"XdcGWS","date":"1452730410","viewed":17970,"name":"Shader Rally","username":"P_Malin","description":"Physics Hackery using the new mutipass things.\nWASD to drive. Space = brake\nClick mouse to orbit camera\nG toggle gravity\nV toggle wheels (vehicle forces)\n. and , flip car","likes":228,"published":3,"flags":49,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Shader Rally - @P_Malin\n\n\/\/ (Uncomment FAST_VERSION in \"Buf C\" for a framerate boost)\n\n\/\/ Physics Hackery using the new mutipass things.\n\n\/\/ WASD to drive. Space = brake\n\/\/ G toggle gravity\n\/\/ V toggle wheels (vehicle forces)\n\/\/ . and , flip car\n\n\/\/ Restart shader to reset car\n\n\/\/ I'll add more soon (including a fast version of the rendering code maybe :)\n\n\/\/ Image shader - final postprocessing\n\n#define MOTION_BLUR_TAPS 32\n\nivec2 addrVehicle = ivec2( 0.0, 0.0 );\n\nivec2 offsetVehicleParam0 = ivec2( 0.0, 0.0 );\n\nivec2 offsetVehicleBody = ivec2( 1.0, 0.0 );\nivec2 offsetBodyPos = ivec2( 0.0, 0.0 );\nivec2 offsetBodyRot = ivec2( 1.0, 0.0 );\nivec2 offsetBodyMom = ivec2( 2.0, 0.0 );\nivec2 offsetBodyAngMom = ivec2( 3.0, 0.0 );\n\nivec2 offsetVehicleWheel0 = ivec2( 5.0, 0.0 );\nivec2 offsetVehicleWheel1 = ivec2( 7.0, 0.0 );\nivec2 offsetVehicleWheel2 = ivec2( 9.0, 0.0 );\nivec2 offsetVehicleWheel3 = ivec2( 11.0, 0.0 );\n\nivec2 offsetWheelState = ivec2( 0.0, 0.0 );\nivec2 offsetWheelContactState = ivec2( 1.0, 0.0 );\n\n\nivec2 addrCamera = ivec2( 0.0, 1.0 );\nivec2 offsetCameraPos = ivec2( 0.0, 0.0 );\nivec2 offsetCameraTarget = ivec2( 1.0, 0.0 );\n\nivec2 addrPrevCamera = ivec2( 0.0, 2.0 );\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Storage\n\nvec4 LoadVec4( in ivec2 vAddr )\n{\n    return texelFetch( iChannel0, vAddr, 0 );\n}\n\nvec3 LoadVec3( in ivec2 vAddr )\n{\n    return LoadVec4( vAddr ).xyz;\n}\n\nbool AtAddress( vec2 p, ivec2 c ) { return all( equal( floor(p), vec2(c) ) ); }\n\nvoid StoreVec4( in ivec2 vAddr, in vec4 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in ivec2 vAddr, in vec3 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n\nvec3 ApplyPostFX( const in vec2 vUV, const in vec3 vInput );\n\n\/\/ CAMERA\n\nvec2 GetWindowCoord( const in vec2 vUV )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x \/ iResolution.y;\n\n\treturn vWindow;\t\n}\n\nvec2 GetUVFromWindowCoord( const in vec2 vWindow )\n{\n\tvec2 vScaledWindow = vWindow;\n    vScaledWindow.x *= iResolution.y \/ iResolution.x;\n    \n\t return vScaledWindow * 0.5 + 0.5;\n}\n\n\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget )\n{\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n\t\t\t\t\t\t\t  \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * 2.0);\n\n\treturn vDir;\n}\n\nvec2 GetCameraWindowCoord(const in vec3 vWorldPos, const in vec3 vCameraPos, const in vec3 vCameraTarget)\n{\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n\t\n    vec3 vOffset = vWorldPos - vCameraPos;\n    vec3 vCameraLocal;\n    vCameraLocal.x = dot(vOffset, vRight);\n    vCameraLocal.y = dot(vOffset, vUp);\n    vCameraLocal.z = dot(vOffset, vForward);\n\n    vec2 vWindowPos = vCameraLocal.xy \/ (vCameraLocal.z \/ 2.0);\n    \n    return vWindowPos;\n}\n\nfloat GetCoC( float fDistance, float fPlaneInFocus )\n{\n\t\/\/ http:\/\/http.developer.nvidia.com\/GPUGems\/gpugems_ch23.html\n\n    float fAperture = 0.03;\n    float fFocalLength = 1.0;\n    \n\treturn abs(fAperture * (fFocalLength * (fDistance - fPlaneInFocus)) \/\n          (fDistance * (fPlaneInFocus - fFocalLength)));  \n}\n\n\n\/\/ Random\n\n#define MOD2 vec2(4.438975,3.972973)\n\nfloat Hash( float p ) \n{\n    \/\/ https:\/\/www.shadertoy.com\/view\/4djSRW - Dave Hoskins\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);    \n}\n\n\nfloat fGolden = 3.141592 * (3.0 - sqrt(5.0));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vUV = fragCoord.xy \/ iResolution.xy;\n\n    vec4 vSample = textureLod( iChannel1, vUV, 0.0 ).rgba;\n\t\n    float fDepth = abs(vSample.w);\n    \n\tvec3 vCameraPos = LoadVec3( addrCamera + offsetCameraPos );\n\tvec3 vCameraTarget = LoadVec3( addrCamera + offsetCameraTarget );\n    \n\tvec3 vRayOrigin = vCameraPos;\n\tvec3 vRayDir = GetCameraRayDir( GetWindowCoord(vUV), vCameraPos, vCameraTarget );\n        \n    vec3 vWorldPos = vRayOrigin + vRayDir * fDepth;\n    \n\tvec3 vPrevCameraPos = LoadVec3( addrPrevCamera + offsetCameraPos );\n\tvec3 vPrevCameraTarget = LoadVec3( addrPrevCamera + offsetCameraTarget );\n    vec2 vPrevWindow = GetCameraWindowCoord( vWorldPos, vPrevCameraPos, vPrevCameraTarget );\n    vec2 vPrevUV = GetUVFromWindowCoord(vPrevWindow);\n    \n    if( vSample.a < 0.0 ) \n    {\n        vPrevUV = vUV;\n    }\n        \n\tvec3 vResult = vec3(0.0);\n    \n    float fTot = 0.0;\n    \n    float fPlaneInFocus = length(vCameraPos - vCameraTarget);\n    \n    float fCoC = GetCoC( abs(fDepth), fPlaneInFocus );\n    \n    float r = 1.0;\n    vec2 vangle = vec2(0.0,fCoC); \/\/ Start angle\n    \n    vResult.rgb = vSample.rgb * fCoC;\n    fTot += fCoC;\n    \n    float fMotionBlurTaps = float(MOTION_BLUR_TAPS);\n    \n    float f = 0.0;\n    float fIndex = 0.0;\n    for(int i=1; i<MOTION_BLUR_TAPS; i++)\n    {\n        vec2 vTapUV = mix( vUV, vPrevUV, f \/ fMotionBlurTaps - 0.5 );\n                \n        float fRand = Hash( iTime + fIndex + vUV.x + vUV.y * 12.345);\n        \n        \/\/ http:\/\/blog.marmakoide.org\/?p=1\n        \n        float fTheta = fRand * fGolden * fMotionBlurTaps;\n        float fRadius = fCoC * sqrt( fRand * fMotionBlurTaps ) \/ sqrt( fMotionBlurTaps );        \n        \n        vTapUV += vec2( sin(fTheta), cos(fTheta) ) * fRadius;\n        \n        vec4 vTapSample = textureLod( iChannel1, vTapUV, 0.0 ).rgba;\n        if( sign(vTapSample.a) == sign(vSample.a) )\n        {\n  \t\t  \tfloat fCurrCoC = GetCoC( abs(vTapSample.a), fPlaneInFocus );\n            \n            float fWeight = fCurrCoC + 1.0;\n            \n    \t\tvResult += vTapSample.rgb * fWeight;\n        \tfTot += fWeight;\n        }\n        f += 1.0;\n        fIndex += 1.0;\n    }\n    vResult \/= fTot;\n        \n\tvec3 vFinal = ApplyPostFX( vUV, vResult );\n\n    \/\/ Draw depth\n    \/\/vFinal = vec3(1.0) \/ abs(vSample.a);    \n    \n\tfragColor = vec4(vFinal, 1.0);\n}\n\n\/\/ POSTFX\n\nvec3 ApplyVignetting( const in vec2 vUV, const in vec3 vInput )\n{\n\tvec2 vOffset = (vUV - 0.5) * sqrt(2.0);\n\t\n\tfloat fDist = dot(vOffset, vOffset);\n\t\n\tconst float kStrength = 0.75;\n\t\n\tfloat fShade = mix( 1.0, 1.0 - kStrength, fDist );\t\n\n\treturn vInput * fShade;\n}\n\nvec3 Tonemap( vec3 x )\n{\n    float a = 0.010;\n    float b = 0.132;\n    float c = 0.010;\n    float d = 0.163;\n    float e = 0.101;\n\n    return ( x * ( a * x + b ) ) \/ ( x * ( c * x + d ) + e );\n}\n\nvec3 ColorGrade( vec3 vColor )\n{\n    vec3 vHue = vec3(1.0, .7, .2);\n    \n    vec3 vGamma = 1.0 + vHue * 0.6;\n    vec3 vGain = vec3(.9) + vHue * vHue * 8.0;\n    \n    vColor *= 1.5;\n    \n    float fMaxLum = 100.0;\n    vColor \/= fMaxLum;\n    vColor = pow( vColor, vGamma );\n    vColor *= vGain;\n    vColor *= fMaxLum;  \n    return vColor;\n}\n\nvec3 ApplyGamma( const in vec3 vLinear )\n{\n\tconst float kGamma = 2.2;\n\n\treturn pow(vLinear, vec3(1.0\/kGamma));\t\n}\n\nvec3 ApplyPostFX( const in vec2 vUV, const in vec3 vInput )\n{\n\tvec3 vTemp = ApplyVignetting( vUV, vInput );\t\n\t\n\tvTemp = vTemp * 2.0;\n    \n    vTemp = ColorGrade( vTemp );\n    \n\treturn Tonemap( vTemp );\t\t\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"\/presets\/tex00.jpg","previewfilepath":"\/presets\/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ Shader Rally - @P_Malin\n\n\/\/ Physics Hackery using the new mutipass things.\n\n\/\/ WASD to drive. Space = brake\n\/\/ G toggle gravity\n\/\/ V toggle wheels (vehicle forces)\n\/\/ . and , flip car\n\n\/\/ Simulation Shader\n\n\/\/#define ENABLE_DEBUG_FORCES\n#define ENABLE_GRAVITY_TOGGLE\n\nivec2 addrVehicle = ivec2( 0.0, 0.0 );\n\nivec2 offsetVehicleParam0 = ivec2( 0.0, 0.0 );\n\nivec2 offsetVehicleBody = ivec2( 1.0, 0.0 );\nivec2 offsetBodyPos = ivec2( 0.0, 0.0 );\nivec2 offsetBodyRot = ivec2( 1.0, 0.0 );\nivec2 offsetBodyMom = ivec2( 2.0, 0.0 );\nivec2 offsetBodyAngMom = ivec2( 3.0, 0.0 );\n\nivec2 offsetVehicleWheel0 = ivec2( 5.0, 0.0 );\nivec2 offsetVehicleWheel1 = ivec2( 7.0, 0.0 );\nivec2 offsetVehicleWheel2 = ivec2( 9.0, 0.0 );\nivec2 offsetVehicleWheel3 = ivec2( 11.0, 0.0 );\n\nivec2 offsetWheelState = ivec2( 0.0, 0.0 );\nivec2 offsetWheelContactState = ivec2( 1.0, 0.0 );\n\n\nivec2 addrCamera = ivec2( 0.0, 1.0 );\nivec2 offsetCameraPos = ivec2( 0.0, 0.0 );\nivec2 offsetCameraTarget = ivec2( 1.0, 0.0 );\n\nivec2 addrPrevCamera = ivec2( 0.0, 2.0 );\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Constants\n\nfloat PI = acos(-1.0);\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Storage\n\nvec4 LoadVec4( in ivec2 vAddr )\n{\n    return texelFetch( iChannel0, vAddr, 0 );\n}\n\nvec3 LoadVec3( in ivec2 vAddr )\n{\n    return LoadVec4( vAddr ).xyz;\n}\n\nbool AtAddress( vec2 p, ivec2 c ) { return all( equal( floor(p), vec2(c) ) ); }\n\nvoid StoreVec4( in ivec2 vAddr, in vec4 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in ivec2 vAddr, in vec3 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ Keyboard \n\n\n\/\/ Keyboard constants definition\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\nconst int KEY_COMMA = 188;\nconst int KEY_PER   = 190;\n\nbool KeyIsPressed(int key)\n{\n\treturn texelFetch( iChannel1, ivec2(key, 0), 0 ).x > 0.0;\n}\n\nbool KeyIsToggled(int key)\n{\n\treturn texelFetch( iChannel1, ivec2(key, 2), 0 ).x > 0.0;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Rotation\n\nvec2 Rotate( const in vec2 vPos, const in float t )\n{\n    float s = sin(t);\n    float c = cos(t);\n    \n    return vec2( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y);\n}\n\nvec3 RotX( const in vec3 vPos, float t )\n{\n    vec3 result;\n    result.x = vPos.x;\n  \tresult.yz = Rotate( vPos.yz, t );\n    return result;\n}\n\nvec3 RotY( const in vec3 vPos, float t )\n{\n    vec3 result;\n    result.y = vPos.y;\n  \tresult.xz = Rotate( vPos.xz, t );\n    return result;\n}\n\nvec3 RotZ( const in vec3 vPos, float t )\n{\n    vec3 result;\n    result.z = vPos.z;\n  \tresult.xy = Rotate( vPos.xy, t );\n    return result;\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Vec\n\nvec3 Vec3Parallel( vec3 x, vec3 n )\n{\n    float d = dot( x, n );\n    \n    return x - n * d;    \n}\n\nvec3 Vec3Perp( vec3 x, vec3 n )\n{\n    return x - Vec3Parallel( x, n );\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Quaternions\n\nvec4 QuatMul(const in vec4 lhs, const in vec4 rhs) \n{\n      return vec4( lhs.y*rhs.z - lhs.z*rhs.y + lhs.x*rhs.w + lhs.w*rhs.x,\n                   lhs.z*rhs.x - lhs.x*rhs.z + lhs.y*rhs.w + lhs.w*rhs.y,\n                   lhs.x*rhs.y - lhs.y*rhs.x + lhs.z*rhs.w + lhs.w*rhs.z,\n                   lhs.w*rhs.w - lhs.x*rhs.x - lhs.y*rhs.y - lhs.z*rhs.z);\n}\n\nvec4 QuatFromAxisAngle( vec3 vAxis, float fAngle )\n{\n\treturn vec4( normalize(vAxis) * sin(fAngle), cos(fAngle) );    \n}\n\nvec4 QuatFromVec3( vec3 vRot )\n{\n    float l = length( vRot );\n    if ( l <= 0.0 )\n    {\n        return vec4( 0.0, 0.0, 0.0, 1.0 );\n    }\n    return QuatFromAxisAngle( vRot, l );\n}\n\nmat3 QuatToMat3( const in vec4 q )\n{\n\tvec4 qSq = q * q;\n\tfloat xy2 = q.x * q.y * 2.0;\n\tfloat xz2 = q.x * q.z * 2.0;\n\tfloat yz2 = q.y * q.z * 2.0;\n\tfloat wx2 = q.w * q.x * 2.0;\n\tfloat wy2 = q.w * q.y * 2.0;\n\tfloat wz2 = q.w * q.z * 2.0;\n \n\treturn mat3 (\t\n     qSq.w + qSq.x - qSq.y - qSq.z, xy2 - wz2, xz2 + wy2,\n     xy2 + wz2, qSq.w - qSq.x + qSq.y - qSq.z, yz2 - wx2,\n     xz2 - wy2, yz2 + wx2, qSq.w - qSq.x - qSq.y + qSq.z );\n}\n\nvec3 QuatMul( vec3 v, vec4 q )\n{\n    \/\/ TODO Validate vs other quat code\n    vec3 t = 2.0 * cross(q.xyz, v);\n\treturn v + q.w * t + cross(q.xyz, t);\n}\n\nvec3 ObjToWorld( vec3 v, mat3 m )\n{\n    return v * m;\n}\n\nvec3 WorldToObj( vec3 v, mat3 m )\n{\n    return m * v;\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\n\/\/ RAYTRACE\n\nfloat kFarClip=10.0;\n\nstruct SurfaceInfo\n{\n    vec3 vUVW;\n    int iId;\n};\n\nstruct ClosestSurface\n{\n    float fDist;\n    SurfaceInfo surface;\n};\n    \nvoid ClosestSurfaceInit( inout ClosestSurface closest, int iId, vec3 vUVW )\n{\n    closest.fDist = 10000.0;\n    closest.surface.vUVW = vUVW;\n    closest.surface.iId = iId;\n}\n\n\nClosestSurface ClosestSurfaceUnion( const in ClosestSurface a, const in ClosestSurface b )\n{\n    if ( a.fDist < b.fDist )\n    {\n        return a;\n    }\n\n    return b;        \n}\n    \nstruct C_Intersection\n{\n\tvec3 vPos;\n\tfloat fDist;\t\n\tvec3 vNormal;\n    SurfaceInfo surface;\n};\n    \n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Random\n\n#define MOD2 vec2(4.438975,3.972973)\n#define MOD3 vec3(.1031,.11369,.13787)\n#define MOD4 vec4(.1031,.11369,.13787, .09987)\n\nfloat Hash( float p ) \n{\n    \/\/ https:\/\/www.shadertoy.com\/view\/4djSRW - Dave Hoskins\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);    \n}\n\nvec3 Hash31(float p)\n{\n    \/\/ https:\/\/www.shadertoy.com\/view\/4djSRW - Dave Hoskins\n   vec3 p3 = fract(vec3(p) * MOD3);\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nfloat SmoothNoise(in vec2 o) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat a = Hash(n+  0.0);\n\tfloat b = Hash(n+  1.0);\n\tfloat c = Hash(n+ 57.0);\n\tfloat d = Hash(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n    return res;\n}\n\nfloat FBM( vec2 p, float ps ) {\n\tfloat f = 0.0;\n    float tot = 0.0;\n    float a = 1.0;\n    for( int i=0; i<3; i++)\n    {\n        f += SmoothNoise( p ) * a;\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f \/ tot;\n}\n    \n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Scene\n\n#define MAT_TERRAIN 1\n#define MAT_CAR_BODY 4\n#define MAT_CAR_WINDOW 3\n#define MAT_CHROME 3\n#define MAT_GRILL 2\n#define MAT_BLACK_PLASTIC 2\n#define MAT_AXLE 2\n#define MAT_WHEEL 5\n#define MAT_REAR 2\n#define MAT_SUSPENSION 6\n#define MAT_WOOD 7\n\nfloat GetTerrainDistance( const vec3 vPos )\n{    \n    float fbm = FBM( vPos.xz * vec2(0.5, 1.0), 0.5 );\n    float fTerrainHeight = fbm * fbm;\n    fTerrainHeight = fTerrainHeight * (sin(vPos.x * 0.1) + 1.0) * 0.5 + vPos.y + 3.0;    \n    \n    \/\/float h = 1.0 - exp(-abs(vPos.x + 15.0) * 0.01);\n    \n    \/\/fTerrainHeight += sin(vPos.x * 0.05) * 5.0 * h;\n    \/\/fTerrainHeight += sin(vPos.z * 0.05) * 5.0 * h;\n\n\treturn fTerrainHeight;\n}\n\nClosestSurface GetRampClosestSurface( const vec3 vPos, const float fRampSeed )\n{\n    ClosestSurface closest;\n    \n    vec3 vHash = Hash31( fRampSeed );\n    \n    closest.surface.iId = MAT_WOOD;\n    closest.surface.vUVW = vPos.xyz;\n    \n    float fHeight = 2.0 + vHash.x * 6.0;\n    float fRadius = 10.0 + vHash.y * 20.0;\n    float fLedge = 2.0 + vHash.z * 3.0;\n        \n    float h2 = fRadius - fHeight;\n    float fLength = sqrt(fRadius * fRadius - h2 * h2);\n    fLength = fLength + fLedge;\n    closest.fDist = sdBox( vPos - vec3( 0.0, fHeight * 0.5, fLength * 0.5 ), vec3(3.0, fHeight * 0.5, fLength * 0.5));\n    \n\n    vec3 vCylDomain = vPos - vec3( 0.0, fRadius, 0.0 );\n    float fCylDist = length(vCylDomain.yz) - fRadius;\n    \n    \/\/closest.fDist = fCylDist;\n    \n    closest.fDist = max( closest.fDist, -fCylDist);\n    \n    return closest;\n}\n\nClosestSurface GetEnvironmentClosestSurface( const vec3 vPos )\n{\n    ClosestSurface terrainClosest;\n    terrainClosest.surface.iId = MAT_TERRAIN;\n    terrainClosest.surface.vUVW = vec3(vPos.xz,0.0);\n    terrainClosest.fDist = GetTerrainDistance( vPos );\n\n    \/\/return terrainClosest;\n    \n    float fRepeat = 100.0;\n    vec3 vRampDomain = vPos - vec3(-15.0, -3.0, 0.0);\n    float fRampUnitZ = vRampDomain.z \/ fRepeat + 0.5;\n    float fRampSeed = floor( fRampUnitZ );\n    vRampDomain.z = (fract(fRampUnitZ) - 0.5) * fRepeat;\n    ClosestSurface rampClosest = GetRampClosestSurface( vRampDomain, fRampSeed );\n\n    return ClosestSurfaceUnion( terrainClosest, rampClosest );\n}\n\nClosestSurface GetSceneClosestSurface( const vec3 vPos )\n{    \n    ClosestSurface closest = GetEnvironmentClosestSurface( vPos );\n    \n    return closest;\n}\n\nvec3 GetSceneNormal( const in vec3 vPos )\n{\n    const float fDelta = 0.0001;\n\n    vec3 vDir1 = vec3( 1.0, -1.0, -1.0);\n    vec3 vDir2 = vec3(-1.0, -1.0,  1.0);\n    vec3 vDir3 = vec3(-1.0,  1.0, -1.0);\n    vec3 vDir4 = vec3( 1.0,  1.0,  1.0);\n\t\n    vec3 vOffset1 = vDir1 * fDelta;\n    vec3 vOffset2 = vDir2 * fDelta;\n    vec3 vOffset3 = vDir3 * fDelta;\n    vec3 vOffset4 = vDir4 * fDelta;\n\n    ClosestSurface c1 = GetSceneClosestSurface( vPos + vOffset1 );\n    ClosestSurface c2 = GetSceneClosestSurface( vPos + vOffset2 );\n    ClosestSurface c3 = GetSceneClosestSurface( vPos + vOffset3 );\n    ClosestSurface c4 = GetSceneClosestSurface( vPos + vOffset4 );\n\t\n    vec3 vNormal = vDir1 * c1.fDist + vDir2 * c2.fDist + vDir3 * c3.fDist + vDir4 * c4.fDist;\t\n\t\t\n    return normalize( vNormal );\n}\n\nvoid TraceScene( out C_Intersection outIntersection, const in vec3 vOrigin, const in vec3 vDir )\n{\t\n\tvec3 vPos = vec3(0.0);\n\t\n\tfloat t = 0.1;\n\tconst int kRaymarchMaxIter = 32;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\n\t\tfloat fClosestDist = GetSceneClosestSurface( vOrigin + vDir * t ).fDist;\n\t\tt += fClosestDist;\n\t\tif(abs(fClosestDist) < 0.01)\n\t\t{\n\t\t\tbreak;\n\t\t}\t\t\n\t\tif(t > kFarClip)\n\t\t{\n\t\t\tt = kFarClip;\n\t\t\tbreak;\n\t\t}\n\t}\n    \n\toutIntersection.fDist = t;\n\toutIntersection.vPos = vOrigin + vDir * t;\n    \n    if( t >= kFarClip )\n    {\n        outIntersection.surface.iId = 0;\n        outIntersection.surface.vUVW = vec3( 0.0 );\n        outIntersection.vNormal = vec3(0.0, 1.0, 0.0);\n    }\n    else\n    {\n\t\toutIntersection.vNormal = GetSceneNormal( outIntersection.vPos );\n        outIntersection.surface = GetSceneClosestSurface( outIntersection.vPos ).surface;\n    }\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nstruct Body\n{\n    \/\/ Persistent State\n    vec3 vPos;\n    vec4 qRot;\n    vec3 vMomentum;\n    vec3 vAngularMomentum;\n    \n    \/\/ Derived\n    mat3 mRot;\n    \n    \/\/ Constant\n    float fMass;\n    float fIT; \/\/ Hacky scalar for inertia tensor\n    \n    \/\/ Per frame\n    vec3 vForce;\n    vec3 vTorque;\n};\n\nvoid BodyLoadState( out Body body, ivec2 addr )\n{\n    body.vPos = LoadVec3( addr + offsetBodyPos );\n    body.qRot = LoadVec4( addr + offsetBodyRot );\n    body.vMomentum = LoadVec3( addr + offsetBodyMom );\n    body.vAngularMomentum = LoadVec3( addr + offsetBodyAngMom );\n}\n\nvoid BodyStoreState( ivec2 addr, const in Body body, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec3( addr + offsetBodyPos, body.vPos, fragColor, fragCoord );\n    StoreVec4( addr + offsetBodyRot, body.qRot, fragColor, fragCoord );\n    StoreVec3( addr + offsetBodyMom, body.vMomentum, fragColor, fragCoord );\n    StoreVec3( addr + offsetBodyAngMom, body.vAngularMomentum, fragColor, fragCoord );\n}\n\nvoid BodyResetForFrame( inout Body body )\n{\n    body.vForce = vec3(0.0);\n    body.vTorque = vec3(0.0);\n}\n\nvoid BodyCalculateDerivedState( inout Body body )\n{\n    body.mRot = QuatToMat3( body.qRot );    \n}\n\nvoid BodyApplyGravity( inout Body body, float dT )\n{\n    float fAccel_MpS = -9.81;\n    body.vForce.y += body.fMass * fAccel_MpS;\n}\n\nvoid BodyIntegrate( inout Body body, float dT )\n{\n#ifdef ENABLE_GRAVITY_TOGGLE    \n    if( !KeyIsToggled( KEY_G ) )\n#endif \/\/ ENABLE_GRAVITY_TOGGLE        \n    {\n    \tBodyApplyGravity( body, dT );\n    }\n    \n    body.vMomentum += body.vForce * dT;\n    body.vAngularMomentum += body.vTorque * dT;\n    \n    vec3 vVel = body.vMomentum \/ body.fMass;\n    vec3 vAngVel = body.vAngularMomentum \/ body.fIT;\n\n    body.vPos += vVel * dT;\n    vec4 qAngDelta = QuatFromVec3( vAngVel * dT );\n    body.qRot = QuatMul( qAngDelta, body.qRot );\n\n    body.qRot = normalize( body.qRot );\n}\n\nvoid BodyApplyForce( inout Body body, vec3 vPos, vec3 vForce )\n{    \n    body.vForce += vForce;\n    body.vTorque += cross(vPos - body.vPos, vForce);     \n}\n\nvoid BodyApplyImpulse( inout Body body, vec3 vPos, vec3 vImpulse )\n{    \n    body.vMomentum += vImpulse;\n    body.vAngularMomentum += cross(vPos - body.vPos, vImpulse);     \n}\n\nvec3 BodyPointVelocity( const in Body body, vec3 vWorldPos )\n{\n    vec3 vVel = body.vMomentum \/ body.fMass;\n    vec3 vAngVel = body.vAngularMomentum \/ body.fIT;\n    \n    return vVel + cross( vAngVel, vWorldPos - body.vPos );\n}\n\n\nvoid BodyApplyDebugForces( inout Body body )\n{\n#ifdef ENABLE_DEBUG_FORCES    \n    float debugForceMag = 20000.0;\n    if ( KeyIsPressed( KEY_LEFT ) )\n    {\n        vec3 vForcePos = body.vPos;\n        vec3 vForce = vec3(-debugForceMag, 0.0, 0.0);\n        BodyApplyForce( body, vForcePos, vForce );\n    }\n    if ( KeyIsPressed( KEY_RIGHT ) )\n    {\n        vec3 vForcePos = body.vPos;\n        vec3 vForce = vec3(debugForceMag, 0.0, 0.0);\n        BodyApplyForce( body, vForcePos, vForce );\n    }\n    if ( KeyIsPressed( KEY_UP ) )\n    {\n        vec3 vForcePos = body.vPos;\n        vec3 vForce = vec3(0.0, 0.0, debugForceMag);\n        BodyApplyForce( body, vForcePos, vForce );\n    }\n    if ( KeyIsPressed( KEY_DOWN ) )\n    {\n        vec3 vForcePos = body.vPos;\n        vec3 vForce = vec3(0.0, 0.0, -debugForceMag);\n        BodyApplyForce( body, vForcePos, vForce );\n    }\n#endif \/\/ ENABLE_DEBUG_FORCES                \n    \n    float debugTorqueMag = 4000.0;\n    if ( KeyIsPressed( KEY_COMMA ) )\n    {\n        vec3 vForcePos = body.vPos;\n        vec3 vForce = vec3(0.0, -debugTorqueMag, 0.0);\n\t\tvForcePos.x += 2.0;\n        BodyApplyForce( body, vForcePos, vForce );\n\t\t\/\/vForcePos.x -= 4.0;\n        \/\/vForce = -vForce;\n        \/\/BodyApplyForce( body, vForcePos, vForce );\n    }\n    if ( KeyIsPressed( KEY_PER ) )\n    {\n        vec3 vForcePos = body.vPos;\n        vec3 vForce = vec3(0.0, debugTorqueMag, 0.0);\n\t\tvForcePos.x += 2.0;\n        BodyApplyForce( body, vForcePos, vForce );\n\t\t\/\/vForcePos.x -= 4.0;\n        \/\/vForce = -vForce;\n        \/\/BodyApplyForce( body, vForcePos, vForce );\n    }        \n}\n\nvoid BodyCollideShapeSphere( inout Body body, vec3 vSphereOrigin, float fSphereRadius, float dT )\n{    \n    vec3 vSphereWorld = ObjToWorld( vSphereOrigin, body.mRot) + body.vPos;\n    \n    ClosestSurface closest = GetSceneClosestSurface( vSphereWorld );\n    \n    float fDepth = fSphereRadius - closest.fDist;\n    \n    if ( fDepth < 0.0 )\n        return;\n    \n    vec3 vNormal = GetSceneNormal( vSphereWorld );\n    vec3 vHitPos = vSphereWorld - vNormal * closest.fDist;    \n    vec3 vPointVel = BodyPointVelocity( body, vHitPos );\n    \n    float fDot = dot( vPointVel, vNormal );\n    \n    if( fDot >= 0.0 )\n        return;\n    \n    float fRestitution = 0.5;\n    \n    vec3 vRelativePos = (vHitPos - body.vPos);\n    float fDenom = (1.0\/body.fMass );\n    float fCr = dot( cross( cross( vRelativePos, vNormal ), vRelativePos), vNormal);\n    fDenom += fCr \/ body.fIT;\n    \n    float fImpulse = -((1.0 + fRestitution) * fDot) \/ fDenom;\n    \n    fImpulse += fDepth \/ fDenom;\n    \n    vec3 vImpulse = vNormal * fImpulse;\n    \n    vec3 vFriction = Vec3Perp( vPointVel, vNormal ) * body.fMass;\n    float fLimit = 100000.0;\n    float fMag = length(vFriction);\n    if( fMag > 0.0 )\n    {\t        \n        vFriction = normalize( vFriction );\n\n        fMag = min( fMag, fLimit );\n        vFriction = vFriction * fMag;\n\n        \/\/BodyApplyForce( body, vHitPos, vFriction );\n        vImpulse += vFriction * dT;        \n    }\n    else\n    {\n        vFriction = vec3(0.0);\n    }\n    \n    BodyApplyImpulse( body, vHitPos, vImpulse );\n}\n    \nvoid BodyCollide( inout Body body, float dT )\n{\n    BodyCollideShapeSphere( body, vec3( 0.7, 0.7,  1.5), 0.5, dT );\n    BodyCollideShapeSphere( body, vec3(-0.7, 0.7,  1.5), 0.5, dT );\n    BodyCollideShapeSphere( body, vec3( 0.7, 0.7, -1.5), 0.5, dT );\n    BodyCollideShapeSphere( body, vec3(-0.7, 0.7, -1.5), 0.5, dT );\n    BodyCollideShapeSphere( body, vec3( 0.5, 1.0,  0.0), 0.7, dT );\n    BodyCollideShapeSphere( body, vec3(-0.5, 1.0,  0.0), 0.7, dT );\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nstruct Engine\n{\n    float fAngularMomentum;\n};\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nstruct Wheel\n{\n    \/\/ Persistent State\n    float fSteer;\n    float fRotation;\n    float fExtension;\n    float fAngularVelocity;\n    \n    \/\/ Results\n    vec2 vContactPos;\n    float fOnGround;\n    float fSkid;    \n    \n    \/\/ Constant\n\tvec3 vBodyPos;    \n    float fRadius;\n    bool bIsDriven;\n    bool bSteering;   \n};\n    \nvoid WheelLoadState( out Wheel wheel, ivec2 addr )\n{    \n    vec4 vState = LoadVec4( addr + offsetWheelState );\n    \n    wheel.fSteer = vState.x;\n    wheel.fRotation = vState.y;\n    wheel.fExtension = vState.z;\n    wheel.fAngularVelocity = vState.w;\n    \n    \/\/ output data\n    wheel.vContactPos = vec2( 0.0 );\n    wheel.fOnGround = 0.0;\n    wheel.fSkid = 0.0;\n}\n    \nvoid WheelStoreState( ivec2 addr, const in Wheel wheel, inout vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 vState = vec4( wheel.fSteer, wheel.fRotation, wheel.fExtension, wheel.fAngularVelocity );\n    StoreVec4( addr + offsetWheelState, vState, fragColor, fragCoord );\n\n    vec4 vState2 = vec4( wheel.vContactPos.xy, wheel.fOnGround, wheel.fSkid );\n    StoreVec4( addr + offsetWheelContactState , vState2, fragColor, fragCoord );\n}\n\nC_Intersection WheelTrace( vec3 vPos, vec3 vDir, Wheel wheel )\n{\n    C_Intersection intersection;\n\tTraceScene( intersection, vPos - vDir * wheel.fRadius, vDir );\n    \n    return intersection;\n}\n\n\nfloat ClampTyreForce( inout vec3 vVel, float fLimit )\n{\n    \/\/ Square clamp\n    \/\/vVelWheel.x = clamp( vVelWheel.x, -fLimit, fLimit);\n    \/\/vVelWheel.z = clamp( vVelWheel.z, -fLimit, fLimit);\n\tfloat fSkid = 0.0;\n    \n    \/\/ Circluar clamp\n    float fMag = length(vVel);\n    if( fMag > 0.0 )\n    {\t        \n        vVel = normalize( vVel );\n    }\n    else\n    {\n        vVel = vec3(0.0);\n    }\n    if ( fMag > fLimit )\n    {\n        fSkid = fMag - fLimit;\n\t    fMag = fLimit;        \n    }\n    vVel = vVel * fMag;\n    \n    return fSkid;\n}\n\nvoid WheelUpdate( inout Engine engine, inout Body body, inout Wheel wheel, float dT )\n{\n    vec3 vWheelWorld = ObjToWorld( wheel.vBodyPos, body.mRot) + body.vPos;\n    vec3 vWheelDown = ObjToWorld( vec3(0.0, -1.0, 0.0), body.mRot);\n    \n    float fSuspensionTravel = 0.25;\n    C_Intersection intersection = WheelTrace( vWheelWorld, vWheelDown, wheel );\n    \n    float fTravel = clamp( intersection.fDist - wheel.fRadius, 0.0, fSuspensionTravel);\n        \n    \/\/ Apply suspension force\n    \/\/ Simple spring-damper\n    \/\/ (No anti-roll bar)\n    float fWheelExt = fTravel \/ fSuspensionTravel;\n\n    wheel.fOnGround = 1.0 - fWheelExt;\n    \n    float delta = (wheel.fExtension - fTravel) \/ fSuspensionTravel;\n\n    float fForce = (1.0 - fWheelExt) * 5000.0 + delta * 15000.0;\n\n    vec3 vForce = Vec3Perp( intersection.vNormal, vWheelDown) * fForce;\n    \/\/BodyApplyForce( body, vWheelWorld, vForce );                \n\n    \/\/ Apply Tyre force\n\n    \/\/ Super simplification of wheel \/ drivetrain \/ engine \/ tyre contact\n    \/\/ ignoring engine \/ wheel angular momentum       \n\n    \/\/ Figure out how contact patch is moving in world space\n    vec3 vIntersectWorld = intersection.vPos;\n    wheel.vContactPos = vIntersectWorld.xz;\n    vec3 vVelWorld = BodyPointVelocity( body, vIntersectWorld );\n\n    \/\/ Transform to body space\n    vec3 vVelBody = WorldToObj( vVelWorld, body.mRot );\n\n    \/\/ Transform to wheel space\n    vec3 vVelWheel = RotY( vVelBody, wheel.fSteer );\n\n    float fWScale = wheel.fRadius;\n\n    float fWheelMOI = 20.0;\n    if ( wheel.bIsDriven )\n    {\n        fWheelMOI = 30.0;\n\n        \/\/ consta-torque mega engine\n        if( KeyIsPressed( KEY_W ) )\n        {\n            wheel.fAngularVelocity += 2.0;\n        }        \n\n        if( KeyIsPressed( KEY_S ) )\n        {\n            wheel.fAngularVelocity -= 2.0;\n        }        \n    }\n\n    if( KeyIsPressed( KEY_SPACE ) )\n    {\n        wheel.fAngularVelocity = 0.0; \/\/ insta-grip super brake\n    }        \n\n    vVelWheel.z -= wheel.fAngularVelocity * fWScale;\n\n    vec3 vForceWheel = vVelWheel * body.fMass;\n\n    \/\/ Hacked 'slip angle'\n    \/\/vForceWheel.x \/=  1.0 + abs(wheel.fAngularVelocity * fWScale) * 0.1;\n\n    float fLimit = 9000.0 * (1.0 - fWheelExt);\n\n    wheel.fSkid = ClampTyreForce( vForceWheel, fLimit );    \n    \n    \/\/vVelWheel.z += wheel.fAngularVelocity * fWScale;\n    vec3 vForceBody = RotY( vForceWheel, -wheel.fSteer );\n\n    \/\/ Apply force back on wheel\n\n    wheel.fAngularVelocity += ((vForceWheel.z \/ fWScale) \/ fWheelMOI) * dT;\n\n    vec3 vForceWorld = ObjToWorld( vForceBody, body.mRot );\n\n    \/\/ cancel in normal dir\n    vForceWorld = Vec3Parallel( vForceWorld, intersection.vNormal );\n\n    vForce -= vForceWorld;\n    \/\/BodyApplyForce( body, vIntersectWorld, -vForceWorld );        \n    \n    BodyApplyForce( body, vIntersectWorld, vForce );        \n\n    wheel.fExtension = fTravel;\n    wheel.fRotation += wheel.fAngularVelocity * dT;    \n}\n\nvoid WheelUpdateSteerAngle( float fSteerAngle, inout Wheel wheel )\n{\n    if ( !wheel.bSteering )\n    {\n        wheel.fSteer = 0.0;\n    }\n    else\n    {\n        \/\/ figure out turning circle if wheel was central\n        float turningCircle = wheel.vBodyPos.z \/ tan( fSteerAngle );\n        float wheelTurningCircle = turningCircle - wheel.vBodyPos.x;\n        wheel.fSteer = atan( abs(wheel.vBodyPos.z) \/ wheelTurningCircle);\n    }\n}\n\nstruct Vechicle\n{\n    Body body;    \n    Engine engine;\n    Wheel wheel[4];\n    \n    float fSteerAngle;\n};\n\nvoid VehicleLoadState( out Vechicle vehicle, ivec2 addr )\n{    \n    BodyLoadState( vehicle.body, addr + offsetVehicleBody );\n    WheelLoadState( vehicle.wheel[0], addr + offsetVehicleWheel0 );\n    WheelLoadState( vehicle.wheel[1], addr + offsetVehicleWheel1 );\n    WheelLoadState( vehicle.wheel[2], addr + offsetVehicleWheel2 );\n    WheelLoadState( vehicle.wheel[3], addr + offsetVehicleWheel3 );\n    \n    vec4 vParam0;\n    vParam0 = LoadVec4( addr + offsetVehicleParam0 );\n    vehicle.fSteerAngle = vParam0.x;\n}\n\nvoid VehicleStoreState( ivec2 addr, const in Vechicle vehicle, inout vec4 fragColor, in vec2 fragCoord )\n{\n    BodyStoreState( addr + offsetVehicleBody, vehicle.body, fragColor, fragCoord );\n    WheelStoreState( addr + offsetVehicleWheel0, vehicle.wheel[0], fragColor, fragCoord );\n    WheelStoreState( addr + offsetVehicleWheel1, vehicle.wheel[1], fragColor, fragCoord );\n    WheelStoreState( addr + offsetVehicleWheel2, vehicle.wheel[2], fragColor, fragCoord );\n    WheelStoreState( addr + offsetVehicleWheel3, vehicle.wheel[3], fragColor, fragCoord );\n\n    vec4 vParam0 = vec4( vehicle.fSteerAngle, 0.0, 0.0, 0.0 );\n    StoreVec4( addr + offsetVehicleParam0, vParam0, fragColor, fragCoord);\n}\n\nvoid VehicleResetForFrame( inout Vechicle vehicle )\n{\n    BodyResetForFrame( vehicle.body );\n}\n\nvoid VehicleSetup( inout Vechicle vehicle )\n{\n    vehicle.body.fMass = 1000.0;\n    vehicle.body.fIT = 1000.0;\n\n    vehicle.engine.fAngularMomentum = 0.0; \/\/ TODO : Move to state\n    \n    vehicle.wheel[0].vBodyPos = vec3( -0.9, -0.1, 1.25 );\n    vehicle.wheel[1].vBodyPos = vec3(  0.9, -0.1, 1.25 );\n    vehicle.wheel[2].vBodyPos = vec3( -0.9, -0.1, -1.25 );\n    vehicle.wheel[3].vBodyPos = vec3(  0.9, -0.1, -1.25 );\n    \n    vehicle.wheel[0].fRadius = 0.45;\n    vehicle.wheel[1].fRadius = 0.45;\n    vehicle.wheel[2].fRadius = 0.45;\n    vehicle.wheel[3].fRadius = 0.45; \n    \n    vehicle.wheel[0].bIsDriven = false;\n    vehicle.wheel[1].bIsDriven = false;\n    vehicle.wheel[2].bIsDriven = true;\n    vehicle.wheel[3].bIsDriven = true;    \n    \n    vehicle.wheel[0].bSteering = true;\n    vehicle.wheel[1].bSteering = true;\n    vehicle.wheel[2].bSteering = false;\n    vehicle.wheel[3].bSteering = false;   \n}\n\n\nstruct Camera\n{\n    vec3 vPos;\n    vec3 vTarget;\n};\n\nvoid CameraLoadState( out Camera cam, in ivec2 addr )\n{\n\tcam.vPos = LoadVec3( addr + offsetCameraPos );\n\tcam.vTarget = LoadVec3( addr + offsetCameraTarget );\n}\n\nvoid CameraStoreState( Camera cam, in ivec2 addr, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec3( addr + offsetCameraPos, cam.vPos, fragColor, fragCoord );\n    StoreVec3( addr + offsetCameraTarget, cam.vTarget, fragColor, fragCoord );    \n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (( fragCoord.x > 13.0 ) || ( fragCoord.y > 3.0 ) )\n    {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    \n    Vechicle vehicle;\n    \n    VehicleLoadState( vehicle, addrVehicle );\n    VehicleSetup( vehicle );\n    VehicleResetForFrame( vehicle );\n\n    if ( iFrame < 1 )\n    {        \n        vehicle.body.vPos = vec3( 0.0, -2.5, 0.0 );\n        vehicle.body.vMomentum = vec3( 0.0 );\n        vehicle.body.qRot = vec4( 0.0, 0.0, 0.0, 1.0 );\n        vehicle.body.vAngularMomentum = vec3( 0.0, 0.5, 0.0 );        \n        \n        vehicle.fSteerAngle = 0.0;\n    }\n\n    BodyCalculateDerivedState( vehicle.body );\n    \n    \/\/ TODO: dT for steering\n    if ( KeyIsPressed( KEY_A ) )\n    {\n        vehicle.fSteerAngle += 0.05;\n    }    \n    if ( KeyIsPressed( KEY_D ) )\n    {\n        vehicle.fSteerAngle -= 0.05;\n    }    \n    \n    vehicle.fSteerAngle *= 0.9;\n    \n    float fSteerAngle = vehicle.fSteerAngle \/ ( 1.0 + length(vehicle.body.vMomentum) * 0.0001 );\n    \n    WheelUpdateSteerAngle( fSteerAngle, vehicle.wheel[0] );\n    WheelUpdateSteerAngle( fSteerAngle, vehicle.wheel[1] );\n    WheelUpdateSteerAngle( fSteerAngle, vehicle.wheel[2] );\n    WheelUpdateSteerAngle( fSteerAngle, vehicle.wheel[3] );\n    \n    float dT = 1.0 \/ 60.0;\n\n\tif ( !KeyIsToggled( KEY_V ) )\n    {\n        WheelUpdate( vehicle.engine, vehicle.body, vehicle.wheel[0], dT );\n        WheelUpdate( vehicle.engine, vehicle.body, vehicle.wheel[1], dT );\n        WheelUpdate( vehicle.engine, vehicle.body, vehicle.wheel[2], dT );\n        WheelUpdate( vehicle.engine, vehicle.body, vehicle.wheel[3], dT );\n    }\n    \n\tBodyApplyDebugForces( vehicle.body );\n    BodyCollide( vehicle.body, dT );\n    BodyIntegrate( vehicle.body, dT );\n\n    fragColor = vec4( 0.0 );\n    \n    VehicleStoreState( addrVehicle, vehicle, fragColor, fragCoord );\n    \n  \n    Camera prevCam;\n    \n    \/\/ load old camera data\n    CameraLoadState( prevCam, addrCamera );\n\n    \/\/ store in addrPrevCamera\n    CameraStoreState( prevCam, addrPrevCamera, fragColor, fragCoord );\n    \n    Camera cam;\n    \n\tvec2 vMouse = iMouse.xy \/ iResolution.xy;\n\tfloat fAngle = (-vMouse.x * 2.0 + 1.0) * 3.14;\n   \tfloat fDistance = 8.0 - vMouse.y * 6.0;\n    \n    cam.vTarget = vec3( 0.0, 1.0, 0.0 ) * vehicle.body.mRot + vehicle.body.vPos;\n    cam.vPos = vec3( 0.0, 0.0, -fDistance ) * vehicle.body.mRot + vehicle.body.vPos + vec3(0.0, 2.0, 0.0);\n    \n    cam.vPos -= cam.vTarget;\n    cam.vPos = RotY( cam.vPos, fAngle );\n    cam.vPos += cam.vTarget;\n            \n    CameraStoreState( cam, addrCamera, fragColor, fragCoord );\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/\/ Tyre track buffer rendering shader\n\nivec2 addrVehicle = ivec2( 0.0, 0.0 );\n\nivec2 offsetVehicleParam0 = ivec2( 0.0, 0.0 );\n\nivec2 offsetVehicleBody = ivec2( 1.0, 0.0 );\nivec2 offsetBodyPos = ivec2( 0.0, 0.0 );\nivec2 offsetBodyRot = ivec2( 1.0, 0.0 );\nivec2 offsetBodyMom = ivec2( 2.0, 0.0 );\nivec2 offsetBodyAngMom = ivec2( 3.0, 0.0 );\n\nivec2 offsetVehicleWheel0 = ivec2( 5.0, 0.0 );\nivec2 offsetVehicleWheel1 = ivec2( 7.0, 0.0 );\nivec2 offsetVehicleWheel2 = ivec2( 9.0, 0.0 );\nivec2 offsetVehicleWheel3 = ivec2( 11.0, 0.0 );\n\nivec2 offsetWheelState = ivec2( 0.0, 0.0 );\nivec2 offsetWheelContactState = ivec2( 1.0, 0.0 );\n\n\nivec2 addrCamera = ivec2( 0.0, 1.0 );\nivec2 offsetCameraPos = ivec2( 0.0, 0.0 );\nivec2 offsetCameraTarget = ivec2( 1.0, 0.0 );\n\nivec2 addrPrevCamera = ivec2( 0.0, 2.0 );\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Storage\n\nvec4 LoadVec4( in ivec2 vAddr )\n{\n    return texelFetch( iChannel0, vAddr, 0 );\n}\n\nvec3 LoadVec3( in ivec2 vAddr )\n{\n    return LoadVec4( vAddr ).xyz;\n}\n\nbool AtAddress( vec2 p, ivec2 c ) { return all( equal( floor(p), vec2(c) ) ); }\n\nvoid StoreVec4( in ivec2 vAddr, in vec4 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in ivec2 vAddr, in vec3 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n\n\nstruct Camera\n{\n    vec3 vPos;\n    vec3 vTarget;\n};\n\nvoid CameraLoadState( out Camera cam, in ivec2 addr )\n{\n\tcam.vPos = LoadVec3( addr + offsetCameraPos );\n\tcam.vTarget = LoadVec3( addr + offsetCameraTarget );\n}\n\n\n\n\nvoid UpdateTyreTracks( vec3 vCamPosPrev, vec3 vCamPos, inout vec4 fragColor, in vec2 fragCoord )\n{\n    float fRange = 20.0;\n    vec2 vPrevOrigin = floor( vCamPosPrev.xz );\n    vec2 vCurrOrigin = floor( vCamPos.xz );\n\n    vec2 vFragOffset = ((fragCoord \/ iResolution.xy) * 2.0 - 1.0) * fRange;\n    vec2 vFragWorldPos = vFragOffset + vCurrOrigin;\n\t\n    vec2 vPrevFragOffset = vFragWorldPos - vPrevOrigin;\n\tvec2 vPrevUV = ( (vPrevFragOffset \/ fRange) + 1.0 ) \/ 2.0;\n    vec4 vPrevSample = textureLod( iChannel1, vPrevUV, 0.0 );\n    \n    vec4 vWheelContactState[4];\n    vWheelContactState[0] = LoadVec4( addrVehicle + offsetVehicleWheel0 + offsetWheelContactState );\n    vWheelContactState[1] = LoadVec4( addrVehicle + offsetVehicleWheel1 + offsetWheelContactState );\n    vWheelContactState[2] = LoadVec4( addrVehicle + offsetVehicleWheel2 + offsetWheelContactState );\n    vWheelContactState[3] = LoadVec4( addrVehicle + offsetVehicleWheel3 + offsetWheelContactState );\n    \n    fragColor = vPrevSample;\n    \n    if ( vPrevUV.x < 0.0 || vPrevUV.x >= 1.0 || vPrevUV.y < 0.0 || vPrevUV.y >= 1.0 )\n    {\n        fragColor = vec4(0.0);\n    }\n    \n    for ( int w=0; w<4; w++ )\n    {        \n        vec2 vContactPos = vWheelContactState[w].xy;\n        \n        float fDist = length( vFragWorldPos - vContactPos );\n        \n        if ( vWheelContactState[w].z > 0.01 )\n        {\n            float fAmount = smoothstep( 0.25, 0.1, fDist );\n            fragColor.x = max(fragColor.x, fAmount * vWheelContactState[w].z );\n            \n            fragColor.y = max(fragColor.y, fAmount * vWheelContactState[w].w * 0.01);\n        }\t\t\n    }\n    \n    \n    fragColor.x = clamp( fragColor.x, 0.0, 1.0);\n    fragColor.y = clamp( fragColor.y, 0.0, 1.0);\n    \n    if( iFrame < 1 )\n    {\n    \tfragColor.x = 0.0;  \n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0, 0.0, 1.0);\n    \n    Camera cam;\n    CameraLoadState( cam, addrCamera );\n\n    Camera prevCam;    \n    CameraLoadState( prevCam, addrPrevCamera );\n    \n    UpdateTyreTracks( prevCam.vPos, cam.vPos, fragColor, fragCoord );        \n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"XsfGRn","filepath":"\/media\/a\/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"\/media\/ap\/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"\/media\/a\/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"\/media\/ap\/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\/\/ Shader Rally - @P_Malin\n\n\/\/ Main HDR scene shader\n\n\/\/ Uncomment the next line to speed things up a bit\n\/\/#define FAST_VERSION\n\/\/#define SHOW_PHYSICS_SHAPE\n\n#define RAYTRACE_COUNT 2\n\nvec3 g_pixelRandom;\n\nivec2 addrVehicle = ivec2( 0.0, 0.0 );\n\nivec2 offsetVehicleParam0 = ivec2( 0.0, 0.0 );\n\nivec2 offsetVehicleBody = ivec2( 1.0, 0.0 );\nivec2 offsetBodyPos = ivec2( 0.0, 0.0 );\nivec2 offsetBodyRot = ivec2( 1.0, 0.0 );\nivec2 offsetBodyMom = ivec2( 2.0, 0.0 );\nivec2 offsetBodyAngMom = ivec2( 3.0, 0.0 );\n\nivec2 offsetVehicleWheel0 = ivec2( 5.0, 0.0 );\nivec2 offsetVehicleWheel1 = ivec2( 7.0, 0.0 );\nivec2 offsetVehicleWheel2 = ivec2( 9.0, 0.0 );\nivec2 offsetVehicleWheel3 = ivec2( 11.0, 0.0 );\n\nivec2 offsetWheelState = ivec2( 0.0, 0.0 );\nivec2 offsetWheelContactState = ivec2( 1.0, 0.0 );\n\n\nivec2 addrCamera = ivec2( 0.0, 1.0 );\nivec2 offsetCameraPos = ivec2( 0.0, 0.0 );\nivec2 offsetCameraTarget = ivec2( 1.0, 0.0 );\n\nivec2 addrPrevCamera = ivec2( 0.0, 2.0 );\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Storage\n\nvec4 LoadVec4( in ivec2 vAddr )\n{\n    return texelFetch( iChannel0, vAddr, 0 );\n}\n\nvec3 LoadVec3( in ivec2 vAddr )\n{\n    return LoadVec4( vAddr ).xyz;\n}\n\nbool AtAddress( vec2 p, ivec2 c ) { return all( equal( floor(p), vec2(c) ) ); }\n\nvoid StoreVec4( in ivec2 vAddr, in vec4 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in ivec2 vAddr, in vec3 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n\nmat3 QuatToMat3( const in vec4 q )\n{\n\tvec4 qSq = q * q;\n\tfloat xy2 = q.x * q.y * 2.0;\n\tfloat xz2 = q.x * q.z * 2.0;\n\tfloat yz2 = q.y * q.z * 2.0;\n\tfloat wx2 = q.w * q.x * 2.0;\n\tfloat wy2 = q.w * q.y * 2.0;\n\tfloat wz2 = q.w * q.z * 2.0;\n \n\treturn mat3 (\t\n     qSq.w + qSq.x - qSq.y - qSq.z, xy2 - wz2, xz2 + wy2,\n     xy2 + wz2, qSq.w - qSq.x + qSq.y - qSq.z, yz2 - wx2,\n     xz2 - wy2, yz2 + wx2, qSq.w - qSq.x - qSq.y + qSq.z );\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Rotation\n\nvec2 Rotate( const in vec2 vPos, const in float t )\n{\n    float s = sin(t);\n    float c = cos(t);\n    \n    return vec2( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y);\n}\n\nvec2 Rotate( const in vec2 vPos, const in vec2 sc )\n{\n    return vec2( sc.y * vPos.x + sc.x * vPos.y, -sc.x * vPos.x + sc.y * vPos.y);\n}\n\nvec3 RotX( const in vec3 vPos, float t )\n{\n    vec3 result;\n    result.x = vPos.x;\n  \tresult.yz = Rotate( vPos.yz, t );\n    return result;\n}\n\nvec3 RotY( const in vec3 vPos, float t )\n{\n    vec3 result;\n    result.y = vPos.y;\n  \tresult.xz = Rotate( vPos.xz, t );\n    return result;\n}\n\nvec3 RotZ( const in vec3 vPos, float t )\n{\n    vec3 result;\n    result.z = vPos.z;\n  \tresult.xy = Rotate( vPos.xy, t );\n    return result;\n}\n\nvec3 RotX( const in vec3 vPos, vec2 sc )\n{\n    vec3 result;\n    result.x = vPos.x;\n  \tresult.yz = Rotate( vPos.yz, sc );\n    return result;\n}\n\nvec3 RotY( const in vec3 vPos, vec2 sc )\n{\n    vec3 result;\n    result.y = vPos.y;\n  \tresult.xz = Rotate( vPos.xz, sc );\n    return result;\n}\n\nvec3 RotZ( const in vec3 vPos, vec2 sc )\n{\n    vec3 result;\n    result.z = vPos.z;\n  \tresult.xy = Rotate( vPos.xy, sc );\n    return result;\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\n\n\nfloat kFarClip=1000.0;\n\nvec2 GetWindowCoord( const in vec2 vUV );\nvec2 GetUVFromWindowCoord( const in vec2 vWindow );\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget );\nvec2 GetCameraWindowCoord(const in vec3 vWorldPos, const in vec3 vCameraPos, const in vec3 vCameraTarget);\nvec3 GetSceneColour( in vec3 vRayOrigin,  in vec3 vRayDir, out float fDepth );\nvec3 ApplyPostFX( const in vec2 vUV, const in vec3 vInput );\nvec3 Hash32( vec2 p );\n\nvec2 g_TyreTrackOrigin;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    g_pixelRandom = normalize( Hash32(fragCoord.xy + iTime) );\n    \n\tvec2 vUV = fragCoord.xy \/ iResolution.xy;\n\n\tvec3 vCameraPos = LoadVec3( addrCamera + offsetCameraPos );\n\tvec3 vCameraTarget = LoadVec3( addrCamera + offsetCameraTarget );\n    \n    g_TyreTrackOrigin = floor(vCameraPos.xz);\n    \n\tvec3 vRayOrigin = vCameraPos;\n\tvec3 vRayDir = GetCameraRayDir( GetWindowCoord(vUV), vCameraPos, vCameraTarget );\n\t\n    float fDepth;\n\tvec3 vResult = GetSceneColour(vRayOrigin, vRayDir, fDepth);\n    vResult = max( vResult, vec3(0.0));\n\t    \n\tfragColor = vec4(vResult, fDepth);\n}\n\n\/\/ CAMERA\n\nvec2 GetWindowCoord( const in vec2 vUV )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x \/ iResolution.y;\n\n\treturn vWindow;\t\n}\n\nvec2 GetUVFromWindowCoord( const in vec2 vWindow )\n{\n\tvec2 vScaledWindow = vWindow;\n    vScaledWindow.x *= iResolution.y \/ iResolution.x;\n    \n\t return vScaledWindow * 0.5 + 0.5;\n}\n\n\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget )\n{\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n\t\t\t\t\t\t\t  \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * 2.0);\n\n\treturn vDir;\n}\n\nvec2 GetCameraWindowCoord(const in vec3 vWorldPos, const in vec3 vCameraPos, const in vec3 vCameraTarget)\n{\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n\t\n    vec3 vOffset = vWorldPos - vCameraPos;\n    vec3 vCameraLocal;\n    vCameraLocal.x = dot(vOffset, vRight);\n    vCameraLocal.y = dot(vOffset, vUp);\n    vCameraLocal.z = dot(vOffset, vForward);\n\n    vec2 vWindowPos = vCameraLocal.xy \/ (vCameraLocal.z \/ 2.0);\n    \n    return vWindowPos;\n}\n\n\/\/ RAYTRACE\n\nstruct SurfaceInfo\n{\n    vec3 vUVW;\n    int iId;\n};\n\nstruct ClosestSurface\n{\n    float fDist;\n    SurfaceInfo surface;\n};\n    \nvoid ClosestSurfaceInit( inout ClosestSurface closest, int iId, vec3 vUVW )\n{\n    closest.fDist = kFarClip;\n    closest.surface.vUVW = vUVW;\n    closest.surface.iId = iId;\n}\n\n\nClosestSurface ClosestSurfaceUnion( const in ClosestSurface a, const in ClosestSurface b )\n{\n    if ( a.fDist < b.fDist )\n    {\n        return a;\n    }\n\n    return b;        \n}\n    \nstruct C_Intersection\n{\n\tvec3 vPos;\n\tfloat fDist;\t\n\tvec3 vNormal;\n    SurfaceInfo surface;\n};\n\nvec2 Segment( vec3 vPos, vec3 vP0, vec3 vP1 )\n{\n\tvec3 pa = vPos - vP0;\n\tvec3 ba = vP1 - vP0;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\t\n\treturn vec2( length( pa - ba*h ), h );\n}\n\nfloat SdCapsule( vec3 vPos, vec3 vP0, vec3 vP1, float r0, float r1 )\n{\n    vec2 vC = Segment( vPos, vP0, vP1 );\n    \n    return vC.x - mix(r0, r1, vC.y);\n}\n\nfloat SdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat SdSphere( vec3 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat UdRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)\/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Scene State\n\nstruct VehicleState\n{\n    vec3 vPos;\n    \n    vec4 qRot;\n    mat3 mRot;\n    \n\tvec4 vWheelState0;\n\tvec4 vWheelState1;\n\tvec4 vWheelState2;\n\tvec4 vWheelState3;\n    \n    vec4 vWheelSC0;\n    vec4 vWheelSC1;\n    vec4 vWheelSC2;\n    vec4 vWheelSC3;\n};\n\nstruct SceneState\n{\n    VehicleState vehicleState;\n};\n    \nSceneState SetupSceneState()\n{\n    SceneState sceneState;\n    \n    sceneState.vehicleState.vPos = LoadVec3( addrVehicle + offsetVehicleBody + offsetBodyPos );\n    \n    sceneState.vehicleState.qRot = LoadVec4( addrVehicle + offsetVehicleBody + offsetBodyRot );\n    sceneState.vehicleState.mRot = QuatToMat3( sceneState.vehicleState.qRot );\n\n    vec4 vWheelState0 = LoadVec4( addrVehicle + offsetVehicleWheel0 );\n    vec4 vWheelState1 = LoadVec4( addrVehicle + offsetVehicleWheel1 );\n    vec4 vWheelState2 = LoadVec4( addrVehicle + offsetVehicleWheel2 );\n    vec4 vWheelState3 = LoadVec4( addrVehicle + offsetVehicleWheel3 );\n    \n    sceneState.vehicleState.vWheelState0 = vWheelState0;\n    sceneState.vehicleState.vWheelState1 = vWheelState1;\n    sceneState.vehicleState.vWheelState2 = vWheelState2;\n    sceneState.vehicleState.vWheelState3 = vWheelState3;\n    \n    sceneState.vehicleState.vWheelSC0 = vec4( sin(vWheelState0.x), cos(vWheelState0.x), sin(vWheelState0.y), cos(vWheelState0.y) );\n    sceneState.vehicleState.vWheelSC1 = vec4( sin(vWheelState1.x), cos(vWheelState1.x), sin(vWheelState1.y), cos(vWheelState1.y) );\n    sceneState.vehicleState.vWheelSC2 = vec4( sin(vWheelState2.x), cos(vWheelState2.x), sin(vWheelState2.y), cos(vWheelState2.y) );\n    sceneState.vehicleState.vWheelSC3 = vec4( sin(vWheelState3.x), cos(vWheelState3.x), sin(vWheelState3.y), cos(vWheelState3.y) );\n    \n    return sceneState;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Random\n\n#define MOD2 vec2(4.438975,3.972973)\n#define MOD3 vec3(.1031,.11369,.13787)\n#define MOD4 vec4(.1031,.11369,.13787, .09987)\n#define HASHSCALE .1031\n\nfloat Hash( float p ) \n{\n    \/\/ https:\/\/www.shadertoy.com\/view\/4djSRW - Dave Hoskins\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);    \n}\n\nvec3 Hash31(float p)\n{\n    \/\/ https:\/\/www.shadertoy.com\/view\/4djSRW - Dave Hoskins\n   vec3 p3 = fract(vec3(p) * MOD3);\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nvec3 Hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nfloat SmoothNoise(in vec2 o) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat a = Hash(n+  0.0);\n\tfloat b = Hash(n+  1.0);\n\tfloat c = Hash(n+ 57.0);\n\tfloat d = Hash(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n    return res;\n}\n\nfloat FBM( vec2 p, float ps ) {\n\tfloat f = 0.0;\n    float tot = 0.0;\n    float a = 1.0;\n#ifndef FAST_VERSION\n    for( int i=0; i<3; i++)\n#endif\n    {\n        f += SmoothNoise( p ) * a;\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f \/ tot;\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Scene\n\n#define MAT_TERRAIN 1\n#define MAT_WOOD 2\n\n#define MAT_CAR_BODY 3\n#define MAT_CHROME 4\n#define MAT_GRILL 5\n#define MAT_BLACK_PLASTIC 5\n#define MAT_AXLE 5\n#define MAT_REAR 5\n#define MAT_WHEEL 6\n#define MAT_SUSPENSION 7\n\n\/\/ Motion blur mask\n#define MAT_FIRST_VEHICLE MAT_CAR_BODY\n\nfloat GetTerrainDistance( const vec3 vPos )\n{    \n    float fbm = FBM( vPos.xz * vec2(0.5, 1.0), 0.5 );\n    float fTerrainHeight = fbm * fbm;\n    fTerrainHeight = fTerrainHeight * (sin(vPos.x * 0.1) + 1.0) * 0.5 + vPos.y + 3.0;    \n    \n    \/\/float h = 1.0 - exp(-abs(vPos.x + 15.0) * 0.01);\n    \n    \/\/fTerrainHeight += sin(vPos.x * 0.05) * 5.0 * h;\n    \/\/fTerrainHeight += sin(vPos.z * 0.05) * 5.0 * h;\n    \n    #ifndef FAST_VERSION\n    {\n\t\t\/\/ Apply Tyre Track to Terrain\n        float fRange = 20.0;\n        vec2 vPrevFragOffset = vPos.xz - g_TyreTrackOrigin;\n        vec2 vPrevUV = ( (vPrevFragOffset \/ fRange) + 1.0 ) \/ 2.0;\n\n        vec4 vTrackSample = textureLod( iChannel3, vPrevUV, 0.0 );\n        float fDepth = vTrackSample.x * (1.0 + vTrackSample.y);\n        \n        fTerrainHeight += fDepth * 0.05;        \n    }\n\t#endif\n    \n\treturn fTerrainHeight;\n}\n\nClosestSurface GetRampClosestSurface( const vec3 vPos, const float fRampSeed )\n{\n    ClosestSurface closest;\n    \n    vec3 vHash = Hash31( fRampSeed );\n    \n    closest.surface.iId = MAT_WOOD;\n    closest.surface.vUVW = vPos.xyz;\n    \n    float fHeight = 2.0 + vHash.x * 6.0;\n    float fRadius = 10.0 + vHash.y * 20.0;\n    float fLedge = 2.0 + vHash.z * 3.0;\n        \n    float h2 = fRadius - fHeight;\n    float fLength = sqrt(fRadius * fRadius - h2 * h2);\n    fLength = fLength + fLedge;\n    closest.fDist = sdBox( vPos - vec3( 0.0, fHeight * 0.5, fLength * 0.5 ), vec3(3.0, fHeight * 0.5, fLength * 0.5));\n    \n\n    vec3 vCylDomain = vPos - vec3( 0.0, fRadius, 0.0 );\n    float fCylDist = length(vCylDomain.yz) - fRadius;\n    \n    \/\/closest.fDist = fCylDist;\n    \n    if ( -fCylDist > closest.fDist )\n    {\n        closest.fDist = -fCylDist;\n        closest.surface.iId = MAT_WOOD;\n    }\n    \/\/closest.fDist = max( closest.fDist, -fCylDist);\n    \n    return closest;\n}\n\nClosestSurface GetEnvironmentClosestSurface( const vec3 vPos )\n{\n    ClosestSurface terrainClosest;\n    terrainClosest.surface.iId = MAT_TERRAIN;\n    terrainClosest.surface.vUVW = vec3(vPos.xz,0.0);\n    terrainClosest.fDist = GetTerrainDistance( vPos );\n#ifdef FAST_VERSION\n    return terrainClosest;\n#else\n    float fRepeat = 100.0;\n    vec3 vRampDomain = vPos - vec3(-15.0, -3.0, 0.0);\n    float fRampUnitZ = vRampDomain.z \/ fRepeat + 0.5;\n    float fRampSeed = floor( fRampUnitZ );\n    vRampDomain.z = (fract(fRampUnitZ) - 0.5) * fRepeat;\n    ClosestSurface rampClosest = GetRampClosestSurface( vRampDomain, fRampSeed );\n\n    return ClosestSurfaceUnion( terrainClosest, rampClosest );\n#endif\n}\n\nfloat PlaneDist( const in vec3 vPos, const in vec3 vNormal, float fDist )\n{\n    return dot(vNormal.xyz, vPos) - fDist;\n}\n\nfloat PlaneDist( const in vec3 vPos, const in vec4 vPlane )\n{\n    return PlaneDist(vPos, vPlane.xyz, vPlane.w);\n}\n\n\n\n\nfloat CarBodyMin( float a, float b, float k )\n{\n    return smin(a, b, k);\n}\n  \nfloat CarBodyMax( float a, float b, float k )\n{\n    return -CarBodyMin(-a, -b, k);\n}\n\nfloat WheelArchCombine( float a, float b )\n{\n    float size = 0.1;\n    float r= clamp( 1.0 - abs(b) \/ size, 0.0, 1.0);\n    a -= r * r * size;\n    \n    return CarBodyMax(a, b, 0.1);\n}\n\nfloat GetWheelArchDist( vec3 vPos )\n{\n    vPos.y = max( vPos.y, 0.0 );\n    return  0.45 - length( vec2( length( vPos.zy ), vPos.x ));\n    \/\/return  0.45 - length( vPos.zy );\n}\n\nvec4 GetPlaneCoeffs( vec3 a, vec3 b, vec3 c )\n{\n    vec3 n = normalize( cross(a-b, b-c) );\n    float d = -dot( n, a );\n    \n    return vec4( n, d );\n}\n\n\nClosestSurface GetCarBodyClosestSurface( const in vec3 vCarPos )\n{\n    ClosestSurface closest;\n    \n#ifdef SHOW_PHYSICS_SHAPE\n    vec4 vSpheres[6];\n    vSpheres[0] = vec4(0.7, 0.7, 1.5, 0.5 );\n    vSpheres[1] = vec4(-0.7, 0.7, 1.5, 0.5 );\n    vSpheres[2] = vec4(0.7, 0.7, -1.5, 0.5 );\n    vSpheres[3] = vec4(-0.7, 0.7, -1.5, 0.5 );\n    vSpheres[4] = vec4(0.5, 1.0, 0.0, 0.7 );\n    vSpheres[5] = vec4(-0.5, 1.0, 0.0, 0.7 );    \n\n\tclosest.surface.vUVW = vCarPos.xyz;\n    closest.surface.fId = MAT_CAR_BODY;\n    closest.fDist = kFarClip;\n    \n    for (int s=0; s<6; s++)\n    {\n        float d = length( vCarPos.xyz - vSpheres[s].xyz) - vSpheres[s].w;\n        \n        closest.fDist = min( closest.fDist, d );\n    }\n#else    \n    \n    vec3 vAbsBodyPos = vCarPos - vec3(0.0, 0.3, 0.0);\n\n    vec3 vBodyPos = vAbsBodyPos;\n    vBodyPos.x = abs(vBodyPos.x);\n\tclosest.surface.vUVW = vAbsBodyPos.xyz;\n    closest.surface.iId = MAT_CAR_BODY;\n   \n    \/\/closest.fDist = SdBox( vBodyPos - vec3(0.0, 0.5, 0.0), vec3(0.7, 0.2, 1.5)-0.2)  -0.2;\n    \n    vec3 vFrontWheelPos = -vec3( 0.0, -0.1, -1.25 ) ;\n    vec3 vRearWheelPos = -vec3( 0.0, -0.1, 1.25 ) ;\n\n    vec3 vWheelPos = vBodyPos - vFrontWheelPos;\n    \n    float fSeparation = (vFrontWheelPos.z - vRearWheelPos.z) * 0.5;\n    vWheelPos.z = abs(vWheelPos.z + fSeparation ) - fSeparation;\n    vWheelPos.x = abs(vWheelPos.x) - 0.8;\n    \n    float fWheelArchDist = GetWheelArchDist( vWheelPos );\n    \n\n    \n    float fBodyBaseDist = kFarClip;\n\n    {\n        float fTopDist = PlaneDist( vBodyPos, normalize(vec3(0.0, 1.0, 0.0)), 0.8 );\n        float fFrontDist = PlaneDist( vBodyPos, normalize(vec3(0.0, 0.2, 1.0)), 1.9 );    \n        float fSideDist = PlaneDist( vBodyPos, normalize(vec3(1.0, -0.1, 0.0)), 0.85 );\n        float fBaseDist = PlaneDist( vBodyPos, normalize(vec3(0.0, -1.0, 0.0)), -0.1 );\n        float fBackDist = PlaneDist( vBodyPos, normalize(vec3(0.0, 0.0, -1.0)), 2.0 );\n\n        float fX = abs(vBodyPos.x);\n        fTopDist += fX * fX * 0.05;\n        fFrontDist += fX * fX * 0.1;\n        \n        float fSmooth = 0.2;\n\n        float fFrontTopDist = CarBodyMax( fTopDist, fFrontDist, 0.2 );\n\n        fBodyBaseDist = fFrontTopDist;\n        fBodyBaseDist = CarBodyMax( fBodyBaseDist, fSideDist, 0.3 );\n\n        float fBaseBackDist = CarBodyMax( fBaseDist, fBackDist, 0.1 );\n        fBodyBaseDist = CarBodyMax( fBodyBaseDist, fBaseBackDist, 0.1 );\n    }\n\n    fBodyBaseDist = WheelArchCombine( fBodyBaseDist, fWheelArchDist );   \n            \n    float fBodyTopDist = kFarClip;\n\n    {\n        float fTopDist = PlaneDist( vBodyPos, normalize(vec3(0.0, 1.0, 0.0)), 1.3 );\n        float fFrontDist = PlaneDist( vBodyPos, normalize(vec3(0.0, 1.0, 0.7)), 1.1 );    \n        float fSideDist = PlaneDist( vBodyPos, normalize(vec3(1.0, 0.4, 0.0)), 1.03 );\n        float fBaseDist = PlaneDist( vBodyPos, normalize(vec3(0.0, -1.0, 0.0)), -0.7);\n        float fBackDist = PlaneDist( vBodyPos, normalize(vec3(0.0, 0.0, -1.0)), 0.55 );\n\n        float fX = abs(vBodyPos.x);\n        fTopDist += fX * fX * 0.1;\n        \n        float fFrontTopDist = CarBodyMax( fTopDist, fFrontDist, 0.1 );\n\n        fBodyTopDist = fFrontTopDist;\n        fBodyTopDist = CarBodyMax( fBodyTopDist, fSideDist, 0.1 );\n\n        float fBaseBackDist = CarBodyMax( fBaseDist, fBackDist, 0.1 );\n        fBodyTopDist = CarBodyMax( fBodyTopDist, fBaseBackDist, 0.1 );\n    }\n        \n    \/\/fBodyTopDist = SdBox( vBodyPos - vec3(0.0, 0.5, -0.5), vec3(0.7, 0.5, 1.0)-0.2)  -0.2;\n    \n    \/\/float fDistDome = SdSphere( vBodyPos - vec3(0.0, -0.5, -0.5), 2.0 );\n    \/\/float fDistBase = -vBodyPos.y;\n    \n    \/\/closest.fDist = max( fDistDome, fDistBase );\n    \n    closest.fDist = fBodyBaseDist;\n    \n    closest.fDist = smin( closest.fDist, fBodyTopDist, 0.1);\n    \n#ifndef FAST_VERSION    \n    float fRearSpace = SdBox( vBodyPos - vec3(0.0, 0.8, -1.3), vec3(0.7, 0.35, 0.65) - 0.05) - 0.05 ;\n    \n    fRearSpace = -min(-fRearSpace, -(fWheelArchDist + 0.02) );\n    \n    if( fRearSpace < -closest.fDist )\n    {\n        closest.fDist = -fRearSpace;\n        closest.surface.iId = MAT_REAR;\n    }\n    \n    \n   \tClosestSurface mirrorClosest;\n    vec3 vMirrorDomain = vBodyPos - vec3(0.875, 0.9, 0.55);\n    vMirrorDomain.z += vMirrorDomain.x * 0.1;\n    mirrorClosest.fDist = SdBox( vMirrorDomain, vec3(0.125, 0.1, 0.06)-0.05)  -0.05;\n\tmirrorClosest.surface.vUVW = vBodyPos.xyz - vec3(0.5);\n    mirrorClosest.surface.iId = MAT_CAR_BODY;    \n    if ( mirrorClosest.fDist < -vMirrorDomain.z )\n    {                \n        if ( mirrorClosest.fDist < -0.01 )\n        {\n    \t\tmirrorClosest.surface.iId = MAT_CHROME;    \n        }\n        \n        mirrorClosest.fDist = -vMirrorDomain.z;        \n    }\n    \n    closest = ClosestSurfaceUnion( closest, mirrorClosest );\n\n    \n   \t\/*ClosestSurface grillClosest;\n    vec3 vGrillDomain = vBodyPos - vec3(0.0, 0.55, 1.85);\n    vGrillDomain.z += vGrillDomain.y * 0.2;\n    float fGrillDist = UdRoundBox( vGrillDomain, vec3(0.85, 0.05, 0.0), 0.1);\n    if ( fGrillDist < closest.fDist )\n    {\n        closest.surface.fId = MAT_GRILL;\n    }*\/\n    \n    \/*ClosestSurface lightClosest;\n    vec3 vLightDomain = vBodyPos - vec3(0.5, 0.5, 2.0);\n    if( vBodyPos.z < 0.5 )\n    {\n        vLightDomain = vBodyPos - vec3(0.3, 1.5, -0.2);\n    }\n    lightClosest.fDist = length(vLightDomain) - 0.15;\n    float fFrontDist = length(vLightDomain + vec3(0.0, 0.0, 0.52)) - 0.5;\n    lightClosest.fDist = -min( -lightClosest.fDist, -fFrontDist );\n\tlightClosest.surface.vUVW = vAbsBodyPos.xyz;\n    lightClosest.surface.fId = MAT_CHROME; \n\n    closest = ClosestSurfaceUnion( closest, lightClosest );*\/\n\t\n#endif    \n#endif\n    return closest;\n}\n\nfloat g_fWheelR = 0.45;\nfloat g_fWheelW = 0.25;\nClosestSurface GetWheelClosestSurface( vec3 vPos )\n{   \n    float theta = atan( vPos.z, vPos.y );\n    float r = length( vPos.zy );    \n    float x = vPos.x;\n        \n    float fr = r * ( 1.0 \/ g_fWheelR );\n    \n    if( fr < 0.5 )\n    {\n        x += 0.01 * clamp((0.5 - fr) * 30.0, 0.0, 1.0);\n        \n        if( fr < 0.3 )\n        {\n            float unitr = fr \/ 0.3;\n            x = x + sqrt(1.0 - unitr * unitr) * 0.05;\n            \/\/x = x + 0.01;\n        }    \n    }\n    else\n    {\n#ifndef FAST_VERSION    \n        \n        float fX = x * (1.0 \/ g_fWheelW);\n        float tread = sin(theta * 15.0 + abs(fX) * 4.0);\n        \n        float treadThickness = 1.0 - clamp( 0.9 - fX * fX * 0.3, 0.0, 1.0 );\n\t    \n        r = -min( -r, -(r + abs(tread) * treadThickness * 0.05 + 0.025));\n#endif\n    }\n    \n    float fRound = 0.1;\n    \n    float fWheelR = g_fWheelR - fRound;\n    float fWheelW = g_fWheelW - fRound;       \n    \n    vec2 rx = vec2( r,x );\n\n    ClosestSurface closest;\n    closest.surface.iId = MAT_WHEEL;\n    closest.surface.vUVW = vPos.yzx;\n    closest.fDist = length( max( abs(rx) - vec2(fWheelR, fWheelW), 0.0)) - fRound;\n        \n    return closest;\n}\n\nClosestSurface GetVehicleClosestSurface( const in VehicleState vehicleState, const vec3 vPos )\n{\n    ClosestSurface closest;\n    \n    \/*\n    float fCullDist = length( vPos - vVehPos );\n    if ( fCullDist > 3.5 ) \n    {\n        closest.fDist = fCullDist - 1.0;\n        closest.surface.fId = 0.0;\n        closest.surface.vUVW = vec3(0.0);\n        return closest;\n    }\n\t*\/        \n    \n    \n    vec3 vLocalPos = vehicleState.mRot * (vPos - vehicleState.vPos);\n    \n    \n    \/\/closest.fDist = 10000.0;\n    \/\/closest.surface.fId = 0.0;\n    \/\/closest.surface.vUVW = vec3(0.0);    \n    closest = GetCarBodyClosestSurface( vLocalPos );\n    \n\tvec3 vWheelPos0 = vec3( -0.9, -0.1, 1.25 );\n\tvec3 vWheelPos1 = vec3(  0.9, -0.1, 1.25 );\n\tvec3 vWheelPos2 = vec3( -0.9, -0.1, -1.25 );\n\tvec3 vWheelPos3 = vec3(  0.9, -0.1, -1.25 );        \n        \n    \n    vec3 vWheelOrigin;\n    vec4 vWheelState;\n    vec4 vWheelSC;\n\n    if ( vLocalPos.z > 0.0 )\n    {\n        if ( vLocalPos.x < 0.0 )\n        {\n            vWheelOrigin = vWheelPos0;\n            vWheelState = vehicleState.vWheelState0;\n            vWheelSC = vehicleState.vWheelSC0;\n        }\n        else\n        {\n            vWheelOrigin = vWheelPos1;\n            vWheelState = vehicleState.vWheelState1;\n            vWheelSC = vehicleState.vWheelSC1;\n        }\n    }\n    else\n    {\n        if ( vLocalPos.x < 0.0 )\n        {\n            vWheelOrigin = vWheelPos2;\n            vWheelState = vehicleState.vWheelState2;\n            vWheelSC = vehicleState.vWheelSC2;\n        }\n        else\n        {\n            vWheelOrigin = vWheelPos3;\n            vWheelState = vehicleState.vWheelState3;\n            vWheelSC = vehicleState.vWheelSC3;\n        }\n    }\n    \n    vec3 vWheelPos = vWheelOrigin;\n    float fWheelSide = sign(vWheelOrigin.x);\n    \n    vWheelPos.y -= vWheelState.z - g_fWheelR;\n    vec3 vWheelLocalPos = vWheelPos - vLocalPos;\n    vWheelLocalPos = RotY( vWheelLocalPos, vWheelSC.xy );        \n    vWheelLocalPos = RotX( vWheelLocalPos, vWheelSC.zw );    \n    vWheelLocalPos.x *= -fWheelSide;\n    closest = ClosestSurfaceUnion( closest, GetWheelClosestSurface( vWheelLocalPos ) );\n    \n#ifndef FAST_VERSION    \n    vec3 vAxleOrigin = vWheelOrigin;\n    vAxleOrigin.x = 0.0;\n    vAxleOrigin.y = 0.25;\n    vec3 vAxleEnd = vWheelPos;\n    vAxleEnd.x = 0.9 * fWheelSide;\n    float cDist0 = SdCapsule(vLocalPos, vAxleOrigin, vAxleEnd, 0.05, 0.05);\n    if( cDist0 < closest.fDist )\n    {\n        closest.surface.iId = MAT_AXLE;\n        closest.fDist = cDist0;\n    }\n    \n    float fSuspensionTop = 0.6;\n    \n    vec3 vSuspensionOrigin = vWheelOrigin;\n    vSuspensionOrigin.x -= 0.4 * fWheelSide;\n    vSuspensionOrigin.y = fSuspensionTop;\n    \/\/vSuspensionOrigin.z *= 0.9;\n\n    vec3 vSuspensionDomain = vLocalPos - vSuspensionOrigin;\n    vSuspensionDomain.z = abs(vSuspensionDomain.z) - 0.1;    \n    \n    vec3 vSuspensionEnd = vec3(0.03 * fWheelSide, -fSuspensionTop + (vWheelPos.y - vWheelOrigin.y) * 0.8, 0.0);\n    \/\/vec3 vSuspensionEnd = vWheelPos;\n    \/\/vSuspensionEnd.x = 0.5 * fWheelSide;\n    \/\/vSuspensionEnd.y += 0.05;\n    \/\/vec3 vSuspensionDomain = vLocalPos - vSuspensionOrigin;\n    float cDist1 = SdCapsule(vSuspensionDomain, vec3(0.0), vSuspensionEnd, 0.05, 0.05);\n    if( cDist1 < closest.fDist )\n    {\n        closest.surface.iId = MAT_SUSPENSION;\n        closest.fDist = cDist1;\n        closest.surface.vUVW = vSuspensionDomain;\n        closest.surface.vUVW.y = closest.surface.vUVW.y \/ vSuspensionEnd.y;\n    }\n#endif \n    \n    return closest;\n}\n\n\n\nClosestSurface GetSceneClosestSurface( const in SceneState sceneState, const vec3 vPos )\n{    \n    ClosestSurface closest;\n    \n    ClosestSurfaceInit( closest, MAT_TERRAIN, vec3( 0.0 ) );\n        \n    ClosestSurface terrainClosest = GetEnvironmentClosestSurface( vPos );\n    ClosestSurface vehicleClosest = GetVehicleClosestSurface( sceneState.vehicleState, vPos );\n    closest = ClosestSurfaceUnion( terrainClosest, vehicleClosest );\n    \n    return closest;\n}\n\nvec3 GetSceneNormal( const in SceneState sceneState, const in vec3 vPos )\n{\n    const float fDelta = 0.0005;\n\n    vec3 vDir1 = vec3( 1.0, -1.0, -1.0);\n    vec3 vDir2 = vec3(-1.0, -1.0,  1.0);\n    vec3 vDir3 = vec3(-1.0,  1.0, -1.0);\n    vec3 vDir4 = vec3( 1.0,  1.0,  1.0);\n\t\n    vec3 vOffset1 = vDir1 * fDelta;\n    vec3 vOffset2 = vDir2 * fDelta;\n    vec3 vOffset3 = vDir3 * fDelta;\n    vec3 vOffset4 = vDir4 * fDelta;\n\n    ClosestSurface c1 = GetSceneClosestSurface( sceneState, vPos + vOffset1 );\n    ClosestSurface c2 = GetSceneClosestSurface( sceneState, vPos + vOffset2 );\n    ClosestSurface c3 = GetSceneClosestSurface( sceneState, vPos + vOffset3 );\n    ClosestSurface c4 = GetSceneClosestSurface( sceneState, vPos + vOffset4 );\n\t\n    vec3 vNormal = vDir1 * c1.fDist + vDir2 * c2.fDist + vDir3 * c3.fDist + vDir4 * c4.fDist;\t\n\t\t\n    return normalize( vNormal );\n}\n\nvoid TraceScene( const in SceneState sceneState, out C_Intersection outIntersection, const in vec3 vOrigin, const in vec3 vDir )\n{\t\n\tvec3 vPos = vec3(0.0);\n\t\n\tfloat t = 0.1;\n\tconst int kRaymarchMaxIter = 64;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\n\t\tfloat fClosestDist = GetSceneClosestSurface( sceneState, vOrigin + vDir * t ).fDist;\n\t\tt += fClosestDist;\n\t\tif(abs(fClosestDist) < 0.01)\n\t\t{\n\t\t\tbreak;\n\t\t}\t\t\n\t\tif(t > kFarClip)\n\t\t{\n\t\t\tt = kFarClip;\n\t\t\tbreak;\n\t\t}\n\t}\n    \n\toutIntersection.fDist = t;\n\toutIntersection.vPos = vOrigin + vDir * t;\n    \n    if( t >= kFarClip )\n    {\n        outIntersection.surface.iId = 0;\n        outIntersection.surface.vUVW = vec3( 0.0 );\n        outIntersection.vNormal = vec3(0.0, 1.0, 0.0);\n    }\n    else\n    {\n\t\toutIntersection.vNormal = GetSceneNormal( sceneState, outIntersection.vPos );\n        outIntersection.surface = GetSceneClosestSurface( sceneState, outIntersection.vPos ).surface;\n    }\n}\n\n#define SOFT_SHADOW\n\nfloat TraceShadow( const in SceneState sceneState, const in vec3 vOrigin, const in vec3 vDir, const in float fDist )\n{\n#ifndef SOFT_SHADOW\n\tC_Intersection shadowIntersection;\n\tTraceScene(sceneState, shadowIntersection, vOrigin, vDir);\n\tif(shadowIntersection.fDist < fDist) \n\t{\n\t\treturn 0.0;\t\t\n\t}\n\t\n\treturn 1.0;\n#else\t\n\t#define kShadowIter 32\n\t#define kShadowFalloff 10.0\n\tfloat fShadow = 1.0;\n\tfloat t = 0.01;\n\tfloat fDelta = 2.5 \/ float(kShadowIter);\n\tfor(int i=0; i<kShadowIter; i++)\n\t{\n\t\tvec4 vUnused;\n\t\tClosestSurface closest = GetSceneClosestSurface( sceneState, vOrigin + vDir * t );\n\t\t\n\t\tfShadow = min( fShadow, kShadowFalloff * closest.fDist \/ t );\n\t\t\n\t\tt = t + fDelta;\n\t}\n\n\treturn clamp(fShadow, 0.0, 1.0);\n#endif\n}\n\n\/\/ AMBIENT OCCLUSION\n\nfloat GetAmbientOcclusion( const in SceneState sceneState, const in vec3 vPos, const in vec3 vNormal )\n{\n\tfloat fAmbientOcclusion = 0.0;\n#ifndef FAST_VERSION    \n\t\n\tfloat fStep = 0.1;\n\tfloat fDist = 0.0;\n\tfor(int i=0; i<=5; i++)\n\t{\n\t\tfDist += fStep;\n\t\t\n\t\tvec4 vUnused;\n        \n\t\tClosestSurface closest = GetSceneClosestSurface( sceneState, vPos + vNormal * fDist );\n\t\t\n\t\tfloat fAmount = (fDist - closest.fDist);\n\t\t\n\t\tfAmbientOcclusion += max(0.0, fAmount * fDist );                                  \n\t}\n#endif\t\n\treturn max(1.0 - fAmbientOcclusion, 0.0);\n}\n\n\/\/ LIGHTING\n\nvoid AddLighting(inout vec3 vDiffuseLight, inout vec3 vSpecularLight, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vNormal, const in float fSmoothness, const in vec3 vLightColour)\n{\n\tfloat fNDotL = clamp(dot(vLightDir, vNormal), 0.0, 1.0);\n\tvec3 vHalfAngle = normalize(-vViewDir + vLightDir);\n    float fNDotH = clamp(dot(vHalfAngle, vNormal), 0.0, 1.0);\n\t\n\tvDiffuseLight += vLightColour * fNDotL;\n\t\n\tfloat fSpecularPower = exp2(4.0 + 6.0 * fSmoothness);\n\tfloat fSpecularIntensity = (fSpecularPower + 2.0) * 0.125;\n\tvSpecularLight += vLightColour * fSpecularIntensity * clamp(pow(fNDotH, fSpecularPower), 0.0, 1.0) * fNDotL;\n}\n\nvoid AddPointLight(const in SceneState sceneState, inout vec3 vDiffuseLight, inout vec3 vSpecularLight, const in vec3 vViewDir, const in vec3 vPos, const in vec3 vNormal, const in float fSmoothness, const in vec3 vLightPos, const in vec3 vLightColour)\n{\n\tvec3 vToLight = vLightPos - vPos;\t\n\tfloat fDistance2 = dot(vToLight, vToLight);\n\tfloat fAttenuation = 100.0 \/ (fDistance2);\n\tvec3 vLightDir = normalize(vToLight);\n\t\n\tvec3 vShadowRayDir = vLightDir;\n\tvec3 vShadowRayOrigin = vPos + vShadowRayDir * 0.01;\n\tfloat fShadowFactor = TraceShadow( sceneState, vShadowRayOrigin, vShadowRayDir, length(vToLight));\n\t\n\tAddLighting(vDiffuseLight, vSpecularLight, vViewDir, vLightDir, vNormal, fSmoothness, vLightColour * fShadowFactor * fAttenuation);\n}\n\nvoid AddPointLightFlare(inout vec3 vEmissiveGlow, const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fIntersectDistance, const in vec3 vLightPos, const in vec3 vLightColour)\n{\n    vec3 vToLight = vLightPos - vRayOrigin;\n    float fPointDot = dot(vToLight, vRayDir);\n    fPointDot = clamp(fPointDot, 0.0, fIntersectDistance);\n\n    vec3 vClosestPoint = vRayOrigin + vRayDir * fPointDot;\n    float fDist = length(vClosestPoint - vLightPos);\n\tvEmissiveGlow += sqrt(vLightColour * 0.05 \/ (fDist * fDist));\n}\n\nvoid AddDirectionalLight(const in SceneState sceneState, inout vec3 vDiffuseLight, inout vec3 vSpecularLight, const in vec3 vViewDir, const in vec3 vPos, const in vec3 vNormal, const in float fSmoothness, const in vec3 vLightDir, const in vec3 vLightColour)\n{\t\n\tfloat fAttenuation = 1.0;\n\n\tvec3 vShadowRayDir = -vLightDir;\n\tvec3 vShadowRayOrigin = vPos + vShadowRayDir * 0.01;\n\tfloat fShadowFactor = TraceShadow(sceneState, vShadowRayOrigin, vShadowRayDir, 10.0);\n\t\n\tAddLighting(vDiffuseLight, vSpecularLight, vViewDir, -vLightDir, vNormal, fSmoothness, vLightColour * fShadowFactor * fAttenuation);\t\n}\n\nvoid AddDirectionalLightFlareToFog(inout vec3 vFogColour, const in vec3 vRayDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\n\tfloat fDirDot = clamp(dot(-vLightDir, vRayDir) * 0.5 + 0.5, 0.0, 1.0);\n\tfloat kSpreadPower = 5.0;\n\tvFogColour += vLightColour * pow(fDirDot, kSpreadPower) * 0.5;\n}\n\n\/\/ SCENE MATERIALS\n\nvec3 ProjectedTexture( vec3 pos, vec3 normal )\n{\n    vec3 vWeights = normal * normal;\n    vec3 col = vec3(0.0);\n    vec3 samplev;\n    samplev = texture( iChannel1, pos.xz ).rgb;\n    col += samplev * samplev * vWeights.y;\n    samplev = texture( iChannel1, pos.xy ).rgb;\n    col += samplev * samplev * vWeights.z;\n    samplev = texture( iChannel1, pos.yz ).rgb;\n    col += samplev * samplev * vWeights.x;\n    col \/= vWeights.x + vWeights.y + vWeights.z;\n    return col;    \n}\n\nvoid GetSurfaceInfo( out vec3 vOutAlbedo, out float fOutR0, out float fOutSmoothness, out vec3 vOutBumpNormal, const in C_Intersection intersection )\n{\n\tvOutBumpNormal = intersection.vNormal;\n    \n    \/*if(false)\n    {\n\t\tvOutAlbedo = vec3(0.1);\n\t\tfOutSmoothness = 0.0;\t\t\t\n\t\tfOutR0 = 0.02;   \n        return;\n    }*\/\n        \n    \n    float fRange = 20.0;\n    vec2 vPrevFragOffset = intersection.vPos.xz - g_TyreTrackOrigin;\n    vec2 vPrevUV = ( (vPrevFragOffset \/ fRange) + 1.0 ) \/ 2.0;\n\n    vec4 vTrackSample = texture( iChannel3, vPrevUV );            \n    \n    if ( vPrevUV.x < 0.0 || vPrevUV.x >=1.0 || vPrevUV.y < 0.0 || vPrevUV.y >= 1.0 )\n    {\n        vTrackSample = vec4(0.0);\n    }\n\t\n\tfOutR0 = 0.02;\n\n    switch (intersection.surface.iId )       \n\t{\n        case MAT_TERRAIN:\n        {\n            vec2 vUV = intersection.surface.vUVW.xy * 0.1;\n            vOutAlbedo = texture(iChannel1, vUV).rgb;\n\n            #ifndef FAST_VERSION\n            float fBumpScale = 1.0;\n\n            vec2 vRes = iChannelResolution[0].xy;\n            vec2 vDU = vec2(1.0, 0.0) \/ vRes;\n            vec2 vDV = vec2(0.0, 1.0) \/ vRes;\n\n            float fSampleW = texture(iChannel1, vUV - vDU).r;\n            float fSampleE = texture(iChannel1, vUV + vDU).r;\n            float fSampleN = texture(iChannel1, vUV - vDV).r;\n            float fSampleS = texture(iChannel1, vUV + vDV).r;\n\n            vec3 vNormalDelta = vec3(0.0);\n            vNormalDelta.x += \n                ( fSampleW * fSampleW\n                 - fSampleE * fSampleE) * fBumpScale;\n            vNormalDelta.z += \n                (fSampleN * fSampleN\n                 - fSampleS * fSampleS) * fBumpScale;\n\n            vOutBumpNormal = normalize(vOutBumpNormal + vNormalDelta);\n            #endif\n\n            vOutAlbedo = vOutAlbedo * vOutAlbedo;\t\n            fOutSmoothness = vOutAlbedo.r * 0.3;\n\n            \/\/if(false)\n            {       \n                \/\/ Tyre tracks\n                float fDepth = vTrackSample.x * (1.0 + vTrackSample.y);\n\n                \/\/vec3 vTex2 = texture(iChannel2, vUV).rgb;\n                vec3 vTex2 = mix( vOutAlbedo, vec3( 0.9, 0.3, 0.01 ), 0.5);\n                vOutAlbedo = mix( vOutAlbedo, vTex2, fDepth );\n\n                \/\/vOutAlbedo *= 1.0 - 0.2 * vTrackSample.r;\n\n                vOutAlbedo *= 1.0 - 0.6 * vTrackSample.g;\n                fOutSmoothness = mix( fOutSmoothness, fOutSmoothness * 0.75 + 0.25, fDepth );                        \n            }  \n        }\n        break;\n        \n        case MAT_BLACK_PLASTIC:\n        {\n            vec2 vUV = intersection.surface.vUVW.xy;\n            vOutAlbedo = texture(iChannel1, vUV).rgb;\n            vOutAlbedo = vOutAlbedo * vOutAlbedo;\t\n            vOutAlbedo *= 0.01;\n            fOutSmoothness = 0.1;\/\/vOutAlbedo.r;\t\t\t\n\n            vec3 vDirt = (texture(iChannel1, intersection.surface.vUVW.zy).rgb + texture(iChannel1, intersection.surface.vUVW.xy).rgb) * 0.5;\n            float fDirt = vDirt.r;\n\n            float fMix = clamp( fDirt - intersection.surface.vUVW.y * 2.5 + 0.8, 0.0, 1.0 );\n\n            vDirt = vDirt * vDirt * 0.1;\n\n            vOutAlbedo = mix( vOutAlbedo, vDirt, fMix );\n            fOutSmoothness = mix( fOutSmoothness, 0.01, fMix );        \n\n        }\n        break;\n                \n\t\tcase MAT_CHROME:\n        {\n            vOutAlbedo = vec3(0.1);\n            fOutSmoothness = 1.0;\t\t\t\n            fOutR0 = 0.9;\n        }\n        break;\n        \n\t\tcase MAT_CAR_BODY:\n        {\n            vOutAlbedo = vec3(0.0, 0.0, 1.0);\n\n            float fAbsX = abs( intersection.surface.vUVW.x );\n\n            fOutSmoothness = 1.0;\n\n            float fStripe = abs(fAbsX - (0.15));\n            fStripe = smoothstep( 0.1 + 0.01, 0.1 - 0.01, fStripe);\n\n            vOutAlbedo = mix( vOutAlbedo, vec3(1.0, 1.0, 1.0), fStripe);\n\n            if ( intersection.surface.vUVW.y < 0.85 )\n            {\n                float fLine = abs(intersection.surface.vUVW.z - 0.7);\n                fLine = min( fLine, abs(intersection.surface.vUVW.z + 0.6) );\n                fLine = min( fLine, abs(fAbsX - 0.65) );\n                fLine = min( fLine, abs(intersection.surface.vUVW.y - 0.2) );\n                fLine = clamp( (fLine - 0.005) \/ 0.01, 0.0, 1.0);\n                vOutAlbedo *= fLine;\n                fOutR0 *= fLine;\n                fOutSmoothness *= fLine;\n\n            }\n\n            if(fAbsX > 0.92 )\n            {\n                vOutAlbedo = vec3(0.02, 0.02, 0.02);\n                fOutSmoothness = 0.2;\n            }\n\n            if( intersection.surface.vUVW.y > 0.85 && intersection.surface.vUVW.y < 1.2)\n            {\n                bool bFront = (intersection.surface.vUVW.z + intersection.surface.vUVW.y * 1.25 )  > 1.6;\n                bool bRear = (intersection.surface.vUVW.z)  < -0.45;\n                bool bSide = (fAbsX +intersection.surface.vUVW.y * 0.3) > 0.9;\n\n                if ( !(bFront && bSide) && !(bRear && bSide))\n                {\n                    vOutAlbedo = vec3(0.0, 0.0, 0.0);\n                    fOutR0 = 0.02;\n                    fOutSmoothness = 0.9;\n                }\n            }\n\n            vec3 vGrillDomain = intersection.surface.vUVW - vec3(0.0, 0.55, 1.85);\n            float fGrillDist = UdRoundBox( vGrillDomain, vec3(0.85, 0.05, 0.0), 0.1);\n            if ( fGrillDist < 0.0 )\n            {\n                vOutAlbedo = vec3(0.0, 0.0, 0.0);\n                fOutR0 = 0.02;\n            }        \n\n            vec3 vLightDomain = intersection.surface.vUVW;\n            vLightDomain.x = abs( vLightDomain.x );\n            vLightDomain -= vec3(0.6, 0.56, 1.85);\n            float fLightDist = UdRoundBox( vLightDomain, vec3(0.1, 0.04, 0.5), 0.05);\n            if ( fLightDist < 0.0 )\n            {\n                vOutAlbedo = vec3(0.5);\n                fOutR0 = 1.0;\n                fOutSmoothness = 0.8;\n            }\n\n\n            vec3 vDirt = (texture(iChannel1, intersection.surface.vUVW.zy).rgb + texture(iChannel1, intersection.surface.vUVW.xy).rgb) * 0.5;\n            float fDirt = vDirt.r;\n\n            float fMix = clamp( fDirt - intersection.surface.vUVW.y * 1.5 + 0.8, 0.0, 1.0 );\n\n            vDirt = vDirt * vDirt * 0.1;\n\n            vOutAlbedo = mix( vOutAlbedo, vDirt, fMix );\n            fOutR0 = mix( fOutR0, 0.01, fMix );\n            fOutSmoothness = mix( fOutSmoothness, 0.01, fMix );\n\n            \/\/vOutR0 = vec3(0.7, 0.5, 0.02);\n            \/\/vOutAlbedo = vOutR0 * 0.01;\n\n        }\n       \tbreak;\n        \n\t\tcase MAT_WHEEL:\n        {\n            vec2 vUV = intersection.surface.vUVW.xy;\n            vOutAlbedo = texture(iChannel2, vUV).rgb;\n            vOutAlbedo = vOutAlbedo * vOutAlbedo;\t\n            vOutAlbedo *= 0.01;\n            float len = length(vUV);\n            float fR = len * (1.0 \/ g_fWheelR);\n            if ( fR < 0.5 )\n            {\n                fOutSmoothness = 1.0;        \n                fOutR0 = 1.0;\n            }\n            else\n            {\n                fOutSmoothness = 0.1;\n            }\n\n            vec3 vDirt = (texture(iChannel1, intersection.surface.vUVW.zy).rgb + texture(iChannel1, intersection.surface.vUVW.xy).rgb) * 0.5;\n\n            float fDirt = vDirt.r;\n            fDirt = sqrt(fDirt);\n\n            float fMix = clamp( fDirt - (1.0 - fR) * 1.0 + 0.8, 0.0, 1.0 );\n\n            vDirt = vDirt * vDirt * 0.1;\n\n            vOutAlbedo = mix( vOutAlbedo, vDirt, fMix );\n            fOutR0 = mix( fOutR0, 0.01, fMix );\n            fOutSmoothness = mix( fOutSmoothness, 0.01, fMix );\n\n        }\n        break;\n        \n    \tcase MAT_SUSPENSION:\n        {\n            vOutAlbedo = vec3(0.1);\n            fOutSmoothness = 1.0;\t\t\t\n            fOutR0 = 0.9;\n\n            float fY = intersection.surface.vUVW.y;\n\n            float fAngle = atan(intersection.surface.vUVW.x, intersection.surface.vUVW.y);        \n            fAngle -= fY * 30.0;\n            float fFAngle = fract(fAngle \/ (3.1415 * 2.0));\n            if ( fFAngle < 0.5 )\n            {\n                fOutR0 = 0.0;\n                vOutAlbedo = vec3(0.0);            \n            }\n\n            vec3 vDirt = (texture(iChannel1, intersection.surface.vUVW.zy).rgb + texture(iChannel1, intersection.surface.vUVW.xy).rgb) * 0.5;\n\n            float fDirt = vDirt.r;\n            fDirt = sqrt(fDirt);\n\n            float fMix = clamp( fDirt + 0.1, 0.0, 1.0 );\n\n            vDirt = vDirt * vDirt * 0.1;\n\n            vOutAlbedo = mix( vOutAlbedo, vDirt, fMix );\n            fOutR0 = mix( fOutR0, 0.01, fMix );\n            fOutSmoothness = mix( fOutSmoothness, 0.01, fMix );\n\n        }\n        break;\n        \n    \tcase MAT_WOOD:\n        {\n            vec2 vUV = intersection.surface.vUVW.xz * 0.1;\n            vOutAlbedo = texture(iChannel2, vUV).rgb;\n            vOutAlbedo = vOutAlbedo * vOutAlbedo;\n            fOutSmoothness = vOutAlbedo.r;\n\n            vOutAlbedo *= 1.0 - vTrackSample.g * 0.6;\n        }\n        break;\n    }\n\t\n\t\/\/vOutR0 = vec3(0.9);\n\t\/\/fOutSmoothness = 0.5;\n}\n\nvec3 vSkyTop = vec3(0.1, 0.5, 0.8);\nvec3 vSkyBottom = vec3(0.02, 0.04, 0.06);\n\nvec3 GetSkyColour( const in vec3 vDir )\n{\n\tvec3 vResult = vec3(0.0);\n\t\n    vResult = mix(vSkyBottom, vSkyTop, abs(vDir.y)) * 30.0;\n\t\n#ifndef FAST_VERSION    \n    float fCloud = texture( iChannel1, vDir.xz * 0.01 \/ vDir.y ).r;\n    fCloud = clamp( fCloud * fCloud * 3.0 - 1.0, 0.0, 1.0);\n    vResult = mix( vResult, vec3(8.0), fCloud );\n#endif \n    \n\treturn vResult;\t\n}\n\nfloat GetFogFactor(const in float fDist)\n{\n\tfloat kFogDensity = 0.0025;\n\treturn exp(fDist * -kFogDensity);\t\n}\n\nvec3 GetFogColour(const in vec3 vDir)\n{\n\treturn (vSkyBottom) * 25.0;\n}\n\n\nvec3 vSunLightColour = vec3(1.0, 0.9, 0.6) * 10.0;\nvec3 vSunLightDir = normalize(vec3(0.4, -0.3, -0.5));\n\t\nvoid ApplyAtmosphere(inout vec3 vColour, const in float fDist, const in vec3 vRayOrigin, const in vec3 vRayDir)\n{\t\t\n\tfloat fFogFactor = GetFogFactor(fDist);\n\tvec3 vFogColour = GetFogColour(vRayDir);\t\t\t\n\tAddDirectionalLightFlareToFog(vFogColour, vRayDir, vSunLightDir, vSunLightColour);\n\t\n\tvec3 vGlow = vec3(0.0);\n\t\/\/AddPointLightFlare(vGlow, vRayOrigin, vRayDir, fDist, vLightPos, vLightColour);\t\t\t\t\t\n\t\n\tvColour = mix(vFogColour, vColour, fFogFactor) + vGlow;\t\n}\n\n\/\/ TRACING LOOP\n\n\t\nvec3 GetSceneColour( in vec3 vRayOrigin,  in vec3 vRayDir, out float fDepth )\n{\n\tvec3 vColour = vec3(0.0);\n\tfloat fRemaining = 1.0;\n\t\n    SceneState sceneState = SetupSceneState();\n    \n    fDepth = 0.0;\n    float fFirstTrace = 1.0;\n    \n#ifndef FAST_VERSION    \n\tfor(int i=0; i<RAYTRACE_COUNT; i++)\n#endif\n    {\t\n        \/\/ result = reflection\n        \/\/vColour = vec3(0.0);\n\t\t\/\/vRemaining = vec3(1.0);\n        \n\t\tfloat fCurrRemaining = fRemaining;\n\t\tfloat fShouldApply = 1.0;\n\t\t\n\t\tC_Intersection intersection;\t\t\t\t\n\t\tTraceScene( sceneState, intersection, vRayOrigin, vRayDir );\n\n        float fHitDepth = intersection.fDist;\n\t\tif(intersection.surface.iId >= MAT_FIRST_VEHICLE)\n\t\t{\n            fHitDepth = -fHitDepth;\n        }\n\t\t\n        fDepth = ( fFirstTrace > 0.0 ) ? fHitDepth : fDepth;\n        fFirstTrace = 0.0;\n        \n\t\tvec3 vResult = vec3(0.0);\n\t\tfloat fBlendFactor = 0.0;\n\t\t\t\t\t\t\n\t\tif(intersection.surface.iId == 0)\n\t\t{\n\t\t\tfBlendFactor = 1.0;\n\t\t\tfShouldApply = 0.0;\n\t\t}\n\t\telse\n\t\t{\t\t\n\t\t\tvec3 vAlbedo;\n\t\t\tfloat fR0;\n\t\t\tfloat fSmoothness;\n\t\t\tvec3 vBumpNormal;\n\t\t\t\n\t\t\tGetSurfaceInfo( vAlbedo, fR0, fSmoothness, vBumpNormal, intersection );\t\t\t\n\t\t\n\t\t\tvec3 vDiffuseLight = vec3(0.0);\n\t\t\tvec3 vSpecularLight = vec3(0.0);\n\n\t\t\t\/\/AddPointLight(sceneState, vDiffuseLight, vSpecularLight, vRayDir, intersection.vPos, vBumpNormal, fSmoothness, vLightPos, vLightColour);\t\t\t\t\t\t\t\t\n\n\t\t\tAddDirectionalLight(sceneState, vDiffuseLight, vSpecularLight, vRayDir, intersection.vPos, vBumpNormal, fSmoothness, vSunLightDir, vSunLightColour);\t\t\t\t\t\t\t\t\n\t\t\t\n\t\t\tvDiffuseLight += 0.2 * GetAmbientOcclusion(sceneState, intersection.vPos, vBumpNormal);\n\n\t\t\tfloat fSmoothFactor = pow(fSmoothness, 5.0);\n\t\t\tfloat fFresnel = fR0 + (1.0 - fR0) * pow(1.0 - dot(-vBumpNormal, vRayDir), 5.0) * fSmoothFactor;\n\t\t\t\n\t\t\tvResult = mix(vAlbedo * vDiffuseLight, vSpecularLight, fFresnel);\t\t\n\t\t\tfBlendFactor = fFresnel;\n\t\t\t\n\t\t\tApplyAtmosphere(vResult, intersection.fDist, vRayOrigin, vRayDir);\t\t\n\t\t\t\n\t\t\tfRemaining *= fBlendFactor;\t\t\t\n            \n            #ifndef FAST_VERSION\n            float fRoughness = 1.0 - fSmoothness;\n            fRoughness = pow(fRoughness, 5.0);\n            vBumpNormal = normalize(vBumpNormal + g_pixelRandom * (fRoughness) * 0.5);\n\t\t\t#endif\n            vRayDir = normalize(reflect(vRayDir, vBumpNormal));\n\t\t\tvRayOrigin = intersection.vPos;\/\/ + intersection.vNormal;            \n\t\t}\t\t\t\n\n\t\tvColour += vResult * fCurrRemaining * fShouldApply;\n\n#ifndef FAST_VERSION    \n        if( fRemaining < 0.05 )\n        {\n            break;\n        }        \t\t\n#endif        \n\t}\n\n\tvec3 vSkyColor = GetSkyColour(vRayDir);\n\t\n\tApplyAtmosphere(vSkyColor, kFarClip, vRayOrigin, vRayDir);\t\t\n\t\n\tvColour += vSkyColor * fRemaining;\n\t\n\treturn vColour;\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    fragRayOri.x = -fragRayOri.x;\n    fragRayDir.x = -fragRayDir.x;\n    \n    g_pixelRandom = normalize( Hash32(fragCoord.xy + iTime) );\n    \n\tvec2 vUV = fragCoord.xy \/ iResolution.xy;\n\n\tvec3 vCameraPos = LoadVec3( addrCamera + offsetCameraPos );\n    \n    \/\/ This will make you vomit good\n    \/\/fragRayOri.xz += vCameraPos.xz;\n                \n    g_TyreTrackOrigin = floor(vCameraPos.xz);\n    \n\tvec3 vRayOrigin = fragRayOri;\n\tvec3 vRayDir = fragRayDir;\n\t\n    float fDepth;\n\tvec3 vResult = GetSceneColour(vRayOrigin, vRayDir, fDepth);\n    vResult = max( vResult, vec3(0.0));\n\t    \n\tfragColor = vec4(vResult, fDepth);    \n}","name":"Buf C","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"XldGR7","date":"1468585914","viewed":17955,"name":"[SH16B] valley flight","username":"Bananaft","description":"Here is my raymarching debut. Developed on GTX 960. Thanks for watching!\n\nMain inspiration (and optional soundtrack): https:\/\/www.youtube.com\/watch?v=zLohrSf69ao\n\nShould look like this: https:\/\/twitter.com\/Bananaft\/status\/754706898092425220","likes":132,"published":1,"flags":32,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"\/media\/a\/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"\/media\/ap\/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/Here is my raymarching debut. Developed on GTX 960. Thanks for watching!\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n\t\n    vec2 uv2 = fragCoord.xy \/ iResolution.xy * 2.0 - 1.0;\n    float asp = iResolution.x \/ iResolution.y;\n    uv2.x *= asp;\n    \n    float dist = pow(max(1. - texture(iChannel0,uv).a * 0.04,0.),3.5);\n    \n    vec3 origin = vec3(0.0, 2.2 + 2. * sin(iTime), -1000.0 + iTime * 15.);\n    \n   vec3 direction;\/\/ = vec3(0.0, 0, 1.0);\n\tvec2 ml;\n    if (iMouse.x>10.)\n    {\n     \tml.x = 2.5 - iMouse.x\/iResolution.x * 5.;\n        ml.y = -2.5 + iMouse.y\/iResolution.y * 5.;\n    }\n   \t\/\/ camera\t\n\tvec3 ro = origin;\n\tvec3 ta = origin + vec3( sin(iTime * 0.2)+ml.x,ml.y , 2. );\n\t\n\t\/\/ camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    \/\/ ray direction\n\tdirection = ca * normalize( vec3(uv2.xy,2.0) );\n    \n    \/\/inverse(ca);\n    vec3 dir = direction;\n    vec2 bdir = vec2(-dir.x,dir.y);\/\/vec2(0.75-uv.x + dir.x,uv.y*asp + dir.y);\/\/-vec2(0.5)+uv;\n    bdir += vec2(-direction.x, direction.y);\n    bdir.x \/= asp;\n    float dither = texture(iChannel1,fragCoord\/4.).r;\n    \n    \/\/bdir.y *= 1.\/asp;\n    vec3 color=vec3(0.);\n    const int BLUR_STEPS = 8;\n    float bs = float(BLUR_STEPS);\n    for ( int i=0; i<BLUR_STEPS; i++ )\n    {\n     \tcolor += texture(iChannel0,uv - bdir * (float(i)+2.*dither) \/ bs * 0.16 * dist).xyz\/bs;\n    }\n    \n   \/\/ color = vec3(dist);\/\/ direction;\/\/ vec3(bdir,0.);\n    \n    \n   \n    \/\/const int RAY_STEPS = 128;\n    \/\/const float NEAR_CLIP = .5;\n    \/\/const float FAR_CLIP = 100.0;\n    \n   \/\/ vec3 normal;\n   \/\/ vec3 intersection; \n    \n    \n    \/\/ Reinhard tonemapping\n    float white = 8.;\n    float L = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.g;\n    float nL = (1.0 + L \/ white) \/ (1.0 + L);;\n    \/\/float scale = nL \/ L;\n    color *= nL;\n    color = pow(color,vec3( 1.\/2.2 ));\n    \n    fragColor = vec4(color,0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rn","filepath":"\/media\/a\/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"\/media\/ap\/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"\/media\/a\/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"\/media\/ap\/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void pR(inout vec2 p,float a)\n{\n    p=cos(a)*p+sin(a)*vec2(p.y,-p.x);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n\n\/\/ 3D voronoi https:\/\/www.shadertoy.com\/view\/ldl3Dl\n\/\/vec3 hash( vec3 x )\n\/\/{\n\/\/\treturn textureLod( iChannel0, (x.xy+vec2(3.0,1.0)*x.z+0.5)\/64.0, 0. ).xyz;\n\/\/}\n\nvec3 hash( vec3 x )\n{\n\tx = vec3( dot(x,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(x,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(x,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(x)*43758.5453123);\n}\n\nvec2 hash2d( vec2 x )\n{\n\treturn textureLod( iChannel0, (x.xy)\/64.0, 0. ).xy;\n}\n\nvec3 voronoi( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\t\/\/float id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + hash( p + b );\n        float d = dot( r, r );\n\n        if( d < res.x )\n        {\n\t\t\t\/\/id = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            res = vec2( d, res.x );\t\t\t\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return vec3(  res , 0.0 );\/\/abs(id)\n}\n\/\/ Gradient noise https:\/\/www.shadertoy.com\/view\/XdXGW8\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash2d( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash2d( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash2d( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash2d( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\nfloat heightmap(vec2 p)\n{\n \tfloat o = textureLod(iChannel1,(p)*0.0036,0.0).x;\n    return 1.-o;\n}\n\nfloat bump(vec2 p)\n{\n \tmat2 mat = mat2(vec2(-0.95765948032,-0.28790331666), vec2(0.28790331666,-0.95765948032));\n    float o = textureLod(iChannel1,(p * mat)*0.17,0.0).x;\n    return o;\n}\n\nvec4 scene(vec3 point)\n{\n \tfloat v = 1. - textureLod(iChannel1, point.xz * 0.02, 0.0).r;\/\/ voronoi(point * 0.2).x;\n    float h1 = bump(point.xz);\n    float h2 = heightmap(point.xz);\n    float valley = pow((min(abs(sin(point.z* 0.03)*0.38 + point.x * 0.08) *0.6,1.)),1.0 + v * 3.2);\n    float d = 1. + point.y + (mix(h1 * 0.3, (1.-h1) * 0.9 ,clamp(-0.3+v,0.0,1.0))) - (-3.+h2 * 8.) * valley;\n    d = min(d-v*3.2 * valley,d) ;\n   \n    \n    \/\/d = min(d, sdSphere(p2 - vec3(10.),10.0));\n    \n    return vec4(d,v,h1,h2);\n}\n\nfloat sky(vec3 point)\n{\n    \/\/vec3 p2;\n    \/\/const float cldspacing = 80.;\n    \/\/vec2 clsftuv = vec2(ceil(point.x\/cldspacing)\/64.,ceil(point.y\/cldspacing)\/64.);\n    \/\/vec2 clsft = vec2(texture(iChannel0,clsftuv).r,texture(iChannel0,clsftuv.yx).r);\n    \/\/p2.xz = mod(point.xz, cldspacing);\n    \/\/p2.y = point.y - 20.;\n \t\/\/float d = sdSphere(p2 - vec3(cldspacing\/2.,0.,cldspacing\/2.),15.0);   \n    \n    \n    \/\/vec3 vrn = voronoi(point * 0.25);\n    vec3 vrn2 = voronoi(point * 0.02 + vec3(iTime * 0.05,iTime * 0.1,0.));\n    \/\/float v3 =  voronoi(point * 0.6).x;\n    float v2 = 0.6 - vrn2.x * (1.5 - vrn2.y );\n    float v =  voronoi(point * 0.25).x;\/\/ vrn.x;\/\/ * (1.4 - vrn.y);\n    \/\/v2 = texture(iChannel0, point.xz * 0.001 + vec2(iTime * 0.001)).r;\n    float cld = max(8. - v2 * 9.8,0.);\n    float d = sdSphere(vec3(cld,point.y - 26., cld),6.0);      \n\tv = -0.3 + v* 2.1 ;\n    d += v;\/\/ + v3 * 1.4;\n    \n    return d;\n}\n\n\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    scene(pos+eps.xyy).x - scene(pos-eps.xyy).x,\n\t    scene(pos+eps.yxy).x - scene(pos-eps.yxy).x,\n\t    scene(pos+eps.yyx).x - scene(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = scene( ro + rd*t ).x;\n        res = min( res, 8.0*h\/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x \/ iResolution.y;\n    \n    const vec3 SKY_COL = vec3(0.6,0.89,0.98);\n    const vec3 SUN_COL = vec3(1.0,0.98,0.87);\n    vec3 suncol = vec3(0.7031,0.4687,0.1055);\n    \n  \n    const int RAY_STEPS = 256;\n    const float NEAR_CLIP = .5;\n    const float FAR_CLIP = 800.0;\n    \n    const int SKY_STEPS = 96;\n    const float SKY_NEAR_CLIP = 20.;\n    \n    vec3 normal;\n    vec3 intersection; \n    vec3 origin = vec3(0.0, -0.2 + 0.3 * sin(iTime * 2.), -1000.0 + iTime * 15.);\n    vec3 direction;\/\/ = vec3(0.0, 0, 1.0);\n\tvec2 ml = vec2(0.);\n    if (iMouse.x>10.)\n    {\n     \tml.x = 2.5 - iMouse.x\/iResolution.x * 5.;\n        ml.y = -2.5 + iMouse.y\/iResolution.y * 5.;\n    }\n   \t\/\/ camera\t\n\tvec3 ro = origin;\n\tvec3 ta = origin + vec3( sin(iTime * 0.2)+ml.x,ml.y , 2. );\n\t\n\t\/\/ camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    \/\/ ray direction\n\tdirection = ca * normalize( vec3(uv.xy,2.0) );\n   \n    float distance = 0.;\n    float totalDistance = NEAR_CLIP;\n    float skyDistance = SKY_NEAR_CLIP;\n    \n    float spec =0.;\n    float shadow =0.;\n    float diff = 1.;\n    float fog = 0.;\n    float amb=0.;\n    \n    vec3 lig  = normalize(vec3(-0.3,0.3,0.6));\/\/iMouse.x\/iResolution.x,iMouse.y\/iResolution.y\n    vec3 texs;\n    \n\tvec3 Col = vec3(4.0);\n    for(int i =0 ;  i < RAY_STEPS; ++i) \/\/\/\/\/\/ Rendering main scene\n    {\n        intersection = origin + direction * totalDistance;\n        vec4 s = scene(intersection);\n        distance = s.r;\n        texs = s.gba;\n        totalDistance += distance;\n                     \n        if(distance <= 0.002 || totalDistance >= FAR_CLIP)\n        {\n            \/\/Col = vec3(0.,1.,0.);\n            break;\n        }\n    }\n    if (totalDistance >= FAR_CLIP)\n    {\t\n     \n        \/\/float myst = 0.0;\n        for(int i =0 ;  i < SKY_STEPS; ++i)    \/\/\/\/\/\/\/\/\/\/\/\/\/\/ Rendering clouds\n        {\n            intersection = origin + direction * skyDistance;\n            distance = sky(intersection);\n            skyDistance += distance;\n           \n\t\t\t\/\/myst += max(1.2-distance,0.);\n            if(distance <= 0.02 || skyDistance >= FAR_CLIP)\n            {\n                \/\/Col = vec3(0.,1.,0.);\n               break;\n            }\n        }\n        float occl = 0.0;\n        for(int i =0 ;  i < 4; ++i)\n        {\n         \tfloat d = sky(intersection + vec3(0.,-2. + 4.7 * float(i),0.));\n            occl += d * 0.067;\n        }\n        occl = clamp(occl,0.1,2.0);\n        float sunlight = 0.0;\n        \n        for(int i =0 ;  i < 4; ++i)\n        {\n         \tfloat d = sky(intersection +(1.3 * lig + lig) * 3.2 * float(i));\n            sunlight += d * 0.037;\n        }\n        sunlight = max(sunlight,0.);\n        \/\/myst = clamp(1.0 - myst,0.,1.);\n    \tCol = vec3(0.6,0.89,0.98) * occl + SUN_COL * sunlight * 4.;\/\/ +vec3(myst);\n        fog = max((1.-(skyDistance \/ FAR_CLIP)), 0.);\n        \/\/Col = vec3(myst);\n        \/\/fog = 1.0;\n       \n    } else {\n     \t\n        float rock = clamp( texs.b * 2. - texs.g * 1. * (3.-intersection.y) * (0.3+texs.r) ,0. ,1.);\n        float nstx = texture(iChannel0, intersection.xz).r;\n        Col = mix(vec3(0.27,0.35,0.15) * (0.2 + pow(texs.g + texs.g * (-0.3 + nstx),2.2)), vec3(0.86,0.48,0.32) * (0.2 + pow(texs.g,0.6)), rock); \/\/clamp(intersection.y,0.,1.)\n        normal = calcNormal(intersection);\n\n        diff = clamp(dot(normal , lig),0.,1.);\n        shadow = softshadow( intersection, lig, 0.02, 2.5 ) * max(2. -texture(iChannel0, intersection.xz * 0.001+vec2(iTime * 0.001)).r * 3.1,0.);\n        diff *= shadow;\n        amb = 0.24 * normal.y;\n        float dotrflct = dot(reflect( direction, normal ), lig );\n        spec = shadow * (rock + ((1.-rock) * pow(nstx,4.0) * 2.) ) * pow(clamp(dotrflct, 0.0, 1.0 ),26.0);\n        \n        float depth = ((totalDistance \/ FAR_CLIP));\n        fog = clamp(exp((intersection.y*0.3 - 1.3)*depth+0.24) * (1.-exp(depth*1.9-1.9)) ,0.,1.);\/\/\n        \/\/fog = 1.0;\n    }\n    \n   float horizon = abs(direction.y);\n   float sun = max(1.0 - (1.0 + 10.0 * lig.y + horizon) * length(direction - lig),0.0)\n        + 0.3 * pow(1.0-horizon,18.0) * (1.3-lig.y);\n    \n   vec3 chroma = vec3(mix(SKY_COL, suncol,clamp(sun,0.,1. ) * 0.85)) + vec3(0.06,0.06,0.06); \n    \n   float luma = ((0.5 + 1.0 * pow(lig.y,0.4)) * (1.5-horizon) + pow(sun, 2.2) * lig.y * (5.0 + 15.0 * lig.y));\n   \n   float exposure = 2.3;\n    \n   vec3 fogCol =  chroma * luma * exposure;\n    \n    vec3 Final = mix(fogCol,Col * diff *SUN_COL*2.0 + spec* SUN_COL * 1.6 + Col * amb * SKY_COL, fog);\n\tfragColor = vec4(Final ,totalDistance);\n    \/\/fragColor = vec4(direction,0.);\n    \/\/fragColor = vec4();\n}","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"MtcGDH","date":"1469033021","viewed":17952,"name":"[SH16C] Voxel Game","username":"fb39ca4","description":"All of the block data here is generated and remains on the GPU, and is rendered by raycasting. If you are getting a black screen, your GPU might be lacking necessary features. Has been tested on recent Nvidia and Intel GPUs.","likes":243,"published":3,"flags":112,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"\/presets\/tex00.jpg","previewfilepath":"\/presets\/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"\/media\/previz\/buffer03.png","previewfilepath":"\/media\/previz\/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/* \nVoxel Game\nfb39ca4's SH16C Entry\n\nThis was an attempt to make something like Minecraft entirely in\nShadertoy. The world around the player is saved in a buffer, and as long\nas an an area is loaded, changes remain. However, if you go too far\naway, blocks you have modified will reset. To load more blocks, go to \nfullscreen to increase the size of the buffers. I tried to implement\nmany of the features from Minecraft's Creative mode, but at this point,\nthis shader is more of a tech demo to prove that interactive voxel games\nare possible.\n\nFeatures:\n    Semi-persistent world\n    Flood-fill sky and torch lighting\n    Smooth lighting and ambient occlusion\n    Day\/Night cycle\n    Movement with collision detection\n    Flying and sprinting mode\n    Block placment and removal\n    Hotbar to choose between: Stone, Dirt, Grass, Cobblestone, Glowstone, \n        Brick, Gold, Wood\n    \nControls:\n    Click and drag mouse to look, select blocks\n    WASD to move\n    Space to jump\n    Double-tap space to start flying, use space and shift to go up and down.\n    Q + mouse button to place block\n    E + mouse button to destroy blocks\n    Z\/X to cycle through available blocks for placement\n    0-8 to choose a block type for placement\n    Page Up\/Down to increase or decrease render resolution\n    O,P to decrease\/increase speed of day\/night cycles\n\n\tThere are #defines in Buffer A to change the controls.\n\nTODO:\n\u00e2\u0153\u201c Voxel Raycaster\n\u00e2\u0153\u201c Free camera controls\n\u00e2\u0153\u201c Store map in texture\n\u00e2\u0153\u201c Infinite World\n\u00e2\u0153\u201c Persistent World\n\u00e2\u0153\u201c Sky Lighting\n\u00e2\u0153\u201c Torch Lighting\n\u00e2\u0153\u201c Smooth Lighting, Ambient Occlusion\n\u00e2\u0153\u201c Vertical Collision Detection\n\u00e2\u0153\u201c Walking, Jumping\n\u00e2\u0153\u201c Horizontal collision detection\n\u00e2\u0153\u201c Textures\n\u00e2\u0153\u201c Proper world generation\n\u00e2\u0153\u201c Block picking\n\u00e2\u0153\u201c Adding\/Removing blocks\n\u00e2\u0153\u201c GUI for block selection\n\u00e2\u0153\u201c Sun, Moon, Sky\n\u00e2\u0153\u201c Day\/Night Cycle\n\u00e2\u0153\u201c Double jump to fly, double tap forwards to run\n*\/\n\n#define var(name, x, y) const vec2 name = vec2(x, y)\n#define varRow 0.\nvar(_pos, 0, varRow);\nvar(_angle, 2, varRow);\nvar(_mouse, 3, varRow);\nvar(_loadRange, 4, varRow);\nvar(_inBlock, 5, varRow);\nvar(_vel, 6, varRow);\nvar(_pick, 7, varRow);\nvar(_pickTimer, 8, varRow);\nvar(_renderScale, 9, varRow);\nvar(_selectedInventory, 10, varRow);\nvar(_flightMode, 11, varRow);\nvar(_sprintMode, 12, varRow);\nvar(_time, 13, varRow);\nvar(_old, 0, 1);\n\n\nvec4 load(vec2 coord) {\n\treturn textureLod(iChannel0, vec2((floor(coord) + 0.5) \/ iChannelResolution[0].xy), 0.0);\n}\n\nfloat keyToggled(int keyCode) {\n\treturn textureLod(iChannel1, vec2((float(keyCode) + 0.5) \/ 256., 2.5\/3.), 0.0).r;   \n}\n\n\n\/\/ ---- 8< ---- GLSL Number Printing - @P_Malin ---- 8< ----\n\/\/ Creative Commons CC0 1.0 Universal (CC-0) \n\/\/ https:\/\/www.shadertoy.com\/view\/4sBSWW\n\nfloat DigitBin(const in int x)\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue(const in vec2 fragCoord, const in vec2 vPixelCoords, const in vec2 vFontSize, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces)\n{\n    vec2 vStringCharCoords = (fragCoord.xy - vPixelCoords) \/ vFontSize;\n    if ((vStringCharCoords.y < 0.0) || (vStringCharCoords.y >= 1.0)) return 0.0;\n\tfloat fLog10Value = log2(abs(fValue)) \/ log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCharCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((fValue < 0.0) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n\t\t\t\tif(fDigitIndex < 0.0) fDigitIndex += 1.0;\n\t\t\t\tfloat fDigitValue = (abs(fValue \/ (pow(10.0, fDigitIndex))));\n                float kFix = 0.0001;\n                fCharBin = DigitBin(int(floor(mod(kFix+fDigitValue, 10.0))));\n\t\t\t}\t\t\n\t\t}\n\t}\n    return floor(mod((fCharBin \/ pow(2.0, floor(fract(vStringCharCoords.x) * 4.0) + (floor(vStringCharCoords.y * 5.0) * 4.0))), 2.0));\n}\n\nfloat getInventory(float slot) {\n\treturn slot + 1. + step(2.5, slot);  \n}\n\nvec4 getTexture(float id, vec2 c) {\n    vec2 gridPos = vec2(mod(id, 16.), floor(id \/ 16.));\n\treturn textureLod(iChannel2, 16. * (c + gridPos) \/ iChannelResolution[2].xy, 0.0);\n}\n\nconst float numItems = 8.;\n\nvec4 drawSelectionBox(vec2 c) {\n\tvec4 o = vec4(0.);\n    float d = max(abs(c.x), abs(c.y));\n    if (d > 6. && d < 9.) {\n        o.a = 1.;\n        o.rgb = vec3(0.9);\n        if (d < 7.) o.rgb -= 0.3;\n        if (d > 8.) o.rgb -= 0.1;\n    }\n    return o;\n}\n\nmat2 inv2(mat2 m) {\n  return mat2(m[1][1],-m[0][1], -m[1][0], m[0][0]) \/ (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\n\nvec4 drawGui(vec2 c) {\n\tfloat scale = floor(iResolution.y \/ 128.);\n    c \/= scale;\n    vec2 r = iResolution.xy \/ scale;\n    vec4 o = vec4(0);\n    float xStart = (r.x - 16. * numItems) \/ 2.;\n    c.x -= xStart;\n    float selected = load(_selectedInventory).r;\n    vec2 p = (fract(c \/ 16.) - .5) * 3.;\n    vec2 u = vec2(sqrt(3.)\/2.,.5);\n    vec2 v = vec2(-sqrt(3.)\/2.,.5);\n    vec2 w = vec2(0,-1);\n    if (c.x < numItems * 16. && c.x >= 0. && c.y < 16.) {\n        float slot = floor(c.x \/ 16.);\n    \to = getTexture(48., fract(c \/ 16.));\n        vec3 b = vec3(dot(p,u), dot(p,v), dot(p,w));\n        vec2 texCoord;\n        \/\/if (all(lessThan(b, vec3(1)))) o = vec4(dot(p,u), dot(p,v), dot(p,w),1.);\n        float top = 0.;\n        float right = 0.;\n        if (b.z < b.x && b.z < b.y) {\n        \ttexCoord = inv2(mat2(u,v)) * p.xy;\n            top = 1.;\n        }\n        else if(b.x < b.y) {\n        \ttexCoord = 1. - inv2(mat2(v,w)) * p.xy;\n            right = 1.;\n        }\n        else {\n        \ttexCoord = inv2(mat2(u,w)) * p.xy;\n            texCoord.y = 1. - texCoord.y;\n        }\n        if (all(lessThanEqual(abs(texCoord - .5), vec2(.5)))) {\n            float id = getInventory(slot);\n            if (id == 3.) id += top;\n            o.rgb = getTexture(id, texCoord).rgb * (0.5 + 0.25 * right + 0.5 * top);\n            o.a = 1.;\n        }\n    }\n    vec4 selection = drawSelectionBox(c - 8. - vec2(16. * selected, 0));\n    o = mix(o, selection, selection.a);\n    return o;\n}\n\n\/\/ ---- 8< -------- 8< -------- 8< -------- 8< ----\n\nconst vec2 packedChunkSize = vec2(11,6);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float scaleFactor = pow(sqrt(2.), load(_renderScale).r);\n    vec2 renderResolution = ceil(iResolution.xy \/ scaleFactor); \n    fragColor = texture(iChannel3, fragCoord * renderResolution \/ iResolution.xy \/ iResolution.xy);\n    vec4 gui = drawGui(fragCoord);\n    fragColor = mix(fragColor, gui, gui.a);\n    \n    vec3 pos = load(_pos).xyz;\n        \n    if (bool(keyToggled(114))) {\n        if (fragCoord.x < 20.) fragColor.rgb = mix(fragColor.rgb, texture(iChannel0, fragCoord \/ iResolution.xy).rgb, texture(iChannel0, fragCoord \/ iResolution.xy).a);\n        fragColor = mix( fragColor, vec4(1,1,0,1), PrintValue(fragCoord, vec2(0.0, 5.0), vec2(8,15), iTimeDelta, 4.0, 1.0));\n        fragColor = mix( fragColor, vec4(1,0,1,1), PrintValue(fragCoord, vec2(0.0, 25.0), vec2(8,15), load(_time).r, 6.0, 1.0));\n        fragColor = mix( fragColor, vec2(1,.5).xyyx, PrintValue(fragCoord, vec2(0., iResolution.y - 20.), vec2(8,15), pos.x, 4.0, 5.0));\n        fragColor = mix( fragColor, vec2(1,.5).yxyx, PrintValue(fragCoord, vec2(0., iResolution.y - 40.), vec2(8,15), pos.y, 4.0, 5.0));\n        fragColor = mix( fragColor, vec2(1,.5).yyxx, PrintValue(fragCoord, vec2(0., iResolution.y - 60.), vec2(8,15), pos.z, 4.0, 5.0));\n        \n    }\n\t\n    \/\/fragColor = texture(iChannel2, fragCoord \/ 3. \/ iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"\/presets\/tex00.jpg","previewfilepath":"\/presets\/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"lsjGRR","filepath":"https:\/\/soundcloud.com\/bitesizekid\/minecraft-background-music","previewfilepath":"https:\/\/soundcloud.com\/bitesizekid\/minecraft-background-music","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define KEY_FORWARDS 87\n#define KEY_BACKWARDS 83\n#define KEY_LEFT 65\n#define KEY_RIGHT 68\n#define KEY_JUMP 32\n#define KEY_SNEAK 16\n#define KEY_PLACE 81\n#define KEY_DESTROY 69\n#define KEY_DECREASE_RESOLUTION 34\n#define KEY_INCREASE_RESOLUTION 33\n#define KEY_INCREASE_TIME_SCALE 80\n#define KEY_DECREASE_TIME_SCALE 79\n#define KEY_INVENTORY_NEXT 88\n#define KEY_INVENTORY_PREVIOUS 90\n#define KEY_INVENTORY_ABSOLUTE_START 49\n\nconst float PI = 3.14159265359;\n#define var(name, x, y) const vec2 name = vec2(x, y)\n#define varRow 0.\nvar(_pos, 0, varRow);\nvar(_angle, 2, varRow);\nvar(_mouse, 3, varRow);\nvar(_loadRange, 4, varRow);\nvar(_inBlock, 5, varRow);\nvar(_vel, 6, varRow);\nvar(_pick, 7, varRow);\nvar(_pickTimer, 8, varRow);\nvar(_renderScale, 9, varRow);\nvar(_selectedInventory, 10, varRow);\nvar(_flightMode, 11, varRow);\nvar(_sprintMode, 12, varRow);\nvar(_time, 13, varRow);\nvar(_old, 0, 1);\n\n\n\nvec4 load(vec2 coord) {\n\treturn textureLod(iChannel0, vec2((floor(coord) + 0.5) \/ iChannelResolution[1].xy), 0.0);\n}\n\nbool inBox(vec2 coord, vec4 bounds) {\n\treturn coord.x >= bounds.x && coord.y >= bounds.y && coord.x < (bounds.x + bounds.z) && coord.y < (bounds.y + bounds.w);\n}\n\nvec2 currentCoord;\nvec4 outValue;\nbool store4(vec2 coord, vec4 value) {\n\tif (inBox(currentCoord, vec4(coord, 1., 1.))) {\n    \toutValue = value;\n        return true;\n    }\n    else return false;\n}\nbool store3(vec2 coord, vec3 value) { return store4(coord, vec4(value, 1)); }\nbool store2(vec2 coord, vec2 value) { return store4(coord, vec4(value, 0, 1)); }\nbool store1(vec2 coord, float value) { return store4(coord, vec4(value, 0, 0, 1)); }\n\nfloat keyDown(int keyCode) {\n\treturn textureLod(iChannel2, vec2((float(keyCode) + 0.5) \/ 256., .5\/3.), 0.0).r;   \n}\n\nfloat keyPress(int keyCode) {\n\treturn textureLod(iChannel2, vec2((float(keyCode) + 0.5) \/ 256., 1.5\/3.), 0.0).r;   \n}\n\nfloat keySinglePress(int keycode) {\n\tbool now = bool(keyDown(keycode));\n    bool previous = bool(textureLod(iChannel0, vec2(256. + float(keycode) + 0.5, 0.5) \/ iResolution.xy, 0.0).r);\n    return float(now && !previous);\n}\n\nconst vec2 packedChunkSize = vec2(12,7);\nconst float heightLimit = packedChunkSize.x * packedChunkSize.y;\n\nfloat calcLoadDist(void) {\n\tvec2 chunks = floor(iResolution.xy \/ packedChunkSize);\n    float gridSize = min(chunks.x, chunks.y);\n    return floor((gridSize - 1.) \/ 2.);\n}\n\nvec4 calcLoadRange(vec2 pos) {\n\tvec2 d = calcLoadDist() * vec2(-1,1);\n    return floor(pos).xxyy + d.xyxy;\n}\n\nvec2 swizzleChunkCoord(vec2 chunkCoord) {\n    vec2 c = chunkCoord;\n    float dist = max(abs(c.x), abs(c.y));\n    vec2 c2 = floor(abs(c - 0.5));\n    float offset = max(c2.x, c2.y);\n    float neg = step(c.x + c.y, 0.) * -2. + 1.;\n    return (neg * c) + offset;\n}\n\nfloat rectangleCollide(vec2 p1, vec2 p2, vec2 s) {\n\treturn float(all(lessThan(abs(p1 - p2), s)));   \n}\n\nfloat horizontalPlayerCollide(vec2 p1, vec2 p2, float h) {\n    vec2 s = (vec2(1) + vec2(.6, h)) \/ 2.;\n    p2.y += h \/ 2.;\n    return rectangleCollide(p1, p2, s);\n}\n\nvec4 readMapTex(vec2 pos) {\n \treturn textureLod(iChannel1, (floor(pos) + 0.5) \/ iChannelResolution[0].xy, 0.0);   \n}\n\nvec2 voxToTexCoord(vec3 voxCoord) {\n    vec3 p = floor(voxCoord);\n    return swizzleChunkCoord(p.xy) * packedChunkSize + vec2(mod(p.z, packedChunkSize.x), floor(p.z \/ packedChunkSize.x));\n}\n\nstruct voxel {\n\tfloat id;\n    float sunlight;\n    float torchlight;\n    float hue;\n};\n\nvoxel decodeTextel(vec4 textel) {\n\tvoxel o;\n    o.id = textel.r;\n    o.sunlight = floor(mod(textel.g, 16.));\n    o.torchlight = floor(mod(textel.g \/ 16., 16.));\n    o.hue = textel.b;\n    return o;\n}\n\nvoxel getVoxel(vec3 p) {\n    return decodeTextel(readMapTex(voxToTexCoord(p)));\n}\n\nbool getHit(vec3 c) {\n\tvec3 p = vec3(c) + vec3(0.5);\n\tfloat d = readMapTex(voxToTexCoord(p)).r;\n\treturn d > 0.5;\n}\n\nstruct rayCastResults {\n\tbool hit;\n    vec3 rayPos;\n    vec3 mapPos;\n    vec3 normal;\n    vec2 uv;\n    vec3 tangent;\n    vec3 bitangent;\n    float dist;\n};\n\n    \nrayCastResults rayCast(vec3 rayPos, vec3 rayDir, vec3 offset) {\n\tvec3 mapPos = floor(rayPos);\n    vec3 deltaDist = abs(vec3(length(rayDir)) \/ rayDir);\n    vec3 rayStep = sign(rayDir);\n    vec3 sideDist = (sign(rayDir) * (mapPos - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; \n    vec3 mask;\n    bool hit = false;\n    for (int i = 0; i < 9; i++) {\n\t\tmask = step(sideDist.xyz, sideDist.yzx) * step(sideDist.xyz, sideDist.zxy);\n\t\tsideDist += vec3(mask) * deltaDist;\n\t\tmapPos += vec3(mask) * rayStep;\n\t\t\n        if (mapPos.z < 0. || mapPos.z >= packedChunkSize.x * packedChunkSize.y) break;\n        if (getHit(mapPos - offset)) { \n            hit = true; \n            break;\n        }\n\n\t}\n    vec3 endRayPos = rayDir \/ dot(mask * rayDir, vec3(1)) * dot(mask * (mapPos + step(rayDir, vec3(0)) - rayPos), vec3(1)) + rayPos;\n   \tvec2 uv;\n    vec3 tangent1;\n    vec3 tangent2;\n    if (abs(mask.x) > 0.) {\n        uv = endRayPos.yz;\n        tangent1 = vec3(0,1,0);\n        tangent2 = vec3(0,0,1);\n    }\n    else if (abs(mask.y) > 0.) {\n        uv = endRayPos.xz;\n        tangent1 = vec3(1,0,0);\n        tangent2 = vec3(0,0,1);\n    }\n    else {\n        uv = endRayPos.xy;\n        tangent1 = vec3(1,0,0);\n        tangent2 = vec3(0,1,0);\n    }\n    uv = fract(uv);\n    rayCastResults res;\n    res.hit = hit;\n    res.uv = uv;\n    res.mapPos = mapPos;\n    res.normal = -rayStep * mask;\n    res.tangent = tangent1;\n    res.bitangent = tangent2;\n    res.rayPos = endRayPos;\n    res.dist = length(rayPos - endRayPos);\n    return res;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    currentCoord = fragCoord;\n    vec2 texCoord = floor(fragCoord);\n    if (texCoord.x < 512.) {\n        if (texCoord.y == varRow) {\n            if (texCoord.x >= 256.) {\n            \tfragColor.r = texture(iChannel2, (fragCoord - 256.) \/ vec2(256,3)).r;\n                vec4 old = texture(iChannel0, (_old + fragCoord) \/ iResolution.xy);\n                if (fragColor.r != old.r) old.a = 0.;\n                fragColor.a = old.a + iTimeDelta;\n        \t}\n            else {\n                vec3 pos = load(_pos).xyz;\n                vec3 oldPos = pos;\n                vec3 offset = vec3(floor(pos.xy), 0.);\n                vec2 angle = load(_angle).xy;\n                vec4 oldMouse = load(_mouse);\n                vec3 vel = load(_vel).xyz;\n                vec4 mouse = iMouse \/ length(iResolution.xy);\n\t\t\t\tfloat renderScale = load(_renderScale).r;\n                vec2 time = load(_time).rg;\n                vec2 flightMode = load(_flightMode).rg;\n                vec2 sprintMode = load(_sprintMode).rg;\n                float selected = load(_selectedInventory).r;\n                float dt = min(iTimeDelta, .05);\n\n                if (iFrame == 0) {\n                    pos = vec3(0,0,52);\n                    angle = vec2(-0.75,2.5);\n                    oldMouse = vec4(-1);\n                    vel = vec3(0);\n                    renderScale = 0.;\n                    time = vec2(0,4);\n                    selected = 0.;\n                }\n                if (oldMouse.z > 0. && iMouse.z > 0.) {\n                    angle += 5.*(mouse.xy - oldMouse.xy) * vec2(-1,-1);\n                    angle.y = clamp(angle.y, 0.1, PI - 0.1);\n                }\n                vec3 dir = vec3(sin(angle.y) * cos(angle.x), sin(angle.y) * sin(angle.x), cos(angle.y));\n                vec3 dirU = vec3(normalize(vec2(dir.y, -dir.x)), 0);\n                vec3 dirV = cross(dirU, dir);\n                vec3 move = vec3(0);\n\n                vec3 dirFwd = vec3(cos(angle.x), sin(angle.x), 0);;\n                vec3 dirRight = vec3(dirFwd.y, -dirFwd.x, 0);\n                vec3 dirUp = vec3(0,0,1);\n                \/*move += dir * (keyDown(87)-keyDown(83));\n                move += dirU * (keyDown(68) - keyDown(65));\n                move += vec3(0,0,1) * (keyDown(82) - keyDown(70));*\/\n\n                float inBlock = 0.;\n                float minHeight = 0.;\n                vec3 vColPos, hColPos;\n                for (float i = 0.; i < 4.; i++) {\n                    vColPos = vec3(floor(pos.xy - 0.5), floor(pos.z - 1. - i));\n                    if (getVoxel(vColPos - offset + vec3(0,0,0)).id * rectangleCollide(vColPos.xy + vec2(0.5,0.5), pos.xy, vec2(.8))\n                        + getVoxel(vColPos - offset + vec3(0,1,0)).id * rectangleCollide(vColPos.xy + vec2(0.5,1.5), pos.xy, vec2(.8)) \n                        + getVoxel(vColPos - offset + vec3(1,0,0)).id * rectangleCollide(vColPos.xy + vec2(1.5,0.5), pos.xy, vec2(.8))\n                        + getVoxel(vColPos - offset + vec3(1,1,0)).id * rectangleCollide(vColPos.xy + vec2(1.5,1.5), pos.xy, vec2(.8))\n                        > .5) {\n                        minHeight = vColPos.z + 1.001; \n                        inBlock = 1.;\n                        break;\n                    }\n                }\n                float maxHeight = heightLimit - 1.8;\n                vColPos = vec3(floor(pos.xy - 0.5), floor(pos.z + 1.8 + 1.));\n                if (getVoxel(vColPos - offset + vec3(0,0,0)).id * rectangleCollide(vColPos.xy + vec2(0.5,0.5), pos.xy, vec2(.8))\n                    + getVoxel(vColPos - offset + vec3(0,1,0)).id * rectangleCollide(vColPos.xy + vec2(0.5,1.5), pos.xy, vec2(.8)) \n                    + getVoxel(vColPos - offset + vec3(1,0,0)).id * rectangleCollide(vColPos.xy + vec2(1.5,0.5), pos.xy, vec2(.8))\n                    + getVoxel(vColPos - offset + vec3(1,1,0)).id * rectangleCollide(vColPos.xy + vec2(1.5,1.5), pos.xy, vec2(.8))\n                    > .5) {\n                    maxHeight = vColPos.z - 1.8 - .001; \n                    inBlock = 1.;\n                }\n                float minX = pos.x - 1000.;\n                hColPos = vec3(floor(pos.xy - vec2(.3, .5)) + vec2(-1,0), floor(pos.z));\n                if (getVoxel(hColPos - offset + vec3(0,0,0)).id * horizontalPlayerCollide(hColPos.yz + vec2(0.5, 0.5), pos.yz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(0,1,0)).id * horizontalPlayerCollide(hColPos.yz + vec2(1.5, 0.5), pos.yz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(0,0,1)).id * horizontalPlayerCollide(hColPos.yz + vec2(0.5, 1.5), pos.yz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(0,1,1)).id * horizontalPlayerCollide(hColPos.yz + vec2(1.5, 1.5), pos.yz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(0,0,2)).id * horizontalPlayerCollide(hColPos.yz + vec2(0.5, 2.5), pos.yz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(0,1,2)).id * horizontalPlayerCollide(hColPos.yz + vec2(1.5, 2.5), pos.yz, 1.8)\n                    > .5) {\n                    minX = hColPos.x + 1.301;\n                }\n                float maxX = pos.x + 1000.;\n                hColPos = vec3(floor(pos.xy - vec2(-.3, .5)) + vec2(1,0), floor(pos.z));\n                if (getVoxel(hColPos - offset + vec3(0,0,0)).id * horizontalPlayerCollide(hColPos.yz + vec2(0.5, 0.5), pos.yz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(0,1,0)).id * horizontalPlayerCollide(hColPos.yz + vec2(1.5, 0.5), pos.yz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(0,0,1)).id * horizontalPlayerCollide(hColPos.yz + vec2(0.5, 1.5), pos.yz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(0,1,1)).id * horizontalPlayerCollide(hColPos.yz + vec2(1.5, 1.5), pos.yz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(0,0,2)).id * horizontalPlayerCollide(hColPos.yz + vec2(0.5, 2.5), pos.yz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(0,1,2)).id * horizontalPlayerCollide(hColPos.yz + vec2(1.5, 2.5), pos.yz, 1.8)\n                    > .5) {\n                    maxX = hColPos.x - .301;\n                }\n                            float minY = pos.y - 1000.;\n                hColPos = vec3(floor(pos.xy - vec2(.5, .3)) + vec2(0,-1), floor(pos.z));\n                if (getVoxel(hColPos - offset + vec3(0,0,0)).id * horizontalPlayerCollide(hColPos.xz + vec2(0.5, 0.5), pos.xz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(1,0,0)).id * horizontalPlayerCollide(hColPos.xz + vec2(1.5, 0.5), pos.xz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(0,0,1)).id * horizontalPlayerCollide(hColPos.xz + vec2(0.5, 1.5), pos.xz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(1,0,1)).id * horizontalPlayerCollide(hColPos.xz + vec2(1.5, 1.5), pos.xz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(0,0,2)).id * horizontalPlayerCollide(hColPos.xz + vec2(0.5, 2.5), pos.xz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(1,0,2)).id * horizontalPlayerCollide(hColPos.xz + vec2(1.5, 2.5), pos.xz, 1.8)\n                    > .5) {\n                    minY = hColPos.y + 1.301;\n                }\n                float maxY = pos.y + 1000.;\n                hColPos = vec3(floor(pos.xy - vec2(.5, -.3)) + vec2(0,1), floor(pos.z));\n                if (getVoxel(hColPos - offset + vec3(0,0,0)).id * horizontalPlayerCollide(hColPos.xz + vec2(0.5, 0.5), pos.xz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(1,0,0)).id * horizontalPlayerCollide(hColPos.xz + vec2(1.5, 0.5), pos.xz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(0,0,1)).id * horizontalPlayerCollide(hColPos.xz + vec2(0.5, 1.5), pos.xz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(1,0,1)).id * horizontalPlayerCollide(hColPos.xz + vec2(1.5, 1.5), pos.xz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(0,0,2)).id * horizontalPlayerCollide(hColPos.xz + vec2(0.5, 2.5), pos.xz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(1,0,2)).id * horizontalPlayerCollide(hColPos.xz + vec2(1.5, 2.5), pos.xz, 1.8)\n                    > .5) {\n                    maxY = hColPos.y - .301;\n                }\n                                \n                if (abs(pos.z - minHeight) < 0.01) flightMode.r = 0.;\n                if (bool(keySinglePress(KEY_JUMP))) {\n                    if (flightMode.g > 0.) {\n                        flightMode.r = 1.- flightMode.r;\n                        sprintMode.r = 0.;\n                    }\n                    flightMode.g = 0.3;\n                }\n                flightMode.g = max(flightMode.g - dt, 0.);\n                    \n                if (bool(keySinglePress(KEY_FORWARDS))) {\n\t\t\t\t\tif (sprintMode.g > 0.) sprintMode.r = 1.;\n                    sprintMode.g = 0.3;\n                }\n                if (!bool(keyDown(KEY_FORWARDS))) {\n                    if (sprintMode.g <= 0.) sprintMode.r = 0.;\n                }\n                sprintMode.g = max(sprintMode.g - dt, 0.);\n\t\t\t\t\n                if (bool(flightMode.r)) {\n                    if (length(vel) > 0.) vel -= min(length(vel), 25. * dt) * normalize(vel);\n                    vel += 50. * dt * dirFwd * sign(keyDown(KEY_FORWARDS)-keyDown(KEY_BACKWARDS)+keyDown(38)-keyDown(40));\n                    vel += 50. * dt * dirRight * sign(keyDown(KEY_RIGHT)-keyDown(KEY_LEFT)+keyDown(39)-keyDown(37));\n                    vel += 50. * dt * dirUp * sign(keyDown(KEY_JUMP) - keyDown(KEY_SNEAK));\n                    if (length(vel) > 20.) vel = normalize(vel) * 20.;\n                }\n                else {\n                    vel.xy *= max(0., (length(vel.xy) - 25. * dt) \/ length(vel.xy));\n                    vel += 50. * dt * dirFwd * sign(keyDown(KEY_FORWARDS)-keyDown(KEY_BACKWARDS)+keyDown(38)-keyDown(40));\n                    vel += 50. * dt * dirFwd * 0.4 * sprintMode.r;\n                    vel += 50. * dt * dirRight * sign(keyDown(KEY_RIGHT)-keyDown(KEY_LEFT)+keyDown(39)-keyDown(37));\n                    if (abs(pos.z - minHeight) < 0.01) {\n                        vel.z = 9. * keyDown(32);\n                    }\n                    else {\n                        vel.z -= 32. * dt;\n                        vel.z = clamp(vel.z, -80., 30.);\n                    }\n                    if (length(vel.xy) > 4.317 * (1. + 0.4 * sprintMode.r)) vel.xy = normalize(vel.xy) * 4.317 * (1. + 0.4 * sprintMode.r);\n                }\n\t\t\t\t\n                \n                pos += dt * vel; \n                if (pos.z < minHeight) {\n                    pos.z = minHeight;\n                    vel.z = 0.;\n                }\n                if (pos.z > maxHeight) {\n                    pos.z = maxHeight;\n                    vel.z = 0.;\n                }\n                if (pos.x < minX) {\n                    pos.x = minX;\n                    vel.x = 0.;\n                }\n                if (pos.x > maxX) {\n                    pos.x = maxX;\n                    vel.x = 0.;\n                }\n                if (pos.y < minY) {\n                    pos.y = minY;\n                    vel.y = 0.;\n                }\n                if (pos.y > maxY) {\n                    pos.y = maxY;\n                    vel.y = 0.;\n                }\n\n                float timer = load(_old+_pickTimer).r;\n                vec4 oldPick = load(_old+_pick);\n                vec4 pick;\n                float pickAction;\n                if (iMouse.z > 0.) {\n                    vec3 cameraDir = vec3(sin(angle.y) * cos(angle.x), sin(angle.y) * sin(angle.x), cos(angle.y));\n                    vec3 cameraPlaneU = vec3(normalize(vec2(cameraDir.y, -cameraDir.x)), 0);\n                    vec3 cameraPlaneV = cross(cameraPlaneU, cameraDir) * iResolution.y \/ iResolution.x;\n                    vec2 screenPos = iMouse.xy \/ iResolution.xy * 2.0 - 1.0;\n                    vec3 rayDir = cameraDir + screenPos.x * cameraPlaneU + screenPos.y * cameraPlaneV;\n                    rayCastResults res = rayCast(pos + vec3(0,0,1.6), rayDir, offset);\n                    if (res.dist <= 5.) {\n                        pick.xyz = res.mapPos;\n                        if (bool(keyDown(KEY_DESTROY))) {\n                            pick.a = 1.;\n                            store1(vec2(0,9),pick.a);\n                            timer += dt \/ 0.25;\n                        }\n                        else if (bool(keySinglePress(KEY_PLACE))) {\n                            pick.a = 2.;\n                            pick.xyz += res.normal;\n                            timer += dt \/ 0.3;\n                        }\n                \t\tif (oldPick != pick) timer = 0.;\n                    }\n                    else {\n                        pick = vec4(-1,-1,-1,0);\n                        timer = 0.;\n                    }\n                }\n                else {\n                    pick = vec4(-1,-1,-1,0);\n                    timer = 0.;\n                }\n\t\t\t\t\n                const int numItems = 8;\n                selected += keyPress(KEY_INVENTORY_NEXT) - keyPress(KEY_INVENTORY_PREVIOUS);\n                for (int i = 0; i < 9; i++) {\n                \tif (bool(keyPress(KEY_INVENTORY_ABSOLUTE_START + i))) selected = float(i);   \n                }\n\t\t\t\tselected = mod(selected, float(numItems));\n                \n                renderScale = clamp(renderScale + keySinglePress(KEY_DECREASE_RESOLUTION) - keySinglePress(KEY_INCREASE_RESOLUTION), 0., 4.);\n\t\t\t\ttime.g = clamp(time.g + keySinglePress(KEY_INCREASE_TIME_SCALE) - keyPress(KEY_DECREASE_TIME_SCALE), 0., 8.);\n\t\t\t\ttime.r = mod(time.r + dt * sign(time.g) * pow(2., time.g - 1.), 1200.);\n\n                store3(_pos, pos);\n                store2(_angle, angle);\n                store4(_loadRange, calcLoadRange(pos.xy));\n                store4(_mouse, mouse);\n                store1(_inBlock, inBlock);\n                store3(_vel, vel);\n                store4(_pick, pick);\n                store1(_pickTimer, timer);\n                store1(_renderScale, renderScale);\n                store1(_selectedInventory, selected);\n                store2(_flightMode, flightMode);\n                store2(_sprintMode, sprintMode);\n                store2(_time, time);\n                fragColor = outValue;\n            }\n        }\n        else fragColor = texture(iChannel0, (fragCoord - _old) \/ iResolution.xy);\n    }\n    else fragColor.rgb = vec3(0,0,0);\n}\n\n\n","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define var(name, x, y) const vec2 name = vec2(x, y)\n#define varRow 0.\nvar(_pos, 0, varRow);\nvar(_angle, 2, varRow);\nvar(_mouse, 3, varRow);\nvar(_loadRange, 4, varRow);\nvar(_inBlock, 5, varRow);\nvar(_vel, 6, varRow);\nvar(_pick, 7, varRow);\nvar(_pickTimer, 8, varRow);\nvar(_renderScale, 9, varRow);\nvar(_selectedInventory, 10, varRow);\nvar(_flightMode, 11, varRow);\nvar(_sprintMode, 12, varRow);\nvar(_time, 13, varRow);\nvar(_old, 0, 1);\n\n\nvec4 load(vec2 coord) {\n\treturn texture(iChannel0, vec2((floor(coord) + 0.5) \/ iChannelResolution[1].xy));\n}\n\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));\n}\n\n\/\/\n\/\/ Description : Array and textureless GLSL 2D,3D simplex noise function.\n\/\/      Author : Ian McEwan, Ashima Arts.\n\/\/  Maintainer : stegu\n\/\/     Lastmod : 20110822 (ijm)\n\/\/     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n\/\/               Distributed under the MIT License. See LICENSE file.\n\/\/               https:\/\/github.com\/ashima\/webgl-noise\n\/\/               https:\/\/github.com\/stegu\/webgl-noise\n\/\/\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 \/ 289.0)) * 289.0;\n}\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 \/ 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 \/ 289.0)) * 289.0;\n}\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0\/6.0, 1.0\/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n\/\/ First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n\/\/ Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  \/\/   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  \/\/   x1 = x0 - i1  + 1.0 * C.xxx;\n  \/\/   x2 = x0 - i2  + 2.0 * C.xxx;\n  \/\/   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; \/\/ 2.0*C.x = 1\/3 = C.y\n  vec3 x3 = x0 - D.yyy;      \/\/ -1.0+3.0*C.x = -0.5 = -D.y\n\n\/\/ Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n\/\/ Gradients: 7x7 points over a square, mapped onto an octahedron.\n\/\/ The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; \/\/ 1.0\/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  \/\/  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    \/\/ mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  \/\/vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  \/\/vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n\/\/Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n\/\/ Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  \/\/ (3.0-sqrt(3.0))\/6.0\n                      0.366025403784439,  \/\/ 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  \/\/ -1.0 + 2.0 * C.x\n                      0.024390243902439); \/\/ 1.0 \/ 41.0\n\/\/ First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n\/\/ Other corners\n  vec2 i1;\n  \/\/i1.x = step( x0.y, x0.x ); \/\/ x0.x > x0.y ? 1.0 : 0.0\n  \/\/i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  \/\/ x0 = x0 - 0.0 + 0.0 * C.xx ;\n  \/\/ x1 = x0 - i1 + 1.0 * C.xx ;\n  \/\/ x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n\/\/ Permutations\n  i = mod289(i); \/\/ Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n\/\/ Gradients: 41 points uniformly over a line, mapped onto a diamond.\n\/\/ The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n\/\/ Normalise gradients implicitly by scaling m\n\/\/ Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n\/\/ Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n\nconst vec2 packedChunkSize = vec2(12,7);\nconst float heightLimit = packedChunkSize.x * packedChunkSize.y;\n\nvec2 unswizzleChunkCoord(vec2 storageCoord) {\n \tvec2 s = floor(storageCoord);\n    float dist = max(s.x, s.y);\n    float offset = floor(dist \/ 2.);\n    float neg = step(0.5, mod(dist, 2.)) * 2. - 1.;\n    return neg * (s - offset);\n}\n\nvec2 swizzleChunkCoord(vec2 chunkCoord) {\n    vec2 c = chunkCoord;\n    float dist = max(abs(c.x), abs(c.y));\n    vec2 c2 = floor(abs(c - 0.5));\n    float offset = max(c2.x, c2.y);\n    float neg = step(c.x + c.y, 0.) * -2. + 1.;\n    return (neg * c) + offset;\n}\n\nfloat calcLoadRange(void) {\n\tvec2 chunks = floor(iResolution.xy \/ packedChunkSize);\n    float gridSize = min(chunks.x, chunks.y);\n    return floor((gridSize - 1.) \/ 2.);\n}\n\nvec4 readMapTex(vec2 pos) {\n \treturn texture(iChannel1, (floor(pos) + 0.5) \/ iChannelResolution[0].xy);   \n}\n\nvec3 texToVoxCoord(vec2 textelCoord, vec3 offset) {\n\tvec3 voxelCoord = offset;\n    voxelCoord.xy += unswizzleChunkCoord(textelCoord \/ packedChunkSize);\n    voxelCoord.z += mod(textelCoord.x, packedChunkSize.x) + packedChunkSize.x * mod(textelCoord.y, packedChunkSize.y);\n    return voxelCoord;\n}\n\nvec2 voxToTexCoord(vec3 voxCoord) {\n    vec3 p = floor(voxCoord);\n    return swizzleChunkCoord(p.xy) * packedChunkSize + vec2(mod(p.z, packedChunkSize.x), floor(p.z \/ packedChunkSize.x));\n}\n\nstruct voxel {\n\tfloat id;\n    float sunlight;\n    float torchlight;\n    float hue;\n};\n\nvoxel decodeTextel(vec4 textel) {\n\tvoxel o;\n    o.id = textel.r;\n    o.sunlight = floor(mod(textel.g, 16.));\n    o.torchlight = floor(mod(textel.g \/ 16., 16.));\n    o.hue = textel.b;\n    return o;\n}\n\nvec4 encodeVoxel(voxel v) {\n\tvec4 o;\n    o.r = v.id;\n    o.g = clamp(floor(v.sunlight), 0., 15.) + 16. * clamp(floor(v.torchlight), 0., 15.);\n    o.b = v.hue;\n    o.a = 1.;\n    return o;\n}\n\nbool inRange(vec2 p, vec4 r) {\n\treturn (p.x > r.x && p.x < r.y && p.y > r.z && p.y < r.w);\n}\n\nvoxel getVoxel(vec3 p) {\n    return decodeTextel(readMapTex(voxToTexCoord(p)));\n}\n\nbool overworld(vec3 p) {\n\tfloat density = 48. - p.z;\n    density += mix(0., 40., pow(.5 + .5 * snoise(p.xy \/557. + vec2(0.576, .492)), 2.)) * snoise(p \/ 31.51 + vec3(0.981, .245, .497));\n    return density > 0.;\n}\n\nfloat getInventory(float slot) {\n\treturn slot + 1. + step(2.5, slot);  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 textelCoord = floor(fragCoord);\n    vec3 offset = floor(vec3(load(_pos).xy, 0.));\n    vec3 oldOffset = floor(vec3(load(_old+_pos).xy, 0.));\n    vec3 voxelCoord = texToVoxCoord(textelCoord, offset);            \n    \n    voxel vox;\n    vec4 range = load(_old+_loadRange);\n    vec4 pick = load(_pick);\n    if (!inRange(voxelCoord.xy, range) || iFrame == 0 ) {\n    \tbool solid = overworld(voxelCoord);\n        if (solid) {\n            vox.id = 3.;\n            if (overworld(voxelCoord + vec3(0,0,1))) vox.id = 2.;\n            if (overworld(voxelCoord + vec3(0,0,3))) vox.id = 1.;\n    \t\tif (hash13(voxelCoord) > 0.98 && !overworld(voxelCoord + vec3(0,0,-1))) vox.id = 6.;\n        }\n        if (snoise(voxelCoord \/ 27.99 + vec3(0.981, .245, .497).yzx * 17.) > 1. - (smoothstep(0., 5., voxelCoord.z) - 0.7 * smoothstep(32., 48., voxelCoord.z))) vox.id = 0.;\n        if (voxelCoord.z < 1.) vox.id = 16.;\n        vox.hue = fract(hash13(voxelCoord));\n        vox.sunlight = 0.;\n        vox.torchlight = 0.;\n    }\n    else {\n    \tvox = getVoxel(voxelCoord - oldOffset);\n    }\n\n    if (voxelCoord == pick.xyz) {\n        if (pick.a == 1. && load(_pickTimer).r > 1. && vox.id != 16.) vox.id = 0.;\n        if (pick.a == 2.) vox.id = getInventory(load(_selectedInventory).r);\n    }\n    \n    voxel temp;\n    if (voxelCoord.z == heightLimit - 1.) {\n    \tvox.sunlight = 15.;   \n    }\n    else vox.sunlight = 0.;\n    vox.torchlight = 0.;\n    \/\/if (length(voxelCoord + .5 - load(_pos).xyz) < 1.) vox.torchlight = 15.;\n    if (voxelCoord.z < heightLimit - 1.) {\n    \ttemp = getVoxel(voxelCoord + vec3(0,0,1) - oldOffset);\n        vox.sunlight = max(vox.sunlight, temp.sunlight);\n        vox.torchlight = max(vox.torchlight, temp.torchlight - 1.);\n    }\n    if (voxelCoord.z > 1.) {\n    \ttemp = getVoxel(voxelCoord + vec3(0,0,-1) - oldOffset);\n        vox.sunlight = max(vox.sunlight, temp.sunlight - 1.);\n        vox.torchlight = max(vox.torchlight, temp.torchlight - 1.);\n    }\n    if (voxelCoord.x > range.x + 1.) {\n    \ttemp = getVoxel(voxelCoord + vec3(-1,0,0) - oldOffset);\n        vox.sunlight = max(vox.sunlight, temp.sunlight - 1.);\n        vox.torchlight = max(vox.torchlight, temp.torchlight - 1.);\n    }\n    if (voxelCoord.x < range.y - 1.) {\n    \ttemp = getVoxel(voxelCoord + vec3(1,0,0) - oldOffset);\n        vox.sunlight = max(vox.sunlight, temp.sunlight - 1.);\n        vox.torchlight = max(vox.torchlight, temp.torchlight - 1.);\n    }\n    if (voxelCoord.y > range.z + 1.) {\n    \ttemp = getVoxel(voxelCoord + vec3(0,-1,0) - oldOffset);\n        vox.sunlight = max(vox.sunlight, temp.sunlight - 1.);\n        vox.torchlight = max(vox.torchlight, temp.torchlight - 1.);\n    }\n    if (voxelCoord.y < range.w - 1.) {\n    \ttemp = getVoxel(voxelCoord + vec3(0,1,0) - oldOffset);\n        vox.sunlight = max(vox.sunlight, temp.sunlight - 1.);\n        vox.torchlight = max(vox.torchlight, temp.torchlight - 1.);\n    }\n    \n    if (vox.id > 0.) {\n        vox.sunlight = 0.;\n        vox.torchlight = 0.;\n    }\n    \n    if (vox.id == 6.) {\n    \tvox.torchlight = 15.;   \n    }\n    fragColor = encodeVoxel(vox);\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"#define var(name, x, y) const vec2 name = vec2(x, y)\n#define varRow 0.\nvar(_pos, 0, varRow);\nvar(_angle, 2, varRow);\nvar(_mouse, 3, varRow);\nvar(_loadRange, 4, varRow);\nvar(_inBlock, 5, varRow);\nvar(_vel, 6, varRow);\nvar(_pick, 7, varRow);\nvar(_pickTimer, 8, varRow);\nvar(_renderScale, 9, varRow);\nvar(_selectedInventory, 10, varRow);\nvar(_flightMode, 11, varRow);\nvar(_sprintMode, 12, varRow);\nvar(_time, 13, varRow);\nvar(_old, 0, 1);\n\n\n\nvec4 load(vec2 coord) {\n\treturn texture(iChannel0, vec2((floor(coord) + 0.5) \/ iChannelResolution[0].xy));\n}\n\n\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\nvec4 noiseTex(vec2 c) {\n\treturn texture(iChannel1, c \/ iChannelResolution[1].xy);   \n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\nfloat signed(float x) {\n\treturn x * 2. - 1.;   \n}\n\n\n\/\/From https:\/\/www.shadertoy.com\/view\/4djGRh\nfloat tileableWorley(in vec2 p, in float numCells)\n{\n\tp *= numCells;\n\tfloat d = 1.0e10;\n\tfor (int xo = -1; xo <= 1; xo++)\n\t{\n\t\tfor (int yo = -1; yo <= 1; yo++)\n\t\t{\n\t\t\tvec2 tp = floor(p) + vec2(xo, yo);\n\t\t\ttp = p - tp - hash22(256. * mod(tp, numCells));\n\t\t\td = min(d, dot(tp, tp));\n\t\t}\n\t}\n\treturn sqrt(d);\n\t\/\/return 1.0 - d;\/\/ ...Bubbles.\n}\n\nfloat crackingAnimation(vec2 p, float t) {\n    t = ceil(t * 8.) \/ 8.;\n\tfloat d = 1.0e10;\n    \/\/t *= ;\n    for (float i = 0.; i < 25.; i++) {\n    \tvec2 tp = texture(iChannel1, vec2(4, i) \/ 256.).xy - 0.5;\n        tp *= max(0., (length(tp) + clamp(t, 0., 1.) - 1.) \/ length(tp));\n        d = min(d, length(tp + 0.5 - p));\n    }\n    return pow(mix(clamp(1. - d * 3., 0., 1.), 1., smoothstep(t - 0.3, t + 0.3, max(abs(p.x - 0.5), abs(p.y - 0.5)) * 2.)), .6) * 1.8 - 0.8;\n}\n\nfloat brickPattern(vec2 c) {\n\tfloat o = 1.;\n    if (mod(c.y, 4.) < 1.) o = 0.;\n    if (mod(c.x - 4. * step(4., mod(c.y, 8.)), 8.) > 7.) o = 0.;\n    return o;\n}\nfloat woodPattern(vec2 c) {\n\tfloat o = 1.;\n    if (mod(c.y, 4.) < 1.) o = 0.;\n    if (mod(c.x + 2. - 6. * step(4., mod(c.y, 8.)), 16.) > 15.) o = 0.;\n    return o;\n}\n\n\/\/From https:\/\/github.com\/hughsk\/glsl-hsv2rgb\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 \/ 3.0, 1.0 \/ 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 getTexture(float id, vec2 c) {\n    vec2 gridPos = vec2(mod(id, 16.), floor(id \/ 16.));\n\treturn texture(iChannel2, (c + gridPos * 16.) \/ iChannelResolution[3].xy);\n}\n\n\n\nvoid mainImage( out vec4 o, in vec2 fragCoord )\n{\n    \n    vec2 gridPos = floor(fragCoord \/ 16.);\n    vec2 c = mod(fragCoord, 16.);\n    int id = int(gridPos.x + gridPos.y * 16.);\n    o.a = 1.;\n    if (id == 0) {\n    \to = vec4(1,0,1,1);\n    }\n    if (id == 1) {\n        o.rgb = 0.45 + 0.2 * vec3(noiseTex(c * vec2(.5, 1.) + vec2(floor(hash12(c + vec2(27,19)) * 3. - 1.), 0.)).b);\n    }\n    if (id == 2) {\n    \to.rgb = vec3(0.55,0.4,0.3) * (1. + 0.3 * signed(noiseTex(c + 37.).r));\n        if (hash12(c * 12.) > 0.95) o.rgb = vec3(0.4) + 0.2 * noiseTex(c + 92.).g;\n    }\n    if (id == 3) {\n    \to.rgb = getTexture(2., c).rgb;\n        if (noiseTex(vec2(0, c.x) + 12.).a * 3. + 1. > 16. - c.y) o.rgb = getTexture(4., c).rgb;\n    }\n    if (id == 4) {\n    \to.rgb = hsv2rgb(vec3(0.22, .8 - 0.3 * noiseTex(c + 47.).b, 0.6 + 0.1 * noiseTex(c + 47.).b));\n    }\n    if (id == 5) {\n    \to.rgb = vec3(clamp(pow(1. - tileableWorley(c \/ 16., 4.), 2.), 0.2, 0.6) + 0.2 * tileableWorley(c \/ 16., 5.));\n    }\n    if (id == 6) {\n        float w = 1. - tileableWorley(c \/ 16., 4.);\n        float l = clamp(0.7 * pow(w, 4.) + 0.5 * w, 0., 1.);\n        o.rgb = mix(vec3(.3, .1, .05), vec3(1,1,.6), l);\n        if (w < 0.2) o.rgb = vec3(0.3, 0.25, 0.05);\n    }\n    if (id == 7) {\n    \to.rgb = -0.1 * hash12(c) + mix(vec3(.6,.3,.2) + 0.1 * (1. - brickPattern(c + vec2(-1,1)) * brickPattern(c)), vec3(0.8), 1. - brickPattern(c));\n    }\n    if (id == 8) {\n    \to.rgb = mix(vec3(1,1,.2), vec3(1,.8,.1), sin((c.x - c.y) \/ 3.) * .5 + .5);\n        if (any(greaterThan(abs(c - 8.), vec2(7)))) o.rgb = vec3(1,.8,.1);\n    }\n    if (id == 9) {\n        o.rgb = vec3(0.5,0.4,0.25)*(0.5 + 0.5 * woodPattern(c)) * (1. + 0.2 * noiseTex(c * vec2(.5, 1.) + vec2(floor(hash12(c + vec2(27,19)))) * 3. - 1.).b);\n    }\n    if (id == 16) {\n      \to.rgb = (-1. + 2. * getTexture(1., c).rgb) * 2.5;\n    }\n    if (id == 32) {\n    \to.rgb = vec3(crackingAnimation(c \/ 16., load(_pickTimer).r));\n    }\n    if (id == 48) {\n    \to = vec4(vec3(0.2), 0.7);\n        vec2 p = c - 8.;\n        float d = max(abs(p.x), abs(p.y));\n        if (d > 6.) {\n            o.rgb = vec3(0.7);\n            o.rgb += 0.05 * hash12(c);\n            o.a = 1.;\n            if ((d < 7. && p.x < 6.)|| (p.x > 7. && abs(p.y) < 7.)) o.rgb -= 0.3;\n        }\n        o.rgb += 0.05 * hash12(c);\n        \n    }\n    \n}","name":"Buf C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"\/media\/previz\/buffer03.png","previewfilepath":"\/media\/previz\/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"const float PI = 3.14159265359;\n\n#define var(name, x, y) const vec2 name = vec2(x, y)\n#define varRow 0.\nvar(_pos, 0, varRow);\nvar(_angle, 2, varRow);\nvar(_mouse, 3, varRow);\nvar(_loadRange, 4, varRow);\nvar(_inBlock, 5, varRow);\nvar(_vel, 6, varRow);\nvar(_pick, 7, varRow);\nvar(_pickTimer, 8, varRow);\nvar(_renderScale, 9, varRow);\nvar(_selectedInventory, 10, varRow);\nvar(_flightMode, 11, varRow);\nvar(_sprintMode, 12, varRow);\nvar(_time, 13, varRow);\nvar(_old, 0, 1);\n\n\nvec4 load(vec2 coord) {\n\treturn textureLod(iChannel0, vec2((floor(coord) + 0.5) \/ iChannelResolution[0].xy), 0.0);\n}\n\nvec2 unswizzleChunkCoord(vec2 storageCoord) {\n \tvec2 s = storageCoord;\n    float dist = max(s.x, s.y);\n    float offset = floor(dist \/ 2.);\n    float neg = step(0.5, mod(dist, 2.)) * 2. - 1.;\n    return neg * (s - offset);\n}\n\nvec2 swizzleChunkCoord(vec2 chunkCoord) {\n    vec2 c = chunkCoord;\n    float dist = max(abs(c.x), abs(c.y));\n    vec2 c2 = floor(abs(c - 0.5));\n    float offset = max(c2.x, c2.y);\n    float neg = step(c.x + c.y, 0.) * -2. + 1.;\n    return (neg * c) + offset;\n}\n\n\nconst vec2 packedChunkSize = vec2(12,7);\n\nvec4 readMapTex(vec2 pos) {\n \treturn textureLod(iChannel1, (floor(pos) + 0.5) \/ iChannelResolution[0].xy, 0.0);   \n}\n\nvec2 voxToTexCoord(vec3 p) {\n \tp = floor(p);\n    return swizzleChunkCoord(p.xy) * packedChunkSize + vec2(mod(p.z, packedChunkSize.x), floor(p.z \/ packedChunkSize.x));\n}\n\nbool getHit(vec3 c) {\n\tvec3 p = vec3(c) + vec3(0.5);\n\tfloat d = readMapTex(voxToTexCoord(p)).r;\n\treturn d > 0.5;\n}\n\nvec2 rotate2d(vec2 v, float a) {\n\tfloat sinA = sin(a);\n\tfloat cosA = cos(a);\n\treturn vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);\t\n}\n\n\/\/From https:\/\/github.com\/hughsk\/glsl-hsv2rgb\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 \/ 3.0, 1.0 \/ 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 getTexture(float id, vec2 c) {\n    vec2 gridPos = vec2(mod(id, 16.), floor(id \/ 16.));\n\treturn textureLod(iChannel2, 16. * (c + gridPos) \/ iChannelResolution[3].xy, 0.0);\n}\n\n\nbool inRange(vec2 p, vec4 r) {\n\treturn (p.x > r.x && p.x < r.y && p.y > r.z && p.y < r.w);\n}\n\nstruct voxel {\n\tfloat id;\n    vec2 light;\n    float hue;\n};\n\nvoxel decodeTextel(vec4 textel) {\n\tvoxel o;\n    o.id = textel.r;\n    o.light.s = floor(mod(textel.g, 16.));\n    o.light.t = floor(mod(textel.g \/ 16., 16.));\n    o.hue = textel.b;\n    return o;\n}\n\nvoxel getVoxel(vec3 p) {\n    return decodeTextel(readMapTex(voxToTexCoord(p)));\n}\n\nvec2 max24(vec2 a, vec2 b, vec2 c, vec2 d) {\n\treturn max(max(a, b), max(c, d));   \n}\n\nfloat lightLevelCurve(float t) {\n    t = mod(t, 1200.);\n\treturn 1. - ( smoothstep(400., 700., t) - smoothstep(900., 1200., t));\n}\n\nvec3 lightmap(vec2 light) {\n    light = 15. - light;\n    return clamp(mix(vec3(0), mix(vec3(0.11, 0.11, 0.21), vec3(1), lightLevelCurve(load(_time).r)), pow(.8, light.s)) + mix(vec3(0), vec3(1.3, 1.15, 1), pow(.75, light.t)), 0., 1.);   \n}\n\nfloat vertexAo(float side1, float side2, float corner) {\n\treturn 1. - (side1 + side2 + max(corner, side1 * side2)) \/ 5.0;\n}\n\nfloat opaque(float id) {\n\treturn id > .5 ? 1. : 0.;   \n}\n\nvec3 calcLightingFancy(vec3 r, vec3 s, vec3 t, vec2 uv) {\n\tvoxel v1, v2, v3, v4, v5, v6, v7, v8, v9;\n    \/\/uv = (floor(uv * 16.) + .5) \/ 16.;\n    v1 = getVoxel(r - s + t);\n    v2 = getVoxel(r + t);\n    v3 = getVoxel(r + s + t);\n    v4 = getVoxel(r - s);\n    v5 = getVoxel(r);\n    v6 = getVoxel(r + s);\n    v7 = getVoxel(r - s - t);\n    v8 = getVoxel(r - t);\n    v9 = getVoxel(r + s - t);\n    \n    \/\/return vec3(uv, 0.) - .5 * opaque(v6.id);\n    \n    vec2 light1, light2, light3, light4, light;\n    light1 = max24(v1.light, v2.light, v4.light, v5.light);\n    light2 = max24(v2.light, v3.light, v5.light, v6.light);\n    light3 = max24(v4.light, v5.light, v7.light, v8.light);\n    light4 = max24(v5.light, v6.light, v8.light, v9.light);\n    \n    float ao1, ao2, ao3, ao4, ao;\n    ao1 = vertexAo(opaque(v2.id), opaque(v4.id), opaque(v1.id));\n    ao2 = vertexAo(opaque(v2.id), opaque(v6.id), opaque(v3.id));\n    ao3 = vertexAo(opaque(v8.id), opaque(v4.id), opaque(v7.id));\n    ao4 = vertexAo(opaque(v8.id), opaque(v6.id), opaque(v9.id));\n    \n    light = mix(mix(light3, light4, uv.x), mix(light1, light2, uv.x), uv.y);\n    ao = mix(mix(ao3, ao4, uv.x), mix(ao1, ao2, uv.x), uv.y);\n    \n    return lightmap(light) * pow(ao, 1. \/ 1.);\n}\n\nvec3 calcLightingFast(vec3 r, vec3 s, vec3 t, vec2 uv) {\n    return lightmap(min(getVoxel(r).light + 0.2, 15.));\n}\n\nstruct rayCastResults {\n\tbool hit;\n    vec3 rayPos;\n    vec3 mapPos;\n    vec3 normal;\n    vec2 uv;\n    vec3 tangent;\n    vec3 bitangent;\n    float dist;\n};\n\nrayCastResults rayCast(vec3 rayPos, vec3 rayDir, vec3 offset, vec4 range) {\n\tvec3 mapPos = floor(rayPos);\n    vec3 deltaDist = abs(vec3(length(rayDir)) \/ rayDir);\n    vec3 rayStep = sign(rayDir);\n    vec3 sideDist = (sign(rayDir) * (mapPos - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; \n    vec3 mask;\n    bool hit = false;\n    for (int i = 0; i < 384; i++) {\n\t\tmask = step(sideDist.xyz, sideDist.yzx) * step(sideDist.xyz, sideDist.zxy);\n\t\tsideDist += vec3(mask) * deltaDist;\n\t\tmapPos += vec3(mask) * rayStep;\n\t\t\n        if (!inRange(mapPos.xy, range) || mapPos.z < 0. || mapPos.z >= packedChunkSize.x * packedChunkSize.y) break;\n        if (getHit(mapPos - offset)) { \n            hit = true; \n            break;\n        }\n\n\t}\n    vec3 endRayPos = rayDir \/ dot(mask * rayDir, vec3(1)) * dot(mask * (mapPos + step(rayDir, vec3(0)) - rayPos), vec3(1)) + rayPos;\n   \tvec2 uv;\n    vec3 tangent1;\n    vec3 tangent2;\n    if (abs(mask.x) > 0.) {\n        uv = endRayPos.yz;\n        tangent1 = vec3(0,1,0);\n        tangent2 = vec3(0,0,1);\n    }\n    else if (abs(mask.y) > 0.) {\n        uv = endRayPos.xz;\n        tangent1 = vec3(1,0,0);\n        tangent2 = vec3(0,0,1);\n    }\n    else {\n        uv = endRayPos.xy;\n        tangent1 = vec3(1,0,0);\n        tangent2 = vec3(0,1,0);\n    }\n    uv = fract(uv);\n    rayCastResults res;\n    res.hit = hit;\n    res.uv = uv;\n    res.mapPos = mapPos;\n    res.normal = -rayStep * mask;\n    res.tangent = tangent1;\n    res.bitangent = tangent2;\n    res.rayPos = endRayPos;\n    res.dist = length(rayPos - endRayPos);\n    return res;\n}\n\n\nvec3 skyColor(vec3 rayDir) {\n    float t = load(_time).r;\n    float lightLevel = lightLevelCurve(t);\n    float sunAngle = (t * PI * 2. \/ 1200.) + PI \/ 4.;\n    vec3 sunDir = vec3(cos(sunAngle), 0, sin(sunAngle));\n    \n    vec3 daySkyColor = vec3(.5,.75,1);\n    vec3 dayHorizonColor = vec3(0.8,0.8,0.9);\n    vec3 nightSkyColor = vec3(0.1,0.1,0.2) \/ 2.;\n    \n    vec3 skyColor = mix(nightSkyColor, daySkyColor, lightLevel);\n    vec3 horizonColor = mix(nightSkyColor, dayHorizonColor, lightLevel);\n    float sunVis = smoothstep(.99, 0.995, dot(sunDir, rayDir));\n    float moonVis = smoothstep(.999, 0.9995, dot(-sunDir, rayDir));\n    return mix(mix(mix(horizonColor, skyColor, clamp(dot(rayDir, vec3(0,0,1)), 0., 1.)), vec3(1,1,0.95), sunVis), vec3(0.8), moonVis);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float scaleFactor = pow(sqrt(2.), load(_renderScale).r);\n    vec2 renderResolution = ceil(iResolution.xy \/ scaleFactor); \n    if (any(greaterThan(fragCoord, renderResolution))) {\n        fragColor = vec4(0);\n        return;\n    }\n    vec2 screenPos = (fragCoord.xy \/ renderResolution.xy) * 2.0 - 1.0;\n\tvec3 rayPos = load(_pos).xyz + vec3(0,0,1.6);\n    vec2 angle = load(_angle).xy;\n    vec4 range = load(_loadRange);\n    vec3 cameraDir = vec3(sin(angle.y) * cos(angle.x), sin(angle.y) * sin(angle.x), cos(angle.y));\n    vec3 cameraPlaneU = vec3(normalize(vec2(cameraDir.y, -cameraDir.x)), 0);\n    vec3 cameraPlaneV = cross(cameraPlaneU, cameraDir) * renderResolution.y \/ renderResolution.x;\n\tvec3 rayDir = normalize(cameraDir + screenPos.x * cameraPlaneU + screenPos.y * cameraPlaneV);\n\t\n\tvec3 mapPos = vec3(floor(rayPos));\n    vec3 offset = vec3(floor(load(_pos).xy), 0.);\n\tvec3 deltaDist = abs(vec3(length(rayDir)) \/ rayDir);\n\t\n\tvec3 rayStep = vec3(sign(rayDir));\n\n\tvec3 sideDist = (sign(rayDir) * (vec3(mapPos) - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; \n\t\n\tvec3 mask;\n    \n    mapPos;\n    \n    rayCastResults res = rayCast(rayPos, rayDir, offset, range);\n\t\n\tvec3 color = vec3(0);\n    voxel vox = getVoxel(res.mapPos - offset);\n    if (res.hit) {\n        \n        color = calcLightingFancy(res.mapPos - offset + res.normal, res.tangent, res.bitangent, res.uv);\n        \/\/color *= hsv2rgb(vec3(getVoxel(mapPos + .5 - offset).hue, .1, 1));\n        float textureId = vox.id;\n        if (textureId == 3.) textureId += res.normal.z;\n        color *= getTexture(textureId, res.uv).rgb;\n        vec4 pick = load(_pick);\n        if (res.mapPos == pick.xyz) {\n            if (pick.a == 1.) color *= getTexture(32., res.uv).r;\n            else color = mix(color, vec3(1), 0.2);\n        }\n        \/\/color.rgb = res.uv.xyx;\n    }\n    \/\/else color = mix(lightmap(vec2(0)) \/ 2., skyColor(rayDir), vox.light.s \/ 15.);\n    else color = skyColor(rayDir);\n    fragColor.rgb = pow(color, vec3(1.));\n    \n}\n\n","name":"Buf D","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"ltfSWn","date":"1360571561","viewed":17943,"name":"Mandelbulb - derivative","username":"iq","description":"A Mandelbulb implementation. Two tricks worth noting: [1] it doesn't use pow() functions to compute complex number powers, but it uses algebra instead.  [2] the distance estimator (DE) is analytic, not based on numerically computed gradient.  ","likes":123,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Copyright Inigo Quilez, 2013 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work neither\n\/\/ as it is or altered, here on Shadertoy or anywhere else, in any\n\/\/ form including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it or train a neural\n\/\/ network with it without permission. I share this Work for educational\n\/\/ purposes, and you can link to it, through an URL, proper attribution\n\/\/ and unmodified screenshot, as part of your educational material. If\n\/\/ these conditions are too restrictive please contact me and we'll\n\/\/ definitely work it out.\n\n\/\/ The source code for these videos from 2009: \n\/\/ https:\/\/www.youtube.com\/watch?v=eKUh4nkmQbc\n\/\/ https:\/\/www.youtube.com\/watch?v=erS6SKqtXLY\n\/\/\n\/\/ More info here: https:\/\/iquilezles.org\/articles\/mandelbulb\n\/\/\n\/\/ See https:\/\/www.shadertoy.com\/view\/MdfGRr to see the Julia counterpart\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2  \/\/ make AA 1 for slow machines or 3 for fast machines\n#endif\n\n\/\/ https:\/\/iquilezles.org\/articles\/intersectors\nvec2 isphere( in vec4 sph, in vec3 ro, in vec3 rd )\n{\n    vec3 oc = ro - sph.xyz;\n\tfloat b = dot(oc,rd);\n\tfloat c = dot(oc,oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return -b + vec2(-h,h);\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/mandelbulb\nfloat map( in vec3 p, out vec4 resColor )\n{\n    vec3 w = p;\n    float m = dot(w,w);\n\n    vec4 trap = vec4(abs(w),m);\n\tfloat dz = 1.0;\n    \n\tfor( int i=0; i<4; i++ )\n    {\n#if 0\n        \/\/ polynomial version (no trigonometrics, but MUCH slower)\n        float m2 = m*m;\n        float m4 = m2*m2;\n\t\tdz = 8.0*sqrt(m4*m2*m)*dz + 1.0;\n\n        float x = w.x; float x2 = x*x; float x4 = x2*x2;\n        float y = w.y; float y2 = y*y; float y4 = y2*y2;\n        float z = w.z; float z2 = z*z; float z4 = z2*z2;\n\n        float k3 = x2 + z2;\n        float k2 = inversesqrt( k3*k3*k3*k3*k3*k3*k3 );\n        float k1 = x4 + y4 + z4 - 6.0*y2*z2 - 6.0*x2*y2 + 2.0*z2*x2;\n        float k4 = x2 - y2 + z2;\n\n        w.x = p.x +  64.0*x*y*z*(x2-z2)*k4*(x4-6.0*x2*z2+z4)*k1*k2;\n        w.y = p.y + -16.0*y2*k3*k4*k4 + k1*k1;\n        w.z = p.z +  -8.0*y*k4*(x4*x4 - 28.0*x4*x2*z2 + 70.0*x4*z4 - 28.0*x2*z2*z4 + z4*z4)*k1*k2;\n#else\n        \/\/ trigonometric version (MUCH faster than polynomial)\n        \n        \/\/ dz = 8*z^7*dz\n\t\tdz = 8.0*pow(m,3.5)*dz + 1.0;\n      \n        \/\/ z = z^8+c\n        float r = length(w);\n        float b = 8.0*acos( w.y\/r);\n        float a = 8.0*atan( w.x, w.z );\n        w = p + pow(r,8.0) * vec3( sin(b)*sin(a), cos(b), sin(b)*cos(a) );\n#endif        \n        \n        trap = min( trap, vec4(abs(w),m) );\n\n        m = dot(w,w);\n\t\tif( m > 256.0 )\n            break;\n    }\n\n    resColor = vec4(m,trap.yzw);\n\n    \/\/ distance estimation (through the Hubbard-Douady potential)\n    return 0.25*log(m)*sqrt(m)\/dz;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/normalsSDF\nvec3 calcNormal( in vec3 pos, in float t, in float px )\n{\n    vec4 tmp;\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.25*px;\n    return normalize( e.xyy*map( pos + e.xyy,tmp ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx,tmp ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy,tmp ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx,tmp ) );\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/rmshadows\nfloat softshadow( in vec3 ro, in vec3 rd, in float k )\n{\n    float res = 1.0;\n    float t = 0.0;\n    for( int i=0; i<64; i++ )\n    {\n        vec4 kk;\n        float h = map(ro + rd*t, kk);\n        res = min( res, k*h\/t );\n        if( res<0.001 ) break;\n        t += clamp( h, 0.01, 0.2 );\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat raycast( in vec3 ro, in vec3 rd, out vec4 rescol, in float px )\n{\n    float res = -1.0;\n\n    \/\/ bounding sphere\n    vec2 dis = isphere( vec4(0.0,0.0,0.0,1.25), ro, rd );\n    if( dis.y<0.0 ) return -1.0;\n    dis.x = max( dis.x, 0.0 );\n    dis.y = min( dis.y, 10.0 );\n\n    \/\/ raymarch fractal distance field\n\tvec4 trap;\n\n\tfloat t = dis.x;\n\tfor( int i=0; i<128; i++  )\n    { \n        vec3 pos = ro + rd*t;\n        float th = 0.25*px*t;\n\t\tfloat h = map( pos, trap );\n\t\tif( t>dis.y || h<th ) break;\n        t += h;\n    }\n    \n    if( t<dis.y )\n    {\n        rescol = trap;\n        res = t;\n    }\n\n    return res;\n}\n\nconst vec3 light1 = vec3(  0.577, 0.577, -0.577 );\nconst vec3 light2 = vec3( -0.707, 0.000,  0.707 );\n\nvec3 refVector( in vec3 v, in vec3 n )\n{\n    return v;\n    float k = dot(v,n);\n    \/\/return (k>0.0) ? v : -v;\n    return (k>0.0) ? v : v-2.0*n*k;\n}\n\n\nvec3 render( in vec2 p, in mat4 cam )\n{\n\t\/\/ ray setup\n    const float fle = 1.5;\n\n    vec2  sp = (2.0*p-iResolution.xy) \/ iResolution.y;\n    float px = 2.0\/(iResolution.y*fle);\n\n    vec3  ro = vec3( cam[0].w, cam[1].w, cam[2].w );\n\tvec3  rd = normalize( (cam*vec4(sp,fle,0.0)).xyz );\n\n    \/\/ intersect fractal\n\tvec4 tra;\n    float t = raycast( ro, rd, tra, px );\n    \n\tvec3 col;\n\n    \/\/ color sky\n    if( t<0.0 )\n    {\n     \tcol  = vec3(0.8,.9,1.1)*(0.6+0.4*rd.y);\n\t\tcol += 5.0*vec3(0.8,0.7,0.5)*pow( clamp(dot(rd,light1),0.0,1.0), 32.0 );\n\t}\n    \/\/ color fractal\n\telse\n\t{\n        \/\/ color\n        col = vec3(0.01);\n\t\tcol = mix( col, vec3(0.10,0.20,0.30), clamp(tra.y,0.0,1.0) );\n\t \tcol = mix( col, vec3(0.02,0.10,0.30), clamp(tra.z*tra.z,0.0,1.0) );\n        col = mix( col, vec3(0.30,0.10,0.02), clamp(pow(tra.w,6.0),0.0,1.0) );\n        col *= 0.5;\n        \n        \/\/ lighting terms\n        vec3  pos = ro + t*rd;\n        vec3  nor = calcNormal( pos, t, px );\n        \n        nor = refVector(nor,-rd);\n        \n        vec3  hal = normalize( light1-rd);\n        vec3  ref = reflect( rd, nor );\n        float occ = clamp(0.05*log(tra.x),0.0,1.0);\n        float fac = clamp(1.0+dot(rd,nor),0.0,1.0);\n\n        \/\/ sun\n        float sha1 = softshadow( pos+0.001*nor, light1, 32.0 );\n        float dif1 = clamp( dot( light1, nor ), 0.0, 1.0 )*sha1;\n        float spe1 = pow( clamp(dot(nor,hal),0.0,1.0), 32.0 )*dif1*(0.04+0.96*pow(clamp(1.0-dot(hal,light1),0.0,1.0),5.0));\n        \/\/ bounce\n        float dif2 = clamp( 0.5 + 0.5*dot( light2, nor ), 0.0, 1.0 )*occ;\n        \/\/ sky\n        float dif3 = (0.7+0.3*nor.y)*(0.2+0.8*occ);\n        \n\t\tvec3 lin = vec3(0.0); \n\t\t     lin += 12.0*vec3(1.50,1.10,0.70)*dif1;\n\t\t     lin +=  4.0*vec3(0.25,0.20,0.15)*dif2;\n        \t lin +=  1.5*vec3(0.10,0.20,0.30)*dif3;\n             lin +=  2.5*vec3(0.35,0.30,0.25)*(0.05+0.95*occ);\n        \t lin +=  4.0*fac*occ;\n\t\tcol *= lin;\n\t\tcol = pow( col, vec3(0.7,0.9,1.0) );\n        col += spe1*15.0;\n    }\n\n    \/\/ gamma\n\tcol = pow( col, vec3(0.4545) );\n    \n    \/\/ vignette\n    col *= 1.0 - 0.05*length(sp);\n\n    return col;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*.1;\n\n    \/\/ camera\n\tfloat di = 1.4+0.1*cos(.29*time);\n\tvec3  ro = di*vec3( cos(.33*time), 0.8*sin(.37*time), sin(.31*time) );\n\tvec3  ta = vec3(0.0,0.1,0.0);\n\tfloat cr = 0.5*cos(0.1*time);\n\n    \/\/ camera matrix\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cw = normalize(ta-ro);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv =          (cross(cu,cw));\n    mat4 cam = mat4( cu, ro.x, cv, ro.y, cw, ro.z, 0.0, 0.0, 0.0, 1.0 );\n\n    \/\/ render\n    #if AA<2\n\tvec3 col = render(  fragCoord, cam );\n    #else\n    #define ZERO (min(iFrame,0))\n    vec3 col = vec3(0.0);\n    for( int j=ZERO; j<AA; j++ )\n    for( int i=ZERO; i<AA; i++ )\n    {\n\t    col += render( fragCoord + (vec2(i,j)\/float(AA)), cam );\n    }\n\tcol \/= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"MtjGRd","date":"1431576207","viewed":17908,"name":"Palette Dithering Test","username":"Flyguy","description":" Testing palette dithering using the bayer matrix texture and colors from the Commodore 64's color palette.","likes":176,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"\/media\/a\/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"\/media\/ap\/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DITHER\n#define AUTO_MODE\n#define DOWN_SCALE 2.0\n\n#define MAX_STEPS 196\n#define MIN_DIST 0.002\n#define NORMAL_SMOOTHNESS 0.1\n#define PI 3.14159265359\n\n#define PALETTE_SIZE 16\n#define SUB_PALETTE_SIZE 8\n\n#define RGB(r,g,b) (vec3(r,g,b) \/ 255.0)\n\nvec3 palette[PALETTE_SIZE];\nvec3 subPalette[SUB_PALETTE_SIZE];\n\n\/\/Initalizes the color palette.\nvoid InitPalette()\n{\n    \/\/16-Color C64 color palette.\n\tpalette = vec3[](\n        RGB(  0,  0,  0),\n        RGB(255,255,255),\n        RGB(152, 75, 67),\n        RGB(121,193,200),\t\n        RGB(155, 81,165),\n        RGB(104,174, 92),\n        RGB( 62, 49,162),\n        RGB(201,214,132),\t\n        RGB(155,103, 57),\n        RGB(106, 84,  0),\n        RGB(195,123,117),\n        RGB( 85, 85, 85),\t\n        RGB(138,138,138),\n        RGB(163,229,153),\n        RGB(138,123,206),\n        RGB(173,173,173)\n\t);\n    \n    \/\/8-Color metalic-like sub palette.\n\tsubPalette = vec3[](\n        palette[ 6],\n        palette[11],\n        palette[ 4],\n        palette[14],\n        palette[ 5],\n        palette[ 3],\n        palette[13],\n        palette[ 1]\n\t);\n\t\n}\n\n\/\/Blends the nearest two palette colors with dithering.\nvec3 GetDitheredPalette(float x,vec2 pixel)\n{\n\tfloat idx = clamp(x,0.0,1.0)*float(SUB_PALETTE_SIZE-1);\n\t\n\tvec3 c1 = vec3(0);\n\tvec3 c2 = vec3(0);\n\t\n\tc1 = subPalette[int(idx)];\n    c2 = subPalette[int(idx) + 1];\n    \n    #ifdef DITHER\n    \tfloat dith = texture(iChannel0, pixel \/ iChannelResolution[0].xy).r;\n    \tfloat mixAmt = float(fract(idx) > dith);\n    #else\n    \tfloat mixAmt = fract(idx);\n    #endif\n    \n\treturn mix(c1,c2,mixAmt);\n}\n\n\/\/Returns a 2D rotation matrix for the given angle.\nmat2 Rotate(float angle)\n{\n\treturn mat2(cos(angle), sin(angle), -sin(angle), cos(angle));   \n}\n\n\/\/Distance field functions & operations by iq. (https:\/\/iquilezles.org\/articles\/distfunctions)\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opI( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return q;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n\/\/Scene definition\/distance function.\nfloat Scene(vec3 pos)\n{\n    float map = -sdSphere(pos, 24.0);\n    \n    vec3 rep = opRep(pos - 2.0, vec3(4.0));\n    \n    map = opU(map, opI(sdBox(pos, vec3(5.5)), sdSphere(rep, 1.0)));\n    \n    vec3 gSize = vec3(0, 0, 0.25);\n    \n    float grid = opU(opU(sdCylinder(rep.xyz, gSize), sdCylinder(rep.xzy, gSize)), sdCylinder(rep.zxy, gSize));\n     \n    grid = opI(sdBox(pos,vec3(4.5)),grid);\n    \n    map = opU(map, grid);\n    \n    return map;\n}\n\n\/\/Returns the normal of the surface at the given position.\nvec3 Normal(vec3 pos)\n{\n\tvec3 offset = vec3(NORMAL_SMOOTHNESS, 0, 0);\n    \n    vec3 normal = vec3\n    (\n        Scene(pos - offset.xyz) - Scene(pos + offset.xyz),\n        Scene(pos - offset.zxy) - Scene(pos + offset.zxy),\n        Scene(pos - offset.yzx) - Scene(pos + offset.yzx)\n    );\n    \n    return normalize(normal);\n}\n\n\/\/Marches a ray defined by the origin and direction and returns the hit position.\nvec3 RayMarch(vec3 origin,vec3 direction)\n{\n    float hitDist = 0.0;\n    \n    for(int i = 0;i < MAX_STEPS;i++)\n    {\n        float sceneDist = Scene(origin + direction * hitDist);\n        \n        hitDist += sceneDist;\n        \n        if(sceneDist < MIN_DIST)\n        {\n            break;\n        }\n    }\n    \n    return origin + direction * hitDist;\n}\n\n\/\/Scene shading.\nvec3 Shade(vec3 position, vec3 normal, vec3 rayOrigin,vec3 rayDirection,vec2 pixel)\n{\n    vec3 color = vec3(0);\n    \n    float ang = iTime * 2.0;\n    \n    vec3 lightPos = vec3(cos(ang), cos(ang*2.0), sin(ang)) * 2.0;  \n    \n    \/\/Normal shading\n\tfloat shade = 0.4 * max(0.0, dot(normal, normalize(-lightPos)));\n    \n    \/\/Specular highlight\n    shade += 0.6 * max(0.0, dot(-reflect(normalize(position - lightPos), normal), rayDirection));\n    \n    \/\/Linear falloff\n    shade *= (16.0-distance(position, lightPos))\/16.0,\n    \n    \/\/Apply palette\n    color = GetDitheredPalette(shade, pixel);\n\n    \/\/color = mix(color, vec3(0.1), step(22.0, length(position)));\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitPalette();\n    \n    vec2 aspect = iResolution.xy \/ iResolution.y;\n    \n    fragCoord = floor(fragCoord \/ DOWN_SCALE) * DOWN_SCALE;\n    \n\tvec2 uv = fragCoord.xy \/ iResolution.y;\n    \n    vec2 mouse = iMouse.xy \/ iResolution.xy - 0.5;\n    \n    vec2 camAngle = vec2(0);\n    \n    #ifdef AUTO_MODE\n\t\tcamAngle.x = PI * (-1.0 \/ 8.0) * sin(iTime * 0.5);\n    \tcamAngle.y = -iTime;\n    #else\n        camAngle.x = PI * mouse.y + PI \/ 2.0;\n        camAngle.x += PI \/ 3.0;\n\n        camAngle.y = 2.0 * PI * -mouse.x;\n        camAngle.y += PI;\n    #endif\n    \n    vec3 rayOrigin = vec3(0 , 0, -16.0);\n    vec3 rayDirection = normalize(vec3(uv - aspect \/ 2.0, 1.0));\n    \n    mat2 rotateX = Rotate(camAngle.x);\n    mat2 rotateY = Rotate(camAngle.y);\n    \n    \/\/Transform ray origin and direction\n    rayOrigin.yz *= rotateX;\n    rayOrigin.xz *= rotateY;\n    rayDirection.yz *= rotateX;\n    rayDirection.xz *= rotateY;\n    \n    vec3 scenePosition = RayMarch(rayOrigin, rayDirection);\n    \n    vec3 outColor = Shade(scenePosition,Normal(scenePosition), rayOrigin, rayDirection, fragCoord \/ DOWN_SCALE);\n    \n    \/\/Palette preview\n    if(uv.x < 0.05) \n    {\n        outColor = GetDitheredPalette(uv.y, fragCoord \/ DOWN_SCALE);\n    }\n    \n\tfragColor = vec4(outColor, 1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"MtcGDf","date":"1473017863","viewed":17849,"name":"No Man's Starfield","username":"marian42","description":"Flight through a starfield inspired by the galactic map in No Man's Sky","likes":136,"published":3,"flags":32,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float FLIGHT_SPEED = 8.0;\n\nconst float DRAW_DISTANCE = 60.0; \/\/ Lower this to increase framerate\nconst float FADEOUT_DISTANCE = 10.0; \/\/ must be < DRAW_DISTANCE    \nconst float FIELD_OF_VIEW = 1.05;   \n\nconst float STAR_SIZE = 0.6; \/\/ must be > 0 and < 1\nconst float STAR_CORE_SIZE = 0.14;\n\nconst float CLUSTER_SCALE = 0.02;\nconst float STAR_THRESHOLD = 0.775;\n\nconst float BLACK_HOLE_CORE_RADIUS = 0.2;\nconst float BLACK_HOLE_THRESHOLD = 0.9995;\nconst float BLACK_HOLE_DISTORTION = 0.03;\n\n\/\/ http:\/\/lolengine.net\/blog\/2013\/07\/27\/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 \/ 3.0, 1.0 \/ 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\/\/ https:\/\/stackoverflow.com\/questions\/4200224\/random-noise-functions-for-glsl\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 getRayDirection(vec2 fragCoord, vec3 cameraDirection) {\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n\t\n    const float screenWidth = 1.0;\n    float originToScreen = screenWidth \/ 2.0 \/ tan(FIELD_OF_VIEW \/ 2.0);\n    \n    vec3 screenCenter = originToScreen * cameraDirection;\n    vec3 baseX = normalize(cross(screenCenter, vec3(0, -1.0, 0)));\n    vec3 baseY = normalize(cross(screenCenter, baseX));\n    \n    return normalize(screenCenter + (uv.x - 0.5) * baseX + (uv.y - 0.5) * iResolution.y \/ iResolution.x * baseY);\n}\n\nfloat getDistance(ivec3 chunkPath, vec3 localStart, vec3 localPosition) {\n    return length(vec3(chunkPath) + localPosition - localStart);\n}\n\nvoid move(inout vec3 localPosition, vec3 rayDirection, vec3 directionBound) {\n    vec3 directionSign = sign(rayDirection);\n\tvec3 amountVector = (directionBound - directionSign * localPosition) \/ abs(rayDirection);\n    \n    float amount = min(amountVector.x, min(amountVector.y, amountVector.z));\n    \n    localPosition += amount * rayDirection;\n}\n\n\/\/ Makes sure that each component of localPosition is >= 0 and <= 1\nvoid moveInsideBox(inout vec3 localPosition, inout ivec3 chunk, vec3 directionSign, vec3 direcctionBound) {\n    const float eps = 0.0000001;\n    if (localPosition.x * directionSign.x >= direcctionBound.x - eps) {\n        localPosition.x -= directionSign.x;\n        chunk.x += int(directionSign.x);\n    } else if (localPosition.y * directionSign.y >= direcctionBound.y - eps) {\n        localPosition.y -= directionSign.y;\n        chunk.y += int(directionSign.y);\n    } else if (localPosition.z * directionSign.z >= direcctionBound.z - eps) {\n        localPosition.z -= directionSign.z;\n        chunk.z += int(directionSign.z);\n    }\n}\n\nbool hasStar(ivec3 chunk) {\n    return texture(iChannel0, mod(CLUSTER_SCALE * (vec2(chunk.xy) + vec2(chunk.zx)) + vec2(0.724, 0.111), 1.0)).r > STAR_THRESHOLD\n        && texture(iChannel0, mod(CLUSTER_SCALE * (vec2(chunk.xz) + vec2(chunk.zy)) + vec2(0.333, 0.777), 1.0)).r > STAR_THRESHOLD;\n}\n\nbool hasBlackHole(ivec3 chunk) {\n    return rand(0.0001 * vec2(chunk.xy) + 0.002 * vec2(chunk.yz)) > BLACK_HOLE_THRESHOLD;\n}\n\nvec3 getStarToRayVector(vec3 rayBase, vec3 rayDirection, vec3 starPosition) {\n\tfloat r = (dot(rayDirection, starPosition) - dot(rayDirection, rayBase)) \/ dot(rayDirection, rayDirection);\n    vec3 pointOnRay = rayBase + r * rayDirection;\n    return pointOnRay - starPosition;\n}\n\nvec3 getStarPosition(ivec3 chunk, float starSize) {\n    vec3 position = abs(vec3(rand(vec2(float(chunk.x) \/ float(chunk.y) + 0.24, float(chunk.y) \/ float(chunk.z) + 0.66)),\n                             rand(vec2(float(chunk.x) \/ float(chunk.z) + 0.73, float(chunk.z) \/ float(chunk.y) + 0.45)),\n                             rand(vec2(float(chunk.y) \/ float(chunk.x) + 0.12, float(chunk.y) \/ float(chunk.z) + 0.76))));\n    \n    return starSize * vec3(1.0) + (1.0 - 2.0 * starSize) * position;\n}\n\nvec4 getNebulaColor(vec3 globalPosition, vec3 rayDirection) {\n    vec3 color = vec3(0.0);\n    float spaceLeft = 1.0;\n    \n    const float layerDistance = 10.0;\n    float rayLayerStep = rayDirection.z \/ layerDistance;\n    \n    const int steps = 4;\n    for (int i = 0; i <= steps; i++) {\n    \tvec3 noiseeval = globalPosition + rayDirection * ((1.0 - fract(globalPosition.z \/ layerDistance) + float(i)) * layerDistance \/ rayDirection.z);\n    \tnoiseeval.xy += noiseeval.z;\n        \n        \n        float value = 0.06 * texture(iChannel0, fract(noiseeval.xy \/ 60.0)).r;\n         \n        if (i == 0) {\n            value *= 1.0 - fract(globalPosition.z \/ layerDistance);\n        } else if (i == steps) {\n            value *= fract(globalPosition.z \/ layerDistance);\n        }\n        \n        float hue = mod(noiseeval.z \/ layerDistance \/ 34.444, 1.0);\n        \n        color += spaceLeft * hsv2rgb(vec3(hue, 1.0, value));\n        spaceLeft = max(0.0, spaceLeft - value * 2.0);\n    }\n    return vec4(color, 1.0);\n}\n\nvec4 getStarGlowColor(float starDistance, float angle, float hue) {\n    float progress = 1.0 - starDistance;\n    return vec4(hsv2rgb(vec3(hue, 0.3, 1.0)), 0.4 * pow(progress, 2.0) * mix(pow(abs(sin(angle * 2.5)), 8.0), 1.0, progress));\n}\n\nfloat atan2(vec2 value) {\n    if (value.x > 0.0) {\n        return atan(value.y \/ value.x);\n    } else if (value.x == 0.0) {\n    \treturn 3.14592 * 0.5 * sign(value.y);   \n    } else if (value.y >= 0.0) {\n        return atan(value.y \/ value.x) + 3.141592;\n    } else {\n        return atan(value.y \/ value.x) - 3.141592;\n    }\n}\n\nvec3 getStarColor(vec3 starSurfaceLocation, float seed, float viewDistance) {\n    const float DISTANCE_FAR = 20.0;\n    const float DISTANCE_NEAR = 15.0;\n    \n    if (viewDistance > DISTANCE_FAR) {\n    \treturn vec3(1.0);\n    }\n    \n    float fadeToWhite = max(0.0, (viewDistance - DISTANCE_NEAR) \/ (DISTANCE_FAR - DISTANCE_NEAR));\n    \n    vec3 coordinate = vec3(acos(starSurfaceLocation.y), atan2(starSurfaceLocation.xz), seed);\n    \n    float progress = pow(texture(iChannel0, fract(0.3 * coordinate.xy + seed * vec2(1.1))).r, 4.0);\n    \n    return mix(mix(vec3(1.0, 0.98, 0.9), vec3(1.0, 0.627, 0.01), progress), vec3(1.0), fadeToWhite);\n}\n\nvec4 blendColors(vec4 front, vec4 back) {\n  \treturn vec4(mix(back.rgb, front.rgb, front.a \/ (front.a + back.a)), front.a + back.a - front.a * back.a);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 movementDirection = normalize(vec3(0.01, 0.0, 1.0));\n    \n    vec3 rayDirection = getRayDirection(fragCoord, movementDirection);\n    vec3 directionSign = sign(rayDirection);\n    vec3 directionBound = vec3(0.5) + 0.5 * directionSign;\n    \n    vec3 globalPosition = vec3(3.14159, 3.14159, 0.0) + (iTime + 1000.0) * FLIGHT_SPEED * movementDirection;\n    ivec3 chunk = ivec3(globalPosition);\n    vec3 localPosition = mod(globalPosition, 1.0);\n    moveInsideBox(localPosition, chunk, directionSign, directionBound);\n    \n    ivec3 startChunk = chunk;\n    vec3 localStart = localPosition;\n    \n    fragColor = vec4(0.0);\n    \n    for (int i = 0; i < 200; i++) {\n        move(localPosition, rayDirection, directionBound);\n        moveInsideBox(localPosition, chunk, directionSign, directionBound);\n        \n        if (hasStar(chunk)) {\n            vec3 starPosition = getStarPosition(chunk, 0.5 * STAR_SIZE);\n\t\t\tfloat currentDistance = getDistance(chunk - startChunk, localStart, starPosition);\n            if (currentDistance > DRAW_DISTANCE && false) {\n                break;\n            }\n            \n            \/\/ This vector points from the center of the star to the closest point on the ray (orthogonal to the ray)\n            vec3 starToRayVector = getStarToRayVector(localPosition, rayDirection, starPosition);\n            \/\/ Distance between ray and star\n            float distanceToStar = length(starToRayVector);\n            distanceToStar *= 2.0;\n            \n            if (distanceToStar < STAR_SIZE) {\n                float starMaxBrightness = clamp((DRAW_DISTANCE - currentDistance) \/ FADEOUT_DISTANCE, 0.001, 1.0);\n            \t\n                float starColorSeed = (float(chunk.x) + 13.0 * float(chunk.y) + 7.0 * float(chunk.z)) * 0.00453;\n                if (distanceToStar < STAR_SIZE * STAR_CORE_SIZE) {\n                    \/\/ This vector points from the center of the star to the point of the star sphere surface that this ray hits\n            \t\tvec3 starSurfaceVector = normalize(starToRayVector + rayDirection * sqrt(pow(STAR_CORE_SIZE * STAR_SIZE, 2.0) - pow(distanceToStar, 2.0)));\n\t\t\t\t\t\n                    fragColor = blendColors(fragColor, vec4(getStarColor(starSurfaceVector, starColorSeed, currentDistance), starMaxBrightness));                    \n                    break;\n                } else {\n                    float localStarDistance = ((distanceToStar \/ STAR_SIZE) - STAR_CORE_SIZE) \/ (1.0 - STAR_CORE_SIZE);\n                    vec4 glowColor = getStarGlowColor(localStarDistance, atan2(starToRayVector.xy), starColorSeed);\n                    glowColor.a *= starMaxBrightness;\n                \tfragColor = blendColors(fragColor, glowColor);\n                }\n            }\n        } else if (hasBlackHole(chunk)) {\n            const vec3 blackHolePosition = vec3(0.5);\n\t\t\tfloat currentDistance = getDistance(chunk - startChunk, localStart, blackHolePosition);\n            float fadeout = min(1.0, (DRAW_DISTANCE - currentDistance) \/ FADEOUT_DISTANCE);\n            \t\n            \/\/ This vector points from the center of the black hole to the closest point on the ray (orthogonal to the ray)\n            vec3 coreToRayVector = getStarToRayVector(localPosition, rayDirection, blackHolePosition);\n            float distanceToCore = length(coreToRayVector);\n            if (distanceToCore < BLACK_HOLE_CORE_RADIUS * 0.5) {\n                fragColor = blendColors(fragColor, vec4(vec3(0.0), fadeout));\n                break;\n            } else if (distanceToCore < 0.5) {\n            \trayDirection = normalize(rayDirection - fadeout * (BLACK_HOLE_DISTORTION \/ distanceToCore - BLACK_HOLE_DISTORTION \/ 0.5) * coreToRayVector \/ distanceToCore);\n            }\n        }\n        \n        if (length(vec3(chunk - startChunk)) > DRAW_DISTANCE) {\n            break;\n        }\n    }\n    \n    if (fragColor.a < 1.0) {\n    \tfragColor = blendColors(fragColor, getNebulaColor(globalPosition, rayDirection));\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/\n\/\/ Description : Array and textureless GLSL 2D\/3D\/4D simplex \n\/\/               noise functions.\n\/\/      Author : Ian McEwan, Ashima Arts.\n\/\/  Maintainer : stegu\n\/\/     Lastmod : 20110822 (ijm)\n\/\/     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n\/\/               Distributed under the MIT License. See LICENSE file.\n\/\/               https:\/\/github.com\/ashima\/webgl-noise\n\/\/               https:\/\/github.com\/stegu\/webgl-noise\n\/\/ \n    vec3 mod289(vec3 x) {\n      return x - floor(x * (1.0 \/ 289.0)) * 289.0;\n    }\n\n    vec4 mod289(vec4 x) {\n      return x - floor(x * (1.0 \/ 289.0)) * 289.0;\n    }\n\n    vec4 permute(vec4 x) {\n         return mod289(((x*34.0)+1.0)*x);\n    }\n\n    vec4 taylorInvSqrt(vec4 r)\n    {\n      return 1.79284291400159 - 0.85373472095314 * r;\n    }\n\n    float snoise(vec3 v)\n      { \n      const vec2  C = vec2(1.0\/6.0, 1.0\/3.0) ;\n      const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    \/\/ First corner\n      vec3 i  = floor(v + dot(v, C.yyy) );\n      vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n    \/\/ Other corners\n      vec3 g = step(x0.yzx, x0.xyz);\n      vec3 l = 1.0 - g;\n      vec3 i1 = min( g.xyz, l.zxy );\n      vec3 i2 = max( g.xyz, l.zxy );\n\n      \/\/   x0 = x0 - 0.0 + 0.0 * C.xxx;\n      \/\/   x1 = x0 - i1  + 1.0 * C.xxx;\n      \/\/   x2 = x0 - i2  + 2.0 * C.xxx;\n      \/\/   x3 = x0 - 1.0 + 3.0 * C.xxx;\n      vec3 x1 = x0 - i1 + C.xxx;\n      vec3 x2 = x0 - i2 + C.yyy; \/\/ 2.0*C.x = 1\/3 = C.y\n      vec3 x3 = x0 - D.yyy;      \/\/ -1.0+3.0*C.x = -0.5 = -D.y\n\n    \/\/ Permutations\n      i = mod289(i); \n      vec4 p = permute( permute( permute( \n                 i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n               + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n               + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    \/\/ Gradients: 7x7 points over a square, mapped onto an octahedron.\n    \/\/ The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n      float n_ = 0.142857142857; \/\/ 1.0\/7.0\n      vec3  ns = n_ * D.wyz - D.xzx;\n\n      vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  \/\/  mod(p,7*7)\n\n      vec4 x_ = floor(j * ns.z);\n      vec4 y_ = floor(j - 7.0 * x_ );    \/\/ mod(j,N)\n\n      vec4 x = x_ *ns.x + ns.yyyy;\n      vec4 y = y_ *ns.x + ns.yyyy;\n      vec4 h = 1.0 - abs(x) - abs(y);\n\n      vec4 b0 = vec4( x.xy, y.xy );\n      vec4 b1 = vec4( x.zw, y.zw );\n\n      \/\/vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n      \/\/vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n      vec4 s0 = floor(b0)*2.0 + 1.0;\n      vec4 s1 = floor(b1)*2.0 + 1.0;\n      vec4 sh = -step(h, vec4(0.0));\n\n      vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n      vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n      vec3 p0 = vec3(a0.xy,h.x);\n      vec3 p1 = vec3(a0.zw,h.y);\n      vec3 p2 = vec3(a1.xy,h.z);\n      vec3 p3 = vec3(a1.zw,h.w);\n\n    \/\/Normalise gradients\n      vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n      p0 *= norm.x;\n      p1 *= norm.y;\n      p2 *= norm.z;\n      p3 *= norm.w;\n\n    \/\/ Mix final noise value\n      vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n      m = m * m;\n      return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                    dot(p2,x2), dot(p3,x3)));\n\t}\n\nfloat tilingNoise(vec2 position, float size) {\n    float value = snoise(vec3(position * size, 0.0));\n    \n    float wrapx = snoise(vec3(position * size - vec2(size, 0.0), 0.0));    \n    value = mix(value, wrapx, max(0.0, position.x * size - (size - 1.0)));\n\n    float wrapy = snoise(vec3(position * size - vec2(0.0, size), 0.0));\n    float wrapxy = snoise(vec3(position * size - vec2(size, size), 0.0)); \n    wrapy = mix(wrapy, wrapxy, max(0.0, position.x * size - (size - 1.0)));\n\treturn mix(value, wrapy, max(0.0, position.y * size - (size - 1.0)));\n}\n\nvoid initialize(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord \/ iResolution.xy;\n    \n    const int octaves = 6;\n    \n    float value = 0.0;\n  \tfloat maxValue = 0.0; \n    for (float octave = 0.0; octave < float(octaves); octave++) {\n    \tvalue += pow(2.0, -octave) * tilingNoise(uv, 8.0 * pow(2.0, octave));\n        maxValue += pow(2.0, -octave);\n    }\n    \n    maxValue *= 0.5;\n    \n    fragColor = vec4(0.5 * (1.0 + value \/ maxValue) * vec3(1.0), 1.0);\n    fragColor.g = iResolution.x;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord \/ iResolution.xy);\n    if (fragColor.g != iResolution.x) {\n    \tinitialize(fragColor, fragCoord);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"4dt3zn","date":"1447773428","viewed":17827,"name":"Raymarched Reflections","username":"Shane","description":"A very basic demonstration of raymarching a distance field with reflections and shadows. Definitely not cutting edge, but hopefully, interesting to anyone who isn't quite familiar with the process.","likes":203,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/*\n\n\tRaymarched Reflections\n\t----------------------\n\n\tA very basic demonstration of raymarching a distance field with reflections \n\tand reasonably passable shadows. Definitely not cutting edge, but hopefully, \n\tinteresting to anyone who isn't quite familiar with the process.\n\n\tReflections are pretty easy: Raymarch to the hit point, then obtain the color \n\tat that point. Continue on from the hit point in the direction of the reflected \n\tray until you reach a new hit point. Obtain the color at the new point, then\n\tadd a portion of it to your original color. Repeat the process.\n\n\tUnfortunately, the extra work can slow things down, especially when you apply\n\tshadows, which is probably why you don't see too many shadowed,\treflected \n\texamples. However, for relatively simple distance fields, it's pretty doable.\n\n\tIt was tempting to do this up, but I figured a simpler example would be more\n\thelpful. Take away the rambling comments, and there isn't a great deal of code.\n\tI'll post a more sophisticated one later.\n\n    \/\/ Reasonably simple examples featuring reflection:\n\n    To the road of ribbon - XT95\n    https:\/\/www.shadertoy.com\/view\/MsfGzr\n\n    704.2 - PauloFalcao\n    https:\/\/www.shadertoy.com\/view\/Xdj3Dt\n\n    \/\/ Reflections and refraction. Really cool.\n    Glass Polyhedron - Nrx\n    https:\/\/www.shadertoy.com\/view\/4slSzj\n\n*\/\n\n#define FAR 30.\n\n\/\/ Distance function: This one is pretty simple. I chose rounded\n\/\/ spherical boxes, because they're cheap and they display the \n\/\/ reflections reasonably well.\nfloat map(vec3 p)\n{\n    \n    \/\/ Positioning the rounded cubes a little off center, in order\n    \/\/ to break up the space a little.\n    \/\/\n    \/\/ \"floor(p)\" represents a unique number (ID) for each cube \n    \/\/ (based on its unique position). Take that number and produce \n    \/\/ a randomized 3D offset, then add it to it's regular position. \n    \/\/ Simple.\n    float n = sin(dot(floor(p), vec3(27, 113, 57)));\n    vec3 rnd = fract(vec3(2097152, 262144, 32768)*n)*.16 - .08;\n    \n    \/\/ Repeat factor. If irregularity isn't your thing, you can get \n    \/\/ rid of \"rnd\" to line things up again.\n    p = fract(p + rnd) - .5;\n    \n    \n    \/\/ Rounded spherical boxes. The following is made up, but kind of\n    \/\/ makes sense. Box, minus a bit of sphericalness, gives you a \n    \/\/ rounded box. By the way, if we're splitting hairs, this is \n    \/\/ technically a bound rather than a distance function, but it \n    \/\/ works roughly the same way.\n    p = abs(p); \n    return max(p.x, max(p.y, p.z)) - 0.25 + dot(p, p)*0.5;\n    \n    \/\/return length(p) - 0.225; \/\/ Just spheres.\n}\n\n\/\/ Standard raymarching routine.\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 0., d;\n    \n    for (int i = 0; i < 96; i++){\n\n        d = map(ro + rd*t);\n        \n        \/\/ Using the hacky \"abs,\" trick, for more accuracy. \n        if(abs(d)<.001 || t>FAR) break;        \n        \n        t += d*.75;  \/\/ Using more accuracy, in the first pass.\n    }\n    \n    return t;\n}\n\n\/\/ Second pass, which is the first, and only, reflected bounce. \n\/\/ Virtually the same as above, but with fewer iterations and less \n\/\/ accuracy.\n\/\/\n\/\/ The reason for a second, virtually identical equation is that \n\/\/ raymarching is usually a pretty expensive exercise, so since the \n\/\/ reflected ray doesn't require as much detail, you can relax things \n\/\/ a bit - in the hope of speeding things up a little.\nfloat traceRef(vec3 ro, vec3 rd){\n    \n    float t = 0., d;\n    \n    for (int i = 0; i < 48; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.002 || t>FAR) break;\n        \n        t += d;\n    }\n    \n    return t;\n}\n\n\n\/\/ Cheap shadows are hard. In fact, I'd almost say, shadowing repeat objects - in a setting like \n\/\/ this - with limited iterations is impossible... However, I'd be very grateful if someone could \n\/\/ prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    \/\/ More would be nicer. More is always nicer, but not really affordable... Not on my slow test \n    \/\/ machine, anyway.\n    const int maxIterationsShad = 24; \n    \n    vec3 rd = lp - ro; \/\/ Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = .002;    \n    float end = max(length(rd), .001);\n    float stepDist = end\/float(maxIterationsShad);\n    \n    rd \/= end;\n\n    \/\/ Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, \n    \/\/ the lowest number to give a decent shadow is the best one to choose. \n    for (int i = 0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        \/\/shade = min(shade, k*h\/dist);\n        shade = min(shade, smoothstep(0., 1., k*h\/dist)); \/\/ Subtle difference. Thanks to IQ for this tidbit.\n        \/\/ So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, .2), \n        \/\/ clamp(h, .02, stepDist*2.), etc.\n        dist += clamp(h, .02, .25);\n        \n        \/\/ Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0. || dist>end) break; \n        \/\/if (h<.001 || dist > end) break; \/\/ If you're prepared to put up with more artifacts.\n    }\n\n    \/\/ I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    \/\/ Really dark shadows look too brutal to me.\n    return min(max(shade, 0.) + .25, 1.); \n}\n\n\n\/\/ Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(.001, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\t\n                          map(p + e.yyx) - map(p - e.yyx)));\n}\n\n\/*\n\/\/ Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 getNormal( in vec3 p ){\n\n    \/\/ Note the slightly increased sampling distance, to alleviate\n    \/\/ artifacts due to hit point inaccuracies.\n    vec2 e = vec2(.0015, -.0015); \n    return normalize(\n        e.xyy * map(p + e.xyy) + \n        e.yyx * map(p + e.yyx) + \n        e.yxy * map(p + e.yxy) + \n        e.xxx * map(p + e.xxx));\n}\n*\/\n\n\/\/ Alternating the objects' colors in a 3D checkered arrangement.\n\/\/ You could just return a single color, if you wanted, but I\n\/\/ thought I'd mix things up a bit.\n\/\/\n\/\/ Color scheme mildly influenced by: Sound Experiment 3 - aiekick\n\/\/ https:\/\/www.shadertoy.com\/view\/Ml2XWt\nvec3 getObjectColor(vec3 p){\n    \n    \n    \/\/ \"floor(p)\" is analogous to a unique ID - based on position.\n    vec3 ip = floor(p);\n    \n    \/\/ Unique random cell number.\n    float rnd = fract(sin(dot(ip, vec3(27.17, 112.61, 57.53)))*43758.5453);\n    \n    \/\/ Color up the objects in a cubic checkered arrangement using a subtle version\n    \/\/ of IQ's palette formula.\n    vec3 col = (fract(dot(ip, vec3(.5))) > .001)? \n         .5 + .45*cos(mix(3., 4., rnd) + vec3(.9, .45, 1.5)) \/\/vec3(.6, .3, 1.)\n         : vec3(.7 + .3*rnd);\n    \n    \/\/ Reverse the RGB channels on some of the objects, for a bit of variance.\n    if(fract(rnd*1183.5437 + .42)>.65) col = col.zyx;\n    \n    return col;\n    \n}\n\n\/\/ Using the hit point, unit direction ray, etc, to color the \n\/\/ scene. Diffuse, specular, falloff, etc. It's all pretty \n\/\/ standard stuff.\nvec3 doColor(in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, float t){\n    \n    vec3 ld = lp - sp; \/\/ Light direction vector.\n    float lDist = max(length(ld), .001); \/\/ Light to surface distance.\n    ld \/= lDist; \/\/ Normalizing the light vector.\n    \n    \/\/ Attenuating the light, based on distance.\n    float atten = 1. \/ (1. + lDist*.2 + lDist*lDist*.1);\n    \n    \/\/ Standard diffuse term.\n    float diff = max(dot(sn, ld), 0.);\n    \/\/ Standard specualr term.\n    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.), 8.);\n    \n    \/\/ Coloring the object. You could set it to a single color, to\n    \/\/ make things simpler, if you wanted.\n    vec3 objCol = getObjectColor(sp);\n    \n    \/\/ Combining the above terms to produce the final scene color.\n    vec3 sceneCol = (objCol*(diff + .15) + vec3(1., .6, .2)*spec*2.)*atten;\n    \n    \n    \/\/ Fog factor -- based on the distance from the camera.\n    float fogF = smoothstep(0., .95, t\/FAR);\n    \/\/\n    \/\/ Applying the background fog. Just black, in this case, but you could\n    \/\/ render sky, etc, as well.\n    sceneCol = mix(sceneCol, vec3(0), fogF); \n\n    \n    \/\/ Return the color. Performed once every pass... of which there are\n    \/\/ only two in this particular instance.\n    return sceneCol;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \/\/ Screen coordinates.\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) \/ iResolution.y;\n    \n    \/\/ Unit direction ray.\n    vec3 rd = normalize(vec3(uv, 1));\n    \n\n    \/\/ Some cheap camera movement, for a bit of a look around. I use this far\n    \/\/ too often. I'm even beginning to bore myself at this point. :)\n    float cs = cos(iTime * .25), si = sin(iTime * .25);\n    rd.xy = mat2(cs, si, -si, cs)*rd.xy;\n    rd.xz = mat2(cs, si, -si, cs)*rd.xz;\n    \n    \/\/ Ray origin: Doubling as the surface position, in this particular example.\n    \/\/ I hope that doesn't confuse anyone.\n    vec3 ro = vec3(0, 0, iTime*1.5);\n    \n    \/\/ Light position. Set in the vicinity the ray origin.\n    vec3 lp = ro + vec3(0, 1, -.5);\n    \n    \n    \/\/ FIRST PASS.\n    \n    float t = trace(ro, rd);\n    \n   \n    \n    \/\/ Advancing the ray origin, \"ro,\" to the new hit point.\n    ro += rd*t;\n    \n    \/\/ Retrieving the normal at the hit point.\n    vec3 sn = getNormal(ro);\n    \n    \/\/ Retrieving the color at the hit point, which is now \"ro.\" I agree, reusing \n    \/\/ the ray origin to describe the surface hit point is kind of confusing. The reason \n    \/\/ we do it is because the reflective ray will begin from the hit point in the \n    \/\/ direction of the reflected ray. Thus the new ray origin will be the hit point. \n    \/\/ See \"traceRef\" below.\n    vec3 sceneColor = doColor(ro, rd, sn, lp, t);\n    \n    \/\/ Checking to see if the surface is in shadow. Ideally, you'd also check to\n    \/\/ see if the reflected surface is in shadow. However, shadows are expensive, so\n    \/\/ it's only performed on the first pass. If you pause and check the reflections,\n    \/\/ you'll see that they're not shadowed. OMG! Better call the shadow police. :)\n    float sh = softShadow(ro +  sn*.0015, lp, 16.);\n    \n    \n    \/\/ SECOND PASS - REFLECTED RAY\n    \n    \/\/ Standard reflected ray, which is just a reflection of the unit\n    \/\/ direction ray off of the intersected surface. You use the normal\n    \/\/ at the surface point to do that. Hopefully, it's common sense.\n    rd = reflect(rd, sn);\n    \n    \n    \/\/ The reflected pass begins where the first ray ended, which is the suface\n    \/\/ hit point, or in a few cases, beyond the far plane. By the way, for the sake\n    \/\/ of simplicity, we'll perform a reflective pass for non hit points too. Kind\n    \/\/ of wasteful, but not really noticeable. The direction of the new ray will\n    \/\/ obviously be in the direction of the reflected ray. See just above.\n    \/\/\n    \/\/ To anyone who's new to this, don't forgot to nudge the ray off of the \n    \/\/ initial surface point. Otherwise, you'll intersect with the surface\n    \/\/ you've just hit. After years of doing this, I still forget on occasion.\n    t = traceRef(ro +  sn*.003, rd);\n    \n    \/\/ Advancing the ray origin, \"ro,\" to the new reflected hit point.\n    ro += rd*t;\n    \n    \/\/ Retrieving the normal at the reflected hit point.\n    sn = getNormal(ro);\n    \n    \/\/ Coloring the reflected hit point, then adding a portion of it to the final scene color.\n    \/\/ How much you add, and how you apply it is up to you, but I'm simply adding 35 percent.\n    sceneColor += doColor(ro, rd, sn, lp, t)*.35;\n    \/\/ Other combinations... depending what you're trying to achieve.\n    \/\/sceneColor = sceneColor*.7 + doColor(ro, rd, sn, lp, t)*.5;\n    \n    \n    \/\/ APPLYING SHADOWS\n    \/\/\n    \/\/ Multiply the shadow from the first pass by the final scene color. Ideally, you'd check to\n    \/\/ see if the reflected point was in shadow, and incorporate that too, but we're cheating to\n    \/\/ save cycles and skipping it. It's not really noticeable anyway. By the way, ambient\n    \/\/ occlusion would make it a little nicer, but we're saving cycles and keeping things simple.\n    sceneColor *= sh;\n    \n    \n   \n\n    \/\/ Clamping the scene color, performing some rough gamma correction (the \"sqrt\" bit), then \n    \/\/ presenting it to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneColor, 0., 1.)), 1);\n}","name":"Image","description":"","type":"image"}]}];    var gUseScreenshots = piIsMobile();
    var gThemeName = "classic";



    </script>
</head>

<!-- <body onload="resultsInit(12,null,null)"> -->
<body onload="resultsInitStatic(12,null,null)">

<!-- header =================================================================================== -->


<div id="header">

    <div id="headerBlock1">
        <a href="/" id="headerTitle">Shadertoy</a>
        <form name="formSearch" action="/results" method="get" style="display:inline-block;">
        <div  id="headerSearch">
            <input type="search" id="mySearch" name="query" placeholder="Search..." value=""/>
        </div>
        </form>
    </div>

    <div id="headerBlock2">
            <a class="headerLinks" href="/browse">Browse</a>
        <a class="headerLinks" href="/new">New</a>
        <a class="headerLinks" href="/signin">Sign In</a>
        </div>
</div>
<!-- content ================================================================================== -->

<div id="content">

  <div id="controls">
    <div>
      <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
      Sort:      </div>
      <div class="controlOptions"><div class="pageButtonsCurrent" href="/results?query=&sort=popular&filter=">Popular</div><a class="pageButtons" href="/results?query=&sort=newest&filter=">Newest</a><a class="pageButtons" href="/results?query=&sort=love&filter=">Love</a><a class="pageButtons" href="/results?query=&sort=hot&filter=">Hot</a></div>
    </div>

    <div id="controlFilter">
      <div style="display:flex;margin-right:8px;align-items:center;">Filter:</div>
      <div class="controlOptions"> <a class="pageButtons" href="/results?query=&sort=popular&filter=multipass">Multipass</a><a class="pageButtons" href="/results?query=&sort=popular&filter=soundoutput">GPU Sound</a><a class="pageButtons" href="/results?query=&sort=popular&filter=vr">VR</a><a class="pageButtons" href="/results?query=&sort=popular&filter=soundinput">Microphone</a><a class="pageButtons" href="/results?query=&sort=popular&filter=musicstream">Soundcloud</a><a class="pageButtons" href="/results?query=&sort=popular&filter=webcam">Webcam</a></div>
    </div>

    <div>
        <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
        View:</div>
        <div><a class="pageButtons" href="/slideshow?query=&sort=popular">Slideshow</a></div>
    </div>

    <div class="navigation" id="navTop" ><span style="padding-right:8px;">Results (74098):</span><div class="controlOptions"><a id="pageButtonFirst" class="pageButtons" href="results?query=&sort=popular&from=0&num=12">1</a><span>...</span><a id="pageButton"0 class="pageButtons" href="results?query=&sort=popular&from=312&num=12">27</a><a id="pageButton"1 class="pageButtons" href="results?query=&sort=popular&from=324&num=12">28</a><div id="pageButton"2 class="pageButtonsCurrent" href="results?query=&sort=popular&from=336&num=12">29</div><a id="pageButton"3 class="pageButtons" href="results?query=&sort=popular&from=348&num=12">30</a><a id="pageButton"4 class="pageButtons" href="results?query=&sort=popular&from=360&num=12">31</a><span>...</span><a id="pageButtonLast" class="pageButtons" href="results?query=&sort=popular&from=74088&num=12">6175</a></div>
</div>
  </div>


  <div id="shaderGrid">
    <div class='searchResult'><div class='searchResultContainer' id='Preview_0_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_0_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_0_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_0_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_0_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_0_Thumnail'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_0_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_0_Info'>  <span class='previewText'  id='Preview_0_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_0_TextUser'></span>  <span class='previewStats' id='Preview_0_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_1_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_1_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_1_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_1_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_1_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_1_Thumnail'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_1_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_1_Info'>  <span class='previewText'  id='Preview_1_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_1_TextUser'></span>  <span class='previewStats' id='Preview_1_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_2_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_2_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_2_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_2_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_2_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_2_Thumnail'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_2_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_2_Info'>  <span class='previewText'  id='Preview_2_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_2_TextUser'></span>  <span class='previewStats' id='Preview_2_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_3_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_3_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_3_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_3_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_3_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_3_Thumnail'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_3_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_3_Info'>  <span class='previewText'  id='Preview_3_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_3_TextUser'></span>  <span class='previewStats' id='Preview_3_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_4_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_4_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_4_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_4_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_4_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_4_Thumnail'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_4_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_4_Info'>  <span class='previewText'  id='Preview_4_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_4_TextUser'></span>  <span class='previewStats' id='Preview_4_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_5_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_5_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_5_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_5_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_5_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_5_Thumnail'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_5_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_5_Info'>  <span class='previewText'  id='Preview_5_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_5_TextUser'></span>  <span class='previewStats' id='Preview_5_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_6_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_6_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_6_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_6_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_6_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_6_Thumnail'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_6_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_6_Info'>  <span class='previewText'  id='Preview_6_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_6_TextUser'></span>  <span class='previewStats' id='Preview_6_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_7_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_7_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_7_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_7_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_7_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_7_Thumnail'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_7_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_7_Info'>  <span class='previewText'  id='Preview_7_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_7_TextUser'></span>  <span class='previewStats' id='Preview_7_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_8_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_8_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_8_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_8_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_8_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_8_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_8_Thumnail'>        <img class='previewThumbnailImage' id='Preview_8_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_8_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_8_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_8_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_8_Info'>  <span class='previewText'  id='Preview_8_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_8_TextUser'></span>  <span class='previewStats' id='Preview_8_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_9_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_9_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_9_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_9_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_9_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_9_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_9_Thumnail'>        <img class='previewThumbnailImage' id='Preview_9_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_9_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_9_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_9_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_9_Info'>  <span class='previewText'  id='Preview_9_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_9_TextUser'></span>  <span class='previewStats' id='Preview_9_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_10_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_10_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_10_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_10_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_10_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_10_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_10_Thumnail'>        <img class='previewThumbnailImage' id='Preview_10_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_10_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_10_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_10_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_10_Info'>  <span class='previewText'  id='Preview_10_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_10_TextUser'></span>  <span class='previewStats' id='Preview_10_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_11_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_11_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_11_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_11_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_11_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_11_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_11_Thumnail'>        <img class='previewThumbnailImage' id='Preview_11_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_11_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_11_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_11_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_11_Info'>  <span class='previewText'  id='Preview_11_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_11_TextUser'></span>  <span class='previewStats' id='Preview_11_Stats'></span></div></div>  </div>
  <br>
  <div class="navigation" id="navBottom" ><span style="padding-right:8px;">Results (74098):</span><div class="controlOptions"><a id="pageButtonFirst" class="pageButtons" href="results?query=&sort=popular&from=0&num=12">1</a><span>...</span><a id="pageButton"0 class="pageButtons" href="results?query=&sort=popular&from=312&num=12">27</a><a id="pageButton"1 class="pageButtons" href="results?query=&sort=popular&from=324&num=12">28</a><div id="pageButton"2 class="pageButtonsCurrent" href="results?query=&sort=popular&from=336&num=12">29</div><a id="pageButton"3 class="pageButtons" href="results?query=&sort=popular&from=348&num=12">30</a><a id="pageButton"4 class="pageButtons" href="results?query=&sort=popular&from=360&num=12">31</a><span>...</span><a id="pageButtonLast" class="pageButtons" href="results?query=&sort=popular&from=74088&num=12">6175</a></div>
</div>  <br>      
</div>

<!-- footer ================================================================================== -->

<div id="footer">
    
    <div><span style="color:#ffffff;">Community Forums</span>
      <ul>
      <li><a class="regular" href="/events">Official Events</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/147749602472741">In Facebook (english)</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/1339783682699494">In Facebook (korean)</a></li>
      <li><a class="regular" href="https://discord.gg/XtmMN6E">In Discord</a> (<a class="regular" href="https://discordapp.com/channels/578696555612209173/579531723348639754">direct link</a>)</li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Feedback and Support</span>
      <ul>
      <li><a class="regular" href="https://www.facebook.com/Shadertoy">Facebook</a></li>
      <li><a class="regular" href="https://twitter.com/shadertoy">Twitter</a></li>
      <li><a class="regular" href="https://www.patreon.com/shadertoy">Patreon</a></li>
      <li><a class="regular" href="https://trello.com/b/5hM0CjId">Roadmap</a></li>

      
      </ul>
    </div>

    <div><span style="color:#ffffff;">Shadertoy</span>
      <ul>
      <li><a class="regular" href="/store">Store</a></li>
      <li><a class="regular" href="/howto">Documentation</a></li>
      <li><a class="regular" href="/terms">Terms & Privacy</a></li>
      <li><a class="regular" href="/about">About</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Apps and Plugins</span>
      <ul>
      <li><a class="regular" href="https://itunes.apple.com/us/app/shadertoy/id717961814">Official iPhone App</a> by <a class="user" href="/user/reinder">Reinder</a></li>
      <li><a class="regular" href="https://steamcommunity.com/sharedfiles/filedetails/?id=1726697188">Screensaver</a> by <a class="user" href="/user/kosro">Kosro</a></li>
      <li><a class="regular" href="https://chrome.google.com/webstore/detail/shadertoy-unofficial-plug/ohicbclhdmkhoabobgppffepcopomhgl">Shadertoy plugin</a> by <a class="user" href="/user/patu">Patu</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Tutorials</span>
      <ul>
      <li><a class="regular" href="https://www.youtube.com/watch?v=0ifChJ0nJfM">Shader coding intro</a> by <a class="user" href="/user/iq">iq</a></li>
      <li><a class="regular" href="https://shadertoyunofficial.wordpress.com/">Shadertoy Unofficial</a> by <a class="user" href="/user/FabriceNeyret2">FabriceNeyret2</a></li>
      </ul>
    </div>

</div>

<div id="compliance" style="padding-bottom:6px;visibility:hidden;left:0;top:0px;width:100%;background-color:rgb(200,120,20,0.93);position:absolute;color:#FFFFFF">
    <div style="text-align: center; margin-top:8px">
        We use cookies to give you the best experience on our website. If you continue using Shadertoy, we'll assume that you are happy to receive all cookies on this website. 
        For more information, please review our <a class="regular" href="/terms">Terms & Privacy</a>.
    </div> 
    <div style="text-align: center;margin-top:6px">
        <button type="button" style="width:100px;font-size:inherit" onclick="acceptCompliance()">Accept</button>
    </div>
</div>

<script>
(function runCompliance() 
{
    let showCompliance = 1;
    let allcookies = document.cookie;
    let cookiearray = allcookies.split(';');
    for (var i=0; i<cookiearray.length; i++)
    {
        let name  = cookiearray[i].split('=')[0];
        let value = cookiearray[i].split('=')[1];
        if (name.trim() == "scmp") 
        {
            showCompliance = value;
            break;
        }
    }

    if (showCompliance === 1) 
    {
        var ve = document.getElementById("compliance");
        ve.style.visibility="visible";
    }
})();

function acceptCompliance()
{
    let now = new Date();
    now.setTime( now.getTime() + (5*365*24*60*60*1000) );
    document.cookie="scmp=0;expires=" + now.toUTCString() + ";";

    var ve = document.getElementById("compliance");
    ve.style.visibility="hidden";
}
</script>

</body>
</html>
